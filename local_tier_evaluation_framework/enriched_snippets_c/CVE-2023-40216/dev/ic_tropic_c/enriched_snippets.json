[
  {
    "function_name": "tr_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1740-1748",
    "snippet": "void\ntr_timeout(arg)\nvoid\t*arg;\n{\n\tstruct tr_softc *sc = arg;\n\n\tprintf(\"Token Ring timeout\\n\");\n\twakeup(&sc->tr_sleepevent);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_timeout",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->tr_sleepevent"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Token Ring timeout\\n\""
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_timeout;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid\ntr_timeout(arg)\nvoid\t*arg;\n{\n\tstruct tr_softc *sc = arg;\n\n\tprintf(\"Token Ring timeout\\n\");\n\twakeup(&sc->tr_sleepevent);\n}"
  },
  {
    "function_name": "tr_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1725-1735",
    "snippet": "void\ntr_watchdog(ifp)\nstruct ifnet\t*ifp;\n{\n\tstruct tr_softc\t*sc = ifp->if_softc;\n\n\tlog(LOG_ERR,\"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++ifp->if_oerrors;\n\n\ttr_reset(sc);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_watchdog",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tr_reset",
          "args": [
            "sc"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "tr_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "504-565",
          "snippet": "int\ntr_reset(sc)\nstruct tr_softc *sc;\n{\n\tint i;\n\n\tsc->sc_srb = 0;\n\n\t/* \n\t * Reset the card.\n\t */\n\t/* latch on an unconditional adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RESET, 0);\n\tdelay(50000); /* delay 50ms */\n\t/*\n\t * XXX set paging if we have the right type of card\n\t */\n\t/* turn off adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RELEASE, 0);\n\n\t/* Enable interrupts. */\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\n\t/* Wait for an answer from the adapter. */\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\n\tif (i == 35000 && sc->sc_srb == 0) {\n\t\tprintf(\"No response from adapter after reset\\n\");\n\t\treturn 1;\n\t}\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tACA_OUTB(sc, ACA_RRR_e, (sc->sc_maddr >> 12));\n\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\tif (SRB_INB(sc, sc->sc_srb, SRB_CMD) != 0x80) {\n\t\tprintf(\"Initialization incomplete, status: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_CMD));\n\t\treturn 1;\n\t}\n\tif (SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC) != 0) {\n\t\tprintf(\"Bring Up Code %02x\\n\",\n\t\t    SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC));\n\t\treturn 1;\n\t}\n\n\tsc->sc_init_status = SRB_INB(sc, sc->sc_srb, SRB_INIT_STATUS);\n\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0;\n\n\t/* XXX should depend on sc_resvdmem. */\n\tif (MM_INB(sc, TR_RAM_OFFSET) == 0xB && sc->sc_memsize == 65536)\n\t\tfor (i = 0; i < 512; i++)\n\t\t\tSR_OUTB(sc, 0xfe00 + i, 0);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_reset(sc)\nstruct tr_softc *sc;\n{\n\tint i;\n\n\tsc->sc_srb = 0;\n\n\t/* \n\t * Reset the card.\n\t */\n\t/* latch on an unconditional adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RESET, 0);\n\tdelay(50000); /* delay 50ms */\n\t/*\n\t * XXX set paging if we have the right type of card\n\t */\n\t/* turn off adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RELEASE, 0);\n\n\t/* Enable interrupts. */\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\n\t/* Wait for an answer from the adapter. */\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\n\tif (i == 35000 && sc->sc_srb == 0) {\n\t\tprintf(\"No response from adapter after reset\\n\");\n\t\treturn 1;\n\t}\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tACA_OUTB(sc, ACA_RRR_e, (sc->sc_maddr >> 12));\n\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\tif (SRB_INB(sc, sc->sc_srb, SRB_CMD) != 0x80) {\n\t\tprintf(\"Initialization incomplete, status: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_CMD));\n\t\treturn 1;\n\t}\n\tif (SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC) != 0) {\n\t\tprintf(\"Bring Up Code %02x\\n\",\n\t\t    SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC));\n\t\treturn 1;\n\t}\n\n\tsc->sc_init_status = SRB_INB(sc, sc->sc_srb, SRB_INIT_STATUS);\n\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0;\n\n\t/* XXX should depend on sc_resvdmem. */\n\tif (MM_INB(sc, TR_RAM_OFFSET) == 0xB && sc->sc_memsize == 65536)\n\t\tfor (i = 0; i < 512; i++)\n\t\t\tSR_OUTB(sc, 0xfe00 + i, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_watchdog;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_watchdog(ifp)\nstruct ifnet\t*ifp;\n{\n\tstruct tr_softc\t*sc = ifp->if_softc;\n\n\tlog(LOG_ERR,\"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++ifp->if_oerrors;\n\n\ttr_reset(sc);\n}"
  },
  {
    "function_name": "tr_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1717-1723",
    "snippet": "void\ntr_sleep(sc)\nstruct tr_softc *sc;\n{\n\ttimeout(tr_timeout, sc, hz*30);\n\tsleep(&sc->tr_sleepevent, 1);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_timeout",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "&sc->tr_sleepevent",
            "1"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "tr_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1717-1723",
          "snippet": "void\ntr_sleep(sc)\nstruct tr_softc *sc;\n{\n\ttimeout(tr_timeout, sc, hz*30);\n\tsleep(&sc->tr_sleepevent, 1);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "tr_timeout",
            "sc",
            "hz*30"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "tr_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1740-1748",
          "snippet": "void\ntr_timeout(arg)\nvoid\t*arg;\n{\n\tstruct tr_softc *sc = arg;\n\n\tprintf(\"Token Ring timeout\\n\");\n\twakeup(&sc->tr_sleepevent);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_timeout",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_timeout;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid\ntr_timeout(arg)\nvoid\t*arg;\n{\n\tstruct tr_softc *sc = arg;\n\n\tprintf(\"Token Ring timeout\\n\");\n\twakeup(&sc->tr_sleepevent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_timeout;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid\ntr_sleep(sc)\nstruct tr_softc *sc;\n{\n\ttimeout(tr_timeout, sc, hz*30);\n\tsleep(&sc->tr_sleepevent, 1);\n}"
  },
  {
    "function_name": "tr_opensap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1668-1712",
    "snippet": "void\ntr_opensap(sc, type) \nstruct tr_softc *sc;\nu_char type;\n{\n\tbus_size_t srb = sc->sc_srb;\n\n/************************************************************************\n ** To use the SAP level interface, we will have to execute a          ** \n ** DLC.OPEN.SAP (pg.6-61 of the Token Ring Tech. Ref.) after we have  **\n ** received a good return code from the DIR.OPEN.ADAPTER command.     **\n ** We will open the IP SAP x'aa'.                                     **\n **                                                                    **\n ** STEPS:                                                             **\n **      1) Reset SRB response interrupt bit                           **\n **      2) Use the open_sap srb.                                      **\n **      3) Fill the following fields:                                 **\n **            command    - x'15'                                      **\n **            sap_value  - x'aa'                                      **\n **            sap_options- x'24'                                      **\n **                                                                    **\n ***********************************************************************/\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tSRB_OUTB(sc, srb, SRB_CMD, DLC_OPEN_SAP);  \n\tSRB_OUTB(sc, srb, SRB_RETCODE, 0x00);  \n\tSRB_OUTW(sc, srb, SRB_OPNSAP_STATIONID, 0x0000);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERT1, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERT2, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERTI, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXOUT, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXIN, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXOUTINCR, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXRETRY, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_GSAPMAXMEMB, 0x00);\n\tSRB_OUTW(sc, srb, SRB_OPNSAP_MAXIFIELD, 0x0088);  \n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPVALUE, type);     \n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPOPTIONS, 0x24);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_STATIONCNT, 0x01);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPGSAPMEMB, 0x00);\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_opensap",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "CMD_IN_SRB"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRP_e",
            "INT_ENABLE"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_SAPGSAPMEMB",
            "0x00"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_STATIONCNT",
            "0x01"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_SAPOPTIONS",
            "0x24"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_SAPVALUE",
            "type"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTW",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_MAXIFIELD",
            "0x0088"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_GSAPMAXMEMB",
            "0x00"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_MAXRETRY",
            "0x00"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_MAXOUTINCR",
            "0x00"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_MAXIN",
            "0x00"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_MAXOUT",
            "0x00"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_TIMERTI",
            "0x00"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_TIMERT2",
            "0x00"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_TIMERT1",
            "0x00"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTW",
          "args": [
            "sc",
            "srb",
            "SRB_OPNSAP_STATIONID",
            "0x0000"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_RETCODE",
            "0x00"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_CMD",
            "DLC_OPEN_SAP"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RSTB",
          "args": [
            "sc",
            "ACA_ISRP_o",
            "~(SRB_RESP_INT)"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_opensap;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid\ntr_opensap(sc, type) \nstruct tr_softc *sc;\nu_char type;\n{\n\tbus_size_t srb = sc->sc_srb;\n\n/************************************************************************\n ** To use the SAP level interface, we will have to execute a          ** \n ** DLC.OPEN.SAP (pg.6-61 of the Token Ring Tech. Ref.) after we have  **\n ** received a good return code from the DIR.OPEN.ADAPTER command.     **\n ** We will open the IP SAP x'aa'.                                     **\n **                                                                    **\n ** STEPS:                                                             **\n **      1) Reset SRB response interrupt bit                           **\n **      2) Use the open_sap srb.                                      **\n **      3) Fill the following fields:                                 **\n **            command    - x'15'                                      **\n **            sap_value  - x'aa'                                      **\n **            sap_options- x'24'                                      **\n **                                                                    **\n ***********************************************************************/\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tSRB_OUTB(sc, srb, SRB_CMD, DLC_OPEN_SAP);  \n\tSRB_OUTB(sc, srb, SRB_RETCODE, 0x00);  \n\tSRB_OUTW(sc, srb, SRB_OPNSAP_STATIONID, 0x0000);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERT1, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERT2, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERTI, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXOUT, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXIN, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXOUTINCR, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXRETRY, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_GSAPMAXMEMB, 0x00);\n\tSRB_OUTW(sc, srb, SRB_OPNSAP_MAXIFIELD, 0x0088);  \n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPVALUE, type);     \n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPOPTIONS, 0x24);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_STATIONCNT, 0x01);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPGSAPMEMB, 0x00);\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n}"
  },
  {
    "function_name": "tr_bcopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1618-1663",
    "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_bcopy",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_sramh",
            "rbc->rbuf_datap",
            "dest",
            "(bus_size_t)len"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tr_bcopy: residual data not copied\\n\""
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_INW",
          "args": [
            "sc",
            "rbc->rbufp",
            "RB_BUFLEN"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_INW",
          "args": [
            "sc",
            "rbc->rbufp",
            "RB_NEXTBUF"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_sramh",
            "rbc->rbuf_datap",
            "dest",
            "(bus_size_t)rbc->data_len"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
  },
  {
    "function_name": "tr_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1536-1611",
    "snippet": "int\ntr_ioctl(ifp, cmd, data)\nstruct ifnet *ifp;\nu_long cmd;\ncaddr_t data;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *) data;\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint s;\n\tint error = 0;\n\n\ts = splnet();\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t/* XXX if not running  */\n\t\t\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t\ttr_init(sc);   /* before arp_ifinit */\n\t\t\t\ttr_sleep(sc);\n\t\t\t}\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif INET\n\t\tdefault:\n\t\t\t/* XXX if not running */\n\t\t\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t\ttr_init(sc);   /* before arpwhohas */\n\t\t\t\ttr_sleep(sc);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\t/*\n\t\t * 1- If the adapter is DOWN , turn the device off\n\t\t *       ie. adapter down but still running\n\t\t * 2- If the adapter is UP, turn the device on\n\t\t *       ie. adapter up but not running yet\n\t\t */\n\t\tif ((ifp->if_flags & (IFF_RUNNING | IFF_UP)) == IFF_RUNNING) {\n\t\t\ttr_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t}\n\t\telse if ((ifp->if_flags & (IFF_RUNNING | IFF_UP)) == IFF_UP) {\n\t\t\ttr_init(sc);\n\t\t\ttr_sleep(sc);\n\t\t}\n\t\telse {\n/*\n * XXX handle other flag changes\n */\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n#ifdef SIOCSIFMTU\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > sc->sc_maxmtu)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tifr_mtu\tifr_metric"
    ],
    "globals_used": [
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->sc_media",
            "cmd"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_sleep",
          "args": [
            "sc"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "tr_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1717-1723",
          "snippet": "void\ntr_sleep(sc)\nstruct tr_softc *sc;\n{\n\ttimeout(tr_timeout, sc, hz*30);\n\tsleep(&sc->tr_sleepevent, 1);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_timeout",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_timeout;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid\ntr_sleep(sc)\nstruct tr_softc *sc;\n{\n\ttimeout(tr_timeout, sc, hz*30);\n\tsleep(&sc->tr_sleepevent, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_init",
          "args": [
            "sc"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "tr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "617-697",
          "snippet": "void\ntr_init(arg)\n\tvoid *arg;\n{\n\tstruct tr_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_size_t open_srb;\n\tint s, num_dhb;\n\tint\tresvdmem, availmem, dhbsize;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0; /* XXX tr_reset() */\n\n\topen_srb = sc->sc_srb;\n\n\t/* Zero SRB. */\n\tbus_space_set_region_1(sc->sc_memt, sc->sc_sramh,\n\t    open_srb, 0, SRB_OPEN_CMDSIZE);\n\n\t/* Open command. */\n\tSRB_OUTB(sc, open_srb, SRB_CMD, DIR_OPEN_ADAPTER);\n/*\n * XXX handle IFM_TOK_ETR !!!!\n */\n\t/* Set open parameters in SRB. */\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_OPTIONS, OPEN_PASS_BCON_MAC);\n\n\tnum_dhb = 1;\n\n\tif ((sc->sc_init_status & FAST_PATH_TRANSMIT) == 0) {\n\t\tavailmem = sc->sc_memsize;\n\t\tresvdmem = RESVDMEM_SIZE + sc->sc_memreserved;\n\n\t\t/* allow MAX of two SAPS */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSAP, 2);\n\t\tresvdmem += 2 * SAPCB_SIZE;\n\n\t\t/* allow MAX of 4 stations */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSTA, 4);\n\t\tresvdmem += 4 * LSCB_SIZE;\n\n\t\tif (sc->sc_init_status & RSP_16) {\n\t\t\tdhbsize = sc->sc_dhb16maxsz;\n\t\t}\n\t\telse {\n\t\t\tdhbsize = sc->sc_dhb4maxsz;\n\t\t}\n#if 0\t/* XXXchb unneeded? */\n\t\tif (dhbsize > 2048)\n\t\t\tnum_dhb = 2;\n#endif\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, dhbsize);\n\t\tsc->sc_nbuf = (dhbsize + 511) / 512;\n\t\t/*\n\t\t * Try to leave room for two fullsized packets when\n\t\t * requesting DHBs.\n\t\t */\n\t\tavailmem -= resvdmem;\n\t\tnum_dhb = (availmem / dhbsize) - 2;\n\t\tif (num_dhb > 2)\n\t\t\tnum_dhb = 2;\t/* firmware can't cope with more DHBs */\n\t\tif (num_dhb < 1)\n\t\t\tnum_dhb = 1;\t/* we need at least one */\n\t}\n\telse\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, DHB_LENGTH);\n\n\tSRB_OUTB(sc, open_srb, SRB_OPEN_NUMDHB, num_dhb);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_RCVBUFLEN, RCV_BUF_LEN);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_NUMRCVBUF, sc->sc_nbuf);\n\n\t/* Tell adapter: command in SRB. */\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
            "struct ifnet *ifp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_init(arg)\n\tvoid *arg;\n{\n\tstruct tr_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_size_t open_srb;\n\tint s, num_dhb;\n\tint\tresvdmem, availmem, dhbsize;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0; /* XXX tr_reset() */\n\n\topen_srb = sc->sc_srb;\n\n\t/* Zero SRB. */\n\tbus_space_set_region_1(sc->sc_memt, sc->sc_sramh,\n\t    open_srb, 0, SRB_OPEN_CMDSIZE);\n\n\t/* Open command. */\n\tSRB_OUTB(sc, open_srb, SRB_CMD, DIR_OPEN_ADAPTER);\n/*\n * XXX handle IFM_TOK_ETR !!!!\n */\n\t/* Set open parameters in SRB. */\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_OPTIONS, OPEN_PASS_BCON_MAC);\n\n\tnum_dhb = 1;\n\n\tif ((sc->sc_init_status & FAST_PATH_TRANSMIT) == 0) {\n\t\tavailmem = sc->sc_memsize;\n\t\tresvdmem = RESVDMEM_SIZE + sc->sc_memreserved;\n\n\t\t/* allow MAX of two SAPS */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSAP, 2);\n\t\tresvdmem += 2 * SAPCB_SIZE;\n\n\t\t/* allow MAX of 4 stations */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSTA, 4);\n\t\tresvdmem += 4 * LSCB_SIZE;\n\n\t\tif (sc->sc_init_status & RSP_16) {\n\t\t\tdhbsize = sc->sc_dhb16maxsz;\n\t\t}\n\t\telse {\n\t\t\tdhbsize = sc->sc_dhb4maxsz;\n\t\t}\n#if 0\t/* XXXchb unneeded? */\n\t\tif (dhbsize > 2048)\n\t\t\tnum_dhb = 2;\n#endif\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, dhbsize);\n\t\tsc->sc_nbuf = (dhbsize + 511) / 512;\n\t\t/*\n\t\t * Try to leave room for two fullsized packets when\n\t\t * requesting DHBs.\n\t\t */\n\t\tavailmem -= resvdmem;\n\t\tnum_dhb = (availmem / dhbsize) - 2;\n\t\tif (num_dhb > 2)\n\t\t\tnum_dhb = 2;\t/* firmware can't cope with more DHBs */\n\t\tif (num_dhb < 1)\n\t\t\tnum_dhb = 1;\t/* we need at least one */\n\t}\n\telse\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, DHB_LENGTH);\n\n\tSRB_OUTB(sc, open_srb, SRB_OPEN_NUMDHB, num_dhb);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_RCVBUFLEN, RCV_BUF_LEN);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_NUMRCVBUF, sc->sc_nbuf);\n\n\t/* Tell adapter: command in SRB. */\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_stop",
          "args": [
            "sc"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "tr_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "570-591",
          "snippet": "void\ntr_stop(sc)\nstruct tr_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0) {\n/*\n * transmitter cannot be used from now on\n */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\t/* Close command. */\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CLOSE);\n\t\t/* Tell adapter: command in SRB. */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\t/* Wait for it to complete. */\n\t\ttr_sleep(sc);\n\t\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\t}\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
            "struct ifnet *ifp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_stop(sc)\nstruct tr_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0) {\n/*\n * transmitter cannot be used from now on\n */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\t/* Close command. */\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CLOSE);\n\t\t/* Tell adapter: command in SRB. */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\t/* Wait for it to complete. */\n\t\ttr_sleep(sc);\n\t\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifr_mtu\tifr_metric\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nint\ntr_ioctl(ifp, cmd, data)\nstruct ifnet *ifp;\nu_long cmd;\ncaddr_t data;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *) data;\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint s;\n\tint error = 0;\n\n\ts = splnet();\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t/* XXX if not running  */\n\t\t\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t\ttr_init(sc);   /* before arp_ifinit */\n\t\t\t\ttr_sleep(sc);\n\t\t\t}\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif INET\n\t\tdefault:\n\t\t\t/* XXX if not running */\n\t\t\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t\ttr_init(sc);   /* before arpwhohas */\n\t\t\t\ttr_sleep(sc);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\t/*\n\t\t * 1- If the adapter is DOWN , turn the device off\n\t\t *       ie. adapter down but still running\n\t\t * 2- If the adapter is UP, turn the device on\n\t\t *       ie. adapter up but not running yet\n\t\t */\n\t\tif ((ifp->if_flags & (IFF_RUNNING | IFF_UP)) == IFF_RUNNING) {\n\t\t\ttr_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t}\n\t\telse if ((ifp->if_flags & (IFF_RUNNING | IFF_UP)) == IFF_UP) {\n\t\t\ttr_init(sc);\n\t\t\ttr_sleep(sc);\n\t\t}\n\t\telse {\n/*\n * XXX handle other flag changes\n */\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n#ifdef SIOCSIFMTU\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > sc->sc_maxmtu)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "tr_mbcopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1441-1462",
    "snippet": "int\ntr_mbcopy(sc, dhb, m0)\nstruct tr_softc *sc;\nbus_size_t dhb;\nstruct mbuf *m0;\n{\n\tbus_size_t addr = dhb;\n\tint len, size = 0;\n\tchar *ptr;\n\tstruct mbuf *m;\n\n\tfor (m = m0; m; m = m->m_next) {\n\t\tlen = m->m_len;\n\t\tptr = mtod(m, char *);\n\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    addr, ptr, len);\n\t\tsize += len;\n\t\taddr += len;\n\t}\n\treturn (size);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttr_mbcopy",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_sramh",
            "addr",
            "ptr",
            "len"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "char*"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\ttr_mbcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_mbcopy(sc, dhb, m0)\nstruct tr_softc *sc;\nbus_size_t dhb;\nstruct mbuf *m0;\n{\n\tbus_size_t addr = dhb;\n\tint len, size = 0;\n\tchar *ptr;\n\tstruct mbuf *m;\n\n\tfor (m = m0; m; m = m->m_next) {\n\t\tlen = m->m_len;\n\t\tptr = mtod(m, char *);\n\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    addr, ptr, len);\n\t\tsize += len;\n\t\taddr += len;\n\t}\n\treturn (size);\n}"
  },
  {
    "function_name": "tr_xint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1399-1435",
    "snippet": "void\ntr_xint(sc)\nstruct tr_softc *sc;\n{\n\tu_short\ttail;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_size_t txbuf;\n\n\t/*\n\t * To prevent race conditions on 8-bit cards when reading or writing\n\t * 16-bit values. See page 4-12 of the IBM manual.\n\t * XXX use volatile ?\n\t */\n\tdo {\n\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t} while (tail != TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL));\n\twhile (tail != TXCA_INW(sc, TXCA_FREE_QUEUE_TAIL)) {\n\t\ttxbuf =  TXCA_INW(sc, TXCA_FREE_QUEUE_TAIL) - XMIT_NEXTBUF;\n\t\ttxbuf =  TXB_INW(sc, txbuf, XMIT_NEXTBUF) - XMIT_NEXTBUF;\n\t\tif (TXB_INB(sc, txbuf, XMIT_RETCODE) != 0) {\n\t\t\tifp->if_oerrors++;\n\t\t\tprintf(\"tx: retcode = %x\\n\",\n\t\t\t    TXB_INB(sc, txbuf, XMIT_RETCODE));\n\t\t}\n\t\tsc->sc_xmit_buffers +=\n\t\t    (TXB_INW(sc, txbuf, XMIT_FRAMELEN) + 514 - 1) / 514;\n\t\ttail = TXB_INW(sc, txbuf, XMIT_LASTBUF);\n\t\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_TAIL, tail);\n\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t\tdo {\n\t\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t\t} while (tail != TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL));\n\t}\n\tif (sc->sc_xmit_buffers == sc->sc_nbuf)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\ttr_start(ifp);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_xint",
      "void\ttr_start",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tr_start",
          "args": [
            "ifp"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "tr_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "720-803",
          "snippet": "void\ntr_start(ifp)\nstruct ifnet *ifp;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\tbus_size_t first_txbuf, txbuf;\n\tstruct mbuf\t*m0, *m;\n\tint\tsize, bufspace;\n\tbus_size_t framedata;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\nnext:\n\tif (sc->sc_xmit_buffers < sc->sc_minbuf)\n\t\treturn;\n\n\t/* if data in queue, copy mbuf chain to fast path buffers */\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\n\tif (m0 == 0)\n\t\treturn;\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\tfirst_txbuf = txbuf = TXCA_INW(sc, TXCA_FREE_QUEUE_HEAD) - XMIT_NEXTBUF;\n\tframedata = txbuf + XMIT_FP_DATA;\n\tsize = 0;\n\tbufspace = FP_BUF_LEN - XMIT_FP_DATA;\n\t--sc->sc_xmit_buffers;\n\tfor (m = m0; m; m = m->m_next) {\n\t\tint len = m->m_len;\n\t\tchar *ptr = mtod(m, char *);\n\n\t\twhile (len >= bufspace) {\n\t\t\t--sc->sc_xmit_buffers;\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t\t    framedata, ptr, bufspace);\n\t\t\tsize += bufspace;\n\t\t\tptr += bufspace;\n\t\t\tlen -= bufspace;\n\t\t\tTXB_OUTW(sc, txbuf, XMIT_BUFLEN,\n\t\t\t    (FP_BUF_LEN - XMIT_FP_DATA));\n\t\t\ttxbuf = TXB_INW(sc, txbuf, XMIT_NEXTBUF) - XMIT_NEXTBUF;\n\t\t\tframedata =  txbuf + XMIT_FP_DATA;\n\t\t\tbufspace = FP_BUF_LEN - XMIT_FP_DATA;\n\t\t}\n\t\tif (len > 0) {\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t\t    framedata, ptr, len);\n\t\t\tsize += len;\n\t\t\tbufspace -= len;\n\t\t\tframedata += len;\n\t\t}\n\t}\n\tTXB_OUTW(sc, txbuf, XMIT_BUFLEN, (FP_BUF_LEN - XMIT_FP_DATA - bufspace));\n\tm_freem(m0);\t\t/* free mbuf chain */\n\n\tTXB_OUTB(sc, first_txbuf, XMIT_RETCODE, 0xfe);\n\tTXB_OUTW(sc, first_txbuf, XMIT_FRAMELEN, size);\n\tTXB_OUTW(sc, first_txbuf, XMIT_LASTBUF, (txbuf + XMIT_NEXTBUF));\n\tTXB_OUTB(sc, first_txbuf, XMIT_CMD, XMIT_DIR_FRAME);\n\tTXB_OUTW(sc, first_txbuf, XMIT_STATIONID, 0);\n\tTXB_OUTB(sc, first_txbuf, XMIT_CMDCORR, sc->sc_xmit_correlator);\n\tsc->sc_xmit_correlator = (sc->sc_xmit_correlator + 1) & 0x7f;\n\n\t/*\n\t * To prevent race conditions on 8-bit cards when reading or writing\n\t * 16-bit values. See page 4-12 of the IBM manual.\n\t */\n\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_HEAD, 1);\n\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_HEAD, TXB_INW(sc, txbuf, XMIT_NEXTBUF));\n\n\tACA_SETB(sc, ACA_ISRA_o, XMIT_REQ);\n\n\tifp->if_flags |= IFF_OACTIVE;\n\tifp->if_opackets++;\n#if 1\n/* XXX do while construction */\n\tgoto next;\n#endif\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_start",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
            "struct ifnet *ifp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_start;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_start(ifp)\nstruct ifnet *ifp;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\tbus_size_t first_txbuf, txbuf;\n\tstruct mbuf\t*m0, *m;\n\tint\tsize, bufspace;\n\tbus_size_t framedata;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\nnext:\n\tif (sc->sc_xmit_buffers < sc->sc_minbuf)\n\t\treturn;\n\n\t/* if data in queue, copy mbuf chain to fast path buffers */\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\n\tif (m0 == 0)\n\t\treturn;\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\tfirst_txbuf = txbuf = TXCA_INW(sc, TXCA_FREE_QUEUE_HEAD) - XMIT_NEXTBUF;\n\tframedata = txbuf + XMIT_FP_DATA;\n\tsize = 0;\n\tbufspace = FP_BUF_LEN - XMIT_FP_DATA;\n\t--sc->sc_xmit_buffers;\n\tfor (m = m0; m; m = m->m_next) {\n\t\tint len = m->m_len;\n\t\tchar *ptr = mtod(m, char *);\n\n\t\twhile (len >= bufspace) {\n\t\t\t--sc->sc_xmit_buffers;\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t\t    framedata, ptr, bufspace);\n\t\t\tsize += bufspace;\n\t\t\tptr += bufspace;\n\t\t\tlen -= bufspace;\n\t\t\tTXB_OUTW(sc, txbuf, XMIT_BUFLEN,\n\t\t\t    (FP_BUF_LEN - XMIT_FP_DATA));\n\t\t\ttxbuf = TXB_INW(sc, txbuf, XMIT_NEXTBUF) - XMIT_NEXTBUF;\n\t\t\tframedata =  txbuf + XMIT_FP_DATA;\n\t\t\tbufspace = FP_BUF_LEN - XMIT_FP_DATA;\n\t\t}\n\t\tif (len > 0) {\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t\t    framedata, ptr, len);\n\t\t\tsize += len;\n\t\t\tbufspace -= len;\n\t\t\tframedata += len;\n\t\t}\n\t}\n\tTXB_OUTW(sc, txbuf, XMIT_BUFLEN, (FP_BUF_LEN - XMIT_FP_DATA - bufspace));\n\tm_freem(m0);\t\t/* free mbuf chain */\n\n\tTXB_OUTB(sc, first_txbuf, XMIT_RETCODE, 0xfe);\n\tTXB_OUTW(sc, first_txbuf, XMIT_FRAMELEN, size);\n\tTXB_OUTW(sc, first_txbuf, XMIT_LASTBUF, (txbuf + XMIT_NEXTBUF));\n\tTXB_OUTB(sc, first_txbuf, XMIT_CMD, XMIT_DIR_FRAME);\n\tTXB_OUTW(sc, first_txbuf, XMIT_STATIONID, 0);\n\tTXB_OUTB(sc, first_txbuf, XMIT_CMDCORR, sc->sc_xmit_correlator);\n\tsc->sc_xmit_correlator = (sc->sc_xmit_correlator + 1) & 0x7f;\n\n\t/*\n\t * To prevent race conditions on 8-bit cards when reading or writing\n\t * 16-bit values. See page 4-12 of the IBM manual.\n\t */\n\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_HEAD, 1);\n\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_HEAD, TXB_INW(sc, txbuf, XMIT_NEXTBUF));\n\n\tACA_SETB(sc, ACA_ISRA_o, XMIT_REQ);\n\n\tifp->if_flags |= IFF_OACTIVE;\n\tifp->if_opackets++;\n#if 1\n/* XXX do while construction */\n\tgoto next;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXCA_INW",
          "args": [
            "sc",
            "TXCA_COMPLETION_QUEUE_TAIL"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_INW",
          "args": [
            "sc",
            "TXCA_COMPLETION_QUEUE_TAIL"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_INW",
          "args": [
            "sc",
            "TXCA_COMPLETION_QUEUE_TAIL"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_OUTW",
          "args": [
            "sc",
            "TXCA_FREE_QUEUE_TAIL",
            "tail"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_INW",
          "args": [
            "sc",
            "txbuf",
            "XMIT_LASTBUF"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_INW",
          "args": [
            "sc",
            "txbuf",
            "XMIT_FRAMELEN"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tx: retcode = %x\\n\"",
            "TXB_INB(sc, txbuf, XMIT_RETCODE)"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXB_INB",
          "args": [
            "sc",
            "txbuf",
            "XMIT_RETCODE"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_INB",
          "args": [
            "sc",
            "txbuf",
            "XMIT_RETCODE"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_INW",
          "args": [
            "sc",
            "txbuf",
            "XMIT_NEXTBUF"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_INW",
          "args": [
            "sc",
            "TXCA_FREE_QUEUE_TAIL"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_INW",
          "args": [
            "sc",
            "TXCA_FREE_QUEUE_TAIL"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_INW",
          "args": [
            "sc",
            "TXCA_COMPLETION_QUEUE_TAIL"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_INW",
          "args": [
            "sc",
            "TXCA_COMPLETION_QUEUE_TAIL"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_xint;\nvoid\ttr_start;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_xint(sc)\nstruct tr_softc *sc;\n{\n\tu_short\ttail;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_size_t txbuf;\n\n\t/*\n\t * To prevent race conditions on 8-bit cards when reading or writing\n\t * 16-bit values. See page 4-12 of the IBM manual.\n\t * XXX use volatile ?\n\t */\n\tdo {\n\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t} while (tail != TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL));\n\twhile (tail != TXCA_INW(sc, TXCA_FREE_QUEUE_TAIL)) {\n\t\ttxbuf =  TXCA_INW(sc, TXCA_FREE_QUEUE_TAIL) - XMIT_NEXTBUF;\n\t\ttxbuf =  TXB_INW(sc, txbuf, XMIT_NEXTBUF) - XMIT_NEXTBUF;\n\t\tif (TXB_INB(sc, txbuf, XMIT_RETCODE) != 0) {\n\t\t\tifp->if_oerrors++;\n\t\t\tprintf(\"tx: retcode = %x\\n\",\n\t\t\t    TXB_INB(sc, txbuf, XMIT_RETCODE));\n\t\t}\n\t\tsc->sc_xmit_buffers +=\n\t\t    (TXB_INW(sc, txbuf, XMIT_FRAMELEN) + 514 - 1) / 514;\n\t\ttail = TXB_INW(sc, txbuf, XMIT_LASTBUF);\n\t\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_TAIL, tail);\n\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t\tdo {\n\t\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t\t} while (tail != TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL));\n\t}\n\tif (sc->sc_xmit_buffers == sc->sc_nbuf)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\ttr_start(ifp);\n}"
  },
  {
    "function_name": "tr_oldxint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1298-1394",
    "snippet": "void\ntr_oldxint(sc)\nstruct tr_softc *sc;\n{\n\tbus_size_t arb = sc->sc_arb;\t/* pointer to ARB */\n\tbus_size_t asb = sc->sc_asb;\t/* pointer to ASB */\n\tbus_size_t dhb;\t\t\t/* pointer to DHB */\n\tstruct mbuf *m0;\t\t/* pointer to top of mbuf chain */\n\tu_short size = 0;\n\tchar\tcommand;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct token_header *trh;\n\tint i;\n\tu_int8_t hlen;\n\n/*\n * XXX xmit_asb_response()\n */\n\tif (ASB_INB(sc, asb, XMIT_RETCODE) != 0xff)\n\t\tprintf(\"tr_oldxint: ASB IS NOT FREE!!!\\n\");\n\n\t/* load parameters into ASB */\n\tASB_OUTB(sc, asb, XMIT_CMDCORR, ARB_INB(sc, arb, ARB_XMT_CMDCORR));\n\tASB_OUTW(sc, asb, XMIT_STATIONID, ARB_INW(sc, arb, ARB_STATIONID));\n\tASB_OUTB(sc, asb, XMIT_RETCODE, 0);\n/*\n * XXX LLC_{X25,ISO}_LSAP\n */\n\tASB_OUTB(sc, asb, XMIT_REMSAP, LLC_SNAP_LSAP);\n\n\t/* XXX if num_dhb == 2 this should alternate between the two buffers */\n\tdhb = ARB_INW(sc, arb, ARB_XMT_DHBADDR);\n\n\tcommand = SRB_INB(sc, sc->sc_srb, SRB_CMD);\n\n\tif (command == XMIT_XID_CMD || command == XMIT_TEST_CMD) {\n\t\tASB_OUTB(sc, asb, XMIT_CMD, command);\n\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, 0x11);\n/*\n * XXX 0xe == sizeof(struct token_header)\n */\n\t\tASB_OUTB(sc, asb, XMIT_HDRLEN, 0x0e);\n\n\t\tSR_OUTB(sc, (dhb + 0), TOKEN_AC);\n\t\tSR_OUTB(sc, (dhb + 1), TOKEN_FC);\n\t\t/* Load destination and source addresses. */\n\t\tfor (i=0; i < ISO88025_ADDR_LEN; i++) {\n\t\t\tSR_OUTB(sc, (dhb + 2 + i), 0xff);\n\t\t\tSR_OUTB(sc, (dhb + 8 + i), 0x00);\n\t\t}\n\t}\n\telse {\n/*\n * XXX what's command here ?  command = 0x0d (always ?)\n */\n\t\t/* if data in queue, copy mbuf chain to DHB */\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 != 0) {\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf)\n\t\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\t\t\t/* Pull packet off interface send queue, fill DHB. */\n\t\t\ttrh = mtod(m0, struct token_header *);\n\t\t\thlen = sizeof(struct token_header);\n\t\t\tif (trh->token_shost[0] & TOKEN_RI_PRESENT) {\n/*\n * XXX assumes route info is in the same mbuf as the token-ring header\n */\n\t\t\t\tstruct token_rif\t*rif;\n\n\t\t\t\trif = TOKEN_RIF(trh);\n\t\t\t\thlen += ((ntohs(rif->tr_rcf) & TOKEN_RCF_LEN_MASK) >> 8);\n\t\t\t}\n\t\t\tsize = tr_mbcopy(sc, dhb, m0);\n\t\t\tm_freem(m0);\n\n\t\t\tASB_OUTB(sc, asb, XMIT_CMD, XMIT_UI_FRM);  \n\t\t\tASB_OUTB(sc, asb, XMIT_HDRLEN, hlen);\n\n\t\t\t/* Set size of transmission frame in ASB. */\n\t\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, size);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%s: unexpected empty mbuf send queue\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t\t/* Set size of transmission frame in ASB to zero. */\n\t\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, 0);\n\t\t}\n\t}\n/*\n * XXX asb_response(void *asb, len)\n */\n\t/* tell adapter that there is a response in the ASB */\n\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_oldxint",
      "int\ttr_mbcopy",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "RESP_IN_ASB"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTW",
          "args": [
            "sc",
            "asb",
            "XMIT_FRAMELEN",
            "0"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unexpected empty mbuf send queue\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASB_OUTW",
          "args": [
            "sc",
            "asb",
            "XMIT_FRAMELEN",
            "size"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTB",
          "args": [
            "sc",
            "asb",
            "XMIT_HDRLEN",
            "hlen"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTB",
          "args": [
            "sc",
            "asb",
            "XMIT_CMD",
            "XMIT_UI_FRM"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_mbcopy",
          "args": [
            "sc",
            "dhb",
            "m0"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "tr_mbcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1441-1462",
          "snippet": "int\ntr_mbcopy(sc, dhb, m0)\nstruct tr_softc *sc;\nbus_size_t dhb;\nstruct mbuf *m0;\n{\n\tbus_size_t addr = dhb;\n\tint len, size = 0;\n\tchar *ptr;\n\tstruct mbuf *m;\n\n\tfor (m = m0; m; m = m->m_next) {\n\t\tlen = m->m_len;\n\t\tptr = mtod(m, char *);\n\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    addr, ptr, len);\n\t\tsize += len;\n\t\taddr += len;\n\t}\n\treturn (size);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\ttr_mbcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\ttr_mbcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_mbcopy(sc, dhb, m0)\nstruct tr_softc *sc;\nbus_size_t dhb;\nstruct mbuf *m0;\n{\n\tbus_size_t addr = dhb;\n\tint len, size = 0;\n\tchar *ptr;\n\tstruct mbuf *m;\n\n\tfor (m = m0; m; m = m->m_next) {\n\t\tlen = m->m_len;\n\t\tptr = mtod(m, char *);\n\n\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    addr, ptr, len);\n\t\tsize += len;\n\t\taddr += len;\n\t}\n\treturn (size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "rif->tr_rcf"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TOKEN_RIF",
          "args": [
            "trh"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "structtoken_header*"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SR_OUTB",
          "args": [
            "sc",
            "(dhb + 8 + i)",
            "0x00"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SR_OUTB",
          "args": [
            "sc",
            "(dhb + 2 + i)",
            "0xff"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SR_OUTB",
          "args": [
            "sc",
            "(dhb + 1)",
            "TOKEN_FC"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SR_OUTB",
          "args": [
            "sc",
            "(dhb + 0)",
            "TOKEN_AC"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTB",
          "args": [
            "sc",
            "asb",
            "XMIT_HDRLEN",
            "0x0e"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTW",
          "args": [
            "sc",
            "asb",
            "XMIT_FRAMELEN",
            "0x11"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTB",
          "args": [
            "sc",
            "asb",
            "XMIT_CMD",
            "command"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CMD"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_XMT_DHBADDR"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTB",
          "args": [
            "sc",
            "asb",
            "XMIT_REMSAP",
            "LLC_SNAP_LSAP"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTB",
          "args": [
            "sc",
            "asb",
            "XMIT_RETCODE",
            "0"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTW",
          "args": [
            "sc",
            "asb",
            "XMIT_STATIONID",
            "ARB_INW(sc, arb, ARB_STATIONID)"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_STATIONID"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTB",
          "args": [
            "sc",
            "asb",
            "XMIT_CMDCORR",
            "ARB_INB(sc, arb, ARB_XMT_CMDCORR)"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INB",
          "args": [
            "sc",
            "arb",
            "ARB_XMT_CMDCORR"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_INB",
          "args": [
            "sc",
            "asb",
            "XMIT_RETCODE"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_oldxint;\nint\ttr_mbcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_oldxint(sc)\nstruct tr_softc *sc;\n{\n\tbus_size_t arb = sc->sc_arb;\t/* pointer to ARB */\n\tbus_size_t asb = sc->sc_asb;\t/* pointer to ASB */\n\tbus_size_t dhb;\t\t\t/* pointer to DHB */\n\tstruct mbuf *m0;\t\t/* pointer to top of mbuf chain */\n\tu_short size = 0;\n\tchar\tcommand;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct token_header *trh;\n\tint i;\n\tu_int8_t hlen;\n\n/*\n * XXX xmit_asb_response()\n */\n\tif (ASB_INB(sc, asb, XMIT_RETCODE) != 0xff)\n\t\tprintf(\"tr_oldxint: ASB IS NOT FREE!!!\\n\");\n\n\t/* load parameters into ASB */\n\tASB_OUTB(sc, asb, XMIT_CMDCORR, ARB_INB(sc, arb, ARB_XMT_CMDCORR));\n\tASB_OUTW(sc, asb, XMIT_STATIONID, ARB_INW(sc, arb, ARB_STATIONID));\n\tASB_OUTB(sc, asb, XMIT_RETCODE, 0);\n/*\n * XXX LLC_{X25,ISO}_LSAP\n */\n\tASB_OUTB(sc, asb, XMIT_REMSAP, LLC_SNAP_LSAP);\n\n\t/* XXX if num_dhb == 2 this should alternate between the two buffers */\n\tdhb = ARB_INW(sc, arb, ARB_XMT_DHBADDR);\n\n\tcommand = SRB_INB(sc, sc->sc_srb, SRB_CMD);\n\n\tif (command == XMIT_XID_CMD || command == XMIT_TEST_CMD) {\n\t\tASB_OUTB(sc, asb, XMIT_CMD, command);\n\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, 0x11);\n/*\n * XXX 0xe == sizeof(struct token_header)\n */\n\t\tASB_OUTB(sc, asb, XMIT_HDRLEN, 0x0e);\n\n\t\tSR_OUTB(sc, (dhb + 0), TOKEN_AC);\n\t\tSR_OUTB(sc, (dhb + 1), TOKEN_FC);\n\t\t/* Load destination and source addresses. */\n\t\tfor (i=0; i < ISO88025_ADDR_LEN; i++) {\n\t\t\tSR_OUTB(sc, (dhb + 2 + i), 0xff);\n\t\t\tSR_OUTB(sc, (dhb + 8 + i), 0x00);\n\t\t}\n\t}\n\telse {\n/*\n * XXX what's command here ?  command = 0x0d (always ?)\n */\n\t\t/* if data in queue, copy mbuf chain to DHB */\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 != 0) {\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf)\n\t\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\t\t\t/* Pull packet off interface send queue, fill DHB. */\n\t\t\ttrh = mtod(m0, struct token_header *);\n\t\t\thlen = sizeof(struct token_header);\n\t\t\tif (trh->token_shost[0] & TOKEN_RI_PRESENT) {\n/*\n * XXX assumes route info is in the same mbuf as the token-ring header\n */\n\t\t\t\tstruct token_rif\t*rif;\n\n\t\t\t\trif = TOKEN_RIF(trh);\n\t\t\t\thlen += ((ntohs(rif->tr_rcf) & TOKEN_RCF_LEN_MASK) >> 8);\n\t\t\t}\n\t\t\tsize = tr_mbcopy(sc, dhb, m0);\n\t\t\tm_freem(m0);\n\n\t\t\tASB_OUTB(sc, asb, XMIT_CMD, XMIT_UI_FRM);  \n\t\t\tASB_OUTB(sc, asb, XMIT_HDRLEN, hlen);\n\n\t\t\t/* Set size of transmission frame in ASB. */\n\t\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, size);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%s: unexpected empty mbuf send queue\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t\t/* Set size of transmission frame in ASB to zero. */\n\t\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, 0);\n\t\t}\n\t}\n/*\n * XXX asb_response(void *asb, len)\n */\n\t/* tell adapter that there is a response in the ASB */\n\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n}"
  },
  {
    "function_name": "tr_rint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1192-1293",
    "snippet": "void\ntr_rint(sc)\nstruct tr_softc *sc;\n{\n\tbus_size_t arb = sc->sc_arb;\n\tbus_size_t asb = sc->sc_asb;\n\tstruct rbcb *rbc = &sc->rbc;\n\tstruct mbuf *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n#ifdef TROPICDEBUG\n\tprintf(\"tr_rint: arb.command = %x, arb.station_id= %x\\n\",\n\t    ARB_INB(sc, arb, ARB_CMD), ARB_INW(sc, arb, ARB_STATIONID));\n\tprintf(\"arb.buf_addr = %x, arb.lan_hdr_len = %x\\n\",\n\t    ARB_INW(sc, arb, ARB_RXD_BUFADDR),\n\t    ARB_INB(sc, arb, ARB_RXD_LANHDRLEN));\n\tprintf(\"arb.dlc_hdr_len = %d, arb.frame_len = %d\\n\",\n\t    ARB_INB(sc, arb, ARB_RXD_DLCHDRLEN),\n\t    ARB_INW(sc, arb, ARB_RXD_FRAMELEN));\n\tprintf(\"arb.msg_type = %x\\n\", ARB_INB(sc, arb, ARB_RXD_MSGTYPE));\n#endif /* TROPICDEBUG */\n\t/*\n\t * copy the offset in RAM of the first receive buffer from the\n\t * receive-data block of the adapter request block associated\n\t * with the unit's softc struct into the receive control block.\n\t */\n\trbc->rbufp = ARB_INW(sc, arb, ARB_RXD_BUFADDR);\n\n\t/*\n\t * copy the pointer to data in first receive buffer\n\t */\n\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\t/*\n\t * the token-ring header is viewed as two header structs: the physical\n\t * header (aka TR header) with access, frame, dest, src, and routing\n\t * information, and the logical link control header (aka LLC header)\n\t * with dsap, ssap, llc, proto and type fields.\n\t *\n\t * rfc1042 requires support for unnumbered information (UI) commands,\n\t * but does not specify a required semantic, so we'll discard them.\n\t *\n\t */\n\n\t/*\n\t * if there is a second receive buffer, set up the next pointer\n\t */\n\tif (RB_INW(sc, rbc->rbufp, RB_NEXTBUF))\n\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF) -\n\t\t    RB_NEXTBUF;\n\telse\n\t\trbc->rbufp_next = 0;\t/* we're finished */\n\n\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t/*\n\t * At this point we move the packet from the adapter to a chain\n\t * of mbufs\n\t */\n\tm = tr_get(sc, ARB_INW(sc, arb, ARB_RXD_FRAMELEN), ifp);\n/*\n * XXX Clear ARB interrupt here?\n */\n/*\n * XXX create a queue where the responses are buffered\n * XXX but is it really needed ?\n */\n\n\tif (ASB_INB(sc, asb, RECV_RETCODE) != 0xff)\n\t\tprintf(\"tr_rint: ASB IS NOT FREE!!!\\n\");\n\t/*\n\t * Load receive response into ASB.\n\t */\n\tASB_OUTB(sc, asb, RECV_CMD, REC_DATA);\n\tASB_OUTW(sc, asb, RECV_STATIONID, ARB_INW(sc, arb, ARB_STATIONID));\n\tASB_OUTW(sc, asb, RECV_RESP_RECBUFADDR,\n\t    ARB_INW(sc, arb, ARB_RXD_BUFADDR));\n\n\tif (m == 0) {\n\t\t/*\n\t\t * Tell adapter data lost, no mbufs.\n\t\t */\n\t\tASB_OUTB(sc, asb, RECV_RETCODE, 0x20);\n\t\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n\t\t++ifp->if_ierrors;\n#ifdef TROPICDEBUG\n\t\tprintf(\"tr_rint: packet dropped\\n\");\n#endif /* TROPICDEBUG */\n\t}\n\telse {\n\t\t/*\n\t\t * Indicate successful receive.\n\t\t */\n\t\tASB_OUTB(sc, asb, RECV_RETCODE, 0);\n\t\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n\t\t++ifp->if_ipackets;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\ttoken_input(ifp, m);\n\t}\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_rint",
      "struct\tmbuf *tr_get",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "token_input",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "RESP_IN_ASB"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTB",
          "args": [
            "sc",
            "asb",
            "RECV_RETCODE",
            "0"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tr_rint: packet dropped\\n\""
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "RESP_IN_ASB"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTB",
          "args": [
            "sc",
            "asb",
            "RECV_RETCODE",
            "0x20"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTW",
          "args": [
            "sc",
            "asb",
            "RECV_RESP_RECBUFADDR",
            "ARB_INW(sc, arb, ARB_RXD_BUFADDR)"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_RXD_BUFADDR"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTW",
          "args": [
            "sc",
            "asb",
            "RECV_STATIONID",
            "ARB_INW(sc, arb, ARB_STATIONID)"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_STATIONID"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_OUTB",
          "args": [
            "sc",
            "asb",
            "RECV_CMD",
            "REC_DATA"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_INB",
          "args": [
            "sc",
            "asb",
            "RECV_RETCODE"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_get",
          "args": [
            "sc",
            "ARB_INW(sc, arb, ARB_RXD_FRAMELEN)",
            "ifp"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_RXD_FRAMELEN"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_INW",
          "args": [
            "sc",
            "rbc->rbufp",
            "RB_BUFLEN"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_INW",
          "args": [
            "sc",
            "rbc->rbufp",
            "RB_NEXTBUF"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_INW",
          "args": [
            "sc",
            "rbc->rbufp",
            "RB_NEXTBUF"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_RXD_BUFADDR"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INB",
          "args": [
            "sc",
            "arb",
            "ARB_RXD_MSGTYPE"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_RXD_FRAMELEN"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INB",
          "args": [
            "sc",
            "arb",
            "ARB_RXD_DLCHDRLEN"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INB",
          "args": [
            "sc",
            "arb",
            "ARB_RXD_LANHDRLEN"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_RXD_BUFADDR"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_STATIONID"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INB",
          "args": [
            "sc",
            "arb",
            "ARB_CMD"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_rint;\nstruct\tmbuf *tr_get;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_rint(sc)\nstruct tr_softc *sc;\n{\n\tbus_size_t arb = sc->sc_arb;\n\tbus_size_t asb = sc->sc_asb;\n\tstruct rbcb *rbc = &sc->rbc;\n\tstruct mbuf *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n#ifdef TROPICDEBUG\n\tprintf(\"tr_rint: arb.command = %x, arb.station_id= %x\\n\",\n\t    ARB_INB(sc, arb, ARB_CMD), ARB_INW(sc, arb, ARB_STATIONID));\n\tprintf(\"arb.buf_addr = %x, arb.lan_hdr_len = %x\\n\",\n\t    ARB_INW(sc, arb, ARB_RXD_BUFADDR),\n\t    ARB_INB(sc, arb, ARB_RXD_LANHDRLEN));\n\tprintf(\"arb.dlc_hdr_len = %d, arb.frame_len = %d\\n\",\n\t    ARB_INB(sc, arb, ARB_RXD_DLCHDRLEN),\n\t    ARB_INW(sc, arb, ARB_RXD_FRAMELEN));\n\tprintf(\"arb.msg_type = %x\\n\", ARB_INB(sc, arb, ARB_RXD_MSGTYPE));\n#endif /* TROPICDEBUG */\n\t/*\n\t * copy the offset in RAM of the first receive buffer from the\n\t * receive-data block of the adapter request block associated\n\t * with the unit's softc struct into the receive control block.\n\t */\n\trbc->rbufp = ARB_INW(sc, arb, ARB_RXD_BUFADDR);\n\n\t/*\n\t * copy the pointer to data in first receive buffer\n\t */\n\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\t/*\n\t * the token-ring header is viewed as two header structs: the physical\n\t * header (aka TR header) with access, frame, dest, src, and routing\n\t * information, and the logical link control header (aka LLC header)\n\t * with dsap, ssap, llc, proto and type fields.\n\t *\n\t * rfc1042 requires support for unnumbered information (UI) commands,\n\t * but does not specify a required semantic, so we'll discard them.\n\t *\n\t */\n\n\t/*\n\t * if there is a second receive buffer, set up the next pointer\n\t */\n\tif (RB_INW(sc, rbc->rbufp, RB_NEXTBUF))\n\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF) -\n\t\t    RB_NEXTBUF;\n\telse\n\t\trbc->rbufp_next = 0;\t/* we're finished */\n\n\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t/*\n\t * At this point we move the packet from the adapter to a chain\n\t * of mbufs\n\t */\n\tm = tr_get(sc, ARB_INW(sc, arb, ARB_RXD_FRAMELEN), ifp);\n/*\n * XXX Clear ARB interrupt here?\n */\n/*\n * XXX create a queue where the responses are buffered\n * XXX but is it really needed ?\n */\n\n\tif (ASB_INB(sc, asb, RECV_RETCODE) != 0xff)\n\t\tprintf(\"tr_rint: ASB IS NOT FREE!!!\\n\");\n\t/*\n\t * Load receive response into ASB.\n\t */\n\tASB_OUTB(sc, asb, RECV_CMD, REC_DATA);\n\tASB_OUTW(sc, asb, RECV_STATIONID, ARB_INW(sc, arb, ARB_STATIONID));\n\tASB_OUTW(sc, asb, RECV_RESP_RECBUFADDR,\n\t    ARB_INW(sc, arb, ARB_RXD_BUFADDR));\n\n\tif (m == 0) {\n\t\t/*\n\t\t * Tell adapter data lost, no mbufs.\n\t\t */\n\t\tASB_OUTB(sc, asb, RECV_RETCODE, 0x20);\n\t\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n\t\t++ifp->if_ierrors;\n#ifdef TROPICDEBUG\n\t\tprintf(\"tr_rint: packet dropped\\n\");\n#endif /* TROPICDEBUG */\n\t}\n\telse {\n\t\t/*\n\t\t * Indicate successful receive.\n\t\t */\n\t\tASB_OUTB(sc, asb, RECV_RETCODE, 0);\n\t\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n\t\t++ifp->if_ipackets;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\ttoken_input(ifp, m);\n\t}\n}"
  },
  {
    "function_name": "asb_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1166-1174",
    "snippet": "int asb_response(bus_size_t asb, size_t len)\n{\n\tif (empty_queue) {\n\t\tanswer with RESP_IN_ASB | ASB_FREE\n\t}\n\telse {\n\t\tput asb in queue\n\t}\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint asb_response(bus_size_t asb, size_t len)\n{\n\tif (empty_queue) {\n\t\tanswer with RESP_IN_ASB | ASB_FREE\n\t}\n\telse {\n\t\tput asb in queue\n\t}\n}"
  },
  {
    "function_name": "asb_reply_xmit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1162-1164",
    "snippet": "int asb_reply_xmit()\n{\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint asb_reply_xmit()\n{\n}"
  },
  {
    "function_name": "asb_reply_rcv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "1158-1160",
    "snippet": "int asb_reply_rcv()\n{\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint asb_reply_rcv()\n{\n}"
  },
  {
    "function_name": "tr_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "812-1155",
    "snippet": "int\ntr_intr(arg)\n\tvoid *arg;\n{\n\tstruct tr_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_char status;\t/* holds status from adapter status register */\n\tu_char command;\t/* holds command from status or request block */\n\tu_char retcode;\t/* holds return value from status or request block */\n\tint rc = 0;\t/* 0 = unclaimed interrupt, 1 = interrupt claimed */\n\n\tstatus = ACA_RDB(sc, ACA_ISRP_o);\n\twhile (status != 0) {\n\n\t\t/* Is this interrupt caused by an adapter check? */\n\t\tif (status & ADAP_CHK_INT) {\n\t\t\tprintf(\"%s: adapter check 0x%04x\\n\",\n\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t    (unsigned int)ntohs(ACA_RDW(sc, ACA_WWCR)));\n\n\t\t\t/* Clear this interrupt bit */\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(ADAP_CHK_INT));\n\n\t\t\trc = 1;\t\t/* Claim interrupt. */\n\t\t\tbreak;\t\t/* Terminate loop. */\n\t\t}\n\t\telse if (status & XMIT_COMPLETE) {\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(XMIT_COMPLETE));\n\t\t\ttr_xint(sc);\n\t\t\trc = 1;\n\t\t}\n\n\t\t/*\n\t\t * Process SRB_RESP_INT, ASB_FREE_INT, ARB_CMD_INT\n\t\t * & SSB_RESP_INT in that order, ISRP-L Hi to Lo\n\t\t */\n\t\telse if (status & SRB_RESP_INT) { /* Adapter response in SRB? */\n\t\t\tbus_size_t sap_srb;\n\t\t\tbus_size_t srb;\n#ifdef TROPICDEBUG\n\t\t\tbus_size_t log_srb;\n#endif\n\t\t\tif (sc->sc_srb == 0)\n\t\t\t\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\t\t\tsrb = sc->sc_srb; /* pointer to SRB */\n\t\t\tretcode = SRB_INB(sc, srb, SRB_RETCODE);\n\t\t\tcommand = SRB_INB(sc, srb, SRB_CMD);\n\t\t\tswitch (command) {\n\t\t\tcase 0x80: /* 0x80 == initialization complete */\n\t\t\tcase DIR_CONFIG_FAST_PATH_RAM:\n\t\t\t\tbreak;\n\t\t\tcase XMIT_DIR_FRAME:\t/* Response to xmit request */\n\t\t\tcase XMIT_UI_FRM:\t/* Response to xmit request */\n\t\t\t\t/* Response not valid? */\n\t\t\t\tif (retcode != 0xff)\n\t\t\t\t\tprintf(\"%s: error on xmit request =%x\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname, retcode);\n\t\t\t\tbreak;\n\n\t\t\tcase DIR_OPEN_ADAPTER:\t/* open-adapter-cmd response */\n\t\t\t\t/* Open successful? */\n\t\t\t\tif (retcode == 0) {\n\t\t\t\t\tifp->if_flags |= IFF_UP | IFF_RUNNING;\n\t\t\t\t\t/* Save new ACA ctrl block addresses */\n\t\t\t\t\tsc->sc_ssb = SRB_INW(sc, srb,\n\t\t\t\t\t    SRB_OPENRESP_SSBADDR);\n\t\t\t\t\tsc->sc_arb = SRB_INW(sc, srb,\n\t\t\t\t\t    SRB_OPENRESP_ARBADDR);\n\t\t\t\t\tsc->sc_srb = SRB_INW(sc, srb,\n\t\t\t\t\t    SRB_OPENRESP_SRBADDR);\n\t\t\t\t\tsc->sc_asb = SRB_INW(sc, srb,\n\t\t\t\t\t    SRB_OPENRESP_ASBADDR);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX, what about LLC_{X25,ISO}_LSAP ?\n\t\t\t\t\t * open two more saps .....\n\t\t\t\t\t */\n\t\t\t\t\tif (sc->sc_init_status &\n\t\t\t\t\t    FAST_PATH_TRANSMIT) {\n\t\t\t\t\t\tsc->sc_xmit_buffers =\n\t\t\t\t\t\t    TXCA_INW(sc, TXCA_BUFFER_COUNT);\n\t\t\t\t\t\tsc->sc_nbuf =\n\t\t\t\t\t\t    sc->sc_xmit_buffers;\n#ifdef TROPICDEBUG\n\t\t\t\t\t\tprintf(\"buffers = %d\\n\",\n\t\t\t\t\t\t    sc->sc_xmit_buffers);\n#endif\n\t\t\t\t\t\tsc->sc_xmit_correlator = 0;\n\t\t\t\t\t\tuntimeout(tr_timeout, sc);\n\t\t\t\t\t\twakeup(&sc->tr_sleepevent);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\ttr_opensap(sc, LLC_SNAP_LSAP); \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%s: Open error = %x\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t\t    SRB_INB(sc, srb, SRB_RETCODE));\n\t\t\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\t\t\tifp->if_flags &= ~IFF_UP;\n/*\n * XXX untimeout depending on the error, timeout in other cases\n * XXX error 0x24 && autospeed mode: open again !!!!\n */\n\t\t\t\t\ttimeout(tr_init, sc, hz*30);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DIR_CLOSE:\t/* Response to close adapter command */\n\t\t\t\t/* Close not successful? */\n\t\t\t\tif (retcode != 0)\n\t\t\t\t\tprintf(\"%s: close error = %x\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname, retcode);\n\t\t\t\telse {\n\t\t\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\t\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\t\t\t\tuntimeout(tr_timeout, sc);\n\t\t\t\t\twakeup(&sc->tr_sleepevent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DIR_SET_DEFAULT_RING_SPEED:\n\t\t\t\tuntimeout(tr_timeout, sc);\n\t\t\t\twakeup(&sc->tr_sleepevent);\n\t\t\t\tbreak;\n\n\t\t\tcase DLC_OPEN_SAP:     \t/* Response to open sap cmd */\n\t\t\t\tsap_srb = sc->sc_srb;\n\t\t\t\tif (SRB_INB(sc, sap_srb, SRB_OPNSAP_SAPVALUE)\n\t\t\t\t    == LLC_SNAP_LSAP)\n\t\t\t\t\tsc->exsap_station =\n\t\t\t\t\t    SRB_INW(sc, sap_srb,\n\t\t\t\t\t        SRB_OPNSAP_STATIONID);\n\t\t\t\tprintf(\"%s: Token Ring opened\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tuntimeout(tr_timeout, sc);\n\t\t\t\twakeup(&sc->tr_sleepevent);\n\t\t\t\tbreak;\n/* XXX DLC_CLOSE_SAP not needed ? */\n\t\t\tcase DLC_CLOSE_SAP: /* Response to close sap cmd */\n\t\t\t\tbreak;\n\t\t\tcase DIR_READ_LOG:   /* Response to read log */\n\t\t\t\t/* Cmd not successful? */\n\t\t\t\tif (retcode != 0)\n\t\t\t\t\tprintf(\"%s: read error log cmd err =%x\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname, retcode);\n#ifdef TROPICDEBUG\n\t\t\t\tlog_srb = sc->sc_srb;\n\t\t\t\tprintf(\"%s: ERROR LOG:\\n\",sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"%s: Line=%d, Internal=%d, Burst=%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_LINEERRS)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_INTERRS)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_BRSTERRS)));\n\t\t\t\tprintf(\"%s: A/C=%d, Abort=%d, Lost frames=%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_ACERRS)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_ABRTERRS)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_LOSTFRMS)));\n\t\t\t\tprintf(\"%s: Receive congestion=%d, Frame copied=%d, Frequency=%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_RCVCONG)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_FCPYERRS)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_FREQERRS)));\n\t\t\t\tprintf(\"%s: Token=%d\\n\",sc->sc_dev.dv_xname,\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_TOKENERRS)));\n#endif /* TROPICDEBUG */\n\t\t\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: bad SRB command encountered %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, command);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* clear the SRB-response interrupt bit */\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\t\t}\n\n\t\telse if (status & ASB_FREE_INT) { /* Is ASB Free? */\n\t\t\tbus_size_t asb = sc->sc_asb;\n\n\t\t\t/*\n\t\t\t * Remove message from asb queue, first element in\n\t\t\t * structure is the command. command == REC_DATA?\n\t\t\t * size = 8 : size = 10\n\t\t\t * reply in isra_l with (RESP_IN_ASB | ASB_FREE)\n\t\t\t */\n\t\t\tretcode = ASB_INB(sc, asb, CMD_RETCODE);\n\t\t\tcommand = ASB_INB(sc, asb, CMD_CMD);\n\t\t\tswitch (command) {\n\t\t\tcase REC_DATA:\t\t/* Receive */\n\t\t\t\t/* Response not valid? */\n\t\t\t\tif (retcode != 0xff)\n\t\t\t\tprintf(\"%s: ASB bad receive response =%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, retcode);\n\t\t\t\tbreak;\n\t\t\tcase XMIT_DIR_FRAME:\t/* Transmit */\n\t\t\tcase XMIT_UI_FRM:   \t/* Transmit */\n\t\t\t\t/* Response not valid? */\n\t\t\t\tif (retcode != 0xff)\n\t\t\t\tprintf(\"%s: ASB response err on xmit =%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, retcode);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: Invalid command in ASB =%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, command);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Clear this interrupt bit */\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(ASB_FREE_INT));\n\t\t}\n\t\telse if (status & ARB_CMD_INT) { /* Command for PC to handle? */\n\t\t\tbus_size_t arb = sc->sc_arb;\n\n\t\t\tcommand = ARB_INB(sc, arb, ARB_CMD);\n\t\t\tswitch (command) {\n\t\t\tcase DLC_STATUS:    /* DLC status change */\t\n\t\t\t\tprintf(\"%s: ARB new DLC  status = 0x%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    ARB_INW(sc, arb, ARB_DLCSTAT_STATUS));\n\t\t\t\tbreak;\n\t\t\tcase REC_DATA:\t\t/* Adapter has data for PC */\n\t\t\t\t/* Call receive interrupt handler */\n\t\t\t\ttr_rint(sc);\n\t\t\t\tbreak;\n\n\t\t\tcase RING_STAT_CHANGE:\t/* Ring status change */\n\t\t\t\tif (ARB_INW(sc, arb, ARB_RINGSTATUS) &\n\t\t\t\t    (SIGNAL_LOSS + LOBE_FAULT)){\n\t\t\t\t\tprintf(\"%s: SIGNAL LOSS/LOBE FAULT\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\t\t\tif_qflush(&ifp->if_snd);\n\t\t\t\t\ttimeout(tr_reinit, sc ,hz*30);\n\t\t\t\t}\n\t\t\t\telse {\n#ifdef TROPICDEBUG\n\t\t\t\t\tif (ARB_INW(sc, arb, ARB_RINGSTATUS) &\n\t\t\t\t\t    ~(SOFT_ERR))\n\t\t\t\t\t\tprintf(\n\t\t\t\t\t\"%s: ARB new ring status = 0x%x\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t\t\t    ARB_INW(sc, arb,\n\t\t\t\t\t\t\tARB_RINGSTATUS));\n#endif /* TROPICDEBUG */\n\t\t\t\t}\n\t\t\t\tif (ARB_INW(sc, arb, ARB_RINGSTATUS) &\n\t\t\t\t    LOG_OFLOW){\n/*\n * XXX CMD_IN_SRB, handle with SRB_FREE_INT ?\n */\n\t\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD,\n\t\t\t\t\t    DIR_READ_LOG);\n\t\t\t\t\t/* Read & reset err log cmnd in SRB. */\n\t\t\t\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase XMIT_DATA_REQ: /* Adapter wants data to transmit */\n\t\t\t\t/* Call transmit interrupt handler */\n\t\t\t\ttr_oldxint(sc);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: Invalid command in ARB =%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, command);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Clear this interrupt bit */\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(ARB_CMD_INT)); \n\n\t\t\t/* Tell adapter that ARB is now free */\n\t\t\tACA_SETB(sc, ACA_ISRA_o, ARB_FREE);\n\t\t}\n\n\n\t\telse if (status & SSB_RESP_INT) {  /* SSB resp. to SRB cmd? */\n\t\t\tbus_size_t\tssb = sc->sc_ssb;\n\n\t\t\tretcode = SSB_INB(sc, ssb, SSB_RETCODE);\n\t\t\tcommand = SSB_INB(sc, ssb, SSB_CMD);\n\t\t\tswitch (command) {\n\t\t\tcase XMIT_UI_FRM:\n\t\t\tcase XMIT_DIR_FRAME:  /* SSB response to SRB xmit cmd */\n\t\t\t\t/* collect status on last packet */\n\t\t\t\tif (retcode != 0) {\n\t\t\t\t\tprintf(\"xmit return code = 0x%x\\n\",\n\t\t\t\t\t    retcode);\n\t\t\t\t\t/* XXXchb */\n\t\t\t\t\tif (retcode == 0x22) {\n\t\t\t\t\t\tprintf(\"FS = 0x%2x\\n\",\n\t\t\t\t\t\t    SSB_INB(sc, ssb,\n\t\t\t\t\t\t        SSB_XMITERR));\n\t\t\t\t\t}\n\t\t\t\t\tifp->if_oerrors++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tifp->if_opackets++;\n\n\t\t\t\tifp->if_flags &= ~IFF_OACTIVE;\n/*\n * XXX should this be done here ?\n */\n\t\t\t\t/* if data on send queue */\n\t\t\t\tif (!IF_EMPTYQUEUE(ifp->if_snd))\n\t\t\t\t\ttr_oldstart(ifp);\n\t\t\t\tbreak;\n\n\t\t\tcase XMIT_XID_CMD:\n\t\t\t\tprintf(\"tr_int: xmit XID return code = 0x%x\\n\",\n\t\t\t\t    retcode);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: SSB error, invalid command =%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, command);\n\t\t\t}\n\t\t\t/* clear this interrupt bit */\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SSB_RESP_INT));\n\n\t\t\t/* tell adapter that SSB is available */\n\t\t\tACA_SETB(sc, ACA_ISRA_o, SSB_FREE);\n\t\t}\n\t\trc = 1;\t\t/* Claim responsibility for interrupt */\n\t\tstatus = ACA_RDB(sc, ACA_ISRP_o);\n\t}\n\t/* Is this interrupt caused by an adapter error or access violation? */\n\tif (ACA_RDB(sc, ACA_ISRP_e) & (TCR_INT | ERR_INT | ACCESS_INT)) {\n\t\tprintf(\"%s: adapter error, ISRP_e = %x\\n\",\n\t\t    sc->sc_dev.dv_xname, ACA_RDB(sc, ACA_ISRP_e));\n\n\t\t/* Clear these interrupt bits */\n\t\tACA_RSTB(sc, ACA_ISRP_e, ~(TCR_INT | ERR_INT | ACCESS_INT));\n\t\trc = 1;\t\t/* Claim responsibility for interrupt */\n\n\t}\n\n\t/* Clear IRQ latch in order to reenable interrupts. */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_CLEARINT, 0);\n\treturn (rc);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_rint",
      "void\ttr_xint",
      "void\ttr_oldxint",
      "void\ttr_opensap",
      "void\ttr_timeout",
      "void\ttr_oldstart",
      "void\ttr_reinit",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_piot",
            "sc->sc_pioh",
            "TR_CLEARINT",
            "0"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RSTB",
          "args": [
            "sc",
            "ACA_ISRP_e",
            "~(TCR_INT | ERR_INT | ACCESS_INT)"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: adapter error, ISRP_e = %x\\n\"",
            "sc->sc_dev.dv_xname",
            "ACA_RDB(sc, ACA_ISRP_e)"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACA_RDB",
          "args": [
            "sc",
            "ACA_ISRP_e"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RDB",
          "args": [
            "sc",
            "ACA_ISRP_e"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RDB",
          "args": [
            "sc",
            "ACA_ISRP_o"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "SSB_FREE"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RSTB",
          "args": [
            "sc",
            "ACA_ISRP_o",
            "~(SSB_RESP_INT)"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_oldstart",
          "args": [
            "ifp"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "tr_oldstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "702-718",
          "snippet": "void\ntr_oldstart(ifp)\nstruct ifnet *ifp;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\tbus_size_t srb = sc->sc_srb;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/* Load SRB to request transmit. */\n\tSRB_OUTB(sc, srb, SRB_CMD, XMIT_UI_FRM);\n\tSRB_OUTW(sc, srb, XMIT_STATIONID, sc->exsap_station);\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_oldstart",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
            "struct ifnet *ifp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_oldstart;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_oldstart(ifp)\nstruct ifnet *ifp;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\tbus_size_t srb = sc->sc_srb;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/* Load SRB to request transmit. */\n\tSRB_OUTB(sc, srb, SRB_CMD, XMIT_UI_FRM);\n\tSRB_OUTW(sc, srb, XMIT_STATIONID, sc->exsap_station);\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_EMPTYQUEUE",
          "args": [
            "ifp->if_snd"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSB_INB",
          "args": [
            "sc",
            "ssb",
            "SSB_XMITERR"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSB_INB",
          "args": [
            "sc",
            "ssb",
            "SSB_CMD"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSB_INB",
          "args": [
            "sc",
            "ssb",
            "SSB_RETCODE"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "ARB_FREE"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RSTB",
          "args": [
            "sc",
            "ACA_ISRP_o",
            "~(ARB_CMD_INT)"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_oldxint",
          "args": [
            "sc"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "tr_oldxint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1298-1394",
          "snippet": "void\ntr_oldxint(sc)\nstruct tr_softc *sc;\n{\n\tbus_size_t arb = sc->sc_arb;\t/* pointer to ARB */\n\tbus_size_t asb = sc->sc_asb;\t/* pointer to ASB */\n\tbus_size_t dhb;\t\t\t/* pointer to DHB */\n\tstruct mbuf *m0;\t\t/* pointer to top of mbuf chain */\n\tu_short size = 0;\n\tchar\tcommand;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct token_header *trh;\n\tint i;\n\tu_int8_t hlen;\n\n/*\n * XXX xmit_asb_response()\n */\n\tif (ASB_INB(sc, asb, XMIT_RETCODE) != 0xff)\n\t\tprintf(\"tr_oldxint: ASB IS NOT FREE!!!\\n\");\n\n\t/* load parameters into ASB */\n\tASB_OUTB(sc, asb, XMIT_CMDCORR, ARB_INB(sc, arb, ARB_XMT_CMDCORR));\n\tASB_OUTW(sc, asb, XMIT_STATIONID, ARB_INW(sc, arb, ARB_STATIONID));\n\tASB_OUTB(sc, asb, XMIT_RETCODE, 0);\n/*\n * XXX LLC_{X25,ISO}_LSAP\n */\n\tASB_OUTB(sc, asb, XMIT_REMSAP, LLC_SNAP_LSAP);\n\n\t/* XXX if num_dhb == 2 this should alternate between the two buffers */\n\tdhb = ARB_INW(sc, arb, ARB_XMT_DHBADDR);\n\n\tcommand = SRB_INB(sc, sc->sc_srb, SRB_CMD);\n\n\tif (command == XMIT_XID_CMD || command == XMIT_TEST_CMD) {\n\t\tASB_OUTB(sc, asb, XMIT_CMD, command);\n\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, 0x11);\n/*\n * XXX 0xe == sizeof(struct token_header)\n */\n\t\tASB_OUTB(sc, asb, XMIT_HDRLEN, 0x0e);\n\n\t\tSR_OUTB(sc, (dhb + 0), TOKEN_AC);\n\t\tSR_OUTB(sc, (dhb + 1), TOKEN_FC);\n\t\t/* Load destination and source addresses. */\n\t\tfor (i=0; i < ISO88025_ADDR_LEN; i++) {\n\t\t\tSR_OUTB(sc, (dhb + 2 + i), 0xff);\n\t\t\tSR_OUTB(sc, (dhb + 8 + i), 0x00);\n\t\t}\n\t}\n\telse {\n/*\n * XXX what's command here ?  command = 0x0d (always ?)\n */\n\t\t/* if data in queue, copy mbuf chain to DHB */\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 != 0) {\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf)\n\t\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\t\t\t/* Pull packet off interface send queue, fill DHB. */\n\t\t\ttrh = mtod(m0, struct token_header *);\n\t\t\thlen = sizeof(struct token_header);\n\t\t\tif (trh->token_shost[0] & TOKEN_RI_PRESENT) {\n/*\n * XXX assumes route info is in the same mbuf as the token-ring header\n */\n\t\t\t\tstruct token_rif\t*rif;\n\n\t\t\t\trif = TOKEN_RIF(trh);\n\t\t\t\thlen += ((ntohs(rif->tr_rcf) & TOKEN_RCF_LEN_MASK) >> 8);\n\t\t\t}\n\t\t\tsize = tr_mbcopy(sc, dhb, m0);\n\t\t\tm_freem(m0);\n\n\t\t\tASB_OUTB(sc, asb, XMIT_CMD, XMIT_UI_FRM);  \n\t\t\tASB_OUTB(sc, asb, XMIT_HDRLEN, hlen);\n\n\t\t\t/* Set size of transmission frame in ASB. */\n\t\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, size);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%s: unexpected empty mbuf send queue\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t\t/* Set size of transmission frame in ASB to zero. */\n\t\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, 0);\n\t\t}\n\t}\n/*\n * XXX asb_response(void *asb, len)\n */\n\t/* tell adapter that there is a response in the ASB */\n\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_oldxint",
            "int\ttr_mbcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
            "struct ifnet *ifp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_oldxint;\nint\ttr_mbcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_oldxint(sc)\nstruct tr_softc *sc;\n{\n\tbus_size_t arb = sc->sc_arb;\t/* pointer to ARB */\n\tbus_size_t asb = sc->sc_asb;\t/* pointer to ASB */\n\tbus_size_t dhb;\t\t\t/* pointer to DHB */\n\tstruct mbuf *m0;\t\t/* pointer to top of mbuf chain */\n\tu_short size = 0;\n\tchar\tcommand;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct token_header *trh;\n\tint i;\n\tu_int8_t hlen;\n\n/*\n * XXX xmit_asb_response()\n */\n\tif (ASB_INB(sc, asb, XMIT_RETCODE) != 0xff)\n\t\tprintf(\"tr_oldxint: ASB IS NOT FREE!!!\\n\");\n\n\t/* load parameters into ASB */\n\tASB_OUTB(sc, asb, XMIT_CMDCORR, ARB_INB(sc, arb, ARB_XMT_CMDCORR));\n\tASB_OUTW(sc, asb, XMIT_STATIONID, ARB_INW(sc, arb, ARB_STATIONID));\n\tASB_OUTB(sc, asb, XMIT_RETCODE, 0);\n/*\n * XXX LLC_{X25,ISO}_LSAP\n */\n\tASB_OUTB(sc, asb, XMIT_REMSAP, LLC_SNAP_LSAP);\n\n\t/* XXX if num_dhb == 2 this should alternate between the two buffers */\n\tdhb = ARB_INW(sc, arb, ARB_XMT_DHBADDR);\n\n\tcommand = SRB_INB(sc, sc->sc_srb, SRB_CMD);\n\n\tif (command == XMIT_XID_CMD || command == XMIT_TEST_CMD) {\n\t\tASB_OUTB(sc, asb, XMIT_CMD, command);\n\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, 0x11);\n/*\n * XXX 0xe == sizeof(struct token_header)\n */\n\t\tASB_OUTB(sc, asb, XMIT_HDRLEN, 0x0e);\n\n\t\tSR_OUTB(sc, (dhb + 0), TOKEN_AC);\n\t\tSR_OUTB(sc, (dhb + 1), TOKEN_FC);\n\t\t/* Load destination and source addresses. */\n\t\tfor (i=0; i < ISO88025_ADDR_LEN; i++) {\n\t\t\tSR_OUTB(sc, (dhb + 2 + i), 0xff);\n\t\t\tSR_OUTB(sc, (dhb + 8 + i), 0x00);\n\t\t}\n\t}\n\telse {\n/*\n * XXX what's command here ?  command = 0x0d (always ?)\n */\n\t\t/* if data in queue, copy mbuf chain to DHB */\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 != 0) {\n#if NBPFILTER > 0\n\t\t\tif (ifp->if_bpf)\n\t\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\t\t\t/* Pull packet off interface send queue, fill DHB. */\n\t\t\ttrh = mtod(m0, struct token_header *);\n\t\t\thlen = sizeof(struct token_header);\n\t\t\tif (trh->token_shost[0] & TOKEN_RI_PRESENT) {\n/*\n * XXX assumes route info is in the same mbuf as the token-ring header\n */\n\t\t\t\tstruct token_rif\t*rif;\n\n\t\t\t\trif = TOKEN_RIF(trh);\n\t\t\t\thlen += ((ntohs(rif->tr_rcf) & TOKEN_RCF_LEN_MASK) >> 8);\n\t\t\t}\n\t\t\tsize = tr_mbcopy(sc, dhb, m0);\n\t\t\tm_freem(m0);\n\n\t\t\tASB_OUTB(sc, asb, XMIT_CMD, XMIT_UI_FRM);  \n\t\t\tASB_OUTB(sc, asb, XMIT_HDRLEN, hlen);\n\n\t\t\t/* Set size of transmission frame in ASB. */\n\t\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, size);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%s: unexpected empty mbuf send queue\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t\t/* Set size of transmission frame in ASB to zero. */\n\t\t\tASB_OUTW(sc, asb, XMIT_FRAMELEN, 0);\n\t\t}\n\t}\n/*\n * XXX asb_response(void *asb, len)\n */\n\t/* tell adapter that there is a response in the ASB */\n\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "CMD_IN_SRB"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CMD",
            "DIR_READ_LOG"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_RINGSTATUS"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_RINGSTATUS"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_RINGSTATUS"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "tr_reinit",
            "sc",
            "hz*30"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "tr_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1740-1748",
          "snippet": "void\ntr_timeout(arg)\nvoid\t*arg;\n{\n\tstruct tr_softc *sc = arg;\n\n\tprintf(\"Token Ring timeout\\n\");\n\twakeup(&sc->tr_sleepevent);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_timeout",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_timeout;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid\ntr_timeout(arg)\nvoid\t*arg;\n{\n\tstruct tr_softc *sc = arg;\n\n\tprintf(\"Token Ring timeout\\n\");\n\twakeup(&sc->tr_sleepevent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_qflush",
          "args": [
            "&ifp->if_snd"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_RINGSTATUS"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_rint",
          "args": [
            "sc"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "tr_rint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1192-1293",
          "snippet": "void\ntr_rint(sc)\nstruct tr_softc *sc;\n{\n\tbus_size_t arb = sc->sc_arb;\n\tbus_size_t asb = sc->sc_asb;\n\tstruct rbcb *rbc = &sc->rbc;\n\tstruct mbuf *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n#ifdef TROPICDEBUG\n\tprintf(\"tr_rint: arb.command = %x, arb.station_id= %x\\n\",\n\t    ARB_INB(sc, arb, ARB_CMD), ARB_INW(sc, arb, ARB_STATIONID));\n\tprintf(\"arb.buf_addr = %x, arb.lan_hdr_len = %x\\n\",\n\t    ARB_INW(sc, arb, ARB_RXD_BUFADDR),\n\t    ARB_INB(sc, arb, ARB_RXD_LANHDRLEN));\n\tprintf(\"arb.dlc_hdr_len = %d, arb.frame_len = %d\\n\",\n\t    ARB_INB(sc, arb, ARB_RXD_DLCHDRLEN),\n\t    ARB_INW(sc, arb, ARB_RXD_FRAMELEN));\n\tprintf(\"arb.msg_type = %x\\n\", ARB_INB(sc, arb, ARB_RXD_MSGTYPE));\n#endif /* TROPICDEBUG */\n\t/*\n\t * copy the offset in RAM of the first receive buffer from the\n\t * receive-data block of the adapter request block associated\n\t * with the unit's softc struct into the receive control block.\n\t */\n\trbc->rbufp = ARB_INW(sc, arb, ARB_RXD_BUFADDR);\n\n\t/*\n\t * copy the pointer to data in first receive buffer\n\t */\n\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\t/*\n\t * the token-ring header is viewed as two header structs: the physical\n\t * header (aka TR header) with access, frame, dest, src, and routing\n\t * information, and the logical link control header (aka LLC header)\n\t * with dsap, ssap, llc, proto and type fields.\n\t *\n\t * rfc1042 requires support for unnumbered information (UI) commands,\n\t * but does not specify a required semantic, so we'll discard them.\n\t *\n\t */\n\n\t/*\n\t * if there is a second receive buffer, set up the next pointer\n\t */\n\tif (RB_INW(sc, rbc->rbufp, RB_NEXTBUF))\n\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF) -\n\t\t    RB_NEXTBUF;\n\telse\n\t\trbc->rbufp_next = 0;\t/* we're finished */\n\n\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t/*\n\t * At this point we move the packet from the adapter to a chain\n\t * of mbufs\n\t */\n\tm = tr_get(sc, ARB_INW(sc, arb, ARB_RXD_FRAMELEN), ifp);\n/*\n * XXX Clear ARB interrupt here?\n */\n/*\n * XXX create a queue where the responses are buffered\n * XXX but is it really needed ?\n */\n\n\tif (ASB_INB(sc, asb, RECV_RETCODE) != 0xff)\n\t\tprintf(\"tr_rint: ASB IS NOT FREE!!!\\n\");\n\t/*\n\t * Load receive response into ASB.\n\t */\n\tASB_OUTB(sc, asb, RECV_CMD, REC_DATA);\n\tASB_OUTW(sc, asb, RECV_STATIONID, ARB_INW(sc, arb, ARB_STATIONID));\n\tASB_OUTW(sc, asb, RECV_RESP_RECBUFADDR,\n\t    ARB_INW(sc, arb, ARB_RXD_BUFADDR));\n\n\tif (m == 0) {\n\t\t/*\n\t\t * Tell adapter data lost, no mbufs.\n\t\t */\n\t\tASB_OUTB(sc, asb, RECV_RETCODE, 0x20);\n\t\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n\t\t++ifp->if_ierrors;\n#ifdef TROPICDEBUG\n\t\tprintf(\"tr_rint: packet dropped\\n\");\n#endif /* TROPICDEBUG */\n\t}\n\telse {\n\t\t/*\n\t\t * Indicate successful receive.\n\t\t */\n\t\tASB_OUTB(sc, asb, RECV_RETCODE, 0);\n\t\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n\t\t++ifp->if_ipackets;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\ttoken_input(ifp, m);\n\t}\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_rint",
            "struct\tmbuf *tr_get",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
            "struct ifnet *ifp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_rint;\nstruct\tmbuf *tr_get;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_rint(sc)\nstruct tr_softc *sc;\n{\n\tbus_size_t arb = sc->sc_arb;\n\tbus_size_t asb = sc->sc_asb;\n\tstruct rbcb *rbc = &sc->rbc;\n\tstruct mbuf *m;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n#ifdef TROPICDEBUG\n\tprintf(\"tr_rint: arb.command = %x, arb.station_id= %x\\n\",\n\t    ARB_INB(sc, arb, ARB_CMD), ARB_INW(sc, arb, ARB_STATIONID));\n\tprintf(\"arb.buf_addr = %x, arb.lan_hdr_len = %x\\n\",\n\t    ARB_INW(sc, arb, ARB_RXD_BUFADDR),\n\t    ARB_INB(sc, arb, ARB_RXD_LANHDRLEN));\n\tprintf(\"arb.dlc_hdr_len = %d, arb.frame_len = %d\\n\",\n\t    ARB_INB(sc, arb, ARB_RXD_DLCHDRLEN),\n\t    ARB_INW(sc, arb, ARB_RXD_FRAMELEN));\n\tprintf(\"arb.msg_type = %x\\n\", ARB_INB(sc, arb, ARB_RXD_MSGTYPE));\n#endif /* TROPICDEBUG */\n\t/*\n\t * copy the offset in RAM of the first receive buffer from the\n\t * receive-data block of the adapter request block associated\n\t * with the unit's softc struct into the receive control block.\n\t */\n\trbc->rbufp = ARB_INW(sc, arb, ARB_RXD_BUFADDR);\n\n\t/*\n\t * copy the pointer to data in first receive buffer\n\t */\n\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\t/*\n\t * the token-ring header is viewed as two header structs: the physical\n\t * header (aka TR header) with access, frame, dest, src, and routing\n\t * information, and the logical link control header (aka LLC header)\n\t * with dsap, ssap, llc, proto and type fields.\n\t *\n\t * rfc1042 requires support for unnumbered information (UI) commands,\n\t * but does not specify a required semantic, so we'll discard them.\n\t *\n\t */\n\n\t/*\n\t * if there is a second receive buffer, set up the next pointer\n\t */\n\tif (RB_INW(sc, rbc->rbufp, RB_NEXTBUF))\n\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF) -\n\t\t    RB_NEXTBUF;\n\telse\n\t\trbc->rbufp_next = 0;\t/* we're finished */\n\n\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t/*\n\t * At this point we move the packet from the adapter to a chain\n\t * of mbufs\n\t */\n\tm = tr_get(sc, ARB_INW(sc, arb, ARB_RXD_FRAMELEN), ifp);\n/*\n * XXX Clear ARB interrupt here?\n */\n/*\n * XXX create a queue where the responses are buffered\n * XXX but is it really needed ?\n */\n\n\tif (ASB_INB(sc, asb, RECV_RETCODE) != 0xff)\n\t\tprintf(\"tr_rint: ASB IS NOT FREE!!!\\n\");\n\t/*\n\t * Load receive response into ASB.\n\t */\n\tASB_OUTB(sc, asb, RECV_CMD, REC_DATA);\n\tASB_OUTW(sc, asb, RECV_STATIONID, ARB_INW(sc, arb, ARB_STATIONID));\n\tASB_OUTW(sc, asb, RECV_RESP_RECBUFADDR,\n\t    ARB_INW(sc, arb, ARB_RXD_BUFADDR));\n\n\tif (m == 0) {\n\t\t/*\n\t\t * Tell adapter data lost, no mbufs.\n\t\t */\n\t\tASB_OUTB(sc, asb, RECV_RETCODE, 0x20);\n\t\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n\t\t++ifp->if_ierrors;\n#ifdef TROPICDEBUG\n\t\tprintf(\"tr_rint: packet dropped\\n\");\n#endif /* TROPICDEBUG */\n\t}\n\telse {\n\t\t/*\n\t\t * Indicate successful receive.\n\t\t */\n\t\tASB_OUTB(sc, asb, RECV_RETCODE, 0);\n\t\tACA_SETB(sc, ACA_ISRA_o, RESP_IN_ASB);\n\t\t++ifp->if_ipackets;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\ttoken_input(ifp, m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARB_INW",
          "args": [
            "sc",
            "arb",
            "ARB_DLCSTAT_STATUS"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARB_INB",
          "args": [
            "sc",
            "arb",
            "ARB_CMD"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RSTB",
          "args": [
            "sc",
            "ACA_ISRP_o",
            "~(ASB_FREE_INT)"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_INB",
          "args": [
            "sc",
            "asb",
            "CMD_CMD"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASB_INB",
          "args": [
            "sc",
            "asb",
            "CMD_RETCODE"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RSTB",
          "args": [
            "sc",
            "ACA_ISRP_o",
            "~(SRB_RESP_INT)"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "log_srb",
            "SRB_LOG_TOKENERRS"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "log_srb",
            "SRB_LOG_FREQERRS"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "log_srb",
            "SRB_LOG_FCPYERRS"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "log_srb",
            "SRB_LOG_RCVCONG"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "log_srb",
            "SRB_LOG_LOSTFRMS"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "log_srb",
            "SRB_LOG_ABRTERRS"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "log_srb",
            "SRB_LOG_ACERRS"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "log_srb",
            "SRB_LOG_BRSTERRS"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "log_srb",
            "SRB_LOG_INTERRS"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "log_srb",
            "SRB_LOG_LINEERRS"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->tr_sleepevent"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "tr_timeout",
            "sc"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INW",
          "args": [
            "sc",
            "sap_srb",
            "SRB_OPNSAP_STATIONID"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sap_srb",
            "SRB_OPNSAP_SAPVALUE"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "tr_timeout",
            "sc"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "tr_timeout",
            "sc"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "srb",
            "SRB_RETCODE"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_opensap",
          "args": [
            "sc",
            "LLC_SNAP_LSAP"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "tr_opensap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1668-1712",
          "snippet": "void\ntr_opensap(sc, type) \nstruct tr_softc *sc;\nu_char type;\n{\n\tbus_size_t srb = sc->sc_srb;\n\n/************************************************************************\n ** To use the SAP level interface, we will have to execute a          ** \n ** DLC.OPEN.SAP (pg.6-61 of the Token Ring Tech. Ref.) after we have  **\n ** received a good return code from the DIR.OPEN.ADAPTER command.     **\n ** We will open the IP SAP x'aa'.                                     **\n **                                                                    **\n ** STEPS:                                                             **\n **      1) Reset SRB response interrupt bit                           **\n **      2) Use the open_sap srb.                                      **\n **      3) Fill the following fields:                                 **\n **            command    - x'15'                                      **\n **            sap_value  - x'aa'                                      **\n **            sap_options- x'24'                                      **\n **                                                                    **\n ***********************************************************************/\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tSRB_OUTB(sc, srb, SRB_CMD, DLC_OPEN_SAP);  \n\tSRB_OUTB(sc, srb, SRB_RETCODE, 0x00);  \n\tSRB_OUTW(sc, srb, SRB_OPNSAP_STATIONID, 0x0000);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERT1, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERT2, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERTI, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXOUT, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXIN, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXOUTINCR, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXRETRY, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_GSAPMAXMEMB, 0x00);\n\tSRB_OUTW(sc, srb, SRB_OPNSAP_MAXIFIELD, 0x0088);  \n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPVALUE, type);     \n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPOPTIONS, 0x24);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_STATIONCNT, 0x01);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPGSAPMEMB, 0x00);\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_opensap",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_opensap;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid\ntr_opensap(sc, type) \nstruct tr_softc *sc;\nu_char type;\n{\n\tbus_size_t srb = sc->sc_srb;\n\n/************************************************************************\n ** To use the SAP level interface, we will have to execute a          ** \n ** DLC.OPEN.SAP (pg.6-61 of the Token Ring Tech. Ref.) after we have  **\n ** received a good return code from the DIR.OPEN.ADAPTER command.     **\n ** We will open the IP SAP x'aa'.                                     **\n **                                                                    **\n ** STEPS:                                                             **\n **      1) Reset SRB response interrupt bit                           **\n **      2) Use the open_sap srb.                                      **\n **      3) Fill the following fields:                                 **\n **            command    - x'15'                                      **\n **            sap_value  - x'aa'                                      **\n **            sap_options- x'24'                                      **\n **                                                                    **\n ***********************************************************************/\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tSRB_OUTB(sc, srb, SRB_CMD, DLC_OPEN_SAP);  \n\tSRB_OUTB(sc, srb, SRB_RETCODE, 0x00);  \n\tSRB_OUTW(sc, srb, SRB_OPNSAP_STATIONID, 0x0000);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERT1, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERT2, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_TIMERTI, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXOUT, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXIN, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXOUTINCR, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_MAXRETRY, 0x00);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_GSAPMAXMEMB, 0x00);\n\tSRB_OUTW(sc, srb, SRB_OPNSAP_MAXIFIELD, 0x0088);  \n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPVALUE, type);     \n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPOPTIONS, 0x24);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_STATIONCNT, 0x01);\n\tSRB_OUTB(sc, srb, SRB_OPNSAP_SAPGSAPMEMB, 0x00);\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "tr_timeout",
            "sc"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_INW",
          "args": [
            "sc",
            "TXCA_BUFFER_COUNT"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INW",
          "args": [
            "sc",
            "srb",
            "SRB_OPENRESP_ASBADDR"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INW",
          "args": [
            "sc",
            "srb",
            "SRB_OPENRESP_SRBADDR"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INW",
          "args": [
            "sc",
            "srb",
            "SRB_OPENRESP_ARBADDR"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INW",
          "args": [
            "sc",
            "srb",
            "SRB_OPENRESP_SSBADDR"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "srb",
            "SRB_CMD"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "srb",
            "SRB_RETCODE"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RDW",
          "args": [
            "sc",
            "ACA_WRBR"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_xint",
          "args": [
            "sc"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "tr_xint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1399-1435",
          "snippet": "void\ntr_xint(sc)\nstruct tr_softc *sc;\n{\n\tu_short\ttail;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_size_t txbuf;\n\n\t/*\n\t * To prevent race conditions on 8-bit cards when reading or writing\n\t * 16-bit values. See page 4-12 of the IBM manual.\n\t * XXX use volatile ?\n\t */\n\tdo {\n\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t} while (tail != TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL));\n\twhile (tail != TXCA_INW(sc, TXCA_FREE_QUEUE_TAIL)) {\n\t\ttxbuf =  TXCA_INW(sc, TXCA_FREE_QUEUE_TAIL) - XMIT_NEXTBUF;\n\t\ttxbuf =  TXB_INW(sc, txbuf, XMIT_NEXTBUF) - XMIT_NEXTBUF;\n\t\tif (TXB_INB(sc, txbuf, XMIT_RETCODE) != 0) {\n\t\t\tifp->if_oerrors++;\n\t\t\tprintf(\"tx: retcode = %x\\n\",\n\t\t\t    TXB_INB(sc, txbuf, XMIT_RETCODE));\n\t\t}\n\t\tsc->sc_xmit_buffers +=\n\t\t    (TXB_INW(sc, txbuf, XMIT_FRAMELEN) + 514 - 1) / 514;\n\t\ttail = TXB_INW(sc, txbuf, XMIT_LASTBUF);\n\t\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_TAIL, tail);\n\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t\tdo {\n\t\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t\t} while (tail != TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL));\n\t}\n\tif (sc->sc_xmit_buffers == sc->sc_nbuf)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\ttr_start(ifp);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_xint",
            "void\ttr_start",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
            "struct ifnet *ifp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_xint;\nvoid\ttr_start;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_xint(sc)\nstruct tr_softc *sc;\n{\n\tu_short\ttail;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_size_t txbuf;\n\n\t/*\n\t * To prevent race conditions on 8-bit cards when reading or writing\n\t * 16-bit values. See page 4-12 of the IBM manual.\n\t * XXX use volatile ?\n\t */\n\tdo {\n\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t} while (tail != TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL));\n\twhile (tail != TXCA_INW(sc, TXCA_FREE_QUEUE_TAIL)) {\n\t\ttxbuf =  TXCA_INW(sc, TXCA_FREE_QUEUE_TAIL) - XMIT_NEXTBUF;\n\t\ttxbuf =  TXB_INW(sc, txbuf, XMIT_NEXTBUF) - XMIT_NEXTBUF;\n\t\tif (TXB_INB(sc, txbuf, XMIT_RETCODE) != 0) {\n\t\t\tifp->if_oerrors++;\n\t\t\tprintf(\"tx: retcode = %x\\n\",\n\t\t\t    TXB_INB(sc, txbuf, XMIT_RETCODE));\n\t\t}\n\t\tsc->sc_xmit_buffers +=\n\t\t    (TXB_INW(sc, txbuf, XMIT_FRAMELEN) + 514 - 1) / 514;\n\t\ttail = TXB_INW(sc, txbuf, XMIT_LASTBUF);\n\t\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_TAIL, tail);\n\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t\tdo {\n\t\t\ttail = TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL);\n\t\t} while (tail != TXCA_INW(sc, TXCA_COMPLETION_QUEUE_TAIL));\n\t}\n\tif (sc->sc_xmit_buffers == sc->sc_nbuf)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\ttr_start(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACA_RSTB",
          "args": [
            "sc",
            "ACA_ISRP_o",
            "~(XMIT_COMPLETE)"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RSTB",
          "args": [
            "sc",
            "ACA_ISRP_o",
            "~(ADAP_CHK_INT)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "ACA_RDW(sc, ACA_WWCR)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RDW",
          "args": [
            "sc",
            "ACA_WWCR"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RDB",
          "args": [
            "sc",
            "ACA_ISRP_o"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_rint;\nvoid\ttr_xint;\nvoid\ttr_oldxint;\nvoid\ttr_opensap;\nvoid\ttr_timeout;\nvoid\ttr_oldstart;\nvoid\ttr_reinit;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nint\ntr_intr(arg)\n\tvoid *arg;\n{\n\tstruct tr_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_char status;\t/* holds status from adapter status register */\n\tu_char command;\t/* holds command from status or request block */\n\tu_char retcode;\t/* holds return value from status or request block */\n\tint rc = 0;\t/* 0 = unclaimed interrupt, 1 = interrupt claimed */\n\n\tstatus = ACA_RDB(sc, ACA_ISRP_o);\n\twhile (status != 0) {\n\n\t\t/* Is this interrupt caused by an adapter check? */\n\t\tif (status & ADAP_CHK_INT) {\n\t\t\tprintf(\"%s: adapter check 0x%04x\\n\",\n\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t    (unsigned int)ntohs(ACA_RDW(sc, ACA_WWCR)));\n\n\t\t\t/* Clear this interrupt bit */\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(ADAP_CHK_INT));\n\n\t\t\trc = 1;\t\t/* Claim interrupt. */\n\t\t\tbreak;\t\t/* Terminate loop. */\n\t\t}\n\t\telse if (status & XMIT_COMPLETE) {\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(XMIT_COMPLETE));\n\t\t\ttr_xint(sc);\n\t\t\trc = 1;\n\t\t}\n\n\t\t/*\n\t\t * Process SRB_RESP_INT, ASB_FREE_INT, ARB_CMD_INT\n\t\t * & SSB_RESP_INT in that order, ISRP-L Hi to Lo\n\t\t */\n\t\telse if (status & SRB_RESP_INT) { /* Adapter response in SRB? */\n\t\t\tbus_size_t sap_srb;\n\t\t\tbus_size_t srb;\n#ifdef TROPICDEBUG\n\t\t\tbus_size_t log_srb;\n#endif\n\t\t\tif (sc->sc_srb == 0)\n\t\t\t\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\t\t\tsrb = sc->sc_srb; /* pointer to SRB */\n\t\t\tretcode = SRB_INB(sc, srb, SRB_RETCODE);\n\t\t\tcommand = SRB_INB(sc, srb, SRB_CMD);\n\t\t\tswitch (command) {\n\t\t\tcase 0x80: /* 0x80 == initialization complete */\n\t\t\tcase DIR_CONFIG_FAST_PATH_RAM:\n\t\t\t\tbreak;\n\t\t\tcase XMIT_DIR_FRAME:\t/* Response to xmit request */\n\t\t\tcase XMIT_UI_FRM:\t/* Response to xmit request */\n\t\t\t\t/* Response not valid? */\n\t\t\t\tif (retcode != 0xff)\n\t\t\t\t\tprintf(\"%s: error on xmit request =%x\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname, retcode);\n\t\t\t\tbreak;\n\n\t\t\tcase DIR_OPEN_ADAPTER:\t/* open-adapter-cmd response */\n\t\t\t\t/* Open successful? */\n\t\t\t\tif (retcode == 0) {\n\t\t\t\t\tifp->if_flags |= IFF_UP | IFF_RUNNING;\n\t\t\t\t\t/* Save new ACA ctrl block addresses */\n\t\t\t\t\tsc->sc_ssb = SRB_INW(sc, srb,\n\t\t\t\t\t    SRB_OPENRESP_SSBADDR);\n\t\t\t\t\tsc->sc_arb = SRB_INW(sc, srb,\n\t\t\t\t\t    SRB_OPENRESP_ARBADDR);\n\t\t\t\t\tsc->sc_srb = SRB_INW(sc, srb,\n\t\t\t\t\t    SRB_OPENRESP_SRBADDR);\n\t\t\t\t\tsc->sc_asb = SRB_INW(sc, srb,\n\t\t\t\t\t    SRB_OPENRESP_ASBADDR);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX, what about LLC_{X25,ISO}_LSAP ?\n\t\t\t\t\t * open two more saps .....\n\t\t\t\t\t */\n\t\t\t\t\tif (sc->sc_init_status &\n\t\t\t\t\t    FAST_PATH_TRANSMIT) {\n\t\t\t\t\t\tsc->sc_xmit_buffers =\n\t\t\t\t\t\t    TXCA_INW(sc, TXCA_BUFFER_COUNT);\n\t\t\t\t\t\tsc->sc_nbuf =\n\t\t\t\t\t\t    sc->sc_xmit_buffers;\n#ifdef TROPICDEBUG\n\t\t\t\t\t\tprintf(\"buffers = %d\\n\",\n\t\t\t\t\t\t    sc->sc_xmit_buffers);\n#endif\n\t\t\t\t\t\tsc->sc_xmit_correlator = 0;\n\t\t\t\t\t\tuntimeout(tr_timeout, sc);\n\t\t\t\t\t\twakeup(&sc->tr_sleepevent);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\ttr_opensap(sc, LLC_SNAP_LSAP); \n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"%s: Open error = %x\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t\t    SRB_INB(sc, srb, SRB_RETCODE));\n\t\t\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\t\t\tifp->if_flags &= ~IFF_UP;\n/*\n * XXX untimeout depending on the error, timeout in other cases\n * XXX error 0x24 && autospeed mode: open again !!!!\n */\n\t\t\t\t\ttimeout(tr_init, sc, hz*30);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DIR_CLOSE:\t/* Response to close adapter command */\n\t\t\t\t/* Close not successful? */\n\t\t\t\tif (retcode != 0)\n\t\t\t\t\tprintf(\"%s: close error = %x\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname, retcode);\n\t\t\t\telse {\n\t\t\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\t\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\t\t\t\tuntimeout(tr_timeout, sc);\n\t\t\t\t\twakeup(&sc->tr_sleepevent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DIR_SET_DEFAULT_RING_SPEED:\n\t\t\t\tuntimeout(tr_timeout, sc);\n\t\t\t\twakeup(&sc->tr_sleepevent);\n\t\t\t\tbreak;\n\n\t\t\tcase DLC_OPEN_SAP:     \t/* Response to open sap cmd */\n\t\t\t\tsap_srb = sc->sc_srb;\n\t\t\t\tif (SRB_INB(sc, sap_srb, SRB_OPNSAP_SAPVALUE)\n\t\t\t\t    == LLC_SNAP_LSAP)\n\t\t\t\t\tsc->exsap_station =\n\t\t\t\t\t    SRB_INW(sc, sap_srb,\n\t\t\t\t\t        SRB_OPNSAP_STATIONID);\n\t\t\t\tprintf(\"%s: Token Ring opened\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tuntimeout(tr_timeout, sc);\n\t\t\t\twakeup(&sc->tr_sleepevent);\n\t\t\t\tbreak;\n/* XXX DLC_CLOSE_SAP not needed ? */\n\t\t\tcase DLC_CLOSE_SAP: /* Response to close sap cmd */\n\t\t\t\tbreak;\n\t\t\tcase DIR_READ_LOG:   /* Response to read log */\n\t\t\t\t/* Cmd not successful? */\n\t\t\t\tif (retcode != 0)\n\t\t\t\t\tprintf(\"%s: read error log cmd err =%x\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname, retcode);\n#ifdef TROPICDEBUG\n\t\t\t\tlog_srb = sc->sc_srb;\n\t\t\t\tprintf(\"%s: ERROR LOG:\\n\",sc->sc_dev.dv_xname);\n\t\t\t\tprintf(\"%s: Line=%d, Internal=%d, Burst=%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_LINEERRS)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_INTERRS)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_BRSTERRS)));\n\t\t\t\tprintf(\"%s: A/C=%d, Abort=%d, Lost frames=%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_ACERRS)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_ABRTERRS)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_LOSTFRMS)));\n\t\t\t\tprintf(\"%s: Receive congestion=%d, Frame copied=%d, Frequency=%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_RCVCONG)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_FCPYERRS)),\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_FREQERRS)));\n\t\t\t\tprintf(\"%s: Token=%d\\n\",sc->sc_dev.dv_xname,\n\t\t\t\t    (SRB_INB(sc, log_srb, SRB_LOG_TOKENERRS)));\n#endif /* TROPICDEBUG */\n\t\t\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: bad SRB command encountered %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, command);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* clear the SRB-response interrupt bit */\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\t\t}\n\n\t\telse if (status & ASB_FREE_INT) { /* Is ASB Free? */\n\t\t\tbus_size_t asb = sc->sc_asb;\n\n\t\t\t/*\n\t\t\t * Remove message from asb queue, first element in\n\t\t\t * structure is the command. command == REC_DATA?\n\t\t\t * size = 8 : size = 10\n\t\t\t * reply in isra_l with (RESP_IN_ASB | ASB_FREE)\n\t\t\t */\n\t\t\tretcode = ASB_INB(sc, asb, CMD_RETCODE);\n\t\t\tcommand = ASB_INB(sc, asb, CMD_CMD);\n\t\t\tswitch (command) {\n\t\t\tcase REC_DATA:\t\t/* Receive */\n\t\t\t\t/* Response not valid? */\n\t\t\t\tif (retcode != 0xff)\n\t\t\t\tprintf(\"%s: ASB bad receive response =%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, retcode);\n\t\t\t\tbreak;\n\t\t\tcase XMIT_DIR_FRAME:\t/* Transmit */\n\t\t\tcase XMIT_UI_FRM:   \t/* Transmit */\n\t\t\t\t/* Response not valid? */\n\t\t\t\tif (retcode != 0xff)\n\t\t\t\tprintf(\"%s: ASB response err on xmit =%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, retcode);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: Invalid command in ASB =%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, command);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Clear this interrupt bit */\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(ASB_FREE_INT));\n\t\t}\n\t\telse if (status & ARB_CMD_INT) { /* Command for PC to handle? */\n\t\t\tbus_size_t arb = sc->sc_arb;\n\n\t\t\tcommand = ARB_INB(sc, arb, ARB_CMD);\n\t\t\tswitch (command) {\n\t\t\tcase DLC_STATUS:    /* DLC status change */\t\n\t\t\t\tprintf(\"%s: ARB new DLC  status = 0x%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t    ARB_INW(sc, arb, ARB_DLCSTAT_STATUS));\n\t\t\t\tbreak;\n\t\t\tcase REC_DATA:\t\t/* Adapter has data for PC */\n\t\t\t\t/* Call receive interrupt handler */\n\t\t\t\ttr_rint(sc);\n\t\t\t\tbreak;\n\n\t\t\tcase RING_STAT_CHANGE:\t/* Ring status change */\n\t\t\t\tif (ARB_INW(sc, arb, ARB_RINGSTATUS) &\n\t\t\t\t    (SIGNAL_LOSS + LOBE_FAULT)){\n\t\t\t\t\tprintf(\"%s: SIGNAL LOSS/LOBE FAULT\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\t\t\tif_qflush(&ifp->if_snd);\n\t\t\t\t\ttimeout(tr_reinit, sc ,hz*30);\n\t\t\t\t}\n\t\t\t\telse {\n#ifdef TROPICDEBUG\n\t\t\t\t\tif (ARB_INW(sc, arb, ARB_RINGSTATUS) &\n\t\t\t\t\t    ~(SOFT_ERR))\n\t\t\t\t\t\tprintf(\n\t\t\t\t\t\"%s: ARB new ring status = 0x%x\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t\t\t    ARB_INW(sc, arb,\n\t\t\t\t\t\t\tARB_RINGSTATUS));\n#endif /* TROPICDEBUG */\n\t\t\t\t}\n\t\t\t\tif (ARB_INW(sc, arb, ARB_RINGSTATUS) &\n\t\t\t\t    LOG_OFLOW){\n/*\n * XXX CMD_IN_SRB, handle with SRB_FREE_INT ?\n */\n\t\t\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\t\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD,\n\t\t\t\t\t    DIR_READ_LOG);\n\t\t\t\t\t/* Read & reset err log cmnd in SRB. */\n\t\t\t\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase XMIT_DATA_REQ: /* Adapter wants data to transmit */\n\t\t\t\t/* Call transmit interrupt handler */\n\t\t\t\ttr_oldxint(sc);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: Invalid command in ARB =%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, command);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Clear this interrupt bit */\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(ARB_CMD_INT)); \n\n\t\t\t/* Tell adapter that ARB is now free */\n\t\t\tACA_SETB(sc, ACA_ISRA_o, ARB_FREE);\n\t\t}\n\n\n\t\telse if (status & SSB_RESP_INT) {  /* SSB resp. to SRB cmd? */\n\t\t\tbus_size_t\tssb = sc->sc_ssb;\n\n\t\t\tretcode = SSB_INB(sc, ssb, SSB_RETCODE);\n\t\t\tcommand = SSB_INB(sc, ssb, SSB_CMD);\n\t\t\tswitch (command) {\n\t\t\tcase XMIT_UI_FRM:\n\t\t\tcase XMIT_DIR_FRAME:  /* SSB response to SRB xmit cmd */\n\t\t\t\t/* collect status on last packet */\n\t\t\t\tif (retcode != 0) {\n\t\t\t\t\tprintf(\"xmit return code = 0x%x\\n\",\n\t\t\t\t\t    retcode);\n\t\t\t\t\t/* XXXchb */\n\t\t\t\t\tif (retcode == 0x22) {\n\t\t\t\t\t\tprintf(\"FS = 0x%2x\\n\",\n\t\t\t\t\t\t    SSB_INB(sc, ssb,\n\t\t\t\t\t\t        SSB_XMITERR));\n\t\t\t\t\t}\n\t\t\t\t\tifp->if_oerrors++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tifp->if_opackets++;\n\n\t\t\t\tifp->if_flags &= ~IFF_OACTIVE;\n/*\n * XXX should this be done here ?\n */\n\t\t\t\t/* if data on send queue */\n\t\t\t\tif (!IF_EMPTYQUEUE(ifp->if_snd))\n\t\t\t\t\ttr_oldstart(ifp);\n\t\t\t\tbreak;\n\n\t\t\tcase XMIT_XID_CMD:\n\t\t\t\tprintf(\"tr_int: xmit XID return code = 0x%x\\n\",\n\t\t\t\t    retcode);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: SSB error, invalid command =%x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, command);\n\t\t\t}\n\t\t\t/* clear this interrupt bit */\n\t\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SSB_RESP_INT));\n\n\t\t\t/* tell adapter that SSB is available */\n\t\t\tACA_SETB(sc, ACA_ISRA_o, SSB_FREE);\n\t\t}\n\t\trc = 1;\t\t/* Claim responsibility for interrupt */\n\t\tstatus = ACA_RDB(sc, ACA_ISRP_o);\n\t}\n\t/* Is this interrupt caused by an adapter error or access violation? */\n\tif (ACA_RDB(sc, ACA_ISRP_e) & (TCR_INT | ERR_INT | ACCESS_INT)) {\n\t\tprintf(\"%s: adapter error, ISRP_e = %x\\n\",\n\t\t    sc->sc_dev.dv_xname, ACA_RDB(sc, ACA_ISRP_e));\n\n\t\t/* Clear these interrupt bits */\n\t\tACA_RSTB(sc, ACA_ISRP_e, ~(TCR_INT | ERR_INT | ACCESS_INT));\n\t\trc = 1;\t\t/* Claim responsibility for interrupt */\n\n\t}\n\n\t/* Clear IRQ latch in order to reenable interrupts. */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_CLEARINT, 0);\n\treturn (rc);\n}"
  },
  {
    "function_name": "tr_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "720-803",
    "snippet": "void\ntr_start(ifp)\nstruct ifnet *ifp;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\tbus_size_t first_txbuf, txbuf;\n\tstruct mbuf\t*m0, *m;\n\tint\tsize, bufspace;\n\tbus_size_t framedata;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\nnext:\n\tif (sc->sc_xmit_buffers < sc->sc_minbuf)\n\t\treturn;\n\n\t/* if data in queue, copy mbuf chain to fast path buffers */\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\n\tif (m0 == 0)\n\t\treturn;\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\tfirst_txbuf = txbuf = TXCA_INW(sc, TXCA_FREE_QUEUE_HEAD) - XMIT_NEXTBUF;\n\tframedata = txbuf + XMIT_FP_DATA;\n\tsize = 0;\n\tbufspace = FP_BUF_LEN - XMIT_FP_DATA;\n\t--sc->sc_xmit_buffers;\n\tfor (m = m0; m; m = m->m_next) {\n\t\tint len = m->m_len;\n\t\tchar *ptr = mtod(m, char *);\n\n\t\twhile (len >= bufspace) {\n\t\t\t--sc->sc_xmit_buffers;\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t\t    framedata, ptr, bufspace);\n\t\t\tsize += bufspace;\n\t\t\tptr += bufspace;\n\t\t\tlen -= bufspace;\n\t\t\tTXB_OUTW(sc, txbuf, XMIT_BUFLEN,\n\t\t\t    (FP_BUF_LEN - XMIT_FP_DATA));\n\t\t\ttxbuf = TXB_INW(sc, txbuf, XMIT_NEXTBUF) - XMIT_NEXTBUF;\n\t\t\tframedata =  txbuf + XMIT_FP_DATA;\n\t\t\tbufspace = FP_BUF_LEN - XMIT_FP_DATA;\n\t\t}\n\t\tif (len > 0) {\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t\t    framedata, ptr, len);\n\t\t\tsize += len;\n\t\t\tbufspace -= len;\n\t\t\tframedata += len;\n\t\t}\n\t}\n\tTXB_OUTW(sc, txbuf, XMIT_BUFLEN, (FP_BUF_LEN - XMIT_FP_DATA - bufspace));\n\tm_freem(m0);\t\t/* free mbuf chain */\n\n\tTXB_OUTB(sc, first_txbuf, XMIT_RETCODE, 0xfe);\n\tTXB_OUTW(sc, first_txbuf, XMIT_FRAMELEN, size);\n\tTXB_OUTW(sc, first_txbuf, XMIT_LASTBUF, (txbuf + XMIT_NEXTBUF));\n\tTXB_OUTB(sc, first_txbuf, XMIT_CMD, XMIT_DIR_FRAME);\n\tTXB_OUTW(sc, first_txbuf, XMIT_STATIONID, 0);\n\tTXB_OUTB(sc, first_txbuf, XMIT_CMDCORR, sc->sc_xmit_correlator);\n\tsc->sc_xmit_correlator = (sc->sc_xmit_correlator + 1) & 0x7f;\n\n\t/*\n\t * To prevent race conditions on 8-bit cards when reading or writing\n\t * 16-bit values. See page 4-12 of the IBM manual.\n\t */\n\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_HEAD, 1);\n\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_HEAD, TXB_INW(sc, txbuf, XMIT_NEXTBUF));\n\n\tACA_SETB(sc, ACA_ISRA_o, XMIT_REQ);\n\n\tifp->if_flags |= IFF_OACTIVE;\n\tifp->if_opackets++;\n#if 1\n/* XXX do while construction */\n\tgoto next;\n#endif\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_start",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "XMIT_REQ"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_OUTW",
          "args": [
            "sc",
            "TXCA_FREE_QUEUE_HEAD",
            "TXB_INW(sc, txbuf, XMIT_NEXTBUF)"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_INW",
          "args": [
            "sc",
            "txbuf",
            "XMIT_NEXTBUF"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_OUTW",
          "args": [
            "sc",
            "TXCA_FREE_QUEUE_HEAD",
            "1"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_OUTB",
          "args": [
            "sc",
            "first_txbuf",
            "XMIT_CMDCORR",
            "sc->sc_xmit_correlator"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_OUTW",
          "args": [
            "sc",
            "first_txbuf",
            "XMIT_STATIONID",
            "0"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_OUTB",
          "args": [
            "sc",
            "first_txbuf",
            "XMIT_CMD",
            "XMIT_DIR_FRAME"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_OUTW",
          "args": [
            "sc",
            "first_txbuf",
            "XMIT_LASTBUF",
            "(txbuf + XMIT_NEXTBUF)"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_OUTW",
          "args": [
            "sc",
            "first_txbuf",
            "XMIT_FRAMELEN",
            "size"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_OUTB",
          "args": [
            "sc",
            "first_txbuf",
            "XMIT_RETCODE",
            "0xfe"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_OUTW",
          "args": [
            "sc",
            "txbuf",
            "XMIT_BUFLEN",
            "(FP_BUF_LEN - XMIT_FP_DATA - bufspace)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_sramh",
            "framedata",
            "ptr",
            "len"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_INW",
          "args": [
            "sc",
            "txbuf",
            "XMIT_NEXTBUF"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXB_OUTW",
          "args": [
            "sc",
            "txbuf",
            "XMIT_BUFLEN",
            "(FP_BUF_LEN - XMIT_FP_DATA)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_sramh",
            "framedata",
            "ptr",
            "bufspace"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "char*"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXCA_INW",
          "args": [
            "sc",
            "TXCA_FREE_QUEUE_HEAD"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_start;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_start(ifp)\nstruct ifnet *ifp;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\tbus_size_t first_txbuf, txbuf;\n\tstruct mbuf\t*m0, *m;\n\tint\tsize, bufspace;\n\tbus_size_t framedata;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\nnext:\n\tif (sc->sc_xmit_buffers < sc->sc_minbuf)\n\t\treturn;\n\n\t/* if data in queue, copy mbuf chain to fast path buffers */\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\n\tif (m0 == 0)\n\t\treturn;\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\tfirst_txbuf = txbuf = TXCA_INW(sc, TXCA_FREE_QUEUE_HEAD) - XMIT_NEXTBUF;\n\tframedata = txbuf + XMIT_FP_DATA;\n\tsize = 0;\n\tbufspace = FP_BUF_LEN - XMIT_FP_DATA;\n\t--sc->sc_xmit_buffers;\n\tfor (m = m0; m; m = m->m_next) {\n\t\tint len = m->m_len;\n\t\tchar *ptr = mtod(m, char *);\n\n\t\twhile (len >= bufspace) {\n\t\t\t--sc->sc_xmit_buffers;\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t\t    framedata, ptr, bufspace);\n\t\t\tsize += bufspace;\n\t\t\tptr += bufspace;\n\t\t\tlen -= bufspace;\n\t\t\tTXB_OUTW(sc, txbuf, XMIT_BUFLEN,\n\t\t\t    (FP_BUF_LEN - XMIT_FP_DATA));\n\t\t\ttxbuf = TXB_INW(sc, txbuf, XMIT_NEXTBUF) - XMIT_NEXTBUF;\n\t\t\tframedata =  txbuf + XMIT_FP_DATA;\n\t\t\tbufspace = FP_BUF_LEN - XMIT_FP_DATA;\n\t\t}\n\t\tif (len > 0) {\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t\t    framedata, ptr, len);\n\t\t\tsize += len;\n\t\t\tbufspace -= len;\n\t\t\tframedata += len;\n\t\t}\n\t}\n\tTXB_OUTW(sc, txbuf, XMIT_BUFLEN, (FP_BUF_LEN - XMIT_FP_DATA - bufspace));\n\tm_freem(m0);\t\t/* free mbuf chain */\n\n\tTXB_OUTB(sc, first_txbuf, XMIT_RETCODE, 0xfe);\n\tTXB_OUTW(sc, first_txbuf, XMIT_FRAMELEN, size);\n\tTXB_OUTW(sc, first_txbuf, XMIT_LASTBUF, (txbuf + XMIT_NEXTBUF));\n\tTXB_OUTB(sc, first_txbuf, XMIT_CMD, XMIT_DIR_FRAME);\n\tTXB_OUTW(sc, first_txbuf, XMIT_STATIONID, 0);\n\tTXB_OUTB(sc, first_txbuf, XMIT_CMDCORR, sc->sc_xmit_correlator);\n\tsc->sc_xmit_correlator = (sc->sc_xmit_correlator + 1) & 0x7f;\n\n\t/*\n\t * To prevent race conditions on 8-bit cards when reading or writing\n\t * 16-bit values. See page 4-12 of the IBM manual.\n\t */\n\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_HEAD, 1);\n\tTXCA_OUTW(sc, TXCA_FREE_QUEUE_HEAD, TXB_INW(sc, txbuf, XMIT_NEXTBUF));\n\n\tACA_SETB(sc, ACA_ISRA_o, XMIT_REQ);\n\n\tifp->if_flags |= IFF_OACTIVE;\n\tifp->if_opackets++;\n#if 1\n/* XXX do while construction */\n\tgoto next;\n#endif\n}"
  },
  {
    "function_name": "tr_oldstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "702-718",
    "snippet": "void\ntr_oldstart(ifp)\nstruct ifnet *ifp;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\tbus_size_t srb = sc->sc_srb;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/* Load SRB to request transmit. */\n\tSRB_OUTB(sc, srb, SRB_CMD, XMIT_UI_FRM);\n\tSRB_OUTW(sc, srb, XMIT_STATIONID, sc->exsap_station);\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_oldstart",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "CMD_IN_SRB"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTW",
          "args": [
            "sc",
            "srb",
            "XMIT_STATIONID",
            "sc->exsap_station"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "srb",
            "SRB_CMD",
            "XMIT_UI_FRM"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_oldstart;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_oldstart(ifp)\nstruct ifnet *ifp;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\tbus_size_t srb = sc->sc_srb;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/* Load SRB to request transmit. */\n\tSRB_OUTB(sc, srb, SRB_CMD, XMIT_UI_FRM);\n\tSRB_OUTW(sc, srb, XMIT_STATIONID, sc->exsap_station);\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n}"
  },
  {
    "function_name": "tr_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "617-697",
    "snippet": "void\ntr_init(arg)\n\tvoid *arg;\n{\n\tstruct tr_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_size_t open_srb;\n\tint s, num_dhb;\n\tint\tresvdmem, availmem, dhbsize;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0; /* XXX tr_reset() */\n\n\topen_srb = sc->sc_srb;\n\n\t/* Zero SRB. */\n\tbus_space_set_region_1(sc->sc_memt, sc->sc_sramh,\n\t    open_srb, 0, SRB_OPEN_CMDSIZE);\n\n\t/* Open command. */\n\tSRB_OUTB(sc, open_srb, SRB_CMD, DIR_OPEN_ADAPTER);\n/*\n * XXX handle IFM_TOK_ETR !!!!\n */\n\t/* Set open parameters in SRB. */\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_OPTIONS, OPEN_PASS_BCON_MAC);\n\n\tnum_dhb = 1;\n\n\tif ((sc->sc_init_status & FAST_PATH_TRANSMIT) == 0) {\n\t\tavailmem = sc->sc_memsize;\n\t\tresvdmem = RESVDMEM_SIZE + sc->sc_memreserved;\n\n\t\t/* allow MAX of two SAPS */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSAP, 2);\n\t\tresvdmem += 2 * SAPCB_SIZE;\n\n\t\t/* allow MAX of 4 stations */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSTA, 4);\n\t\tresvdmem += 4 * LSCB_SIZE;\n\n\t\tif (sc->sc_init_status & RSP_16) {\n\t\t\tdhbsize = sc->sc_dhb16maxsz;\n\t\t}\n\t\telse {\n\t\t\tdhbsize = sc->sc_dhb4maxsz;\n\t\t}\n#if 0\t/* XXXchb unneeded? */\n\t\tif (dhbsize > 2048)\n\t\t\tnum_dhb = 2;\n#endif\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, dhbsize);\n\t\tsc->sc_nbuf = (dhbsize + 511) / 512;\n\t\t/*\n\t\t * Try to leave room for two fullsized packets when\n\t\t * requesting DHBs.\n\t\t */\n\t\tavailmem -= resvdmem;\n\t\tnum_dhb = (availmem / dhbsize) - 2;\n\t\tif (num_dhb > 2)\n\t\t\tnum_dhb = 2;\t/* firmware can't cope with more DHBs */\n\t\tif (num_dhb < 1)\n\t\t\tnum_dhb = 1;\t/* we need at least one */\n\t}\n\telse\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, DHB_LENGTH);\n\n\tSRB_OUTB(sc, open_srb, SRB_OPEN_NUMDHB, num_dhb);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_RCVBUFLEN, RCV_BUF_LEN);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_NUMRCVBUF, sc->sc_nbuf);\n\n\t/* Tell adapter: command in SRB. */\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "CMD_IN_SRB"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTW",
          "args": [
            "sc",
            "open_srb",
            "SRB_OPEN_NUMRCVBUF",
            "sc->sc_nbuf"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTW",
          "args": [
            "sc",
            "open_srb",
            "SRB_OPEN_RCVBUFLEN",
            "RCV_BUF_LEN"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "open_srb",
            "SRB_OPEN_NUMDHB",
            "num_dhb"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTW",
          "args": [
            "sc",
            "open_srb",
            "SRB_OPEN_DHBLEN",
            "DHB_LENGTH"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTW",
          "args": [
            "sc",
            "open_srb",
            "SRB_OPEN_DHBLEN",
            "dhbsize"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "open_srb",
            "SRB_OPEN_DLCMAXSTA",
            "4"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "open_srb",
            "SRB_OPEN_DLCMAXSAP",
            "2"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTW",
          "args": [
            "sc",
            "open_srb",
            "SRB_OPEN_OPTIONS",
            "OPEN_PASS_BCON_MAC"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "open_srb",
            "SRB_CMD",
            "DIR_OPEN_ADAPTER"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_set_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_sramh",
            "open_srb",
            "0",
            "SRB_OPEN_CMDSIZE"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_init(arg)\n\tvoid *arg;\n{\n\tstruct tr_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_size_t open_srb;\n\tint s, num_dhb;\n\tint\tresvdmem, availmem, dhbsize;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0; /* XXX tr_reset() */\n\n\topen_srb = sc->sc_srb;\n\n\t/* Zero SRB. */\n\tbus_space_set_region_1(sc->sc_memt, sc->sc_sramh,\n\t    open_srb, 0, SRB_OPEN_CMDSIZE);\n\n\t/* Open command. */\n\tSRB_OUTB(sc, open_srb, SRB_CMD, DIR_OPEN_ADAPTER);\n/*\n * XXX handle IFM_TOK_ETR !!!!\n */\n\t/* Set open parameters in SRB. */\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_OPTIONS, OPEN_PASS_BCON_MAC);\n\n\tnum_dhb = 1;\n\n\tif ((sc->sc_init_status & FAST_PATH_TRANSMIT) == 0) {\n\t\tavailmem = sc->sc_memsize;\n\t\tresvdmem = RESVDMEM_SIZE + sc->sc_memreserved;\n\n\t\t/* allow MAX of two SAPS */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSAP, 2);\n\t\tresvdmem += 2 * SAPCB_SIZE;\n\n\t\t/* allow MAX of 4 stations */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSTA, 4);\n\t\tresvdmem += 4 * LSCB_SIZE;\n\n\t\tif (sc->sc_init_status & RSP_16) {\n\t\t\tdhbsize = sc->sc_dhb16maxsz;\n\t\t}\n\t\telse {\n\t\t\tdhbsize = sc->sc_dhb4maxsz;\n\t\t}\n#if 0\t/* XXXchb unneeded? */\n\t\tif (dhbsize > 2048)\n\t\t\tnum_dhb = 2;\n#endif\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, dhbsize);\n\t\tsc->sc_nbuf = (dhbsize + 511) / 512;\n\t\t/*\n\t\t * Try to leave room for two fullsized packets when\n\t\t * requesting DHBs.\n\t\t */\n\t\tavailmem -= resvdmem;\n\t\tnum_dhb = (availmem / dhbsize) - 2;\n\t\tif (num_dhb > 2)\n\t\t\tnum_dhb = 2;\t/* firmware can't cope with more DHBs */\n\t\tif (num_dhb < 1)\n\t\t\tnum_dhb = 1;\t/* we need at least one */\n\t}\n\telse\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, DHB_LENGTH);\n\n\tSRB_OUTB(sc, open_srb, SRB_OPEN_NUMDHB, num_dhb);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_RCVBUFLEN, RCV_BUF_LEN);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_NUMRCVBUF, sc->sc_nbuf);\n\n\t/* Tell adapter: command in SRB. */\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "tr_reinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "602-611",
    "snippet": "void\ntr_reinit(arg)\n\tvoid *arg;\n{\n\tif (tr_reset((struct tr_softc *) arg))\n\t\treturn;\n\tif (tr_config((struct tr_softc *) arg))\n\t\treturn;\n\ttr_init(arg);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_reinit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tr_init",
          "args": [
            "arg"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "tr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "617-697",
          "snippet": "void\ntr_init(arg)\n\tvoid *arg;\n{\n\tstruct tr_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_size_t open_srb;\n\tint s, num_dhb;\n\tint\tresvdmem, availmem, dhbsize;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0; /* XXX tr_reset() */\n\n\topen_srb = sc->sc_srb;\n\n\t/* Zero SRB. */\n\tbus_space_set_region_1(sc->sc_memt, sc->sc_sramh,\n\t    open_srb, 0, SRB_OPEN_CMDSIZE);\n\n\t/* Open command. */\n\tSRB_OUTB(sc, open_srb, SRB_CMD, DIR_OPEN_ADAPTER);\n/*\n * XXX handle IFM_TOK_ETR !!!!\n */\n\t/* Set open parameters in SRB. */\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_OPTIONS, OPEN_PASS_BCON_MAC);\n\n\tnum_dhb = 1;\n\n\tif ((sc->sc_init_status & FAST_PATH_TRANSMIT) == 0) {\n\t\tavailmem = sc->sc_memsize;\n\t\tresvdmem = RESVDMEM_SIZE + sc->sc_memreserved;\n\n\t\t/* allow MAX of two SAPS */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSAP, 2);\n\t\tresvdmem += 2 * SAPCB_SIZE;\n\n\t\t/* allow MAX of 4 stations */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSTA, 4);\n\t\tresvdmem += 4 * LSCB_SIZE;\n\n\t\tif (sc->sc_init_status & RSP_16) {\n\t\t\tdhbsize = sc->sc_dhb16maxsz;\n\t\t}\n\t\telse {\n\t\t\tdhbsize = sc->sc_dhb4maxsz;\n\t\t}\n#if 0\t/* XXXchb unneeded? */\n\t\tif (dhbsize > 2048)\n\t\t\tnum_dhb = 2;\n#endif\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, dhbsize);\n\t\tsc->sc_nbuf = (dhbsize + 511) / 512;\n\t\t/*\n\t\t * Try to leave room for two fullsized packets when\n\t\t * requesting DHBs.\n\t\t */\n\t\tavailmem -= resvdmem;\n\t\tnum_dhb = (availmem / dhbsize) - 2;\n\t\tif (num_dhb > 2)\n\t\t\tnum_dhb = 2;\t/* firmware can't cope with more DHBs */\n\t\tif (num_dhb < 1)\n\t\t\tnum_dhb = 1;\t/* we need at least one */\n\t}\n\telse\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, DHB_LENGTH);\n\n\tSRB_OUTB(sc, open_srb, SRB_OPEN_NUMDHB, num_dhb);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_RCVBUFLEN, RCV_BUF_LEN);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_NUMRCVBUF, sc->sc_nbuf);\n\n\t/* Tell adapter: command in SRB. */\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
            "struct ifnet *ifp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_init(arg)\n\tvoid *arg;\n{\n\tstruct tr_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_size_t open_srb;\n\tint s, num_dhb;\n\tint\tresvdmem, availmem, dhbsize;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0)\n\t\treturn;\n\n\ts = splimp();\n\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0; /* XXX tr_reset() */\n\n\topen_srb = sc->sc_srb;\n\n\t/* Zero SRB. */\n\tbus_space_set_region_1(sc->sc_memt, sc->sc_sramh,\n\t    open_srb, 0, SRB_OPEN_CMDSIZE);\n\n\t/* Open command. */\n\tSRB_OUTB(sc, open_srb, SRB_CMD, DIR_OPEN_ADAPTER);\n/*\n * XXX handle IFM_TOK_ETR !!!!\n */\n\t/* Set open parameters in SRB. */\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_OPTIONS, OPEN_PASS_BCON_MAC);\n\n\tnum_dhb = 1;\n\n\tif ((sc->sc_init_status & FAST_PATH_TRANSMIT) == 0) {\n\t\tavailmem = sc->sc_memsize;\n\t\tresvdmem = RESVDMEM_SIZE + sc->sc_memreserved;\n\n\t\t/* allow MAX of two SAPS */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSAP, 2);\n\t\tresvdmem += 2 * SAPCB_SIZE;\n\n\t\t/* allow MAX of 4 stations */\n\t\tSRB_OUTB(sc, open_srb, SRB_OPEN_DLCMAXSTA, 4);\n\t\tresvdmem += 4 * LSCB_SIZE;\n\n\t\tif (sc->sc_init_status & RSP_16) {\n\t\t\tdhbsize = sc->sc_dhb16maxsz;\n\t\t}\n\t\telse {\n\t\t\tdhbsize = sc->sc_dhb4maxsz;\n\t\t}\n#if 0\t/* XXXchb unneeded? */\n\t\tif (dhbsize > 2048)\n\t\t\tnum_dhb = 2;\n#endif\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, dhbsize);\n\t\tsc->sc_nbuf = (dhbsize + 511) / 512;\n\t\t/*\n\t\t * Try to leave room for two fullsized packets when\n\t\t * requesting DHBs.\n\t\t */\n\t\tavailmem -= resvdmem;\n\t\tnum_dhb = (availmem / dhbsize) - 2;\n\t\tif (num_dhb > 2)\n\t\t\tnum_dhb = 2;\t/* firmware can't cope with more DHBs */\n\t\tif (num_dhb < 1)\n\t\t\tnum_dhb = 1;\t/* we need at least one */\n\t}\n\telse\n\t\tSRB_OUTW(sc, open_srb, SRB_OPEN_DHBLEN, DHB_LENGTH);\n\n\tSRB_OUTB(sc, open_srb, SRB_OPEN_NUMDHB, num_dhb);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_RCVBUFLEN, RCV_BUF_LEN);\n\tSRB_OUTW(sc, open_srb, SRB_OPEN_NUMRCVBUF, sc->sc_nbuf);\n\n\t/* Tell adapter: command in SRB. */\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_config",
          "args": [
            "(struct tr_softc *) arg"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "tr_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "178-235",
          "snippet": "int\ntr_config(sc)\n\tstruct tr_softc *sc;\n{\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT) {\n\t\tint i;\n\n\t\tfor (i=0; i < SRB_CFP_CMDSIZE; i++)\n\t\t\tSRB_OUTB(sc, sc->sc_srb, i, 0);\n\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CONFIG_FAST_PATH_RAM);\n\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_RAMSIZE,\n\t\t    (16 + (sc->sc_nbuf * FP_BUF_LEN) / 8));\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_BUFSIZE, FP_BUF_LEN);\n\n\t\t/* tell adapter: command in SRB */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\tfor (i = 0; i < 30000; i++) {\n\t\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\t\tbreak;\n\t\t\tdelay(100);\n\t\t}\n\n\t\tif (i == 30000 && sc->sc_srb == ACA_RDW(sc, ACA_WRBR)) {\n\t\t\tprintf(\"No response for fast path cfg\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\n\t\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\t\tprintf(\"cfg fast path returned: %02x\\n\",\n\t\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsc->sc_txca = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_FPXMIT);\n\t\tsc->sc_srb = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_SRBADDR);\n\t}\n\telse {\n\t\tif (sc->sc_init_status & RSP_16)\n\t\t\tsc->sc_maxmtu = sc->sc_dhb16maxsz;\n\t\telse\n\t\t\tsc->sc_maxmtu = sc->sc_dhb4maxsz;\n/*\n * XXX Not completely true because Fast Path Transmit has 514 byte buffers\n * XXX and TR_MAX_LINK_HDR is only correct when source-routing is used.\n * XXX depending on wether source routing is used change the calculation\n * XXX use IFM_TOK_SRCRT (IFF_LINK0)\n * XXX recompute sc_minbuf !!\n */\n\t\tsc->sc_maxmtu -= TR_MAX_LINK_HDR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_config(sc)\n\tstruct tr_softc *sc;\n{\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT) {\n\t\tint i;\n\n\t\tfor (i=0; i < SRB_CFP_CMDSIZE; i++)\n\t\t\tSRB_OUTB(sc, sc->sc_srb, i, 0);\n\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CONFIG_FAST_PATH_RAM);\n\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_RAMSIZE,\n\t\t    (16 + (sc->sc_nbuf * FP_BUF_LEN) / 8));\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_BUFSIZE, FP_BUF_LEN);\n\n\t\t/* tell adapter: command in SRB */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\tfor (i = 0; i < 30000; i++) {\n\t\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\t\tbreak;\n\t\t\tdelay(100);\n\t\t}\n\n\t\tif (i == 30000 && sc->sc_srb == ACA_RDW(sc, ACA_WRBR)) {\n\t\t\tprintf(\"No response for fast path cfg\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\n\t\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\t\tprintf(\"cfg fast path returned: %02x\\n\",\n\t\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsc->sc_txca = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_FPXMIT);\n\t\tsc->sc_srb = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_SRBADDR);\n\t}\n\telse {\n\t\tif (sc->sc_init_status & RSP_16)\n\t\t\tsc->sc_maxmtu = sc->sc_dhb16maxsz;\n\t\telse\n\t\t\tsc->sc_maxmtu = sc->sc_dhb4maxsz;\n/*\n * XXX Not completely true because Fast Path Transmit has 514 byte buffers\n * XXX and TR_MAX_LINK_HDR is only correct when source-routing is used.\n * XXX depending on wether source routing is used change the calculation\n * XXX use IFM_TOK_SRCRT (IFF_LINK0)\n * XXX recompute sc_minbuf !!\n */\n\t\tsc->sc_maxmtu -= TR_MAX_LINK_HDR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_reset",
          "args": [
            "(struct tr_softc *) arg"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "tr_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "504-565",
          "snippet": "int\ntr_reset(sc)\nstruct tr_softc *sc;\n{\n\tint i;\n\n\tsc->sc_srb = 0;\n\n\t/* \n\t * Reset the card.\n\t */\n\t/* latch on an unconditional adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RESET, 0);\n\tdelay(50000); /* delay 50ms */\n\t/*\n\t * XXX set paging if we have the right type of card\n\t */\n\t/* turn off adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RELEASE, 0);\n\n\t/* Enable interrupts. */\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\n\t/* Wait for an answer from the adapter. */\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\n\tif (i == 35000 && sc->sc_srb == 0) {\n\t\tprintf(\"No response from adapter after reset\\n\");\n\t\treturn 1;\n\t}\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tACA_OUTB(sc, ACA_RRR_e, (sc->sc_maddr >> 12));\n\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\tif (SRB_INB(sc, sc->sc_srb, SRB_CMD) != 0x80) {\n\t\tprintf(\"Initialization incomplete, status: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_CMD));\n\t\treturn 1;\n\t}\n\tif (SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC) != 0) {\n\t\tprintf(\"Bring Up Code %02x\\n\",\n\t\t    SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC));\n\t\treturn 1;\n\t}\n\n\tsc->sc_init_status = SRB_INB(sc, sc->sc_srb, SRB_INIT_STATUS);\n\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0;\n\n\t/* XXX should depend on sc_resvdmem. */\n\tif (MM_INB(sc, TR_RAM_OFFSET) == 0xB && sc->sc_memsize == 65536)\n\t\tfor (i = 0; i < 512; i++)\n\t\t\tSR_OUTB(sc, 0xfe00 + i, 0);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_reset(sc)\nstruct tr_softc *sc;\n{\n\tint i;\n\n\tsc->sc_srb = 0;\n\n\t/* \n\t * Reset the card.\n\t */\n\t/* latch on an unconditional adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RESET, 0);\n\tdelay(50000); /* delay 50ms */\n\t/*\n\t * XXX set paging if we have the right type of card\n\t */\n\t/* turn off adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RELEASE, 0);\n\n\t/* Enable interrupts. */\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\n\t/* Wait for an answer from the adapter. */\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\n\tif (i == 35000 && sc->sc_srb == 0) {\n\t\tprintf(\"No response from adapter after reset\\n\");\n\t\treturn 1;\n\t}\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tACA_OUTB(sc, ACA_RRR_e, (sc->sc_maddr >> 12));\n\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\tif (SRB_INB(sc, sc->sc_srb, SRB_CMD) != 0x80) {\n\t\tprintf(\"Initialization incomplete, status: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_CMD));\n\t\treturn 1;\n\t}\n\tif (SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC) != 0) {\n\t\tprintf(\"Bring Up Code %02x\\n\",\n\t\t    SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC));\n\t\treturn 1;\n\t}\n\n\tsc->sc_init_status = SRB_INB(sc, sc->sc_srb, SRB_INIT_STATUS);\n\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0;\n\n\t/* XXX should depend on sc_resvdmem. */\n\tif (MM_INB(sc, TR_RAM_OFFSET) == 0xB && sc->sc_memsize == 65536)\n\t\tfor (i = 0; i < 512; i++)\n\t\t\tSR_OUTB(sc, 0xfe00 + i, 0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_reinit;\n\nvoid\ntr_reinit(arg)\n\tvoid *arg;\n{\n\tif (tr_reset((struct tr_softc *) arg))\n\t\treturn;\n\tif (tr_config((struct tr_softc *) arg))\n\t\treturn;\n\ttr_init(arg);\n}"
  },
  {
    "function_name": "tr_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "593-600",
    "snippet": "static void\ntr_shutdown(arg)\n\tvoid *arg;\n{\n\tstruct tr_softc *sc = arg;\n\n\ttr_stop(sc);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tr_shutdown",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tr_stop",
          "args": [
            "sc"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "tr_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "570-591",
          "snippet": "void\ntr_stop(sc)\nstruct tr_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0) {\n/*\n * transmitter cannot be used from now on\n */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\t/* Close command. */\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CLOSE);\n\t\t/* Tell adapter: command in SRB. */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\t/* Wait for it to complete. */\n\t\ttr_sleep(sc);\n\t\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\t}\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
            "struct ifnet *ifp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_stop(sc)\nstruct tr_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0) {\n/*\n * transmitter cannot be used from now on\n */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\t/* Close command. */\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CLOSE);\n\t\t/* Tell adapter: command in SRB. */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\t/* Wait for it to complete. */\n\t\ttr_sleep(sc);\n\t\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic void tr_shutdown;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nstatic void\ntr_shutdown(arg)\n\tvoid *arg;\n{\n\tstruct tr_softc *sc = arg;\n\n\ttr_stop(sc);\n}"
  },
  {
    "function_name": "tr_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "570-591",
    "snippet": "void\ntr_stop(sc)\nstruct tr_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0) {\n/*\n * transmitter cannot be used from now on\n */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\t/* Close command. */\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CLOSE);\n\t\t/* Tell adapter: command in SRB. */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\t/* Wait for it to complete. */\n\t\ttr_sleep(sc);\n\t\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\t}\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACA_RDW",
          "args": [
            "sc",
            "ACA_WRBR"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_sleep",
          "args": [
            "sc"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "tr_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1717-1723",
          "snippet": "void\ntr_sleep(sc)\nstruct tr_softc *sc;\n{\n\ttimeout(tr_timeout, sc, hz*30);\n\tsleep(&sc->tr_sleepevent, 1);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_timeout",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_timeout;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid\ntr_sleep(sc)\nstruct tr_softc *sc;\n{\n\ttimeout(tr_timeout, sc, hz*30);\n\tsleep(&sc->tr_sleepevent, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "CMD_IN_SRB"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CMD",
            "DIR_CLOSE"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_stop(sc)\nstruct tr_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0) {\n/*\n * transmitter cannot be used from now on\n */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\t/* Close command. */\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CLOSE);\n\t\t/* Tell adapter: command in SRB. */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\t/* Wait for it to complete. */\n\t\ttr_sleep(sc);\n\t\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\t}\n}"
  },
  {
    "function_name": "tr_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "504-565",
    "snippet": "int\ntr_reset(sc)\nstruct tr_softc *sc;\n{\n\tint i;\n\n\tsc->sc_srb = 0;\n\n\t/* \n\t * Reset the card.\n\t */\n\t/* latch on an unconditional adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RESET, 0);\n\tdelay(50000); /* delay 50ms */\n\t/*\n\t * XXX set paging if we have the right type of card\n\t */\n\t/* turn off adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RELEASE, 0);\n\n\t/* Enable interrupts. */\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\n\t/* Wait for an answer from the adapter. */\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\n\tif (i == 35000 && sc->sc_srb == 0) {\n\t\tprintf(\"No response from adapter after reset\\n\");\n\t\treturn 1;\n\t}\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tACA_OUTB(sc, ACA_RRR_e, (sc->sc_maddr >> 12));\n\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\tif (SRB_INB(sc, sc->sc_srb, SRB_CMD) != 0x80) {\n\t\tprintf(\"Initialization incomplete, status: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_CMD));\n\t\treturn 1;\n\t}\n\tif (SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC) != 0) {\n\t\tprintf(\"Bring Up Code %02x\\n\",\n\t\t    SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC));\n\t\treturn 1;\n\t}\n\n\tsc->sc_init_status = SRB_INB(sc, sc->sc_srb, SRB_INIT_STATUS);\n\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0;\n\n\t/* XXX should depend on sc_resvdmem. */\n\tif (MM_INB(sc, TR_RAM_OFFSET) == 0xB && sc->sc_memsize == 65536)\n\t\tfor (i = 0; i < 512; i++)\n\t\t\tSR_OUTB(sc, 0xfe00 + i, 0);\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SR_OUTB",
          "args": [
            "sc",
            "0xfe00 + i",
            "0"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MM_INB",
          "args": [
            "sc",
            "TR_RAM_OFFSET"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_INIT_STATUS"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Bring Up Code %02x\\n\"",
            "SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC)"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_INIT_BUC"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_INIT_BUC"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CMD"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CMD"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RDW",
          "args": [
            "sc",
            "ACA_WRBR"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_OUTB",
          "args": [
            "sc",
            "ACA_RRR_e",
            "(sc->sc_maddr >> 12)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RSTB",
          "args": [
            "sc",
            "ACA_ISRP_o",
            "~(SRB_RESP_INT)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACA_RDB",
          "args": [
            "sc",
            "ACA_ISRP_o"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRP_e",
            "INT_ENABLE"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_piot",
            "sc->sc_pioh",
            "TR_RELEASE",
            "0"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_piot",
            "sc->sc_pioh",
            "TR_RESET",
            "0"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_reset(sc)\nstruct tr_softc *sc;\n{\n\tint i;\n\n\tsc->sc_srb = 0;\n\n\t/* \n\t * Reset the card.\n\t */\n\t/* latch on an unconditional adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RESET, 0);\n\tdelay(50000); /* delay 50ms */\n\t/*\n\t * XXX set paging if we have the right type of card\n\t */\n\t/* turn off adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RELEASE, 0);\n\n\t/* Enable interrupts. */\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\n\t/* Wait for an answer from the adapter. */\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\n\tif (i == 35000 && sc->sc_srb == 0) {\n\t\tprintf(\"No response from adapter after reset\\n\");\n\t\treturn 1;\n\t}\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tACA_OUTB(sc, ACA_RRR_e, (sc->sc_maddr >> 12));\n\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\tif (SRB_INB(sc, sc->sc_srb, SRB_CMD) != 0x80) {\n\t\tprintf(\"Initialization incomplete, status: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_CMD));\n\t\treturn 1;\n\t}\n\tif (SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC) != 0) {\n\t\tprintf(\"Bring Up Code %02x\\n\",\n\t\t    SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC));\n\t\treturn 1;\n\t}\n\n\tsc->sc_init_status = SRB_INB(sc, sc->sc_srb, SRB_INIT_STATUS);\n\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0;\n\n\t/* XXX should depend on sc_resvdmem. */\n\tif (MM_INB(sc, TR_RAM_OFFSET) == 0xB && sc->sc_memsize == 65536)\n\t\tfor (i = 0; i < 512; i++)\n\t\t\tSR_OUTB(sc, 0xfe00 + i, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "tr_mediastatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "492-502",
    "snippet": "void\ntr_mediastatus(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\n/* set LINK0 and/or LINK1 */\n\tif (sc->sc_mediastatus)\n\t\t(*sc->sc_mediastatus)(sc, ifmr);\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttr_mediastatus",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "ifmr"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_mediastatus;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_mediastatus(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\n/* set LINK0 and/or LINK1 */\n\tif (sc->sc_mediastatus)\n\t\t(*sc->sc_mediastatus)(sc, ifmr);\n}"
  },
  {
    "function_name": "tr_mediachange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "481-490",
    "snippet": "int\ntr_mediachange(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\n\tif (sc->sc_mediachange)\n\t\treturn ((*sc->sc_mediachange)(sc));\n\treturn EINVAL;\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttr_mediachange",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\ttr_mediachange;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nint\ntr_mediachange(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct tr_softc *sc = ifp->if_softc;\n\n\tif (sc->sc_mediachange)\n\t\treturn ((*sc->sc_mediachange)(sc));\n\treturn EINVAL;\n}"
  },
  {
    "function_name": "tr_setspeed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "459-479",
    "snippet": "int\ntr_setspeed(sc, speed)\nstruct tr_softc *sc;\nu_int8_t speed;\n{\n\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_SET_DEFAULT_RING_SPEED);\n\tSRB_OUTB(sc, sc->sc_srb, CMD_RETCODE, 0xfe);\n\tSRB_OUTB(sc, sc->sc_srb, SRB_SET_DEFRSP, speed);\n\t/* Tell adapter: command in SRB. */\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t/* Wait for it to complete. */\n\ttr_sleep(sc);\n\n\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\tprintf(\"set default ringspeed returned: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"set default ringspeed returned: %02x\\n\"",
            "SRB_INB(sc, sc->sc_srb, SRB_RETCODE)"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_RETCODE"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_RETCODE"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr_sleep",
          "args": [
            "sc"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "tr_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1717-1723",
          "snippet": "void\ntr_sleep(sc)\nstruct tr_softc *sc;\n{\n\ttimeout(tr_timeout, sc, hz*30);\n\tsleep(&sc->tr_sleepevent, 1);\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_timeout",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_timeout;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid\ntr_sleep(sc)\nstruct tr_softc *sc;\n{\n\ttimeout(tr_timeout, sc, hz*30);\n\tsleep(&sc->tr_sleepevent, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "CMD_IN_SRB"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_SET_DEFRSP",
            "speed"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "sc->sc_srb",
            "CMD_RETCODE",
            "0xfe"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CMD",
            "DIR_SET_DEFAULT_RING_SPEED"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_setspeed(sc, speed)\nstruct tr_softc *sc;\nu_int8_t speed;\n{\n\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_SET_DEFAULT_RING_SPEED);\n\tSRB_OUTB(sc, sc->sc_srb, CMD_RETCODE, 0xfe);\n\tSRB_OUTB(sc, sc->sc_srb, SRB_SET_DEFRSP, speed);\n\t/* Tell adapter: command in SRB. */\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t/* Wait for it to complete. */\n\ttr_sleep(sc);\n\n\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\tprintf(\"set default ringspeed returned: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "tr_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "237-457",
    "snippet": "int\ntr_attach(sc)\n\tstruct tr_softc *sc;\n{\n\tint\tnmedia, *mediaptr, *defmediaptr;\n\tint\ti, temp;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT) {\n\t\tbus_size_t srb;\n\t\tint\tnbuf = 0;\n\n\t\tsrb = sc->sc_srb;\n\n\t\tswitch (sc->sc_memsize) {\n\t\tcase 65536:\n\t\t\tnbuf = 58;\n\t\t\tsc->sc_maxmtu = IPMTU_4MBIT_MAX;\n\t\t\tbreak;\n\t\tcase 32768:\n\t\t\tnbuf = 29;\n\t\t\tsc->sc_maxmtu = IPMTU_4MBIT_MAX;\n\t\t\tbreak;\n\t\tcase 16384:\n\t\t\tnbuf = 13;\n\t\t\tsc->sc_maxmtu = IPMTU_4MBIT_MAX;\n\t\t\tbreak;\n\t\tcase 8192:\n\t\t\tnbuf = 5;\n\t\t\tsc->sc_maxmtu = ISO88025_MTU;\n\t\t}\n\n\t\tsc->sc_minbuf = ((sc->sc_maxmtu + 511) / 512) + 1;\n\t\tsc->sc_nbuf = nbuf;\n\n/*\n *  Create circular queues caching the buffer pointers ?\n */\n\t}\n\telse {\n/*\n * MAX_MACFRAME_SIZE = DHB_SIZE - 6\n * IPMTU = MAX_MACFRAME_SIZE - (14 + 18 + 8)\n * (14 = header, 18 = sroute, 8 = llcsnap)\n */\n\n\t\tswitch (sc->sc_memsize) {\n\t\tcase 8192:\n\t\t\tsc->sc_dhb4maxsz = 2048;\n\t\t\tsc->sc_dhb16maxsz = 2048;\n\t\t\tbreak;\n\t\tcase 16384:\n\t\t\tsc->sc_dhb4maxsz = 4096;\n\t\t\tsc->sc_dhb16maxsz = 4096;\n\t\t\tbreak;\n\t\tcase 32768:\n\t\t\tsc->sc_dhb4maxsz = 4464;\n\t\t\tsc->sc_dhb16maxsz = 8192;\n\t\t\tbreak;\n\t\tcase 65536:\n\t\t\tsc->sc_dhb4maxsz = 4464;\n\t\t\tsc->sc_dhb16maxsz = 8192;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (MM_INB(sc, TR_DHB4_OFFSET)) {\n\t\tcase 0xF:\n\t\t\tif (sc->sc_dhb4maxsz > 2048)\n\t\t\t\tsc->sc_dhb4maxsz = 2048;\n\t\t\tbreak;\n\t\tcase 0xE:\n\t\t\tif (sc->sc_dhb4maxsz > 4096)\n\t\t\t\tsc->sc_dhb4maxsz = 4096;\n\t\t\tbreak;\n\t\tcase 0xD:\n\t\t\tif (sc->sc_dhb4maxsz > 4464)\n\t\t\t\tsc->sc_dhb4maxsz = 4464;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (MM_INB(sc, TR_DHB16_OFFSET)) {\n\t\tcase 0xF:\n\t\t\tif (sc->sc_dhb16maxsz > 2048)\n\t\t\t\tsc->sc_dhb16maxsz = 2048;\n\t\t\tbreak;\n\t\tcase 0xE:\n\t\t\tif (sc->sc_dhb16maxsz > 4096)\n\t\t\t\tsc->sc_dhb16maxsz = 4096;\n\t\t\tbreak;\n\t\tcase 0xD:\n\t\t\tif (sc->sc_dhb16maxsz > 8192)\n\t\t\t\tsc->sc_dhb16maxsz = 8192;\n\t\t\tbreak;\n\t\tcase 0xC:\n\t\t\tif (sc->sc_dhb16maxsz > 8192)\n\t\t\t\tsc->sc_dhb16maxsz = 8192;\n\t\t\tbreak;\n\t\tcase 0xB:\n\t\t\tif (sc->sc_dhb16maxsz > 8192)\n\t\t\t\tsc->sc_dhb16maxsz = 8192;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tr_config(sc))\n\t\treturn 1;\n\n\t/*\n\t * init network-visible interface \n\t */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_ioctl = tr_ioctl;\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT)\n\t\tifp->if_start = tr_start;\n\telse\n\t\tifp->if_start = tr_oldstart;\n\tifp->if_flags = IFF_BROADCAST | IFF_NOTRAILERS;\n\tifp->if_watchdog = tr_watchdog;\n\n\tswitch (MM_INB(sc, TR_MEDIAS_OFFSET)) {\n\tcase 0xF:\n\t\tnmedia = 1;\n\t\tmediaptr = &media[6];\n\t\tbreak;\n\tcase 0xE:\n\t\tnmedia = 2;\n\t\tmediaptr = &media[0];\n\t\tbreak;\n\tcase 0xD:\n\t\tnmedia = 1;\n\t\tmediaptr = &media[4];\n\t\tbreak;\n\tdefault:\n\t\tnmedia = 0;\n\t\tmediaptr = NULL;\n\t}\n\n\tswitch (MM_INB(sc, TR_RATES_OFFSET)) {\n\tcase 0xF:\n\t\t/* 4 Mbps */\n\t\tbreak;\n\tcase 0xE:\n\t\t/* 16 Mbps */\n\t\tif (mediaptr)\n\t\t\tmediaptr += nmedia;\n\t\tbreak;\n\tcase 0xD:\n\t\t/* 4/16 Mbps */\n\t\tnmedia *= 2;\n\t\tbreak;\n\t}\n\n\tswitch (MM_INB(sc, TR_MEDIA_OFFSET)) {\n\tcase 0xF:\n\t\t/* STP */\n\t\tdefmediaptr = &media[6];\n\t\tbreak;\n\tcase 0xE:\n\t\t/* UTP */\n\t\tdefmediaptr = &media[4];\n\t\tbreak;\n\tcase 0xD:\n\t\t/* STP and UTP == a single shielded RJ45 which supports both */\n\t\t/* XXX additional types in net/if_media.h ?? */\n\t\tdefmediaptr = &media[4];\n\t\tbreak;\n\tdefault:\n\t\tdefmediaptr = NULL;\n\t}\n\n\tif (defmediaptr && (sc->sc_init_status & RSP_16))\n\t\t++defmediaptr;\n\n\tif (sc->sc_mediachange == NULL && sc->sc_mediastatus == NULL) {\n\t\tswitch (MM_INB(sc, TR_TYP_OFFSET)) {\n\t\tcase 0x0D:\n\t\tcase 0x0C:\n\t\t\tsc->sc_mediachange = tropic_mediachange;\n\t\t\tsc->sc_mediastatus = tropic_mediastatus;\n\t\t}\n\t}\n\n\tifmedia_init(&sc->sc_media, 0, tr_mediachange, tr_mediastatus);\n\tif (mediaptr != NULL) {\n\t\tfor (i = 0; i < nmedia; i++)\n\t\t\tifmedia_add(&sc->sc_media, mediaptr[i], 0, NULL);\n\t\tif (defmediaptr)\n\t\t\tifmedia_set(&sc->sc_media, *defmediaptr);\n\t\telse\n\t\t\tifmedia_set(&sc->sc_media, 0);\n\t}\n\telse {\n\t\tifmedia_add(&sc->sc_media, IFM_TOKEN | IFM_MANUAL, 0, NULL);\n\t\tifmedia_set(&sc->sc_media, IFM_TOKEN | IFM_MANUAL);\n\t}\n\n\tif_attach(ifp);\n\n\tfor (i = 0, temp = 0; i < ISO88025_ADDR_LEN; i++, temp += 4) {\n\t\tsc->sc_arpcom.ac_enaddr[i] =\n\t\t    (MM_INB(sc, (TR_MAC_OFFSET + temp)) & 0xf) << 4;\n\t\tsc->sc_arpcom.ac_enaddr[i] |=\n\t\t    MM_INB(sc, (TR_MAC_OFFSET + temp + 2)) & 0xf;\n\t}\n\n\ttoken_ifattach(ifp);\n\n\tprintf(\"\\n%s: address %s ring speed %d Mbps\\n\",\n\t\tsc->sc_dev.dv_xname, token_sprintf(sc->sc_arpcom.ac_enaddr),\n\t\t(sc->sc_init_status & RSP_16) ? 16 : 4);\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_IEEE802, sizeof(struct token_header));\n#endif\n\n/*\n * XXX rnd stuff\n */\n\tshutdownhook_establish(tr_shutdown, sc);\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void tr_shutdown",
      "void\ttr_start",
      "void\ttr_oldstart",
      "void\ttr_watchdog",
      "int\ttr_mediachange",
      "void\ttr_mediastatus",
      "int\ttropic_mediachange",
      "void\ttropic_mediastatus",
      "static\tint media[] = {\n\tIFM_TOKEN | IFM_TOK_UTP4,\n\tIFM_TOKEN | IFM_TOK_STP4,\n\tIFM_TOKEN | IFM_TOK_UTP16,\n\tIFM_TOKEN | IFM_TOK_STP16,\n\tIFM_TOKEN | IFM_TOK_UTP4,\n\tIFM_TOKEN | IFM_TOK_UTP16,\n\tIFM_TOKEN | IFM_TOK_STP4,\n\tIFM_TOKEN | IFM_TOK_STP16\n};",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
      "struct ifnet *ifp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "tr_shutdown",
            "sc"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_IEEE802",
            "sizeof(struct token_header)"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n%s: address %s ring speed %d Mbps\\n\"",
            "sc->sc_dev.dv_xname",
            "token_sprintf(sc->sc_arpcom.ac_enaddr)",
            "(sc->sc_init_status & RSP_16) ? 16 : 4"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "token_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "token_ifattach",
          "args": [
            "ifp"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MM_INB",
          "args": [
            "sc",
            "(TR_MAC_OFFSET + temp + 2)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MM_INB",
          "args": [
            "sc",
            "(TR_MAC_OFFSET + temp)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_media",
            "IFM_TOKEN | IFM_MANUAL"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_media",
            "IFM_TOKEN | IFM_MANUAL",
            "0",
            "NULL"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_media",
            "0"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_media",
            "*defmediaptr"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_media",
            "mediaptr[i]",
            "0",
            "NULL"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_media",
            "0",
            "tr_mediachange",
            "tr_mediastatus"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MM_INB",
          "args": [
            "sc",
            "TR_TYP_OFFSET"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MM_INB",
          "args": [
            "sc",
            "TR_MEDIA_OFFSET"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MM_INB",
          "args": [
            "sc",
            "TR_RATES_OFFSET"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MM_INB",
          "args": [
            "sc",
            "TR_MEDIAS_OFFSET"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_config",
          "args": [
            "sc"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "tr_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "178-235",
          "snippet": "int\ntr_config(sc)\n\tstruct tr_softc *sc;\n{\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT) {\n\t\tint i;\n\n\t\tfor (i=0; i < SRB_CFP_CMDSIZE; i++)\n\t\t\tSRB_OUTB(sc, sc->sc_srb, i, 0);\n\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CONFIG_FAST_PATH_RAM);\n\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_RAMSIZE,\n\t\t    (16 + (sc->sc_nbuf * FP_BUF_LEN) / 8));\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_BUFSIZE, FP_BUF_LEN);\n\n\t\t/* tell adapter: command in SRB */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\tfor (i = 0; i < 30000; i++) {\n\t\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\t\tbreak;\n\t\t\tdelay(100);\n\t\t}\n\n\t\tif (i == 30000 && sc->sc_srb == ACA_RDW(sc, ACA_WRBR)) {\n\t\t\tprintf(\"No response for fast path cfg\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\n\t\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\t\tprintf(\"cfg fast path returned: %02x\\n\",\n\t\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsc->sc_txca = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_FPXMIT);\n\t\tsc->sc_srb = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_SRBADDR);\n\t}\n\telse {\n\t\tif (sc->sc_init_status & RSP_16)\n\t\t\tsc->sc_maxmtu = sc->sc_dhb16maxsz;\n\t\telse\n\t\t\tsc->sc_maxmtu = sc->sc_dhb4maxsz;\n/*\n * XXX Not completely true because Fast Path Transmit has 514 byte buffers\n * XXX and TR_MAX_LINK_HDR is only correct when source-routing is used.\n * XXX depending on wether source routing is used change the calculation\n * XXX use IFM_TOK_SRCRT (IFF_LINK0)\n * XXX recompute sc_minbuf !!\n */\n\t\tsc->sc_maxmtu -= TR_MAX_LINK_HDR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_config(sc)\n\tstruct tr_softc *sc;\n{\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT) {\n\t\tint i;\n\n\t\tfor (i=0; i < SRB_CFP_CMDSIZE; i++)\n\t\t\tSRB_OUTB(sc, sc->sc_srb, i, 0);\n\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CONFIG_FAST_PATH_RAM);\n\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_RAMSIZE,\n\t\t    (16 + (sc->sc_nbuf * FP_BUF_LEN) / 8));\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_BUFSIZE, FP_BUF_LEN);\n\n\t\t/* tell adapter: command in SRB */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\tfor (i = 0; i < 30000; i++) {\n\t\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\t\tbreak;\n\t\t\tdelay(100);\n\t\t}\n\n\t\tif (i == 30000 && sc->sc_srb == ACA_RDW(sc, ACA_WRBR)) {\n\t\t\tprintf(\"No response for fast path cfg\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\n\t\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\t\tprintf(\"cfg fast path returned: %02x\\n\",\n\t\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsc->sc_txca = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_FPXMIT);\n\t\tsc->sc_srb = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_SRBADDR);\n\t}\n\telse {\n\t\tif (sc->sc_init_status & RSP_16)\n\t\t\tsc->sc_maxmtu = sc->sc_dhb16maxsz;\n\t\telse\n\t\t\tsc->sc_maxmtu = sc->sc_dhb4maxsz;\n/*\n * XXX Not completely true because Fast Path Transmit has 514 byte buffers\n * XXX and TR_MAX_LINK_HDR is only correct when source-routing is used.\n * XXX depending on wether source routing is used change the calculation\n * XXX use IFM_TOK_SRCRT (IFF_LINK0)\n * XXX recompute sc_minbuf !!\n */\n\t\tsc->sc_maxmtu -= TR_MAX_LINK_HDR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MM_INB",
          "args": [
            "sc",
            "TR_DHB16_OFFSET"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MM_INB",
          "args": [
            "sc",
            "TR_DHB4_OFFSET"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic void tr_shutdown;\nvoid\ttr_start;\nvoid\ttr_oldstart;\nvoid\ttr_watchdog;\nint\ttr_mediachange;\nvoid\ttr_mediastatus;\nint\ttropic_mediachange;\nvoid\ttropic_mediastatus;\nstatic\tint media[] = {\n\tIFM_TOKEN | IFM_TOK_UTP4,\n\tIFM_TOKEN | IFM_TOK_STP4,\n\tIFM_TOKEN | IFM_TOK_UTP16,\n\tIFM_TOKEN | IFM_TOK_STP16,\n\tIFM_TOKEN | IFM_TOK_UTP4,\n\tIFM_TOKEN | IFM_TOK_UTP16,\n\tIFM_TOKEN | IFM_TOK_STP4,\n\tIFM_TOKEN | IFM_TOK_STP16\n};\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nint\ntr_attach(sc)\n\tstruct tr_softc *sc;\n{\n\tint\tnmedia, *mediaptr, *defmediaptr;\n\tint\ti, temp;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT) {\n\t\tbus_size_t srb;\n\t\tint\tnbuf = 0;\n\n\t\tsrb = sc->sc_srb;\n\n\t\tswitch (sc->sc_memsize) {\n\t\tcase 65536:\n\t\t\tnbuf = 58;\n\t\t\tsc->sc_maxmtu = IPMTU_4MBIT_MAX;\n\t\t\tbreak;\n\t\tcase 32768:\n\t\t\tnbuf = 29;\n\t\t\tsc->sc_maxmtu = IPMTU_4MBIT_MAX;\n\t\t\tbreak;\n\t\tcase 16384:\n\t\t\tnbuf = 13;\n\t\t\tsc->sc_maxmtu = IPMTU_4MBIT_MAX;\n\t\t\tbreak;\n\t\tcase 8192:\n\t\t\tnbuf = 5;\n\t\t\tsc->sc_maxmtu = ISO88025_MTU;\n\t\t}\n\n\t\tsc->sc_minbuf = ((sc->sc_maxmtu + 511) / 512) + 1;\n\t\tsc->sc_nbuf = nbuf;\n\n/*\n *  Create circular queues caching the buffer pointers ?\n */\n\t}\n\telse {\n/*\n * MAX_MACFRAME_SIZE = DHB_SIZE - 6\n * IPMTU = MAX_MACFRAME_SIZE - (14 + 18 + 8)\n * (14 = header, 18 = sroute, 8 = llcsnap)\n */\n\n\t\tswitch (sc->sc_memsize) {\n\t\tcase 8192:\n\t\t\tsc->sc_dhb4maxsz = 2048;\n\t\t\tsc->sc_dhb16maxsz = 2048;\n\t\t\tbreak;\n\t\tcase 16384:\n\t\t\tsc->sc_dhb4maxsz = 4096;\n\t\t\tsc->sc_dhb16maxsz = 4096;\n\t\t\tbreak;\n\t\tcase 32768:\n\t\t\tsc->sc_dhb4maxsz = 4464;\n\t\t\tsc->sc_dhb16maxsz = 8192;\n\t\t\tbreak;\n\t\tcase 65536:\n\t\t\tsc->sc_dhb4maxsz = 4464;\n\t\t\tsc->sc_dhb16maxsz = 8192;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (MM_INB(sc, TR_DHB4_OFFSET)) {\n\t\tcase 0xF:\n\t\t\tif (sc->sc_dhb4maxsz > 2048)\n\t\t\t\tsc->sc_dhb4maxsz = 2048;\n\t\t\tbreak;\n\t\tcase 0xE:\n\t\t\tif (sc->sc_dhb4maxsz > 4096)\n\t\t\t\tsc->sc_dhb4maxsz = 4096;\n\t\t\tbreak;\n\t\tcase 0xD:\n\t\t\tif (sc->sc_dhb4maxsz > 4464)\n\t\t\t\tsc->sc_dhb4maxsz = 4464;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (MM_INB(sc, TR_DHB16_OFFSET)) {\n\t\tcase 0xF:\n\t\t\tif (sc->sc_dhb16maxsz > 2048)\n\t\t\t\tsc->sc_dhb16maxsz = 2048;\n\t\t\tbreak;\n\t\tcase 0xE:\n\t\t\tif (sc->sc_dhb16maxsz > 4096)\n\t\t\t\tsc->sc_dhb16maxsz = 4096;\n\t\t\tbreak;\n\t\tcase 0xD:\n\t\t\tif (sc->sc_dhb16maxsz > 8192)\n\t\t\t\tsc->sc_dhb16maxsz = 8192;\n\t\t\tbreak;\n\t\tcase 0xC:\n\t\t\tif (sc->sc_dhb16maxsz > 8192)\n\t\t\t\tsc->sc_dhb16maxsz = 8192;\n\t\t\tbreak;\n\t\tcase 0xB:\n\t\t\tif (sc->sc_dhb16maxsz > 8192)\n\t\t\t\tsc->sc_dhb16maxsz = 8192;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tr_config(sc))\n\t\treturn 1;\n\n\t/*\n\t * init network-visible interface \n\t */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_ioctl = tr_ioctl;\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT)\n\t\tifp->if_start = tr_start;\n\telse\n\t\tifp->if_start = tr_oldstart;\n\tifp->if_flags = IFF_BROADCAST | IFF_NOTRAILERS;\n\tifp->if_watchdog = tr_watchdog;\n\n\tswitch (MM_INB(sc, TR_MEDIAS_OFFSET)) {\n\tcase 0xF:\n\t\tnmedia = 1;\n\t\tmediaptr = &media[6];\n\t\tbreak;\n\tcase 0xE:\n\t\tnmedia = 2;\n\t\tmediaptr = &media[0];\n\t\tbreak;\n\tcase 0xD:\n\t\tnmedia = 1;\n\t\tmediaptr = &media[4];\n\t\tbreak;\n\tdefault:\n\t\tnmedia = 0;\n\t\tmediaptr = NULL;\n\t}\n\n\tswitch (MM_INB(sc, TR_RATES_OFFSET)) {\n\tcase 0xF:\n\t\t/* 4 Mbps */\n\t\tbreak;\n\tcase 0xE:\n\t\t/* 16 Mbps */\n\t\tif (mediaptr)\n\t\t\tmediaptr += nmedia;\n\t\tbreak;\n\tcase 0xD:\n\t\t/* 4/16 Mbps */\n\t\tnmedia *= 2;\n\t\tbreak;\n\t}\n\n\tswitch (MM_INB(sc, TR_MEDIA_OFFSET)) {\n\tcase 0xF:\n\t\t/* STP */\n\t\tdefmediaptr = &media[6];\n\t\tbreak;\n\tcase 0xE:\n\t\t/* UTP */\n\t\tdefmediaptr = &media[4];\n\t\tbreak;\n\tcase 0xD:\n\t\t/* STP and UTP == a single shielded RJ45 which supports both */\n\t\t/* XXX additional types in net/if_media.h ?? */\n\t\tdefmediaptr = &media[4];\n\t\tbreak;\n\tdefault:\n\t\tdefmediaptr = NULL;\n\t}\n\n\tif (defmediaptr && (sc->sc_init_status & RSP_16))\n\t\t++defmediaptr;\n\n\tif (sc->sc_mediachange == NULL && sc->sc_mediastatus == NULL) {\n\t\tswitch (MM_INB(sc, TR_TYP_OFFSET)) {\n\t\tcase 0x0D:\n\t\tcase 0x0C:\n\t\t\tsc->sc_mediachange = tropic_mediachange;\n\t\t\tsc->sc_mediastatus = tropic_mediastatus;\n\t\t}\n\t}\n\n\tifmedia_init(&sc->sc_media, 0, tr_mediachange, tr_mediastatus);\n\tif (mediaptr != NULL) {\n\t\tfor (i = 0; i < nmedia; i++)\n\t\t\tifmedia_add(&sc->sc_media, mediaptr[i], 0, NULL);\n\t\tif (defmediaptr)\n\t\t\tifmedia_set(&sc->sc_media, *defmediaptr);\n\t\telse\n\t\t\tifmedia_set(&sc->sc_media, 0);\n\t}\n\telse {\n\t\tifmedia_add(&sc->sc_media, IFM_TOKEN | IFM_MANUAL, 0, NULL);\n\t\tifmedia_set(&sc->sc_media, IFM_TOKEN | IFM_MANUAL);\n\t}\n\n\tif_attach(ifp);\n\n\tfor (i = 0, temp = 0; i < ISO88025_ADDR_LEN; i++, temp += 4) {\n\t\tsc->sc_arpcom.ac_enaddr[i] =\n\t\t    (MM_INB(sc, (TR_MAC_OFFSET + temp)) & 0xf) << 4;\n\t\tsc->sc_arpcom.ac_enaddr[i] |=\n\t\t    MM_INB(sc, (TR_MAC_OFFSET + temp + 2)) & 0xf;\n\t}\n\n\ttoken_ifattach(ifp);\n\n\tprintf(\"\\n%s: address %s ring speed %d Mbps\\n\",\n\t\tsc->sc_dev.dv_xname, token_sprintf(sc->sc_arpcom.ac_enaddr),\n\t\t(sc->sc_init_status & RSP_16) ? 16 : 4);\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_IEEE802, sizeof(struct token_header));\n#endif\n\n/*\n * XXX rnd stuff\n */\n\tshutdownhook_establish(tr_shutdown, sc);\n\treturn 0;\n}"
  },
  {
    "function_name": "tr_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "178-235",
    "snippet": "int\ntr_config(sc)\n\tstruct tr_softc *sc;\n{\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT) {\n\t\tint i;\n\n\t\tfor (i=0; i < SRB_CFP_CMDSIZE; i++)\n\t\t\tSRB_OUTB(sc, sc->sc_srb, i, 0);\n\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CONFIG_FAST_PATH_RAM);\n\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_RAMSIZE,\n\t\t    (16 + (sc->sc_nbuf * FP_BUF_LEN) / 8));\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_BUFSIZE, FP_BUF_LEN);\n\n\t\t/* tell adapter: command in SRB */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\tfor (i = 0; i < 30000; i++) {\n\t\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\t\tbreak;\n\t\t\tdelay(100);\n\t\t}\n\n\t\tif (i == 30000 && sc->sc_srb == ACA_RDW(sc, ACA_WRBR)) {\n\t\t\tprintf(\"No response for fast path cfg\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\n\t\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\t\tprintf(\"cfg fast path returned: %02x\\n\",\n\t\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsc->sc_txca = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_FPXMIT);\n\t\tsc->sc_srb = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_SRBADDR);\n\t}\n\telse {\n\t\tif (sc->sc_init_status & RSP_16)\n\t\t\tsc->sc_maxmtu = sc->sc_dhb16maxsz;\n\t\telse\n\t\t\tsc->sc_maxmtu = sc->sc_dhb4maxsz;\n/*\n * XXX Not completely true because Fast Path Transmit has 514 byte buffers\n * XXX and TR_MAX_LINK_HDR is only correct when source-routing is used.\n * XXX depending on wether source routing is used change the calculation\n * XXX use IFM_TOK_SRCRT (IFF_LINK0)\n * XXX recompute sc_minbuf !!\n */\n\t\tsc->sc_maxmtu -= TR_MAX_LINK_HDR;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRB_INW",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CFPRESP_SRBADDR"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INW",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CFPRESP_FPXMIT"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cfg fast path returned: %02x\\n\"",
            "SRB_INB(sc, sc->sc_srb, SRB_RETCODE)"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_RETCODE"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_INB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_RETCODE"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RSTB",
          "args": [
            "sc",
            "ACA_ISRP_o",
            "~(SRB_RESP_INT)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_RDW",
          "args": [
            "sc",
            "ACA_WRBR"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACA_RDB",
          "args": [
            "sc",
            "ACA_ISRP_o"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACA_SETB",
          "args": [
            "sc",
            "ACA_ISRA_o",
            "CMD_IN_SRB"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTW",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CFP_BUFSIZE",
            "FP_BUF_LEN"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTW",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CFP_RAMSIZE",
            "(16 + (sc->sc_nbuf * FP_BUF_LEN) / 8)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "sc->sc_srb",
            "SRB_CMD",
            "DIR_CONFIG_FAST_PATH_RAM"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRB_OUTB",
          "args": [
            "sc",
            "sc->sc_srb",
            "i",
            "0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_config(sc)\n\tstruct tr_softc *sc;\n{\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT) {\n\t\tint i;\n\n\t\tfor (i=0; i < SRB_CFP_CMDSIZE; i++)\n\t\t\tSRB_OUTB(sc, sc->sc_srb, i, 0);\n\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CONFIG_FAST_PATH_RAM);\n\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_RAMSIZE,\n\t\t    (16 + (sc->sc_nbuf * FP_BUF_LEN) / 8));\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_BUFSIZE, FP_BUF_LEN);\n\n\t\t/* tell adapter: command in SRB */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\tfor (i = 0; i < 30000; i++) {\n\t\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\t\tbreak;\n\t\t\tdelay(100);\n\t\t}\n\n\t\tif (i == 30000 && sc->sc_srb == ACA_RDW(sc, ACA_WRBR)) {\n\t\t\tprintf(\"No response for fast path cfg\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\n\t\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\t\tprintf(\"cfg fast path returned: %02x\\n\",\n\t\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsc->sc_txca = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_FPXMIT);\n\t\tsc->sc_srb = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_SRBADDR);\n\t}\n\telse {\n\t\tif (sc->sc_init_status & RSP_16)\n\t\t\tsc->sc_maxmtu = sc->sc_dhb16maxsz;\n\t\telse\n\t\t\tsc->sc_maxmtu = sc->sc_dhb4maxsz;\n/*\n * XXX Not completely true because Fast Path Transmit has 514 byte buffers\n * XXX and TR_MAX_LINK_HDR is only correct when source-routing is used.\n * XXX depending on wether source routing is used change the calculation\n * XXX use IFM_TOK_SRCRT (IFF_LINK0)\n * XXX recompute sc_minbuf !!\n */\n\t\tsc->sc_maxmtu -= TR_MAX_LINK_HDR;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "tropic_mediastatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "168-176",
    "snippet": "void\ntropic_mediastatus(sc, ifmr)\n\tstruct tr_softc *sc;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct ifmedia\t*ifm = &sc->sc_media;\n\n\tifmr->ifm_active = ifm->ifm_cur->ifm_media;\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\ttropic_mediastatus",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttropic_mediastatus;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid\ntropic_mediastatus(sc, ifmr)\n\tstruct tr_softc *sc;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct ifmedia\t*ifm = &sc->sc_media;\n\n\tifmr->ifm_active = ifm->ifm_cur->ifm_media;\n}"
  },
  {
    "function_name": "tropic_mediachange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
    "lines": "129-166",
    "snippet": "int\ntropic_mediachange(sc)\n\tstruct tr_softc *sc;\n{\n\tif (IFM_TYPE(sc->sc_media.ifm_media) != IFM_TOKEN)\n\t\treturn EINVAL;\n\n\tswitch (IFM_SUBTYPE(sc->sc_media.ifm_media)) {\n\tcase IFM_TOK_STP16:\n\tcase IFM_TOK_UTP16:\n\t\tif ((sc->sc_init_status & RSP_16) == 0) {\n\t\t\ttr_stop(sc);\n\t\t\tif (tr_setspeed(sc, 16))\n\t\t\t\treturn EINVAL;\n\t\t\tif (tr_reset(sc))\n\t\t\t\treturn EINVAL;\n\t\t\tif (tr_config(sc))\n\t\t\t\treturn EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IFM_TOK_STP4:\n\tcase IFM_TOK_UTP4:\n\t\tif ((sc->sc_init_status & RSP_16) != 0) {\n\t\t\ttr_stop(sc);\n\t\t\tif (tr_setspeed(sc, 4))\n\t\t\t\treturn EINVAL;\n\t\t\tif (tr_reset(sc))\n\t\t\t\treturn EINVAL;\n\t\t\tif (tr_config(sc))\n\t\t\t\treturn EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n/*\n * XXX Handle Early Token Release !!!!\n */\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ic/tropicvar.h>",
      "#include <dev/ic/tropicreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <net/if_token.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_media.h>",
      "#include <net/if_llc.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\ttropic_mediachange",
      "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tr_config",
          "args": [
            "sc"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "tr_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "178-235",
          "snippet": "int\ntr_config(sc)\n\tstruct tr_softc *sc;\n{\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT) {\n\t\tint i;\n\n\t\tfor (i=0; i < SRB_CFP_CMDSIZE; i++)\n\t\t\tSRB_OUTB(sc, sc->sc_srb, i, 0);\n\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CONFIG_FAST_PATH_RAM);\n\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_RAMSIZE,\n\t\t    (16 + (sc->sc_nbuf * FP_BUF_LEN) / 8));\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_BUFSIZE, FP_BUF_LEN);\n\n\t\t/* tell adapter: command in SRB */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\tfor (i = 0; i < 30000; i++) {\n\t\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\t\tbreak;\n\t\t\tdelay(100);\n\t\t}\n\n\t\tif (i == 30000 && sc->sc_srb == ACA_RDW(sc, ACA_WRBR)) {\n\t\t\tprintf(\"No response for fast path cfg\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\n\t\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\t\tprintf(\"cfg fast path returned: %02x\\n\",\n\t\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsc->sc_txca = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_FPXMIT);\n\t\tsc->sc_srb = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_SRBADDR);\n\t}\n\telse {\n\t\tif (sc->sc_init_status & RSP_16)\n\t\t\tsc->sc_maxmtu = sc->sc_dhb16maxsz;\n\t\telse\n\t\t\tsc->sc_maxmtu = sc->sc_dhb4maxsz;\n/*\n * XXX Not completely true because Fast Path Transmit has 514 byte buffers\n * XXX and TR_MAX_LINK_HDR is only correct when source-routing is used.\n * XXX depending on wether source routing is used change the calculation\n * XXX use IFM_TOK_SRCRT (IFF_LINK0)\n * XXX recompute sc_minbuf !!\n */\n\t\tsc->sc_maxmtu -= TR_MAX_LINK_HDR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_config(sc)\n\tstruct tr_softc *sc;\n{\n\tif (sc->sc_init_status & FAST_PATH_TRANSMIT) {\n\t\tint i;\n\n\t\tfor (i=0; i < SRB_CFP_CMDSIZE; i++)\n\t\t\tSRB_OUTB(sc, sc->sc_srb, i, 0);\n\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CONFIG_FAST_PATH_RAM);\n\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_RAMSIZE,\n\t\t    (16 + (sc->sc_nbuf * FP_BUF_LEN) / 8));\n\t\tSRB_OUTW(sc, sc->sc_srb, SRB_CFP_BUFSIZE, FP_BUF_LEN);\n\n\t\t/* tell adapter: command in SRB */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\tfor (i = 0; i < 30000; i++) {\n\t\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\t\tbreak;\n\t\t\tdelay(100);\n\t\t}\n\n\t\tif (i == 30000 && sc->sc_srb == ACA_RDW(sc, ACA_WRBR)) {\n\t\t\tprintf(\"No response for fast path cfg\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\n\t\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\t\tprintf(\"cfg fast path returned: %02x\\n\",\n\t\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\t\treturn 1;\n\t\t}\n\n\t\tsc->sc_txca = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_FPXMIT);\n\t\tsc->sc_srb = SRB_INW(sc, sc->sc_srb, SRB_CFPRESP_SRBADDR);\n\t}\n\telse {\n\t\tif (sc->sc_init_status & RSP_16)\n\t\t\tsc->sc_maxmtu = sc->sc_dhb16maxsz;\n\t\telse\n\t\t\tsc->sc_maxmtu = sc->sc_dhb4maxsz;\n/*\n * XXX Not completely true because Fast Path Transmit has 514 byte buffers\n * XXX and TR_MAX_LINK_HDR is only correct when source-routing is used.\n * XXX depending on wether source routing is used change the calculation\n * XXX use IFM_TOK_SRCRT (IFF_LINK0)\n * XXX recompute sc_minbuf !!\n */\n\t\tsc->sc_maxmtu -= TR_MAX_LINK_HDR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_reset",
          "args": [
            "sc"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "tr_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "504-565",
          "snippet": "int\ntr_reset(sc)\nstruct tr_softc *sc;\n{\n\tint i;\n\n\tsc->sc_srb = 0;\n\n\t/* \n\t * Reset the card.\n\t */\n\t/* latch on an unconditional adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RESET, 0);\n\tdelay(50000); /* delay 50ms */\n\t/*\n\t * XXX set paging if we have the right type of card\n\t */\n\t/* turn off adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RELEASE, 0);\n\n\t/* Enable interrupts. */\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\n\t/* Wait for an answer from the adapter. */\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\n\tif (i == 35000 && sc->sc_srb == 0) {\n\t\tprintf(\"No response from adapter after reset\\n\");\n\t\treturn 1;\n\t}\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tACA_OUTB(sc, ACA_RRR_e, (sc->sc_maddr >> 12));\n\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\tif (SRB_INB(sc, sc->sc_srb, SRB_CMD) != 0x80) {\n\t\tprintf(\"Initialization incomplete, status: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_CMD));\n\t\treturn 1;\n\t}\n\tif (SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC) != 0) {\n\t\tprintf(\"Bring Up Code %02x\\n\",\n\t\t    SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC));\n\t\treturn 1;\n\t}\n\n\tsc->sc_init_status = SRB_INB(sc, sc->sc_srb, SRB_INIT_STATUS);\n\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0;\n\n\t/* XXX should depend on sc_resvdmem. */\n\tif (MM_INB(sc, TR_RAM_OFFSET) == 0xB && sc->sc_memsize == 65536)\n\t\tfor (i = 0; i < 512; i++)\n\t\t\tSR_OUTB(sc, 0xfe00 + i, 0);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_reset(sc)\nstruct tr_softc *sc;\n{\n\tint i;\n\n\tsc->sc_srb = 0;\n\n\t/* \n\t * Reset the card.\n\t */\n\t/* latch on an unconditional adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RESET, 0);\n\tdelay(50000); /* delay 50ms */\n\t/*\n\t * XXX set paging if we have the right type of card\n\t */\n\t/* turn off adapter reset */\n\tbus_space_write_1(sc->sc_piot, sc->sc_pioh, TR_RELEASE, 0);\n\n\t/* Enable interrupts. */\n\n\tACA_SETB(sc, ACA_ISRP_e, INT_ENABLE);\n\n\t/* Wait for an answer from the adapter. */\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tif (ACA_RDB(sc, ACA_ISRP_o) & SRB_RESP_INT)\n\t\t\tbreak;\n\t\tdelay(100);\n\t}\n\n\tif (i == 35000 && sc->sc_srb == 0) {\n\t\tprintf(\"No response from adapter after reset\\n\");\n\t\treturn 1;\n\t}\n\n\tACA_RSTB(sc, ACA_ISRP_o, ~(SRB_RESP_INT));\n\n\tACA_OUTB(sc, ACA_RRR_e, (sc->sc_maddr >> 12));\n\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\tif (SRB_INB(sc, sc->sc_srb, SRB_CMD) != 0x80) {\n\t\tprintf(\"Initialization incomplete, status: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_CMD));\n\t\treturn 1;\n\t}\n\tif (SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC) != 0) {\n\t\tprintf(\"Bring Up Code %02x\\n\",\n\t\t    SRB_INB(sc, sc->sc_srb, SRB_INIT_BUC));\n\t\treturn 1;\n\t}\n\n\tsc->sc_init_status = SRB_INB(sc, sc->sc_srb, SRB_INIT_STATUS);\n\n\tsc->sc_xmit_head = sc->sc_xmit_tail = 0;\n\n\t/* XXX should depend on sc_resvdmem. */\n\tif (MM_INB(sc, TR_RAM_OFFSET) == 0xB && sc->sc_memsize == 65536)\n\t\tfor (i = 0; i < 512; i++)\n\t\t\tSR_OUTB(sc, 0xfe00 + i, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_setspeed",
          "args": [
            "sc",
            "4"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "tr_setspeed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "459-479",
          "snippet": "int\ntr_setspeed(sc, speed)\nstruct tr_softc *sc;\nu_int8_t speed;\n{\n\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_SET_DEFAULT_RING_SPEED);\n\tSRB_OUTB(sc, sc->sc_srb, CMD_RETCODE, 0xfe);\n\tSRB_OUTB(sc, sc->sc_srb, SRB_SET_DEFRSP, speed);\n\t/* Tell adapter: command in SRB. */\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t/* Wait for it to complete. */\n\ttr_sleep(sc);\n\n\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\tprintf(\"set default ringspeed returned: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntr_setspeed(sc, speed)\nstruct tr_softc *sc;\nu_int8_t speed;\n{\n\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_SET_DEFAULT_RING_SPEED);\n\tSRB_OUTB(sc, sc->sc_srb, CMD_RETCODE, 0xfe);\n\tSRB_OUTB(sc, sc->sc_srb, SRB_SET_DEFRSP, speed);\n\t/* Tell adapter: command in SRB. */\n\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t/* Wait for it to complete. */\n\ttr_sleep(sc);\n\n\tif ((SRB_INB(sc, sc->sc_srb, SRB_RETCODE) != 0)) {\n\t\tprintf(\"set default ringspeed returned: %02x\\n\",\n\t\t\tSRB_INB(sc, sc->sc_srb, SRB_RETCODE));\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tr_stop",
          "args": [
            "sc"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "tr_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "570-591",
          "snippet": "void\ntr_stop(sc)\nstruct tr_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0) {\n/*\n * transmitter cannot be used from now on\n */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\t/* Close command. */\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CLOSE);\n\t\t/* Tell adapter: command in SRB. */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\t/* Wait for it to complete. */\n\t\ttr_sleep(sc);\n\t\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\t}\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;",
            "struct ifnet *ifp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\nstruct ifnet *ifp;\n\nvoid\ntr_stop(sc)\nstruct tr_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tif ((ifp->if_flags & IFF_RUNNING) != 0) {\n/*\n * transmitter cannot be used from now on\n */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\n\t\t/* Close command. */\n\t\tSRB_OUTB(sc, sc->sc_srb, SRB_CMD, DIR_CLOSE);\n\t\t/* Tell adapter: command in SRB. */\n\t\tACA_SETB(sc, ACA_ISRA_o, CMD_IN_SRB);\n\n\t\t/* Wait for it to complete. */\n\t\ttr_sleep(sc);\n\t\tsc->sc_srb = ACA_RDW(sc, ACA_WRBR);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "sc->sc_media.ifm_media"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_TYPE",
          "args": [
            "sc->sc_media.ifm_media"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\ttropic_mediachange;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nint\ntropic_mediachange(sc)\n\tstruct tr_softc *sc;\n{\n\tif (IFM_TYPE(sc->sc_media.ifm_media) != IFM_TOKEN)\n\t\treturn EINVAL;\n\n\tswitch (IFM_SUBTYPE(sc->sc_media.ifm_media)) {\n\tcase IFM_TOK_STP16:\n\tcase IFM_TOK_UTP16:\n\t\tif ((sc->sc_init_status & RSP_16) == 0) {\n\t\t\ttr_stop(sc);\n\t\t\tif (tr_setspeed(sc, 16))\n\t\t\t\treturn EINVAL;\n\t\t\tif (tr_reset(sc))\n\t\t\t\treturn EINVAL;\n\t\t\tif (tr_config(sc))\n\t\t\t\treturn EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IFM_TOK_STP4:\n\tcase IFM_TOK_UTP4:\n\t\tif ((sc->sc_init_status & RSP_16) != 0) {\n\t\t\ttr_stop(sc);\n\t\t\tif (tr_setspeed(sc, 4))\n\t\t\t\treturn EINVAL;\n\t\t\tif (tr_reset(sc))\n\t\t\t\treturn EINVAL;\n\t\t\tif (tr_config(sc))\n\t\t\t\treturn EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n/*\n * XXX Handle Early Token Release !!!!\n */\n\treturn 0;\n}"
  }
]