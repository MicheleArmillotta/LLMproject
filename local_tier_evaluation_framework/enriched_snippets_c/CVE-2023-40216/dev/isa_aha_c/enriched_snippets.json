[
  {
    "function_name": "aha_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "1385-1434",
    "snippet": "void\naha_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aha_ccb *ccb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct aha_softc *sc;\n\tint s;\n\n\ts = splbio();\n\tisadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\txs = ccb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef AHADIAG\n\t/*\n\t * If The ccb's mbx is not free, then the board has gone south?\n\t */\n\taha_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = AHA_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\taha_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tAHA_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
    ],
    "globals_used": [
      "aha_finish_ccbs __P((struct aha_softc *));",
      "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "void aha_queue_ccb",
      "void aha_collect_mbo",
      "void aha_timeout",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "int flags;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
      "u_long ccb_phys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aha_queue_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "aha_queue_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "698-706",
          "snippet": "void\naha_queue_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\taha_start_ccbs(sc);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "void aha_queue_ccb",
            "void aha_start_ccbs",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_queue_ccb;\nvoid aha_start_ccbs;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_queue_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\taha_start_ccbs(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aha_collect_mbo",
          "args": [
            "sc"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "aha_collect_mbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "711-740",
          "snippet": "void\naha_collect_mbo(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef AHADIAG\n\tstruct aha_ccb *ccb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != AHA_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef AHADIAG\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbo ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t} else\n\t\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(sc->sc_mbx)"
          ],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "struct aha_ccb *aha_ccb_phys_kv",
            "void aha_collect_mbo",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *aha_ccb_phys_kv;\nvoid aha_collect_mbo;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_collect_mbo(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef AHADIAG\n\tstruct aha_ccb *ccb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != AHA_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef AHADIAG\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbo ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t} else\n\t\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_copyfrombuf",
          "args": [
            "(caddr_t)ccb",
            "CCB_PHYS_SIZE",
            "1",
            "ccb->ccb_phys"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAHA_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_queue_ccb;\nvoid aha_collect_mbo;\nvoid aha_timeout;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nvoid\naha_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aha_ccb *ccb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct aha_softc *sc;\n\tint s;\n\n\ts = splbio();\n\tisadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\txs = ccb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef AHADIAG\n\t/*\n\t * If The ccb's mbx is not free, then the board has gone south?\n\t */\n\taha_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = AHA_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\taha_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "aha_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "1361-1383",
    "snippet": "int\naha_poll(sc, xs, count)\n\tstruct aha_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint iobase = sc->sc_iobase;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (inb(iobase + AHA_INTR_PORT) & AHA_INTR_ANYINTR)\n\t\t\tahaintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aha_finish_ccbs __P((struct aha_softc *));",
      "int ahaintr",
      "int aha_poll",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "int flags;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahaintr",
          "args": [
            "sc"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "ahaintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "505-548",
          "snippet": "int\nahaintr(arg)\n\tvoid *arg;\n{\n\tstruct aha_softc *sc = arg;\n\tint iobase = sc->sc_iobase;\n\tu_char sts;\n\n#ifdef AHADEBUG\n\tif (aha_debug)\n\t\tprintf(\"%s: ahaintr \", sc->sc_dev.dv_xname);\n#endif /*AHADEBUG */\n\n\t/*\n\t * First acknowlege the interrupt, Then if it's not telling about\n\t * a completed operation just return.\n\t */\n\tsts = inb(iobase + AHA_INTR_PORT);\n\tif ((sts & AHA_INTR_ANYINTR) == 0)\n\t\treturn 0;\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\n#ifdef AHADIAG\n\t/* Make sure we clear CCB_SENDING before finishing a CCB. */\n\taha_collect_mbo(sc);\n#endif\n\n\t/* Mail box out empty? */\n\tif (sts & AHA_INTR_MBOA) {\n\t\tstruct aha_toggle toggle;\n\n\t\ttoggle.cmd.opcode = AHA_MBO_INTR_EN;\n\t\ttoggle.cmd.enable = 0;\n\t\taha_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd,\n\t\t    0, (u_char *)0);\n\t\taha_start_ccbs(sc);\n\t}\n\n\t/* Mail box in full? */\n\tif (sts & AHA_INTR_MBIF)\n\t\taha_finish_ccbs(sc);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "int ahaintr",
            "void aha_collect_mbo",
            "void aha_start_ccbs",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nint ahaintr;\nvoid aha_collect_mbo;\nvoid aha_start_ccbs;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\nahaintr(arg)\n\tvoid *arg;\n{\n\tstruct aha_softc *sc = arg;\n\tint iobase = sc->sc_iobase;\n\tu_char sts;\n\n#ifdef AHADEBUG\n\tif (aha_debug)\n\t\tprintf(\"%s: ahaintr \", sc->sc_dev.dv_xname);\n#endif /*AHADEBUG */\n\n\t/*\n\t * First acknowlege the interrupt, Then if it's not telling about\n\t * a completed operation just return.\n\t */\n\tsts = inb(iobase + AHA_INTR_PORT);\n\tif ((sts & AHA_INTR_ANYINTR) == 0)\n\t\treturn 0;\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\n#ifdef AHADIAG\n\t/* Make sure we clear CCB_SENDING before finishing a CCB. */\n\taha_collect_mbo(sc);\n#endif\n\n\t/* Mail box out empty? */\n\tif (sts & AHA_INTR_MBOA) {\n\t\tstruct aha_toggle toggle;\n\n\t\ttoggle.cmd.opcode = AHA_MBO_INTR_EN;\n\t\ttoggle.cmd.enable = 0;\n\t\taha_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd,\n\t\t    0, (u_char *)0);\n\t\taha_start_ccbs(sc);\n\t}\n\n\t/* Mail box in full? */\n\tif (sts & AHA_INTR_MBIF)\n\t\taha_finish_ccbs(sc);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + AHA_INTR_PORT"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\nint ahaintr;\nint aha_poll;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_poll(sc, xs, count)\n\tstruct aha_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint iobase = sc->sc_iobase;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (inb(iobase + AHA_INTR_PORT) & AHA_INTR_ANYINTR)\n\t\t\tahaintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "aha_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "1204-1356",
    "snippet": "int\naha_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aha_softc *sc = sc_link->adapter_softc;\n\tstruct aha_ccb *ccb;\n\tstruct aha_scat_gath *sg;\n\tint seg, flags, mflags;\n#ifdef\tTFS\n\tstruct iovec *iovp;\n\tint datalen;\n#endif\n\tint s;\n\n\tSC_DEBUG(sc_link, SDEV_DB2, (\"aha_scsi_cmd\\n\"));\n\t/*\n\t * get a ccb to use. If the transfer\n\t * is from a buf (possibly from interrupt time)\n\t * then we can't allow it to sleep\n\t */\n\tflags = xs->flags;\n\tif (flags & SCSI_NOSLEEP)\n\t\tmflags = ISADMA_MAP_BOUNCE;\n\telse\n\t\tmflags = ISADMA_MAP_BOUNCE | ISADMA_MAP_WAITOK;\n\tif ((ccb = aha_get_ccb(sc, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\t/*\n\t * Put all the arguments for the xfer in the ccb\n\t */\n\tif (flags & SCSI_RESET) {\n\t\tccb->opcode = AHA_RESET_CCB;\n\t\tccb->scsi_cmd_length = 0;\n\t} else {\n\t\t/* can't use S/G if zero length */\n\t\tccb->opcode =\n\t\t    (xs->datalen ? AHA_INIT_SCAT_GATH_CCB : AHA_INITIATOR_CCB);\n\t\tbcopy(xs->cmd, &ccb->scsi_cmd,\n\t\t    ccb->scsi_cmd_length = xs->cmdlen);\n\t}\n\n\tif (xs->datalen) {\n\t\tsg = ccb->scat_gath;\n\t\tseg = 0;\n#ifdef\tTFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\tiovp = ((struct uio *)xs->data)->uio_iov;\n\t\t\tdatalen = ((struct uio *)xs->data)->uio_iovcnt;\n\t\t\txs->datalen = 0;\n\t\t\twhile (datalen && seg < AHA_NSEG) {\n\t\t\t\tltophys(iovp->iov_base, sg->seg_addr);\n\t\t\t\tltophys(iovp->iov_len, sg->seg_len);\n\t\t\t\txs->datalen += iovp->iov_len;\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"UIO(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base));\n\t\t\t\tsg++;\n\t\t\t\tiovp++;\n\t\t\t\tseg++;\n\t\t\t\tdatalen--;\n\t\t\t}\n\t\t} else\n#endif /* TFS */\n\t\t{\n\t\t\t/*\n\t\t\t * Set up the scatter-gather block.\n\t\t\t */\n\t\t\tccb->data_nseg = isadma_map(xs->data, xs->datalen,\n\t\t\t    ccb->data_phys, mflags);\n\t\t\tfor (seg = 0; seg < ccb->data_nseg; seg++) {\n\t\t\t\tltophys(ccb->data_phys[seg].addr,\n\t\t\t\t    sg[seg].seg_addr);\n\t\t\t\tltophys(ccb->data_phys[seg].length,\n\t\t\t\t    sg[seg].seg_len);\n\t\t\t}\n\t\t}\n\t\t/* end of iov/kv decision */\n\t\tif (ccb->data_nseg == 0) {\n\t\t\tprintf(\"%s: aha_scsi_cmd, cannot map\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto bad;\n\t\t} else if (flags & SCSI_DATA_OUT)\n\t\t\tisadma_copytobuf(xs->data, xs->datalen,\n\t\t\t    ccb->data_nseg, ccb->data_phys);\n\t\tltophys((unsigned)\n\t\t    ((struct aha_ccb *)(ccb->ccb_phys[0].addr))->scat_gath,\n\t\t    ccb->data_addr);\n\t\tltophys(ccb->data_nseg * sizeof(struct aha_scat_gath),\n\t\t    ccb->data_length);\n\t} else {\t\t/* No data xfer, use non S/G values */\n\t\tltophys(0, ccb->data_addr);\n\t\tltophys(0, ccb->data_length);\n\t}\n\n\tccb->data_out = 0;\n\tccb->data_in = 0;\n\tccb->target = sc_link->target;\n\tccb->lun = sc_link->lun;\n\tccb->req_sense_length = sizeof(ccb->scsi_sense);\n\tccb->host_stat = 0x00;\n\tccb->target_stat = 0x00;\n\tccb->link_id = 0;\n\tltophys(0, ccb->link_addr);\n\n\ts = splbio();\n\taha_queue_ccb(sc, ccb);\n\n\t/*\n\t * Usually return SUCCESSFULLY QUEUED\n\t */\n\tSC_DEBUG(sc_link, SDEV_DB3, (\"cmd_sent\\n\"));\n\n\tif (VOLATILE_XS(xs)) {\n\t\twhile ((ccb->xs->flags & ITSDONE) == 0) {\n\t\t\ttsleep(ccb, PRIBIO, \"ahawait\", 0);\n\t\t}\n\t\tif (ccb->data_nseg) {\n\t\t\tif (flags & SCSI_DATA_IN)\n\t\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t\t    ccb->data_nseg, ccb->data_phys);\n\t\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t\t    ccb->data_nseg, ccb->data_phys);\n\t\t}\n\t\taha_free_ccb(sc, ccb);\n\t\tscsi_done(xs);\n\t\tsplx(s);\n\t\treturn COMPLETE;\n\t}\n\tsplx(s);\n\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn SUCCESSFULLY_QUEUED;\n\n\t/*\n\t * If we can't use interrupts, poll on completion\n\t */\n\tif (aha_poll(sc, xs, ccb->timeout)) {\n\t\taha_timeout(ccb);\n\t\tif (aha_poll(sc, xs, ccb->timeout))\n\t\t\taha_timeout(ccb);\n\t}\n\treturn COMPLETE;\n\nbad:\n\txs->error = XS_DRIVER_STUFFUP;\n\taha_free_ccb(sc, ccb);\n\treturn COMPLETE;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aha_finish_ccbs __P((struct aha_softc *));",
      "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "void aha_free_ccb",
      "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "struct aha_ccb *aha_get_ccb",
      "void aha_queue_ccb",
      "int aha_scsi_cmd",
      "int aha_poll",
      "void aha_timeout",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "int flags;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
      "u_long ccb_phys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aha_free_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "aha_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "562-599",
          "snippet": "void\naha_free_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tint s, hashnum;\n\tstruct aha_ccb **hashccb;\n\n\ts = splbio();\n\n\tif (ccb->ccb_phys[0].addr)\n\t        isadma_unmap((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\n\t/* remove from hash table */\n\n\thashnum = CCB_HASH(ccb->ccb_phys[0].addr);\n\thashccb = &sc->sc_ccbhash[hashnum];\n\n\twhile (*hashccb) {\n\t\tif ((*hashccb)->ccb_phys[0].addr == ccb->ccb_phys[0].addr) {\n\t\t\t*hashccb = (*hashccb)->nexthash;\n\t\t\tbreak;\n\t\t}\n\t\thashccb = &(*hashccb)->nexthash;\n\t}\n\n\taha_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "void aha_free_ccb",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
            "u_long ccb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_free_ccb;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nvoid\naha_free_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tint s, hashnum;\n\tstruct aha_ccb **hashccb;\n\n\ts = splbio();\n\n\tif (ccb->ccb_phys[0].addr)\n\t        isadma_unmap((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\n\t/* remove from hash table */\n\n\thashnum = CCB_HASH(ccb->ccb_phys[0].addr);\n\thashccb = &sc->sc_ccbhash[hashnum];\n\n\twhile (*hashccb) {\n\t\tif ((*hashccb)->ccb_phys[0].addr == ccb->ccb_phys[0].addr) {\n\t\t\t*hashccb = (*hashccb)->nexthash;\n\t\t\tbreak;\n\t\t}\n\t\thashccb = &(*hashccb)->nexthash;\n\t}\n\n\taha_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_timeout",
          "args": [
            "ccb"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "aha_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "1385-1434",
          "snippet": "void\naha_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aha_ccb *ccb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct aha_softc *sc;\n\tint s;\n\n\ts = splbio();\n\tisadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\txs = ccb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef AHADIAG\n\t/*\n\t * If The ccb's mbx is not free, then the board has gone south?\n\t */\n\taha_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = AHA_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\taha_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tAHA_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "void aha_queue_ccb",
            "void aha_collect_mbo",
            "void aha_timeout",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
            "u_long ccb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAHA_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_queue_ccb;\nvoid aha_collect_mbo;\nvoid aha_timeout;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nvoid\naha_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aha_ccb *ccb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct aha_softc *sc;\n\tint s;\n\n\ts = splbio();\n\tisadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\txs = ccb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef AHADIAG\n\t/*\n\t * If The ccb's mbx is not free, then the board has gone south?\n\t */\n\taha_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = AHA_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\taha_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_poll",
          "args": [
            "sc",
            "xs",
            "ccb->timeout"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "aha_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "1361-1383",
          "snippet": "int\naha_poll(sc, xs, count)\n\tstruct aha_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint iobase = sc->sc_iobase;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (inb(iobase + AHA_INTR_PORT) & AHA_INTR_ANYINTR)\n\t\t\tahaintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "int ahaintr",
            "int aha_poll",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\nint ahaintr;\nint aha_poll;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_poll(sc, xs, count)\n\tstruct aha_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint iobase = sc->sc_iobase;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (inb(iobase + AHA_INTR_PORT) & AHA_INTR_ANYINTR)\n\t\t\tahaintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_unmap",
          "args": [
            "xs->data",
            "xs->datalen",
            "ccb->data_nseg",
            "ccb->data_phys"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_copyfrombuf",
          "args": [
            "xs->data",
            "xs->datalen",
            "ccb->data_nseg",
            "ccb->data_phys"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "ccb",
            "PRIBIO",
            "\"ahawait\"",
            "0"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOLATILE_XS",
          "args": [
            "xs"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB3",
            "(\"cmd_sent\\n\")"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aha_queue_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "aha_queue_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "698-706",
          "snippet": "void\naha_queue_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\taha_start_ccbs(sc);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "void aha_queue_ccb",
            "void aha_start_ccbs",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_queue_ccb;\nvoid aha_start_ccbs;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_queue_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\taha_start_ccbs(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "0",
            "ccb->link_addr"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "0",
            "ccb->data_length"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "0",
            "ccb->data_addr"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "ccb->data_nseg * sizeof(struct aha_scat_gath)",
            "ccb->data_length"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "(unsigned)\n\t\t    ((struct aha_ccb *)(ccb->ccb_phys[0].addr))->scat_gath",
            "ccb->data_addr"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_copytobuf",
          "args": [
            "xs->data",
            "xs->datalen",
            "ccb->data_nseg",
            "ccb->data_phys"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: aha_scsi_cmd, cannot map\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "ccb->data_phys[seg].length",
            "sg[seg].seg_len"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "ccb->data_phys[seg].addr",
            "sg[seg].seg_addr"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_map",
          "args": [
            "xs->data",
            "xs->datalen",
            "ccb->data_phys",
            "mflags"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"UIO(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base)"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "iovp->iov_len",
            "sg->seg_len"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "iovp->iov_base",
            "sg->seg_addr"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "xs->cmd",
            "&ccb->scsi_cmd",
            "ccb->scsi_cmd_length = xs->cmdlen"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_get_ccb",
          "args": [
            "sc",
            "flags"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB2",
            "(\"aha_scsi_cmd\\n\")"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_free_ccb;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *aha_get_ccb;\nvoid aha_queue_ccb;\nint aha_scsi_cmd;\nint aha_poll;\nvoid aha_timeout;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nint\naha_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct aha_softc *sc = sc_link->adapter_softc;\n\tstruct aha_ccb *ccb;\n\tstruct aha_scat_gath *sg;\n\tint seg, flags, mflags;\n#ifdef\tTFS\n\tstruct iovec *iovp;\n\tint datalen;\n#endif\n\tint s;\n\n\tSC_DEBUG(sc_link, SDEV_DB2, (\"aha_scsi_cmd\\n\"));\n\t/*\n\t * get a ccb to use. If the transfer\n\t * is from a buf (possibly from interrupt time)\n\t * then we can't allow it to sleep\n\t */\n\tflags = xs->flags;\n\tif (flags & SCSI_NOSLEEP)\n\t\tmflags = ISADMA_MAP_BOUNCE;\n\telse\n\t\tmflags = ISADMA_MAP_BOUNCE | ISADMA_MAP_WAITOK;\n\tif ((ccb = aha_get_ccb(sc, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\t/*\n\t * Put all the arguments for the xfer in the ccb\n\t */\n\tif (flags & SCSI_RESET) {\n\t\tccb->opcode = AHA_RESET_CCB;\n\t\tccb->scsi_cmd_length = 0;\n\t} else {\n\t\t/* can't use S/G if zero length */\n\t\tccb->opcode =\n\t\t    (xs->datalen ? AHA_INIT_SCAT_GATH_CCB : AHA_INITIATOR_CCB);\n\t\tbcopy(xs->cmd, &ccb->scsi_cmd,\n\t\t    ccb->scsi_cmd_length = xs->cmdlen);\n\t}\n\n\tif (xs->datalen) {\n\t\tsg = ccb->scat_gath;\n\t\tseg = 0;\n#ifdef\tTFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\tiovp = ((struct uio *)xs->data)->uio_iov;\n\t\t\tdatalen = ((struct uio *)xs->data)->uio_iovcnt;\n\t\t\txs->datalen = 0;\n\t\t\twhile (datalen && seg < AHA_NSEG) {\n\t\t\t\tltophys(iovp->iov_base, sg->seg_addr);\n\t\t\t\tltophys(iovp->iov_len, sg->seg_len);\n\t\t\t\txs->datalen += iovp->iov_len;\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"UIO(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base));\n\t\t\t\tsg++;\n\t\t\t\tiovp++;\n\t\t\t\tseg++;\n\t\t\t\tdatalen--;\n\t\t\t}\n\t\t} else\n#endif /* TFS */\n\t\t{\n\t\t\t/*\n\t\t\t * Set up the scatter-gather block.\n\t\t\t */\n\t\t\tccb->data_nseg = isadma_map(xs->data, xs->datalen,\n\t\t\t    ccb->data_phys, mflags);\n\t\t\tfor (seg = 0; seg < ccb->data_nseg; seg++) {\n\t\t\t\tltophys(ccb->data_phys[seg].addr,\n\t\t\t\t    sg[seg].seg_addr);\n\t\t\t\tltophys(ccb->data_phys[seg].length,\n\t\t\t\t    sg[seg].seg_len);\n\t\t\t}\n\t\t}\n\t\t/* end of iov/kv decision */\n\t\tif (ccb->data_nseg == 0) {\n\t\t\tprintf(\"%s: aha_scsi_cmd, cannot map\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto bad;\n\t\t} else if (flags & SCSI_DATA_OUT)\n\t\t\tisadma_copytobuf(xs->data, xs->datalen,\n\t\t\t    ccb->data_nseg, ccb->data_phys);\n\t\tltophys((unsigned)\n\t\t    ((struct aha_ccb *)(ccb->ccb_phys[0].addr))->scat_gath,\n\t\t    ccb->data_addr);\n\t\tltophys(ccb->data_nseg * sizeof(struct aha_scat_gath),\n\t\t    ccb->data_length);\n\t} else {\t\t/* No data xfer, use non S/G values */\n\t\tltophys(0, ccb->data_addr);\n\t\tltophys(0, ccb->data_length);\n\t}\n\n\tccb->data_out = 0;\n\tccb->data_in = 0;\n\tccb->target = sc_link->target;\n\tccb->lun = sc_link->lun;\n\tccb->req_sense_length = sizeof(ccb->scsi_sense);\n\tccb->host_stat = 0x00;\n\tccb->target_stat = 0x00;\n\tccb->link_id = 0;\n\tltophys(0, ccb->link_addr);\n\n\ts = splbio();\n\taha_queue_ccb(sc, ccb);\n\n\t/*\n\t * Usually return SUCCESSFULLY QUEUED\n\t */\n\tSC_DEBUG(sc_link, SDEV_DB3, (\"cmd_sent\\n\"));\n\n\tif (VOLATILE_XS(xs)) {\n\t\twhile ((ccb->xs->flags & ITSDONE) == 0) {\n\t\t\ttsleep(ccb, PRIBIO, \"ahawait\", 0);\n\t\t}\n\t\tif (ccb->data_nseg) {\n\t\t\tif (flags & SCSI_DATA_IN)\n\t\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t\t    ccb->data_nseg, ccb->data_phys);\n\t\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t\t    ccb->data_nseg, ccb->data_phys);\n\t\t}\n\t\taha_free_ccb(sc, ccb);\n\t\tscsi_done(xs);\n\t\tsplx(s);\n\t\treturn COMPLETE;\n\t}\n\tsplx(s);\n\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn SUCCESSFULLY_QUEUED;\n\n\t/*\n\t * If we can't use interrupts, poll on completion\n\t */\n\tif (aha_poll(sc, xs, ccb->timeout)) {\n\t\taha_timeout(ccb);\n\t\tif (aha_poll(sc, xs, ccb->timeout))\n\t\t\taha_timeout(ccb);\n\t}\n\treturn COMPLETE;\n\nbad:\n\txs->error = XS_DRIVER_STUFFUP;\n\taha_free_ccb(sc, ccb);\n\treturn COMPLETE;\n}"
  },
  {
    "function_name": "ahaminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "1190-1198",
    "snippet": "void\nahaminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((AHA_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((AHA_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ahaminphys"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "ahaminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "1190-1198",
          "snippet": "void\nahaminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((AHA_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((AHA_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid ahaminphys;\n\nvoid\nahaminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((AHA_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((AHA_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
  },
  {
    "function_name": "aha_inquire_setup_information",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "1108-1188",
    "snippet": "void\naha_inquire_setup_information(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_revision revision;\n\tu_char sts;\n\tint i;\n\tchar *p;\n\n\tstrcpy(sc->sc_model, \"unknown\");\n\n\t/*\n\t * Assume we have a board at this stage, do an adapter inquire\n\t * to find out what type of controller it is.  If the command\n\t * fails, we assume it's either a crusty board or an old 1542\n\t * clone, and skip the board-specific stuff.\n\t */\n\trevision.cmd.opcode = AHA_INQUIRE_REVISION;\n\tif (aha_cmd(iobase, sc, sizeof(revision.cmd), (u_char *)&revision.cmd,\n\t    sizeof(revision.reply), (u_char *)&revision.reply)) {\n\t\t/*\n\t\t * aha_cmd() already started the reset.  It's not clear we\n\t\t * even need to bother here.\n\t\t */\n\t\tfor (i = AHA_RESET_TIMEOUT; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))\n\t\t\t\tbreak;\n\t\t\tdelay(1000);\n\t\t}\n\t\tif (!i) {\n#ifdef AHADEBUG\n\t\t\tprintf(\"aha_init: soft reset failed\\n\");\n#endif /* AHADEBUG */\n\t\t\treturn;\n\t\t}\n#ifdef AHADEBUG\n\t\tprintf(\"aha_init: inquire command failed\\n\");\n#endif /* AHADEBUG */\n\t\tgoto noinquire;\n\t}\n\n#ifdef AHADEBUG\n\tprintf(\"%s: inquire %x, %x, %x, %x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    revision.reply.boardid, revision.reply.spec_opts,\n\t    revision.reply.revision_1, revision.reply.revision_2);\n#endif /* AHADEBUG */\n\n\tswitch (revision.reply.boardid) {\n\tcase 0x31:\n\t\tstrcpy(sc->sc_model, \"1540\");\n\t\tbreak;\n\tcase 0x41:\n\t\tstrcpy(sc->sc_model, \"1540A/1542A/1542B\");\n\t\tbreak;\n\tcase 0x42:\n\t\tstrcpy(sc->sc_model, \"1640\");\n\t\tbreak;\n\tcase 0x43:\n\tcase 0x44:\t\t/* Is this 1542C or -CF? */\n\t\tstrcpy(sc->sc_model, \"1542C\");\n\t\tbreak;\n\tcase 0x45:\n\t\tstrcpy(sc->sc_model, \"1542CF\");\n\t\tbreak;\n\tcase 0x46:\n\t\tstrcpy(sc->sc_model, \"1542CP\");\n\t\tbreak;\n\t}\n\n\tp = sc->sc_firmware;\n\t*p++ = revision.reply.revision_1;\n\t*p++ = '.';\n\t*p++ = revision.reply.revision_2;\n\t*p = '\\0';\n\nnoinquire:\n\tprintf(\": model AHA-%s, firmware %s\\n\", sc->sc_model, sc->sc_firmware);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define AHA_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */"
    ],
    "globals_used": [
      "int aha_cmd",
      "struct aha_softc *, int, u_char *, int, u_char *));",
      "aha_finish_ccbs __P((struct aha_softc *));",
      "void aha_init",
      "void aha_inquire_setup_information",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": model AHA-%s, firmware %s\\n\"",
            "sc->sc_model",
            "sc->sc_firmware"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->sc_model",
            "\"1542CP\""
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->sc_model",
            "\"1542CF\""
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->sc_model",
            "\"1542C\""
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->sc_model",
            "\"1640\""
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->sc_model",
            "\"1540A/1542A/1542B\""
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->sc_model",
            "\"1540\""
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + AHA_STAT_PORT"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_cmd",
          "args": [
            "iobase",
            "sc",
            "sizeof(revision.cmd)",
            "(u_char *)&revision.cmd",
            "sizeof(revision.reply)",
            "(u_char *)&revision.reply"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "aha_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "208-324",
          "snippet": "int\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->sc_model",
            "\"unknown\""
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AHA_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nvoid aha_init;\nvoid aha_inquire_setup_information;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_inquire_setup_information(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_revision revision;\n\tu_char sts;\n\tint i;\n\tchar *p;\n\n\tstrcpy(sc->sc_model, \"unknown\");\n\n\t/*\n\t * Assume we have a board at this stage, do an adapter inquire\n\t * to find out what type of controller it is.  If the command\n\t * fails, we assume it's either a crusty board or an old 1542\n\t * clone, and skip the board-specific stuff.\n\t */\n\trevision.cmd.opcode = AHA_INQUIRE_REVISION;\n\tif (aha_cmd(iobase, sc, sizeof(revision.cmd), (u_char *)&revision.cmd,\n\t    sizeof(revision.reply), (u_char *)&revision.reply)) {\n\t\t/*\n\t\t * aha_cmd() already started the reset.  It's not clear we\n\t\t * even need to bother here.\n\t\t */\n\t\tfor (i = AHA_RESET_TIMEOUT; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))\n\t\t\t\tbreak;\n\t\t\tdelay(1000);\n\t\t}\n\t\tif (!i) {\n#ifdef AHADEBUG\n\t\t\tprintf(\"aha_init: soft reset failed\\n\");\n#endif /* AHADEBUG */\n\t\t\treturn;\n\t\t}\n#ifdef AHADEBUG\n\t\tprintf(\"aha_init: inquire command failed\\n\");\n#endif /* AHADEBUG */\n\t\tgoto noinquire;\n\t}\n\n#ifdef AHADEBUG\n\tprintf(\"%s: inquire %x, %x, %x, %x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    revision.reply.boardid, revision.reply.spec_opts,\n\t    revision.reply.revision_1, revision.reply.revision_2);\n#endif /* AHADEBUG */\n\n\tswitch (revision.reply.boardid) {\n\tcase 0x31:\n\t\tstrcpy(sc->sc_model, \"1540\");\n\t\tbreak;\n\tcase 0x41:\n\t\tstrcpy(sc->sc_model, \"1540A/1542A/1542B\");\n\t\tbreak;\n\tcase 0x42:\n\t\tstrcpy(sc->sc_model, \"1640\");\n\t\tbreak;\n\tcase 0x43:\n\tcase 0x44:\t\t/* Is this 1542C or -CF? */\n\t\tstrcpy(sc->sc_model, \"1542C\");\n\t\tbreak;\n\tcase 0x45:\n\t\tstrcpy(sc->sc_model, \"1542CF\");\n\t\tbreak;\n\tcase 0x46:\n\t\tstrcpy(sc->sc_model, \"1542CP\");\n\t\tbreak;\n\t}\n\n\tp = sc->sc_firmware;\n\t*p++ = revision.reply.revision_1;\n\t*p++ = '.';\n\t*p++ = revision.reply.revision_2;\n\t*p = '\\0';\n\nnoinquire:\n\tprintf(\": model AHA-%s, firmware %s\\n\", sc->sc_model, sc->sc_firmware);\n}"
  },
  {
    "function_name": "aha_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "1002-1106",
    "snippet": "void\naha_init(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_devices devices;\n\tstruct aha_setup setup;\n\tstruct aha_mailbox mailbox;\n\tint i;\n\n\t/*\n\t * XXX\n\t * If we are a 1542C or later, disable the extended BIOS so that the\n\t * mailbox interface is unlocked.\n\t * No need to check the extended BIOS flags as some of the\n\t * extensions that cause us problems are not flagged in that byte.\n\t */\n\tif (!strncmp(sc->sc_model, \"1542C\", 5)) {\n\t\tstruct aha_extbios extbios;\n\t\tstruct aha_unlock unlock;\n\n\t\tprintf(\"%s: unlocking mailbox interface\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\textbios.cmd.opcode = AHA_EXT_BIOS;\n\t\taha_cmd(iobase, sc, sizeof(extbios.cmd),\n\t\t    (u_char *)&extbios.cmd, sizeof(extbios.reply),\n\t\t    (u_char *)&extbios.reply);\n\n#ifdef AHADEBUG\n\t\tprintf(\"%s: flags=%02x, mailboxlock=%02x\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    extbios.reply.flags, extbios.reply.mailboxlock);\n#endif /* AHADEBUG */\n\n\t\tunlock.cmd.opcode = AHA_MBX_ENABLE;\n\t\tunlock.cmd.junk = 0;\n\t\tunlock.cmd.magic = extbios.reply.mailboxlock;\n\t\taha_cmd(iobase, sc, sizeof(unlock.cmd), (u_char *)&unlock.cmd,\n\t\t    0, (u_char *)0);\n\t}\n\n#if 0\n\t/*\n\t * Change the bus on/off times to not clash with other dma users.\n\t */\n\taha_cmd(sc, 1, 0, 0, 0, AHA_BUS_ON_TIME_SET, 7);\n\taha_cmd(sc, 1, 0, 0, 0, AHA_BUS_OFF_TIME_SET, 4);\n#endif\n\n\t/* Inquire Installed Devices (to force synchronous negotiation). */\n\tdevices.cmd.opcode = AHA_INQUIRE_DEVICES;\n\taha_cmd(iobase, sc, sizeof(devices.cmd), (u_char *)&devices.cmd,\n\t    sizeof(devices.reply), (u_char *)&devices.reply);\n\n\t/* Obtain setup information from. */\n\tsetup.cmd.opcode = AHA_INQUIRE_SETUP;\n\tsetup.cmd.len = sizeof(setup.reply);\n\taha_cmd(iobase, sc, sizeof(setup.cmd), (u_char *)&setup.cmd,\n\t    sizeof(setup.reply), (u_char *)&setup.reply);\n\n\tprintf(\"%s: %s, %s\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    setup.reply.sync_neg ? \"sync\" : \"async\",\n\t    setup.reply.parity ? \"parity\" : \"no parity\");\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!setup.reply.sync[i].valid ||\n\t\t    (!setup.reply.sync[i].offset &&\n\t\t    !setup.reply.sync[i].period))\n\t\t\tcontinue;\n\t\tprintf(\"%s targ %d: sync, offset %d, period %dnsec\\n\",\n\t\t    sc->sc_dev.dv_xname, i, setup.reply.sync[i].offset,\n\t\t    setup.reply.sync[i].period * 50 + 200);\n\t}\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\n\t/* XXX KLUDGE!  Should use bus_dmamem_alloc when busified.  */\n#ifdef UVM\n\twmbx = (struct aha_mbx *)uvm_pagealloc_contig(sizeof(struct aha_mbx),\n\t    0, 0xffffff, PAGE_SIZE);\n#else\n\twmbx = (struct aha_mbx *)vm_pagealloc_contig(sizeof(struct aha_mbx),\n\t    0, 0xffffff, PAGE_SIZE);\n#endif\n\tif (wmbx == NULL)\n\t\tpanic(\"aha_init: could not allocate mailbox\");\n\n\tfor (i = 0; i < AHA_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = AHA_MBO_FREE;\n\t\twmbx->mbi[i].stat = AHA_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Initialize mail box. */\n\tmailbox.cmd.opcode = AHA_MBX_INIT;\n\tmailbox.cmd.nmbx = AHA_MBX_SIZE;\n\tltophys(vtophys(wmbx), mailbox.cmd.addr);\n\taha_cmd(iobase, sc, sizeof(mailbox.cmd), (u_char *)&mailbox.cmd,\n\t    0, (u_char *)0);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(sc->sc_mbx)",
      "#define AHA_MBX_SIZE\t16\t/* mail box size */"
    ],
    "globals_used": [
      "int aha_cmd",
      "struct aha_softc *, int, u_char *, int, u_char *));",
      "aha_finish_ccbs __P((struct aha_softc *));",
      "void aha_init",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "int flags;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aha_cmd",
          "args": [
            "iobase",
            "sc",
            "sizeof(mailbox.cmd)",
            "(u_char *)&mailbox.cmd",
            "0",
            "(u_char *)0"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "aha_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "208-324",
          "snippet": "int\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "vtophys(wmbx)",
            "mailbox.cmd.addr"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "wmbx"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"aha_init: could not allocate mailbox\""
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_pagealloc_contig",
          "args": [
            "sizeof(struct aha_mbx)",
            "0",
            "0xffffff",
            "PAGE_SIZE"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uvm_pagealloc_contig",
          "args": [
            "sizeof(struct aha_mbx)",
            "0",
            "0xffffff",
            "PAGE_SIZE"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s targ %d: sync, offset %d, period %dnsec\\n\"",
            "sc->sc_dev.dv_xname",
            "i",
            "setup.reply.sync[i].offset",
            "setup.reply.sync[i].period * 50 + 200"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "sc->sc_model",
            "\"1542C\"",
            "5"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n#define AHA_MBX_SIZE\t16\t/* mail box size */\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nvoid aha_init;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_init(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_devices devices;\n\tstruct aha_setup setup;\n\tstruct aha_mailbox mailbox;\n\tint i;\n\n\t/*\n\t * XXX\n\t * If we are a 1542C or later, disable the extended BIOS so that the\n\t * mailbox interface is unlocked.\n\t * No need to check the extended BIOS flags as some of the\n\t * extensions that cause us problems are not flagged in that byte.\n\t */\n\tif (!strncmp(sc->sc_model, \"1542C\", 5)) {\n\t\tstruct aha_extbios extbios;\n\t\tstruct aha_unlock unlock;\n\n\t\tprintf(\"%s: unlocking mailbox interface\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\textbios.cmd.opcode = AHA_EXT_BIOS;\n\t\taha_cmd(iobase, sc, sizeof(extbios.cmd),\n\t\t    (u_char *)&extbios.cmd, sizeof(extbios.reply),\n\t\t    (u_char *)&extbios.reply);\n\n#ifdef AHADEBUG\n\t\tprintf(\"%s: flags=%02x, mailboxlock=%02x\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    extbios.reply.flags, extbios.reply.mailboxlock);\n#endif /* AHADEBUG */\n\n\t\tunlock.cmd.opcode = AHA_MBX_ENABLE;\n\t\tunlock.cmd.junk = 0;\n\t\tunlock.cmd.magic = extbios.reply.mailboxlock;\n\t\taha_cmd(iobase, sc, sizeof(unlock.cmd), (u_char *)&unlock.cmd,\n\t\t    0, (u_char *)0);\n\t}\n\n#if 0\n\t/*\n\t * Change the bus on/off times to not clash with other dma users.\n\t */\n\taha_cmd(sc, 1, 0, 0, 0, AHA_BUS_ON_TIME_SET, 7);\n\taha_cmd(sc, 1, 0, 0, 0, AHA_BUS_OFF_TIME_SET, 4);\n#endif\n\n\t/* Inquire Installed Devices (to force synchronous negotiation). */\n\tdevices.cmd.opcode = AHA_INQUIRE_DEVICES;\n\taha_cmd(iobase, sc, sizeof(devices.cmd), (u_char *)&devices.cmd,\n\t    sizeof(devices.reply), (u_char *)&devices.reply);\n\n\t/* Obtain setup information from. */\n\tsetup.cmd.opcode = AHA_INQUIRE_SETUP;\n\tsetup.cmd.len = sizeof(setup.reply);\n\taha_cmd(iobase, sc, sizeof(setup.cmd), (u_char *)&setup.cmd,\n\t    sizeof(setup.reply), (u_char *)&setup.reply);\n\n\tprintf(\"%s: %s, %s\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    setup.reply.sync_neg ? \"sync\" : \"async\",\n\t    setup.reply.parity ? \"parity\" : \"no parity\");\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!setup.reply.sync[i].valid ||\n\t\t    (!setup.reply.sync[i].offset &&\n\t\t    !setup.reply.sync[i].period))\n\t\t\tcontinue;\n\t\tprintf(\"%s targ %d: sync, offset %d, period %dnsec\\n\",\n\t\t    sc->sc_dev.dv_xname, i, setup.reply.sync[i].offset,\n\t\t    setup.reply.sync[i].period * 50 + 200);\n\t}\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\n\t/* XXX KLUDGE!  Should use bus_dmamem_alloc when busified.  */\n#ifdef UVM\n\twmbx = (struct aha_mbx *)uvm_pagealloc_contig(sizeof(struct aha_mbx),\n\t    0, 0xffffff, PAGE_SIZE);\n#else\n\twmbx = (struct aha_mbx *)vm_pagealloc_contig(sizeof(struct aha_mbx),\n\t    0, 0xffffff, PAGE_SIZE);\n#endif\n\tif (wmbx == NULL)\n\t\tpanic(\"aha_init: could not allocate mailbox\");\n\n\tfor (i = 0; i < AHA_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = AHA_MBO_FREE;\n\t\twmbx->mbi[i].stat = AHA_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Initialize mail box. */\n\tmailbox.cmd.opcode = AHA_MBX_INIT;\n\tmailbox.cmd.nmbx = AHA_MBX_SIZE;\n\tltophys(vtophys(wmbx), mailbox.cmd.addr);\n\taha_cmd(iobase, sc, sizeof(mailbox.cmd), (u_char *)&mailbox.cmd,\n\t    0, (u_char *)0);\n}"
  },
  {
    "function_name": "aha_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "883-997",
    "snippet": "int\naha_find(ia, sc, isapnp)\n\tstruct isa_attach_args *ia;\n\tstruct aha_softc *sc;\n\tint isapnp;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct aha_config config;\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_HRST | AHA_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = AHA_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\tif (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* calibrated in msec */\n\t}\n\tif (!i) {\n#ifdef AHADEBUG\n\t\tif (aha_debug)\n\t\t\tprintf(\"aha_find: No answer from adaptec board\\n\");\n#endif /* AHADEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * setup dma channel from jumpers and save int\n\t * level\n\t */\n\tdelay(1000);\t\t/* for Bustek 545 */\n\tconfig.cmd.opcode = AHA_INQUIRE_CONFIG;\n\taha_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\t/* for EISA/VLB/PCI clones */\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal drq setting %x\\n\",\n\t\t    config.reply.chan);\n\t\treturn 1;\n\t}\n\tif (isapnp)\n\t\tirq = ia->ia_irq;\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal irq setting %x\\n\",\n\t\t    config.reply.intr);\n\t\treturn EIO;\n\t}\n\tif (isapnp)\n\t\tdrq = ia->ia_drq;\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (isapnp)\n\t\t\treturn (0);\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define AHA_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */"
    ],
    "globals_used": [
      "int aha_cmd",
      "struct aha_softc *, int, u_char *, int, u_char *));",
      "aha_finish_ccbs __P((struct aha_softc *));",
      "int aha_find",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"aha_find: illegal irq setting %x\\n\"",
            "config.reply.intr"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_cmd",
          "args": [
            "iobase",
            "sc",
            "sizeof(config.cmd)",
            "(u_char *)&config.cmd",
            "sizeof(config.reply)",
            "(u_char *)&config.reply"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "aha_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "208-324",
          "snippet": "int\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + AHA_STAT_PORT"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + AHA_CTRL_PORT",
            "AHA_CTRL_HRST | AHA_CTRL_SRST"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AHA_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nint aha_find;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_find(ia, sc, isapnp)\n\tstruct isa_attach_args *ia;\n\tstruct aha_softc *sc;\n\tint isapnp;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct aha_config config;\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_HRST | AHA_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = AHA_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\tif (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* calibrated in msec */\n\t}\n\tif (!i) {\n#ifdef AHADEBUG\n\t\tif (aha_debug)\n\t\t\tprintf(\"aha_find: No answer from adaptec board\\n\");\n#endif /* AHADEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * setup dma channel from jumpers and save int\n\t * level\n\t */\n\tdelay(1000);\t\t/* for Bustek 545 */\n\tconfig.cmd.opcode = AHA_INQUIRE_CONFIG;\n\taha_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\t/* for EISA/VLB/PCI clones */\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal drq setting %x\\n\",\n\t\t    config.reply.chan);\n\t\treturn 1;\n\t}\n\tif (isapnp)\n\t\tirq = ia->ia_irq;\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal irq setting %x\\n\",\n\t\t    config.reply.intr);\n\t\treturn EIO;\n\t}\n\tif (isapnp)\n\t\tdrq = ia->ia_drq;\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (isapnp)\n\t\t\treturn (0);\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aha_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "801-878",
    "snippet": "void\naha_done(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ccb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"aha_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n#ifdef AHADIAG\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: exiting ccb still in transit!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n#endif\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->host_stat != AHA_OK) {\n\t\t\tswitch (ccb->host_stat) {\n\t\t\tcase AHA_SEL_TIMEOUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ccb->target_stat != SCSI_OK) {\n\t\t\tswitch (ccb->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = (struct scsi_sense_data *)\n\t\t\t\t    (((char *)(&ccb->scsi_cmd)) +\n\t\t\t\t    ccb->scsi_cmd_length);\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\txs->flags |= ITSDONE;\n\n\tif (VOLATILE_XS(xs)) {\n\t\twakeup(ccb);\n\t\treturn;\n\t}\n\n\tif (ccb->data_nseg) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t    ccb->data_nseg, ccb->data_phys);\n\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t    ccb->data_nseg, ccb->data_phys);\n\t}\n\taha_free_ccb(sc, ccb);\n\tscsi_done(xs);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aha_finish_ccbs __P((struct aha_softc *));",
      "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "void aha_free_ccb",
      "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "void aha_done",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "int flags;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aha_free_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "aha_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "562-599",
          "snippet": "void\naha_free_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tint s, hashnum;\n\tstruct aha_ccb **hashccb;\n\n\ts = splbio();\n\n\tif (ccb->ccb_phys[0].addr)\n\t        isadma_unmap((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\n\t/* remove from hash table */\n\n\thashnum = CCB_HASH(ccb->ccb_phys[0].addr);\n\thashccb = &sc->sc_ccbhash[hashnum];\n\n\twhile (*hashccb) {\n\t\tif ((*hashccb)->ccb_phys[0].addr == ccb->ccb_phys[0].addr) {\n\t\t\t*hashccb = (*hashccb)->nexthash;\n\t\t\tbreak;\n\t\t}\n\t\thashccb = &(*hashccb)->nexthash;\n\t}\n\n\taha_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "void aha_free_ccb",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
            "u_long ccb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_free_ccb;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nvoid\naha_free_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tint s, hashnum;\n\tstruct aha_ccb **hashccb;\n\n\ts = splbio();\n\n\tif (ccb->ccb_phys[0].addr)\n\t        isadma_unmap((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\n\t/* remove from hash table */\n\n\thashnum = CCB_HASH(ccb->ccb_phys[0].addr);\n\thashccb = &sc->sc_ccbhash[hashnum];\n\n\twhile (*hashccb) {\n\t\tif ((*hashccb)->ccb_phys[0].addr == ccb->ccb_phys[0].addr) {\n\t\t\t*hashccb = (*hashccb)->nexthash;\n\t\t\tbreak;\n\t\t}\n\t\thashccb = &(*hashccb)->nexthash;\n\t}\n\n\taha_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isadma_unmap",
          "args": [
            "xs->data",
            "xs->datalen",
            "ccb->data_nseg",
            "ccb->data_phys"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_copyfrombuf",
          "args": [
            "xs->data",
            "xs->datalen",
            "ccb->data_nseg",
            "ccb->data_phys"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "ccb"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VOLATILE_XS",
          "args": [
            "xs"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: target_stat %x\\n\"",
            "sc->sc_dev.dv_xname",
            "ccb->target_stat"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "xs->sc_link",
            "SDEV_DB2",
            "(\"aha_done\\n\")"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_free_ccb;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_done;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_done(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ccb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"aha_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n#ifdef AHADIAG\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: exiting ccb still in transit!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n#endif\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->host_stat != AHA_OK) {\n\t\t\tswitch (ccb->host_stat) {\n\t\t\tcase AHA_SEL_TIMEOUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ccb->target_stat != SCSI_OK) {\n\t\t\tswitch (ccb->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = (struct scsi_sense_data *)\n\t\t\t\t    (((char *)(&ccb->scsi_cmd)) +\n\t\t\t\t    ccb->scsi_cmd_length);\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\txs->flags |= ITSDONE;\n\n\tif (VOLATILE_XS(xs)) {\n\t\twakeup(ccb);\n\t\treturn;\n\t}\n\n\tif (ccb->data_nseg) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t    ccb->data_nseg, ccb->data_phys);\n\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t    ccb->data_nseg, ccb->data_phys);\n\t}\n\taha_free_ccb(sc, ccb);\n\tscsi_done(xs);\n}"
  },
  {
    "function_name": "aha_start_ccbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "745-794",
    "snippet": "void\naha_start_ccbs(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct aha_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\taha_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\t\tstruct aha_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = AHA_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\taha_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef AHADIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tisadma_copytobuf((caddr_t)ccb, CCB_PHYS_SIZE,\n\t\t    1, ccb->ccb_phys);\n\t\tltophys(ccb->ccb_phys[0].addr, wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = AHA_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = AHA_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + AHA_CMD_PORT, AHA_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(aha_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(sc->sc_mbx)",
      "#define AHA_MBX_SIZE\t16\t/* mail box size */"
    ],
    "globals_used": [
      "int aha_cmd",
      "struct aha_softc *, int, u_char *, int, u_char *));",
      "aha_finish_ccbs __P((struct aha_softc *));",
      "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "void aha_collect_mbo",
      "void aha_start_ccbs",
      "void aha_timeout",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "int flags;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
      "u_long ccb_phys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aha_nextmbx",
          "args": [
            "wmbo",
            "wmbx",
            "mbo"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "aha_timeout",
            "ccb",
            "(ccb->timeout * hz) / 1000"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "aha_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "1385-1434",
          "snippet": "void\naha_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aha_ccb *ccb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct aha_softc *sc;\n\tint s;\n\n\ts = splbio();\n\tisadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\txs = ccb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef AHADIAG\n\t/*\n\t * If The ccb's mbx is not free, then the board has gone south?\n\t */\n\taha_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = AHA_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\taha_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tAHA_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "void aha_queue_ccb",
            "void aha_collect_mbo",
            "void aha_timeout",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
            "u_long ccb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAHA_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_queue_ccb;\nvoid aha_collect_mbo;\nvoid aha_timeout;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nvoid\naha_timeout(arg)\n\tvoid *arg;\n{\n\tstruct aha_ccb *ccb = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct aha_softc *sc;\n\tint s;\n\n\ts = splbio();\n\tisadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\txs = ccb->xs;\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n#ifdef AHADIAG\n\t/*\n\t * If The ccb's mbx is not free, then the board has gone south?\n\t */\n\taha_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = AHA_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\taha_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + AHA_CMD_PORT",
            "AHA_START_SCSI"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "ccb->ccb_phys[0].addr",
            "wmbo->ccb_addr"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_copytobuf",
          "args": [
            "(caddr_t)ccb",
            "CCB_PHYS_SIZE",
            "1",
            "ccb->ccb_phys"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->sc_waiting_ccb",
            "ccb",
            "chain"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aha_cmd",
          "args": [
            "iobase",
            "sc",
            "sizeof(toggle.cmd)",
            "(u_char *)&toggle.cmd",
            "0",
            "(u_char *)0"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "aha_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "208-324",
          "snippet": "int\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_collect_mbo",
          "args": [
            "sc"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "aha_collect_mbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "711-740",
          "snippet": "void\naha_collect_mbo(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef AHADIAG\n\tstruct aha_ccb *ccb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != AHA_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef AHADIAG\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbo ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t} else\n\t\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(sc->sc_mbx)"
          ],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "struct aha_ccb *aha_ccb_phys_kv",
            "void aha_collect_mbo",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *aha_ccb_phys_kv;\nvoid aha_collect_mbo;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_collect_mbo(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef AHADIAG\n\tstruct aha_ccb *ccb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != AHA_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef AHADIAG\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbo ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t} else\n\t\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n#define AHA_MBX_SIZE\t16\t/* mail box size */\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_collect_mbo;\nvoid aha_start_ccbs;\nvoid aha_timeout;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nvoid\naha_start_ccbs(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct aha_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\taha_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\t\tstruct aha_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = AHA_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\taha_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef AHADIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tisadma_copytobuf((caddr_t)ccb, CCB_PHYS_SIZE,\n\t\t    1, ccb->ccb_phys);\n\t\tltophys(ccb->ccb_phys[0].addr, wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = AHA_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = AHA_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + AHA_CMD_PORT, AHA_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(aha_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}"
  },
  {
    "function_name": "aha_collect_mbo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "711-740",
    "snippet": "void\naha_collect_mbo(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef AHADIAG\n\tstruct aha_ccb *ccb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != AHA_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef AHADIAG\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbo ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t} else\n\t\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(sc->sc_mbx)"
    ],
    "globals_used": [
      "aha_finish_ccbs __P((struct aha_softc *));",
      "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "struct aha_ccb *aha_ccb_phys_kv",
      "void aha_collect_mbo",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "int flags;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aha_nextmbx",
          "args": [
            "wmbo",
            "wmbx",
            "mbo"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bad mbo ccb pointer; skipping\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_ccb_phys_kv",
          "args": [
            "sc",
            "phystol(wmbo->ccb_addr)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phystol",
          "args": [
            "wmbo->ccb_addr"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *aha_ccb_phys_kv;\nvoid aha_collect_mbo;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_collect_mbo(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef AHADIAG\n\tstruct aha_ccb *ccb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != AHA_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef AHADIAG\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbo ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t} else\n\t\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
  },
  {
    "function_name": "aha_queue_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "698-706",
    "snippet": "void\naha_queue_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\taha_start_ccbs(sc);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aha_finish_ccbs __P((struct aha_softc *));",
      "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "void aha_queue_ccb",
      "void aha_start_ccbs",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aha_start_ccbs",
          "args": [
            "sc"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "aha_start_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "745-794",
          "snippet": "void\naha_start_ccbs(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct aha_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\taha_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\t\tstruct aha_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = AHA_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\taha_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef AHADIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tisadma_copytobuf((caddr_t)ccb, CCB_PHYS_SIZE,\n\t\t    1, ccb->ccb_phys);\n\t\tltophys(ccb->ccb_phys[0].addr, wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = AHA_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = AHA_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + AHA_CMD_PORT, AHA_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(aha_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(sc->sc_mbx)",
            "#define AHA_MBX_SIZE\t16\t/* mail box size */"
          ],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "void aha_collect_mbo",
            "void aha_start_ccbs",
            "void aha_timeout",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
            "u_long ccb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n#define AHA_MBX_SIZE\t16\t/* mail box size */\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_collect_mbo;\nvoid aha_start_ccbs;\nvoid aha_timeout;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nvoid\naha_start_ccbs(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct aha_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\taha_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\t\tstruct aha_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = AHA_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\taha_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef AHADIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tisadma_copytobuf((caddr_t)ccb, CCB_PHYS_SIZE,\n\t\t    1, ccb->ccb_phys);\n\t\tltophys(ccb->ccb_phys[0].addr, wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = AHA_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = AHA_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + AHA_CMD_PORT, AHA_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(aha_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->sc_waiting_ccb",
            "ccb",
            "chain"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_queue_ccb;\nvoid aha_start_ccbs;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_queue_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\taha_start_ccbs(sc);\n}"
  },
  {
    "function_name": "aha_init_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "601-608",
    "snippet": "integrate void\naha_init_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tbzero(ccb, sizeof(struct aha_ccb));\n\taha_reset_ccb(sc, ccb);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define integrate"
    ],
    "globals_used": [
      "integrate void",
      "aha_finish_ccbs __P((struct aha_softc *));",
      "integrate void",
      "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "integrate void",
      "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aha_reset_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "aha_reset_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "550-557",
          "snippet": "integrate void\naha_reset_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define integrate"
          ],
          "globals_used": [
            "integrate void",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "integrate void",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "integrate void",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define integrate\n\nintegrate void;\naha_finish_ccbs __P((struct aha_softc *));\nintegrate void;\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nintegrate void;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nintegrate void\naha_reset_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ccb",
            "sizeof(struct aha_ccb)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define integrate\n\nintegrate void;\naha_finish_ccbs __P((struct aha_softc *));\nintegrate void;\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nintegrate void;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nintegrate void\naha_init_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tbzero(ccb, sizeof(struct aha_ccb));\n\taha_reset_ccb(sc, ccb);\n}"
  },
  {
    "function_name": "aha_free_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "562-599",
    "snippet": "void\naha_free_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tint s, hashnum;\n\tstruct aha_ccb **hashccb;\n\n\ts = splbio();\n\n\tif (ccb->ccb_phys[0].addr)\n\t        isadma_unmap((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\n\t/* remove from hash table */\n\n\thashnum = CCB_HASH(ccb->ccb_phys[0].addr);\n\thashccb = &sc->sc_ccbhash[hashnum];\n\n\twhile (*hashccb) {\n\t\tif ((*hashccb)->ccb_phys[0].addr == ccb->ccb_phys[0].addr) {\n\t\t\t*hashccb = (*hashccb)->nexthash;\n\t\t\tbreak;\n\t\t}\n\t\thashccb = &(*hashccb)->nexthash;\n\t}\n\n\taha_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aha_finish_ccbs __P((struct aha_softc *));",
      "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "void aha_free_ccb",
      "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
      "u_long ccb_phys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->sc_free_ccb"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->sc_free_ccb",
            "ccb",
            "chain"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aha_reset_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "aha_reset_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "550-557",
          "snippet": "integrate void\naha_reset_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define integrate"
          ],
          "globals_used": [
            "integrate void",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "integrate void",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "integrate void",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define integrate\n\nintegrate void;\naha_finish_ccbs __P((struct aha_softc *));\nintegrate void;\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nintegrate void;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nintegrate void\naha_reset_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CCB_HASH",
          "args": [
            "ccb->ccb_phys[0].addr"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isadma_unmap",
          "args": [
            "(caddr_t)ccb",
            "CCB_PHYS_SIZE",
            "1",
            "ccb->ccb_phys"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_free_ccb;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nvoid\naha_free_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tint s, hashnum;\n\tstruct aha_ccb **hashccb;\n\n\ts = splbio();\n\n\tif (ccb->ccb_phys[0].addr)\n\t        isadma_unmap((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);\n\n\t/* remove from hash table */\n\n\thashnum = CCB_HASH(ccb->ccb_phys[0].addr);\n\thashccb = &sc->sc_ccbhash[hashnum];\n\n\twhile (*hashccb) {\n\t\tif ((*hashccb)->ccb_phys[0].addr == ccb->ccb_phys[0].addr) {\n\t\t\t*hashccb = (*hashccb)->nexthash;\n\t\t\tbreak;\n\t\t}\n\t\thashccb = &(*hashccb)->nexthash;\n\t}\n\n\taha_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "aha_reset_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "550-557",
    "snippet": "integrate void\naha_reset_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define integrate"
    ],
    "globals_used": [
      "integrate void",
      "aha_finish_ccbs __P((struct aha_softc *));",
      "integrate void",
      "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "integrate void",
      "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "int flags;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define integrate\n\nintegrate void;\naha_finish_ccbs __P((struct aha_softc *));\nintegrate void;\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nintegrate void;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nintegrate void\naha_reset_ccb(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}"
  },
  {
    "function_name": "ahaintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "505-548",
    "snippet": "int\nahaintr(arg)\n\tvoid *arg;\n{\n\tstruct aha_softc *sc = arg;\n\tint iobase = sc->sc_iobase;\n\tu_char sts;\n\n#ifdef AHADEBUG\n\tif (aha_debug)\n\t\tprintf(\"%s: ahaintr \", sc->sc_dev.dv_xname);\n#endif /*AHADEBUG */\n\n\t/*\n\t * First acknowlege the interrupt, Then if it's not telling about\n\t * a completed operation just return.\n\t */\n\tsts = inb(iobase + AHA_INTR_PORT);\n\tif ((sts & AHA_INTR_ANYINTR) == 0)\n\t\treturn 0;\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\n#ifdef AHADIAG\n\t/* Make sure we clear CCB_SENDING before finishing a CCB. */\n\taha_collect_mbo(sc);\n#endif\n\n\t/* Mail box out empty? */\n\tif (sts & AHA_INTR_MBOA) {\n\t\tstruct aha_toggle toggle;\n\n\t\ttoggle.cmd.opcode = AHA_MBO_INTR_EN;\n\t\ttoggle.cmd.enable = 0;\n\t\taha_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd,\n\t\t    0, (u_char *)0);\n\t\taha_start_ccbs(sc);\n\t}\n\n\t/* Mail box in full? */\n\tif (sts & AHA_INTR_MBIF)\n\t\taha_finish_ccbs(sc);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int aha_cmd",
      "struct aha_softc *, int, u_char *, int, u_char *));",
      "aha_finish_ccbs __P((struct aha_softc *));",
      "int ahaintr",
      "void aha_collect_mbo",
      "void aha_start_ccbs",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aha_finish_ccbs",
          "args": [
            "sc"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "aha_finish_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "413-500",
          "snippet": "integrate void\naha_finish_ccbs(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_in *wmbi;\n\tstruct aha_ccb *ccb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == AHA_MBI_FREE) {\n\t\tfor (i = 0; i < AHA_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != AHA_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\taha_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef AHADIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbi->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbi ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef AHADEBUG\n\t\tif (aha_debug) {\n\t\t\tu_char *cp = (u_char*)&ccb->scsi_cmd;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"ccb addr = 0x%x\\n\", ccb);\n\t\t}\n#endif /* AHADEBUG */\n\n\t\tswitch (wmbi->stat) {\n\t\tcase AHA_MBI_OK:\n\t\tcase AHA_MBI_ERROR:\n\t\t\tif ((ccb->flags & CCB_ABORT) != 0) {\n\t\t\t\t/*\n\t\t\t\t * If we already started an abort, wait for it\n\t\t\t\t * to complete before clearing the CCB.  We\n\t\t\t\t * could instead just clear CCB_SENDING, but\n\t\t\t\t * what if the mailbox was already received?\n\t\t\t\t * The worst that happens here is that we clear\n\t\t\t\t * the CCB a bit later than we need to.  BFD.\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AHA_MBI_ABORT:\n\t\tcase AHA_MBI_UNKNOWN:\n\t\t\t/*\n\t\t\t * Even if the CCB wasn't found, we clear it anyway.\n\t\t\t * See preceeding comment.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: bad mbi status %02x; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname, wmbi->stat);\n\t\t\tgoto next;\n\t\t}\n\n\t\tuntimeout(aha_timeout, ccb);\n\t\tisadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE,\n\t\t    1, ccb->ccb_phys);\n\t\taha_done(sc, ccb);\n\n\tnext:\n\t\twmbi->stat = AHA_MBI_FREE;\n\t\taha_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != AHA_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(sc->sc_mbx)",
            "#define AHA_MBX_SIZE\t16\t/* mail box size */",
            "#define integrate"
          ],
          "globals_used": [
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "integrate void",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "integrate void",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "integrate void",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "struct aha_ccb *aha_ccb_phys_kv",
            "void aha_done",
            "void aha_timeout",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
            "u_long ccb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n#define AHA_MBX_SIZE\t16\t/* mail box size */\n#define integrate\n\nstruct aha_softc *, int, u_char *, int, u_char *));\nintegrate void;\naha_finish_ccbs __P((struct aha_softc *));\nintegrate void;\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nintegrate void;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *aha_ccb_phys_kv;\nvoid aha_done;\nvoid aha_timeout;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nintegrate void\naha_finish_ccbs(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_in *wmbi;\n\tstruct aha_ccb *ccb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == AHA_MBI_FREE) {\n\t\tfor (i = 0; i < AHA_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != AHA_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\taha_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef AHADIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbi->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbi ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef AHADEBUG\n\t\tif (aha_debug) {\n\t\t\tu_char *cp = (u_char*)&ccb->scsi_cmd;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"ccb addr = 0x%x\\n\", ccb);\n\t\t}\n#endif /* AHADEBUG */\n\n\t\tswitch (wmbi->stat) {\n\t\tcase AHA_MBI_OK:\n\t\tcase AHA_MBI_ERROR:\n\t\t\tif ((ccb->flags & CCB_ABORT) != 0) {\n\t\t\t\t/*\n\t\t\t\t * If we already started an abort, wait for it\n\t\t\t\t * to complete before clearing the CCB.  We\n\t\t\t\t * could instead just clear CCB_SENDING, but\n\t\t\t\t * what if the mailbox was already received?\n\t\t\t\t * The worst that happens here is that we clear\n\t\t\t\t * the CCB a bit later than we need to.  BFD.\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AHA_MBI_ABORT:\n\t\tcase AHA_MBI_UNKNOWN:\n\t\t\t/*\n\t\t\t * Even if the CCB wasn't found, we clear it anyway.\n\t\t\t * See preceeding comment.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: bad mbi status %02x; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname, wmbi->stat);\n\t\t\tgoto next;\n\t\t}\n\n\t\tuntimeout(aha_timeout, ccb);\n\t\tisadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE,\n\t\t    1, ccb->ccb_phys);\n\t\taha_done(sc, ccb);\n\n\tnext:\n\t\twmbi->stat = AHA_MBI_FREE;\n\t\taha_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != AHA_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_start_ccbs",
          "args": [
            "sc"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "aha_start_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "745-794",
          "snippet": "void\naha_start_ccbs(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct aha_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\taha_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\t\tstruct aha_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = AHA_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\taha_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef AHADIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tisadma_copytobuf((caddr_t)ccb, CCB_PHYS_SIZE,\n\t\t    1, ccb->ccb_phys);\n\t\tltophys(ccb->ccb_phys[0].addr, wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = AHA_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = AHA_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + AHA_CMD_PORT, AHA_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(aha_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(sc->sc_mbx)",
            "#define AHA_MBX_SIZE\t16\t/* mail box size */"
          ],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "void aha_collect_mbo",
            "void aha_start_ccbs",
            "void aha_timeout",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
            "u_long ccb_phys;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n#define AHA_MBX_SIZE\t16\t/* mail box size */\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_collect_mbo;\nvoid aha_start_ccbs;\nvoid aha_timeout;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nvoid\naha_start_ccbs(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct aha_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\taha_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= AHA_MBX_SIZE) {\n\t\t\t\tstruct aha_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = AHA_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\taha_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef AHADIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tisadma_copytobuf((caddr_t)ccb, CCB_PHYS_SIZE,\n\t\t    1, ccb->ccb_phys);\n\t\tltophys(ccb->ccb_phys[0].addr, wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = AHA_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = AHA_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + AHA_CMD_PORT, AHA_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(aha_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_cmd",
          "args": [
            "iobase",
            "sc",
            "sizeof(toggle.cmd)",
            "(u_char *)&toggle.cmd",
            "0",
            "(u_char *)0"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "aha_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "208-324",
          "snippet": "int\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_collect_mbo",
          "args": [
            "sc"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "aha_collect_mbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "711-740",
          "snippet": "void\naha_collect_mbo(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef AHADIAG\n\tstruct aha_ccb *ccb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != AHA_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef AHADIAG\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbo ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t} else\n\t\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(sc->sc_mbx)"
          ],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "struct aha_ccb *aha_ccb_phys_kv",
            "void aha_collect_mbo",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *aha_ccb_phys_kv;\nvoid aha_collect_mbo;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_collect_mbo(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef AHADIAG\n\tstruct aha_ccb *ccb;\n#endif\n\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != AHA_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef AHADIAG\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbo ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t} else\n\t\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\taha_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + AHA_CTRL_PORT",
            "AHA_CTRL_IRST"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + AHA_INTR_PORT"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: ahaintr \"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nint ahaintr;\nvoid aha_collect_mbo;\nvoid aha_start_ccbs;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\nahaintr(arg)\n\tvoid *arg;\n{\n\tstruct aha_softc *sc = arg;\n\tint iobase = sc->sc_iobase;\n\tu_char sts;\n\n#ifdef AHADEBUG\n\tif (aha_debug)\n\t\tprintf(\"%s: ahaintr \", sc->sc_dev.dv_xname);\n#endif /*AHADEBUG */\n\n\t/*\n\t * First acknowlege the interrupt, Then if it's not telling about\n\t * a completed operation just return.\n\t */\n\tsts = inb(iobase + AHA_INTR_PORT);\n\tif ((sts & AHA_INTR_ANYINTR) == 0)\n\t\treturn 0;\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\n#ifdef AHADIAG\n\t/* Make sure we clear CCB_SENDING before finishing a CCB. */\n\taha_collect_mbo(sc);\n#endif\n\n\t/* Mail box out empty? */\n\tif (sts & AHA_INTR_MBOA) {\n\t\tstruct aha_toggle toggle;\n\n\t\ttoggle.cmd.opcode = AHA_MBO_INTR_EN;\n\t\ttoggle.cmd.enable = 0;\n\t\taha_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd,\n\t\t    0, (u_char *)0);\n\t\taha_start_ccbs(sc);\n\t}\n\n\t/* Mail box in full? */\n\tif (sts & AHA_INTR_MBIF)\n\t\taha_finish_ccbs(sc);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "aha_finish_ccbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "413-500",
    "snippet": "integrate void\naha_finish_ccbs(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_in *wmbi;\n\tstruct aha_ccb *ccb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == AHA_MBI_FREE) {\n\t\tfor (i = 0; i < AHA_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != AHA_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\taha_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef AHADIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbi->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbi ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef AHADEBUG\n\t\tif (aha_debug) {\n\t\t\tu_char *cp = (u_char*)&ccb->scsi_cmd;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"ccb addr = 0x%x\\n\", ccb);\n\t\t}\n#endif /* AHADEBUG */\n\n\t\tswitch (wmbi->stat) {\n\t\tcase AHA_MBI_OK:\n\t\tcase AHA_MBI_ERROR:\n\t\t\tif ((ccb->flags & CCB_ABORT) != 0) {\n\t\t\t\t/*\n\t\t\t\t * If we already started an abort, wait for it\n\t\t\t\t * to complete before clearing the CCB.  We\n\t\t\t\t * could instead just clear CCB_SENDING, but\n\t\t\t\t * what if the mailbox was already received?\n\t\t\t\t * The worst that happens here is that we clear\n\t\t\t\t * the CCB a bit later than we need to.  BFD.\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AHA_MBI_ABORT:\n\t\tcase AHA_MBI_UNKNOWN:\n\t\t\t/*\n\t\t\t * Even if the CCB wasn't found, we clear it anyway.\n\t\t\t * See preceeding comment.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: bad mbi status %02x; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname, wmbi->stat);\n\t\t\tgoto next;\n\t\t}\n\n\t\tuntimeout(aha_timeout, ccb);\n\t\tisadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE,\n\t\t    1, ccb->ccb_phys);\n\t\taha_done(sc, ccb);\n\n\tnext:\n\t\twmbi->stat = AHA_MBI_FREE;\n\t\taha_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != AHA_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(sc->sc_mbx)",
      "#define AHA_MBX_SIZE\t16\t/* mail box size */",
      "#define integrate"
    ],
    "globals_used": [
      "struct aha_softc *, int, u_char *, int, u_char *));",
      "integrate void",
      "aha_finish_ccbs __P((struct aha_softc *));",
      "integrate void",
      "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "integrate void",
      "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
      "struct aha_ccb *aha_ccb_phys_kv",
      "void aha_done",
      "void aha_timeout",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "int flags;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;",
      "u_long ccb_phys;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aha_nextmbx",
          "args": [
            "wmbi",
            "wmbx",
            "mbi"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aha_done",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "aha_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "801-878",
          "snippet": "void\naha_done(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ccb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"aha_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n#ifdef AHADIAG\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: exiting ccb still in transit!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n#endif\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->host_stat != AHA_OK) {\n\t\t\tswitch (ccb->host_stat) {\n\t\t\tcase AHA_SEL_TIMEOUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ccb->target_stat != SCSI_OK) {\n\t\t\tswitch (ccb->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = (struct scsi_sense_data *)\n\t\t\t\t    (((char *)(&ccb->scsi_cmd)) +\n\t\t\t\t    ccb->scsi_cmd_length);\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\txs->flags |= ITSDONE;\n\n\tif (VOLATILE_XS(xs)) {\n\t\twakeup(ccb);\n\t\treturn;\n\t}\n\n\tif (ccb->data_nseg) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t    ccb->data_nseg, ccb->data_phys);\n\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t    ccb->data_nseg, ccb->data_phys);\n\t}\n\taha_free_ccb(sc, ccb);\n\tscsi_done(xs);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "aha_finish_ccbs __P((struct aha_softc *));",
            "aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "void aha_free_ccb",
            "aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));",
            "void aha_done",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_free_ccb;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nvoid aha_done;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_done(sc, ccb)\n\tstruct aha_softc *sc;\n\tstruct aha_ccb *ccb;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ccb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"aha_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n#ifdef AHADIAG\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: exiting ccb still in transit!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n#endif\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->host_stat != AHA_OK) {\n\t\t\tswitch (ccb->host_stat) {\n\t\t\tcase AHA_SEL_TIMEOUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ccb->target_stat != SCSI_OK) {\n\t\t\tswitch (ccb->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = (struct scsi_sense_data *)\n\t\t\t\t    (((char *)(&ccb->scsi_cmd)) +\n\t\t\t\t    ccb->scsi_cmd_length);\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\txs->flags |= ITSDONE;\n\n\tif (VOLATILE_XS(xs)) {\n\t\twakeup(ccb);\n\t\treturn;\n\t}\n\n\tif (ccb->data_nseg) {\n\t\tif (xs->flags & SCSI_DATA_IN)\n\t\t\tisadma_copyfrombuf(xs->data, xs->datalen,\n\t\t\t    ccb->data_nseg, ccb->data_phys);\n\t\tisadma_unmap(xs->data, xs->datalen,\n\t\t    ccb->data_nseg, ccb->data_phys);\n\t}\n\taha_free_ccb(sc, ccb);\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isadma_copyfrombuf",
          "args": [
            "(caddr_t)ccb",
            "CCB_PHYS_SIZE",
            "1",
            "ccb->ccb_phys"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "aha_timeout",
            "ccb"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bad mbi status %02x; skipping\\n\"",
            "sc->sc_dev.dv_xname",
            "wmbi->stat"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_ccb_phys_kv",
          "args": [
            "sc",
            "phystol(wmbi->ccb_addr)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phystol",
          "args": [
            "wmbi->ccb_addr"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aha_nextmbx",
          "args": [
            "wmbi",
            "wmbx",
            "mbi"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n#define AHA_MBX_SIZE\t16\t/* mail box size */\n#define integrate\n\nstruct aha_softc *, int, u_char *, int, u_char *));\nintegrate void;\naha_finish_ccbs __P((struct aha_softc *));\nintegrate void;\naha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));\nintegrate void;\naha_init_ccb __P((struct aha_softc *, struct aha_ccb *));\nstruct aha_ccb *aha_ccb_phys_kv;\nvoid aha_done;\nvoid aha_timeout;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\nu_long ccb_phys;\n\nintegrate void\naha_finish_ccbs(sc)\n\tstruct aha_softc *sc;\n{\n\tstruct aha_mbx_in *wmbi;\n\tstruct aha_ccb *ccb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == AHA_MBI_FREE) {\n\t\tfor (i = 0; i < AHA_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != AHA_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\taha_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef AHADIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tccb = aha_ccb_phys_kv(sc, phystol(wmbi->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbi ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef AHADEBUG\n\t\tif (aha_debug) {\n\t\t\tu_char *cp = (u_char*)&ccb->scsi_cmd;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"ccb addr = 0x%x\\n\", ccb);\n\t\t}\n#endif /* AHADEBUG */\n\n\t\tswitch (wmbi->stat) {\n\t\tcase AHA_MBI_OK:\n\t\tcase AHA_MBI_ERROR:\n\t\t\tif ((ccb->flags & CCB_ABORT) != 0) {\n\t\t\t\t/*\n\t\t\t\t * If we already started an abort, wait for it\n\t\t\t\t * to complete before clearing the CCB.  We\n\t\t\t\t * could instead just clear CCB_SENDING, but\n\t\t\t\t * what if the mailbox was already received?\n\t\t\t\t * The worst that happens here is that we clear\n\t\t\t\t * the CCB a bit later than we need to.  BFD.\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AHA_MBI_ABORT:\n\t\tcase AHA_MBI_UNKNOWN:\n\t\t\t/*\n\t\t\t * Even if the CCB wasn't found, we clear it anyway.\n\t\t\t * See preceeding comment.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: bad mbi status %02x; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname, wmbi->stat);\n\t\t\tgoto next;\n\t\t}\n\n\t\tuntimeout(aha_timeout, ccb);\n\t\tisadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE,\n\t\t    1, ccb->ccb_phys);\n\t\taha_done(sc, ccb);\n\n\tnext:\n\t\twmbi->stat = AHA_MBI_FREE;\n\t\taha_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != AHA_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}"
  },
  {
    "function_name": "ahaattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "369-411",
    "snippet": "void\nahaattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct aha_softc *sc = (void *)self;\n\tint isapnp = !strcmp(parent->dv_cfdata->cf_driver->cd_name, \"isapnp\");\n\n\tif (isapnp) {\n\t\tia->ia_iobase = ia->ipa_io[0].base;\n\t\tisadma_cascade(ia->ia_drq);\n\t}\n\n\tif (aha_find(ia, sc, isapnp) != 0)\n\t\tpanic(\"ahaattach: aha_find of %s failed\", self->dv_xname);\n\tsc->sc_iobase = ia->ia_iobase;\n\n\tif (sc->sc_drq != DRQUNK && isapnp == 0)\n\t\tisadma_cascade(sc->sc_drq);\n\n\taha_inquire_setup_information(sc);\n\taha_init(sc);\n\tTAILQ_INIT(&sc->sc_free_ccb);\n\tTAILQ_INIT(&sc->sc_waiting_ccb);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &aha_switch;\n\tsc->sc_link.device = &aha_dev;\n\tsc->sc_link.openings = 2;\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, sc->sc_irq, IST_EDGE,\n\t    IPL_BIO, ahaintr, sc, sc->sc_dev.dv_xname);\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tconfig_found(self, &sc->sc_link, scsiprint);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "aha_finish_ccbs __P((struct aha_softc *));",
      "int ahaintr",
      "int aha_find",
      "void aha_init",
      "void aha_inquire_setup_information",
      "struct scsi_adapter aha_switch = {\n\taha_scsi_cmd,\n\tahaminphys,\n\t0,\n\t0,\n};",
      "struct scsi_device aha_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
      "void\tahaattach",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "&sc->sc_link",
            "scsiprint"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "sc->sc_irq",
            "IST_EDGE",
            "IPL_BIO",
            "ahaintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_waiting_ccb"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_free_ccb"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aha_init",
          "args": [
            "sc"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "aha_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "1002-1106",
          "snippet": "void\naha_init(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_devices devices;\n\tstruct aha_setup setup;\n\tstruct aha_mailbox mailbox;\n\tint i;\n\n\t/*\n\t * XXX\n\t * If we are a 1542C or later, disable the extended BIOS so that the\n\t * mailbox interface is unlocked.\n\t * No need to check the extended BIOS flags as some of the\n\t * extensions that cause us problems are not flagged in that byte.\n\t */\n\tif (!strncmp(sc->sc_model, \"1542C\", 5)) {\n\t\tstruct aha_extbios extbios;\n\t\tstruct aha_unlock unlock;\n\n\t\tprintf(\"%s: unlocking mailbox interface\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\textbios.cmd.opcode = AHA_EXT_BIOS;\n\t\taha_cmd(iobase, sc, sizeof(extbios.cmd),\n\t\t    (u_char *)&extbios.cmd, sizeof(extbios.reply),\n\t\t    (u_char *)&extbios.reply);\n\n#ifdef AHADEBUG\n\t\tprintf(\"%s: flags=%02x, mailboxlock=%02x\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    extbios.reply.flags, extbios.reply.mailboxlock);\n#endif /* AHADEBUG */\n\n\t\tunlock.cmd.opcode = AHA_MBX_ENABLE;\n\t\tunlock.cmd.junk = 0;\n\t\tunlock.cmd.magic = extbios.reply.mailboxlock;\n\t\taha_cmd(iobase, sc, sizeof(unlock.cmd), (u_char *)&unlock.cmd,\n\t\t    0, (u_char *)0);\n\t}\n\n#if 0\n\t/*\n\t * Change the bus on/off times to not clash with other dma users.\n\t */\n\taha_cmd(sc, 1, 0, 0, 0, AHA_BUS_ON_TIME_SET, 7);\n\taha_cmd(sc, 1, 0, 0, 0, AHA_BUS_OFF_TIME_SET, 4);\n#endif\n\n\t/* Inquire Installed Devices (to force synchronous negotiation). */\n\tdevices.cmd.opcode = AHA_INQUIRE_DEVICES;\n\taha_cmd(iobase, sc, sizeof(devices.cmd), (u_char *)&devices.cmd,\n\t    sizeof(devices.reply), (u_char *)&devices.reply);\n\n\t/* Obtain setup information from. */\n\tsetup.cmd.opcode = AHA_INQUIRE_SETUP;\n\tsetup.cmd.len = sizeof(setup.reply);\n\taha_cmd(iobase, sc, sizeof(setup.cmd), (u_char *)&setup.cmd,\n\t    sizeof(setup.reply), (u_char *)&setup.reply);\n\n\tprintf(\"%s: %s, %s\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    setup.reply.sync_neg ? \"sync\" : \"async\",\n\t    setup.reply.parity ? \"parity\" : \"no parity\");\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!setup.reply.sync[i].valid ||\n\t\t    (!setup.reply.sync[i].offset &&\n\t\t    !setup.reply.sync[i].period))\n\t\t\tcontinue;\n\t\tprintf(\"%s targ %d: sync, offset %d, period %dnsec\\n\",\n\t\t    sc->sc_dev.dv_xname, i, setup.reply.sync[i].offset,\n\t\t    setup.reply.sync[i].period * 50 + 200);\n\t}\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\n\t/* XXX KLUDGE!  Should use bus_dmamem_alloc when busified.  */\n#ifdef UVM\n\twmbx = (struct aha_mbx *)uvm_pagealloc_contig(sizeof(struct aha_mbx),\n\t    0, 0xffffff, PAGE_SIZE);\n#else\n\twmbx = (struct aha_mbx *)vm_pagealloc_contig(sizeof(struct aha_mbx),\n\t    0, 0xffffff, PAGE_SIZE);\n#endif\n\tif (wmbx == NULL)\n\t\tpanic(\"aha_init: could not allocate mailbox\");\n\n\tfor (i = 0; i < AHA_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = AHA_MBO_FREE;\n\t\twmbx->mbi[i].stat = AHA_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Initialize mail box. */\n\tmailbox.cmd.opcode = AHA_MBX_INIT;\n\tmailbox.cmd.nmbx = AHA_MBX_SIZE;\n\tltophys(vtophys(wmbx), mailbox.cmd.addr);\n\taha_cmd(iobase, sc, sizeof(mailbox.cmd), (u_char *)&mailbox.cmd,\n\t    0, (u_char *)0);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(sc->sc_mbx)",
            "#define AHA_MBX_SIZE\t16\t/* mail box size */"
          ],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "void aha_init",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "int flags;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(sc->sc_mbx)\n#define AHA_MBX_SIZE\t16\t/* mail box size */\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nvoid aha_init;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nint flags;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_init(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_devices devices;\n\tstruct aha_setup setup;\n\tstruct aha_mailbox mailbox;\n\tint i;\n\n\t/*\n\t * XXX\n\t * If we are a 1542C or later, disable the extended BIOS so that the\n\t * mailbox interface is unlocked.\n\t * No need to check the extended BIOS flags as some of the\n\t * extensions that cause us problems are not flagged in that byte.\n\t */\n\tif (!strncmp(sc->sc_model, \"1542C\", 5)) {\n\t\tstruct aha_extbios extbios;\n\t\tstruct aha_unlock unlock;\n\n\t\tprintf(\"%s: unlocking mailbox interface\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\textbios.cmd.opcode = AHA_EXT_BIOS;\n\t\taha_cmd(iobase, sc, sizeof(extbios.cmd),\n\t\t    (u_char *)&extbios.cmd, sizeof(extbios.reply),\n\t\t    (u_char *)&extbios.reply);\n\n#ifdef AHADEBUG\n\t\tprintf(\"%s: flags=%02x, mailboxlock=%02x\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    extbios.reply.flags, extbios.reply.mailboxlock);\n#endif /* AHADEBUG */\n\n\t\tunlock.cmd.opcode = AHA_MBX_ENABLE;\n\t\tunlock.cmd.junk = 0;\n\t\tunlock.cmd.magic = extbios.reply.mailboxlock;\n\t\taha_cmd(iobase, sc, sizeof(unlock.cmd), (u_char *)&unlock.cmd,\n\t\t    0, (u_char *)0);\n\t}\n\n#if 0\n\t/*\n\t * Change the bus on/off times to not clash with other dma users.\n\t */\n\taha_cmd(sc, 1, 0, 0, 0, AHA_BUS_ON_TIME_SET, 7);\n\taha_cmd(sc, 1, 0, 0, 0, AHA_BUS_OFF_TIME_SET, 4);\n#endif\n\n\t/* Inquire Installed Devices (to force synchronous negotiation). */\n\tdevices.cmd.opcode = AHA_INQUIRE_DEVICES;\n\taha_cmd(iobase, sc, sizeof(devices.cmd), (u_char *)&devices.cmd,\n\t    sizeof(devices.reply), (u_char *)&devices.reply);\n\n\t/* Obtain setup information from. */\n\tsetup.cmd.opcode = AHA_INQUIRE_SETUP;\n\tsetup.cmd.len = sizeof(setup.reply);\n\taha_cmd(iobase, sc, sizeof(setup.cmd), (u_char *)&setup.cmd,\n\t    sizeof(setup.reply), (u_char *)&setup.reply);\n\n\tprintf(\"%s: %s, %s\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    setup.reply.sync_neg ? \"sync\" : \"async\",\n\t    setup.reply.parity ? \"parity\" : \"no parity\");\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!setup.reply.sync[i].valid ||\n\t\t    (!setup.reply.sync[i].offset &&\n\t\t    !setup.reply.sync[i].period))\n\t\t\tcontinue;\n\t\tprintf(\"%s targ %d: sync, offset %d, period %dnsec\\n\",\n\t\t    sc->sc_dev.dv_xname, i, setup.reply.sync[i].offset,\n\t\t    setup.reply.sync[i].period * 50 + 200);\n\t}\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\n\t/* XXX KLUDGE!  Should use bus_dmamem_alloc when busified.  */\n#ifdef UVM\n\twmbx = (struct aha_mbx *)uvm_pagealloc_contig(sizeof(struct aha_mbx),\n\t    0, 0xffffff, PAGE_SIZE);\n#else\n\twmbx = (struct aha_mbx *)vm_pagealloc_contig(sizeof(struct aha_mbx),\n\t    0, 0xffffff, PAGE_SIZE);\n#endif\n\tif (wmbx == NULL)\n\t\tpanic(\"aha_init: could not allocate mailbox\");\n\n\tfor (i = 0; i < AHA_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = AHA_MBO_FREE;\n\t\twmbx->mbi[i].stat = AHA_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Initialize mail box. */\n\tmailbox.cmd.opcode = AHA_MBX_INIT;\n\tmailbox.cmd.nmbx = AHA_MBX_SIZE;\n\tltophys(vtophys(wmbx), mailbox.cmd.addr);\n\taha_cmd(iobase, sc, sizeof(mailbox.cmd), (u_char *)&mailbox.cmd,\n\t    0, (u_char *)0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aha_inquire_setup_information",
          "args": [
            "sc"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "aha_inquire_setup_information",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "1108-1188",
          "snippet": "void\naha_inquire_setup_information(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_revision revision;\n\tu_char sts;\n\tint i;\n\tchar *p;\n\n\tstrcpy(sc->sc_model, \"unknown\");\n\n\t/*\n\t * Assume we have a board at this stage, do an adapter inquire\n\t * to find out what type of controller it is.  If the command\n\t * fails, we assume it's either a crusty board or an old 1542\n\t * clone, and skip the board-specific stuff.\n\t */\n\trevision.cmd.opcode = AHA_INQUIRE_REVISION;\n\tif (aha_cmd(iobase, sc, sizeof(revision.cmd), (u_char *)&revision.cmd,\n\t    sizeof(revision.reply), (u_char *)&revision.reply)) {\n\t\t/*\n\t\t * aha_cmd() already started the reset.  It's not clear we\n\t\t * even need to bother here.\n\t\t */\n\t\tfor (i = AHA_RESET_TIMEOUT; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))\n\t\t\t\tbreak;\n\t\t\tdelay(1000);\n\t\t}\n\t\tif (!i) {\n#ifdef AHADEBUG\n\t\t\tprintf(\"aha_init: soft reset failed\\n\");\n#endif /* AHADEBUG */\n\t\t\treturn;\n\t\t}\n#ifdef AHADEBUG\n\t\tprintf(\"aha_init: inquire command failed\\n\");\n#endif /* AHADEBUG */\n\t\tgoto noinquire;\n\t}\n\n#ifdef AHADEBUG\n\tprintf(\"%s: inquire %x, %x, %x, %x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    revision.reply.boardid, revision.reply.spec_opts,\n\t    revision.reply.revision_1, revision.reply.revision_2);\n#endif /* AHADEBUG */\n\n\tswitch (revision.reply.boardid) {\n\tcase 0x31:\n\t\tstrcpy(sc->sc_model, \"1540\");\n\t\tbreak;\n\tcase 0x41:\n\t\tstrcpy(sc->sc_model, \"1540A/1542A/1542B\");\n\t\tbreak;\n\tcase 0x42:\n\t\tstrcpy(sc->sc_model, \"1640\");\n\t\tbreak;\n\tcase 0x43:\n\tcase 0x44:\t\t/* Is this 1542C or -CF? */\n\t\tstrcpy(sc->sc_model, \"1542C\");\n\t\tbreak;\n\tcase 0x45:\n\t\tstrcpy(sc->sc_model, \"1542CF\");\n\t\tbreak;\n\tcase 0x46:\n\t\tstrcpy(sc->sc_model, \"1542CP\");\n\t\tbreak;\n\t}\n\n\tp = sc->sc_firmware;\n\t*p++ = revision.reply.revision_1;\n\t*p++ = '.';\n\t*p++ = revision.reply.revision_2;\n\t*p = '\\0';\n\nnoinquire:\n\tprintf(\": model AHA-%s, firmware %s\\n\", sc->sc_model, sc->sc_firmware);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define AHA_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */"
          ],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "void aha_init",
            "void aha_inquire_setup_information",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AHA_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nvoid aha_init;\nvoid aha_inquire_setup_information;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\naha_inquire_setup_information(sc)\n\tstruct aha_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct aha_revision revision;\n\tu_char sts;\n\tint i;\n\tchar *p;\n\n\tstrcpy(sc->sc_model, \"unknown\");\n\n\t/*\n\t * Assume we have a board at this stage, do an adapter inquire\n\t * to find out what type of controller it is.  If the command\n\t * fails, we assume it's either a crusty board or an old 1542\n\t * clone, and skip the board-specific stuff.\n\t */\n\trevision.cmd.opcode = AHA_INQUIRE_REVISION;\n\tif (aha_cmd(iobase, sc, sizeof(revision.cmd), (u_char *)&revision.cmd,\n\t    sizeof(revision.reply), (u_char *)&revision.reply)) {\n\t\t/*\n\t\t * aha_cmd() already started the reset.  It's not clear we\n\t\t * even need to bother here.\n\t\t */\n\t\tfor (i = AHA_RESET_TIMEOUT; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))\n\t\t\t\tbreak;\n\t\t\tdelay(1000);\n\t\t}\n\t\tif (!i) {\n#ifdef AHADEBUG\n\t\t\tprintf(\"aha_init: soft reset failed\\n\");\n#endif /* AHADEBUG */\n\t\t\treturn;\n\t\t}\n#ifdef AHADEBUG\n\t\tprintf(\"aha_init: inquire command failed\\n\");\n#endif /* AHADEBUG */\n\t\tgoto noinquire;\n\t}\n\n#ifdef AHADEBUG\n\tprintf(\"%s: inquire %x, %x, %x, %x\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    revision.reply.boardid, revision.reply.spec_opts,\n\t    revision.reply.revision_1, revision.reply.revision_2);\n#endif /* AHADEBUG */\n\n\tswitch (revision.reply.boardid) {\n\tcase 0x31:\n\t\tstrcpy(sc->sc_model, \"1540\");\n\t\tbreak;\n\tcase 0x41:\n\t\tstrcpy(sc->sc_model, \"1540A/1542A/1542B\");\n\t\tbreak;\n\tcase 0x42:\n\t\tstrcpy(sc->sc_model, \"1640\");\n\t\tbreak;\n\tcase 0x43:\n\tcase 0x44:\t\t/* Is this 1542C or -CF? */\n\t\tstrcpy(sc->sc_model, \"1542C\");\n\t\tbreak;\n\tcase 0x45:\n\t\tstrcpy(sc->sc_model, \"1542CF\");\n\t\tbreak;\n\tcase 0x46:\n\t\tstrcpy(sc->sc_model, \"1542CP\");\n\t\tbreak;\n\t}\n\n\tp = sc->sc_firmware;\n\t*p++ = revision.reply.revision_1;\n\t*p++ = '.';\n\t*p++ = revision.reply.revision_2;\n\t*p = '\\0';\n\nnoinquire:\n\tprintf(\": model AHA-%s, firmware %s\\n\", sc->sc_model, sc->sc_firmware);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isadma_cascade",
          "args": [
            "sc->sc_drq"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahaattach: aha_find of %s failed\"",
            "self->dv_xname"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aha_find",
          "args": [
            "ia",
            "sc",
            "isapnp"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "aha_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "883-997",
          "snippet": "int\naha_find(ia, sc, isapnp)\n\tstruct isa_attach_args *ia;\n\tstruct aha_softc *sc;\n\tint isapnp;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct aha_config config;\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_HRST | AHA_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = AHA_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\tif (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* calibrated in msec */\n\t}\n\tif (!i) {\n#ifdef AHADEBUG\n\t\tif (aha_debug)\n\t\t\tprintf(\"aha_find: No answer from adaptec board\\n\");\n#endif /* AHADEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * setup dma channel from jumpers and save int\n\t * level\n\t */\n\tdelay(1000);\t\t/* for Bustek 545 */\n\tconfig.cmd.opcode = AHA_INQUIRE_CONFIG;\n\taha_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\t/* for EISA/VLB/PCI clones */\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal drq setting %x\\n\",\n\t\t    config.reply.chan);\n\t\treturn 1;\n\t}\n\tif (isapnp)\n\t\tirq = ia->ia_irq;\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal irq setting %x\\n\",\n\t\t    config.reply.intr);\n\t\treturn EIO;\n\t}\n\tif (isapnp)\n\t\tdrq = ia->ia_drq;\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (isapnp)\n\t\t\treturn (0);\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define AHA_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */"
          ],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "int aha_find",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AHA_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nint aha_find;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_find(ia, sc, isapnp)\n\tstruct isa_attach_args *ia;\n\tstruct aha_softc *sc;\n\tint isapnp;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct aha_config config;\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_HRST | AHA_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = AHA_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\tif (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* calibrated in msec */\n\t}\n\tif (!i) {\n#ifdef AHADEBUG\n\t\tif (aha_debug)\n\t\t\tprintf(\"aha_find: No answer from adaptec board\\n\");\n#endif /* AHADEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * setup dma channel from jumpers and save int\n\t * level\n\t */\n\tdelay(1000);\t\t/* for Bustek 545 */\n\tconfig.cmd.opcode = AHA_INQUIRE_CONFIG;\n\taha_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\t/* for EISA/VLB/PCI clones */\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal drq setting %x\\n\",\n\t\t    config.reply.chan);\n\t\treturn 1;\n\t}\n\tif (isapnp)\n\t\tirq = ia->ia_irq;\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal irq setting %x\\n\",\n\t\t    config.reply.intr);\n\t\treturn EIO;\n\t}\n\tif (isapnp)\n\t\tdrq = ia->ia_drq;\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (isapnp)\n\t\t\treturn (0);\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isadma_cascade",
          "args": [
            "ia->ia_drq"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parent->dv_cfdata->cf_driver->cd_name",
            "\"isapnp\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\naha_finish_ccbs __P((struct aha_softc *));\nint ahaintr;\nint aha_find;\nvoid aha_init;\nvoid aha_inquire_setup_information;\nstruct scsi_adapter aha_switch = {\n\taha_scsi_cmd,\n\tahaminphys,\n\t0,\n\t0,\n};\nstruct scsi_device aha_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nvoid\tahaattach;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nvoid\nahaattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct aha_softc *sc = (void *)self;\n\tint isapnp = !strcmp(parent->dv_cfdata->cf_driver->cd_name, \"isapnp\");\n\n\tif (isapnp) {\n\t\tia->ia_iobase = ia->ipa_io[0].base;\n\t\tisadma_cascade(ia->ia_drq);\n\t}\n\n\tif (aha_find(ia, sc, isapnp) != 0)\n\t\tpanic(\"ahaattach: aha_find of %s failed\", self->dv_xname);\n\tsc->sc_iobase = ia->ia_iobase;\n\n\tif (sc->sc_drq != DRQUNK && isapnp == 0)\n\t\tisadma_cascade(sc->sc_drq);\n\n\taha_inquire_setup_information(sc);\n\taha_init(sc);\n\tTAILQ_INIT(&sc->sc_free_ccb);\n\tTAILQ_INIT(&sc->sc_waiting_ccb);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &aha_switch;\n\tsc->sc_link.device = &aha_dev;\n\tsc->sc_link.openings = 2;\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, sc->sc_irq, IST_EDGE,\n\t    IPL_BIO, ahaintr, sc, sc->sc_dev.dv_xname);\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tconfig_found(self, &sc->sc_link, scsiprint);\n}"
  },
  {
    "function_name": "ahaprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "341-364",
    "snippet": "int\nahaprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tregister struct isa_attach_args *ia = aux;\n#if NBT > 0\n\textern int btports[], nbtports;\n\tint i;\n\n\tfor (i = 0; i < nbtports; i++)\n\t\tif (btports[i] == ia->ia_iobase)\n\t\t\treturn 0;\n#endif\n\n\t/* See if there is a unit at this location. */\n\tif (aha_find(ia, NULL, 0) != 0)\n\t\treturn 0;\n\n\tia->ia_msize = 0;\n\tia->ia_iosize = 4;\n\t/* IRQ and DRQ set by aha_find(). */\n\treturn 1;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int aha_find",
      "int\tahaprobe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aha_find",
          "args": [
            "ia",
            "NULL",
            "0"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "aha_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
          "lines": "883-997",
          "snippet": "int\naha_find(ia, sc, isapnp)\n\tstruct isa_attach_args *ia;\n\tstruct aha_softc *sc;\n\tint isapnp;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct aha_config config;\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_HRST | AHA_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = AHA_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\tif (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* calibrated in msec */\n\t}\n\tif (!i) {\n#ifdef AHADEBUG\n\t\tif (aha_debug)\n\t\t\tprintf(\"aha_find: No answer from adaptec board\\n\");\n#endif /* AHADEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * setup dma channel from jumpers and save int\n\t * level\n\t */\n\tdelay(1000);\t\t/* for Bustek 545 */\n\tconfig.cmd.opcode = AHA_INQUIRE_CONFIG;\n\taha_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\t/* for EISA/VLB/PCI clones */\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal drq setting %x\\n\",\n\t\t    config.reply.chan);\n\t\treturn 1;\n\t}\n\tif (isapnp)\n\t\tirq = ia->ia_irq;\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal irq setting %x\\n\",\n\t\t    config.reply.intr);\n\t\treturn EIO;\n\t}\n\tif (isapnp)\n\t\tdrq = ia->ia_drq;\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (isapnp)\n\t\t\treturn (0);\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include <dev/isa/ahareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define AHA_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */"
          ],
          "globals_used": [
            "int aha_cmd",
            "struct aha_softc *, int, u_char *, int, u_char *));",
            "aha_finish_ccbs __P((struct aha_softc *));",
            "int aha_find",
            "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
            "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AHA_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nint aha_find;\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_find(ia, sc, isapnp)\n\tstruct isa_attach_args *ia;\n\tstruct aha_softc *sc;\n\tint isapnp;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct aha_config config;\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_HRST | AHA_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = AHA_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\tif (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\t/* calibrated in msec */\n\t}\n\tif (!i) {\n#ifdef AHADEBUG\n\t\tif (aha_debug)\n\t\t\tprintf(\"aha_find: No answer from adaptec board\\n\");\n#endif /* AHADEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * setup dma channel from jumpers and save int\n\t * level\n\t */\n\tdelay(1000);\t\t/* for Bustek 545 */\n\tconfig.cmd.opcode = AHA_INQUIRE_CONFIG;\n\taha_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\t/* for EISA/VLB/PCI clones */\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal drq setting %x\\n\",\n\t\t    config.reply.chan);\n\t\treturn 1;\n\t}\n\tif (isapnp)\n\t\tirq = ia->ia_irq;\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"aha_find: illegal irq setting %x\\n\",\n\t\t    config.reply.intr);\n\t\treturn EIO;\n\t}\n\tif (isapnp)\n\t\tdrq = ia->ia_drq;\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (isapnp)\n\t\t\treturn (0);\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint aha_find;\nint\tahaprobe;\n\nint\nahaprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tregister struct isa_attach_args *ia = aux;\n#if NBT > 0\n\textern int btports[], nbtports;\n\tint i;\n\n\tfor (i = 0; i < nbtports; i++)\n\t\tif (btports[i] == ia->ia_iobase)\n\t\t\treturn 0;\n#endif\n\n\t/* See if there is a unit at this location. */\n\tif (aha_find(ia, NULL, 0) != 0)\n\t\treturn 0;\n\n\tia->ia_msize = 0;\n\tia->ia_iosize = 4;\n\t/* IRQ and DRQ set by aha_find(). */\n\treturn 1;\n}"
  },
  {
    "function_name": "aha_isapnp_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "326-332",
    "snippet": "int\naha_isapnp_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\taha_isapnp_probe"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\taha_isapnp_probe;\n\nint\naha_isapnp_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "aha_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/aha.c",
    "lines": "208-324",
    "snippet": "int\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include <dev/isa/ahareg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int aha_cmd",
      "struct aha_softc *, int, u_char *, int, u_char *));",
      "aha_finish_ccbs __P((struct aha_softc *));",
      "struct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;",
      "struct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + AHA_CTRL_PORT",
            "AHA_CTRL_IRST"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: aha_cmd, host not finished(0x%x)\\n\"",
            "name",
            "sts"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "50"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + AHA_INTR_PORT"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include <dev/isa/ahareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint aha_cmd;\nstruct aha_softc *, int, u_char *, int, u_char *));\naha_finish_ccbs __P((struct aha_softc *));\nstruct aha_ccb *\naha_get_ccb(sc, flags)\n\tstruct aha_softc *sc;\nstruct aha_ccb *\naha_ccb_phys_kv(sc, ccb_phys)\n\tstruct aha_softc *sc;\n\nint\naha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct aha_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(aha probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase AHA_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)\n\t\t\tinb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (!(sts & AHA_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port full\\n\",\n\t\t\t\t    name);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + AHA_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + AHA_STAT_PORT);\n\t\t\tif (sts & AHA_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != AHA_INQUIRE_REVISION)\n\t\t\t\tprintf(\"%s: aha_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + AHA_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != AHA_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + AHA_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & AHA_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: aha_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);\n\treturn 0;\n}"
  }
]