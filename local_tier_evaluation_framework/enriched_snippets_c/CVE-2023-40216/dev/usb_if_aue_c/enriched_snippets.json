[
  {
    "function_name": "aue_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1912-1922",
    "snippet": "Static void\naue_shutdown(dev)\n\tdevice_ptr_t\t\tdev;\n{\n\tstruct aue_softc\t*sc = USBGETSOFTC(dev);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\taue_reset(sc);\n\taue_stop(sc);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "aue_miibus_readreg\t__P((device_ptr_t, int, int));",
      "Static void",
      "aue_miibus_statchg\t__P((device_ptr_t));",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));",
      "device_ptr_t\t\tdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aue_stop",
          "args": [
            "sc"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "aue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1817-1905",
          "snippet": "Static void\naue_stop(sc)\n\tstruct aue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\taue_csr_write_1(sc, AUE_CTL0, 0);\n\taue_csr_write_1(sc, AUE_CTL1, 0);\n\taue_reset(sc);\n\tusb_uncallout(sc->aue_stat_ch, aue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->aue_ep[AUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\tsc->aue_link = 0;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_stop(sc)\n\tstruct aue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\taue_csr_write_1(sc, AUE_CTL0, 0);\n\taue_csr_write_1(sc, AUE_CTL1, 0);\n\taue_reset(sc);\n\tusb_uncallout(sc->aue_stat_ch, aue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->aue_ep[AUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\tsc->aue_link = 0;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_reset",
          "args": [
            "sc"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "aue_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "676-721",
          "snippet": "Static void\naue_reset(sc)\n\tstruct aue_softc\t*sc;\n{\n\tint\t\ti;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_RESETMAC);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (!(aue_csr_read_1(sc, AUE_CTL1) & AUE_CTL1_RESETMAC))\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->aue_dev));\n\n\t/*\n\t * The PHY(s) attached to the Pegasus chip may be held\n\t * in reset until we flip on the GPIO outputs. Make sure\n\t * to set the GPIO pins high so that the PHY(s) will\n\t * be enabled.\n\t *\n\t * Note: We force all of the GPIO pins low first, *then*\n\t * enable the ones we want.\n  \t */\n\taue_csr_write_1(sc, AUE_GPIO0, \n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);\n  \taue_csr_write_1(sc, AUE_GPIO0,\n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n  \n\t/* Grrr. LinkSys has to be different from everyone else. */\n\tif ((sc->aue_vendor == USB_VENDOR_LINKSYS &&\n\t     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||\n\t    (sc->aue_vendor == USB_VENDOR_DLINK &&\n\t     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {\n\t\taue_csr_write_1(sc, AUE_GPIO0, \n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n\t\taue_csr_write_1(sc, AUE_GPIO0,\n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1 | AUE_GPIO_OUT0);\n\t}\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(10000);\t\t/* XXX */\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_reset(sc)\n\tstruct aue_softc\t*sc;\n{\n\tint\t\ti;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_RESETMAC);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (!(aue_csr_read_1(sc, AUE_CTL1) & AUE_CTL1_RESETMAC))\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->aue_dev));\n\n\t/*\n\t * The PHY(s) attached to the Pegasus chip may be held\n\t * in reset until we flip on the GPIO outputs. Make sure\n\t * to set the GPIO pins high so that the PHY(s) will\n\t * be enabled.\n\t *\n\t * Note: We force all of the GPIO pins low first, *then*\n\t * enable the ones we want.\n  \t */\n\taue_csr_write_1(sc, AUE_GPIO0, \n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);\n  \taue_csr_write_1(sc, AUE_GPIO0,\n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n  \n\t/* Grrr. LinkSys has to be different from everyone else. */\n\tif ((sc->aue_vendor == USB_VENDOR_LINKSYS &&\n\t     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||\n\t    (sc->aue_vendor == USB_VENDOR_DLINK &&\n\t     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {\n\t\taue_csr_write_1(sc, AUE_GPIO0, \n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n\t\taue_csr_write_1(sc, AUE_GPIO0,\n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1 | AUE_GPIO_OUT0);\n\t}\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(10000);\t\t/* XXX */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBGETSOFTC",
          "args": [
            "dev"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\naue_miibus_readreg\t__P((device_ptr_t, int, int));\nStatic void;\naue_miibus_statchg\t__P((device_ptr_t));\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\ndevice_ptr_t\t\tdev;\n\nStatic void\naue_shutdown(dev)\n\tdevice_ptr_t\t\tdev;\n{\n\tstruct aue_softc\t*sc = USBGETSOFTC(dev);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\taue_reset(sc);\n\taue_stop(sc);\n}"
  },
  {
    "function_name": "aue_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1817-1905",
    "snippet": "Static void\naue_stop(sc)\n\tstruct aue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\taue_csr_write_1(sc, AUE_CTL0, 0);\n\taue_csr_write_1(sc, AUE_CTL1, 0);\n\taue_reset(sc);\n\tusb_uncallout(sc->aue_stat_ch, aue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->aue_ep[AUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\tsc->aue_link = 0;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "sc->aue_cdata.aue_tx_chain[i].aue_xfer"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->aue_cdata.aue_tx_chain[i].aue_mbuf"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->aue_cdata.aue_rx_chain[i].aue_mbuf"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: close intr pipe failed: %s\\n\"",
            "USBDEVNAME(sc->aue_dev)",
            "usbd_errstr(err)"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "sc->aue_ep[AUE_ENDPT_INTR]"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_abort_pipe",
          "args": [
            "sc->aue_ep[AUE_ENDPT_INTR]"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_abort_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "560-577",
          "snippet": "usbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_uncallout",
          "args": [
            "sc->aue_stat_ch",
            "aue_tick",
            "sc"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_reset",
          "args": [
            "sc"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "aue_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "676-721",
          "snippet": "Static void\naue_reset(sc)\n\tstruct aue_softc\t*sc;\n{\n\tint\t\ti;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_RESETMAC);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (!(aue_csr_read_1(sc, AUE_CTL1) & AUE_CTL1_RESETMAC))\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->aue_dev));\n\n\t/*\n\t * The PHY(s) attached to the Pegasus chip may be held\n\t * in reset until we flip on the GPIO outputs. Make sure\n\t * to set the GPIO pins high so that the PHY(s) will\n\t * be enabled.\n\t *\n\t * Note: We force all of the GPIO pins low first, *then*\n\t * enable the ones we want.\n  \t */\n\taue_csr_write_1(sc, AUE_GPIO0, \n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);\n  \taue_csr_write_1(sc, AUE_GPIO0,\n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n  \n\t/* Grrr. LinkSys has to be different from everyone else. */\n\tif ((sc->aue_vendor == USB_VENDOR_LINKSYS &&\n\t     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||\n\t    (sc->aue_vendor == USB_VENDOR_DLINK &&\n\t     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {\n\t\taue_csr_write_1(sc, AUE_GPIO0, \n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n\t\taue_csr_write_1(sc, AUE_GPIO0,\n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1 | AUE_GPIO_OUT0);\n\t}\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(10000);\t\t/* XXX */\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_reset(sc)\n\tstruct aue_softc\t*sc;\n{\n\tint\t\ti;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_RESETMAC);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (!(aue_csr_read_1(sc, AUE_CTL1) & AUE_CTL1_RESETMAC))\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->aue_dev));\n\n\t/*\n\t * The PHY(s) attached to the Pegasus chip may be held\n\t * in reset until we flip on the GPIO outputs. Make sure\n\t * to set the GPIO pins high so that the PHY(s) will\n\t * be enabled.\n\t *\n\t * Note: We force all of the GPIO pins low first, *then*\n\t * enable the ones we want.\n  \t */\n\taue_csr_write_1(sc, AUE_GPIO0, \n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);\n  \taue_csr_write_1(sc, AUE_GPIO0,\n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n  \n\t/* Grrr. LinkSys has to be different from everyone else. */\n\tif ((sc->aue_vendor == USB_VENDOR_LINKSYS &&\n\t     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||\n\t    (sc->aue_vendor == USB_VENDOR_DLINK &&\n\t     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {\n\t\taue_csr_write_1(sc, AUE_GPIO0, \n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n\t\taue_csr_write_1(sc, AUE_GPIO0,\n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1 | AUE_GPIO_OUT0);\n\t}\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(10000);\t\t/* XXX */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_csr_write_1",
          "args": [
            "sc",
            "AUE_CTL1",
            "0"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "355-386",
          "snippet": "Static int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_stop(sc)\n\tstruct aue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\taue_csr_write_1(sc, AUE_CTL0, 0);\n\taue_csr_write_1(sc, AUE_CTL1, 0);\n\taue_reset(sc);\n\tusb_uncallout(sc->aue_stat_ch, aue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->aue_ep[AUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\tsc->aue_link = 0;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
  },
  {
    "function_name": "aue_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1787-1811",
    "snippet": "Static void\naue_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp->if_oerrors++;\n\tprintf(\"%s: watchdog timeout\\n\", USBDEVNAME(sc->aue_dev));\n\n\t/*\n\t * The polling business is a kludge to avoid allowing the\n\t * USB code to call tsleep() in usbd_delay_ms(), which will\n\t * kill us since the watchdog routine is invoked from\n\t * interrupt context.\n\t */\n\tusbd_set_polling(sc->aue_udev, 1);\n\taue_stop(sc);\n\taue_init(sc);\n\tusbd_set_polling(sc->aue_udev, 0);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\taue_start(ifp);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aue_start",
          "args": [
            "ifp"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "aue_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1464-1508",
          "snippet": "Static void\naue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(5,(\"%s: %s: enter, link=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, sc->aue_link));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!sc->aue_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (aue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(5,(\"%s: %s: enter, link=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, sc->aue_link));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!sc->aue_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (aue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_set_polling",
          "args": [
            "sc->aue_udev",
            "0"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_polling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1100-1109",
          "snippet": "void\nusbd_set_polling(dev, on)\n\tusbd_device_handle dev;\n\tint on;\n{\n\tif (on)\n\t\tdev->bus->use_polling++;\n\telse\n\t\tdev->bus->use_polling--;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nvoid\nusbd_set_polling(dev, on)\n\tusbd_device_handle dev;\n\tint on;\n{\n\tif (on)\n\t\tdev->bus->use_polling++;\n\telse\n\t\tdev->bus->use_polling--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_init",
          "args": [
            "sc"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "aue_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1510-1586",
          "snippet": "Static void\naue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct aue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\tint\t\t\ti, s;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\taue_reset(sc);\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taue_csr_write_1(sc, AUE_PAR0 + i, eaddr[i]);\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\telse\n\t\tAUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\n\t/* Init TX ring. */\n\tif (aue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (aue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\taue_setmulti(sc);\n\n\t/* Enable RX and TX */\n\taue_csr_write_1(sc, AUE_CTL0, AUE_CTL0_RXSTAT_APPEND | AUE_CTL0_RX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_TX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_EP3_CLR);\n\n\tmii_mediachg(mii);\n\n\tif (sc->aue_ep[AUE_ENDPT_RX] == NULL) {\n\t\tif (aue_openpipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->aue_stat_ch, hz, aue_tick, sc);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "aue_read_mac\t__P((struct aue_softc *, u_char *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\naue_read_mac\t__P((struct aue_softc *, u_char *));\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct aue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\tint\t\t\ti, s;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\taue_reset(sc);\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taue_csr_write_1(sc, AUE_PAR0 + i, eaddr[i]);\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\telse\n\t\tAUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\n\t/* Init TX ring. */\n\tif (aue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (aue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\taue_setmulti(sc);\n\n\t/* Enable RX and TX */\n\taue_csr_write_1(sc, AUE_CTL0, AUE_CTL0_RXSTAT_APPEND | AUE_CTL0_RX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_TX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_EP3_CLR);\n\n\tmii_mediachg(mii);\n\n\tif (sc->aue_ep[AUE_ENDPT_RX] == NULL) {\n\t\tif (aue_openpipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->aue_stat_ch, hz, aue_tick, sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_stop",
          "args": [
            "sc"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "aue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1817-1905",
          "snippet": "Static void\naue_stop(sc)\n\tstruct aue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\taue_csr_write_1(sc, AUE_CTL0, 0);\n\taue_csr_write_1(sc, AUE_CTL1, 0);\n\taue_reset(sc);\n\tusb_uncallout(sc->aue_stat_ch, aue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->aue_ep[AUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\tsc->aue_link = 0;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_stop(sc)\n\tstruct aue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\taue_csr_write_1(sc, AUE_CTL0, 0);\n\taue_csr_write_1(sc, AUE_CTL1, 0);\n\taue_reset(sc);\n\tusb_uncallout(sc->aue_stat_ch, aue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->aue_ep[AUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\tsc->aue_link = 0;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: watchdog timeout\\n\"",
            "USBDEVNAME(sc->aue_dev)"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp->if_oerrors++;\n\tprintf(\"%s: watchdog timeout\\n\", USBDEVNAME(sc->aue_dev));\n\n\t/*\n\t * The polling business is a kludge to avoid allowing the\n\t * USB code to call tsleep() in usbd_delay_ms(), which will\n\t * kill us since the watchdog routine is invoked from\n\t * interrupt context.\n\t */\n\tusbd_set_polling(sc->aue_udev, 1);\n\taue_stop(sc);\n\taue_init(sc);\n\tusbd_set_polling(sc->aue_udev, 0);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\taue_start(ifp);\n}"
  },
  {
    "function_name": "aue_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1681-1785",
    "snippet": "Static int\naue_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ifaddr \t\t*ifa = (struct ifaddr *)data;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tstruct ifreq\t\t*ifr = (struct ifreq *)data;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts, error = 0;\n\n\tif (sc->aue_dying)\n\t\treturn (EIO);\n\n\ts = splimp();\n\n\tswitch(command) {\n#if defined(__FreeBSD__)\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFMTU:\n\t\terror = ether_ioctl(ifp, command, data);\n\t\tbreak;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\taue_init(sc);\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#if defined(__NetBSD__)\n\t\t\tarp_ifinit(ifp, ifa);\n#else\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n#endif\n\t\t\tbreak;\n#endif /* INET */\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t\tLLADDR(ifp->if_sadl);\n\t\t\telse\n\t\t\t\tmemcpy(LLADDR(ifp->if_sadl),\n\t\t\t\t       ina->x_host.c_host,\n\t\t\t\t       ifp->if_addrlen);\n\t\t\tbreak;\n\t\t    }\n#endif /* NS */\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > ETHERMTU)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\tbreak;\n\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->aue_if_flags & IFF_PROMISC)) {\n\t\t\t\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->aue_if_flags & IFF_PROMISC) {\n\t\t\t\tAUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\t\t\t} else if (!(ifp->if_flags & IFF_RUNNING))\n\t\t\t\taue_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\taue_stop(sc);\n\t\t}\n\t\tsc->aue_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\taue_setmulti(sc);\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\tmii = GET_MII(sc);\n\t\terror = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "aue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "aue_crc\t__P((caddr_t));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));",
      "int\t\t\tphy, reg, data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&mii->mii_media",
            "command"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_MII",
          "args": [
            "sc"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_setmulti",
          "args": [
            "sc"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "aue_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "617-674",
          "snippet": "Static void\naue_setmulti(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th = 0, i;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\treturn;\n\t}\n\n\tAUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < 8; i++)\n\t\taue_csr_write_1(sc, AUE_MAR0 + i, 0);\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = aue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->aue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 1\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = aue_crc(enm->enm_addrlo);\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static u_int32_t",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic u_int32_t;\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_setmulti(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th = 0, i;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\treturn;\n\t}\n\n\tAUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < 8; i++)\n\t\taue_csr_write_1(sc, AUE_MAR0 + i, 0);\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = aue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->aue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 1\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = aue_crc(enm->enm_addrlo);\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_stop",
          "args": [
            "sc"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "aue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1817-1905",
          "snippet": "Static void\naue_stop(sc)\n\tstruct aue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\taue_csr_write_1(sc, AUE_CTL0, 0);\n\taue_csr_write_1(sc, AUE_CTL1, 0);\n\taue_reset(sc);\n\tusb_uncallout(sc->aue_stat_ch, aue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->aue_ep[AUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\tsc->aue_link = 0;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_stop(sc)\n\tstruct aue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\taue_csr_write_1(sc, AUE_CTL0, 0);\n\taue_csr_write_1(sc, AUE_CTL1, 0);\n\taue_reset(sc);\n\tusb_uncallout(sc->aue_stat_ch, aue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->aue_ep[AUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\tsc->aue_link = 0;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_init",
          "args": [
            "sc"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "aue_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1510-1586",
          "snippet": "Static void\naue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct aue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\tint\t\t\ti, s;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\taue_reset(sc);\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taue_csr_write_1(sc, AUE_PAR0 + i, eaddr[i]);\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\telse\n\t\tAUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\n\t/* Init TX ring. */\n\tif (aue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (aue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\taue_setmulti(sc);\n\n\t/* Enable RX and TX */\n\taue_csr_write_1(sc, AUE_CTL0, AUE_CTL0_RXSTAT_APPEND | AUE_CTL0_RX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_TX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_EP3_CLR);\n\n\tmii_mediachg(mii);\n\n\tif (sc->aue_ep[AUE_ENDPT_RX] == NULL) {\n\t\tif (aue_openpipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->aue_stat_ch, hz, aue_tick, sc);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "aue_read_mac\t__P((struct aue_softc *, u_char *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\naue_read_mac\t__P((struct aue_softc *, u_char *));\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct aue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\tint\t\t\ti, s;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\taue_reset(sc);\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taue_csr_write_1(sc, AUE_PAR0 + i, eaddr[i]);\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\telse\n\t\tAUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\n\t/* Init TX ring. */\n\tif (aue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (aue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\taue_setmulti(sc);\n\n\t/* Enable RX and TX */\n\taue_csr_write_1(sc, AUE_CTL0, AUE_CTL0_RXSTAT_APPEND | AUE_CTL0_RX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_TX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_EP3_CLR);\n\n\tmii_mediachg(mii);\n\n\tif (sc->aue_ep[AUE_ENDPT_RX] == NULL) {\n\t\tif (aue_openpipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->aue_stat_ch, hz, aue_tick, sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUE_CLRBIT",
          "args": [
            "sc",
            "AUE_CTL2",
            "AUE_CTL2_RX_PROMISC"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_CTL2",
            "AUE_CTL2_RX_PROMISC"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "LLADDR(ifp->if_sadl)",
            "ina->x_host.c_host",
            "ifp->if_addrlen"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "command",
            "data"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\naue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\naue_crc\t__P((caddr_t));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\nint\t\t\tphy, reg, data;\n\nStatic int\naue_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ifaddr \t\t*ifa = (struct ifaddr *)data;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tstruct ifreq\t\t*ifr = (struct ifreq *)data;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts, error = 0;\n\n\tif (sc->aue_dying)\n\t\treturn (EIO);\n\n\ts = splimp();\n\n\tswitch(command) {\n#if defined(__FreeBSD__)\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFMTU:\n\t\terror = ether_ioctl(ifp, command, data);\n\t\tbreak;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\taue_init(sc);\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#if defined(__NetBSD__)\n\t\t\tarp_ifinit(ifp, ifa);\n#else\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n#endif\n\t\t\tbreak;\n#endif /* INET */\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t\tLLADDR(ifp->if_sadl);\n\t\t\telse\n\t\t\t\tmemcpy(LLADDR(ifp->if_sadl),\n\t\t\t\t       ina->x_host.c_host,\n\t\t\t\t       ifp->if_addrlen);\n\t\t\tbreak;\n\t\t    }\n#endif /* NS */\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > ETHERMTU)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\tbreak;\n\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->aue_if_flags & IFF_PROMISC)) {\n\t\t\t\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->aue_if_flags & IFF_PROMISC) {\n\t\t\t\tAUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\t\t\t} else if (!(ifp->if_flags & IFF_RUNNING))\n\t\t\t\taue_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\taue_stop(sc);\n\t\t}\n\t\tsc->aue_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\taue_setmulti(sc);\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\tmii = GET_MII(sc);\n\t\terror = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "aue_ifmedia_sts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1666-1679",
    "snippet": "Static void\naue_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "aue_ifmedia_sts\t__P((struct ifnet *, struct ifmediareq *));",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "mii"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_MII",
          "args": [
            "sc"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\naue_ifmedia_sts\t__P((struct ifnet *, struct ifmediareq *));\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tmii_pollstat(mii);\n\tifmr->ifm_active = mii->mii_media_active;\n\tifmr->ifm_status = mii->mii_media_status;\n}"
  },
  {
    "function_name": "aue_ifmedia_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1639-1661",
    "snippet": "Static int\naue_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tsc->aue_link = 0;\n\tif (mii->mii_instance) {\n\t\tstruct mii_softc\t*miisc;\n\t\tfor (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;\n\t\t    miisc = LIST_NEXT(miisc, mii_list))\n\t\t\t mii_phy_reset(miisc);\n\t}\n\tmii_mediachg(mii);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_mediachg",
          "args": [
            "mii"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "mii_mediachg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "170-187",
          "snippet": "int\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_phy_reset",
          "args": [
            "miisc"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii_physubr.c",
          "lines": "160-182",
          "snippet": "void\nmii_phy_reset(mii)\n\tstruct mii_softc *mii;\n{\n\tint reg, i;\n\n\tif (mii->mii_flags & MIIF_NOISOLATE)\n\t\treg = BMCR_RESET;\n\telse\n\t\treg = BMCR_RESET | BMCR_ISO;\n\tPHY_WRITE(mii, MII_BMCR, reg);\n\n\t/* Wait 100ms for it to complete. */\n\tfor (i = 0; i < 100; i++) {\n\t\treg = PHY_READ(mii, MII_BMCR); \n\t\tif ((reg & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\n\tif (mii->mii_inst != 0 && ((mii->mii_flags & MIIF_NOISOLATE) == 0))\n\t\tPHY_WRITE(mii, MII_BMCR, reg | BMCR_ISO);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_phy_reset(mii)\n\tstruct mii_softc *mii;\n{\n\tint reg, i;\n\n\tif (mii->mii_flags & MIIF_NOISOLATE)\n\t\treg = BMCR_RESET;\n\telse\n\t\treg = BMCR_RESET | BMCR_ISO;\n\tPHY_WRITE(mii, MII_BMCR, reg);\n\n\t/* Wait 100ms for it to complete. */\n\tfor (i = 0; i < 100; i++) {\n\t\treg = PHY_READ(mii, MII_BMCR); \n\t\tif ((reg & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\n\tif (mii->mii_inst != 0 && ((mii->mii_flags & MIIF_NOISOLATE) == 0))\n\t\tPHY_WRITE(mii, MII_BMCR, reg | BMCR_ISO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "miisc",
            "mii_list"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&mii->mii_phys"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_MII",
          "args": [
            "sc"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tsc->aue_link = 0;\n\tif (mii->mii_instance) {\n\t\tstruct mii_softc\t*miisc;\n\t\tfor (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;\n\t\t    miisc = LIST_NEXT(miisc, mii_list))\n\t\t\t mii_phy_reset(miisc);\n\t}\n\tmii_mediachg(mii);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "aue_openpipes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1588-1634",
    "snippet": "Static int\naue_openpipes(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_chain\t*c;\n\tusbd_status\t\terr;\n\tint i;\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\tusbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\terr = usbd_open_pipe_intr(sc->aue_iface, sc->aue_ed[AUE_ENDPT_INTR],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_INTR], sc,\n\t    &sc->aue_cdata.aue_ibuf, AUE_INTR_PKTLEN, aue_intr, \n\t    AUE_INTR_INTERVAL);\n\tif (err) {\n\t\tprintf(\"%s: open intr pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->aue_cdata.aue_rx_chain[i];\n\t\tusbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_RX],\n\t\t    c, c->aue_buf, AUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    aue_rxeof);\n\t\t(void)usbd_transfer(c->aue_xfer); /* XXX */\n\t\tDPRINTFN(5,(\"%s: %s: start read\\n\", USBDEVNAME(sc->aue_dev),\n\t\t\t    __FUNCTION__));\n\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: start read\\n\", USBDEVNAME(sc->aue_dev),\n\t\t\t    __FUNCTION__)"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->aue_xfer"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->aue_xfer",
            "sc->aue_ep[AUE_ENDPT_RX]",
            "c",
            "c->aue_buf",
            "AUE_BUFSZ",
            "USBD_SHORT_XFER_OK | USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "aue_rxeof"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: open intr pipe failed: %s\\n\"",
            "USBDEVNAME(sc->aue_dev)",
            "usbd_errstr(err)"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_open_pipe_intr",
          "args": [
            "sc->aue_iface",
            "sc->aue_ed[AUE_ENDPT_INTR]",
            "USBD_EXCLUSIVE_USE",
            "&sc->aue_ep[AUE_ENDPT_INTR]",
            "sc",
            "&sc->aue_cdata.aue_ibuf",
            "AUE_INTR_PKTLEN",
            "aue_intr",
            "AUE_INTR_INTERVAL"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_open_pipe_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "177-222",
          "snippet": "usbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_openpipes(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_chain\t*c;\n\tusbd_status\t\terr;\n\tint i;\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\tusbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\terr = usbd_open_pipe_intr(sc->aue_iface, sc->aue_ed[AUE_ENDPT_INTR],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_INTR], sc,\n\t    &sc->aue_cdata.aue_ibuf, AUE_INTR_PKTLEN, aue_intr, \n\t    AUE_INTR_INTERVAL);\n\tif (err) {\n\t\tprintf(\"%s: open intr pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->aue_cdata.aue_rx_chain[i];\n\t\tusbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_RX],\n\t\t    c, c->aue_buf, AUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    aue_rxeof);\n\t\t(void)usbd_transfer(c->aue_xfer); /* XXX */\n\t\tDPRINTFN(5,(\"%s: %s: start read\\n\", USBDEVNAME(sc->aue_dev),\n\t\t\t    __FUNCTION__));\n\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "aue_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1510-1586",
    "snippet": "Static void\naue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct aue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\tint\t\t\ti, s;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\taue_reset(sc);\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taue_csr_write_1(sc, AUE_PAR0 + i, eaddr[i]);\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\telse\n\t\tAUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\n\t/* Init TX ring. */\n\tif (aue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (aue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\taue_setmulti(sc);\n\n\t/* Enable RX and TX */\n\taue_csr_write_1(sc, AUE_CTL0, AUE_CTL0_RXSTAT_APPEND | AUE_CTL0_RX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_TX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_EP3_CLR);\n\n\tmii_mediachg(mii);\n\n\tif (sc->aue_ep[AUE_ENDPT_RX] == NULL) {\n\t\tif (aue_openpipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->aue_stat_ch, hz, aue_tick, sc);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "aue_read_mac\t__P((struct aue_softc *, u_char *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "sc->aue_stat_ch",
            "hz",
            "aue_tick",
            "sc"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_openpipes",
          "args": [
            "sc"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "aue_openpipes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1588-1634",
          "snippet": "Static int\naue_openpipes(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_chain\t*c;\n\tusbd_status\t\terr;\n\tint i;\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\tusbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\terr = usbd_open_pipe_intr(sc->aue_iface, sc->aue_ed[AUE_ENDPT_INTR],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_INTR], sc,\n\t    &sc->aue_cdata.aue_ibuf, AUE_INTR_PKTLEN, aue_intr, \n\t    AUE_INTR_INTERVAL);\n\tif (err) {\n\t\tprintf(\"%s: open intr pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->aue_cdata.aue_rx_chain[i];\n\t\tusbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_RX],\n\t\t    c, c->aue_buf, AUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    aue_rxeof);\n\t\t(void)usbd_transfer(c->aue_xfer); /* XXX */\n\t\tDPRINTFN(5,(\"%s: %s: start read\\n\", USBDEVNAME(sc->aue_dev),\n\t\t\t    __FUNCTION__));\n\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_openpipes(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_chain\t*c;\n\tusbd_status\t\terr;\n\tint i;\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\tusbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\terr = usbd_open_pipe_intr(sc->aue_iface, sc->aue_ed[AUE_ENDPT_INTR],\n\t    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_INTR], sc,\n\t    &sc->aue_cdata.aue_ibuf, AUE_INTR_PKTLEN, aue_intr, \n\t    AUE_INTR_INTERVAL);\n\tif (err) {\n\t\tprintf(\"%s: open intr pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->aue_cdata.aue_rx_chain[i];\n\t\tusbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_RX],\n\t\t    c, c->aue_buf, AUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    aue_rxeof);\n\t\t(void)usbd_transfer(c->aue_xfer); /* XXX */\n\t\tDPRINTFN(5,(\"%s: %s: start read\\n\", USBDEVNAME(sc->aue_dev),\n\t\t\t    __FUNCTION__));\n\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_mediachg",
          "args": [
            "mii"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "mii_mediachg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "170-187",
          "snippet": "int\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_CTL2",
            "AUE_CTL2_EP3_CLR"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_CTL0",
            "AUE_CTL0_TX_ENB"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_csr_write_1",
          "args": [
            "sc",
            "AUE_CTL0",
            "AUE_CTL0_RXSTAT_APPEND | AUE_CTL0_RX_ENB"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "355-386",
          "snippet": "Static int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_setmulti",
          "args": [
            "sc"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "aue_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "617-674",
          "snippet": "Static void\naue_setmulti(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th = 0, i;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\treturn;\n\t}\n\n\tAUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < 8; i++)\n\t\taue_csr_write_1(sc, AUE_MAR0 + i, 0);\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = aue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->aue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 1\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = aue_crc(enm->enm_addrlo);\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static u_int32_t",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic u_int32_t;\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_setmulti(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th = 0, i;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\treturn;\n\t}\n\n\tAUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < 8; i++)\n\t\taue_csr_write_1(sc, AUE_MAR0 + i, 0);\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = aue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->aue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 1\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = aue_crc(enm->enm_addrlo);\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: rx list init failed\\n\"",
            "USBDEVNAME(sc->aue_dev)"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_rx_list_init",
          "args": [
            "sc"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "aue_rx_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1060-1088",
          "snippet": "Static int \naue_rx_list_init(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_cdata\t*cd;\n\tstruct aue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tcd = &sc->aue_cdata;\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->aue_rx_chain[i];\n\t\tc->aue_sc = sc;\n\t\tc->aue_idx = i;\n\t\tif (aue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->aue_xfer == NULL) {\n\t\t\tc->aue_xfer = usbd_alloc_xfer(sc->aue_udev);\n\t\t\tif (c->aue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->aue_buf = usbd_alloc_buffer(c->aue_xfer, AUE_BUFSZ);\n\t\t\tif (c->aue_buf == NULL)\n\t\t\t\treturn (ENOBUFS); /* XXX free xfer */\n\t\t}\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int \naue_rx_list_init(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_cdata\t*cd;\n\tstruct aue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tcd = &sc->aue_cdata;\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->aue_rx_chain[i];\n\t\tc->aue_sc = sc;\n\t\tc->aue_idx = i;\n\t\tif (aue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->aue_xfer == NULL) {\n\t\t\tc->aue_xfer = usbd_alloc_xfer(sc->aue_udev);\n\t\t\tif (c->aue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->aue_buf = usbd_alloc_buffer(c->aue_xfer, AUE_BUFSZ);\n\t\t\tif (c->aue_buf == NULL)\n\t\t\t\treturn (ENOBUFS); /* XXX free xfer */\n\t\t}\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_tx_list_init",
          "args": [
            "sc"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "aue_tx_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1090-1117",
          "snippet": "Static int\naue_tx_list_init(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_cdata\t*cd;\n\tstruct aue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tcd = &sc->aue_cdata;\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->aue_tx_chain[i];\n\t\tc->aue_sc = sc;\n\t\tc->aue_idx = i;\n\t\tc->aue_mbuf = NULL;\n\t\tif (c->aue_xfer == NULL) {\n\t\t\tc->aue_xfer = usbd_alloc_xfer(sc->aue_udev);\n\t\t\tif (c->aue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->aue_buf = usbd_alloc_buffer(c->aue_xfer, AUE_BUFSZ);\n\t\t\tif (c->aue_buf == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t}\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_tx_list_init(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_cdata\t*cd;\n\tstruct aue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tcd = &sc->aue_cdata;\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->aue_tx_chain[i];\n\t\tc->aue_sc = sc;\n\t\tc->aue_idx = i;\n\t\tc->aue_mbuf = NULL;\n\t\tif (c->aue_xfer == NULL) {\n\t\t\tc->aue_xfer = usbd_alloc_xfer(sc->aue_udev);\n\t\t\tif (c->aue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->aue_buf = usbd_alloc_buffer(c->aue_xfer, AUE_BUFSZ);\n\t\t\tif (c->aue_buf == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t}\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUE_CLRBIT",
          "args": [
            "sc",
            "AUE_CTL2",
            "AUE_CTL2_RX_PROMISC"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_CTL2",
            "AUE_CTL2_RX_PROMISC"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_reset",
          "args": [
            "sc"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "aue_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "676-721",
          "snippet": "Static void\naue_reset(sc)\n\tstruct aue_softc\t*sc;\n{\n\tint\t\ti;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_RESETMAC);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (!(aue_csr_read_1(sc, AUE_CTL1) & AUE_CTL1_RESETMAC))\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->aue_dev));\n\n\t/*\n\t * The PHY(s) attached to the Pegasus chip may be held\n\t * in reset until we flip on the GPIO outputs. Make sure\n\t * to set the GPIO pins high so that the PHY(s) will\n\t * be enabled.\n\t *\n\t * Note: We force all of the GPIO pins low first, *then*\n\t * enable the ones we want.\n  \t */\n\taue_csr_write_1(sc, AUE_GPIO0, \n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);\n  \taue_csr_write_1(sc, AUE_GPIO0,\n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n  \n\t/* Grrr. LinkSys has to be different from everyone else. */\n\tif ((sc->aue_vendor == USB_VENDOR_LINKSYS &&\n\t     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||\n\t    (sc->aue_vendor == USB_VENDOR_DLINK &&\n\t     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {\n\t\taue_csr_write_1(sc, AUE_GPIO0, \n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n\t\taue_csr_write_1(sc, AUE_GPIO0,\n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1 | AUE_GPIO_OUT0);\n\t}\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(10000);\t\t/* XXX */\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_reset(sc)\n\tstruct aue_softc\t*sc;\n{\n\tint\t\ti;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_RESETMAC);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (!(aue_csr_read_1(sc, AUE_CTL1) & AUE_CTL1_RESETMAC))\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->aue_dev));\n\n\t/*\n\t * The PHY(s) attached to the Pegasus chip may be held\n\t * in reset until we flip on the GPIO outputs. Make sure\n\t * to set the GPIO pins high so that the PHY(s) will\n\t * be enabled.\n\t *\n\t * Note: We force all of the GPIO pins low first, *then*\n\t * enable the ones we want.\n  \t */\n\taue_csr_write_1(sc, AUE_GPIO0, \n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);\n  \taue_csr_write_1(sc, AUE_GPIO0,\n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n  \n\t/* Grrr. LinkSys has to be different from everyone else. */\n\tif ((sc->aue_vendor == USB_VENDOR_LINKSYS &&\n\t     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||\n\t    (sc->aue_vendor == USB_VENDOR_DLINK &&\n\t     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {\n\t\taue_csr_write_1(sc, AUE_GPIO0, \n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n\t\taue_csr_write_1(sc, AUE_GPIO0,\n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1 | AUE_GPIO_OUT0);\n\t}\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(10000);\t\t/* XXX */\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_MII",
          "args": [
            "sc"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\naue_read_mac\t__P((struct aue_softc *, u_char *));\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct aue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\tint\t\t\ti, s;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\taue_reset(sc);\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\taue_csr_write_1(sc, AUE_PAR0 + i, eaddr[i]);\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\telse\n\t\tAUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);\n\n\t/* Init TX ring. */\n\tif (aue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (aue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->aue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\taue_setmulti(sc);\n\n\t/* Enable RX and TX */\n\taue_csr_write_1(sc, AUE_CTL0, AUE_CTL0_RXSTAT_APPEND | AUE_CTL0_RX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_TX_ENB);\n\tAUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_EP3_CLR);\n\n\tmii_mediachg(mii);\n\n\tif (sc->aue_ep[AUE_ENDPT_RX] == NULL) {\n\t\tif (aue_openpipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\tusb_callout(sc->aue_stat_ch, hz, aue_tick, sc);\n}"
  },
  {
    "function_name": "aue_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1464-1508",
    "snippet": "Static void\naue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(5,(\"%s: %s: enter, link=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, sc->aue_link));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!sc->aue_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (aue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m_head"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_send",
          "args": [
            "sc",
            "m_head",
            "0"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "aue_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1413-1462",
          "snippet": "Static int\naue_send(sc, m, idx)\n\tstruct aue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct aue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tc = &sc->aue_cdata.aue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->aue_buf + 2);\n\tc->aue_mbuf = m;\n\n\t/*\n\t * The ADMtek documentation says that the packet length is\n\t * supposed to be specified in the first two bytes of the\n\t * transfer, however it actually seems to ignore this info\n\t * and base the frame size on the bulk transfer length.\n\t */\n\tc->aue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->aue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\ttotal_len = m->m_pkthdr.len + 2;\n\n\tusbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_TX],\n\t    c, c->aue_buf, total_len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,\n\t    AUE_TX_TIMEOUT, aue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->aue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: aue_send error=%s\\n\", USBDEVNAME(sc->aue_dev),\n\t\t       usbd_errstr(err));\n\t\taue_stop(sc);\n\t\treturn (EIO);\n\t}\n\tDPRINTFN(5,(\"%s: %s: send %d bytes\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, total_len));\n\n\tsc->aue_cdata.aue_tx_cnt++;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));",
            "int\t\t\tphy, reg, data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\nint\t\t\tphy, reg, data;\n\nStatic int\naue_send(sc, m, idx)\n\tstruct aue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct aue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tc = &sc->aue_cdata.aue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->aue_buf + 2);\n\tc->aue_mbuf = m;\n\n\t/*\n\t * The ADMtek documentation says that the packet length is\n\t * supposed to be specified in the first two bytes of the\n\t * transfer, however it actually seems to ignore this info\n\t * and base the frame size on the bulk transfer length.\n\t */\n\tc->aue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->aue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\ttotal_len = m->m_pkthdr.len + 2;\n\n\tusbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_TX],\n\t    c, c->aue_buf, total_len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,\n\t    AUE_TX_TIMEOUT, aue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->aue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: aue_send error=%s\\n\", USBDEVNAME(sc->aue_dev),\n\t\t       usbd_errstr(err));\n\t\taue_stop(sc);\n\t\treturn (EIO);\n\t}\n\tDPRINTFN(5,(\"%s: %s: send %d bytes\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, total_len));\n\n\tsc->aue_cdata.aue_tx_cnt++;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter, link=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, sc->aue_link)"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(5,(\"%s: %s: enter, link=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, sc->aue_link));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!sc->aue_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (aue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
  },
  {
    "function_name": "aue_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1413-1462",
    "snippet": "Static int\naue_send(sc, m, idx)\n\tstruct aue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct aue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tc = &sc->aue_cdata.aue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->aue_buf + 2);\n\tc->aue_mbuf = m;\n\n\t/*\n\t * The ADMtek documentation says that the packet length is\n\t * supposed to be specified in the first two bytes of the\n\t * transfer, however it actually seems to ignore this info\n\t * and base the frame size on the bulk transfer length.\n\t */\n\tc->aue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->aue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\ttotal_len = m->m_pkthdr.len + 2;\n\n\tusbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_TX],\n\t    c, c->aue_buf, total_len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,\n\t    AUE_TX_TIMEOUT, aue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->aue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: aue_send error=%s\\n\", USBDEVNAME(sc->aue_dev),\n\t\t       usbd_errstr(err));\n\t\taue_stop(sc);\n\t\treturn (EIO);\n\t}\n\tDPRINTFN(5,(\"%s: %s: send %d bytes\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, total_len));\n\n\tsc->aue_cdata.aue_tx_cnt++;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
      "Static void",
      "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));",
      "int\t\t\tphy, reg, data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: send %d bytes\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, total_len)"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_stop",
          "args": [
            "sc"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "aue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1817-1905",
          "snippet": "Static void\naue_stop(sc)\n\tstruct aue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\taue_csr_write_1(sc, AUE_CTL0, 0);\n\taue_csr_write_1(sc, AUE_CTL1, 0);\n\taue_reset(sc);\n\tusb_uncallout(sc->aue_stat_ch, aue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->aue_ep[AUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\tsc->aue_link = 0;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_stop(sc)\n\tstruct aue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\taue_csr_write_1(sc, AUE_CTL0, 0);\n\taue_csr_write_1(sc, AUE_CTL1, 0);\n\taue_reset(sc);\n\tusb_uncallout(sc->aue_stat_ch, aue_tick, sc);\n\n\t/* Stop transfers. */\n\tif (sc->aue_ep[AUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->aue_ep[AUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {\n\t\t\tm_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;\n\t\t}\n\t\tif (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);\n\t\t\tsc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;\n\t\t}\n\t}\n\n\tsc->aue_link = 0;\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: aue_send error=%s\\n\"",
            "USBDEVNAME(sc->aue_dev)",
            "usbd_errstr(err)"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->aue_xfer"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->aue_xfer",
            "sc->aue_ep[AUE_ENDPT_TX]",
            "c",
            "c->aue_buf",
            "total_len",
            "USBD_FORCE_SHORT_XFER | USBD_NO_COPY",
            "AUE_TX_TIMEOUT",
            "aue_txeof"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m->m_pkthdr.len >> 8"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m",
            "0",
            "m->m_pkthdr.len",
            "c->aue_buf + 2"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__)"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\nint\t\t\tphy, reg, data;\n\nStatic int\naue_send(sc, m, idx)\n\tstruct aue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct aue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tc = &sc->aue_cdata.aue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->aue_buf + 2);\n\tc->aue_mbuf = m;\n\n\t/*\n\t * The ADMtek documentation says that the packet length is\n\t * supposed to be specified in the first two bytes of the\n\t * transfer, however it actually seems to ignore this info\n\t * and base the frame size on the bulk transfer length.\n\t */\n\tc->aue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->aue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\ttotal_len = m->m_pkthdr.len + 2;\n\n\tusbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_TX],\n\t    c, c->aue_buf, total_len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,\n\t    AUE_TX_TIMEOUT, aue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->aue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: aue_send error=%s\\n\", USBDEVNAME(sc->aue_dev),\n\t\t       usbd_errstr(err));\n\t\taue_stop(sc);\n\t\treturn (EIO);\n\t}\n\tDPRINTFN(5,(\"%s: %s: send %d bytes\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, total_len));\n\n\tsc->aue_cdata.aue_tx_cnt++;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "aue_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1371-1411",
    "snippet": "Static void\naue_tick(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct aue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\tDPRINTFN(15,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (sc == NULL)\n\t\treturn;\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tifp = GET_IFP(sc);\n\tmii = GET_MII(sc);\n\tif (mii == NULL)\n\t\treturn;\n\n\ts = splimp();\n\n\tmii_tick(mii);\n\tif (!sc->aue_link) {\n\t\tmii_pollstat(mii);\n\t\tif (mii->mii_media_status & IFM_ACTIVE &&\n\t\t    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {\n\t\t\tDPRINTFN(2,(\"%s: %s: got link\\n\",\n\t\t\t\t    USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\t\t\tsc->aue_link++;\n\t\t\tif (ifp->if_snd.ifq_head != NULL)\n\t\t\t\taue_start(ifp);\n\t\t}\n\t}\n\n\tusb_callout(sc->aue_stat_ch, hz, aue_tick, sc);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_callout",
          "args": [
            "sc->aue_stat_ch",
            "hz",
            "aue_tick",
            "sc"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_start",
          "args": [
            "ifp"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "aue_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1464-1508",
          "snippet": "Static void\naue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(5,(\"%s: %s: enter, link=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, sc->aue_link));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!sc->aue_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (aue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(5,(\"%s: %s: enter, link=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, sc->aue_link));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!sc->aue_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (aue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"%s: %s: got link\\n\",\n\t\t\t\t    USBDEVNAME(sc->aue_dev),__FUNCTION__)"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "mii->mii_media_active"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "mii"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_tick",
          "args": [
            "mii"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "mii_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "192-201",
          "snippet": "void\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_MII",
          "args": [
            "sc"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "15",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__)"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_tick(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct aue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp;\n\tstruct mii_data\t\t*mii;\n\tint\t\t\ts;\n\n\tDPRINTFN(15,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (sc == NULL)\n\t\treturn;\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tifp = GET_IFP(sc);\n\tmii = GET_MII(sc);\n\tif (mii == NULL)\n\t\treturn;\n\n\ts = splimp();\n\n\tmii_tick(mii);\n\tif (!sc->aue_link) {\n\t\tmii_pollstat(mii);\n\t\tif (mii->mii_media_status & IFM_ACTIVE &&\n\t\t    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {\n\t\t\tDPRINTFN(2,(\"%s: %s: got link\\n\",\n\t\t\t\t    USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\t\t\tsc->aue_link++;\n\t\t\tif (ifp->if_snd.ifq_head != NULL)\n\t\t\t\taue_start(ifp);\n\t\t}\n\t}\n\n\tusb_callout(sc->aue_stat_ch, hz, aue_tick, sc);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "aue_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1318-1369",
    "snippet": "Static void\naue_txeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct aue_chain\t*c = priv;\n\tstruct aue_softc\t*sc = c->aue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\ts = splimp();\n\n\tDPRINTFN(10,(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, status));\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t\tifp->if_oerrors++;\n\t\tprintf(\"%s: usb error on tx: %s\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    usbd_errstr(status));\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tifp->if_opackets++;\n\n#if defined(__FreeBSD__)\n\tc->aue_mbuf->m_pkthdr.rcvif = ifp;\n\tusb_tx_done(c->aue_mbuf);\n  \tc->aue_mbuf = NULL;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm_freem(c->aue_mbuf);\n\tc->aue_mbuf = NULL;\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\taue_start(ifp);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_start",
          "args": [
            "ifp"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "aue_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1464-1508",
          "snippet": "Static void\naue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(5,(\"%s: %s: enter, link=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, sc->aue_link));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!sc->aue_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (aue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "aue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "aue_watchdog\t__P((struct ifnet *));",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "aue_ifmedia_upd\t__P((struct ifnet *));",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(5,(\"%s: %s: enter, link=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, sc->aue_link));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!sc->aue_link)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (aue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "c->aue_mbuf"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_tx_done",
          "args": [
            "c->aue_mbuf"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall",
          "args": [
            "sc->aue_ep[AUE_ENDPT_TX]"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: usb error on tx: %s\\n\"",
            "USBDEVNAME(sc->aue_dev)",
            "usbd_errstr(status)"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "status"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, status)"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_txeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct aue_chain\t*c = priv;\n\tstruct aue_softc\t*sc = c->aue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\ts = splimp();\n\n\tDPRINTFN(10,(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, status));\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t\tifp->if_oerrors++;\n\t\tprintf(\"%s: usb error on tx: %s\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    usbd_errstr(status));\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->aue_ep[AUE_ENDPT_TX]);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tifp->if_opackets++;\n\n#if defined(__FreeBSD__)\n\tc->aue_mbuf->m_pkthdr.rcvif = ifp;\n\tusb_tx_done(c->aue_mbuf);\n  \tc->aue_mbuf = NULL;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm_freem(c->aue_mbuf);\n\tc->aue_mbuf = NULL;\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\taue_start(ifp);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "aue_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1188-1311",
    "snippet": "Static void\naue_rxeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct aue_chain\t*c = priv;\n\tstruct aue_softc\t*sc = c->aue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mbuf\t\t*m;\n\tu_int32_t\t\ttotal_len;\n\tstruct aue_rxpkt\tr;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tint\t\t\ts;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED)\n\t\t\treturn;\n\t\tsc->aue_rx_errs++;\n\t\tif (usbd_ratecheck(&sc->aue_rx_notice)) {\n\t\t\tprintf(\"%s: %u usb errors on rx: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), sc->aue_rx_errs,\n\t\t\t    usbd_errstr(status));\n\t\t\tsc->aue_rx_errs = 0;\n\t\t}\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tgoto done;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);\n\n\tmemcpy(mtod(c->aue_mbuf, char*), c->aue_buf, total_len);\n\n\tif (total_len <= 4 + ETHER_CRC_LEN) {\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\n\tmemcpy(&r, c->aue_buf + total_len - 4, sizeof(r));\n\n\t/* Turn off all the non-error bits in the rx status word. */\n\tr.aue_rxstat &= AUE_RXSTAT_MASK;\n\tif (r.aue_rxstat) {\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\n\t/* No errors; receive the packet. */\n\tm = c->aue_mbuf;\n\ttotal_len -= ETHER_CRC_LEN + 4;\n\tm->m_pkthdr.len = m->m_len = total_len;\n\tifp->if_ipackets++;\n\n#if defined(__FreeBSD__)\n\tm->m_pkthdr.rcvif = (struct ifnet *)&kue_qdat;\n\t/* Put the packet on the special USB input queue. */\n\tusb_ether_input(m);\n\n\treturn;\n\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm->m_pkthdr.rcvif = ifp;\n\n\ts = splimp();\n\n\t/* XXX ugly */\n\tif (aue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\tgoto done1;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * Handle BPF listeners. Let the BPF user see the packet, but\n\t * don't pass it up to the ether_input() layer unless it's\n\t * a broadcast packet, multicast packet, matches our ethernet\n\t * address or the interface is in promiscuous mode.\n\t */\n\tif (ifp->if_bpf) {\n#if defined(__NetBSD__)\n\t\tstruct ether_header *eh = mtod(m, struct ether_header *);\n\t\tBPF_MTAP(ifp, m);\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),\n\t\t\t   ETHER_ADDR_LEN) &&\n\t\t    !(eh->ether_dhost[0] & 1)) {\n\t\t\tm_freem(m);\n\t\t\tgoto done1;\n\t\t}\n#else\n\t\tBPF_MTAP(ifp, m);\n#endif\n\t}\n#endif\n\n\tDPRINTFN(10,(\"%s: %s: deliver %d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, m->m_len));\n\tIF_INPUT(ifp, m);\n done1:\n\tsplx(s);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n done:\n\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(xfer, sc->aue_ep[AUE_ENDPT_RX],\n\t    c, c->aue_buf, AUE_BUFSZ,\n\t    USBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t    USBD_NO_TIMEOUT, aue_rxeof);\n\tusbd_transfer(xfer);\n\n\tDPRINTFN(10,(\"%s: %s: start rx\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__));\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
      "Static void",
      "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static u_int32_t",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: start rx\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__)"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "xfer"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "xfer",
            "sc->aue_ep[AUE_ENDPT_RX]",
            "c",
            "c->aue_buf",
            "AUE_BUFSZ",
            "USBD_SHORT_XFER_OK | USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "aue_rxeof"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_INPUT",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: deliver %d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, m->m_len)"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "eh->ether_dhost",
            "LLADDR(ifp->if_sadl)",
            "ETHER_ADDR_LEN"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_newbuf",
          "args": [
            "sc",
            "c",
            "NULL"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "aue_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1022-1058",
          "snippet": "Static int\naue_newbuf(sc, c, m)\n\tstruct aue_softc\t*sc;\n\tstruct aue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->aue_mbuf = m_new;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_newbuf(sc, c, m)\n\tstruct aue_softc\t*sc;\n\tstruct aue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->aue_mbuf = m_new;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_ether_input",
          "args": [
            "m"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&r",
            "c->aue_buf + total_len - 4",
            "sizeof(r)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mtod(c->aue_mbuf, char*)",
            "c->aue_buf",
            "total_len"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "c->aue_mbuf",
            "char*"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "NULL",
            "&total_len",
            "NULL"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall",
          "args": [
            "sc->aue_ep[AUE_ENDPT_RX]"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %u usb errors on rx: %s\\n\"",
            "USBDEVNAME(sc->aue_dev)",
            "sc->aue_rx_errs",
            "usbd_errstr(status)"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "status"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_ratecheck",
          "args": [
            "&sc->aue_rx_notice"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_ratecheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1134-1141",
          "snippet": "int\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__)"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic u_int32_t;\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_rxeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct aue_chain\t*c = priv;\n\tstruct aue_softc\t*sc = c->aue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mbuf\t\t*m;\n\tu_int32_t\t\ttotal_len;\n\tstruct aue_rxpkt\tr;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tint\t\t\ts;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED)\n\t\t\treturn;\n\t\tsc->aue_rx_errs++;\n\t\tif (usbd_ratecheck(&sc->aue_rx_notice)) {\n\t\t\tprintf(\"%s: %u usb errors on rx: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), sc->aue_rx_errs,\n\t\t\t    usbd_errstr(status));\n\t\t\tsc->aue_rx_errs = 0;\n\t\t}\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->aue_ep[AUE_ENDPT_RX]);\n\t\tgoto done;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);\n\n\tmemcpy(mtod(c->aue_mbuf, char*), c->aue_buf, total_len);\n\n\tif (total_len <= 4 + ETHER_CRC_LEN) {\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\n\tmemcpy(&r, c->aue_buf + total_len - 4, sizeof(r));\n\n\t/* Turn off all the non-error bits in the rx status word. */\n\tr.aue_rxstat &= AUE_RXSTAT_MASK;\n\tif (r.aue_rxstat) {\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\n\t/* No errors; receive the packet. */\n\tm = c->aue_mbuf;\n\ttotal_len -= ETHER_CRC_LEN + 4;\n\tm->m_pkthdr.len = m->m_len = total_len;\n\tifp->if_ipackets++;\n\n#if defined(__FreeBSD__)\n\tm->m_pkthdr.rcvif = (struct ifnet *)&kue_qdat;\n\t/* Put the packet on the special USB input queue. */\n\tusb_ether_input(m);\n\n\treturn;\n\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm->m_pkthdr.rcvif = ifp;\n\n\ts = splimp();\n\n\t/* XXX ugly */\n\tif (aue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\tgoto done1;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * Handle BPF listeners. Let the BPF user see the packet, but\n\t * don't pass it up to the ether_input() layer unless it's\n\t * a broadcast packet, multicast packet, matches our ethernet\n\t * address or the interface is in promiscuous mode.\n\t */\n\tif (ifp->if_bpf) {\n#if defined(__NetBSD__)\n\t\tstruct ether_header *eh = mtod(m, struct ether_header *);\n\t\tBPF_MTAP(ifp, m);\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),\n\t\t\t   ETHER_ADDR_LEN) &&\n\t\t    !(eh->ether_dhost[0] & 1)) {\n\t\t\tm_freem(m);\n\t\t\tgoto done1;\n\t\t}\n#else\n\t\tBPF_MTAP(ifp, m);\n#endif\n\t}\n#endif\n\n\tDPRINTFN(10,(\"%s: %s: deliver %d\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__, m->m_len));\n\tIF_INPUT(ifp, m);\n done1:\n\tsplx(s);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n done:\n\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(xfer, sc->aue_ep[AUE_ENDPT_RX],\n\t    c, c->aue_buf, AUE_BUFSZ,\n\t    USBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t    USBD_NO_TIMEOUT, aue_rxeof);\n\tusbd_transfer(xfer);\n\n\tDPRINTFN(10,(\"%s: %s: start rx\\n\", USBDEVNAME(sc->aue_dev),\n\t\t    __FUNCTION__));\n}"
  },
  {
    "function_name": "aue_rxstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1161-1181",
    "snippet": "Static void\naue_rxstart(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc;\n\tstruct aue_chain\t*c;\n\n\tsc = ifp->if_softc;\n\tc = &sc->aue_cdata.aue_rx_chain[sc->aue_cdata.aue_rx_prod];\n\n\tif (aue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_RX],\n\t    c, mtod(c->aue_mbuf, char *), AUE_BUFSZ, USBD_SHORT_XFER_OK,\n\t    USBD_NO_TIMEOUT, aue_rxeof);\n\tusbd_transfer(c->aue_xfer);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->aue_xfer"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->aue_xfer",
            "sc->aue_ep[AUE_ENDPT_RX]",
            "c",
            "mtod(c->aue_mbuf, char *)",
            "AUE_BUFSZ",
            "USBD_SHORT_XFER_OK",
            "USBD_NO_TIMEOUT",
            "aue_rxeof"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "c->aue_mbuf",
            "char*"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_newbuf",
          "args": [
            "sc",
            "c",
            "NULL"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "aue_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1022-1058",
          "snippet": "Static int\naue_newbuf(sc, c, m)\n\tstruct aue_softc\t*sc;\n\tstruct aue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->aue_mbuf = m_new;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_newbuf(sc, c, m)\n\tstruct aue_softc\t*sc;\n\tstruct aue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->aue_mbuf = m_new;\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_rxstart(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct aue_softc\t*sc;\n\tstruct aue_chain\t*c;\n\n\tsc = ifp->if_softc;\n\tc = &sc->aue_cdata.aue_rx_chain[sc->aue_cdata.aue_rx_prod];\n\n\tif (aue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_RX],\n\t    c, mtod(c->aue_mbuf, char *), AUE_BUFSZ, USBD_SHORT_XFER_OK,\n\t    USBD_NO_TIMEOUT, aue_rxeof);\n\tusbd_transfer(c->aue_xfer);\n}"
  },
  {
    "function_name": "aue_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1119-1158",
    "snippet": "Static void\naue_intr(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct aue_softc\t*sc = priv;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct aue_intrpkt\t*p = &sc->aue_cdata.aue_ibuf;\n\n\tDPRINTFN(15,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {\n\t\t\treturn;\n\t\t}\n\t\tsc->aue_intr_errs++;\n\t\tif (usbd_ratecheck(&sc->aue_rx_notice)) {\n\t\t\tprintf(\"%s: %u usb errors on intr: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), sc->aue_rx_errs,\n\t\t\t    usbd_errstr(status));\n\t\t\tsc->aue_intr_errs = 0;\n\t\t}\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->aue_ep[AUE_ENDPT_RX]);\n\t\treturn;\n\t}\n\n\tif (p->aue_txstat0)\n\t\tifp->if_oerrors++;\n\n\tif (p->aue_txstat0 & (AUE_TXSTAT0_LATECOLL | AUE_TXSTAT0_EXCESSCOLL))\n\t\tifp->if_collisions++;\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall",
          "args": [
            "sc->aue_ep[AUE_ENDPT_RX]"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %u usb errors on intr: %s\\n\"",
            "USBDEVNAME(sc->aue_dev)",
            "sc->aue_rx_errs",
            "usbd_errstr(status)"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "status"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_ratecheck",
          "args": [
            "&sc->aue_rx_notice"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_ratecheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1134-1141",
          "snippet": "int\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "15",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_intr(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct aue_softc\t*sc = priv;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct aue_intrpkt\t*p = &sc->aue_cdata.aue_ibuf;\n\n\tDPRINTFN(15,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (sc->aue_dying)\n\t\treturn;\n\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {\n\t\t\treturn;\n\t\t}\n\t\tsc->aue_intr_errs++;\n\t\tif (usbd_ratecheck(&sc->aue_rx_notice)) {\n\t\t\tprintf(\"%s: %u usb errors on intr: %s\\n\",\n\t\t\t    USBDEVNAME(sc->aue_dev), sc->aue_rx_errs,\n\t\t\t    usbd_errstr(status));\n\t\t\tsc->aue_intr_errs = 0;\n\t\t}\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->aue_ep[AUE_ENDPT_RX]);\n\t\treturn;\n\t}\n\n\tif (p->aue_txstat0)\n\t\tifp->if_oerrors++;\n\n\tif (p->aue_txstat0 & (AUE_TXSTAT0_LATECOLL | AUE_TXSTAT0_EXCESSCOLL))\n\t\tifp->if_collisions++;\n}"
  },
  {
    "function_name": "aue_tx_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1090-1117",
    "snippet": "Static int\naue_tx_list_init(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_cdata\t*cd;\n\tstruct aue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tcd = &sc->aue_cdata;\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->aue_tx_chain[i];\n\t\tc->aue_sc = sc;\n\t\tc->aue_idx = i;\n\t\tc->aue_mbuf = NULL;\n\t\tif (c->aue_xfer == NULL) {\n\t\t\tc->aue_xfer = usbd_alloc_xfer(sc->aue_udev);\n\t\t\tif (c->aue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->aue_buf = usbd_alloc_buffer(c->aue_xfer, AUE_BUFSZ);\n\t\t\tif (c->aue_buf == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t}\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_alloc_buffer",
          "args": [
            "c->aue_xfer",
            "AUE_BUFSZ"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->aue_udev"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_tx_list_init(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_cdata\t*cd;\n\tstruct aue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tcd = &sc->aue_cdata;\n\tfor (i = 0; i < AUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->aue_tx_chain[i];\n\t\tc->aue_sc = sc;\n\t\tc->aue_idx = i;\n\t\tc->aue_mbuf = NULL;\n\t\tif (c->aue_xfer == NULL) {\n\t\t\tc->aue_xfer = usbd_alloc_xfer(sc->aue_udev);\n\t\t\tif (c->aue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->aue_buf = usbd_alloc_buffer(c->aue_xfer, AUE_BUFSZ);\n\t\t\tif (c->aue_buf == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t}\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "aue_rx_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1060-1088",
    "snippet": "Static int \naue_rx_list_init(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_cdata\t*cd;\n\tstruct aue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tcd = &sc->aue_cdata;\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->aue_rx_chain[i];\n\t\tc->aue_sc = sc;\n\t\tc->aue_idx = i;\n\t\tif (aue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->aue_xfer == NULL) {\n\t\t\tc->aue_xfer = usbd_alloc_xfer(sc->aue_udev);\n\t\t\tif (c->aue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->aue_buf = usbd_alloc_buffer(c->aue_xfer, AUE_BUFSZ);\n\t\t\tif (c->aue_buf == NULL)\n\t\t\t\treturn (ENOBUFS); /* XXX free xfer */\n\t\t}\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_alloc_buffer",
          "args": [
            "c->aue_xfer",
            "AUE_BUFSZ"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->aue_udev"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_newbuf",
          "args": [
            "sc",
            "c",
            "NULL"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "aue_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "1022-1058",
          "snippet": "Static int\naue_newbuf(sc, c, m)\n\tstruct aue_softc\t*sc;\n\tstruct aue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->aue_mbuf = m_new;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_newbuf(sc, c, m)\n\tstruct aue_softc\t*sc;\n\tstruct aue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->aue_mbuf = m_new;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int \naue_rx_list_init(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct aue_cdata\t*cd;\n\tstruct aue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tcd = &sc->aue_cdata;\n\tfor (i = 0; i < AUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->aue_rx_chain[i];\n\t\tc->aue_sc = sc;\n\t\tc->aue_idx = i;\n\t\tif (aue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->aue_xfer == NULL) {\n\t\t\tc->aue_xfer = usbd_alloc_xfer(sc->aue_udev);\n\t\t\tif (c->aue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->aue_buf = usbd_alloc_buffer(c->aue_xfer, AUE_BUFSZ);\n\t\t\tif (c->aue_buf == NULL)\n\t\t\t\treturn (ENOBUFS); /* XXX free xfer */\n\t\t}\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "aue_newbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "1022-1058",
    "snippet": "Static int\naue_newbuf(sc, c, m)\n\tstruct aue_softc\t*sc;\n\tstruct aue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->aue_mbuf = m_new;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "aue_send\t\t__P((struct aue_softc *, struct mbuf *, int));",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m_new",
            "ETHER_ALIGN"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\"",
            "USBDEVNAME(sc->aue_dev)"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__)"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_newbuf\t\t__P((struct aue_softc *, struct aue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\naue_send\t\t__P((struct aue_softc *, struct mbuf *, int));\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_newbuf(sc, c, m)\n\tstruct aue_softc\t*sc;\n\tstruct aue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->aue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tm_adj(m_new, ETHER_ALIGN);\n\tc->aue_mbuf = m_new;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "aue_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "996-1016",
    "snippet": "int\naue_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct aue_softc *sc = (struct aue_softc *)self;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif_deactivate(&sc->aue_ec.ec_if);\n\t\tsc->aue_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "aue_stop\t\t__P((struct aue_softc *));",
      "aue_openpipes\t__P((struct aue_softc *));",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "aue_miibus_readreg\t__P((device_ptr_t, int, int));",
      "aue_miibus_statchg\t__P((device_ptr_t));",
      "aue_setmulti\t__P((struct aue_softc *));",
      "aue_reset\t\t__P((struct aue_softc *));",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "if_deactivate",
          "args": [
            "&sc->aue_ec.ec_if"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\naue_tx_list_init\t__P((struct aue_softc *));\naue_rx_list_init\t__P((struct aue_softc *));\naue_stop\t\t__P((struct aue_softc *));\naue_openpipes\t__P((struct aue_softc *));\naue_eeprom_getword\t__P((struct aue_softc *, int));\naue_miibus_readreg\t__P((device_ptr_t, int, int));\naue_miibus_statchg\t__P((device_ptr_t));\naue_setmulti\t__P((struct aue_softc *));\naue_reset\t\t__P((struct aue_softc *));\naue_csr_read_1\t__P((struct aue_softc *, int));\naue_csr_write_1\t__P((struct aue_softc *, int, int));\naue_csr_read_2\t__P((struct aue_softc *, int));\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nint\naue_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct aue_softc *sc = (struct aue_softc *)self;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tif_deactivate(&sc->aue_ec.ec_if);\n\t\tsc->aue_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "aue_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "676-721",
    "snippet": "Static void\naue_reset(sc)\n\tstruct aue_softc\t*sc;\n{\n\tint\t\ti;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_RESETMAC);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (!(aue_csr_read_1(sc, AUE_CTL1) & AUE_CTL1_RESETMAC))\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->aue_dev));\n\n\t/*\n\t * The PHY(s) attached to the Pegasus chip may be held\n\t * in reset until we flip on the GPIO outputs. Make sure\n\t * to set the GPIO pins high so that the PHY(s) will\n\t * be enabled.\n\t *\n\t * Note: We force all of the GPIO pins low first, *then*\n\t * enable the ones we want.\n  \t */\n\taue_csr_write_1(sc, AUE_GPIO0, \n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);\n  \taue_csr_write_1(sc, AUE_GPIO0,\n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n  \n\t/* Grrr. LinkSys has to be different from everyone else. */\n\tif ((sc->aue_vendor == USB_VENDOR_LINKSYS &&\n\t     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||\n\t    (sc->aue_vendor == USB_VENDOR_DLINK &&\n\t     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {\n\t\taue_csr_write_1(sc, AUE_GPIO0, \n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n\t\taue_csr_write_1(sc, AUE_GPIO0,\n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1 | AUE_GPIO_OUT0);\n\t}\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(10000);\t\t/* XXX */\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10000"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_csr_write_1",
          "args": [
            "sc",
            "AUE_GPIO0",
            "AUE_GPIO_SEL0 | AUE_GPIO_SEL1 | AUE_GPIO_OUT0"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "355-386",
          "snippet": "Static int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reset failed\\n\"",
            "USBDEVNAME(sc->aue_dev)"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_csr_read_1",
          "args": [
            "sc",
            "AUE_CTL1"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_read_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "291-321",
          "snippet": "Static int\naue_csr_read_1(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuByte\t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_read_1(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuByte\t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_CTL1",
            "AUE_CTL1_RESETMAC"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_reset(sc)\n\tstruct aue_softc\t*sc;\n{\n\tint\t\ti;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_RESETMAC);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (!(aue_csr_read_1(sc, AUE_CTL1) & AUE_CTL1_RESETMAC))\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->aue_dev));\n\n\t/*\n\t * The PHY(s) attached to the Pegasus chip may be held\n\t * in reset until we flip on the GPIO outputs. Make sure\n\t * to set the GPIO pins high so that the PHY(s) will\n\t * be enabled.\n\t *\n\t * Note: We force all of the GPIO pins low first, *then*\n\t * enable the ones we want.\n  \t */\n\taue_csr_write_1(sc, AUE_GPIO0, \n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);\n  \taue_csr_write_1(sc, AUE_GPIO0,\n\t    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n  \n\t/* Grrr. LinkSys has to be different from everyone else. */\n\tif ((sc->aue_vendor == USB_VENDOR_LINKSYS &&\n\t     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||\n\t    (sc->aue_vendor == USB_VENDOR_DLINK &&\n\t     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {\n\t\taue_csr_write_1(sc, AUE_GPIO0, \n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1);\n\t\taue_csr_write_1(sc, AUE_GPIO0,\n\t\t    AUE_GPIO_SEL0 | AUE_GPIO_SEL1 | AUE_GPIO_OUT0);\n\t}\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tdelay(10000);\t\t/* XXX */\n}"
  },
  {
    "function_name": "aue_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "617-674",
    "snippet": "Static void\naue_setmulti(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th = 0, i;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\treturn;\n\t}\n\n\tAUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < 8; i++)\n\t\taue_csr_write_1(sc, AUE_MAR0 + i, 0);\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = aue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->aue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 1\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = aue_crc(enm->enm_addrlo);\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "aue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "aue_watchdog\t__P((struct ifnet *));",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "aue_ifmedia_upd\t__P((struct ifnet *));",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static u_int32_t",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_MAR + (h >> 3)",
            "1 << (h & 0xF)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_crc",
          "args": [
            "enm->enm_addrlo"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "aue_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "600-615",
          "snippet": "Static u_int32_t \naue_crc(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? AUE_POLY : 0);\n\t}\n\n\treturn (crc & ((1 << AUE_BITS) - 1));\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [
            "#define AUE_BITS\t6",
            "#define AUE_POLY\t0xEDB88320"
          ],
          "globals_used": [
            "Static int",
            "Static int",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "aue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static int",
            "Static void",
            "Static int",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static u_int32_t",
            "aue_crc\t__P((caddr_t));",
            "Static void",
            "Static int",
            "Static int",
            "Static int",
            "Static int",
            "int\t\t\tphy, reg, data;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\n#define AUE_BITS\t6\n#define AUE_POLY\t0xEDB88320\n\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\naue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic int;\nStatic void;\nStatic int;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic u_int32_t;\naue_crc\t__P((caddr_t));\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nint\t\t\tphy, reg, data;\n\nStatic u_int32_t \naue_crc(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? AUE_POLY : 0);\n\t}\n\n\treturn (crc & ((1 << AUE_BITS) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_CTL0",
            "AUE_CTL0_ALLMULTI"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "ETHER_ADDR_LEN"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->arpcom",
            "enm"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->aue_ec",
            "enm"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_MAR + (h >> 3)",
            "1 << (h & 0xF)"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "(struct sockaddr_dl *)ifma->ifma_addr"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_csr_write_1",
          "args": [
            "sc",
            "AUE_MAR0 + i",
            "0"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "355-386",
          "snippet": "Static int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUE_CLRBIT",
          "args": [
            "sc",
            "AUE_CTL0",
            "AUE_CTL0_ALLMULTI"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_CTL0",
            "AUE_CTL0_ALLMULTI"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\naue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\naue_watchdog\t__P((struct ifnet *));\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\naue_ifmedia_upd\t__P((struct ifnet *));\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic u_int32_t;\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_setmulti(sc)\n\tstruct aue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\tu_int32_t\t\th = 0, i;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\treturn;\n\t}\n\n\tAUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < 8; i++)\n\t\taue_csr_write_1(sc, AUE_MAR0 + i, 0);\n\n\t/* now program new ones */\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\th = aue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined(__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->aue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n#if 1\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);\n\t\t\treturn;\n\t\t}\n#endif\n\t\th = aue_crc(enm->enm_addrlo);\n\t\tAUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n}"
  },
  {
    "function_name": "aue_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "600-615",
    "snippet": "Static u_int32_t \naue_crc(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? AUE_POLY : 0);\n\t}\n\n\treturn (crc & ((1 << AUE_BITS) - 1));\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [
      "#define AUE_BITS\t6",
      "#define AUE_POLY\t0xEDB88320"
    ],
    "globals_used": [
      "Static int",
      "Static int",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "aue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static int",
      "Static void",
      "Static int",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "Static u_int32_t",
      "aue_crc\t__P((caddr_t));",
      "Static void",
      "Static int",
      "Static int",
      "Static int",
      "Static int",
      "int\t\t\tphy, reg, data;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\n#define AUE_BITS\t6\n#define AUE_POLY\t0xEDB88320\n\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\naue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic int;\nStatic void;\nStatic int;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic u_int32_t;\naue_crc\t__P((caddr_t));\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nint\t\t\tphy, reg, data;\n\nStatic u_int32_t \naue_crc(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? AUE_POLY : 0);\n\t}\n\n\treturn (crc & ((1 << AUE_BITS) - 1));\n}"
  },
  {
    "function_name": "aue_miibus_statchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "558-595",
    "snippet": "Static void\naue_miibus_statchg(dev)\n\tdevice_ptr_t\t\tdev;\n{\n\tstruct aue_softc\t*sc = USBGETSOFTC(dev);\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tAUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_RX_ENB | AUE_CTL0_TX_ENB);\n\n\tif (IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX) {\n\t\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_SPEEDSEL);\n\t} else {\n\t\tAUE_CLRBIT(sc, AUE_CTL1, AUE_CTL1_SPEEDSEL);\n\t}\n\n\tif ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)\n\t\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_DUPLEX);\n\telse\n\t\tAUE_CLRBIT(sc, AUE_CTL1, AUE_CTL1_DUPLEX);\n\n\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_RX_ENB | AUE_CTL0_TX_ENB);\n\n\t/*\n\t * Set the LED modes on the LinkSys adapter.\n\t * This turns on the 'dual link LED' bin in the auxmode\n\t * register of the Broadcom PHY.\n\t */\n\tif ((sc->aue_vendor == USB_VENDOR_LINKSYS &&\n\t     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||\n\t    (sc->aue_vendor == USB_VENDOR_DLINK &&\n\t     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {\n\t\tu_int16_t               auxmode;\n\t\tauxmode = aue_miibus_readreg(dev, 0, 0x1b);\n\t\taue_miibus_writereg(dev, 0, 0x1b, auxmode | 0x04);\n\t}\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "aue_miibus_readreg\t__P((device_ptr_t, int, int));",
      "Static void",
      "aue_miibus_statchg\t__P((device_ptr_t));",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));",
      "device_ptr_t\t\tdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aue_miibus_writereg",
          "args": [
            "dev",
            "0",
            "0x1b",
            "auxmode | 0x04"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_miibus_readreg",
          "args": [
            "dev",
            "0",
            "0x1b"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "aue_miibus_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "468-512",
          "snippet": "Static int\naue_miibus_readreg(dev, phy, reg)\n\tdevice_ptr_t\t\tdev;\n\tint\t\t\tphy, reg;\n{\n\tstruct aue_softc\t*sc = USBGETSOFTC(dev);\n\tint\t\t\ti;\n\tu_int16_t\t\tval;\n\n\t/*\n\t * The Am79C901 HomePNA PHY actually contains\n\t * two transceivers: a 1Mbps HomePNA PHY and a\n\t * 10Mbps full/half duplex ethernet PHY with\n\t * NWAY autoneg. However in the ADMtek adapter,\n\t * only the 1Mbps PHY is actually connected to\n\t * anything, so we ignore the 10Mbps one. It\n\t * happens to be configured for MII address 3,\n\t * so we filter that out.\n\t */\n\tif (sc->aue_vendor == USB_VENDOR_ADMTEK &&\n\t    sc->aue_product == USB_PRODUCT_ADMTEK_PEGASUS) {\n\t\tif (phy != 1)\n\t\t\treturn (0);\n\t}\n\n\taue_csr_write_1(sc, AUE_PHY_ADDR, phy);\n\taue_csr_write_1(sc, AUE_PHY_CTL, reg | AUE_PHYCTL_READ);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (aue_csr_read_1(sc, AUE_PHY_CTL) & AUE_PHYCTL_DONE)\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT) {\n\t\tprintf(\"%s: MII read timed out\\n\",\n\t\t    USBDEVNAME(sc->aue_dev));\n\t}\n\n\tval = aue_csr_read_2(sc, AUE_PHY_DATA);\n\n\tDPRINTFN(11,(\"%s: %s: phy=%d reg=%d => 0x%04x\\n\",\n\t\t     USBDEVNAME(sc->aue_dev), __FUNCTION__, phy, reg, val));\n\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "aue_miibus_readreg\t__P((device_ptr_t, int, int));",
            "Static void",
            "aue_miibus_statchg\t__P((device_ptr_t));",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));",
            "device_ptr_t\t\tdev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\naue_miibus_readreg\t__P((device_ptr_t, int, int));\nStatic void;\naue_miibus_statchg\t__P((device_ptr_t));\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\ndevice_ptr_t\t\tdev;\n\nStatic int\naue_miibus_readreg(dev, phy, reg)\n\tdevice_ptr_t\t\tdev;\n\tint\t\t\tphy, reg;\n{\n\tstruct aue_softc\t*sc = USBGETSOFTC(dev);\n\tint\t\t\ti;\n\tu_int16_t\t\tval;\n\n\t/*\n\t * The Am79C901 HomePNA PHY actually contains\n\t * two transceivers: a 1Mbps HomePNA PHY and a\n\t * 10Mbps full/half duplex ethernet PHY with\n\t * NWAY autoneg. However in the ADMtek adapter,\n\t * only the 1Mbps PHY is actually connected to\n\t * anything, so we ignore the 10Mbps one. It\n\t * happens to be configured for MII address 3,\n\t * so we filter that out.\n\t */\n\tif (sc->aue_vendor == USB_VENDOR_ADMTEK &&\n\t    sc->aue_product == USB_PRODUCT_ADMTEK_PEGASUS) {\n\t\tif (phy != 1)\n\t\t\treturn (0);\n\t}\n\n\taue_csr_write_1(sc, AUE_PHY_ADDR, phy);\n\taue_csr_write_1(sc, AUE_PHY_CTL, reg | AUE_PHYCTL_READ);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (aue_csr_read_1(sc, AUE_PHY_CTL) & AUE_PHYCTL_DONE)\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT) {\n\t\tprintf(\"%s: MII read timed out\\n\",\n\t\t    USBDEVNAME(sc->aue_dev));\n\t}\n\n\tval = aue_csr_read_2(sc, AUE_PHY_DATA);\n\n\tDPRINTFN(11,(\"%s: %s: phy=%d reg=%d => 0x%04x\\n\",\n\t\t     USBDEVNAME(sc->aue_dev), __FUNCTION__, phy, reg, val));\n\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_CTL0",
            "AUE_CTL0_RX_ENB | AUE_CTL0_TX_ENB"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_CLRBIT",
          "args": [
            "sc",
            "AUE_CTL1",
            "AUE_CTL1_DUPLEX"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_CTL1",
            "AUE_CTL1_DUPLEX"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_CLRBIT",
          "args": [
            "sc",
            "AUE_CTL1",
            "AUE_CTL1_SPEEDSEL"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_SETBIT",
          "args": [
            "sc",
            "AUE_CTL1",
            "AUE_CTL1_SPEEDSEL"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "mii->mii_media_active"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_CLRBIT",
          "args": [
            "sc",
            "AUE_CTL0",
            "AUE_CTL0_RX_ENB | AUE_CTL0_TX_ENB"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_MII",
          "args": [
            "sc"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBGETSOFTC",
          "args": [
            "dev"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\naue_miibus_readreg\t__P((device_ptr_t, int, int));\nStatic void;\naue_miibus_statchg\t__P((device_ptr_t));\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\ndevice_ptr_t\t\tdev;\n\nStatic void\naue_miibus_statchg(dev)\n\tdevice_ptr_t\t\tdev;\n{\n\tstruct aue_softc\t*sc = USBGETSOFTC(dev);\n\tstruct mii_data\t\t*mii = GET_MII(sc);\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tAUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_RX_ENB | AUE_CTL0_TX_ENB);\n\n\tif (IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX) {\n\t\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_SPEEDSEL);\n\t} else {\n\t\tAUE_CLRBIT(sc, AUE_CTL1, AUE_CTL1_SPEEDSEL);\n\t}\n\n\tif ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)\n\t\tAUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_DUPLEX);\n\telse\n\t\tAUE_CLRBIT(sc, AUE_CTL1, AUE_CTL1_DUPLEX);\n\n\tAUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_RX_ENB | AUE_CTL0_TX_ENB);\n\n\t/*\n\t * Set the LED modes on the LinkSys adapter.\n\t * This turns on the 'dual link LED' bin in the auxmode\n\t * register of the Broadcom PHY.\n\t */\n\tif ((sc->aue_vendor == USB_VENDOR_LINKSYS &&\n\t     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||\n\t    (sc->aue_vendor == USB_VENDOR_DLINK &&\n\t     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {\n\t\tu_int16_t               auxmode;\n\t\tauxmode = aue_miibus_readreg(dev, 0, 0x1b);\n\t\taue_miibus_writereg(dev, 0, 0x1b, auxmode | 0x04);\n\t}\n}"
  },
  {
    "function_name": "aue_miibus_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "468-512",
    "snippet": "Static int\naue_miibus_readreg(dev, phy, reg)\n\tdevice_ptr_t\t\tdev;\n\tint\t\t\tphy, reg;\n{\n\tstruct aue_softc\t*sc = USBGETSOFTC(dev);\n\tint\t\t\ti;\n\tu_int16_t\t\tval;\n\n\t/*\n\t * The Am79C901 HomePNA PHY actually contains\n\t * two transceivers: a 1Mbps HomePNA PHY and a\n\t * 10Mbps full/half duplex ethernet PHY with\n\t * NWAY autoneg. However in the ADMtek adapter,\n\t * only the 1Mbps PHY is actually connected to\n\t * anything, so we ignore the 10Mbps one. It\n\t * happens to be configured for MII address 3,\n\t * so we filter that out.\n\t */\n\tif (sc->aue_vendor == USB_VENDOR_ADMTEK &&\n\t    sc->aue_product == USB_PRODUCT_ADMTEK_PEGASUS) {\n\t\tif (phy != 1)\n\t\t\treturn (0);\n\t}\n\n\taue_csr_write_1(sc, AUE_PHY_ADDR, phy);\n\taue_csr_write_1(sc, AUE_PHY_CTL, reg | AUE_PHYCTL_READ);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (aue_csr_read_1(sc, AUE_PHY_CTL) & AUE_PHYCTL_DONE)\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT) {\n\t\tprintf(\"%s: MII read timed out\\n\",\n\t\t    USBDEVNAME(sc->aue_dev));\n\t}\n\n\tval = aue_csr_read_2(sc, AUE_PHY_DATA);\n\n\tDPRINTFN(11,(\"%s: %s: phy=%d reg=%d => 0x%04x\\n\",\n\t\t     USBDEVNAME(sc->aue_dev), __FUNCTION__, phy, reg, val));\n\n\treturn (val);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "aue_miibus_readreg\t__P((device_ptr_t, int, int));",
      "Static void",
      "aue_miibus_statchg\t__P((device_ptr_t));",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));",
      "device_ptr_t\t\tdev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "11",
            "(\"%s: %s: phy=%d reg=%d => 0x%04x\\n\",\n\t\t     USBDEVNAME(sc->aue_dev), __FUNCTION__, phy, reg, val)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_csr_read_2",
          "args": [
            "sc",
            "AUE_PHY_DATA"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_read_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "323-353",
          "snippet": "Static int\naue_csr_read_2(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (UGETW(val));\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_read_2(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (UGETW(val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: MII read timed out\\n\"",
            "USBDEVNAME(sc->aue_dev)"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_csr_read_1",
          "args": [
            "sc",
            "AUE_PHY_CTL"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_read_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "291-321",
          "snippet": "Static int\naue_csr_read_1(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuByte\t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_read_1(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuByte\t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_csr_write_1",
          "args": [
            "sc",
            "AUE_PHY_CTL",
            "reg | AUE_PHYCTL_READ"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "355-386",
          "snippet": "Static int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBGETSOFTC",
          "args": [
            "dev"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\naue_miibus_readreg\t__P((device_ptr_t, int, int));\nStatic void;\naue_miibus_statchg\t__P((device_ptr_t));\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\ndevice_ptr_t\t\tdev;\n\nStatic int\naue_miibus_readreg(dev, phy, reg)\n\tdevice_ptr_t\t\tdev;\n\tint\t\t\tphy, reg;\n{\n\tstruct aue_softc\t*sc = USBGETSOFTC(dev);\n\tint\t\t\ti;\n\tu_int16_t\t\tval;\n\n\t/*\n\t * The Am79C901 HomePNA PHY actually contains\n\t * two transceivers: a 1Mbps HomePNA PHY and a\n\t * 10Mbps full/half duplex ethernet PHY with\n\t * NWAY autoneg. However in the ADMtek adapter,\n\t * only the 1Mbps PHY is actually connected to\n\t * anything, so we ignore the 10Mbps one. It\n\t * happens to be configured for MII address 3,\n\t * so we filter that out.\n\t */\n\tif (sc->aue_vendor == USB_VENDOR_ADMTEK &&\n\t    sc->aue_product == USB_PRODUCT_ADMTEK_PEGASUS) {\n\t\tif (phy != 1)\n\t\t\treturn (0);\n\t}\n\n\taue_csr_write_1(sc, AUE_PHY_ADDR, phy);\n\taue_csr_write_1(sc, AUE_PHY_CTL, reg | AUE_PHYCTL_READ);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (aue_csr_read_1(sc, AUE_PHY_CTL) & AUE_PHYCTL_DONE)\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT) {\n\t\tprintf(\"%s: MII read timed out\\n\",\n\t\t    USBDEVNAME(sc->aue_dev));\n\t}\n\n\tval = aue_csr_read_2(sc, AUE_PHY_DATA);\n\n\tDPRINTFN(11,(\"%s: %s: phy=%d reg=%d => 0x%04x\\n\",\n\t\t     USBDEVNAME(sc->aue_dev), __FUNCTION__, phy, reg, val));\n\n\treturn (val);\n}"
  },
  {
    "function_name": "aue_read_mac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "450-466",
    "snippet": "Static void\naue_read_mac(sc, dest)\n\tstruct aue_softc\t*sc;\n\tu_char\t\t\t*dest;\n{\n\tint\t\t\ti;\n\tint\t\t\toff = 0;\n\tint\t\t\tword;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tfor (i = 0; i < 3; i++) {\n\t\tword = aue_eeprom_getword(sc, off + i);\n\t\tdest[2 * i] = (u_char)word;\n\t\tdest[2 * i + 1] = (u_char)(word >> 8);\n\t}\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "aue_read_mac\t__P((struct aue_softc *, u_char *));",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "word >> 8"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_eeprom_getword",
          "args": [
            "sc",
            "off + i"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "aue_eeprom_getword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "424-445",
          "snippet": "Static int\naue_eeprom_getword(sc, addr)\n\tstruct aue_softc\t*sc;\n\tint\t\t\taddr;\n{\n\tint\t\ti;\n\n\taue_csr_write_1(sc, AUE_EE_REG, addr);\n\taue_csr_write_1(sc, AUE_EE_CTL, AUE_EECTL_READ);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (aue_csr_read_1(sc, AUE_EE_CTL) & AUE_EECTL_DONE)\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT) {\n\t\tprintf(\"%s: EEPROM read timed out\\n\",\n\t\t    USBDEVNAME(sc->aue_dev));\n\t}\n\n\treturn (aue_csr_read_2(sc, AUE_EE_DATA));\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_eeprom_getword(sc, addr)\n\tstruct aue_softc\t*sc;\n\tint\t\t\taddr;\n{\n\tint\t\ti;\n\n\taue_csr_write_1(sc, AUE_EE_REG, addr);\n\taue_csr_write_1(sc, AUE_EE_CTL, AUE_EECTL_READ);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (aue_csr_read_1(sc, AUE_EE_CTL) & AUE_EECTL_DONE)\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT) {\n\t\tprintf(\"%s: EEPROM read timed out\\n\",\n\t\t    USBDEVNAME(sc->aue_dev));\n\t}\n\n\treturn (aue_csr_read_2(sc, AUE_EE_DATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\naue_read_mac\t__P((struct aue_softc *, u_char *));\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic void\naue_read_mac(sc, dest)\n\tstruct aue_softc\t*sc;\n\tu_char\t\t\t*dest;\n{\n\tint\t\t\ti;\n\tint\t\t\toff = 0;\n\tint\t\t\tword;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->aue_dev), __FUNCTION__));\n\n\tfor (i = 0; i < 3; i++) {\n\t\tword = aue_eeprom_getword(sc, off + i);\n\t\tdest[2 * i] = (u_char)word;\n\t\tdest[2 * i + 1] = (u_char)(word >> 8);\n\t}\n}"
  },
  {
    "function_name": "aue_eeprom_getword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "424-445",
    "snippet": "Static int\naue_eeprom_getword(sc, addr)\n\tstruct aue_softc\t*sc;\n\tint\t\t\taddr;\n{\n\tint\t\ti;\n\n\taue_csr_write_1(sc, AUE_EE_REG, addr);\n\taue_csr_write_1(sc, AUE_EE_CTL, AUE_EECTL_READ);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (aue_csr_read_1(sc, AUE_EE_CTL) & AUE_EECTL_DONE)\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT) {\n\t\tprintf(\"%s: EEPROM read timed out\\n\",\n\t\t    USBDEVNAME(sc->aue_dev));\n\t}\n\n\treturn (aue_csr_read_2(sc, AUE_EE_DATA));\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aue_csr_read_2",
          "args": [
            "sc",
            "AUE_EE_DATA"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_read_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "323-353",
          "snippet": "Static int\naue_csr_read_2(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (UGETW(val));\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_read_2(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (UGETW(val));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: EEPROM read timed out\\n\"",
            "USBDEVNAME(sc->aue_dev)"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aue_csr_read_1",
          "args": [
            "sc",
            "AUE_EE_CTL"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_read_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "291-321",
          "snippet": "Static int\naue_csr_read_1(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuByte\t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (val);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_read_1(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuByte\t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aue_csr_write_1",
          "args": [
            "sc",
            "AUE_EE_CTL",
            "AUE_EECTL_READ"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "aue_csr_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
          "lines": "355-386",
          "snippet": "Static int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/if_auereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include \"miibus_if.h\"",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "aue_tx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "aue_rx_list_init\t__P((struct aue_softc *));",
            "Static int",
            "Static int",
            "Static void",
            "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_stop\t\t__P((struct aue_softc *));",
            "Static void",
            "Static int",
            "aue_openpipes\t__P((struct aue_softc *));",
            "Static int",
            "Static void",
            "Static int",
            "aue_eeprom_getword\t__P((struct aue_softc *, int));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "aue_setmulti\t__P((struct aue_softc *));",
            "Static void",
            "aue_reset\t\t__P((struct aue_softc *));",
            "Static int",
            "aue_csr_read_1\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
            "Static int",
            "aue_csr_read_2\t__P((struct aue_softc *, int));",
            "Static int",
            "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_eeprom_getword(sc, addr)\n\tstruct aue_softc\t*sc;\n\tint\t\t\taddr;\n{\n\tint\t\ti;\n\n\taue_csr_write_1(sc, AUE_EE_REG, addr);\n\taue_csr_write_1(sc, AUE_EE_CTL, AUE_EECTL_READ);\n\n\tfor (i = 0; i < AUE_TIMEOUT; i++) {\n\t\tif (aue_csr_read_1(sc, AUE_EE_CTL) & AUE_EECTL_DONE)\n\t\t\tbreak;\n\t}\n\n\tif (i == AUE_TIMEOUT) {\n\t\tprintf(\"%s: EEPROM read timed out\\n\",\n\t\t    USBDEVNAME(sc->aue_dev));\n\t}\n\n\treturn (aue_csr_read_2(sc, AUE_EE_DATA));\n}"
  },
  {
    "function_name": "aue_csr_write_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "388-419",
    "snippet": "Static int\naue_csr_write_2(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuWord\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tUSETW(val, aval);\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, aval);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: aue_csr_write_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err))"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_DO_REQUEST",
          "args": [
            "sc->aue_udev",
            "&req",
            "&val"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "2"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "reg"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "aval"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "val",
            "aval"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_write_2(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuWord\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tUSETW(val, aval);\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, aval);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "aue_csr_write_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "355-386",
    "snippet": "Static int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err))"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_DO_REQUEST",
          "args": [
            "sc->aue_udev",
            "&req",
            "&val"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "1"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "reg"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "val"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_write_1(sc, reg, aval)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg, aval;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\tuByte\t\t\tval;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\tval = aval;\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_WRITEREG;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_write_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "aue_csr_read_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "323-353",
    "snippet": "Static int\naue_csr_read_2(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (UGETW(val));\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "val"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: aue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err))"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_DO_REQUEST",
          "args": [
            "sc->aue_udev",
            "&req",
            "&val"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "2"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "reg"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_read_2(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuWord\t\t\tval;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 2);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_2: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (UGETW(val));\n}"
  },
  {
    "function_name": "aue_csr_read_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_aue.c",
    "lines": "291-321",
    "snippet": "Static int\naue_csr_read_1(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuByte\t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (val);\n}",
    "includes": [
      "#include <dev/usb/if_auereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include \"miibus_if.h\"",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "aue_tx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "aue_rx_list_init\t__P((struct aue_softc *));",
      "Static int",
      "Static int",
      "Static void",
      "aue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "aue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_stop\t\t__P((struct aue_softc *));",
      "Static void",
      "Static int",
      "aue_openpipes\t__P((struct aue_softc *));",
      "Static int",
      "Static void",
      "Static int",
      "aue_eeprom_getword\t__P((struct aue_softc *, int));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "aue_setmulti\t__P((struct aue_softc *));",
      "Static void",
      "aue_reset\t\t__P((struct aue_softc *));",
      "Static int",
      "aue_csr_read_1\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_1\t__P((struct aue_softc *, int, int));",
      "Static int",
      "aue_csr_read_2\t__P((struct aue_softc *, int));",
      "Static int",
      "aue_csr_write_2\t__P((struct aue_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: aue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err))"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->aue_dev"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUE_DO_REQUEST",
          "args": [
            "sc->aue_udev",
            "&req",
            "&val"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "1"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "reg"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/if_auereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include \"miibus_if.h\"\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\naue_tx_list_init\t__P((struct aue_softc *));\nStatic int;\naue_rx_list_init\t__P((struct aue_softc *));\nStatic int;\nStatic int;\nStatic void;\naue_intr\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\naue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_stop\t\t__P((struct aue_softc *));\nStatic void;\nStatic int;\naue_openpipes\t__P((struct aue_softc *));\nStatic int;\nStatic void;\nStatic int;\naue_eeprom_getword\t__P((struct aue_softc *, int));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\naue_setmulti\t__P((struct aue_softc *));\nStatic void;\naue_reset\t\t__P((struct aue_softc *));\nStatic int;\naue_csr_read_1\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_1\t__P((struct aue_softc *, int, int));\nStatic int;\naue_csr_read_2\t__P((struct aue_softc *, int));\nStatic int;\naue_csr_write_2\t__P((struct aue_softc *, int, int));\n\nStatic int\naue_csr_read_1(sc, reg)\n\tstruct aue_softc\t*sc;\n\tint\t\t\treg;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tuByte\t\t\tval = 0;\n\tint\t\t\ts;\n\n\tif (sc->aue_dying)\n\t\treturn (0);\n\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = AUE_UR_READREG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, reg);\n\tUSETW(req.wLength, 1);\n\n\ts = splusb();\n\terr = AUE_DO_REQUEST(sc->aue_udev, &req, &val);\n\tsplx(s);\n\n\tif (err) {\n\t\tDPRINTF((\"%s: aue_csr_read_1: reg=0x%x err=%s\\n\",\n\t\t\t USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));\n\t\treturn (0);\n\t}\n\n\treturn (val);\n}"
  }
]