[
  {
    "function_name": "tc_dma_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc_tc.c",
    "lines": "183-191",
    "snippet": "static void\ntc_dma_end(asc, state, flag)\n\tasc_softc_t asc;\n\tState *state;\n\tint flag;\n{\n\tif (flag == ASCDMA_READ)\n\t\tbcopy(state->dmaBufAddr, state->buf, state->dmalen);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/dev/ascreg.h>\t/* XXX */",
      "#include <pmax/dev/scsi.h>\t/* XXX */",
      "#include <pmax/dev/device.h>\t/* XXX */",
      "#include <dev/tc/ioasicvar.h>",
      "#include <machine/autoconf.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\ntc_dma_end"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "state->dmaBufAddr",
            "state->buf",
            "state->dmalen"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/dev/ascreg.h>\t/* XXX */\n#include <pmax/dev/scsi.h>\t/* XXX */\n#include <pmax/dev/device.h>\t/* XXX */\n#include <dev/tc/ioasicvar.h>\n#include <machine/autoconf.h>\n#include <dev/tc/tcvar.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\ntc_dma_end;\n\nstatic void\ntc_dma_end(asc, state, flag)\n\tasc_softc_t asc;\n\tState *state;\n\tint flag;\n{\n\tif (flag == ASCDMA_READ)\n\t\tbcopy(state->dmaBufAddr, state->buf, state->dmalen);\n}"
  },
  {
    "function_name": "tc_dma_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc_tc.c",
    "lines": "162-181",
    "snippet": "static int\ntc_dma_start(asc, state, cp, flag, len, off)\n\tasc_softc_t asc;\n\tState *state;\n\tcaddr_t cp;\n\tint flag;\n\tint len;\n\tint off;\n{\n\n\tif (len > PER_TGT_DMA_SIZE)\n\t\tlen = PER_TGT_DMA_SIZE;\n\tif (flag == ASCDMA_WRITE)\n\t\tbcopy(cp, state->dmaBufAddr + off, len);\n\tif (flag == ASCDMA_WRITE)\n\t\t*asc->dmar = ASC_DMAR_WRITE | ASC_DMA_ADDR(state->dmaBufAddr + off);\n\telse\n\t\t*asc->dmar = ASC_DMA_ADDR(state->dmaBufAddr + off);\n\treturn (len);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/dev/ascreg.h>\t/* XXX */",
      "#include <pmax/dev/scsi.h>\t/* XXX */",
      "#include <pmax/dev/device.h>\t/* XXX */",
      "#include <dev/tc/ioasicvar.h>",
      "#include <machine/autoconf.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ntc_dma_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASC_DMA_ADDR",
          "args": [
            "state->dmaBufAddr + off"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASC_DMA_ADDR",
          "args": [
            "state->dmaBufAddr + off"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "cp",
            "state->dmaBufAddr + off",
            "len"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/dev/ascreg.h>\t/* XXX */\n#include <pmax/dev/scsi.h>\t/* XXX */\n#include <pmax/dev/device.h>\t/* XXX */\n#include <dev/tc/ioasicvar.h>\n#include <machine/autoconf.h>\n#include <dev/tc/tcvar.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\ntc_dma_start;\n\nstatic int\ntc_dma_start(asc, state, cp, flag, len, off)\n\tasc_softc_t asc;\n\tState *state;\n\tcaddr_t cp;\n\tint flag;\n\tint len;\n\tint off;\n{\n\n\tif (len > PER_TGT_DMA_SIZE)\n\t\tlen = PER_TGT_DMA_SIZE;\n\tif (flag == ASCDMA_WRITE)\n\t\tbcopy(cp, state->dmaBufAddr + off, len);\n\tif (flag == ASCDMA_WRITE)\n\t\t*asc->dmar = ASC_DMAR_WRITE | ASC_DMA_ADDR(state->dmaBufAddr + off);\n\telse\n\t\t*asc->dmar = ASC_DMA_ADDR(state->dmaBufAddr + off);\n\treturn (len);\n}"
  },
  {
    "function_name": "asc_tc_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc_tc.c",
    "lines": "80-155",
    "snippet": "void\nasc_tc_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tregister struct tc_attach_args *t = aux;\n\tregister asc_softc_t asc = (asc_softc_t) self;\n\tu_char *buff;\n\tint i, speed;\n\n\tvoid *ascaddr;\n\tint unit;\n\n\t/* Use uncached address for chip registers.  */\n\tascaddr = (void*)MIPS_PHYS_TO_KSEG1(t->ta_addr);\n\tunit = asc->sc_dev.dv_unit;\n\t\n\t/*\n\t * Initialize hw descriptor, cache some pointers\n\t */\n\tasc->regs = (asc_regmap_t *)(ascaddr + ASC_OFFSET_53C94);\n\n\t/*\n\t * Set up machine dependencies.\n\t * (1) how to do dma\n\t * (2) timing based on turbochannel frequency\n\t */\n\n\t/*\n\t * Fall through for turbochannel option.\n\t */\n\tasc->dmar = (volatile int *)(ascaddr + ASC_OFFSET_DMAR);\n\tbuff = (u_char *)(ascaddr + ASC_OFFSET_RAM);\n\n\t/*\n\t * Statically partition the DMA buffer between targets.\n\t * This way we will eventually be able to attach/detach\n\t * drives on-fly.  And 18k/target is plenty for normal use.\n\t */\n\n\t/*\n\t * Give each target its own DMA buffer region.\n\t * We may want to try ping ponging buffers later.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++)\n\t\tasc->st[i].dmaBufAddr = buff + PER_TGT_DMA_SIZE * i;\n\n\tasc->dma_start = tc_dma_start;\n\tasc->dma_end = tc_dma_end;\n\n\t/*\n\t * Now for timing. The 3max has a 25Mhz tb whereas the 3min and\n\t * maxine are 12.5Mhz.\n\t */\n\tprintf(\" (bus speed: %s MHz) \", t->ta_busspeed? \"25\"  : \"12.5\");\n\n\tswitch (t->ta_busspeed) {\n\tcase TC_SPEED_25_MHZ:\n\t\tspeed = ASC_SPEED_25_MHZ;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\" (unknown TC speed, assuming 12.5MHz) \");\n\t\t/* FALLTHROUGH*/\n\tcase TC_SPEED_12_5_MHZ:\n\t\tspeed = ASC_SPEED_12_5_MHZ;\n\t\tbreak;\n\t};\n\n\tascattach(asc, speed);\n\n\t/* tie pseudo-slot to device */\n\ttc_intr_establish(parent, t->ta_cookie, TC_IPL_BIO,\n\t\t\t  asc_intr, asc);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/dev/ascreg.h>\t/* XXX */",
      "#include <pmax/dev/scsi.h>\t/* XXX */",
      "#include <pmax/dev/device.h>\t/* XXX */",
      "#include <dev/tc/ioasicvar.h>",
      "#include <machine/autoconf.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void asc_tc_attach",
      "static int\ntc_dma_start",
      "static void\ntc_dma_end"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tc_intr_establish",
          "args": [
            "parent",
            "t->ta_cookie",
            "TC_IPL_BIO",
            "asc_intr",
            "asc"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "tc_intr_establish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/tc.c",
          "lines": "276-287",
          "snippet": "void\ntc_intr_establish(dev, cookie, level, handler, arg)\n\tstruct device *dev;\n\tvoid *cookie, *arg;\n\ttc_intrlevel_t level;\n\tint (*handler) __P((void *));\n{\n\tstruct tc_softc *sc = (struct tc_softc *)dev;\n\n\t(*sc->sc_intr_establish)(sc->sc_dv.dv_parent, cookie, level,\n\t    handler, arg);\n}",
          "includes": [
            "#include <dev/tc/tcdevs_data.h>",
            "#include <machine/autoconf.h>\t/* for the proto of badaddr() */",
            "#include <dev/tc/tcdevs.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <dev/tc/tcreg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/tcdevs_data.h>\n#include <machine/autoconf.h>\t/* for the proto of badaddr() */\n#include <dev/tc/tcdevs.h>\n#include <dev/tc/tcvar.h>\n#include <dev/tc/tcreg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ntc_intr_establish(dev, cookie, level, handler, arg)\n\tstruct device *dev;\n\tvoid *cookie, *arg;\n\ttc_intrlevel_t level;\n\tint (*handler) __P((void *));\n{\n\tstruct tc_softc *sc = (struct tc_softc *)dev;\n\n\t(*sc->sc_intr_establish)(sc->sc_dv.dv_parent, cookie, level,\n\t    handler, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ascattach",
          "args": [
            "asc",
            "speed"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ascattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc.c",
          "lines": "450-546",
          "snippet": "void\nascattach(asc, bus_speed)\n\tregister asc_softc_t asc;\n\tint bus_speed;\n{\n\tregister asc_regmap_t *regs;\n\tint id, s;\n\n\tint unit;\n\n\tunit = asc->sc_dev.dv_unit;\n\t\n\t/*\n\t * Set up machine dependencies.\n\t * (1) timing based on turbochannel frequency\n\t */\n\n\t/* dma setup done in parent-specific attach code */\n\n\t/*\n\t * Now for timing. The 3max has a 25Mhz tb whereas the 3min and\n\t * maxine are 12.5Mhz.\n\t */\n\tswitch (bus_speed) {\n\tcase ASC_SPEED_25_MHZ:\n\t\tasc->min_period = ASC_MIN_PERIOD25;\n\t\tasc->max_period = ASC_MAX_PERIOD25;\n\t\tasc->ccf = ASC_CCF(25);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(25, asc->ccf);\n\t\tasc->tb_ticks = 10;\n\t\tbreak;\n\n\tcase ASC_SPEED_12_5_MHZ:\n\tdefault:\n\t\tasc->min_period = ASC_MIN_PERIOD12;\n\t\tasc->max_period = ASC_MAX_PERIOD12;\n\t\tasc->ccf = ASC_CCF(13);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(13, asc->ccf);\n\t\tasc->tb_ticks = 20;\n\t\tbreak;\n\t};\n\n\tasc->state = ASC_STATE_IDLE;\n\tasc->target = -1;\n\n\tregs = asc->regs;\n\n\t/*\n\t * Reset chip, fully.  Note that interrupts are already enabled.\n\t */\n\ts = splbio();\n\n\t/* preserve our ID for now */\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n\tasc->myidmask = ~(1 << asc->sc_id);\n\n\tasc_reset(asc, regs);\n\n\t/*\n\t * Our SCSI id on the bus.\n\t * The user can set this via the prom on 3maxen/pmaxen.\n\t * If this changes it is easy to fix: make a default that\n\t * can be changed as boot arg.\n\t */\n#ifdef\tunneeded\n\tregs->asc_cnfg1 = (regs->asc_cnfg1 & ~ASC_CNFG1_MY_BUS_ID) |\n\t\t\t      (scsi_initiator_id[unit] & 0x7);\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n#endif\n\n\tid = asc->sc_id;\n\tsplx(s);\n\n\t/* Hack for old-sytle SCSI-device probe */\n\t(void) pmax_add_scsi(&ascdriver, unit);\n\n\tprintf(\": target %d\\n\", id);\n\n\n#ifdef USE_NEW_SCSI\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tasc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n\tasc->sc_link.adapter_softc = asc;\n\tasc->sc_link.adapter_target = asc->sc_id;\n\tasc->sc_link.adapter = &asc_switch;\n\tasc->sc_link.device = &asc_dev;\n\tasc->sc_link.openings = 2;\n\n\t/*\n\t * Now try to attach all the sub-devices.\n\t */\n\tconfig_found(self, &asc->sc_link, scsiprint);\n\n#endif /* USE_NEW_SCSI */\n}",
          "includes": [
            "#include <dev/tc/ascvar.h>",
            "#include <pmax/pmax/kmin.h>",
            "#include <pmax/pmax/asic.h>",
            "#include <pmax/dev/ascreg.h>",
            "#include <pmax/dev/scsi.h>",
            "#include <pmax/dev/device.h>",
            "#include <machine/bus.h>",
            "#include <machine/autoconf.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/tc/ioasicvar.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <sys/reboot.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/errno.h>",
            "#include <sys/conf.h>",
            "#include <sys/buf.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <asc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/pmax/kmin.h>\n#include <pmax/pmax/asic.h>\n#include <pmax/dev/ascreg.h>\n#include <pmax/dev/scsi.h>\n#include <pmax/dev/device.h>\n#include <machine/bus.h>\n#include <machine/autoconf.h>\n#include <machine/cpu.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/tc/ioasicvar.h>\n#include <dev/tc/tcvar.h>\n#include <sys/reboot.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/errno.h>\n#include <sys/conf.h>\n#include <sys/buf.h>\n#include <sys/dkstat.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <asc.h>\n\nvoid\nascattach(asc, bus_speed)\n\tregister asc_softc_t asc;\n\tint bus_speed;\n{\n\tregister asc_regmap_t *regs;\n\tint id, s;\n\n\tint unit;\n\n\tunit = asc->sc_dev.dv_unit;\n\t\n\t/*\n\t * Set up machine dependencies.\n\t * (1) timing based on turbochannel frequency\n\t */\n\n\t/* dma setup done in parent-specific attach code */\n\n\t/*\n\t * Now for timing. The 3max has a 25Mhz tb whereas the 3min and\n\t * maxine are 12.5Mhz.\n\t */\n\tswitch (bus_speed) {\n\tcase ASC_SPEED_25_MHZ:\n\t\tasc->min_period = ASC_MIN_PERIOD25;\n\t\tasc->max_period = ASC_MAX_PERIOD25;\n\t\tasc->ccf = ASC_CCF(25);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(25, asc->ccf);\n\t\tasc->tb_ticks = 10;\n\t\tbreak;\n\n\tcase ASC_SPEED_12_5_MHZ:\n\tdefault:\n\t\tasc->min_period = ASC_MIN_PERIOD12;\n\t\tasc->max_period = ASC_MAX_PERIOD12;\n\t\tasc->ccf = ASC_CCF(13);\n\t\tasc->timeout_250 = ASC_TIMEOUT_250(13, asc->ccf);\n\t\tasc->tb_ticks = 20;\n\t\tbreak;\n\t};\n\n\tasc->state = ASC_STATE_IDLE;\n\tasc->target = -1;\n\n\tregs = asc->regs;\n\n\t/*\n\t * Reset chip, fully.  Note that interrupts are already enabled.\n\t */\n\ts = splbio();\n\n\t/* preserve our ID for now */\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n\tasc->myidmask = ~(1 << asc->sc_id);\n\n\tasc_reset(asc, regs);\n\n\t/*\n\t * Our SCSI id on the bus.\n\t * The user can set this via the prom on 3maxen/pmaxen.\n\t * If this changes it is easy to fix: make a default that\n\t * can be changed as boot arg.\n\t */\n#ifdef\tunneeded\n\tregs->asc_cnfg1 = (regs->asc_cnfg1 & ~ASC_CNFG1_MY_BUS_ID) |\n\t\t\t      (scsi_initiator_id[unit] & 0x7);\n\tasc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;\n#endif\n\n\tid = asc->sc_id;\n\tsplx(s);\n\n\t/* Hack for old-sytle SCSI-device probe */\n\t(void) pmax_add_scsi(&ascdriver, unit);\n\n\tprintf(\": target %d\\n\", id);\n\n\n#ifdef USE_NEW_SCSI\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tasc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;\n\tasc->sc_link.adapter_softc = asc;\n\tasc->sc_link.adapter_target = asc->sc_id;\n\tasc->sc_link.adapter = &asc_switch;\n\tasc->sc_link.device = &asc_dev;\n\tasc->sc_link.openings = 2;\n\n\t/*\n\t * Now try to attach all the sub-devices.\n\t */\n\tconfig_found(self, &asc->sc_link, scsiprint);\n\n#endif /* USE_NEW_SCSI */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" (unknown TC speed, assuming 12.5MHz) \""
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIPS_PHYS_TO_KSEG1",
          "args": [
            "t->ta_addr"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/dev/ascreg.h>\t/* XXX */\n#include <pmax/dev/scsi.h>\t/* XXX */\n#include <pmax/dev/device.h>\t/* XXX */\n#include <dev/tc/ioasicvar.h>\n#include <machine/autoconf.h>\n#include <dev/tc/tcvar.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid asc_tc_attach;\nstatic int\ntc_dma_start;\nstatic void\ntc_dma_end;\n\nvoid\nasc_tc_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tregister struct tc_attach_args *t = aux;\n\tregister asc_softc_t asc = (asc_softc_t) self;\n\tu_char *buff;\n\tint i, speed;\n\n\tvoid *ascaddr;\n\tint unit;\n\n\t/* Use uncached address for chip registers.  */\n\tascaddr = (void*)MIPS_PHYS_TO_KSEG1(t->ta_addr);\n\tunit = asc->sc_dev.dv_unit;\n\t\n\t/*\n\t * Initialize hw descriptor, cache some pointers\n\t */\n\tasc->regs = (asc_regmap_t *)(ascaddr + ASC_OFFSET_53C94);\n\n\t/*\n\t * Set up machine dependencies.\n\t * (1) how to do dma\n\t * (2) timing based on turbochannel frequency\n\t */\n\n\t/*\n\t * Fall through for turbochannel option.\n\t */\n\tasc->dmar = (volatile int *)(ascaddr + ASC_OFFSET_DMAR);\n\tbuff = (u_char *)(ascaddr + ASC_OFFSET_RAM);\n\n\t/*\n\t * Statically partition the DMA buffer between targets.\n\t * This way we will eventually be able to attach/detach\n\t * drives on-fly.  And 18k/target is plenty for normal use.\n\t */\n\n\t/*\n\t * Give each target its own DMA buffer region.\n\t * We may want to try ping ponging buffers later.\n\t */\n\tfor (i = 0; i < ASC_NCMD; i++)\n\t\tasc->st[i].dmaBufAddr = buff + PER_TGT_DMA_SIZE * i;\n\n\tasc->dma_start = tc_dma_start;\n\tasc->dma_end = tc_dma_end;\n\n\t/*\n\t * Now for timing. The 3max has a 25Mhz tb whereas the 3min and\n\t * maxine are 12.5Mhz.\n\t */\n\tprintf(\" (bus speed: %s MHz) \", t->ta_busspeed? \"25\"  : \"12.5\");\n\n\tswitch (t->ta_busspeed) {\n\tcase TC_SPEED_25_MHZ:\n\t\tspeed = ASC_SPEED_25_MHZ;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\" (unknown TC speed, assuming 12.5MHz) \");\n\t\t/* FALLTHROUGH*/\n\tcase TC_SPEED_12_5_MHZ:\n\t\tspeed = ASC_SPEED_12_5_MHZ;\n\t\tbreak;\n\t};\n\n\tascattach(asc, speed);\n\n\t/* tie pseudo-slot to device */\n\ttc_intr_establish(parent, t->ta_cookie, TC_IPL_BIO,\n\t\t\t  asc_intr, asc);\n}"
  },
  {
    "function_name": "asc_tc_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/asc_tc.c",
    "lines": "58-76",
    "snippet": "int\nasc_tc_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct tc_attach_args *t = aux;\n\tvoid *ascaddr;\n\n\tif (strncmp(t->ta_modname, \"PMAZ-AA \", TC_ROM_LLEN))\n\t\treturn (0);\n\n\tascaddr = (void*)t->ta_addr;\n\n\tif (tc_badaddr(ascaddr + ASC_OFFSET_53C94))\n\t\treturn (0);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/tc/ascvar.h>",
      "#include <pmax/dev/ascreg.h>\t/* XXX */",
      "#include <pmax/dev/scsi.h>\t/* XXX */",
      "#include <pmax/dev/device.h>\t/* XXX */",
      "#include <dev/tc/ioasicvar.h>",
      "#include <machine/autoconf.h>",
      "#include <dev/tc/tcvar.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int asc_tc_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tc_badaddr",
          "args": [
            "ascaddr + ASC_OFFSET_53C94"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "t->ta_modname",
            "\"PMAZ-AA \"",
            "TC_ROM_LLEN"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/tc/ascvar.h>\n#include <pmax/dev/ascreg.h>\t/* XXX */\n#include <pmax/dev/scsi.h>\t/* XXX */\n#include <pmax/dev/device.h>\t/* XXX */\n#include <dev/tc/ioasicvar.h>\n#include <machine/autoconf.h>\n#include <dev/tc/tcvar.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint asc_tc_match;\n\nint\nasc_tc_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct tc_attach_args *t = aux;\n\tvoid *ascaddr;\n\n\tif (strncmp(t->ta_modname, \"PMAZ-AA \", TC_ROM_LLEN))\n\t\treturn (0);\n\n\tascaddr = (void*)t->ta_addr;\n\n\tif (tc_badaddr(ascaddr + ASC_OFFSET_53C94))\n\t\treturn (0);\n\n\treturn (1);\n}"
  }
]