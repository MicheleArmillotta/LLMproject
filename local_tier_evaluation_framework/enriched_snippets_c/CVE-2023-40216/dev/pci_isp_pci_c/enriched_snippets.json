[
  {
    "function_name": "isp_pci_dumpregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "944-951",
    "snippet": "static void\nisp_pci_dumpregs(isp)\n\tstruct ispsoftc *isp;\n{\n\tstruct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;\n\tprintf(\"%s: PCI Status Command/Status=%x\\n\", pci->pci_isp.isp_name,\n\t    pci_conf_read(pci->pci_pc, pci->pci_tag, PCI_COMMAND_STATUS_REG));\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_pci_dumpregs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: PCI Status Command/Status=%x\\n\"",
            "pci->pci_isp.isp_name",
            "pci_conf_read(pci->pci_pc, pci->pci_tag, PCI_COMMAND_STATUS_REG)"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pci->pci_pc",
            "pci->pci_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_pci_dumpregs;\n\nstatic void\nisp_pci_dumpregs(isp)\n\tstruct ispsoftc *isp;\n{\n\tstruct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;\n\tprintf(\"%s: PCI Status Command/Status=%x\\n\", pci->pci_isp.isp_name,\n\t    pci_conf_read(pci->pci_pc, pci->pci_tag, PCI_COMMAND_STATUS_REG));\n}"
  },
  {
    "function_name": "isp_pci_reset1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "936-942",
    "snippet": "static void\nisp_pci_reset1(isp)\n\tstruct ispsoftc *isp;\n{\n\t/* Make sure the BIOS is disabled */\n\tisp_pci_wr_reg(isp, HCCR, PCI_HCCR_CMD_BIOS);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_pci_wr_reg",
      "static void isp_pci_reset1"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_pci_wr_reg",
          "args": [
            "isp",
            "HCCR",
            "PCI_HCCR_CMD_BIOS"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pci_wr_reg_1080",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
          "lines": "691-731",
          "snippet": "static void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/microcode/isp/asm_pci.h>",
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t isp_pci_rd_reg",
            "static void isp_pci_wr_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_pci_wr_reg;\nstatic void isp_pci_reset1;\n\nstatic void\nisp_pci_reset1(isp)\n\tstruct ispsoftc *isp;\n{\n\t/* Make sure the BIOS is disabled */\n\tisp_pci_wr_reg(isp, HCCR, PCI_HCCR_CMD_BIOS);\n}"
  },
  {
    "function_name": "isp_pci_dmateardown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "921-934",
    "snippet": "static void\nisp_pci_dmateardown(isp, xs, handle)\n\tstruct ispsoftc *isp;\n\tstruct scsi_xfer *xs;\n\tu_int32_t handle;\n{\n\tstruct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;\n\tbus_dmamap_t dmap;\n\tassert(handle != 0 && handle <= isp->isp_maxcmds);\n\tdmap = pci->pci_xfer_dmap[handle-1];\n\tbus_dmamap_sync(pci->pci_dmat, dmap, xs->flags & SCSI_DATA_IN ?\n\t    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);\n\tbus_dmamap_unload(pci->pci_dmat, dmap);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nisp_pci_dmateardown"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "pci->pci_dmat",
            "dmap"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "pci->pci_dmat",
            "dmap",
            "xs->flags & SCSI_DATA_IN ?\n\t    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "handle != 0 && handle <= isp->isp_maxcmds"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic void\nisp_pci_dmateardown;\n\nstatic void\nisp_pci_dmateardown(isp, xs, handle)\n\tstruct ispsoftc *isp;\n\tstruct scsi_xfer *xs;\n\tu_int32_t handle;\n{\n\tstruct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;\n\tbus_dmamap_t dmap;\n\tassert(handle != 0 && handle <= isp->isp_maxcmds);\n\tdmap = pci->pci_xfer_dmap[handle-1];\n\tbus_dmamap_sync(pci->pci_dmat, dmap, xs->flags & SCSI_DATA_IN ?\n\t    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);\n\tbus_dmamap_unload(pci->pci_dmat, dmap);\n}"
  },
  {
    "function_name": "isp_pci_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "911-919",
    "snippet": "static int\nisp_pci_intr(arg)\n\tvoid *arg;\n{\n\tstruct isp_pcisoftc *pci = (struct isp_pcisoftc *)arg;\n\tbus_dmamap_sync(pci->pci_dmat, pci->pci_result_dmap,\n\t    BUS_DMASYNC_POSTREAD);\n\treturn (isp_intr(arg));\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int isp_pci_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_intr",
          "args": [
            "arg"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "isp_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "2284-2561",
          "snippet": "int\nisp_intr(arg)\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *complist[RESULT_QUEUE_LEN], *xs;\n\tstruct ispsoftc *isp = arg;\n\tu_int16_t iptr, optr;\n\tu_int16_t isr, isrb, sema;\n\tint i, nlooked = 0, ndone = 0;\n\n\t/*\n\t * Well, if we've disabled interrupts, we may get a case where\n\t * isr isn't set, but sema is. In any case, debounce isr reads.\n\t */\n\tdo {\n\t\tisr = ISP_READ(isp, BIU_ISR);\n\t\tisrb = ISP_READ(isp, BIU_ISR);\n\t} while (isr != isrb);\n\tsema = ISP_READ(isp, BIU_SEMA) & 0x1;\n\tIDPRINTF(5, (\"%s: isp_intr isr %x sem %x\\n\", isp->isp_name, isr, sema));\n\tif (isr == 0) {\n\t\treturn (0);\n\t}\n\tif (!INT_PENDING(isp, isr)) {\n\t\tIDPRINTF(4, (\"%s: isp_intr isr=%x\\n\", isp->isp_name, isr));\n\t\treturn (0);\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tIDPRINTF(3, (\"%s: interrupt (isr=%x,sema=%x) when not ready\\n\",\n\t\t    isp->isp_name, isr, sema));\n\t\tISP_WRITE(isp, INMAILBOX5, ISP_READ(isp, OUTMAILBOX5));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\tif (sema) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox & 0x4000) {\n\t\t\tIDPRINTF(4, (\"%s: Command Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t} else {\n\t\t\tu_int32_t fhandle = isp_parse_async(isp, (int) mbox);\n\t\t\tIDPRINTF(4, (\"%s: Async Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t\tif (fhandle > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fhandle);\n\t\t\t}\n\t\t}\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\t/*\n\t * You *must* read OUTMAILBOX5 prior to clearing the RISC interrupt.\n\t */\n\toptr = isp->isp_residx;\n\tiptr = ISP_READ(isp, OUTMAILBOX5);\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\tif (optr == iptr) {\n\t\tIDPRINTF(4, (\"why intr? isr %x iptr %x optr %x\\n\",\n\t\t    isr, optr, iptr));\n\t}\n\n\twhile (optr != iptr) {\n\t\tispstatusreq_t *sp;\n\t\tu_int16_t oop;\n\t\tint buddaboom = 0;\n\n\t\tsp = (ispstatusreq_t *) ISP_QUEUE_ENTRY(isp->isp_result, optr);\n\t\toop = optr;\n\t\toptr = ISP_NXT_QENTRY(optr, RESULT_QUEUE_LEN);\n\t\tnlooked++;\n\t\tMemoryBarrier();\n\t\t/*\n\t\t * Do any appropriate unswizzling of what the Qlogic f/w has\n\t\t * written into memory so it makes sense to us. This is a\n\t\t * per-platform thing.\n\t\t */\n\t\tISP_UNSWIZZLE_RESPONSE(isp, sp);\n\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {\n\t\t\tif (isp_handle_other_response(isp, sp, &optr) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It really has to be a bounced request just copied\n\t\t\t * from the request queue to the response queue. If\n\t\t\t * not, something bad has happened.\n\t\t\t */\n\t\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_REQUEST) {\n\t\t\t\tPRINTF(\"%s: not RESPONSE in RESPONSE Queue \"\n\t\t\t\t    \"(type 0x%x) @ idx %d (next %d)\\n\",\n\t\t\t\t    isp->isp_name,\n\t\t\t\t    sp->req_header.rqs_entry_type, oop, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbuddaboom = 1;\n\t\t}\n\n\t\tif (sp->req_header.rqs_flags & 0xf) {\n#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_CONTINUATION) {\n\t\t\t\tIDPRINTF(4, (\"%s: continuation segment\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\tIDPRINTF(2, (\"%s: internal queues full\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\t/*\n\t\t\t\t * We'll synthesize a QUEUE FULL message below.\n\t\t\t\t */\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADHEADER) {\n\t\t\t\tPRINTF(\"%s: bad header\\n\", isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADPACKET) {\n\t\t\t\tPRINTF(\"%s: bad request packet\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & _RQS_OFLAGS) {\n\t\t\t\tPRINTF(\"%s: unknown flags in response (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, sp->req_header.rqs_flags);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n#undef\t_RQS_OFLAGS\n\t\t}\n\t\tif (sp->req_handle > isp->isp_maxcmds || sp->req_handle < 1) {\n\t\t\tPRINTF(\"%s: bad request handle %d\\n\", isp->isp_name,\n\t\t\t    sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\txs = isp_find_xs(isp, sp->req_handle);\n\t\tif (xs == NULL) {\n\t\t\tPRINTF(\"%s: NULL xs in xflist (handle 0x%x)\\n\",\n\t\t\t    isp->isp_name, sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, sp->req_handle);\n\t\tif (sp->req_status_flags & RQSTF_BUS_RESET) {\n\t\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tif (buddaboom) {\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t}\n\t\tXS_STS(xs) = sp->req_scsi_status & 0xff;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data,\n\t\t\t\t\tXS_SNSLEN(xs));\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t}\n\t\t\t/*\n\t\t\t * A new synchronous rate was negotiated for this\n\t\t\t * target. Mark state such that we'll go look up\n\t\t\t * that which has changed later.\n\t\t\t */\n\t\t\tif (sp->req_status_flags & RQSTF_NEGOTIATION) {\n\t\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_refresh = 1;\n\t\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t\t}\n\t\t} else {\n\t\t\tif (sp->req_scsi_status & RQCS_SV) {\n\t\t\t\tint amt = min(XS_SNSLEN(xs), sp->req_sense_len);\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data, amt);\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t\tsp->req_state_flags |= RQSF_GOT_SENSE;\n\t\t\t} else if (XS_STS(xs) == SCSI_CHECK) {\n\t\t\t\tIDPRINTF(1, (\"%s: check condition with no sense\"\n\t\t\t\t    \" data\\n\", isp->isp_name));\n\t\t\t}\n\t\t}\n\t\tif (XS_NOERR(xs) && XS_STS(xs) == SCSI_BUSY) {\n\t\t\tXS_SETERR(xs, HBA_TGTBSY);\n\t\t}\n\n\t\tif (sp->req_header.rqs_entry_type == RQSTYPE_RESPONSE) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t    if (sp->req_completion_status != RQCS_COMPLETE) {\n\t\t\t\tisp_parse_status(isp, sp, xs);\n\t\t\t    } else {\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t    }\n\t\t\t}\n\t\t} else if (sp->req_header.rqs_entry_type == RQSTYPE_REQUEST) {\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\t/*\n\t\t\t\t * Force Queue Full status.\n\t\t\t\t */\n\t\t\t\tXS_STS(xs) = SCSI_QFULL;\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t} else if (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t} else {\n\t\t\tPRINTF(\"%s: unhandled respose queue type 0x%x\\n\",\n\t\t\t    isp->isp_name, sp->req_header.rqs_entry_type);\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t}\n\t\tif (IS_SCSI(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t} else if (sp->req_scsi_status & RQCS_RU) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t\tIDPRINTF(4, (\"%s: cnt %d rsd %d\\n\", isp->isp_name,\n\t\t\t\tXS_XFRLEN(xs), sp->req_resid));\n\t\t}\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, sp->req_handle);\n\t\t}\n\t\t/*\n\t\t * Let the platforms cope.\n\t\t */\n#if\t0\n\t\t/*\n\t\t * XXX: If we have a check condition, but no Sense Data,\n\t\t * XXX: mark it as an error (ARQ failed). We need to\n\t\t * XXX: to do a more distinct job because there may\n\t\t * XXX: cases where ARQ is disabled.\n\t\t */\n\t\tif (XS_STS(xs) == SCSI_CHECK && !(XS_IS_SNS_VALID(xs))) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tPRINTF(\"%s: ARQ failure for target %d lun %d\\n\",\n\t\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\t\t\tXS_SETERR(xs, HBA_ARQFAIL);\n\t\t\t}\n\t\t}\n#endif\n\t\tif ((isp->isp_dblev >= 5) ||\n\t\t    (isp->isp_dblev > 2 && !XS_NOERR(xs))) {\n\t\t\tPRINTF(\"%s(%d.%d): FIN dl%d resid%d STS %x\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_XFRLEN(xs), XS_RESID(xs), XS_STS(xs));\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tPRINTF(\" Skey: %x\", XS_SNSKEY(xs));\n\t\t\t\tif (!(XS_IS_SNS_VALID(xs))) {\n\t\t\t\t\tPRINTF(\" BUT NOT SET\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tPRINTF(\" XS_ERR=0x%x\\n\", (unsigned int) XS_ERR(xs));\n\t\t}\n\n\t\tif (isp->isp_nactive > 0)\n\t\t    isp->isp_nactive--;\n\t\tcomplist[ndone++] = xs;\t/* defer completion call until later */\n\t}\n\n\t/*\n\t * If we looked at any commands, then it's valid to find out\n\t * what the outpointer is. It also is a trigger to update the\n\t * ISP's notion of what we've seen so far.\n\t */\n\tif (nlooked) {\n\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\tisp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\t}\n\tisp->isp_residx = optr;\n\tfor (i = 0; i < ndone; i++) {\n\t\txs = complist[i];\n\t\tif (xs) {\n\t\t\tXS_CMD_DONE(xs);\n\t\t}\n\t}\n\tENABLE_INTS(isp);\n\treturn (1);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static int isp_handle_other_response",
            "static void isp_parse_status",
            "static void isp_fastpost_complete",
            "static void isp_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)\n\nstatic int isp_parse_async;\nstatic int isp_handle_other_response;\nstatic void isp_parse_status;\nstatic void isp_fastpost_complete;\nstatic void isp_update;\n\nint\nisp_intr(arg)\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *complist[RESULT_QUEUE_LEN], *xs;\n\tstruct ispsoftc *isp = arg;\n\tu_int16_t iptr, optr;\n\tu_int16_t isr, isrb, sema;\n\tint i, nlooked = 0, ndone = 0;\n\n\t/*\n\t * Well, if we've disabled interrupts, we may get a case where\n\t * isr isn't set, but sema is. In any case, debounce isr reads.\n\t */\n\tdo {\n\t\tisr = ISP_READ(isp, BIU_ISR);\n\t\tisrb = ISP_READ(isp, BIU_ISR);\n\t} while (isr != isrb);\n\tsema = ISP_READ(isp, BIU_SEMA) & 0x1;\n\tIDPRINTF(5, (\"%s: isp_intr isr %x sem %x\\n\", isp->isp_name, isr, sema));\n\tif (isr == 0) {\n\t\treturn (0);\n\t}\n\tif (!INT_PENDING(isp, isr)) {\n\t\tIDPRINTF(4, (\"%s: isp_intr isr=%x\\n\", isp->isp_name, isr));\n\t\treturn (0);\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tIDPRINTF(3, (\"%s: interrupt (isr=%x,sema=%x) when not ready\\n\",\n\t\t    isp->isp_name, isr, sema));\n\t\tISP_WRITE(isp, INMAILBOX5, ISP_READ(isp, OUTMAILBOX5));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\tif (sema) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox & 0x4000) {\n\t\t\tIDPRINTF(4, (\"%s: Command Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t} else {\n\t\t\tu_int32_t fhandle = isp_parse_async(isp, (int) mbox);\n\t\t\tIDPRINTF(4, (\"%s: Async Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t\tif (fhandle > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fhandle);\n\t\t\t}\n\t\t}\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\t/*\n\t * You *must* read OUTMAILBOX5 prior to clearing the RISC interrupt.\n\t */\n\toptr = isp->isp_residx;\n\tiptr = ISP_READ(isp, OUTMAILBOX5);\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\tif (optr == iptr) {\n\t\tIDPRINTF(4, (\"why intr? isr %x iptr %x optr %x\\n\",\n\t\t    isr, optr, iptr));\n\t}\n\n\twhile (optr != iptr) {\n\t\tispstatusreq_t *sp;\n\t\tu_int16_t oop;\n\t\tint buddaboom = 0;\n\n\t\tsp = (ispstatusreq_t *) ISP_QUEUE_ENTRY(isp->isp_result, optr);\n\t\toop = optr;\n\t\toptr = ISP_NXT_QENTRY(optr, RESULT_QUEUE_LEN);\n\t\tnlooked++;\n\t\tMemoryBarrier();\n\t\t/*\n\t\t * Do any appropriate unswizzling of what the Qlogic f/w has\n\t\t * written into memory so it makes sense to us. This is a\n\t\t * per-platform thing.\n\t\t */\n\t\tISP_UNSWIZZLE_RESPONSE(isp, sp);\n\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {\n\t\t\tif (isp_handle_other_response(isp, sp, &optr) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It really has to be a bounced request just copied\n\t\t\t * from the request queue to the response queue. If\n\t\t\t * not, something bad has happened.\n\t\t\t */\n\t\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_REQUEST) {\n\t\t\t\tPRINTF(\"%s: not RESPONSE in RESPONSE Queue \"\n\t\t\t\t    \"(type 0x%x) @ idx %d (next %d)\\n\",\n\t\t\t\t    isp->isp_name,\n\t\t\t\t    sp->req_header.rqs_entry_type, oop, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbuddaboom = 1;\n\t\t}\n\n\t\tif (sp->req_header.rqs_flags & 0xf) {\n#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_CONTINUATION) {\n\t\t\t\tIDPRINTF(4, (\"%s: continuation segment\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\tIDPRINTF(2, (\"%s: internal queues full\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\t/*\n\t\t\t\t * We'll synthesize a QUEUE FULL message below.\n\t\t\t\t */\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADHEADER) {\n\t\t\t\tPRINTF(\"%s: bad header\\n\", isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADPACKET) {\n\t\t\t\tPRINTF(\"%s: bad request packet\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & _RQS_OFLAGS) {\n\t\t\t\tPRINTF(\"%s: unknown flags in response (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, sp->req_header.rqs_flags);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n#undef\t_RQS_OFLAGS\n\t\t}\n\t\tif (sp->req_handle > isp->isp_maxcmds || sp->req_handle < 1) {\n\t\t\tPRINTF(\"%s: bad request handle %d\\n\", isp->isp_name,\n\t\t\t    sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\txs = isp_find_xs(isp, sp->req_handle);\n\t\tif (xs == NULL) {\n\t\t\tPRINTF(\"%s: NULL xs in xflist (handle 0x%x)\\n\",\n\t\t\t    isp->isp_name, sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, sp->req_handle);\n\t\tif (sp->req_status_flags & RQSTF_BUS_RESET) {\n\t\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tif (buddaboom) {\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t}\n\t\tXS_STS(xs) = sp->req_scsi_status & 0xff;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data,\n\t\t\t\t\tXS_SNSLEN(xs));\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t}\n\t\t\t/*\n\t\t\t * A new synchronous rate was negotiated for this\n\t\t\t * target. Mark state such that we'll go look up\n\t\t\t * that which has changed later.\n\t\t\t */\n\t\t\tif (sp->req_status_flags & RQSTF_NEGOTIATION) {\n\t\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_refresh = 1;\n\t\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t\t}\n\t\t} else {\n\t\t\tif (sp->req_scsi_status & RQCS_SV) {\n\t\t\t\tint amt = min(XS_SNSLEN(xs), sp->req_sense_len);\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data, amt);\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t\tsp->req_state_flags |= RQSF_GOT_SENSE;\n\t\t\t} else if (XS_STS(xs) == SCSI_CHECK) {\n\t\t\t\tIDPRINTF(1, (\"%s: check condition with no sense\"\n\t\t\t\t    \" data\\n\", isp->isp_name));\n\t\t\t}\n\t\t}\n\t\tif (XS_NOERR(xs) && XS_STS(xs) == SCSI_BUSY) {\n\t\t\tXS_SETERR(xs, HBA_TGTBSY);\n\t\t}\n\n\t\tif (sp->req_header.rqs_entry_type == RQSTYPE_RESPONSE) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t    if (sp->req_completion_status != RQCS_COMPLETE) {\n\t\t\t\tisp_parse_status(isp, sp, xs);\n\t\t\t    } else {\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t    }\n\t\t\t}\n\t\t} else if (sp->req_header.rqs_entry_type == RQSTYPE_REQUEST) {\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\t/*\n\t\t\t\t * Force Queue Full status.\n\t\t\t\t */\n\t\t\t\tXS_STS(xs) = SCSI_QFULL;\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t} else if (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t} else {\n\t\t\tPRINTF(\"%s: unhandled respose queue type 0x%x\\n\",\n\t\t\t    isp->isp_name, sp->req_header.rqs_entry_type);\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t}\n\t\tif (IS_SCSI(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t} else if (sp->req_scsi_status & RQCS_RU) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t\tIDPRINTF(4, (\"%s: cnt %d rsd %d\\n\", isp->isp_name,\n\t\t\t\tXS_XFRLEN(xs), sp->req_resid));\n\t\t}\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, sp->req_handle);\n\t\t}\n\t\t/*\n\t\t * Let the platforms cope.\n\t\t */\n#if\t0\n\t\t/*\n\t\t * XXX: If we have a check condition, but no Sense Data,\n\t\t * XXX: mark it as an error (ARQ failed). We need to\n\t\t * XXX: to do a more distinct job because there may\n\t\t * XXX: cases where ARQ is disabled.\n\t\t */\n\t\tif (XS_STS(xs) == SCSI_CHECK && !(XS_IS_SNS_VALID(xs))) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tPRINTF(\"%s: ARQ failure for target %d lun %d\\n\",\n\t\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\t\t\tXS_SETERR(xs, HBA_ARQFAIL);\n\t\t\t}\n\t\t}\n#endif\n\t\tif ((isp->isp_dblev >= 5) ||\n\t\t    (isp->isp_dblev > 2 && !XS_NOERR(xs))) {\n\t\t\tPRINTF(\"%s(%d.%d): FIN dl%d resid%d STS %x\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_XFRLEN(xs), XS_RESID(xs), XS_STS(xs));\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tPRINTF(\" Skey: %x\", XS_SNSKEY(xs));\n\t\t\t\tif (!(XS_IS_SNS_VALID(xs))) {\n\t\t\t\t\tPRINTF(\" BUT NOT SET\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tPRINTF(\" XS_ERR=0x%x\\n\", (unsigned int) XS_ERR(xs));\n\t\t}\n\n\t\tif (isp->isp_nactive > 0)\n\t\t    isp->isp_nactive--;\n\t\tcomplist[ndone++] = xs;\t/* defer completion call until later */\n\t}\n\n\t/*\n\t * If we looked at any commands, then it's valid to find out\n\t * what the outpointer is. It also is a trigger to update the\n\t * ISP's notion of what we've seen so far.\n\t */\n\tif (nlooked) {\n\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\tisp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\t}\n\tisp->isp_residx = optr;\n\tfor (i = 0; i < ndone; i++) {\n\t\txs = complist[i];\n\t\tif (xs) {\n\t\t\tXS_CMD_DONE(xs);\n\t\t}\n\t}\n\tENABLE_INTS(isp);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "pci->pci_dmat",
            "pci->pci_result_dmap",
            "BUS_DMASYNC_POSTREAD"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic int isp_pci_intr;\n\nstatic int\nisp_pci_intr(arg)\n\tvoid *arg;\n{\n\tstruct isp_pcisoftc *pci = (struct isp_pcisoftc *)arg;\n\tbus_dmamap_sync(pci->pci_dmat, pci->pci_result_dmap,\n\t    BUS_DMASYNC_POSTREAD);\n\treturn (isp_intr(arg));\n}"
  },
  {
    "function_name": "isp_pci_dmasetup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "811-909",
    "snippet": "static int\nisp_pci_dmasetup(isp, xs, rq, iptrp, optr)\n\tstruct ispsoftc *isp;\n\tstruct scsi_xfer *xs;\n\tispreq_t *rq;\n\tu_int16_t *iptrp;\n\tu_int16_t optr;\n{\n\tstruct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;\n\tbus_dmamap_t dmap = pci->pci_xfer_dmap[rq->req_handle - 1];\n\tispcontreq_t *crq;\n\tint segcnt, seg, error, ovseg, seglim, drq;\n\n\tif (xs->datalen == 0) {\n\t\trq->req_seg_count = 1;\n\t\tgoto mbxsync;\n\t}\n\tassert(rq->req_handle != 0 && rq->req_handle <= isp->isp_maxcmds);\n\n\tif (xs->flags & SCSI_DATA_IN) {\n\t\tdrq = REQFLAG_DATA_IN;\n\t} else {\n\t\tdrq = REQFLAG_DATA_OUT;\n\t}\n\n\tif (IS_FC(isp)) {\n\t\tseglim = ISP_RQDSEG_T2;\n\t\t((ispreqt2_t *)rq)->req_totalcnt = xs->datalen;\n\t\t((ispreqt2_t *)rq)->req_flags |= drq;\n\t} else {\n\t\tif (XS_CDBLEN(xs) > 12)\n\t\t\tseglim = 0;\n\t\telse\n\t\t\tseglim = ISP_RQDSEG;\n\t\trq->req_flags |= drq;\n\t}\n\terror = bus_dmamap_load(pci->pci_dmat, dmap, xs->data, xs->datalen,\n\t    NULL, xs->flags & SCSI_NOSLEEP ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\tif (error) {\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\tsegcnt = dmap->dm_nsegs;\n\n\tfor (seg = 0, rq->req_seg_count = 0;\n\t     seg < segcnt && rq->req_seg_count < seglim;\n\t     seg++, rq->req_seg_count++) {\n\t\tif (isp->isp_type & ISP_HA_FC) {\n\t\t\tispreqt2_t *rq2 = (ispreqt2_t *)rq;\n\t\t\trq2->req_dataseg[rq2->req_seg_count].ds_count =\n\t\t\t    dmap->dm_segs[seg].ds_len;\n\t\t\trq2->req_dataseg[rq2->req_seg_count].ds_base =\n\t\t\t    dmap->dm_segs[seg].ds_addr;\n\t\t} else {\n\t\t\trq->req_dataseg[rq->req_seg_count].ds_count =\n\t\t\t    dmap->dm_segs[seg].ds_len;\n\t\t\trq->req_dataseg[rq->req_seg_count].ds_base =\n\t\t\t    dmap->dm_segs[seg].ds_addr;\n\t\t}\n\t}\n\n\tif (seg == segcnt)\n\t\tgoto dmasync;\n\n\tdo {\n\t\tcrq = (ispcontreq_t *)\n\t\t\tISP_QUEUE_ENTRY(isp->isp_rquest, *iptrp);\n\t\t*iptrp = (*iptrp + 1) & (RQUEST_QUEUE_LEN - 1);\n\t\tif (*iptrp == optr) {\n\t\t\tprintf(\"%s: Request Queue Overflow++\\n\", isp->isp_name);\n\t\t\tbus_dmamap_unload(pci->pci_dmat, dmap);\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\trq->req_header.rqs_entry_count++;\n\t\tbzero((void *)crq, sizeof (*crq));\n\t\tcrq->req_header.rqs_entry_count = 1;\n\t\tcrq->req_header.rqs_entry_type = RQSTYPE_DATASEG;\n\n\t\tfor (ovseg = 0; seg < segcnt && ovseg < ISP_CDSEG;\n\t\t    rq->req_seg_count++, seg++, ovseg++) {\n\t\t\tcrq->req_dataseg[ovseg].ds_count =\n\t\t\t    dmap->dm_segs[seg].ds_len;\n\t\t\tcrq->req_dataseg[ovseg].ds_base =\n\t\t\t    dmap->dm_segs[seg].ds_addr;\n\t\t}\n\t} while (seg < segcnt);\n\ndmasync:\n\tbus_dmamap_sync(pci->pci_dmat, dmap, (xs->flags & SCSI_DATA_IN) ?\n\t    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);\n\nmbxsync:\n\tISP_SWIZZLE_REQUEST(isp, rq);\n\tbus_dmamap_sync(pci->pci_dmat, pci->pci_rquest_dmap,\n\t    BUS_DMASYNC_PREWRITE);\n\treturn (CMD_QUEUED);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int isp_pci_dmasetup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "pci->pci_dmat",
            "pci->pci_rquest_dmap",
            "BUS_DMASYNC_PREWRITE"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SWIZZLE_REQUEST",
          "args": [
            "isp",
            "rq"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "pci->pci_dmat",
            "dmap",
            "(xs->flags & SCSI_DATA_IN) ?\n\t    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(void *)crq",
            "sizeof (*crq)"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "pci->pci_dmat",
            "dmap"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Request Queue Overflow++\\n\"",
            "isp->isp_name"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_QUEUE_ENTRY",
          "args": [
            "isp->isp_rquest",
            "*iptrp"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "pci->pci_dmat",
            "dmap",
            "xs->data",
            "xs->datalen",
            "NULL",
            "xs->flags & SCSI_NOSLEEP ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CDBLEN",
          "args": [
            "xs"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "rq->req_handle != 0 && rq->req_handle <= isp->isp_maxcmds"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic int isp_pci_dmasetup;\n\nstatic int\nisp_pci_dmasetup(isp, xs, rq, iptrp, optr)\n\tstruct ispsoftc *isp;\n\tstruct scsi_xfer *xs;\n\tispreq_t *rq;\n\tu_int16_t *iptrp;\n\tu_int16_t optr;\n{\n\tstruct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;\n\tbus_dmamap_t dmap = pci->pci_xfer_dmap[rq->req_handle - 1];\n\tispcontreq_t *crq;\n\tint segcnt, seg, error, ovseg, seglim, drq;\n\n\tif (xs->datalen == 0) {\n\t\trq->req_seg_count = 1;\n\t\tgoto mbxsync;\n\t}\n\tassert(rq->req_handle != 0 && rq->req_handle <= isp->isp_maxcmds);\n\n\tif (xs->flags & SCSI_DATA_IN) {\n\t\tdrq = REQFLAG_DATA_IN;\n\t} else {\n\t\tdrq = REQFLAG_DATA_OUT;\n\t}\n\n\tif (IS_FC(isp)) {\n\t\tseglim = ISP_RQDSEG_T2;\n\t\t((ispreqt2_t *)rq)->req_totalcnt = xs->datalen;\n\t\t((ispreqt2_t *)rq)->req_flags |= drq;\n\t} else {\n\t\tif (XS_CDBLEN(xs) > 12)\n\t\t\tseglim = 0;\n\t\telse\n\t\t\tseglim = ISP_RQDSEG;\n\t\trq->req_flags |= drq;\n\t}\n\terror = bus_dmamap_load(pci->pci_dmat, dmap, xs->data, xs->datalen,\n\t    NULL, xs->flags & SCSI_NOSLEEP ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK);\n\tif (error) {\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\tsegcnt = dmap->dm_nsegs;\n\n\tfor (seg = 0, rq->req_seg_count = 0;\n\t     seg < segcnt && rq->req_seg_count < seglim;\n\t     seg++, rq->req_seg_count++) {\n\t\tif (isp->isp_type & ISP_HA_FC) {\n\t\t\tispreqt2_t *rq2 = (ispreqt2_t *)rq;\n\t\t\trq2->req_dataseg[rq2->req_seg_count].ds_count =\n\t\t\t    dmap->dm_segs[seg].ds_len;\n\t\t\trq2->req_dataseg[rq2->req_seg_count].ds_base =\n\t\t\t    dmap->dm_segs[seg].ds_addr;\n\t\t} else {\n\t\t\trq->req_dataseg[rq->req_seg_count].ds_count =\n\t\t\t    dmap->dm_segs[seg].ds_len;\n\t\t\trq->req_dataseg[rq->req_seg_count].ds_base =\n\t\t\t    dmap->dm_segs[seg].ds_addr;\n\t\t}\n\t}\n\n\tif (seg == segcnt)\n\t\tgoto dmasync;\n\n\tdo {\n\t\tcrq = (ispcontreq_t *)\n\t\t\tISP_QUEUE_ENTRY(isp->isp_rquest, *iptrp);\n\t\t*iptrp = (*iptrp + 1) & (RQUEST_QUEUE_LEN - 1);\n\t\tif (*iptrp == optr) {\n\t\t\tprintf(\"%s: Request Queue Overflow++\\n\", isp->isp_name);\n\t\t\tbus_dmamap_unload(pci->pci_dmat, dmap);\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\trq->req_header.rqs_entry_count++;\n\t\tbzero((void *)crq, sizeof (*crq));\n\t\tcrq->req_header.rqs_entry_count = 1;\n\t\tcrq->req_header.rqs_entry_type = RQSTYPE_DATASEG;\n\n\t\tfor (ovseg = 0; seg < segcnt && ovseg < ISP_CDSEG;\n\t\t    rq->req_seg_count++, seg++, ovseg++) {\n\t\t\tcrq->req_dataseg[ovseg].ds_count =\n\t\t\t    dmap->dm_segs[seg].ds_len;\n\t\t\tcrq->req_dataseg[ovseg].ds_base =\n\t\t\t    dmap->dm_segs[seg].ds_addr;\n\t\t}\n\t} while (seg < segcnt);\n\ndmasync:\n\tbus_dmamap_sync(pci->pci_dmat, dmap, (xs->flags & SCSI_DATA_IN) ?\n\t    BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);\n\nmbxsync:\n\tISP_SWIZZLE_REQUEST(isp, rq);\n\tbus_dmamap_sync(pci->pci_dmat, pci->pci_rquest_dmap,\n\t    BUS_DMASYNC_PREWRITE);\n\treturn (CMD_QUEUED);\n}"
  },
  {
    "function_name": "isp_pci_mbxdma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "734-809",
    "snippet": "static int\nisp_pci_mbxdma(isp)\n\tstruct ispsoftc *isp;\n{\n\tstruct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;\n\tbus_dma_segment_t seg;\n\tbus_size_t len;\n\tfcparam *fcp;\n\tint rseg;\n\n\tif (isp->isp_rquest_dma)\t/* been here before? */\n\t\treturn (0);\n\n\tlen = isp->isp_maxcmds * sizeof (ISP_SCSI_XFER_T);\n\tisp->isp_xflist = (ISP_SCSI_XFER_T **) malloc(len, M_DEVBUF, M_WAITOK);\n\tif (isp->isp_xflist == NULL) {\n\t\tprintf(\"%s: cannot malloc xflist array\\n\", isp->isp_name);\n\t\treturn (1);\n\t}\n\tbzero(isp->isp_xflist, len);\n\tlen = isp->isp_maxcmds * sizeof (bus_dmamap_t);\n\tpci->pci_xfer_dmap = (bus_dmamap_t *) malloc(len, M_DEVBUF, M_WAITOK);\n\tif (pci->pci_xfer_dmap == NULL) {\n\t\tprintf(\"%s: cannot dma xfer map array\\n\", isp->isp_name);\n\t\treturn (1);\n\t}\n\n\t/*\n\t * Allocate and map the request queue.\n\t */\n\tlen = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN);\n\tif (bus_dmamem_alloc(pci->pci_dmat, len, NBPG, 0, &seg, 1, &rseg,\n\t      BUS_DMA_NOWAIT) || bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,\n\t      (caddr_t *)&isp->isp_rquest, BUS_DMA_NOWAIT|BUS_DMA_COHERENT))\n\t\treturn (1);\n\tif (bus_dmamap_create(pci->pci_dmat, len, 1, len, 0, BUS_DMA_NOWAIT,\n\t      &pci->pci_rquest_dmap) ||\n\t    bus_dmamap_load(pci->pci_dmat, pci->pci_rquest_dmap,\n\t      (caddr_t)isp->isp_rquest, len, NULL, BUS_DMA_NOWAIT))\n\t\treturn (1);\n\n\tisp->isp_rquest_dma = pci->pci_rquest_dmap->dm_segs[0].ds_addr;\n\n\t/*\n\t * Allocate and map the result queue.\n\t */\n\tlen = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN);\n\tif (bus_dmamem_alloc(pci->pci_dmat, len, NBPG, 0, &seg, 1, &rseg,\n\t      BUS_DMA_NOWAIT) || bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,\n\t      (caddr_t *)&isp->isp_result, BUS_DMA_NOWAIT|BUS_DMA_COHERENT))\n\t\treturn (1);\n\tif (bus_dmamap_create(pci->pci_dmat, len, 1, len, 0, BUS_DMA_NOWAIT,\n\t      &pci->pci_result_dmap) ||\n\t    bus_dmamap_load(pci->pci_dmat, pci->pci_result_dmap,\n\t      (caddr_t)isp->isp_result, len, NULL, BUS_DMA_NOWAIT))\n\t\treturn (1);\n\tisp->isp_result_dma = pci->pci_result_dmap->dm_segs[0].ds_addr;\n\n\tif (IS_SCSI(isp)) {\n\t\treturn (0);\n\t}\n\n\tfcp = isp->isp_param;\n\tlen = ISP2100_SCRLEN;\n\tif (bus_dmamem_alloc(pci->pci_dmat, len, NBPG, 0, &seg, 1, &rseg,\n\t    BUS_DMA_NOWAIT) || bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,\n\t      (caddr_t *)&fcp->isp_scratch, BUS_DMA_NOWAIT|BUS_DMA_COHERENT))\n\t\treturn (1);\n\tif (bus_dmamap_create(pci->pci_dmat, len, 1, len, 0, BUS_DMA_NOWAIT,\n\t    &pci->pci_scratch_dmap) || bus_dmamap_load(pci->pci_dmat,\n\t    pci->pci_scratch_dmap, (caddr_t)fcp->isp_scratch, len, NULL,\n\t    BUS_DMA_NOWAIT))\n\t\treturn (1);\n\tfcp->isp_scdma = pci->pci_scratch_dmap->dm_segs[0].ds_addr;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [
      "#define\tBUS_DMA_COHERENT\tBUS_DMAMEM_NOSYNC"
    ],
    "globals_used": [
      "static int isp_pci_mbxdma"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "pci->pci_dmat",
            "pci->pci_scratch_dmap",
            "(caddr_t)fcp->isp_scratch",
            "len",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "pci->pci_dmat",
            "len",
            "1",
            "len",
            "0",
            "BUS_DMA_NOWAIT",
            "&pci->pci_scratch_dmap"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "pci->pci_dmat",
            "&seg",
            "rseg",
            "len",
            "(caddr_t *)&fcp->isp_scratch",
            "BUS_DMA_NOWAIT|BUS_DMA_COHERENT"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "pci->pci_dmat",
            "len",
            "NBPG",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "pci->pci_dmat",
            "pci->pci_result_dmap",
            "(caddr_t)isp->isp_result",
            "len",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "pci->pci_dmat",
            "len",
            "1",
            "len",
            "0",
            "BUS_DMA_NOWAIT",
            "&pci->pci_result_dmap"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "pci->pci_dmat",
            "&seg",
            "rseg",
            "len",
            "(caddr_t *)&isp->isp_result",
            "BUS_DMA_NOWAIT|BUS_DMA_COHERENT"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "pci->pci_dmat",
            "len",
            "NBPG",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_QUEUE_SIZE",
          "args": [
            "RESULT_QUEUE_LEN"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "pci->pci_dmat",
            "pci->pci_rquest_dmap",
            "(caddr_t)isp->isp_rquest",
            "len",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "pci->pci_dmat",
            "len",
            "1",
            "len",
            "0",
            "BUS_DMA_NOWAIT",
            "&pci->pci_rquest_dmap"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "pci->pci_dmat",
            "&seg",
            "rseg",
            "len",
            "(caddr_t *)&isp->isp_rquest",
            "BUS_DMA_NOWAIT|BUS_DMA_COHERENT"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "pci->pci_dmat",
            "len",
            "NBPG",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_QUEUE_SIZE",
          "args": [
            "RQUEST_QUEUE_LEN"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: cannot dma xfer map array\\n\"",
            "isp->isp_name"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "isp->isp_xflist",
            "len"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\n#define\tBUS_DMA_COHERENT\tBUS_DMAMEM_NOSYNC\n\nstatic int isp_pci_mbxdma;\n\nstatic int\nisp_pci_mbxdma(isp)\n\tstruct ispsoftc *isp;\n{\n\tstruct isp_pcisoftc *pci = (struct isp_pcisoftc *)isp;\n\tbus_dma_segment_t seg;\n\tbus_size_t len;\n\tfcparam *fcp;\n\tint rseg;\n\n\tif (isp->isp_rquest_dma)\t/* been here before? */\n\t\treturn (0);\n\n\tlen = isp->isp_maxcmds * sizeof (ISP_SCSI_XFER_T);\n\tisp->isp_xflist = (ISP_SCSI_XFER_T **) malloc(len, M_DEVBUF, M_WAITOK);\n\tif (isp->isp_xflist == NULL) {\n\t\tprintf(\"%s: cannot malloc xflist array\\n\", isp->isp_name);\n\t\treturn (1);\n\t}\n\tbzero(isp->isp_xflist, len);\n\tlen = isp->isp_maxcmds * sizeof (bus_dmamap_t);\n\tpci->pci_xfer_dmap = (bus_dmamap_t *) malloc(len, M_DEVBUF, M_WAITOK);\n\tif (pci->pci_xfer_dmap == NULL) {\n\t\tprintf(\"%s: cannot dma xfer map array\\n\", isp->isp_name);\n\t\treturn (1);\n\t}\n\n\t/*\n\t * Allocate and map the request queue.\n\t */\n\tlen = ISP_QUEUE_SIZE(RQUEST_QUEUE_LEN);\n\tif (bus_dmamem_alloc(pci->pci_dmat, len, NBPG, 0, &seg, 1, &rseg,\n\t      BUS_DMA_NOWAIT) || bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,\n\t      (caddr_t *)&isp->isp_rquest, BUS_DMA_NOWAIT|BUS_DMA_COHERENT))\n\t\treturn (1);\n\tif (bus_dmamap_create(pci->pci_dmat, len, 1, len, 0, BUS_DMA_NOWAIT,\n\t      &pci->pci_rquest_dmap) ||\n\t    bus_dmamap_load(pci->pci_dmat, pci->pci_rquest_dmap,\n\t      (caddr_t)isp->isp_rquest, len, NULL, BUS_DMA_NOWAIT))\n\t\treturn (1);\n\n\tisp->isp_rquest_dma = pci->pci_rquest_dmap->dm_segs[0].ds_addr;\n\n\t/*\n\t * Allocate and map the result queue.\n\t */\n\tlen = ISP_QUEUE_SIZE(RESULT_QUEUE_LEN);\n\tif (bus_dmamem_alloc(pci->pci_dmat, len, NBPG, 0, &seg, 1, &rseg,\n\t      BUS_DMA_NOWAIT) || bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,\n\t      (caddr_t *)&isp->isp_result, BUS_DMA_NOWAIT|BUS_DMA_COHERENT))\n\t\treturn (1);\n\tif (bus_dmamap_create(pci->pci_dmat, len, 1, len, 0, BUS_DMA_NOWAIT,\n\t      &pci->pci_result_dmap) ||\n\t    bus_dmamap_load(pci->pci_dmat, pci->pci_result_dmap,\n\t      (caddr_t)isp->isp_result, len, NULL, BUS_DMA_NOWAIT))\n\t\treturn (1);\n\tisp->isp_result_dma = pci->pci_result_dmap->dm_segs[0].ds_addr;\n\n\tif (IS_SCSI(isp)) {\n\t\treturn (0);\n\t}\n\n\tfcp = isp->isp_param;\n\tlen = ISP2100_SCRLEN;\n\tif (bus_dmamem_alloc(pci->pci_dmat, len, NBPG, 0, &seg, 1, &rseg,\n\t    BUS_DMA_NOWAIT) || bus_dmamem_map(pci->pci_dmat, &seg, rseg, len,\n\t      (caddr_t *)&fcp->isp_scratch, BUS_DMA_NOWAIT|BUS_DMA_COHERENT))\n\t\treturn (1);\n\tif (bus_dmamap_create(pci->pci_dmat, len, 1, len, 0, BUS_DMA_NOWAIT,\n\t    &pci->pci_scratch_dmap) || bus_dmamap_load(pci->pci_dmat,\n\t    pci->pci_scratch_dmap, (caddr_t)fcp->isp_scratch, len, NULL,\n\t    BUS_DMA_NOWAIT))\n\t\treturn (1);\n\tfcp->isp_scdma = pci->pci_scratch_dmap->dm_segs[0].ds_addr;\n\treturn (0);\n}"
  },
  {
    "function_name": "isp_pci_wr_reg_1080",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "691-731",
    "snippet": "static void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int16_t isp_pci_rd_reg",
      "static void isp_pci_wr_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "250"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_pci_wr_reg",
          "args": [
            "isp",
            "BIU_CONF1",
            "oc"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pci_wr_reg_1080",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
          "lines": "691-731",
          "snippet": "static void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "pcs->pci_st",
            "pcs->pci_sh",
            "offset",
            "val"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_pci_rd_reg",
          "args": [
            "isp",
            "BIU_CONF1"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pci_rd_reg_1080",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
          "lines": "649-689",
          "snippet": "static u_int16_t\nisp_pci_rd_reg_1080(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv, oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/microcode/isp/asm_pci.h>",
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t isp_pci_rd_reg",
            "static void isp_pci_wr_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic u_int16_t\nisp_pci_rd_reg_1080(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv, oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_12X0",
          "args": [
            "isp"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}"
  },
  {
    "function_name": "isp_pci_rd_reg_1080",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "649-689",
    "snippet": "static u_int16_t\nisp_pci_rd_reg_1080(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv, oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int16_t isp_pci_rd_reg",
      "static void isp_pci_wr_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "250"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_pci_wr_reg",
          "args": [
            "isp",
            "BIU_CONF1",
            "oc"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pci_wr_reg_1080",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
          "lines": "691-731",
          "snippet": "static void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/microcode/isp/asm_pci.h>",
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t isp_pci_rd_reg",
            "static void isp_pci_wr_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "pcs->pci_st",
            "pcs->pci_sh",
            "offset"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_pci_rd_reg",
          "args": [
            "isp",
            "BIU_CONF1"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pci_rd_reg_1080",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
          "lines": "649-689",
          "snippet": "static u_int16_t\nisp_pci_rd_reg_1080(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv, oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "IS_12X0",
          "args": [
            "isp"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic u_int16_t\nisp_pci_rd_reg_1080(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv, oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}"
  },
  {
    "function_name": "isp_pci_wr_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "622-646",
    "snippet": "static void\nisp_pci_wr_reg(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset, oldconf = 0;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toldconf = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oldconf | BIU_PCI_CONF1_SXP);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oldconf);\n\t\tdelay(250);\n\t}\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int16_t isp_pci_rd_reg",
      "static void isp_pci_wr_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "250"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_pci_wr_reg",
          "args": [
            "isp",
            "BIU_CONF1",
            "oldconf"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pci_wr_reg_1080",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
          "lines": "691-731",
          "snippet": "static void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/microcode/isp/asm_pci.h>",
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t isp_pci_rd_reg",
            "static void isp_pci_wr_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "pcs->pci_st",
            "pcs->pci_sh",
            "offset",
            "val"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_pci_rd_reg",
          "args": [
            "isp",
            "BIU_CONF1"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pci_rd_reg_1080",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
          "lines": "649-689",
          "snippet": "static u_int16_t\nisp_pci_rd_reg_1080(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv, oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/microcode/isp/asm_pci.h>",
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t isp_pci_rd_reg",
            "static void isp_pci_wr_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic u_int16_t\nisp_pci_rd_reg_1080(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv, oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic void\nisp_pci_wr_reg(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset, oldconf = 0;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toldconf = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oldconf | BIU_PCI_CONF1_SXP);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oldconf);\n\t\tdelay(250);\n\t}\n}"
  },
  {
    "function_name": "isp_pci_rd_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "595-620",
    "snippet": "static u_int16_t\nisp_pci_rd_reg(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset, oldconf = 0;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toldconf = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oldconf | BIU_PCI_CONF1_SXP);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oldconf);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int16_t isp_pci_rd_reg",
      "static void isp_pci_wr_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "250"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_pci_wr_reg",
          "args": [
            "isp",
            "BIU_CONF1",
            "oldconf"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pci_wr_reg_1080",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
          "lines": "691-731",
          "snippet": "static void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/microcode/isp/asm_pci.h>",
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t isp_pci_rd_reg",
            "static void isp_pci_wr_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic void\nisp_pci_wr_reg_1080(isp, regoff, val)\n\tstruct ispsoftc *isp;\n\tint regoff;\n\tu_int16_t val;\n{\n\tu_int16_t oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\tbus_space_write_2(pcs->pci_st, pcs->pci_sh, offset, val);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "pcs->pci_st",
            "pcs->pci_sh",
            "offset"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_pci_rd_reg",
          "args": [
            "isp",
            "BIU_CONF1"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "isp_pci_rd_reg_1080",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
          "lines": "649-689",
          "snippet": "static u_int16_t\nisp_pci_rd_reg_1080(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv, oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/microcode/isp/asm_pci.h>",
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t isp_pci_rd_reg",
            "static void isp_pci_wr_reg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic u_int16_t\nisp_pci_rd_reg_1080(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv, oc = 0;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK ||\n\t    (regoff & _BLK_REG_MASK) == (SXP_BLOCK|SXP_BANK1_SELECT)) {\n\t\tu_int16_t tc;\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\ttc = oc & ~(BIU_PCI1080_CONF1_DMA|BIU_PCI_CONF1_SXP);\n\t\tif (IS_12X0(isp)) {\n\t\t\tif (regoff & SXP_BANK1_SELECT)\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t\telse\n\t\t\t\ttc |= BIU_PCI1080_CONF1_SXP1;\n\t\t} else {\n\t\t\ttc |= BIU_PCI1080_CONF1_SXP0;\n\t\t}\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, tc);\n\t\tdelay(250);\n\t} else if ((regoff & _BLK_REG_MASK) == DMA_BLOCK) {\n\t\toc = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc | BIU_PCI1080_CONF1_DMA);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif (oc) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oc);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\nstatic u_int16_t isp_pci_rd_reg;\nstatic void isp_pci_wr_reg;\n\nstatic u_int16_t\nisp_pci_rd_reg(isp, regoff)\n\tstruct ispsoftc *isp;\n\tint regoff;\n{\n\tu_int16_t rv;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) isp;\n\tint offset, oldconf = 0;\n\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {\n\t\t/*\n\t\t * We will assume that someone has paused the RISC processor.\n\t\t */\n\t\toldconf = isp_pci_rd_reg(isp, BIU_CONF1);\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oldconf | BIU_PCI_CONF1_SXP);\n\t\tdelay(250);\n\t}\n\toffset = pcs->pci_poff[(regoff & _BLK_REG_MASK) >> _BLK_REG_SHFT];\n\toffset += (regoff & 0xff);\n\trv = bus_space_read_2(pcs->pci_st, pcs->pci_sh, offset);\n\tif ((regoff & _BLK_REG_MASK) == SXP_BLOCK) {\n\t\tisp_pci_wr_reg(isp, BIU_CONF1, oldconf);\n\t\tdelay(250);\n\t}\n\treturn (rv);\n}"
  },
  {
    "function_name": "isp_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "279-593",
    "snippet": "static void    \nisp_pci_attach(parent, self, aux)\n        struct device *parent, *self;\n        void *aux;\n{\n#ifdef\tDEBUG\n\tstatic char oneshot = 1;\n#endif\n\tu_int32_t data, rev, linesz = PCI_DFLT_LNSZ;\n\tstruct pci_attach_args *pa = aux;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) self;\n\tstruct ispsoftc *isp = &pcs->pci_isp;\n\tbus_space_tag_t st, iot, memt;\n\tbus_space_handle_t sh, ioh, memh;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr;\n\tint ioh_valid, memh_valid, i, s;\n\tbus_addr_t iobase, mbase;\n\tbus_size_t iosize, msize;\n\n\tioh_valid = memh_valid = 0;\n\n#if\tSCSI_ISP_PREFER_MEM_MAP == 1\n\tif (pci_mem_find(pa->pa_pc, pa->pa_tag, MEM_MAP_REG, &mbase, &msize,\n\t    NULL)) {\n\t\tprintf(\": can't find mem space\\n\");\n\t} else if (bus_space_map(pa->pa_memt, mbase, msize, 0, &memh)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t} else  {\n\t\tmemt = pa->pa_memt;\n\t\tst = memt;\n\t\tsh = memh;\n\t\tmemh_valid = 1;\n\t}\n\tif (memh_valid == 0) {\n\t\tif (pci_io_find(pa->pa_pc, pa->pa_tag, IO_MAP_REG, &iobase,\n\t\t    &iosize)) {\n\t\t\tprintf(\": can't find i/o space\\n\");\n\t\t} else if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &ioh)) {\n\t\t\tprintf(\": can't map i/o space\\n\");\n\t\t} else {\n\t\t\tiot = pa->pa_iot;\n\t\t\tst = iot;\n\t\t\tsh = ioh;\n\t\t\tioh_valid = 1;\n\t\t}\n\t}\n#else\n\tif (pci_io_find(pa->pa_pc, pa->pa_tag, IO_MAP_REG, &iobase, &iosize)) {\n\t\tprintf(\": can't find i/o space\\n\");\n\t} else if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &ioh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t} else {\n\t\tiot = pa->pa_iot;\n\t\tst = iot;\n\t\tsh = ioh;\n\t\tioh_valid = 1;\n\t}\n\tif (ioh_valid == 0) {\n\t\tif (pci_mem_find(pa->pa_pc, pa->pa_tag, MEM_MAP_REG, &mbase,\n\t\t    &msize, NULL)) {\n\t\t\tprintf(\": can't find mem space\\n\");\n\t\t} else if (bus_space_map(pa->pa_memt, mbase, msize, 0, &memh)) {\n\t\t\tprintf(\": can't map mem space\\n\");\n\t\t} else  {\n\t\t\tmemt = pa->pa_memt;\n\t\t\tst = memt;\n\t\t\tsh = memh;\n\t\t\tmemh_valid = 1;\n\t\t}\n\t}\n#endif\n\tif (ioh_valid == 0 && memh_valid == 0) {\n\t\tprintf(\": unable to map device registers\\n\");\n\t\treturn;\n\t}\n\tprintf(\"\\n\");\n\n\tpcs->pci_st = st;\n\tpcs->pci_sh = sh;\n\tpcs->pci_dmat = pa->pa_dmat;\n\tpcs->pci_pc = pa->pa_pc;\n\tpcs->pci_tag = pa->pa_tag;\n\tpcs->pci_poff[BIU_BLOCK >> _BLK_REG_SHFT] = BIU_REGS_OFF;\n\tpcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] = PCI_MBOX_REGS_OFF;\n\tpcs->pci_poff[SXP_BLOCK >> _BLK_REG_SHFT] = PCI_SXP_REGS_OFF;\n\tpcs->pci_poff[RISC_BLOCK >> _BLK_REG_SHFT] = PCI_RISC_REGS_OFF;\n\tpcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] = DMA_REGS_OFF;\n\trev = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0xff;\n#ifndef\tISP_DISABLE_1020_SUPPORT\n\tif (pa->pa_id == PCI_QLOGIC_ISP) {\n\t\tisp->isp_mdvec = &mdvec;\n\t\tisp->isp_type = ISP_HA_SCSI_UNKNOWN;\n\t\tisp->isp_param = malloc(sizeof (sdparam), M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate sdparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (sdparam));\n\t}\n#endif\n#ifndef\tISP_DISABLE_1080_SUPPORT\n\tif (pa->pa_id == PCI_QLOGIC_ISP1080) {\n\t\tisp->isp_mdvec = &mdvec_1080;\n\t\tisp->isp_type = ISP_HA_SCSI_1080;\n\t\tisp->isp_param = malloc(sizeof (sdparam), M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate sdparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (sdparam));\n\t\tpcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =\n\t\t    ISP1080_DMA_REGS_OFF;\n\t}\n\tif (pa->pa_id == PCI_QLOGIC_ISP1240) {\n\t\tisp->isp_mdvec = &mdvec_1080;\n\t\tisp->isp_type = ISP_HA_SCSI_1240;\n\t\tisp->isp_param = malloc(2 * sizeof (sdparam),\n\t\t    M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate sdparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (sdparam));\n\t\tpcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =\n\t\t    ISP1080_DMA_REGS_OFF;\n\t}\n\tif (pa->pa_id == PCI_QLOGIC_ISP1280) {\n\t\tisp->isp_mdvec = &mdvec_1080;\n\t\tisp->isp_type = ISP_HA_SCSI_1280;\n\t\tisp->isp_param = malloc(2 * sizeof (sdparam),\n\t\t    M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate sdparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (sdparam));\n\t\tpcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =\n\t\t    ISP1080_DMA_REGS_OFF;\n\t}\n#endif\n#ifndef\tISP_DISABLE_12160_SUPPORT\n\tif (pa->pa_id == PCI_QLOGIC_ISP12160) {\n\t\tisp->isp_mdvec = &mdvec_12160;\n\t\tisp->isp_type = ISP_HA_SCSI_12160;\n\t\tisp->isp_param = malloc(2 * sizeof (sdparam),\n\t\t    M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate sdparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (sdparam));\n\t\tpcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =\n\t\t    ISP1080_DMA_REGS_OFF;\n\t}\n#endif\n#ifndef\tISP_DISABLE_2100_SUPPORT\n\tif (pa->pa_id == PCI_QLOGIC_ISP2100) {\n\t\tisp->isp_mdvec = &mdvec_2100;\n\t\tisp->isp_type = ISP_HA_FC_2100;\n\t\tisp->isp_param = malloc(sizeof (fcparam), M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate fcparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (fcparam));\n\t\tpcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =\n\t\t    PCI_MBOX_REGS2100_OFF;\n\n\t\tif (rev < 3) {\n\t\t\t/*\n\t\t\t * XXX: Need to get the actual revision\n\t\t\t * XXX: number of the 2100 FB. At any rate,\n\t\t\t * XXX: lower cache line size for early revision\n\t\t\t * XXX; boards.\n\t\t\t */\n\t\t\tlinesz = 1;\n\t\t}\n\t}\n#endif\n#ifndef\tISP_DISABLE_2200_SUPPORT\n\tif (pa->pa_id == PCI_QLOGIC_ISP2200) {\n\t\tisp->isp_mdvec = &mdvec_2200;\n\t\tisp->isp_type = ISP_HA_FC_2200;\n\t\tisp->isp_param = malloc(sizeof (fcparam), M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate fcparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (fcparam));\n\t\tpcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =\n\t\t    PCI_MBOX_REGS2100_OFF;\n\t\tdata = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG);\n\t}\n#endif\n\tisp->isp_revision = rev;\n\n\t/*\n\t * Make sure that command register set sanely.\n\t */\n\tdata = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tdata |= PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_INVALIDATE_ENABLE;\n\n\t/*\n\t * Not so sure about these- but I think it's important that they get\n\t * enabled......\n\t */\n\tdata |= PCI_COMMAND_PARITY_ENABLE | PCI_COMMAND_SERR_ENABLE;\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, data);\n\n\t/*\n\t * Make sure that the latency timer, cache line size,\n\t * and ROM is disabled.\n\t */\n\tdata = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);\n\tdata &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);\n\tdata &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);\n\tdata |= (0x40 << PCI_LATTIMER_SHIFT);\n\tdata |= (0x10 << PCI_CACHELINE_SHIFT);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);\n\n\tdata = pci_conf_read(pa->pa_pc, pa->pa_tag, PCIR_ROMADDR);\n\tdata &= ~1;\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCIR_ROMADDR, data);\n\n#ifdef DEBUG\n\tif (oneshot) {\n\t\toneshot = 0;\n\t\tprintf(\"Qlogic ISP Driver, OpenBSD (pci) Platform Version \"\n\t\t    \"%d.%d Core Version %d.%d\\n\",\n\t\t    ISP_PLATFORM_VERSION_MAJOR, ISP_PLATFORM_VERSION_MINOR,\n\t\t    ISP_CORE_VERSION_MAJOR, ISP_CORE_VERSION_MINOR);\n\t}\n#endif\n\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt\\n\", isp->isp_name);\n\t\tfree(isp->isp_param, M_DEVBUF);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pa->pa_pc, ih);\n\tif (intrstr == NULL)\n\t\tintrstr = \"<I dunno>\";\n\tpcs->pci_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, isp_pci_intr,\n\t    isp, isp->isp_name);\n\tif (pcs->pci_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt at %s\\n\",\n\t\t\tisp->isp_name, intrstr);\n\t\tfree(isp->isp_param, M_DEVBUF);\n\t\treturn;\n\t}\n\tprintf(\"%s: interrupting at %s\\n\", isp->isp_name, intrstr);\n\n\tif (IS_FC(isp)) {\n\t\tlong foo;\n\t\t/*\n\t\t * This isn't very random, but it's the best we can do for\n\t\t * the real edge case of cards that don't have WWNs.\n\t\t */\n\t\tfoo = (long) isp;\n\t\tfoo >>= 4;\n\t\tfoo &= 0x7;\n\t\twhile (version[foo])\n\t\t\tisp->isp_osinfo.seed += (int) version[foo++];\n\t\tisp->isp_osinfo.seed <<= 8;\n\t\tisp->isp_osinfo.seed += (isp->isp_osinfo._dev.dv_unit + 1);\n\t}\n\n\ts = splbio();\n\tisp_reset(isp);\n\tif (isp->isp_state != ISP_RESETSTATE) {\n\t\tfree(isp->isp_param, M_DEVBUF);\n\t\t(void) splx(s);\n\t\treturn;\n\t}\n\tisp_init(isp);\n\tif (isp->isp_state != ISP_INITSTATE) {\n\t\tisp_uninit(isp);\n\t\tfree(isp->isp_param, M_DEVBUF);\n\t\t(void) splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Create the DMA maps for the data transfers.\n\t */\n\tfor (i = 0; i < isp->isp_maxcmds; i++) {\n\t\tif (bus_dmamap_create(pcs->pci_dmat, MAXPHYS,\n\t\t    (MAXPHYS / NBPG) + 1, MAXPHYS, 0, BUS_DMA_NOWAIT,\n\t\t    &pcs->pci_xfer_dmap[i])) {\n\t\t\tprintf(\"%s: can't create dma maps\\n\", isp->isp_name);\n\t\t\tisp_uninit(isp);\n\t\t\tfree(isp->isp_param, M_DEVBUF);\n\t\t\t(void) splx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Do Generic attach now.\n\t */\n\tisp_attach(isp);\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tisp_uninit(isp);\n\t\tfree(isp->isp_param, M_DEVBUF);\n\t}\n\t(void) splx(s);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [
      "#define SCSI_ISP_PREFER_MEM_MAP 0",
      "#define\tPCI_DFLT_LNSZ\t0x10",
      "#define\tPCIR_ROMADDR\t0x30",
      "#define MEM_MAP_REG\t0x14",
      "#define IO_MAP_REG\t0x10",
      "#define\tPCI_QLOGIC_ISP2200\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP2200 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP2100\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP2100 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP12160\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP12160 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP1280\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1280 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP1240\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1240 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP1080\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1080 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP\t((PCI_PRODUCT_QLOGIC_ISP1020 << 16) | PCI_VENDOR_QLOGIC)"
    ],
    "globals_used": [
      "static int isp_pci_intr",
      "static void isp_pci_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "isp->isp_param",
            "M_DEVBUF"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "epic_freebsd_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "437-614",
          "snippet": "void\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include <pci/if_txvar.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_mib.h>",
            "#include <dev/pci/if_txvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sockio.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))",
            "#define EPIC_NOIFMEDIA\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\n#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))\n#define EPIC_NOIFMEDIA\t1\n\nvoid\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_uninit",
          "args": [
            "isp"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "isp_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "477-496",
          "snippet": "void\nisp_uninit(isp)\n\tstruct ispsoftc *isp;\n{\n\tint s = splbio();\n\t/*\n\t * Leave with interrupts disabled.\n\t */\n\tDISABLE_INTS(isp);\n\n\t/*\n\t * Turn off the watchdog (if active).\n\t */\n\tif (isp->isp_dogactive) {\n\t\tuntimeout(isp_watch, isp);\n\t\tisp->isp_dogactive = 0;\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_watch"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_watch;\n\nvoid\nisp_uninit(isp)\n\tstruct ispsoftc *isp;\n{\n\tint s = splbio();\n\t/*\n\t * Leave with interrupts disabled.\n\t */\n\tDISABLE_INTS(isp);\n\n\t/*\n\t * Turn off the watchdog (if active).\n\t */\n\tif (isp->isp_dogactive) {\n\t\tuntimeout(isp_watch, isp);\n\t\tisp->isp_dogactive = 0;\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_attach",
          "args": [
            "isp"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "isp_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "70-186",
          "snippet": "void\nisp_attach(isp)\n\tstruct ispsoftc *isp;\n{\n\tstruct scsi_link *lptr = &isp->isp_osinfo._link[0];\n\tisp->isp_osinfo._adapter.scsi_minphys = ispminphys;\n\n\tisp->isp_state = ISP_RUNSTATE;\n\n\t/*\n\t * We only manage a single wait queues for dual bus controllers.\n\t * This is arguably broken.\n\t */\n\tisp->isp_osinfo.wqf = isp->isp_osinfo.wqt = NULL;\n\n\tlptr->adapter_softc = isp;\n\tlptr->device = &isp_dev;\n\tlptr->adapter = &isp->isp_osinfo._adapter;\n\tlptr->openings = isp->isp_maxcmds;\n\tif (IS_FC(isp)) {\n\t\tisp->isp_osinfo._adapter.scsi_cmd = ispcmd;\n\t\tlptr->adapter_buswidth = MAX_FC_TARG;\n\t\t/* We can set max lun width here */\n\t\t/* loopid set below */\n\t} else {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tisp->isp_osinfo._adapter.scsi_cmd = ispcmd_slow;\n\t\tlptr->adapter_buswidth = MAX_TARGETS;\n\t\t/* We can set max lun width here */\n\t\tlptr->adapter_target = sdp->isp_initiator_id;\n\t\tisp->isp_osinfo.discovered[0] = 1 << sdp->isp_initiator_id;\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tstruct scsi_link *lptrb = &isp->isp_osinfo._link[1];\n\t\t\tlptrb->adapter_softc = isp;\n\t\t\tlptrb->device = &isp_dev;\n\t\t\tlptrb->adapter = &isp->isp_osinfo._adapter;\n\t\t\tlptrb->openings = isp->isp_maxcmds;\n\t\t\tlptrb->adapter_buswidth = MAX_TARGETS;\n\t\t\tlptrb->adapter_target = sdp->isp_initiator_id;\n\t\t\tlptrb->flags = SDEV_2NDBUS;\n\t\t\tisp->isp_osinfo.discovered[1] =\n\t\t\t    1 << (sdp+1)->isp_initiator_id;\n\t\t}\n\t}\n\n\t/*\n\t * Send a SCSI Bus Reset (used to be done as part of attach,\n\t * but now left to the OS outer layers).\n\t *\n\t * We don't do 'bus resets' for FC because the LIP that occurs\n\t * when we start the firmware does all that for us.\n\t */\n\tif (IS_SCSI(isp)) {\n\t\tint bus = 0;\n\t\t(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tbus++;\n\t\t\t(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);\n\t\t}\n\t\t/*\n\t\t * wait for the bus to settle.\n\t\t */\n\t\tprintf(\"%s: waiting 4 seconds for bus reset settling\\n\",\n\t\t    isp->isp_name);\n\t\tdelay(4 * 1000000);\n\t} else {\n\t\tint i, j;\n\t\tfcparam *fcp = isp->isp_param;\n\t\t/*\n\t\t * wait for the loop to settle.\n\t\t */\n\t\tprintf(\"%s: waiting 2 seconds for loop reset settling\\n\",\n\t\t    isp->isp_name);\n\t\tdelay(2 * 1000000);\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (isp_control(isp, ISPCTL_FCLINK_TEST, NULL))\n\t\t\t\t\tcontinue;\n#ifdef\tISP2100_FABRIC\n\t\t\t\t/*\n\t\t\t\t * Wait extra time to see if the f/w\n\t\t\t\t * eventually completed an FLOGI that\n\t\t\t\t * will allow us to know we're on a\n\t\t\t\t * fabric.\n\t\t\t\t */\n\t\t\t\tif (fcp->isp_onfabric == 0) {\n\t\t\t\t\tdelay(1 * 1000000);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fcp->isp_fwstate == FW_READY &&\n\t\t\t    fcp->isp_loopstate >= LOOP_PDB_RCVD) { \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlptr->adapter_target = fcp->isp_loopid;\n\t}\n\n\t/*\n\t * Start the watchdog.\n\t *\n\t * The watchdog will, ridiculously enough, also enable Sync negotiation.\n\t */\n\tisp->isp_dogactive = 1;\n\ttimeout(isp_watch, isp, WATCH_INTERVAL * hz);\n\n\t/*\n\t * And attach children (if any).\n\t */\n\tconfig_found((void *)isp, lptr, scsiprint);\n\tif (IS_DUALBUS(isp)) {\n\t\tlptr++;\n\t\tconfig_found((void *)isp, lptr, scsiprint);\n\t}\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ispminphys",
            "static int32_t ispcmd_slow",
            "static int32_t ispcmd",
            "static struct scsi_device isp_dev = { NULL, NULL, NULL, NULL };",
            "static void isp_watch"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void ispminphys;\nstatic int32_t ispcmd_slow;\nstatic int32_t ispcmd;\nstatic struct scsi_device isp_dev = { NULL, NULL, NULL, NULL };\nstatic void isp_watch;\n\nvoid\nisp_attach(isp)\n\tstruct ispsoftc *isp;\n{\n\tstruct scsi_link *lptr = &isp->isp_osinfo._link[0];\n\tisp->isp_osinfo._adapter.scsi_minphys = ispminphys;\n\n\tisp->isp_state = ISP_RUNSTATE;\n\n\t/*\n\t * We only manage a single wait queues for dual bus controllers.\n\t * This is arguably broken.\n\t */\n\tisp->isp_osinfo.wqf = isp->isp_osinfo.wqt = NULL;\n\n\tlptr->adapter_softc = isp;\n\tlptr->device = &isp_dev;\n\tlptr->adapter = &isp->isp_osinfo._adapter;\n\tlptr->openings = isp->isp_maxcmds;\n\tif (IS_FC(isp)) {\n\t\tisp->isp_osinfo._adapter.scsi_cmd = ispcmd;\n\t\tlptr->adapter_buswidth = MAX_FC_TARG;\n\t\t/* We can set max lun width here */\n\t\t/* loopid set below */\n\t} else {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tisp->isp_osinfo._adapter.scsi_cmd = ispcmd_slow;\n\t\tlptr->adapter_buswidth = MAX_TARGETS;\n\t\t/* We can set max lun width here */\n\t\tlptr->adapter_target = sdp->isp_initiator_id;\n\t\tisp->isp_osinfo.discovered[0] = 1 << sdp->isp_initiator_id;\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tstruct scsi_link *lptrb = &isp->isp_osinfo._link[1];\n\t\t\tlptrb->adapter_softc = isp;\n\t\t\tlptrb->device = &isp_dev;\n\t\t\tlptrb->adapter = &isp->isp_osinfo._adapter;\n\t\t\tlptrb->openings = isp->isp_maxcmds;\n\t\t\tlptrb->adapter_buswidth = MAX_TARGETS;\n\t\t\tlptrb->adapter_target = sdp->isp_initiator_id;\n\t\t\tlptrb->flags = SDEV_2NDBUS;\n\t\t\tisp->isp_osinfo.discovered[1] =\n\t\t\t    1 << (sdp+1)->isp_initiator_id;\n\t\t}\n\t}\n\n\t/*\n\t * Send a SCSI Bus Reset (used to be done as part of attach,\n\t * but now left to the OS outer layers).\n\t *\n\t * We don't do 'bus resets' for FC because the LIP that occurs\n\t * when we start the firmware does all that for us.\n\t */\n\tif (IS_SCSI(isp)) {\n\t\tint bus = 0;\n\t\t(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tbus++;\n\t\t\t(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);\n\t\t}\n\t\t/*\n\t\t * wait for the bus to settle.\n\t\t */\n\t\tprintf(\"%s: waiting 4 seconds for bus reset settling\\n\",\n\t\t    isp->isp_name);\n\t\tdelay(4 * 1000000);\n\t} else {\n\t\tint i, j;\n\t\tfcparam *fcp = isp->isp_param;\n\t\t/*\n\t\t * wait for the loop to settle.\n\t\t */\n\t\tprintf(\"%s: waiting 2 seconds for loop reset settling\\n\",\n\t\t    isp->isp_name);\n\t\tdelay(2 * 1000000);\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (isp_control(isp, ISPCTL_FCLINK_TEST, NULL))\n\t\t\t\t\tcontinue;\n#ifdef\tISP2100_FABRIC\n\t\t\t\t/*\n\t\t\t\t * Wait extra time to see if the f/w\n\t\t\t\t * eventually completed an FLOGI that\n\t\t\t\t * will allow us to know we're on a\n\t\t\t\t * fabric.\n\t\t\t\t */\n\t\t\t\tif (fcp->isp_onfabric == 0) {\n\t\t\t\t\tdelay(1 * 1000000);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fcp->isp_fwstate == FW_READY &&\n\t\t\t    fcp->isp_loopstate >= LOOP_PDB_RCVD) { \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlptr->adapter_target = fcp->isp_loopid;\n\t}\n\n\t/*\n\t * Start the watchdog.\n\t *\n\t * The watchdog will, ridiculously enough, also enable Sync negotiation.\n\t */\n\tisp->isp_dogactive = 1;\n\ttimeout(isp_watch, isp, WATCH_INTERVAL * hz);\n\n\t/*\n\t * And attach children (if any).\n\t */\n\tconfig_found((void *)isp, lptr, scsiprint);\n\tif (IS_DUALBUS(isp)) {\n\t\tlptr++;\n\t\tconfig_found((void *)isp, lptr, scsiprint);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't create dma maps\\n\"",
            "isp->isp_name"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "pcs->pci_dmat",
            "MAXPHYS",
            "(MAXPHYS / NBPG) + 1",
            "MAXPHYS",
            "0",
            "BUS_DMA_NOWAIT",
            "&pcs->pci_xfer_dmap[i]"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_init",
          "args": [
            "isp"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "isp_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "647-664",
          "snippet": "void\nisp_init(isp)\n\tstruct ispsoftc *isp;\n{\n\t/*\n\t * Must do this first to get defaults established.\n\t */\n\tisp_setdfltparm(isp, 0);\n\tif (IS_DUALBUS(isp)) {\n\t\tisp_setdfltparm(isp, 1);\n\t}\n\n\tif (IS_FC(isp)) {\n\t\tisp_fibre_init(isp);\n\t} else {\n\t\tisp_scsi_init(isp);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_scsi_init",
            "static void isp_fibre_init",
            "static void isp_setdfltparm"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_scsi_init;\nstatic void isp_fibre_init;\nstatic void isp_setdfltparm;\n\nvoid\nisp_init(isp)\n\tstruct ispsoftc *isp;\n{\n\t/*\n\t * Must do this first to get defaults established.\n\t */\n\tisp_setdfltparm(isp, 0);\n\tif (IS_DUALBUS(isp)) {\n\t\tisp_setdfltparm(isp, 1);\n\t}\n\n\tif (IS_FC(isp)) {\n\t\tisp_fibre_init(isp);\n\t} else {\n\t\tisp_scsi_init(isp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_reset",
          "args": [
            "isp"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "isp_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "111-639",
          "snippet": "void\nisp_reset(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tint loops, i, dodnld = 1;\n\tchar *revname;\n\n\tisp->isp_state = ISP_NILSTATE;\n\n\t/*\n\t * Basic types (SCSI, FibreChannel and PCI or SBus)\n\t * have been set in the MD code. We figure out more\n\t * here.\n\t */\n\tisp->isp_dblev = DFLT_DBLEVEL;\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\t/*\n\t * Get the current running firmware revision out of the\n\t * chip before we hit it over the head (if this is our\n\t * first time through). Note that we store this as the\n\t * 'ROM' firmware revision- which it may not be. In any\n\t * case, we don't really use this yet, but we may in\n\t * the future.\n\t */\n\tif (isp->isp_touched == 0) {\n\t\t/*\n\t\t * Just in case it was paused...\n\t\t */\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\t/*\n\t\t * If this fails, it probably means we're running\n\t\t * an old prom, if anything at all...\n\t\t */\n\t\tif (mbs.param[0] == MBOX_COMMAND_COMPLETE) {\n\t\t\tisp->isp_romfw_rev[0] = mbs.param[1];\n\t\t\tisp->isp_romfw_rev[1] = mbs.param[2];\n\t\t\tisp->isp_romfw_rev[2] = mbs.param[3];\n\t\t}\n\t\tisp->isp_touched = 1;\n\t}\n\n\tDISABLE_INTS(isp);\n\n\t/*\n\t * Put the board into PAUSE mode (so we can read the SXP registers).\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\n\tif (IS_FC(isp)) {\n\t\trevname = \"2X00\";\n\t\tswitch (isp->isp_type) {\n\t\tcase ISP_HA_FC_2100:\n\t\t\trevname[1] = '1';\n\t\t\tbreak;\n\t\tcase ISP_HA_FC_2200:\n\t\t\trevname[1] = '2';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_1240(isp)) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\trevname = \"1240\";\n\t\tisp->isp_clock = 60;\n\t\tsdp->isp_ultramode = 1;\n\t\tsdp++;\n\t\tsdp->isp_ultramode = 1;\n\t\t/*\n\t\t * XXX: Should probably do some bus sensing.\n\t\t */\n\t} else if (IS_ULTRA2(isp)) {\n\t\tstatic char *m = \"%s: bus %d is in %s Mode\\n\";\n\t\tu_int16_t l;\n\t\tsdparam *sdp = isp->isp_param;\n\n\t\tisp->isp_clock = 100;\n\n\t\tif (IS_1280(isp))\n\t\t\trevname = \"1280\";\n\t\telse if (IS_1080(isp))\n\t\t\trevname = \"1080\";\n\t\telse if (IS_12160(isp))\n\t\t\trevname = \"12160\";\n\t\telse\n\t\t\trevname = \"<UNKLVD>\";\n\n\t\tl = ISP_READ(isp, SXP_PINS_DIFF) & ISP1080_MODE_MASK;\n\t\tswitch (l) {\n\t\tcase ISP1080_LVD_MODE:\n\t\t\tsdp->isp_lvdmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"LVD\");\n\t\t\tbreak;\n\t\tcase ISP1080_HVD_MODE:\n\t\t\tsdp->isp_diffmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Differential\");\n\t\t\tbreak;\n\t\tcase ISP1080_SE_MODE:\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Single-Ended\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t    isp->isp_name, 0, l);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tsdp++;\n\t\t\tl = ISP_READ(isp, SXP_PINS_DIFF|SXP_BANK1_SELECT);\n\t\t\tl &= ISP1080_MODE_MASK;\n\t\t\tswitch(l) {\n\t\t\tcase ISP1080_LVD_MODE:\n\t\t\t\tsdp->isp_lvdmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"LVD\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_HVD_MODE:\n\t\t\t\tsdp->isp_diffmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Differential\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_SE_MODE:\n\t\t\t\tsdp->isp_ultramode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Single-Ended\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, 1, l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsdparam *sdp = isp->isp_param;\n\t\ti = ISP_READ(isp, BIU_CONF0) & BIU_CONF0_HW_MASK;\n\t\tswitch (i) {\n\t\tdefault:\n\t\t\tPRINTF(\"%s: unknown chip rev. 0x%x- assuming a 1020\\n\",\n\t\t\t    isp->isp_name, i);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\trevname = \"1020\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/*\n\t\t\t * Some 1020A chips are Ultra Capable, but don't\n\t\t\t * run the clock rate up for that unless told to\n\t\t\t * do so by the Ultra Capable bits being set.\n\t\t\t */\n\t\t\trevname = \"1020A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020A;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trevname = \"1040\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trevname = \"1040A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040A;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevname = \"1040B\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040B;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 6: \n\t\t\trevname = \"1040C\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040C;\n\t\t\tisp->isp_clock = 60;\n                        break; \n\t\t}\n\t\t/*\n\t\t * Now, while we're at it, gather info about ultra\n\t\t * and/or differential mode.\n\t\t */\n\t\tif (ISP_READ(isp, SXP_PINS_DIFF) & SXP_PINS_DIFF_MODE) {\n\t\t\tCFGPRINTF(\"%s: Differential Mode\\n\", isp->isp_name);\n\t\t\tsdp->isp_diffmode = 1;\n\t\t} else {\n\t\t\tsdp->isp_diffmode = 0;\n\t\t}\n\t\ti = ISP_READ(isp, RISC_PSR);\n\t\tif (isp->isp_bustype == ISP_BT_SBUS) {\n\t\t\ti &= RISC_PSR_SBUS_ULTRA;\n\t\t} else {\n\t\t\ti &= RISC_PSR_PCI_ULTRA;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tCFGPRINTF(\"%s: Ultra Mode Capable\\n\", isp->isp_name);\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\t/*\n\t\t\t * If we're in Ultra Mode, we have to be 60Mhz clock-\n\t\t\t * even for the SBus version.\n\t\t\t */\n\t\t\tisp->isp_clock = 60;\n\t\t} else {\n\t\t\tsdp->isp_ultramode = 0;\n\t\t\t/*\n\t\t\t * Clock is known. Gronk.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * Machine dependent clock (if set) overrides\n\t\t * our generic determinations.\n\t\t */\n\t\tif (isp->isp_mdvec->dv_clock) {\n\t\t\tif (isp->isp_mdvec->dv_clock < isp->isp_clock) {\n\t\t\t\tisp->isp_clock = isp->isp_mdvec->dv_clock;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/*\n\t * Do MD specific pre initialization\n\t */\n\tISP_RESET0(isp);\n\nagain:\n\n\t/*\n\t * Hit the chip over the head with hammer,\n\t * and give the ISP a chance to recover.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_ICR, BIU_ICR_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n#if\t0\n\t\tPRINTF(\"%s: mbox0-5: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t    isp->isp_name, ISP_READ(isp, OUTMAILBOX0),\n\t\t    ISP_READ(isp, OUTMAILBOX1), ISP_READ(isp, OUTMAILBOX2),\n\t\t    ISP_READ(isp, OUTMAILBOX3), ISP_READ(isp, OUTMAILBOX4),\n\t\t    ISP_READ(isp, OUTMAILBOX5));\n#endif\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\t\tISP_WRITE(isp, DDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\n\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, TDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, RDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t}\n\n\t/*\n\t * Wait for ISP to be ready to go...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (!(ISP_READ(isp, BIU_ICR) & BIU_ICR_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!(ISP_READ(isp, BIU2100_CSR) & BIU2100_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tisp_dumpregs(isp, \"chip reset timed out\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_CONF1, 0);\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, 0);\n\t}\n\n\t/*\n\t * Reset RISC Processor\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RESET);\n\tSYS_DELAY(100);\n\n\t/*\n\t * Establish some initial burst rate stuff.\n\t * (only for the 1XX0 boards). This really should\n\t * be done later after fetching from NVRAM.\n\t */\n\tif (IS_SCSI(isp)) {\n\t\tu_int16_t tmp = isp->isp_mdvec->dv_conf1;\n\t\t/*\n\t\t * Busted FIFO. Turn off all but burst enables.\n\t\t */\n\t\tif (isp->isp_type == ISP_HA_SCSI_1040A) {\n\t\t\ttmp &= BIU_BURST_ENABLE;\n\t\t}\n\t\tISP_SETBITS(isp, BIU_CONF1, tmp);\n\t\tif (tmp & BIU_BURST_ENABLE) {\n\t\t\tISP_SETBITS(isp, CDMA_CONF, DMA_ENABLE_BURST);\n\t\t\tISP_SETBITS(isp, DDMA_CONF, DMA_ENABLE_BURST);\n\t\t}\n#ifdef\tPTI_CARDS\n\t\tif (((sdparam *) isp->isp_param)->isp_ultramode) {\n\t\t\twhile (ISP_READ(isp, RISC_MTR) != 0x1313) {\n\t\t\t\tISP_WRITE(isp, RISC_MTR, 0x1313);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_STEP);\n\t\t\t}\n\t\t} else {\n\t\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n\t\t}\n\t\t/*\n\t\t * PTI specific register\n\t\t */\n\t\tISP_WRITE(isp, RISC_EMB, DUAL_BANK)\n#else\n\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n#endif\n\t} else {\n\t\tISP_WRITE(isp, RISC_MTR2100, 0x1212);\n\t}\n\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE); /* release paused processor */\n\n\t/*\n\t * Do MD specific post initialization\n\t */\n\tISP_RESET1(isp);\n\n\t/*\n\t * Wait for everything to finish firing up...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\twhile (ISP_READ(isp, OUTMAILBOX0) == MBOX_BUSY) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: MBOX_BUSY never cleared on reset\\n\",\n\t\t\t    isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Up until this point we've done everything by just reading or\n\t * setting registers. From this point on we rely on at least *some*\n\t * kind of firmware running in the card.\n\t */\n\n\t/*\n\t * Do some sanity checking.\n\t */\n\tmbs.param[0] = MBOX_NO_OP;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tisp_dumpregs(isp, \"NOP test failed\");\n\t\treturn;\n\t}\n\n\tif (IS_SCSI(isp)) {\n\t\tmbs.param[0] = MBOX_MAILBOX_REG_TEST;\n\t\tmbs.param[1] = 0xdead;\n\t\tmbs.param[2] = 0xbeef;\n\t\tmbs.param[3] = 0xffff;\n\t\tmbs.param[4] = 0x1111;\n\t\tmbs.param[5] = 0xa5a5;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp,\n\t\t\t\t\"Mailbox Register test didn't complete\");\n\t\t\treturn;\n\t\t}\n\t\tif (mbs.param[1] != 0xdead || mbs.param[2] != 0xbeef ||\n\t\t    mbs.param[3] != 0xffff || mbs.param[4] != 0x1111 ||\n\t\t    mbs.param[5] != 0xa5a5) {\n\t\t\tisp_dumpregs(isp, \"Register Test Failed\");\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\t/*\n\t * Download new Firmware, unless requested not to do so.\n\t * This is made slightly trickier in some cases where the\n\t * firmware of the ROM revision is newer than the revision\n\t * compiled into the driver. So, where we used to compare\n\t * versions of our f/w and the ROM f/w, now we just see\n\t * whether we have f/w at all and whether a config flag\n\t * has disabled our download.\n\t */\n\tif ((isp->isp_mdvec->dv_ispfw == NULL) ||\n\t    (isp->isp_confopts & ISP_CFG_NORELOAD)) {\n\t\tdodnld = 0;\n\t}\n\n\tif (dodnld) {\n\t\tu_int16_t fwlen  = isp->isp_mdvec->dv_fwlen;\n\t\tif (fwlen == 0)\n\t\t\tfwlen = isp->isp_mdvec->dv_ispfw[3]; /* usually here */\n\t\tfor (i = 0; i < fwlen; i++) {\n\t\t\tmbs.param[0] = MBOX_WRITE_RAM_WORD;\n\t\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg + i;\n\t\t\tmbs.param[2] = isp->isp_mdvec->dv_ispfw[i];\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: F/W download failed at word %d\\n\",\n\t\t\t\t    isp->isp_name, i);\n\t\t\t\tdodnld = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Verify that it downloaded correctly.\n\t\t */\n\t\tmbs.param[0] = MBOX_VERIFY_CHECKSUM;\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"ram checksum failure\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tIDPRINTF(3, (\"%s: skipping f/w download\\n\", isp->isp_name));\n\t}\n\n\t/*\n\t * Now start it rolling.\n\t *\n\t * If we didn't actually download f/w,\n\t * we still need to (re)start it.\n\t */\n\n\tmbs.param[0] = MBOX_EXEC_FIRMWARE;\n\tif (isp->isp_mdvec->dv_codeorg)\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\telse\n\t\tmbs.param[1] = 0x1000;\n\tisp_mboxcmd(isp, &mbs);\n\n\tif (IS_SCSI(isp)) {\n\t\t/*\n\t\t * Set CLOCK RATE, but only if asked to.\n\t\t */\n\t\tif (isp->isp_clock) {\n\t\t\tmbs.param[0] = MBOX_SET_CLOCK_RATE;\n\t\t\tmbs.param[1] = isp->isp_clock;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"failed to set clockrate (0x%x)\\n\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\t/* but continue */\n\t\t\t}\n\t\t}\n\t}\n\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"could not get f/w started (0x%x)\\n\", mbs.param[0]);\n\t\treturn;\n\t}\n\tCFGPRINTF(\"%s: Board Revision %s, %s F/W Revision %d.%d.%d\\n\",\n\t    isp->isp_name, revname, dodnld? \"loaded\" : \"resident\",\n\t    mbs.param[1], mbs.param[2], mbs.param[3]);\n\tif (IS_FC(isp)) {\n\t\tif (ISP_READ(isp, BIU2100_CSR) & BIU2100_PCI64) {\n\t\t\tCFGPRINTF(\"%s: in 64-Bit PCI slot\\n\", isp->isp_name);\n\t\t}\n\t}\n\n\tisp->isp_fwrev[0] = mbs.param[1];\n\tisp->isp_fwrev[1] = mbs.param[2];\n\tisp->isp_fwrev[2] = mbs.param[3];\n\tif (isp->isp_romfw_rev[0] || isp->isp_romfw_rev[1] ||\n\t    isp->isp_romfw_rev[2]) {\n\t\tCFGPRINTF(\"%s: Last F/W revision was %d.%d.%d\\n\", isp->isp_name,\n\t\t    isp->isp_romfw_rev[0], isp->isp_romfw_rev[1],\n\t\t    isp->isp_romfw_rev[2]);\n\t}\n\n\tmbs.param[0] = MBOX_GET_FIRMWARE_STATUS;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: could not GET FIRMWARE STATUS\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_maxcmds = mbs.param[2];\n\tCFGPRINTF(\"%s: %d max I/O commands supported\\n\",\n\t    isp->isp_name, mbs.param[2]);\n\tisp_fw_state(isp);\n\n\t/*\n\t * Set up DMA for the request and result mailboxes.\n\t */\n\tif (ISP_MBOXDMASETUP(isp) != 0) {\n\t\tPRINTF(\"%s: can't setup dma mailboxes\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_state = ISP_RESETSTATE;\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tMBOX_DELAY_COUNT\t1000000 / 100"
          ],
          "globals_used": [
            "static void isp_fw_state",
            "static void isp_dumpregs",
            "static void isp_mboxcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tMBOX_DELAY_COUNT\t1000000 / 100\n\nstatic void isp_fw_state;\nstatic void isp_dumpregs;\nstatic void isp_mboxcmd;\n\nvoid\nisp_reset(isp)\n\tstruct ispsoftc *isp;\n{\n\tmbreg_t mbs;\n\tint loops, i, dodnld = 1;\n\tchar *revname;\n\n\tisp->isp_state = ISP_NILSTATE;\n\n\t/*\n\t * Basic types (SCSI, FibreChannel and PCI or SBus)\n\t * have been set in the MD code. We figure out more\n\t * here.\n\t */\n\tisp->isp_dblev = DFLT_DBLEVEL;\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\t/*\n\t * Get the current running firmware revision out of the\n\t * chip before we hit it over the head (if this is our\n\t * first time through). Note that we store this as the\n\t * 'ROM' firmware revision- which it may not be. In any\n\t * case, we don't really use this yet, but we may in\n\t * the future.\n\t */\n\tif (isp->isp_touched == 0) {\n\t\t/*\n\t\t * Just in case it was paused...\n\t\t */\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE);\n\t\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\t/*\n\t\t * If this fails, it probably means we're running\n\t\t * an old prom, if anything at all...\n\t\t */\n\t\tif (mbs.param[0] == MBOX_COMMAND_COMPLETE) {\n\t\t\tisp->isp_romfw_rev[0] = mbs.param[1];\n\t\t\tisp->isp_romfw_rev[1] = mbs.param[2];\n\t\t\tisp->isp_romfw_rev[2] = mbs.param[3];\n\t\t}\n\t\tisp->isp_touched = 1;\n\t}\n\n\tDISABLE_INTS(isp);\n\n\t/*\n\t * Put the board into PAUSE mode (so we can read the SXP registers).\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_PAUSE);\n\n\tif (IS_FC(isp)) {\n\t\trevname = \"2X00\";\n\t\tswitch (isp->isp_type) {\n\t\tcase ISP_HA_FC_2100:\n\t\t\trevname[1] = '1';\n\t\t\tbreak;\n\t\tcase ISP_HA_FC_2200:\n\t\t\trevname[1] = '2';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (IS_1240(isp)) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\trevname = \"1240\";\n\t\tisp->isp_clock = 60;\n\t\tsdp->isp_ultramode = 1;\n\t\tsdp++;\n\t\tsdp->isp_ultramode = 1;\n\t\t/*\n\t\t * XXX: Should probably do some bus sensing.\n\t\t */\n\t} else if (IS_ULTRA2(isp)) {\n\t\tstatic char *m = \"%s: bus %d is in %s Mode\\n\";\n\t\tu_int16_t l;\n\t\tsdparam *sdp = isp->isp_param;\n\n\t\tisp->isp_clock = 100;\n\n\t\tif (IS_1280(isp))\n\t\t\trevname = \"1280\";\n\t\telse if (IS_1080(isp))\n\t\t\trevname = \"1080\";\n\t\telse if (IS_12160(isp))\n\t\t\trevname = \"12160\";\n\t\telse\n\t\t\trevname = \"<UNKLVD>\";\n\n\t\tl = ISP_READ(isp, SXP_PINS_DIFF) & ISP1080_MODE_MASK;\n\t\tswitch (l) {\n\t\tcase ISP1080_LVD_MODE:\n\t\t\tsdp->isp_lvdmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"LVD\");\n\t\t\tbreak;\n\t\tcase ISP1080_HVD_MODE:\n\t\t\tsdp->isp_diffmode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Differential\");\n\t\t\tbreak;\n\t\tcase ISP1080_SE_MODE:\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\tCFGPRINTF(m, isp->isp_name, 0, \"Single-Ended\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t    isp->isp_name, 0, l);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tsdp++;\n\t\t\tl = ISP_READ(isp, SXP_PINS_DIFF|SXP_BANK1_SELECT);\n\t\t\tl &= ISP1080_MODE_MASK;\n\t\t\tswitch(l) {\n\t\t\tcase ISP1080_LVD_MODE:\n\t\t\t\tsdp->isp_lvdmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"LVD\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_HVD_MODE:\n\t\t\t\tsdp->isp_diffmode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Differential\");\n\t\t\t\tbreak;\n\t\t\tcase ISP1080_SE_MODE:\n\t\t\t\tsdp->isp_ultramode = 1;\n\t\t\t\tCFGPRINTF(m, isp->isp_name, 1, \"Single-Ended\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tCFGPRINTF(\"%s: unknown mode on bus %d (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, 1, l);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsdparam *sdp = isp->isp_param;\n\t\ti = ISP_READ(isp, BIU_CONF0) & BIU_CONF0_HW_MASK;\n\t\tswitch (i) {\n\t\tdefault:\n\t\t\tPRINTF(\"%s: unknown chip rev. 0x%x- assuming a 1020\\n\",\n\t\t\t    isp->isp_name, i);\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\trevname = \"1020\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/*\n\t\t\t * Some 1020A chips are Ultra Capable, but don't\n\t\t\t * run the clock rate up for that unless told to\n\t\t\t * do so by the Ultra Capable bits being set.\n\t\t\t */\n\t\t\trevname = \"1020A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1020A;\n\t\t\tisp->isp_clock = 40;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trevname = \"1040\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trevname = \"1040A\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040A;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevname = \"1040B\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040B;\n\t\t\tisp->isp_clock = 60;\n\t\t\tbreak;\n\t\tcase 6: \n\t\t\trevname = \"1040C\";\n\t\t\tisp->isp_type = ISP_HA_SCSI_1040C;\n\t\t\tisp->isp_clock = 60;\n                        break; \n\t\t}\n\t\t/*\n\t\t * Now, while we're at it, gather info about ultra\n\t\t * and/or differential mode.\n\t\t */\n\t\tif (ISP_READ(isp, SXP_PINS_DIFF) & SXP_PINS_DIFF_MODE) {\n\t\t\tCFGPRINTF(\"%s: Differential Mode\\n\", isp->isp_name);\n\t\t\tsdp->isp_diffmode = 1;\n\t\t} else {\n\t\t\tsdp->isp_diffmode = 0;\n\t\t}\n\t\ti = ISP_READ(isp, RISC_PSR);\n\t\tif (isp->isp_bustype == ISP_BT_SBUS) {\n\t\t\ti &= RISC_PSR_SBUS_ULTRA;\n\t\t} else {\n\t\t\ti &= RISC_PSR_PCI_ULTRA;\n\t\t}\n\t\tif (i != 0) {\n\t\t\tCFGPRINTF(\"%s: Ultra Mode Capable\\n\", isp->isp_name);\n\t\t\tsdp->isp_ultramode = 1;\n\t\t\t/*\n\t\t\t * If we're in Ultra Mode, we have to be 60Mhz clock-\n\t\t\t * even for the SBus version.\n\t\t\t */\n\t\t\tisp->isp_clock = 60;\n\t\t} else {\n\t\t\tsdp->isp_ultramode = 0;\n\t\t\t/*\n\t\t\t * Clock is known. Gronk.\n\t\t\t */\n\t\t}\n\n\t\t/*\n\t\t * Machine dependent clock (if set) overrides\n\t\t * our generic determinations.\n\t\t */\n\t\tif (isp->isp_mdvec->dv_clock) {\n\t\t\tif (isp->isp_mdvec->dv_clock < isp->isp_clock) {\n\t\t\t\tisp->isp_clock = isp->isp_mdvec->dv_clock;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/*\n\t * Do MD specific pre initialization\n\t */\n\tISP_RESET0(isp);\n\nagain:\n\n\t/*\n\t * Hit the chip over the head with hammer,\n\t * and give the ISP a chance to recover.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_ICR, BIU_ICR_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n#if\t0\n\t\tPRINTF(\"%s: mbox0-5: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t    isp->isp_name, ISP_READ(isp, OUTMAILBOX0),\n\t\t    ISP_READ(isp, OUTMAILBOX1), ISP_READ(isp, OUTMAILBOX2),\n\t\t    ISP_READ(isp, OUTMAILBOX3), ISP_READ(isp, OUTMAILBOX4),\n\t\t    ISP_READ(isp, OUTMAILBOX5));\n#endif\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\t\tISP_WRITE(isp, DDMA_CONTROL,\n\t\t    DMA_CNTRL_CLEAR_CHAN | DMA_CNTRL_RESET_INT);\n\n\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, BIU2100_SOFT_RESET);\n\t\t/*\n\t\t * A slight delay...\n\t\t */\n\t\tSYS_DELAY(100);\n\n\t\t/*\n\t\t * Clear data && control DMA engines.\n\t\t */\n\t\tISP_WRITE(isp, CDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, TDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t\tISP_WRITE(isp, RDMA2100_CONTROL,\n\t\t\tDMA_CNTRL2100_CLEAR_CHAN | DMA_CNTRL2100_RESET_INT);\n\t}\n\n\t/*\n\t * Wait for ISP to be ready to go...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\tfor (;;) {\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (!(ISP_READ(isp, BIU_ICR) & BIU_ICR_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (!(ISP_READ(isp, BIU2100_CSR) & BIU2100_SOFT_RESET))\n\t\t\t\tbreak;\n\t\t}\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tisp_dumpregs(isp, \"chip reset timed out\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * After we've fired this chip up, zero out the conf1 register\n\t * for SCSI adapters and other settings for the 2100.\n\t */\n\n\tif (IS_SCSI(isp)) {\n\t\tISP_WRITE(isp, BIU_CONF1, 0);\n\t} else {\n\t\tISP_WRITE(isp, BIU2100_CSR, 0);\n\t}\n\n\t/*\n\t * Reset RISC Processor\n\t */\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RESET);\n\tSYS_DELAY(100);\n\n\t/*\n\t * Establish some initial burst rate stuff.\n\t * (only for the 1XX0 boards). This really should\n\t * be done later after fetching from NVRAM.\n\t */\n\tif (IS_SCSI(isp)) {\n\t\tu_int16_t tmp = isp->isp_mdvec->dv_conf1;\n\t\t/*\n\t\t * Busted FIFO. Turn off all but burst enables.\n\t\t */\n\t\tif (isp->isp_type == ISP_HA_SCSI_1040A) {\n\t\t\ttmp &= BIU_BURST_ENABLE;\n\t\t}\n\t\tISP_SETBITS(isp, BIU_CONF1, tmp);\n\t\tif (tmp & BIU_BURST_ENABLE) {\n\t\t\tISP_SETBITS(isp, CDMA_CONF, DMA_ENABLE_BURST);\n\t\t\tISP_SETBITS(isp, DDMA_CONF, DMA_ENABLE_BURST);\n\t\t}\n#ifdef\tPTI_CARDS\n\t\tif (((sdparam *) isp->isp_param)->isp_ultramode) {\n\t\t\twhile (ISP_READ(isp, RISC_MTR) != 0x1313) {\n\t\t\t\tISP_WRITE(isp, RISC_MTR, 0x1313);\n\t\t\t\tISP_WRITE(isp, HCCR, HCCR_CMD_STEP);\n\t\t\t}\n\t\t} else {\n\t\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n\t\t}\n\t\t/*\n\t\t * PTI specific register\n\t\t */\n\t\tISP_WRITE(isp, RISC_EMB, DUAL_BANK)\n#else\n\t\tISP_WRITE(isp, RISC_MTR, 0x1212);\n#endif\n\t} else {\n\t\tISP_WRITE(isp, RISC_MTR2100, 0x1212);\n\t}\n\n\tISP_WRITE(isp, HCCR, HCCR_CMD_RELEASE); /* release paused processor */\n\n\t/*\n\t * Do MD specific post initialization\n\t */\n\tISP_RESET1(isp);\n\n\t/*\n\t * Wait for everything to finish firing up...\n\t */\n\tloops = MBOX_DELAY_COUNT;\n\twhile (ISP_READ(isp, OUTMAILBOX0) == MBOX_BUSY) {\n\t\tSYS_DELAY(100);\n\t\tif (--loops < 0) {\n\t\t\tPRINTF(\"%s: MBOX_BUSY never cleared on reset\\n\",\n\t\t\t    isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Up until this point we've done everything by just reading or\n\t * setting registers. From this point on we rely on at least *some*\n\t * kind of firmware running in the card.\n\t */\n\n\t/*\n\t * Do some sanity checking.\n\t */\n\tmbs.param[0] = MBOX_NO_OP;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tisp_dumpregs(isp, \"NOP test failed\");\n\t\treturn;\n\t}\n\n\tif (IS_SCSI(isp)) {\n\t\tmbs.param[0] = MBOX_MAILBOX_REG_TEST;\n\t\tmbs.param[1] = 0xdead;\n\t\tmbs.param[2] = 0xbeef;\n\t\tmbs.param[3] = 0xffff;\n\t\tmbs.param[4] = 0x1111;\n\t\tmbs.param[5] = 0xa5a5;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp,\n\t\t\t\t\"Mailbox Register test didn't complete\");\n\t\t\treturn;\n\t\t}\n\t\tif (mbs.param[1] != 0xdead || mbs.param[2] != 0xbeef ||\n\t\t    mbs.param[3] != 0xffff || mbs.param[4] != 0x1111 ||\n\t\t    mbs.param[5] != 0xa5a5) {\n\t\t\tisp_dumpregs(isp, \"Register Test Failed\");\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\t/*\n\t * Download new Firmware, unless requested not to do so.\n\t * This is made slightly trickier in some cases where the\n\t * firmware of the ROM revision is newer than the revision\n\t * compiled into the driver. So, where we used to compare\n\t * versions of our f/w and the ROM f/w, now we just see\n\t * whether we have f/w at all and whether a config flag\n\t * has disabled our download.\n\t */\n\tif ((isp->isp_mdvec->dv_ispfw == NULL) ||\n\t    (isp->isp_confopts & ISP_CFG_NORELOAD)) {\n\t\tdodnld = 0;\n\t}\n\n\tif (dodnld) {\n\t\tu_int16_t fwlen  = isp->isp_mdvec->dv_fwlen;\n\t\tif (fwlen == 0)\n\t\t\tfwlen = isp->isp_mdvec->dv_ispfw[3]; /* usually here */\n\t\tfor (i = 0; i < fwlen; i++) {\n\t\t\tmbs.param[0] = MBOX_WRITE_RAM_WORD;\n\t\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg + i;\n\t\t\tmbs.param[2] = isp->isp_mdvec->dv_ispfw[i];\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: F/W download failed at word %d\\n\",\n\t\t\t\t    isp->isp_name, i);\n\t\t\t\tdodnld = 0;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Verify that it downloaded correctly.\n\t\t */\n\t\tmbs.param[0] = MBOX_VERIFY_CHECKSUM;\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"ram checksum failure\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tIDPRINTF(3, (\"%s: skipping f/w download\\n\", isp->isp_name));\n\t}\n\n\t/*\n\t * Now start it rolling.\n\t *\n\t * If we didn't actually download f/w,\n\t * we still need to (re)start it.\n\t */\n\n\tmbs.param[0] = MBOX_EXEC_FIRMWARE;\n\tif (isp->isp_mdvec->dv_codeorg)\n\t\tmbs.param[1] = isp->isp_mdvec->dv_codeorg;\n\telse\n\t\tmbs.param[1] = 0x1000;\n\tisp_mboxcmd(isp, &mbs);\n\n\tif (IS_SCSI(isp)) {\n\t\t/*\n\t\t * Set CLOCK RATE, but only if asked to.\n\t\t */\n\t\tif (isp->isp_clock) {\n\t\t\tmbs.param[0] = MBOX_SET_CLOCK_RATE;\n\t\t\tmbs.param[1] = isp->isp_clock;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"failed to set clockrate (0x%x)\\n\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\t/* but continue */\n\t\t\t}\n\t\t}\n\t}\n\tmbs.param[0] = MBOX_ABOUT_FIRMWARE;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"could not get f/w started (0x%x)\\n\", mbs.param[0]);\n\t\treturn;\n\t}\n\tCFGPRINTF(\"%s: Board Revision %s, %s F/W Revision %d.%d.%d\\n\",\n\t    isp->isp_name, revname, dodnld? \"loaded\" : \"resident\",\n\t    mbs.param[1], mbs.param[2], mbs.param[3]);\n\tif (IS_FC(isp)) {\n\t\tif (ISP_READ(isp, BIU2100_CSR) & BIU2100_PCI64) {\n\t\t\tCFGPRINTF(\"%s: in 64-Bit PCI slot\\n\", isp->isp_name);\n\t\t}\n\t}\n\n\tisp->isp_fwrev[0] = mbs.param[1];\n\tisp->isp_fwrev[1] = mbs.param[2];\n\tisp->isp_fwrev[2] = mbs.param[3];\n\tif (isp->isp_romfw_rev[0] || isp->isp_romfw_rev[1] ||\n\t    isp->isp_romfw_rev[2]) {\n\t\tCFGPRINTF(\"%s: Last F/W revision was %d.%d.%d\\n\", isp->isp_name,\n\t\t    isp->isp_romfw_rev[0], isp->isp_romfw_rev[1],\n\t\t    isp->isp_romfw_rev[2]);\n\t}\n\n\tmbs.param[0] = MBOX_GET_FIRMWARE_STATUS;\n\tisp_mboxcmd(isp, &mbs);\n\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\tPRINTF(\"%s: could not GET FIRMWARE STATUS\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_maxcmds = mbs.param[2];\n\tCFGPRINTF(\"%s: %d max I/O commands supported\\n\",\n\t    isp->isp_name, mbs.param[2]);\n\tisp_fw_state(isp);\n\n\t/*\n\t * Set up DMA for the request and result mailboxes.\n\t */\n\tif (ISP_MBOXDMASETUP(isp) != 0) {\n\t\tPRINTF(\"%s: can't setup dma mailboxes\\n\", isp->isp_name);\n\t\treturn;\n\t}\n\tisp->isp_state = ISP_RESETSTATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pa->pa_pc",
            "ih",
            "IPL_BIO",
            "isp_pci_intr",
            "isp",
            "isp->isp_name"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pa->pa_pc",
            "ih"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pa->pa_pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCIR_ROMADDR",
            "data"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCIR_ROMADDR"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_BHLC_REG",
            "data"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_BHLC_REG"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "data"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_CLASS_REG"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "isp->isp_param",
            "sizeof (fcparam)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (fcparam)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "isp->isp_param",
            "sizeof (fcparam)"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "isp->isp_param",
            "sizeof (sdparam)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "isp->isp_param",
            "sizeof (sdparam)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "isp->isp_param",
            "sizeof (sdparam)"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "isp->isp_param",
            "sizeof (sdparam)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "isp->isp_param",
            "sizeof (sdparam)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_CLASS_REG"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "mbase",
            "msize",
            "0",
            "&memh"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "MEM_MAP_REG",
            "&mbase",
            "&msize",
            "NULL"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_iot",
            "iobase",
            "iosize",
            "0",
            "&ioh"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "IO_MAP_REG",
            "&iobase",
            "&iosize"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_iot",
            "iobase",
            "iosize",
            "0",
            "&ioh"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "mbase",
            "msize",
            "0",
            "&memh"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\n#define SCSI_ISP_PREFER_MEM_MAP 0\n#define\tPCI_DFLT_LNSZ\t0x10\n#define\tPCIR_ROMADDR\t0x30\n#define MEM_MAP_REG\t0x14\n#define IO_MAP_REG\t0x10\n#define\tPCI_QLOGIC_ISP2200\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP2200 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP2100\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP2100 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP12160\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP12160 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP1280\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1280 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP1240\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1240 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP1080\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1080 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP\t((PCI_PRODUCT_QLOGIC_ISP1020 << 16) | PCI_VENDOR_QLOGIC)\n\nstatic int isp_pci_intr;\nstatic void isp_pci_attach;\n\nstatic void    \nisp_pci_attach(parent, self, aux)\n        struct device *parent, *self;\n        void *aux;\n{\n#ifdef\tDEBUG\n\tstatic char oneshot = 1;\n#endif\n\tu_int32_t data, rev, linesz = PCI_DFLT_LNSZ;\n\tstruct pci_attach_args *pa = aux;\n\tstruct isp_pcisoftc *pcs = (struct isp_pcisoftc *) self;\n\tstruct ispsoftc *isp = &pcs->pci_isp;\n\tbus_space_tag_t st, iot, memt;\n\tbus_space_handle_t sh, ioh, memh;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr;\n\tint ioh_valid, memh_valid, i, s;\n\tbus_addr_t iobase, mbase;\n\tbus_size_t iosize, msize;\n\n\tioh_valid = memh_valid = 0;\n\n#if\tSCSI_ISP_PREFER_MEM_MAP == 1\n\tif (pci_mem_find(pa->pa_pc, pa->pa_tag, MEM_MAP_REG, &mbase, &msize,\n\t    NULL)) {\n\t\tprintf(\": can't find mem space\\n\");\n\t} else if (bus_space_map(pa->pa_memt, mbase, msize, 0, &memh)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t} else  {\n\t\tmemt = pa->pa_memt;\n\t\tst = memt;\n\t\tsh = memh;\n\t\tmemh_valid = 1;\n\t}\n\tif (memh_valid == 0) {\n\t\tif (pci_io_find(pa->pa_pc, pa->pa_tag, IO_MAP_REG, &iobase,\n\t\t    &iosize)) {\n\t\t\tprintf(\": can't find i/o space\\n\");\n\t\t} else if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &ioh)) {\n\t\t\tprintf(\": can't map i/o space\\n\");\n\t\t} else {\n\t\t\tiot = pa->pa_iot;\n\t\t\tst = iot;\n\t\t\tsh = ioh;\n\t\t\tioh_valid = 1;\n\t\t}\n\t}\n#else\n\tif (pci_io_find(pa->pa_pc, pa->pa_tag, IO_MAP_REG, &iobase, &iosize)) {\n\t\tprintf(\": can't find i/o space\\n\");\n\t} else if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &ioh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t} else {\n\t\tiot = pa->pa_iot;\n\t\tst = iot;\n\t\tsh = ioh;\n\t\tioh_valid = 1;\n\t}\n\tif (ioh_valid == 0) {\n\t\tif (pci_mem_find(pa->pa_pc, pa->pa_tag, MEM_MAP_REG, &mbase,\n\t\t    &msize, NULL)) {\n\t\t\tprintf(\": can't find mem space\\n\");\n\t\t} else if (bus_space_map(pa->pa_memt, mbase, msize, 0, &memh)) {\n\t\t\tprintf(\": can't map mem space\\n\");\n\t\t} else  {\n\t\t\tmemt = pa->pa_memt;\n\t\t\tst = memt;\n\t\t\tsh = memh;\n\t\t\tmemh_valid = 1;\n\t\t}\n\t}\n#endif\n\tif (ioh_valid == 0 && memh_valid == 0) {\n\t\tprintf(\": unable to map device registers\\n\");\n\t\treturn;\n\t}\n\tprintf(\"\\n\");\n\n\tpcs->pci_st = st;\n\tpcs->pci_sh = sh;\n\tpcs->pci_dmat = pa->pa_dmat;\n\tpcs->pci_pc = pa->pa_pc;\n\tpcs->pci_tag = pa->pa_tag;\n\tpcs->pci_poff[BIU_BLOCK >> _BLK_REG_SHFT] = BIU_REGS_OFF;\n\tpcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] = PCI_MBOX_REGS_OFF;\n\tpcs->pci_poff[SXP_BLOCK >> _BLK_REG_SHFT] = PCI_SXP_REGS_OFF;\n\tpcs->pci_poff[RISC_BLOCK >> _BLK_REG_SHFT] = PCI_RISC_REGS_OFF;\n\tpcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] = DMA_REGS_OFF;\n\trev = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0xff;\n#ifndef\tISP_DISABLE_1020_SUPPORT\n\tif (pa->pa_id == PCI_QLOGIC_ISP) {\n\t\tisp->isp_mdvec = &mdvec;\n\t\tisp->isp_type = ISP_HA_SCSI_UNKNOWN;\n\t\tisp->isp_param = malloc(sizeof (sdparam), M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate sdparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (sdparam));\n\t}\n#endif\n#ifndef\tISP_DISABLE_1080_SUPPORT\n\tif (pa->pa_id == PCI_QLOGIC_ISP1080) {\n\t\tisp->isp_mdvec = &mdvec_1080;\n\t\tisp->isp_type = ISP_HA_SCSI_1080;\n\t\tisp->isp_param = malloc(sizeof (sdparam), M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate sdparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (sdparam));\n\t\tpcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =\n\t\t    ISP1080_DMA_REGS_OFF;\n\t}\n\tif (pa->pa_id == PCI_QLOGIC_ISP1240) {\n\t\tisp->isp_mdvec = &mdvec_1080;\n\t\tisp->isp_type = ISP_HA_SCSI_1240;\n\t\tisp->isp_param = malloc(2 * sizeof (sdparam),\n\t\t    M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate sdparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (sdparam));\n\t\tpcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =\n\t\t    ISP1080_DMA_REGS_OFF;\n\t}\n\tif (pa->pa_id == PCI_QLOGIC_ISP1280) {\n\t\tisp->isp_mdvec = &mdvec_1080;\n\t\tisp->isp_type = ISP_HA_SCSI_1280;\n\t\tisp->isp_param = malloc(2 * sizeof (sdparam),\n\t\t    M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate sdparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (sdparam));\n\t\tpcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =\n\t\t    ISP1080_DMA_REGS_OFF;\n\t}\n#endif\n#ifndef\tISP_DISABLE_12160_SUPPORT\n\tif (pa->pa_id == PCI_QLOGIC_ISP12160) {\n\t\tisp->isp_mdvec = &mdvec_12160;\n\t\tisp->isp_type = ISP_HA_SCSI_12160;\n\t\tisp->isp_param = malloc(2 * sizeof (sdparam),\n\t\t    M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate sdparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (sdparam));\n\t\tpcs->pci_poff[DMA_BLOCK >> _BLK_REG_SHFT] =\n\t\t    ISP1080_DMA_REGS_OFF;\n\t}\n#endif\n#ifndef\tISP_DISABLE_2100_SUPPORT\n\tif (pa->pa_id == PCI_QLOGIC_ISP2100) {\n\t\tisp->isp_mdvec = &mdvec_2100;\n\t\tisp->isp_type = ISP_HA_FC_2100;\n\t\tisp->isp_param = malloc(sizeof (fcparam), M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate fcparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (fcparam));\n\t\tpcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =\n\t\t    PCI_MBOX_REGS2100_OFF;\n\n\t\tif (rev < 3) {\n\t\t\t/*\n\t\t\t * XXX: Need to get the actual revision\n\t\t\t * XXX: number of the 2100 FB. At any rate,\n\t\t\t * XXX: lower cache line size for early revision\n\t\t\t * XXX; boards.\n\t\t\t */\n\t\t\tlinesz = 1;\n\t\t}\n\t}\n#endif\n#ifndef\tISP_DISABLE_2200_SUPPORT\n\tif (pa->pa_id == PCI_QLOGIC_ISP2200) {\n\t\tisp->isp_mdvec = &mdvec_2200;\n\t\tisp->isp_type = ISP_HA_FC_2200;\n\t\tisp->isp_param = malloc(sizeof (fcparam), M_DEVBUF, M_NOWAIT);\n\t\tif (isp->isp_param == NULL) {\n\t\t\tprintf(\"%s: couldn't allocate fcparam table\\n\",\n\t\t\t       isp->isp_name);\n\t\t\treturn;\n\t\t}\n\t\tbzero(isp->isp_param, sizeof (fcparam));\n\t\tpcs->pci_poff[MBOX_BLOCK >> _BLK_REG_SHFT] =\n\t\t    PCI_MBOX_REGS2100_OFF;\n\t\tdata = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG);\n\t}\n#endif\n\tisp->isp_revision = rev;\n\n\t/*\n\t * Make sure that command register set sanely.\n\t */\n\tdata = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tdata |= PCI_COMMAND_MASTER_ENABLE | PCI_COMMAND_INVALIDATE_ENABLE;\n\n\t/*\n\t * Not so sure about these- but I think it's important that they get\n\t * enabled......\n\t */\n\tdata |= PCI_COMMAND_PARITY_ENABLE | PCI_COMMAND_SERR_ENABLE;\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, data);\n\n\t/*\n\t * Make sure that the latency timer, cache line size,\n\t * and ROM is disabled.\n\t */\n\tdata = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);\n\tdata &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);\n\tdata &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);\n\tdata |= (0x40 << PCI_LATTIMER_SHIFT);\n\tdata |= (0x10 << PCI_CACHELINE_SHIFT);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);\n\n\tdata = pci_conf_read(pa->pa_pc, pa->pa_tag, PCIR_ROMADDR);\n\tdata &= ~1;\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCIR_ROMADDR, data);\n\n#ifdef DEBUG\n\tif (oneshot) {\n\t\toneshot = 0;\n\t\tprintf(\"Qlogic ISP Driver, OpenBSD (pci) Platform Version \"\n\t\t    \"%d.%d Core Version %d.%d\\n\",\n\t\t    ISP_PLATFORM_VERSION_MAJOR, ISP_PLATFORM_VERSION_MINOR,\n\t\t    ISP_CORE_VERSION_MAJOR, ISP_CORE_VERSION_MINOR);\n\t}\n#endif\n\tif (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt\\n\", isp->isp_name);\n\t\tfree(isp->isp_param, M_DEVBUF);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pa->pa_pc, ih);\n\tif (intrstr == NULL)\n\t\tintrstr = \"<I dunno>\";\n\tpcs->pci_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, isp_pci_intr,\n\t    isp, isp->isp_name);\n\tif (pcs->pci_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt at %s\\n\",\n\t\t\tisp->isp_name, intrstr);\n\t\tfree(isp->isp_param, M_DEVBUF);\n\t\treturn;\n\t}\n\tprintf(\"%s: interrupting at %s\\n\", isp->isp_name, intrstr);\n\n\tif (IS_FC(isp)) {\n\t\tlong foo;\n\t\t/*\n\t\t * This isn't very random, but it's the best we can do for\n\t\t * the real edge case of cards that don't have WWNs.\n\t\t */\n\t\tfoo = (long) isp;\n\t\tfoo >>= 4;\n\t\tfoo &= 0x7;\n\t\twhile (version[foo])\n\t\t\tisp->isp_osinfo.seed += (int) version[foo++];\n\t\tisp->isp_osinfo.seed <<= 8;\n\t\tisp->isp_osinfo.seed += (isp->isp_osinfo._dev.dv_unit + 1);\n\t}\n\n\ts = splbio();\n\tisp_reset(isp);\n\tif (isp->isp_state != ISP_RESETSTATE) {\n\t\tfree(isp->isp_param, M_DEVBUF);\n\t\t(void) splx(s);\n\t\treturn;\n\t}\n\tisp_init(isp);\n\tif (isp->isp_state != ISP_INITSTATE) {\n\t\tisp_uninit(isp);\n\t\tfree(isp->isp_param, M_DEVBUF);\n\t\t(void) splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Create the DMA maps for the data transfers.\n\t */\n\tfor (i = 0; i < isp->isp_maxcmds; i++) {\n\t\tif (bus_dmamap_create(pcs->pci_dmat, MAXPHYS,\n\t\t    (MAXPHYS / NBPG) + 1, MAXPHYS, 0, BUS_DMA_NOWAIT,\n\t\t    &pcs->pci_xfer_dmap[i])) {\n\t\t\tprintf(\"%s: can't create dma maps\\n\", isp->isp_name);\n\t\t\tisp_uninit(isp);\n\t\t\tfree(isp->isp_param, M_DEVBUF);\n\t\t\t(void) splx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Do Generic attach now.\n\t */\n\tisp_attach(isp);\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tisp_uninit(isp);\n\t\tfree(isp->isp_param, M_DEVBUF);\n\t}\n\t(void) splx(s);\n}"
  },
  {
    "function_name": "isp_pci_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/isp_pci.c",
    "lines": "242-276",
    "snippet": "static int\nisp_pci_probe(parent, match, aux)\n        struct device *parent;\n        void *match;\n\tvoid *aux; \n{\n        struct pci_attach_args *pa = aux;\n\n        switch (pa->pa_id) {\n#ifndef\tISP_DISABLE_1020_SUPPORT\n\tcase PCI_QLOGIC_ISP:\n\t\treturn (1);\n#endif\n#ifndef\tISP_DISABLE_1080_SUPPORT\n\tcase PCI_QLOGIC_ISP1080:\n\tcase PCI_QLOGIC_ISP1240:\n\tcase PCI_QLOGIC_ISP1280:\n\t\treturn (1);\n#endif\n#ifndef\tISP_DISABLE_12160_SUPPORT\n\tcase PCI_QLOGIC_ISP12160:\n\t\treturn (1);\n#endif\n#ifndef\tISP_DISABLE_2100_SUPPORT\n\tcase PCI_QLOGIC_ISP2100:\n\t\treturn (1);\n#endif\n#ifndef\tISP_DISABLE_2200_SUPPORT\n\tcase PCI_QLOGIC_ISP2200:\n\t\treturn (1);\n#endif\n\tdefault:\n\t\treturn (0);\n\t}\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/microcode/isp/asm_pci.h>",
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [
      "#define\tPCI_QLOGIC_ISP2200\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP2200 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP2100\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP2100 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP12160\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP12160 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP1280\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1280 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP1240\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1240 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP1080\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1080 << 16) | PCI_VENDOR_QLOGIC)",
      "#define\tPCI_QLOGIC_ISP\t((PCI_PRODUCT_QLOGIC_ISP1020 << 16) | PCI_VENDOR_QLOGIC)"
    ],
    "globals_used": [
      "static int isp_pci_probe"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/microcode/isp/asm_pci.h>\n#include <dev/ic/isp_openbsd.h>\n\n#define\tPCI_QLOGIC_ISP2200\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP2200 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP2100\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP2100 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP12160\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP12160 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP1280\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1280 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP1240\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1240 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP1080\t\\\n\t((PCI_PRODUCT_QLOGIC_ISP1080 << 16) | PCI_VENDOR_QLOGIC)\n#define\tPCI_QLOGIC_ISP\t((PCI_PRODUCT_QLOGIC_ISP1020 << 16) | PCI_VENDOR_QLOGIC)\n\nstatic int isp_pci_probe;\n\nstatic int\nisp_pci_probe(parent, match, aux)\n        struct device *parent;\n        void *match;\n\tvoid *aux; \n{\n        struct pci_attach_args *pa = aux;\n\n        switch (pa->pa_id) {\n#ifndef\tISP_DISABLE_1020_SUPPORT\n\tcase PCI_QLOGIC_ISP:\n\t\treturn (1);\n#endif\n#ifndef\tISP_DISABLE_1080_SUPPORT\n\tcase PCI_QLOGIC_ISP1080:\n\tcase PCI_QLOGIC_ISP1240:\n\tcase PCI_QLOGIC_ISP1280:\n\t\treturn (1);\n#endif\n#ifndef\tISP_DISABLE_12160_SUPPORT\n\tcase PCI_QLOGIC_ISP12160:\n\t\treturn (1);\n#endif\n#ifndef\tISP_DISABLE_2100_SUPPORT\n\tcase PCI_QLOGIC_ISP2100:\n\t\treturn (1);\n#endif\n#ifndef\tISP_DISABLE_2200_SUPPORT\n\tcase PCI_QLOGIC_ISP2200:\n\t\treturn (1);\n#endif\n\tdefault:\n\t\treturn (0);\n\t}\n}"
  }
]