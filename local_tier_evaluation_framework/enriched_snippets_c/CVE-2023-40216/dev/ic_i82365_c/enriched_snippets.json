[
  {
    "function_name": "st_pcic_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1453-1465",
    "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tst_pcic_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "h->ph_bus_t",
            "h->ph_bus_h",
            "PCIC_REG_DATA",
            "data"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "h->ph_bus_t",
            "h->ph_bus_h",
            "PCIC_REG_INDEX",
            "h->sock + idx"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
  },
  {
    "function_name": "st_pcic_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1442-1451",
    "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t st_pcic_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "h->ph_bus_t",
            "h->ph_bus_h",
            "PCIC_REG_DATA"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "h->ph_bus_t",
            "h->ph_bus_h",
            "PCIC_REG_INDEX",
            "h->sock + idx"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
  },
  {
    "function_name": "pcic_chip_socket_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1424-1440",
    "snippet": "void\npcic_chip_socket_disable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\n\tDPRINTF((\"pcic_chip_socket_disable\\n\"));\n\n\t/* power down the socket */\n\n\tpcic_write(h, PCIC_PWRCTL, 0);\n\n\t/*\n\t * wait 300ms until power fails (Tpf).\n\t */\n\tdelay(300 * 1000);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "300 * 1000"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_write",
          "args": [
            "h",
            "PCIC_PWRCTL",
            "0"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1453-1465",
          "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tst_pcic_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_chip_socket_disable\\n\")"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\npcic_chip_socket_disable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\n\tDPRINTF((\"pcic_chip_socket_disable\\n\"));\n\n\t/* power down the socket */\n\n\tpcic_write(h, PCIC_PWRCTL, 0);\n\n\t/*\n\t * wait 300ms until power fails (Tpf).\n\t */\n\tdelay(300 * 1000);\n}"
  },
  {
    "function_name": "pcic_chip_socket_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1326-1422",
    "snippet": "void\npcic_chip_socket_enable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tint cardtype, reg, win;\n\n\t/* this bit is mostly stolen from pcic_attach_card */\n\n\t/* power down the socket to reset it, clear the card reset pin */\n\n\tpcic_write(h, PCIC_PWRCTL, 0);\n\n\t/* \n\t * wait 300ms until power fails (Tpf).  Then, wait 100ms since\n\t * we are changing Vcc (Toff).\n\t */\n\tdelay((300 + 100) * 1000);\n\n\tif (h->vendor == PCIC_VENDOR_VADEM_VG469) {\n\t\treg = pcic_read(h, PCIC_VG469_VSELECT);\n\t\treg &= ~PCIC_VG469_VSELECT_VCC;\n\t\tpcic_write(h, PCIC_VG469_VSELECT, reg);\n\t}\n\n\t/* power up the socket */\n\n\tpcic_write(h, PCIC_PWRCTL, PCIC_PWRCTL_DISABLE_RESETDRV\n\t\t\t   | PCIC_PWRCTL_PWR_ENABLE);\n\n\t/*\n\t * wait 100ms until power raise (Tpr) and 20ms to become\n\t * stable (Tsu(Vcc)).\n\t *\n\t * some machines require some more time to be settled\n\t * (another 200ms is added here).\n\t */\n\tdelay((100 + 20 + 200) * 1000);\n\n\tpcic_write(h, PCIC_PWRCTL, PCIC_PWRCTL_DISABLE_RESETDRV |\n\t    PCIC_PWRCTL_OE | PCIC_PWRCTL_PWR_ENABLE);\n\tpcic_write(h, PCIC_INTR, 0);\n\n\t/*\n\t * hold RESET at least 10us.\n\t */\n\tdelay(10);\n\n\t/* clear the reset flag */\n\n\tpcic_write(h, PCIC_INTR, PCIC_INTR_RESET);\n\n\t/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */\n\n\tdelay(20000);\n\n\t/* wait for the chip to finish initializing */\n\n#ifdef DIAGNOSTIC\n\treg = pcic_read(h, PCIC_IF_STATUS);\n\tif (!(reg & PCIC_IF_STATUS_POWERACTIVE)) {\n\t\tprintf(\"pcic_chip_socket_enable: status %x\", reg);\n\t}\n#endif\n\n\tpcic_wait_ready(h);\n\n\t/* zero out the address windows */\n\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, 0);\n\n\t/* set the card type */\n\n\tcardtype = pcmcia_card_gettype(h->pcmcia);\n\n\treg = pcic_read(h, PCIC_INTR);\n\treg &= ~PCIC_INTR_CARDTYPE_MASK;\n\treg |= ((cardtype == PCMCIA_IFTYPE_IO) ?\n\t\tPCIC_INTR_CARDTYPE_IO :\n\t\tPCIC_INTR_CARDTYPE_MEM);\n\treg |= h->ih_irq;\n\tpcic_write(h, PCIC_INTR, reg);\n\n\tDPRINTF((\"%s: pcic_chip_socket_enable %02x cardtype %s %02x\\n\",\n\t    h->ph_parent->dv_xname, h->sock,\n\t    ((cardtype == PCMCIA_IFTYPE_IO) ? \"io\" : \"mem\"), reg));\n\n\t/* reinstall all the memory and io mappings */\n\n\tfor (win = 0; win < PCIC_MEM_WINS; win++)\n\t\tif (h->memalloc & (1 << win))\n\t\t\tpcic_chip_do_mem_map(h, win);\n\n\tfor (win = 0; win < PCIC_IO_WINS; win++)\n\t\tif (h->ioalloc & (1 << win))\n\t\t\tpcic_chip_do_io_map(h, win);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tPCIC_VENDOR_VADEM_VG469\t\t7"
    ],
    "globals_used": [
      "void\tpcic_attach_card",
      "void\tpcic_chip_do_mem_map",
      "void\tpcic_chip_do_io_map",
      "void\tpcic_wait_ready"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_chip_do_io_map",
          "args": [
            "h",
            "win"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_chip_do_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1206-1234",
          "snippet": "void \npcic_chip_do_io_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\n\tDPRINTF((\"pcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\tpcic_write(h, io_map_index[win].start_lsb, h->io[win].addr & 0xff);\n\tpcic_write(h, io_map_index[win].start_msb,\n\t    (h->io[win].addr >> 8) & 0xff);\n\n\tpcic_write(h, io_map_index[win].stop_lsb,\n\t    (h->io[win].addr + h->io[win].size - 1) & 0xff);\n\tpcic_write(h, io_map_index[win].stop_msb,\n\t    ((h->io[win].addr + h->io[win].size - 1) >> 8) & 0xff);\n\n\treg = pcic_read(h, PCIC_IOCTL);\n\treg &= ~io_map_index[win].ioctlmask;\n\treg |= io_map_index[win].ioctlbits[h->io[win].width];\n\tpcic_write(h, PCIC_IOCTL, reg);\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= io_map_index[win].ioenable;\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_chip_do_io_map",
            "static struct io_map_index_st {\n\tint\tstart_lsb;\n\tint\tstart_msb;\n\tint\tstop_lsb;\n\tint\tstop_msb;\n\tint\tioenable;\n\tint\tioctlmask;\n\tint\tioctlbits[3];\t\t/* indexed by PCMCIA_WIDTH_* */\n}               io_map_index[] = {\n\t{\n\t\tPCIC_IOADDR0_START_LSB,\n\t\tPCIC_IOADDR0_START_MSB,\n\t\tPCIC_IOADDR0_STOP_LSB,\n\t\tPCIC_IOADDR0_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO0,\n\t\tPCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_MASK | PCIC_IOCTL_IO0_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t\t},\n\t},\n\t{\n\t\tPCIC_IOADDR1_START_LSB,\n\t\tPCIC_IOADDR1_START_MSB,\n\t\tPCIC_IOADDR1_STOP_LSB,\n\t\tPCIC_IOADDR1_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO1,\n\t\tPCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\tPCIC_IOCTL_IO1_IOCS16SRC_MASK | PCIC_IOCTL_IO1_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_16BIT,\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_chip_do_io_map;\nstatic struct io_map_index_st {\n\tint\tstart_lsb;\n\tint\tstart_msb;\n\tint\tstop_lsb;\n\tint\tstop_msb;\n\tint\tioenable;\n\tint\tioctlmask;\n\tint\tioctlbits[3];\t\t/* indexed by PCMCIA_WIDTH_* */\n}               io_map_index[] = {\n\t{\n\t\tPCIC_IOADDR0_START_LSB,\n\t\tPCIC_IOADDR0_START_MSB,\n\t\tPCIC_IOADDR0_STOP_LSB,\n\t\tPCIC_IOADDR0_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO0,\n\t\tPCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_MASK | PCIC_IOCTL_IO0_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t\t},\n\t},\n\t{\n\t\tPCIC_IOADDR1_START_LSB,\n\t\tPCIC_IOADDR1_START_MSB,\n\t\tPCIC_IOADDR1_STOP_LSB,\n\t\tPCIC_IOADDR1_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO1,\n\t\tPCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\tPCIC_IOCTL_IO1_IOCS16SRC_MASK | PCIC_IOCTL_IO1_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_16BIT,\n\t\t},\n\t},\n};\n\nvoid \npcic_chip_do_io_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\n\tDPRINTF((\"pcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\tpcic_write(h, io_map_index[win].start_lsb, h->io[win].addr & 0xff);\n\tpcic_write(h, io_map_index[win].start_msb,\n\t    (h->io[win].addr >> 8) & 0xff);\n\n\tpcic_write(h, io_map_index[win].stop_lsb,\n\t    (h->io[win].addr + h->io[win].size - 1) & 0xff);\n\tpcic_write(h, io_map_index[win].stop_msb,\n\t    ((h->io[win].addr + h->io[win].size - 1) >> 8) & 0xff);\n\n\treg = pcic_read(h, PCIC_IOCTL);\n\treg &= ~io_map_index[win].ioctlmask;\n\treg |= io_map_index[win].ioctlbits[h->io[win].width];\n\tpcic_write(h, PCIC_IOCTL, reg);\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= io_map_index[win].ioenable;\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_chip_do_mem_map",
          "args": [
            "h",
            "win"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_chip_do_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "914-968",
          "snippet": "void \npcic_chip_do_mem_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 =\n\t    (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8\n\t    || (kind == PCMCIA_MEM_ATTR);\n\n\tpcic_write(h, mem_map_index[win].sysmem_start_lsb,\n\t    (h->mem[win].addr >> PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_start_msb,\n\t    ((h->mem[win].addr >> (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_START_MSB_ADDR_MASK) |\n\t    (mem8 ? 0 : PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT));\n\n\tpcic_write(h, mem_map_index[win].sysmem_stop_lsb,\n\t    ((h->mem[win].addr + h->mem[win].size) >>\n\t    PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_stop_msb,\n\t    (((h->mem[win].addr + h->mem[win].size) >>\n\t    (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_ADDR_MASK) |\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2);\n\n\tpcic_write(h, mem_map_index[win].cardmem_lsb,\n\t    (h->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].cardmem_msb,\n\t    ((h->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK) |\n\t    ((kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0));\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= (mem_map_index[win].memenable | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n\n#ifdef PCICDEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6;\n\n\t\tr1 = pcic_read(h, mem_map_index[win].sysmem_start_msb);\n\t\tr2 = pcic_read(h, mem_map_index[win].sysmem_start_lsb);\n\t\tr3 = pcic_read(h, mem_map_index[win].sysmem_stop_msb);\n\t\tr4 = pcic_read(h, mem_map_index[win].sysmem_stop_lsb);\n\t\tr5 = pcic_read(h, mem_map_index[win].cardmem_msb);\n\t\tr6 = pcic_read(h, mem_map_index[win].cardmem_lsb);\n\n\t\tDPRINTF((\"pcic_chip_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\\n\", win, r1, r2, r3, r4, r5, r6));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_chip_do_mem_map",
            "static struct mem_map_index_st {\n\tint\tsysmem_start_lsb;\n\tint\tsysmem_start_msb;\n\tint\tsysmem_stop_lsb;\n\tint\tsysmem_stop_msb;\n\tint\tcardmem_lsb;\n\tint\tcardmem_msb;\n\tint\tmemenable;\n} mem_map_index[] = {\n\t{\n\t\tPCIC_SYSMEM_ADDR0_START_LSB,\n\t\tPCIC_SYSMEM_ADDR0_START_MSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR0_LSB,\n\t\tPCIC_CARDMEM_ADDR0_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM0,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR1_START_LSB,\n\t\tPCIC_SYSMEM_ADDR1_START_MSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR1_LSB,\n\t\tPCIC_CARDMEM_ADDR1_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM1,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR2_START_LSB,\n\t\tPCIC_SYSMEM_ADDR2_START_MSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR2_LSB,\n\t\tPCIC_CARDMEM_ADDR2_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM2,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR3_START_LSB,\n\t\tPCIC_SYSMEM_ADDR3_START_MSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR3_LSB,\n\t\tPCIC_CARDMEM_ADDR3_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM3,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR4_START_LSB,\n\t\tPCIC_SYSMEM_ADDR4_START_MSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR4_LSB,\n\t\tPCIC_CARDMEM_ADDR4_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM4,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_chip_do_mem_map;\nstatic struct mem_map_index_st {\n\tint\tsysmem_start_lsb;\n\tint\tsysmem_start_msb;\n\tint\tsysmem_stop_lsb;\n\tint\tsysmem_stop_msb;\n\tint\tcardmem_lsb;\n\tint\tcardmem_msb;\n\tint\tmemenable;\n} mem_map_index[] = {\n\t{\n\t\tPCIC_SYSMEM_ADDR0_START_LSB,\n\t\tPCIC_SYSMEM_ADDR0_START_MSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR0_LSB,\n\t\tPCIC_CARDMEM_ADDR0_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM0,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR1_START_LSB,\n\t\tPCIC_SYSMEM_ADDR1_START_MSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR1_LSB,\n\t\tPCIC_CARDMEM_ADDR1_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM1,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR2_START_LSB,\n\t\tPCIC_SYSMEM_ADDR2_START_MSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR2_LSB,\n\t\tPCIC_CARDMEM_ADDR2_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM2,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR3_START_LSB,\n\t\tPCIC_SYSMEM_ADDR3_START_MSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR3_LSB,\n\t\tPCIC_CARDMEM_ADDR3_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM3,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR4_START_LSB,\n\t\tPCIC_SYSMEM_ADDR4_START_MSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR4_LSB,\n\t\tPCIC_CARDMEM_ADDR4_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM4,\n\t},\n};\n\nvoid \npcic_chip_do_mem_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 =\n\t    (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8\n\t    || (kind == PCMCIA_MEM_ATTR);\n\n\tpcic_write(h, mem_map_index[win].sysmem_start_lsb,\n\t    (h->mem[win].addr >> PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_start_msb,\n\t    ((h->mem[win].addr >> (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_START_MSB_ADDR_MASK) |\n\t    (mem8 ? 0 : PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT));\n\n\tpcic_write(h, mem_map_index[win].sysmem_stop_lsb,\n\t    ((h->mem[win].addr + h->mem[win].size) >>\n\t    PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_stop_msb,\n\t    (((h->mem[win].addr + h->mem[win].size) >>\n\t    (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_ADDR_MASK) |\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2);\n\n\tpcic_write(h, mem_map_index[win].cardmem_lsb,\n\t    (h->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].cardmem_msb,\n\t    ((h->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK) |\n\t    ((kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0));\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= (mem_map_index[win].memenable | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n\n#ifdef PCICDEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6;\n\n\t\tr1 = pcic_read(h, mem_map_index[win].sysmem_start_msb);\n\t\tr2 = pcic_read(h, mem_map_index[win].sysmem_start_lsb);\n\t\tr3 = pcic_read(h, mem_map_index[win].sysmem_stop_msb);\n\t\tr4 = pcic_read(h, mem_map_index[win].sysmem_stop_lsb);\n\t\tr5 = pcic_read(h, mem_map_index[win].cardmem_msb);\n\t\tr6 = pcic_read(h, mem_map_index[win].cardmem_lsb);\n\n\t\tDPRINTF((\"pcic_chip_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\\n\", win, r1, r2, r3, r4, r5, r6));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: pcic_chip_socket_enable %02x cardtype %s %02x\\n\",\n\t    h->ph_parent->dv_xname, h->sock,\n\t    ((cardtype == PCMCIA_IFTYPE_IO) ? \"io\" : \"mem\"), reg)"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcic_write",
          "args": [
            "h",
            "PCIC_INTR",
            "reg"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1453-1465",
          "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tst_pcic_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_read",
          "args": [
            "h",
            "PCIC_INTR"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1442-1451",
          "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t st_pcic_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_card_gettype",
          "args": [
            "h->pcmcia"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_gettype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "367-386",
          "snippet": "int \npcmcia_card_gettype(dev)\n\tstruct device  *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *)dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * Set the iftype to memory if this card has no functions (not yet\n\t * probed), or only one function, and that is not initialized yet or\n\t * that is memory.\n\t */\n\tpf = SIMPLEQ_FIRST(&sc->card.pf_head);\n\tif (pf == NULL || (SIMPLEQ_NEXT(pf, pf_list) == NULL &&\n\t    ((pf->pf_flags & PFF_FAKE) ||\n\t    pf->cfe == NULL || pf->cfe->iftype == PCMCIA_IFTYPE_MEMORY)))\n\t\treturn (PCMCIA_IFTYPE_MEMORY);\n\telse\n\t\treturn (PCMCIA_IFTYPE_IO);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint \npcmcia_card_gettype(dev)\n\tstruct device  *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *)dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * Set the iftype to memory if this card has no functions (not yet\n\t * probed), or only one function, and that is not initialized yet or\n\t * that is memory.\n\t */\n\tpf = SIMPLEQ_FIRST(&sc->card.pf_head);\n\tif (pf == NULL || (SIMPLEQ_NEXT(pf, pf_list) == NULL &&\n\t    ((pf->pf_flags & PFF_FAKE) ||\n\t    pf->cfe == NULL || pf->cfe->iftype == PCMCIA_IFTYPE_MEMORY)))\n\t\treturn (PCMCIA_IFTYPE_MEMORY);\n\telse\n\t\treturn (PCMCIA_IFTYPE_IO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_wait_ready",
          "args": [
            "h"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_wait_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1304-1324",
          "snippet": "void\npcic_wait_ready(h)\n\tstruct pcic_handle *h;\n{\n\tint i;\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (pcic_read(h, PCIC_IF_STATUS) & PCIC_IF_STATUS_READY)\n\t\t\treturn;\n\t\tdelay(500);\n#ifdef PCICDEBUG\n\t\t\tif ((i>5000) && (i%100 == 99))\n\t\t\t\tprintf(\".\");\n#endif\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintf(\"pcic_wait_ready: ready never happened, status = %02x\\n\",\n\t    pcic_read(h, PCIC_IF_STATUS));\n#endif\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_wait_ready"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_wait_ready;\n\nvoid\npcic_wait_ready(h)\n\tstruct pcic_handle *h;\n{\n\tint i;\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (pcic_read(h, PCIC_IF_STATUS) & PCIC_IF_STATUS_READY)\n\t\t\treturn;\n\t\tdelay(500);\n#ifdef PCICDEBUG\n\t\t\tif ((i>5000) && (i%100 == 99))\n\t\t\t\tprintf(\".\");\n#endif\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintf(\"pcic_wait_ready: ready never happened, status = %02x\\n\",\n\t    pcic_read(h, PCIC_IF_STATUS));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"pcic_chip_socket_enable: status %x\"",
            "reg"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "20000"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCIC_VENDOR_VADEM_VG469\t\t7\n\nvoid\tpcic_attach_card;\nvoid\tpcic_chip_do_mem_map;\nvoid\tpcic_chip_do_io_map;\nvoid\tpcic_wait_ready;\n\nvoid\npcic_chip_socket_enable(pch)\n\tpcmcia_chipset_handle_t pch;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tint cardtype, reg, win;\n\n\t/* this bit is mostly stolen from pcic_attach_card */\n\n\t/* power down the socket to reset it, clear the card reset pin */\n\n\tpcic_write(h, PCIC_PWRCTL, 0);\n\n\t/* \n\t * wait 300ms until power fails (Tpf).  Then, wait 100ms since\n\t * we are changing Vcc (Toff).\n\t */\n\tdelay((300 + 100) * 1000);\n\n\tif (h->vendor == PCIC_VENDOR_VADEM_VG469) {\n\t\treg = pcic_read(h, PCIC_VG469_VSELECT);\n\t\treg &= ~PCIC_VG469_VSELECT_VCC;\n\t\tpcic_write(h, PCIC_VG469_VSELECT, reg);\n\t}\n\n\t/* power up the socket */\n\n\tpcic_write(h, PCIC_PWRCTL, PCIC_PWRCTL_DISABLE_RESETDRV\n\t\t\t   | PCIC_PWRCTL_PWR_ENABLE);\n\n\t/*\n\t * wait 100ms until power raise (Tpr) and 20ms to become\n\t * stable (Tsu(Vcc)).\n\t *\n\t * some machines require some more time to be settled\n\t * (another 200ms is added here).\n\t */\n\tdelay((100 + 20 + 200) * 1000);\n\n\tpcic_write(h, PCIC_PWRCTL, PCIC_PWRCTL_DISABLE_RESETDRV |\n\t    PCIC_PWRCTL_OE | PCIC_PWRCTL_PWR_ENABLE);\n\tpcic_write(h, PCIC_INTR, 0);\n\n\t/*\n\t * hold RESET at least 10us.\n\t */\n\tdelay(10);\n\n\t/* clear the reset flag */\n\n\tpcic_write(h, PCIC_INTR, PCIC_INTR_RESET);\n\n\t/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */\n\n\tdelay(20000);\n\n\t/* wait for the chip to finish initializing */\n\n#ifdef DIAGNOSTIC\n\treg = pcic_read(h, PCIC_IF_STATUS);\n\tif (!(reg & PCIC_IF_STATUS_POWERACTIVE)) {\n\t\tprintf(\"pcic_chip_socket_enable: status %x\", reg);\n\t}\n#endif\n\n\tpcic_wait_ready(h);\n\n\t/* zero out the address windows */\n\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, 0);\n\n\t/* set the card type */\n\n\tcardtype = pcmcia_card_gettype(h->pcmcia);\n\n\treg = pcic_read(h, PCIC_INTR);\n\treg &= ~PCIC_INTR_CARDTYPE_MASK;\n\treg |= ((cardtype == PCMCIA_IFTYPE_IO) ?\n\t\tPCIC_INTR_CARDTYPE_IO :\n\t\tPCIC_INTR_CARDTYPE_MEM);\n\treg |= h->ih_irq;\n\tpcic_write(h, PCIC_INTR, reg);\n\n\tDPRINTF((\"%s: pcic_chip_socket_enable %02x cardtype %s %02x\\n\",\n\t    h->ph_parent->dv_xname, h->sock,\n\t    ((cardtype == PCMCIA_IFTYPE_IO) ? \"io\" : \"mem\"), reg));\n\n\t/* reinstall all the memory and io mappings */\n\n\tfor (win = 0; win < PCIC_MEM_WINS; win++)\n\t\tif (h->memalloc & (1 << win))\n\t\t\tpcic_chip_do_mem_map(h, win);\n\n\tfor (win = 0; win < PCIC_IO_WINS; win++)\n\t\tif (h->ioalloc & (1 << win))\n\t\t\tpcic_chip_do_io_map(h, win);\n}"
  },
  {
    "function_name": "pcic_wait_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1304-1324",
    "snippet": "void\npcic_wait_ready(h)\n\tstruct pcic_handle *h;\n{\n\tint i;\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (pcic_read(h, PCIC_IF_STATUS) & PCIC_IF_STATUS_READY)\n\t\t\treturn;\n\t\tdelay(500);\n#ifdef PCICDEBUG\n\t\t\tif ((i>5000) && (i%100 == 99))\n\t\t\t\tprintf(\".\");\n#endif\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintf(\"pcic_wait_ready: ready never happened, status = %02x\\n\",\n\t    pcic_read(h, PCIC_IF_STATUS));\n#endif\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_wait_ready"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"pcic_wait_ready: ready never happened, status = %02x\\n\"",
            "pcic_read(h, PCIC_IF_STATUS)"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_read",
          "args": [
            "h",
            "PCIC_IF_STATUS"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1442-1451",
          "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t st_pcic_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "500"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_wait_ready;\n\nvoid\npcic_wait_ready(h)\n\tstruct pcic_handle *h;\n{\n\tint i;\n\n\tfor (i = 0; i < 10000; i++) {\n\t\tif (pcic_read(h, PCIC_IF_STATUS) & PCIC_IF_STATUS_READY)\n\t\t\treturn;\n\t\tdelay(500);\n#ifdef PCICDEBUG\n\t\t\tif ((i>5000) && (i%100 == 99))\n\t\t\t\tprintf(\".\");\n#endif\n\t}\n\n#ifdef DIAGNOSTIC\n\tprintf(\"pcic_wait_ready: ready never happened, status = %02x\\n\",\n\t    pcic_read(h, PCIC_IF_STATUS));\n#endif\n}"
  },
  {
    "function_name": "pcic_chip_io_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1286-1302",
    "snippet": "void \npcic_chip_io_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tint reg;\n\n\tif (window >= (sizeof(io_map_index) / sizeof(io_map_index[0])))\n\t\tpanic(\"pcic_chip_io_unmap: window out of range\");\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg &= ~io_map_index[window].ioenable;\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n\n\th->ioalloc &= ~(1 << window);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_write",
          "args": [
            "h",
            "PCIC_ADDRWIN_ENABLE",
            "reg"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1453-1465",
          "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tst_pcic_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_read",
          "args": [
            "h",
            "PCIC_ADDRWIN_ENABLE"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1442-1451",
          "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t st_pcic_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcic_chip_io_unmap: window out of range\""
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \npcic_chip_io_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tint reg;\n\n\tif (window >= (sizeof(io_map_index) / sizeof(io_map_index[0])))\n\t\tpanic(\"pcic_chip_io_unmap: window out of range\");\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg &= ~io_map_index[window].ioenable;\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n\n\th->ioalloc &= ~(1 << window);\n}"
  },
  {
    "function_name": "pcic_chip_io_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1236-1284",
    "snippet": "int \npcic_chip_io_map(pch, width, offset, size, pcihp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tbus_addr_t ioaddr = pcihp->addr + offset;\n\tint i, win;\n#ifdef PCICDEBUG\n\tstatic char *width_names[] = { \"auto\", \"io8\", \"io16\" };\n#endif\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/* XXX Sanity check offset/size. */\n\n\twin = -1;\n\tfor (i = 0; i < (sizeof(io_map_index) / sizeof(io_map_index[0])); i++) {\n\t\tif ((h->ioalloc & (1 << i)) == 0) {\n\t\t\twin = i;\n\t\t\th->ioalloc |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == -1)\n\t\treturn (1);\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (sc->iot != pcihp->iot)\n\t\tpanic(\"pcic_chip_io_map iot is bogus\");\n\n\tDPRINTF((\"pcic_chip_io_map window %d %s port %lx+%lx\\n\",\n\t\t win, width_names[width], (u_long) ioaddr, (u_long) size));\n\n\th->io[win].addr = ioaddr;\n\th->io[win].size = size;\n\th->io[win].width = width;\n\n\tpcic_chip_do_io_map(h, win);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_chip_do_io_map"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_chip_do_io_map",
          "args": [
            "h",
            "win"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_chip_do_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1206-1234",
          "snippet": "void \npcic_chip_do_io_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\n\tDPRINTF((\"pcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\tpcic_write(h, io_map_index[win].start_lsb, h->io[win].addr & 0xff);\n\tpcic_write(h, io_map_index[win].start_msb,\n\t    (h->io[win].addr >> 8) & 0xff);\n\n\tpcic_write(h, io_map_index[win].stop_lsb,\n\t    (h->io[win].addr + h->io[win].size - 1) & 0xff);\n\tpcic_write(h, io_map_index[win].stop_msb,\n\t    ((h->io[win].addr + h->io[win].size - 1) >> 8) & 0xff);\n\n\treg = pcic_read(h, PCIC_IOCTL);\n\treg &= ~io_map_index[win].ioctlmask;\n\treg |= io_map_index[win].ioctlbits[h->io[win].width];\n\tpcic_write(h, PCIC_IOCTL, reg);\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= io_map_index[win].ioenable;\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_chip_do_io_map",
            "static struct io_map_index_st {\n\tint\tstart_lsb;\n\tint\tstart_msb;\n\tint\tstop_lsb;\n\tint\tstop_msb;\n\tint\tioenable;\n\tint\tioctlmask;\n\tint\tioctlbits[3];\t\t/* indexed by PCMCIA_WIDTH_* */\n}               io_map_index[] = {\n\t{\n\t\tPCIC_IOADDR0_START_LSB,\n\t\tPCIC_IOADDR0_START_MSB,\n\t\tPCIC_IOADDR0_STOP_LSB,\n\t\tPCIC_IOADDR0_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO0,\n\t\tPCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_MASK | PCIC_IOCTL_IO0_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t\t},\n\t},\n\t{\n\t\tPCIC_IOADDR1_START_LSB,\n\t\tPCIC_IOADDR1_START_MSB,\n\t\tPCIC_IOADDR1_STOP_LSB,\n\t\tPCIC_IOADDR1_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO1,\n\t\tPCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\tPCIC_IOCTL_IO1_IOCS16SRC_MASK | PCIC_IOCTL_IO1_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_16BIT,\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_chip_do_io_map;\nstatic struct io_map_index_st {\n\tint\tstart_lsb;\n\tint\tstart_msb;\n\tint\tstop_lsb;\n\tint\tstop_msb;\n\tint\tioenable;\n\tint\tioctlmask;\n\tint\tioctlbits[3];\t\t/* indexed by PCMCIA_WIDTH_* */\n}               io_map_index[] = {\n\t{\n\t\tPCIC_IOADDR0_START_LSB,\n\t\tPCIC_IOADDR0_START_MSB,\n\t\tPCIC_IOADDR0_STOP_LSB,\n\t\tPCIC_IOADDR0_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO0,\n\t\tPCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_MASK | PCIC_IOCTL_IO0_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t\t},\n\t},\n\t{\n\t\tPCIC_IOADDR1_START_LSB,\n\t\tPCIC_IOADDR1_START_MSB,\n\t\tPCIC_IOADDR1_STOP_LSB,\n\t\tPCIC_IOADDR1_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO1,\n\t\tPCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\tPCIC_IOCTL_IO1_IOCS16SRC_MASK | PCIC_IOCTL_IO1_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_16BIT,\n\t\t},\n\t},\n};\n\nvoid \npcic_chip_do_io_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\n\tDPRINTF((\"pcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\tpcic_write(h, io_map_index[win].start_lsb, h->io[win].addr & 0xff);\n\tpcic_write(h, io_map_index[win].start_msb,\n\t    (h->io[win].addr >> 8) & 0xff);\n\n\tpcic_write(h, io_map_index[win].stop_lsb,\n\t    (h->io[win].addr + h->io[win].size - 1) & 0xff);\n\tpcic_write(h, io_map_index[win].stop_msb,\n\t    ((h->io[win].addr + h->io[win].size - 1) >> 8) & 0xff);\n\n\treg = pcic_read(h, PCIC_IOCTL);\n\treg &= ~io_map_index[win].ioctlmask;\n\treg |= io_map_index[win].ioctlbits[h->io[win].width];\n\tpcic_write(h, PCIC_IOCTL, reg);\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= io_map_index[win].ioenable;\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_chip_io_map window %d %s port %lx+%lx\\n\",\n\t\t win, width_names[width], (u_long) ioaddr, (u_long) size)"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcic_chip_io_map iot is bogus\""
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_chip_do_io_map;\n\nint \npcic_chip_io_map(pch, width, offset, size, pcihp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tbus_addr_t ioaddr = pcihp->addr + offset;\n\tint i, win;\n#ifdef PCICDEBUG\n\tstatic char *width_names[] = { \"auto\", \"io8\", \"io16\" };\n#endif\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/* XXX Sanity check offset/size. */\n\n\twin = -1;\n\tfor (i = 0; i < (sizeof(io_map_index) / sizeof(io_map_index[0])); i++) {\n\t\tif ((h->ioalloc & (1 << i)) == 0) {\n\t\t\twin = i;\n\t\t\th->ioalloc |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == -1)\n\t\treturn (1);\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (sc->iot != pcihp->iot)\n\t\tpanic(\"pcic_chip_io_map iot is bogus\");\n\n\tDPRINTF((\"pcic_chip_io_map window %d %s port %lx+%lx\\n\",\n\t\t win, width_names[width], (u_long) ioaddr, (u_long) size));\n\n\th->io[win].addr = ioaddr;\n\th->io[win].size = size;\n\th->io[win].width = width;\n\n\tpcic_chip_do_io_map(h, win);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "pcic_chip_do_io_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1206-1234",
    "snippet": "void \npcic_chip_do_io_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\n\tDPRINTF((\"pcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\tpcic_write(h, io_map_index[win].start_lsb, h->io[win].addr & 0xff);\n\tpcic_write(h, io_map_index[win].start_msb,\n\t    (h->io[win].addr >> 8) & 0xff);\n\n\tpcic_write(h, io_map_index[win].stop_lsb,\n\t    (h->io[win].addr + h->io[win].size - 1) & 0xff);\n\tpcic_write(h, io_map_index[win].stop_msb,\n\t    ((h->io[win].addr + h->io[win].size - 1) >> 8) & 0xff);\n\n\treg = pcic_read(h, PCIC_IOCTL);\n\treg &= ~io_map_index[win].ioctlmask;\n\treg |= io_map_index[win].ioctlbits[h->io[win].width];\n\tpcic_write(h, PCIC_IOCTL, reg);\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= io_map_index[win].ioenable;\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_chip_do_io_map",
      "static struct io_map_index_st {\n\tint\tstart_lsb;\n\tint\tstart_msb;\n\tint\tstop_lsb;\n\tint\tstop_msb;\n\tint\tioenable;\n\tint\tioctlmask;\n\tint\tioctlbits[3];\t\t/* indexed by PCMCIA_WIDTH_* */\n}               io_map_index[] = {\n\t{\n\t\tPCIC_IOADDR0_START_LSB,\n\t\tPCIC_IOADDR0_START_MSB,\n\t\tPCIC_IOADDR0_STOP_LSB,\n\t\tPCIC_IOADDR0_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO0,\n\t\tPCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_MASK | PCIC_IOCTL_IO0_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t\t},\n\t},\n\t{\n\t\tPCIC_IOADDR1_START_LSB,\n\t\tPCIC_IOADDR1_START_MSB,\n\t\tPCIC_IOADDR1_STOP_LSB,\n\t\tPCIC_IOADDR1_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO1,\n\t\tPCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\tPCIC_IOCTL_IO1_IOCS16SRC_MASK | PCIC_IOCTL_IO1_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_16BIT,\n\t\t},\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_write",
          "args": [
            "h",
            "PCIC_ADDRWIN_ENABLE",
            "reg"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1453-1465",
          "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tst_pcic_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_read",
          "args": [
            "h",
            "PCIC_ADDRWIN_ENABLE"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1442-1451",
          "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t st_pcic_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_chip_do_io_map;\nstatic struct io_map_index_st {\n\tint\tstart_lsb;\n\tint\tstart_msb;\n\tint\tstop_lsb;\n\tint\tstop_msb;\n\tint\tioenable;\n\tint\tioctlmask;\n\tint\tioctlbits[3];\t\t/* indexed by PCMCIA_WIDTH_* */\n}               io_map_index[] = {\n\t{\n\t\tPCIC_IOADDR0_START_LSB,\n\t\tPCIC_IOADDR0_START_MSB,\n\t\tPCIC_IOADDR0_STOP_LSB,\n\t\tPCIC_IOADDR0_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO0,\n\t\tPCIC_IOCTL_IO0_WAITSTATE | PCIC_IOCTL_IO0_ZEROWAIT |\n\t\tPCIC_IOCTL_IO0_IOCS16SRC_MASK | PCIC_IOCTL_IO0_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO0_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO0_DATASIZE_16BIT,\n\t\t},\n\t},\n\t{\n\t\tPCIC_IOADDR1_START_LSB,\n\t\tPCIC_IOADDR1_START_MSB,\n\t\tPCIC_IOADDR1_STOP_LSB,\n\t\tPCIC_IOADDR1_STOP_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_IO1,\n\t\tPCIC_IOCTL_IO1_WAITSTATE | PCIC_IOCTL_IO1_ZEROWAIT |\n\t\tPCIC_IOCTL_IO1_IOCS16SRC_MASK | PCIC_IOCTL_IO1_DATASIZE_MASK,\n\t\t{\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_CARD,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_8BIT,\n\t\t\tPCIC_IOCTL_IO1_IOCS16SRC_DATASIZE |\n\t\t\t    PCIC_IOCTL_IO1_DATASIZE_16BIT,\n\t\t},\n\t},\n};\n\nvoid \npcic_chip_do_io_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\n\tDPRINTF((\"pcic_chip_do_io_map win %d addr %lx size %lx width %d\\n\",\n\t    win, (long) h->io[win].addr, (long) h->io[win].size,\n\t    h->io[win].width * 8));\n\n\tpcic_write(h, io_map_index[win].start_lsb, h->io[win].addr & 0xff);\n\tpcic_write(h, io_map_index[win].start_msb,\n\t    (h->io[win].addr >> 8) & 0xff);\n\n\tpcic_write(h, io_map_index[win].stop_lsb,\n\t    (h->io[win].addr + h->io[win].size - 1) & 0xff);\n\tpcic_write(h, io_map_index[win].stop_msb,\n\t    ((h->io[win].addr + h->io[win].size - 1) >> 8) & 0xff);\n\n\treg = pcic_read(h, PCIC_IOCTL);\n\treg &= ~io_map_index[win].ioctlmask;\n\treg |= io_map_index[win].ioctlbits[h->io[win].width];\n\tpcic_write(h, PCIC_IOCTL, reg);\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= io_map_index[win].ioenable;\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n}"
  },
  {
    "function_name": "pcic_chip_io_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1147-1160",
    "snippet": "void \npcic_chip_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tbus_space_tag_t iot = pcihp->iot;\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "size"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_free",
          "args": [
            "iot",
            "ioh",
            "size"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "179-207",
          "snippet": "int\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \npcic_chip_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tbus_space_tag_t iot = pcihp->iot;\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n}"
  },
  {
    "function_name": "pcic_chip_io_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1058-1145",
    "snippet": "int \npcic_chip_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_addr_t ioaddr, beg, fin;\n\tint flags = 0;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\tstruct pcic_ranges *range;\n\n\t/*\n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = sc->iot;\n\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh))\n\t\t\treturn (1);\n\t\tDPRINTF((\"pcic_chip_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long)ioaddr, (u_long)size));\n\t} else if (sc->ranges) {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\n \t\t/*\n\t\t * In this case, we know the \"size\" and \"align\" that\n\t\t * we want.  So we need to start walking down\n\t\t * sc->ranges, searching for a similar space that\n\t\t * is (1) large enough for the size and alignment\n\t\t * (2) then we need to try to allocate\n\t\t * (3) if it fails to allocate, we try next range.\n\t\t *\n\t\t * We must also check that the start/size of each\n\t\t * allocation we are about to do is within the bounds\n\t\t * of \"sc->iobase\" and \"sc->iosize\".\n\t\t * (Some pcmcia controllers handle a 12 bits of addressing,\n\t\t * but we want to use the same range structure)\n\t\t */\n\t\tfor (range = sc->ranges; range->start; range++) {\n\t\t\t/* Potentially trim the range because of bounds. */\n\t\t\tbeg = max(range->start, sc->iobase);\n\t\t\tfin = min(range->start + range->len,\n\t\t\t    sc->iobase + sc->iosize);\n\n\t\t\t/* Short-circuit easy cases. */\n\t\t\tif (fin < beg || fin - beg < size)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * This call magically fulfills our alignment\n\t\t\t * requirements.\n\t\t\t */\n\t\t\tDPRINTF((\"pcic_chip_io_alloc beg-fin %lx-%lx\\n\",\n\t\t\t    (u_long)beg, (u_long)fin));\n\t\t\tif (bus_space_alloc(iot, beg, fin, size, align, 0, 0,\n\t\t\t    &ioaddr, &ioh) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (range->start == 0)\n\t\t\treturn (1);\n\t\tDPRINTF((\"pcic_chip_io_alloc alloc port %lx+%lx\\n\",\n\t\t    (u_long)ioaddr, (u_long)size));\n\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, sc->iobase,\n\t\t    sc->iobase + sc->iosize, size, align, 0, 0,\n\t\t    &ioaddr, &ioh))\n\t\t\treturn (1);\n\t\tDPRINTF((\"pcic_chip_io_alloc alloc port %lx+%lx\\n\",\n\t\t    (u_long)ioaddr, (u_long)size));\n\t}\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_chip_io_alloc alloc port %lx+%lx\\n\",\n\t\t    (u_long)ioaddr, (u_long)size)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_alloc",
          "args": [
            "iot",
            "sc->iobase",
            "sc->iobase + sc->iosize",
            "size",
            "align",
            "0",
            "0",
            "&ioaddr",
            "&ioh"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_alloc_subregion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "82-173",
          "snippet": "int\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct extent *ex, bus_addr_t start,\n\t\t\t\t    bus_addr_t end, bus_addr_t offset,\n\t\t\t\t    int flags));\n\nint\nrbus_space_alloc_subregion(rbt, substart, subend, addr, size, mask, align, flags, addrp, bshp)\n     rbus_tag_t rbt;\n     bus_addr_t addr;\n     bus_addr_t substart;\n     bus_addr_t subend;\n     bus_size_t size;\n     bus_addr_t mask, align;\n     int flags;\n     bus_addr_t *addrp;\n     bus_space_handle_t *bshp;\n{\n  bus_addr_t decodesize = mask + 1;\n  bus_addr_t boundary, search_addr;\n  int val = 0;\n  bus_addr_t result;\n  int exflags = EX_FAST | EX_NOWAIT;\n\n  DPRINTF((\"rbus_space_alloc: addr %lx, size %lx, mask %lx, align %lx\\n\",\n\t   addr, size, mask, align));\n\n  addr += rbt->rb_offset;\n\n  if (mask == 0) {\n    /* FULL Decode */\n    decodesize = 0;\n  }\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    return rbus_space_alloc(rbt->rb_parent, addr, size, mask, align, flags,\n\t\t\t    addrp, bshp);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    /* rbt has its own sh_extent */\n\n    /* sanity check: the subregion [substart, subend] should be\n       smaller than the region included in sh_extent */\n    if (substart < rbt->rb_ext->ex_start || subend > rbt->rb_ext->ex_end) {\n      return 1;\n    }\n\n    if (decodesize == align) {\n      if(extent_alloc_subregion(rbt->rb_ext, substart, subend, size, align, 0,\n\t\t\t\texflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else if (decodesize == 0) {\n      /* maybe, the resister is overflowed. */\n      \n      if (extent_alloc_subregion(rbt->rb_ext, addr, addr + size, size,\n\t\t\t\t 0, 0, exflags, (u_long *)&result)) {\n\treturn 1;\n      }\n    } else {\n\n      boundary = decodesize > align ? decodesize : align;\n\n      search_addr = (substart & ~(boundary - 1)) + addr;\n\n      if (search_addr < substart) {\n\tsearch_addr += boundary;\n      }\n\n      for (; search_addr + size <= subend; search_addr += boundary) {\n\tval = extent_alloc_subregion(rbt->rb_ext,search_addr, search_addr+size,\n\t\t\t\tsize, align, 0, exflags, (u_long *)&result);\n\tif (val == 0) {\n\t  break;\n\t}\n      }\n      if (val) {\n\treturn 1;\n      }\n    }\n\n    if(md_space_map(rbt->rb_bt, result, size, flags, bshp)) {\n      /* map failed */\n      extent_free(rbt->rb_ext, result, size, exflags);\n      return 1;\n    }\n\n    if (addrp != NULL) {\n      *addrp = result + rbt->rb_offset;\n    }\n    return 0;\n\n  } else {\n    /* error!! */\n    return 1;\n  }\n  return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_chip_io_alloc alloc port %lx+%lx\\n\",\n\t\t    (u_long)ioaddr, (u_long)size)"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_chip_io_alloc beg-fin %lx-%lx\\n\",\n\t\t\t    (u_long)beg, (u_long)fin)"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "range->start + range->len",
            "sc->iobase + sc->iosize"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "range->start",
            "sc->iobase"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_chip_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long)ioaddr, (u_long)size)"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "start",
            "size",
            "0",
            "&ioh"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint \npcic_chip_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_addr_t ioaddr, beg, fin;\n\tint flags = 0;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\tstruct pcic_ranges *range;\n\n\t/*\n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = sc->iot;\n\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh))\n\t\t\treturn (1);\n\t\tDPRINTF((\"pcic_chip_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long)ioaddr, (u_long)size));\n\t} else if (sc->ranges) {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\n \t\t/*\n\t\t * In this case, we know the \"size\" and \"align\" that\n\t\t * we want.  So we need to start walking down\n\t\t * sc->ranges, searching for a similar space that\n\t\t * is (1) large enough for the size and alignment\n\t\t * (2) then we need to try to allocate\n\t\t * (3) if it fails to allocate, we try next range.\n\t\t *\n\t\t * We must also check that the start/size of each\n\t\t * allocation we are about to do is within the bounds\n\t\t * of \"sc->iobase\" and \"sc->iosize\".\n\t\t * (Some pcmcia controllers handle a 12 bits of addressing,\n\t\t * but we want to use the same range structure)\n\t\t */\n\t\tfor (range = sc->ranges; range->start; range++) {\n\t\t\t/* Potentially trim the range because of bounds. */\n\t\t\tbeg = max(range->start, sc->iobase);\n\t\t\tfin = min(range->start + range->len,\n\t\t\t    sc->iobase + sc->iosize);\n\n\t\t\t/* Short-circuit easy cases. */\n\t\t\tif (fin < beg || fin - beg < size)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * This call magically fulfills our alignment\n\t\t\t * requirements.\n\t\t\t */\n\t\t\tDPRINTF((\"pcic_chip_io_alloc beg-fin %lx-%lx\\n\",\n\t\t\t    (u_long)beg, (u_long)fin));\n\t\t\tif (bus_space_alloc(iot, beg, fin, size, align, 0, 0,\n\t\t\t    &ioaddr, &ioh) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (range->start == 0)\n\t\t\treturn (1);\n\t\tDPRINTF((\"pcic_chip_io_alloc alloc port %lx+%lx\\n\",\n\t\t    (u_long)ioaddr, (u_long)size));\n\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, sc->iobase,\n\t\t    sc->iobase + sc->iosize, size, align, 0, 0,\n\t\t    &ioaddr, &ioh))\n\t\t\treturn (1);\n\t\tDPRINTF((\"pcic_chip_io_alloc alloc port %lx+%lx\\n\",\n\t\t    (u_long)ioaddr, (u_long)size));\n\t}\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "pcic_chip_mem_unmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "1040-1056",
    "snippet": "void \npcic_chip_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tint reg;\n\n\tif (window >= (sizeof(mem_map_index) / sizeof(mem_map_index[0])))\n\t\tpanic(\"pcic_chip_mem_unmap: window out of range\");\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg &= ~mem_map_index[window].memenable;\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n\n\th->memalloc &= ~(1 << window);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mem_map_index_st {\n\tint\tsysmem_start_lsb;\n\tint\tsysmem_start_msb;\n\tint\tsysmem_stop_lsb;\n\tint\tsysmem_stop_msb;\n\tint\tcardmem_lsb;\n\tint\tcardmem_msb;\n\tint\tmemenable;\n} mem_map_index[] = {\n\t{\n\t\tPCIC_SYSMEM_ADDR0_START_LSB,\n\t\tPCIC_SYSMEM_ADDR0_START_MSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR0_LSB,\n\t\tPCIC_CARDMEM_ADDR0_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM0,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR1_START_LSB,\n\t\tPCIC_SYSMEM_ADDR1_START_MSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR1_LSB,\n\t\tPCIC_CARDMEM_ADDR1_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM1,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR2_START_LSB,\n\t\tPCIC_SYSMEM_ADDR2_START_MSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR2_LSB,\n\t\tPCIC_CARDMEM_ADDR2_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM2,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR3_START_LSB,\n\t\tPCIC_SYSMEM_ADDR3_START_MSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR3_LSB,\n\t\tPCIC_CARDMEM_ADDR3_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM3,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR4_START_LSB,\n\t\tPCIC_SYSMEM_ADDR4_START_MSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR4_LSB,\n\t\tPCIC_CARDMEM_ADDR4_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM4,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_write",
          "args": [
            "h",
            "PCIC_ADDRWIN_ENABLE",
            "reg"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1453-1465",
          "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tst_pcic_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_read",
          "args": [
            "h",
            "PCIC_ADDRWIN_ENABLE"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1442-1451",
          "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t st_pcic_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcic_chip_mem_unmap: window out of range\""
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic struct mem_map_index_st {\n\tint\tsysmem_start_lsb;\n\tint\tsysmem_start_msb;\n\tint\tsysmem_stop_lsb;\n\tint\tsysmem_stop_msb;\n\tint\tcardmem_lsb;\n\tint\tcardmem_msb;\n\tint\tmemenable;\n} mem_map_index[] = {\n\t{\n\t\tPCIC_SYSMEM_ADDR0_START_LSB,\n\t\tPCIC_SYSMEM_ADDR0_START_MSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR0_LSB,\n\t\tPCIC_CARDMEM_ADDR0_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM0,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR1_START_LSB,\n\t\tPCIC_SYSMEM_ADDR1_START_MSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR1_LSB,\n\t\tPCIC_CARDMEM_ADDR1_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM1,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR2_START_LSB,\n\t\tPCIC_SYSMEM_ADDR2_START_MSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR2_LSB,\n\t\tPCIC_CARDMEM_ADDR2_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM2,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR3_START_LSB,\n\t\tPCIC_SYSMEM_ADDR3_START_MSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR3_LSB,\n\t\tPCIC_CARDMEM_ADDR3_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM3,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR4_START_LSB,\n\t\tPCIC_SYSMEM_ADDR4_START_MSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR4_LSB,\n\t\tPCIC_CARDMEM_ADDR4_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM4,\n\t},\n};\n\nvoid \npcic_chip_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tint reg;\n\n\tif (window >= (sizeof(mem_map_index) / sizeof(mem_map_index[0])))\n\t\tpanic(\"pcic_chip_mem_unmap: window out of range\");\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg &= ~mem_map_index[window].memenable;\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n\n\th->memalloc &= ~(1 << window);\n}"
  },
  {
    "function_name": "pcic_chip_mem_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "970-1038",
    "snippet": "int \npcic_chip_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint i, win;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\twin = -1;\n\tfor (i = 0; i < (sizeof(mem_map_index) / sizeof(mem_map_index[0]));\n\t    i++) {\n\t\tif ((h->memalloc & (1 << i)) == 0) {\n\t\t\twin = i;\n\t\t\th->memalloc |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == -1)\n\t\treturn (1);\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (sc->memt != pcmhp->memt)\n\t\tpanic(\"pcic_chip_mem_map memt is bogus\");\n\n\tbusaddr = pcmhp->addr;\n\n\t/*\n\t * Compute the address offset to the pcmcia address space for the\n\t * pcic.  This is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_ALIGN;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pcic_chip_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/*\n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long) card_addr) - ((long) busaddr));\n\n\th->mem[win].addr = busaddr;\n\th->mem[win].size = size;\n\th->mem[win].offset = card_offset;\n\th->mem[win].kind = kind;\n\n\tpcic_chip_do_mem_map(h, win);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tPCIC_MEM_ALIGN\tPCIC_MEM_PAGESIZE"
    ],
    "globals_used": [
      "void\tpcic_chip_do_mem_map",
      "static struct mem_map_index_st {\n\tint\tsysmem_start_lsb;\n\tint\tsysmem_start_msb;\n\tint\tsysmem_stop_lsb;\n\tint\tsysmem_stop_msb;\n\tint\tcardmem_lsb;\n\tint\tcardmem_msb;\n\tint\tmemenable;\n} mem_map_index[] = {\n\t{\n\t\tPCIC_SYSMEM_ADDR0_START_LSB,\n\t\tPCIC_SYSMEM_ADDR0_START_MSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR0_LSB,\n\t\tPCIC_CARDMEM_ADDR0_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM0,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR1_START_LSB,\n\t\tPCIC_SYSMEM_ADDR1_START_MSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR1_LSB,\n\t\tPCIC_CARDMEM_ADDR1_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM1,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR2_START_LSB,\n\t\tPCIC_SYSMEM_ADDR2_START_MSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR2_LSB,\n\t\tPCIC_CARDMEM_ADDR2_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM2,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR3_START_LSB,\n\t\tPCIC_SYSMEM_ADDR3_START_MSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR3_LSB,\n\t\tPCIC_CARDMEM_ADDR3_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM3,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR4_START_LSB,\n\t\tPCIC_SYSMEM_ADDR4_START_MSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR4_LSB,\n\t\tPCIC_CARDMEM_ADDR4_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM4,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_chip_do_mem_map",
          "args": [
            "h",
            "win"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_chip_do_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "914-968",
          "snippet": "void \npcic_chip_do_mem_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 =\n\t    (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8\n\t    || (kind == PCMCIA_MEM_ATTR);\n\n\tpcic_write(h, mem_map_index[win].sysmem_start_lsb,\n\t    (h->mem[win].addr >> PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_start_msb,\n\t    ((h->mem[win].addr >> (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_START_MSB_ADDR_MASK) |\n\t    (mem8 ? 0 : PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT));\n\n\tpcic_write(h, mem_map_index[win].sysmem_stop_lsb,\n\t    ((h->mem[win].addr + h->mem[win].size) >>\n\t    PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_stop_msb,\n\t    (((h->mem[win].addr + h->mem[win].size) >>\n\t    (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_ADDR_MASK) |\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2);\n\n\tpcic_write(h, mem_map_index[win].cardmem_lsb,\n\t    (h->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].cardmem_msb,\n\t    ((h->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK) |\n\t    ((kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0));\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= (mem_map_index[win].memenable | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n\n#ifdef PCICDEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6;\n\n\t\tr1 = pcic_read(h, mem_map_index[win].sysmem_start_msb);\n\t\tr2 = pcic_read(h, mem_map_index[win].sysmem_start_lsb);\n\t\tr3 = pcic_read(h, mem_map_index[win].sysmem_stop_msb);\n\t\tr4 = pcic_read(h, mem_map_index[win].sysmem_stop_lsb);\n\t\tr5 = pcic_read(h, mem_map_index[win].cardmem_msb);\n\t\tr6 = pcic_read(h, mem_map_index[win].cardmem_lsb);\n\n\t\tDPRINTF((\"pcic_chip_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\\n\", win, r1, r2, r3, r4, r5, r6));\n\t}\n#endif\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_chip_do_mem_map",
            "static struct mem_map_index_st {\n\tint\tsysmem_start_lsb;\n\tint\tsysmem_start_msb;\n\tint\tsysmem_stop_lsb;\n\tint\tsysmem_stop_msb;\n\tint\tcardmem_lsb;\n\tint\tcardmem_msb;\n\tint\tmemenable;\n} mem_map_index[] = {\n\t{\n\t\tPCIC_SYSMEM_ADDR0_START_LSB,\n\t\tPCIC_SYSMEM_ADDR0_START_MSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR0_LSB,\n\t\tPCIC_CARDMEM_ADDR0_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM0,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR1_START_LSB,\n\t\tPCIC_SYSMEM_ADDR1_START_MSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR1_LSB,\n\t\tPCIC_CARDMEM_ADDR1_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM1,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR2_START_LSB,\n\t\tPCIC_SYSMEM_ADDR2_START_MSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR2_LSB,\n\t\tPCIC_CARDMEM_ADDR2_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM2,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR3_START_LSB,\n\t\tPCIC_SYSMEM_ADDR3_START_MSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR3_LSB,\n\t\tPCIC_CARDMEM_ADDR3_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM3,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR4_START_LSB,\n\t\tPCIC_SYSMEM_ADDR4_START_MSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR4_LSB,\n\t\tPCIC_CARDMEM_ADDR4_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM4,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_chip_do_mem_map;\nstatic struct mem_map_index_st {\n\tint\tsysmem_start_lsb;\n\tint\tsysmem_start_msb;\n\tint\tsysmem_stop_lsb;\n\tint\tsysmem_stop_msb;\n\tint\tcardmem_lsb;\n\tint\tcardmem_msb;\n\tint\tmemenable;\n} mem_map_index[] = {\n\t{\n\t\tPCIC_SYSMEM_ADDR0_START_LSB,\n\t\tPCIC_SYSMEM_ADDR0_START_MSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR0_LSB,\n\t\tPCIC_CARDMEM_ADDR0_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM0,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR1_START_LSB,\n\t\tPCIC_SYSMEM_ADDR1_START_MSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR1_LSB,\n\t\tPCIC_CARDMEM_ADDR1_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM1,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR2_START_LSB,\n\t\tPCIC_SYSMEM_ADDR2_START_MSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR2_LSB,\n\t\tPCIC_CARDMEM_ADDR2_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM2,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR3_START_LSB,\n\t\tPCIC_SYSMEM_ADDR3_START_MSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR3_LSB,\n\t\tPCIC_CARDMEM_ADDR3_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM3,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR4_START_LSB,\n\t\tPCIC_SYSMEM_ADDR4_START_MSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR4_LSB,\n\t\tPCIC_CARDMEM_ADDR4_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM4,\n\t},\n};\n\nvoid \npcic_chip_do_mem_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 =\n\t    (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8\n\t    || (kind == PCMCIA_MEM_ATTR);\n\n\tpcic_write(h, mem_map_index[win].sysmem_start_lsb,\n\t    (h->mem[win].addr >> PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_start_msb,\n\t    ((h->mem[win].addr >> (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_START_MSB_ADDR_MASK) |\n\t    (mem8 ? 0 : PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT));\n\n\tpcic_write(h, mem_map_index[win].sysmem_stop_lsb,\n\t    ((h->mem[win].addr + h->mem[win].size) >>\n\t    PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_stop_msb,\n\t    (((h->mem[win].addr + h->mem[win].size) >>\n\t    (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_ADDR_MASK) |\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2);\n\n\tpcic_write(h, mem_map_index[win].cardmem_lsb,\n\t    (h->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].cardmem_msb,\n\t    ((h->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK) |\n\t    ((kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0));\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= (mem_map_index[win].memenable | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n\n#ifdef PCICDEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6;\n\n\t\tr1 = pcic_read(h, mem_map_index[win].sysmem_start_msb);\n\t\tr2 = pcic_read(h, mem_map_index[win].sysmem_start_lsb);\n\t\tr3 = pcic_read(h, mem_map_index[win].sysmem_stop_msb);\n\t\tr4 = pcic_read(h, mem_map_index[win].sysmem_stop_lsb);\n\t\tr5 = pcic_read(h, mem_map_index[win].cardmem_msb);\n\t\tr6 = pcic_read(h, mem_map_index[win].cardmem_lsb);\n\n\t\tDPRINTF((\"pcic_chip_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\\n\", win, r1, r2, r3, r4, r5, r6));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_chip_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcic_chip_mem_map memt is bogus\""
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCIC_MEM_ALIGN\tPCIC_MEM_PAGESIZE\n\nvoid\tpcic_chip_do_mem_map;\nstatic struct mem_map_index_st {\n\tint\tsysmem_start_lsb;\n\tint\tsysmem_start_msb;\n\tint\tsysmem_stop_lsb;\n\tint\tsysmem_stop_msb;\n\tint\tcardmem_lsb;\n\tint\tcardmem_msb;\n\tint\tmemenable;\n} mem_map_index[] = {\n\t{\n\t\tPCIC_SYSMEM_ADDR0_START_LSB,\n\t\tPCIC_SYSMEM_ADDR0_START_MSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR0_LSB,\n\t\tPCIC_CARDMEM_ADDR0_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM0,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR1_START_LSB,\n\t\tPCIC_SYSMEM_ADDR1_START_MSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR1_LSB,\n\t\tPCIC_CARDMEM_ADDR1_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM1,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR2_START_LSB,\n\t\tPCIC_SYSMEM_ADDR2_START_MSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR2_LSB,\n\t\tPCIC_CARDMEM_ADDR2_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM2,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR3_START_LSB,\n\t\tPCIC_SYSMEM_ADDR3_START_MSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR3_LSB,\n\t\tPCIC_CARDMEM_ADDR3_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM3,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR4_START_LSB,\n\t\tPCIC_SYSMEM_ADDR4_START_MSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR4_LSB,\n\t\tPCIC_CARDMEM_ADDR4_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM4,\n\t},\n};\n\nint \npcic_chip_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint i, win;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\twin = -1;\n\tfor (i = 0; i < (sizeof(mem_map_index) / sizeof(mem_map_index[0]));\n\t    i++) {\n\t\tif ((h->memalloc & (1 << i)) == 0) {\n\t\t\twin = i;\n\t\t\th->memalloc |= (1 << i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == -1)\n\t\treturn (1);\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (sc->memt != pcmhp->memt)\n\t\tpanic(\"pcic_chip_mem_map memt is bogus\");\n\n\tbusaddr = pcmhp->addr;\n\n\t/*\n\t * Compute the address offset to the pcmcia address space for the\n\t * pcic.  This is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_ALIGN;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pcic_chip_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/*\n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long) card_addr) - ((long) busaddr));\n\n\th->mem[win].addr = busaddr;\n\th->mem[win].size = size;\n\th->mem[win].offset = card_offset;\n\th->mem[win].kind = kind;\n\n\tpcic_chip_do_mem_map(h, win);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "pcic_chip_do_mem_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "914-968",
    "snippet": "void \npcic_chip_do_mem_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 =\n\t    (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8\n\t    || (kind == PCMCIA_MEM_ATTR);\n\n\tpcic_write(h, mem_map_index[win].sysmem_start_lsb,\n\t    (h->mem[win].addr >> PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_start_msb,\n\t    ((h->mem[win].addr >> (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_START_MSB_ADDR_MASK) |\n\t    (mem8 ? 0 : PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT));\n\n\tpcic_write(h, mem_map_index[win].sysmem_stop_lsb,\n\t    ((h->mem[win].addr + h->mem[win].size) >>\n\t    PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_stop_msb,\n\t    (((h->mem[win].addr + h->mem[win].size) >>\n\t    (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_ADDR_MASK) |\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2);\n\n\tpcic_write(h, mem_map_index[win].cardmem_lsb,\n\t    (h->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].cardmem_msb,\n\t    ((h->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK) |\n\t    ((kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0));\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= (mem_map_index[win].memenable | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n\n#ifdef PCICDEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6;\n\n\t\tr1 = pcic_read(h, mem_map_index[win].sysmem_start_msb);\n\t\tr2 = pcic_read(h, mem_map_index[win].sysmem_start_lsb);\n\t\tr3 = pcic_read(h, mem_map_index[win].sysmem_stop_msb);\n\t\tr4 = pcic_read(h, mem_map_index[win].sysmem_stop_lsb);\n\t\tr5 = pcic_read(h, mem_map_index[win].cardmem_msb);\n\t\tr6 = pcic_read(h, mem_map_index[win].cardmem_lsb);\n\n\t\tDPRINTF((\"pcic_chip_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\\n\", win, r1, r2, r3, r4, r5, r6));\n\t}\n#endif\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_chip_do_mem_map",
      "static struct mem_map_index_st {\n\tint\tsysmem_start_lsb;\n\tint\tsysmem_start_msb;\n\tint\tsysmem_stop_lsb;\n\tint\tsysmem_stop_msb;\n\tint\tcardmem_lsb;\n\tint\tcardmem_msb;\n\tint\tmemenable;\n} mem_map_index[] = {\n\t{\n\t\tPCIC_SYSMEM_ADDR0_START_LSB,\n\t\tPCIC_SYSMEM_ADDR0_START_MSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR0_LSB,\n\t\tPCIC_CARDMEM_ADDR0_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM0,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR1_START_LSB,\n\t\tPCIC_SYSMEM_ADDR1_START_MSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR1_LSB,\n\t\tPCIC_CARDMEM_ADDR1_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM1,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR2_START_LSB,\n\t\tPCIC_SYSMEM_ADDR2_START_MSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR2_LSB,\n\t\tPCIC_CARDMEM_ADDR2_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM2,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR3_START_LSB,\n\t\tPCIC_SYSMEM_ADDR3_START_MSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR3_LSB,\n\t\tPCIC_CARDMEM_ADDR3_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM3,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR4_START_LSB,\n\t\tPCIC_SYSMEM_ADDR4_START_MSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR4_LSB,\n\t\tPCIC_CARDMEM_ADDR4_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM4,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_chip_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\\n\", win, r1, r2, r3, r4, r5, r6)"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcic_read",
          "args": [
            "h",
            "mem_map_index[win].cardmem_lsb"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1442-1451",
          "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t st_pcic_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_write",
          "args": [
            "h",
            "PCIC_ADDRWIN_ENABLE",
            "reg"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1453-1465",
          "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tst_pcic_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_chip_do_mem_map;\nstatic struct mem_map_index_st {\n\tint\tsysmem_start_lsb;\n\tint\tsysmem_start_msb;\n\tint\tsysmem_stop_lsb;\n\tint\tsysmem_stop_msb;\n\tint\tcardmem_lsb;\n\tint\tcardmem_msb;\n\tint\tmemenable;\n} mem_map_index[] = {\n\t{\n\t\tPCIC_SYSMEM_ADDR0_START_LSB,\n\t\tPCIC_SYSMEM_ADDR0_START_MSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR0_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR0_LSB,\n\t\tPCIC_CARDMEM_ADDR0_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM0,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR1_START_LSB,\n\t\tPCIC_SYSMEM_ADDR1_START_MSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR1_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR1_LSB,\n\t\tPCIC_CARDMEM_ADDR1_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM1,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR2_START_LSB,\n\t\tPCIC_SYSMEM_ADDR2_START_MSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR2_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR2_LSB,\n\t\tPCIC_CARDMEM_ADDR2_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM2,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR3_START_LSB,\n\t\tPCIC_SYSMEM_ADDR3_START_MSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR3_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR3_LSB,\n\t\tPCIC_CARDMEM_ADDR3_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM3,\n\t},\n\t{\n\t\tPCIC_SYSMEM_ADDR4_START_LSB,\n\t\tPCIC_SYSMEM_ADDR4_START_MSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_LSB,\n\t\tPCIC_SYSMEM_ADDR4_STOP_MSB,\n\t\tPCIC_CARDMEM_ADDR4_LSB,\n\t\tPCIC_CARDMEM_ADDR4_MSB,\n\t\tPCIC_ADDRWIN_ENABLE_MEM4,\n\t},\n};\n\nvoid \npcic_chip_do_mem_map(h, win)\n\tstruct pcic_handle *h;\n\tint win;\n{\n\tint reg;\n\tint kind = h->mem[win].kind & ~PCMCIA_WIDTH_MEM_MASK;\n\tint mem8 =\n\t    (h->mem[win].kind & PCMCIA_WIDTH_MEM_MASK) == PCMCIA_WIDTH_MEM8\n\t    || (kind == PCMCIA_MEM_ATTR);\n\n\tpcic_write(h, mem_map_index[win].sysmem_start_lsb,\n\t    (h->mem[win].addr >> PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_start_msb,\n\t    ((h->mem[win].addr >> (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_START_MSB_ADDR_MASK) |\n\t    (mem8 ? 0 : PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT));\n\n\tpcic_write(h, mem_map_index[win].sysmem_stop_lsb,\n\t    ((h->mem[win].addr + h->mem[win].size) >>\n\t    PCIC_SYSMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].sysmem_stop_msb,\n\t    (((h->mem[win].addr + h->mem[win].size) >>\n\t    (PCIC_SYSMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_ADDR_MASK) |\n\t    PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2);\n\n\tpcic_write(h, mem_map_index[win].cardmem_lsb,\n\t    (h->mem[win].offset >> PCIC_CARDMEM_ADDRX_SHIFT) & 0xff);\n\tpcic_write(h, mem_map_index[win].cardmem_msb,\n\t    ((h->mem[win].offset >> (PCIC_CARDMEM_ADDRX_SHIFT + 8)) &\n\t    PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK) |\n\t    ((kind == PCMCIA_MEM_ATTR) ?\n\t    PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR : 0));\n\n\treg = pcic_read(h, PCIC_ADDRWIN_ENABLE);\n\treg |= (mem_map_index[win].memenable | PCIC_ADDRWIN_ENABLE_MEMCS16);\n\tpcic_write(h, PCIC_ADDRWIN_ENABLE, reg);\n\n#ifdef PCICDEBUG\n\t{\n\t\tint r1, r2, r3, r4, r5, r6;\n\n\t\tr1 = pcic_read(h, mem_map_index[win].sysmem_start_msb);\n\t\tr2 = pcic_read(h, mem_map_index[win].sysmem_start_lsb);\n\t\tr3 = pcic_read(h, mem_map_index[win].sysmem_stop_msb);\n\t\tr4 = pcic_read(h, mem_map_index[win].sysmem_stop_lsb);\n\t\tr5 = pcic_read(h, mem_map_index[win].cardmem_msb);\n\t\tr6 = pcic_read(h, mem_map_index[win].cardmem_lsb);\n\n\t\tDPRINTF((\"pcic_chip_do_mem_map window %d: %02x%02x %02x%02x \"\n\t\t    \"%02x%02x\\n\", win, r1, r2, r3, r4, r5, r6));\n\t}\n#endif\n}"
  },
  {
    "function_name": "pcic_chip_mem_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "847-856",
    "snippet": "void \npcic_chip_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\tsc->subregionmask |= pcmhp->mhandle;\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \npcic_chip_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\tsc->subregionmask |= pcmhp->mhandle;\n}"
  },
  {
    "function_name": "pcic_chip_mem_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "795-845",
    "snippet": "int \npcic_chip_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tint i, mask, mhandle;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\tsizepg = (size + (PCIC_MEM_ALIGN - 1)) / PCIC_MEM_ALIGN;\n\n\tmask = (1 << sizepg) - 1;\n\n\taddr = 0;\t\t/* XXX gcc -Wuninitialized */\n\tmhandle = 0;\t\t/* XXX gcc -Wuninitialized */\n\n\tfor (i = 0; i < (PCIC_MEM_PAGES + 1 - sizepg); i++) {\n\t\tif ((sc->subregionmask & (mask << i)) == (mask << i)) {\n\t\t\tif (bus_space_subregion(sc->memt, sc->memh,\n\t\t\t    i * PCIC_MEM_PAGESIZE,\n\t\t\t    sizepg * PCIC_MEM_PAGESIZE, &memh))\n\t\t\t\treturn (1);\n\t\t\tmhandle = mask << i;\n\t\t\taddr = sc->membase + (i * PCIC_MEM_PAGESIZE);\n\t\t\tsc->subregionmask &= ~(mhandle);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == (PCIC_MEM_PAGES + 1 - size))\n\t\treturn (1);\n\n\tDPRINTF((\"pcic_chip_mem_alloc bus addr 0x%lx+0x%lx\\n\", (u_long) addr,\n\t\t (u_long) size));\n\n\tpcmhp->memt = sc->memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->mhandle = mhandle;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tPCIC_MEM_ALIGN\tPCIC_MEM_PAGESIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_chip_mem_alloc bus addr 0x%lx+0x%lx\\n\", (u_long) addr,\n\t\t (u_long) size)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_subregion",
          "args": [
            "sc->memt",
            "sc->memh",
            "i * PCIC_MEM_PAGESIZE",
            "sizepg * PCIC_MEM_PAGESIZE",
            "&memh"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCIC_MEM_ALIGN\tPCIC_MEM_PAGESIZE\n\nint \npcic_chip_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *h = (struct pcic_handle *) pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tint i, mask, mhandle;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\tsizepg = (size + (PCIC_MEM_ALIGN - 1)) / PCIC_MEM_ALIGN;\n\n\tmask = (1 << sizepg) - 1;\n\n\taddr = 0;\t\t/* XXX gcc -Wuninitialized */\n\tmhandle = 0;\t\t/* XXX gcc -Wuninitialized */\n\n\tfor (i = 0; i < (PCIC_MEM_PAGES + 1 - sizepg); i++) {\n\t\tif ((sc->subregionmask & (mask << i)) == (mask << i)) {\n\t\t\tif (bus_space_subregion(sc->memt, sc->memh,\n\t\t\t    i * PCIC_MEM_PAGESIZE,\n\t\t\t    sizepg * PCIC_MEM_PAGESIZE, &memh))\n\t\t\t\treturn (1);\n\t\t\tmhandle = mask << i;\n\t\t\taddr = sc->membase + (i * PCIC_MEM_PAGESIZE);\n\t\t\tsc->subregionmask &= ~(mhandle);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == (PCIC_MEM_PAGES + 1 - size))\n\t\treturn (1);\n\n\tDPRINTF((\"pcic_chip_mem_alloc bus addr 0x%lx+0x%lx\\n\", (u_long) addr,\n\t\t (u_long) size));\n\n\tpcmhp->memt = sc->memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->mhandle = mhandle;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "pcic_deactivate_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "780-793",
    "snippet": "void\npcic_deactivate_card(h)\n\tstruct pcic_handle *h;\n{\n\n\t/* call the MI deactivate function */\n\tpcmcia_card_deactivate(h->pcmcia);\n\n\t/* power down the socket */\n\tpcic_write(h, PCIC_PWRCTL, 0);\n\n\t/* reset the socket */\n\tpcic_write(h, PCIC_INTR, 0);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_deactivate_card"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_write",
          "args": [
            "h",
            "PCIC_INTR",
            "0"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1453-1465",
          "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tst_pcic_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_card_deactivate",
          "args": [
            "h->pcmcia"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "282-304",
          "snippet": "void\npcmcia_card_deactivate(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * We're in the chip's card removal interrupt handler.\n\t * Deactivate the child driver.  The PCMCIA socket's\n\t * event thread will run later to finish the detach.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tconfig_deactivate(pf->child);\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_card_deactivate(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\n\t/*\n\t * We're in the chip's card removal interrupt handler.\n\t * Deactivate the child driver.  The PCMCIA socket's\n\t * event thread will run later to finish the detach.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: deactivating %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tconfig_deactivate(pf->child);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_deactivate_card;\n\nvoid\npcic_deactivate_card(h)\n\tstruct pcic_handle *h;\n{\n\n\t/* call the MI deactivate function */\n\tpcmcia_card_deactivate(h->pcmcia);\n\n\t/* power down the socket */\n\tpcic_write(h, PCIC_PWRCTL, 0);\n\n\t/* reset the socket */\n\tpcic_write(h, PCIC_INTR, 0);\n}"
  },
  {
    "function_name": "pcic_detach_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "764-778",
    "snippet": "void\npcic_detach_card(h, flags)\n\tstruct pcic_handle *h;\n\tint flags;\t\t/* DETACH_* */\n{\n\n\tif (h->flags & PCIC_FLAG_CARDP) {\n\t\th->flags &= ~PCIC_FLAG_CARDP;\n\n\t\t/* call the MI detach function */\n\t\tpcmcia_card_detach(h->pcmcia, flags);\n\t} else {\n\t\tDPRINTF((\"pcic_detach_card: already detached\"));\n\t}\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_detach_card"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic_detach_card: already detached\")"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_card_detach",
          "args": [
            "h->pcmcia",
            "flags"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "252-280",
          "snippet": "void\npcmcia_card_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\t\t/* DETACH_* flags */\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tint error;\n\n\t/*\n\t * We are running on either the PCMCIA socket's event thread\n\t * or in user context detaching a device by user request.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tif ((error = config_detach(pf->child, flags)) != 0) {\n\t\t\tprintf(\"%s: error %d detaching %s (function %d)\\n\",\n\t\t\t    sc->dev.dv_xname, error, pf->child->dv_xname,\n\t\t\t    pf->number);\n\t\t} else\n\t\t\tpf->child = NULL;\n\t}\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_card_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\t\t/* DETACH_* flags */\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tint error;\n\n\t/*\n\t * We are running on either the PCMCIA socket's event thread\n\t * or in user context detaching a device by user request.\n\t */\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t     pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tif (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)\n\t\t\tcontinue;\n\t\tif (pf->child == NULL)\n\t\t\tcontinue;\n\t\tDPRINTF((\"%s: detaching %s (function %d)\\n\",\n\t\t    sc->dev.dv_xname, pf->child->dv_xname, pf->number));\n\t\tif ((error = config_detach(pf->child, flags)) != 0) {\n\t\t\tprintf(\"%s: error %d detaching %s (function %d)\\n\",\n\t\t\t    sc->dev.dv_xname, error, pf->child->dv_xname,\n\t\t\t    pf->number);\n\t\t} else\n\t\t\tpf->child = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_detach_card;\n\nvoid\npcic_detach_card(h, flags)\n\tstruct pcic_handle *h;\n\tint flags;\t\t/* DETACH_* */\n{\n\n\tif (h->flags & PCIC_FLAG_CARDP) {\n\t\th->flags &= ~PCIC_FLAG_CARDP;\n\n\t\t/* call the MI detach function */\n\t\tpcmcia_card_detach(h->pcmcia, flags);\n\t} else {\n\t\tDPRINTF((\"pcic_detach_card: already detached\"));\n\t}\n}"
  },
  {
    "function_name": "pcic_attach_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "750-762",
    "snippet": "void\npcic_attach_card(h)\n\tstruct pcic_handle *h;\n{\n\tif (h->flags & PCIC_FLAG_CARDP)\n\t\tpanic(\"pcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= PCIC_FLAG_CARDP;\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_attach_card"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_card_attach",
          "args": [
            "h->pcmcia"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_card_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "159-250",
          "snippet": "int\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpcmcia_submatch",
            "int\tpcmcia_print",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_submatch;\nint\tpcmcia_print;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\nvoid *ih_arg;\n\nint\npcmcia_card_attach(dev)\n\tstruct device *dev;\n{\n\tstruct pcmcia_softc *sc = (struct pcmcia_softc *) dev;\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_attach_args paa;\n\tint attached;\n\n\t/*\n\t * this is here so that when socket_enable calls gettype, trt happens\n\t */\n\tsc->card.pf_head.sqh_first = NULL;\n\n\tpcmcia_chip_socket_enable(sc->pct, sc->pch);\n\n\tpcmcia_read_cis(sc);\n\n\tpcmcia_chip_socket_disable(sc->pct, sc->pch);\n\n\tpcmcia_check_cis_quirks(sc);\n\n#if 1\n\t/*\n\t * Bail now if the card has no functions, or if there was an error in\n\t * the CIS.\n\t */\n\n\tif (sc->card.error)\n\t\treturn (1);\n\tif (sc->card.pf_head.sqh_first == NULL)\n\t\treturn (1);\n#endif\n\n\tif (pcmcia_verbose)\n\t\tpcmcia_print_cis(sc);\n\n\t/*\n\t * If there was no function, this might be CIS-less card we still\n\t * want to probe.  Fixup a function element for it.\n\t */\n\tif (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {\n\t\tpf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);\n\t\tbzero(pf, sizeof *pf);\n\t\tpf->number = 0;\n\t\tpf->pf_flags = PFF_FAKE;\n\t\tpf->last_config_index = -1;\n\t\tSIMPLEQ_INIT(&pf->cfe_head);\n\t\tSIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);\n\t}\n\n\tattached = 0;\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpf->sc = sc;\n\t\tpf->child = NULL;\n\t\tpf->cfe = NULL;\n\t\tpf->ih_fct = NULL;\n\t\tpf->ih_arg = NULL;\n\t}\n\n\tfor (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;\n\t    pf = SIMPLEQ_NEXT(pf, pf_list)) {\n\t\tpaa.manufacturer = sc->card.manufacturer;\n\t\tpaa.product = sc->card.product;\n\t\tpaa.card = &sc->card;\n\t\tpaa.pf = pf;\n\n\t\tpf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,\n\t\t    pcmcia_submatch);\n\t\tif (pf->child) {\n\t\t\tattached++;\n\n\t\t\tif ((pf->pf_flags & PFF_FAKE) == 0)\n\t\t\t\tDPRINTF((\"%s: function %d CCR at %d offset %lx\"\n\t\t\t\t\t\": %x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t\t\t\tsc->dev.dv_xname, pf->number,\n\t\t\t\t\tpf->pf_ccr_window, pf->pf_ccr_offset,\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x00),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x02),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x04),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x06),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0A),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0C),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x0E),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x10),\n\t\t\t\t\tpcmcia_ccr_read(pf, 0x12)));\n\t\t}\n\t}\n\treturn (attached ? 0 : 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcic_attach_card: already attached\""
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_attach_card;\n\nvoid\npcic_attach_card(h)\n\tstruct pcic_handle *h;\n{\n\tif (h->flags & PCIC_FLAG_CARDP)\n\t\tpanic(\"pcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= PCIC_FLAG_CARDP;\n}"
  },
  {
    "function_name": "pcic_queue_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "731-748",
    "snippet": "void\npcic_queue_event(h, event)\n\tstruct pcic_handle *h;\n\tint event;\n{\n\tstruct pcic_event *pe;\n\tint s;\n\n\tpe = malloc(sizeof(*pe), M_TEMP, M_NOWAIT);\n\tif (pe == NULL)\n\t\tpanic(\"pcic_queue_event: can't allocate event\");\n\n\tpe->pe_type = event;\n\ts = splhigh();\n\tSIMPLEQ_INSERT_TAIL(&h->events, pe, pe_q);\n\tsplx(s);\n\twakeup(&h->events);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_queue_event"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&h->events"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_TAIL",
          "args": [
            "&h->events",
            "pe",
            "pe_q"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcic_queue_event: can't allocate event\""
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*pe)",
            "M_TEMP",
            "M_NOWAIT"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_queue_event;\n\nvoid\npcic_queue_event(h, event)\n\tstruct pcic_handle *h;\n\tint event;\n{\n\tstruct pcic_event *pe;\n\tint s;\n\n\tpe = malloc(sizeof(*pe), M_TEMP, M_NOWAIT);\n\tif (pe == NULL)\n\t\tpanic(\"pcic_queue_event: can't allocate event\");\n\n\tpe->pe_type = event;\n\ts = splhigh();\n\tSIMPLEQ_INSERT_TAIL(&h->events, pe, pe_q);\n\tsplx(s);\n\twakeup(&h->events);\n}"
  },
  {
    "function_name": "pcic_intr_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "667-729",
    "snippet": "int\npcic_intr_socket(h)\n\tstruct pcic_handle *h;\n{\n\tint cscreg;\n\n\tcscreg = pcic_read(h, PCIC_CSC);\n\n\tcscreg &= (PCIC_CSC_GPI |\n\t\t   PCIC_CSC_CD |\n\t\t   PCIC_CSC_READY |\n\t\t   PCIC_CSC_BATTWARN |\n\t\t   PCIC_CSC_BATTDEAD);\n\n\tif (cscreg & PCIC_CSC_GPI) {\n\t\tDPRINTF((\"%s: %02x GPI\\n\", h->ph_parent->dv_xname, h->sock));\n\t}\n\tif (cscreg & PCIC_CSC_CD) {\n\t\tint statreg;\n\n\t\tstatreg = pcic_read(h, PCIC_IF_STATUS);\n\n\t\tDPRINTF((\"%s: %02x CD %x\\n\", h->ph_parent->dv_xname, h->sock,\n\t\t    statreg));\n\n\t\tif ((statreg & PCIC_IF_STATUS_CARDDETECT_MASK) ==\n\t\t    PCIC_IF_STATUS_CARDDETECT_PRESENT) {\n\t\t\tif (h->laststate != PCIC_LASTSTATE_PRESENT) {\n\t\t\t\tDPRINTF((\"%s: enqueing INSERTION event\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_queue_event(h, PCIC_EVENT_INSERTION);\n\t\t\t}\n\t\t\th->laststate = PCIC_LASTSTATE_PRESENT;\n\t\t} else {\n\t\t\tif (h->laststate == PCIC_LASTSTATE_PRESENT) {\n\t\t\t\t/* Deactivate the card now. */\n\t\t\t\tDPRINTF((\"%s: deactivating card\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_deactivate_card(h);\n\n\t\t\t\tDPRINTF((\"%s: enqueing REMOVAL event\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_queue_event(h, PCIC_EVENT_REMOVAL);\n\t\t\t}\n\t\t\th->laststate =\n\t\t\t    ((statreg & PCIC_IF_STATUS_CARDDETECT_MASK) == 0)\n\t\t\t    ? PCIC_LASTSTATE_EMPTY : PCIC_LASTSTATE_HALF;\n\t\t}\n\t}\n\tif (cscreg & PCIC_CSC_READY) {\n\t\tDPRINTF((\"%s: %02x READY\\n\", h->ph_parent->dv_xname, h->sock));\n\t\t/* shouldn't happen */\n\t}\n\tif (cscreg & PCIC_CSC_BATTWARN) {\n\t\tDPRINTF((\"%s: %02x BATTWARN\\n\", h->ph_parent->dv_xname,\n\t\t    h->sock));\n\t}\n\tif (cscreg & PCIC_CSC_BATTDEAD) {\n\t\tDPRINTF((\"%s: %02x BATTDEAD\\n\", h->ph_parent->dv_xname,\n\t\t    h->sock));\n\t}\n\treturn (cscreg ? 1 : 0);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcic_intr_socket",
      "void\tpcic_deactivate_card",
      "void\tpcic_queue_event"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x BATTDEAD\\n\", h->ph_parent->dv_xname,\n\t\t    h->sock)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x BATTWARN\\n\", h->ph_parent->dv_xname,\n\t\t    h->sock)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x READY\\n\", h->ph_parent->dv_xname, h->sock)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcic_queue_event",
          "args": [
            "h",
            "PCIC_EVENT_REMOVAL"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_queue_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "731-748",
          "snippet": "void\npcic_queue_event(h, event)\n\tstruct pcic_handle *h;\n\tint event;\n{\n\tstruct pcic_event *pe;\n\tint s;\n\n\tpe = malloc(sizeof(*pe), M_TEMP, M_NOWAIT);\n\tif (pe == NULL)\n\t\tpanic(\"pcic_queue_event: can't allocate event\");\n\n\tpe->pe_type = event;\n\ts = splhigh();\n\tSIMPLEQ_INSERT_TAIL(&h->events, pe, pe_q);\n\tsplx(s);\n\twakeup(&h->events);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_queue_event"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_queue_event;\n\nvoid\npcic_queue_event(h, event)\n\tstruct pcic_handle *h;\n\tint event;\n{\n\tstruct pcic_event *pe;\n\tint s;\n\n\tpe = malloc(sizeof(*pe), M_TEMP, M_NOWAIT);\n\tif (pe == NULL)\n\t\tpanic(\"pcic_queue_event: can't allocate event\");\n\n\tpe->pe_type = event;\n\ts = splhigh();\n\tSIMPLEQ_INSERT_TAIL(&h->events, pe, pe_q);\n\tsplx(s);\n\twakeup(&h->events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: enqueing REMOVAL event\\n\",\n\t\t\t\t    h->ph_parent->dv_xname)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcic_deactivate_card",
          "args": [
            "h"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_deactivate_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "780-793",
          "snippet": "void\npcic_deactivate_card(h)\n\tstruct pcic_handle *h;\n{\n\n\t/* call the MI deactivate function */\n\tpcmcia_card_deactivate(h->pcmcia);\n\n\t/* power down the socket */\n\tpcic_write(h, PCIC_PWRCTL, 0);\n\n\t/* reset the socket */\n\tpcic_write(h, PCIC_INTR, 0);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_deactivate_card"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_deactivate_card;\n\nvoid\npcic_deactivate_card(h)\n\tstruct pcic_handle *h;\n{\n\n\t/* call the MI deactivate function */\n\tpcmcia_card_deactivate(h->pcmcia);\n\n\t/* power down the socket */\n\tpcic_write(h, PCIC_PWRCTL, 0);\n\n\t/* reset the socket */\n\tpcic_write(h, PCIC_INTR, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: deactivating card\\n\",\n\t\t\t\t    h->ph_parent->dv_xname)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: enqueing INSERTION event\\n\",\n\t\t\t\t    h->ph_parent->dv_xname)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x CD %x\\n\", h->ph_parent->dv_xname, h->sock,\n\t\t    statreg)"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcic_read",
          "args": [
            "h",
            "PCIC_IF_STATUS"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1442-1451",
          "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t st_pcic_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: %02x GPI\\n\", h->ph_parent->dv_xname, h->sock)"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcic_intr_socket;\nvoid\tpcic_deactivate_card;\nvoid\tpcic_queue_event;\n\nint\npcic_intr_socket(h)\n\tstruct pcic_handle *h;\n{\n\tint cscreg;\n\n\tcscreg = pcic_read(h, PCIC_CSC);\n\n\tcscreg &= (PCIC_CSC_GPI |\n\t\t   PCIC_CSC_CD |\n\t\t   PCIC_CSC_READY |\n\t\t   PCIC_CSC_BATTWARN |\n\t\t   PCIC_CSC_BATTDEAD);\n\n\tif (cscreg & PCIC_CSC_GPI) {\n\t\tDPRINTF((\"%s: %02x GPI\\n\", h->ph_parent->dv_xname, h->sock));\n\t}\n\tif (cscreg & PCIC_CSC_CD) {\n\t\tint statreg;\n\n\t\tstatreg = pcic_read(h, PCIC_IF_STATUS);\n\n\t\tDPRINTF((\"%s: %02x CD %x\\n\", h->ph_parent->dv_xname, h->sock,\n\t\t    statreg));\n\n\t\tif ((statreg & PCIC_IF_STATUS_CARDDETECT_MASK) ==\n\t\t    PCIC_IF_STATUS_CARDDETECT_PRESENT) {\n\t\t\tif (h->laststate != PCIC_LASTSTATE_PRESENT) {\n\t\t\t\tDPRINTF((\"%s: enqueing INSERTION event\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_queue_event(h, PCIC_EVENT_INSERTION);\n\t\t\t}\n\t\t\th->laststate = PCIC_LASTSTATE_PRESENT;\n\t\t} else {\n\t\t\tif (h->laststate == PCIC_LASTSTATE_PRESENT) {\n\t\t\t\t/* Deactivate the card now. */\n\t\t\t\tDPRINTF((\"%s: deactivating card\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_deactivate_card(h);\n\n\t\t\t\tDPRINTF((\"%s: enqueing REMOVAL event\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_queue_event(h, PCIC_EVENT_REMOVAL);\n\t\t\t}\n\t\t\th->laststate =\n\t\t\t    ((statreg & PCIC_IF_STATUS_CARDDETECT_MASK) == 0)\n\t\t\t    ? PCIC_LASTSTATE_EMPTY : PCIC_LASTSTATE_HALF;\n\t\t}\n\t}\n\tif (cscreg & PCIC_CSC_READY) {\n\t\tDPRINTF((\"%s: %02x READY\\n\", h->ph_parent->dv_xname, h->sock));\n\t\t/* shouldn't happen */\n\t}\n\tif (cscreg & PCIC_CSC_BATTWARN) {\n\t\tDPRINTF((\"%s: %02x BATTWARN\\n\", h->ph_parent->dv_xname,\n\t\t    h->sock));\n\t}\n\tif (cscreg & PCIC_CSC_BATTDEAD) {\n\t\tDPRINTF((\"%s: %02x BATTDEAD\\n\", h->ph_parent->dv_xname,\n\t\t    h->sock));\n\t}\n\treturn (cscreg ? 1 : 0);\n}"
  },
  {
    "function_name": "pcic_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "651-665",
    "snippet": "int\npcic_intr(arg)\n\tvoid *arg;\n{\n\tstruct pcic_softc *sc = arg;\n\tint i, ret = 0;\n\n\tDPRINTF((\"%s: intr\\n\", sc->dev.dv_xname));\n\n\tfor (i = 0; i < PCIC_NSLOTS; i++)\n\t\tif (sc->handle[i].flags & PCIC_FLAG_SOCKETP)\n\t\t\tret += pcic_intr_socket(&sc->handle[i]);\n\n\treturn (ret ? 1 : 0);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcic_intr_socket"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_intr_socket",
          "args": [
            "&sc->handle[i]"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_intr_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "667-729",
          "snippet": "int\npcic_intr_socket(h)\n\tstruct pcic_handle *h;\n{\n\tint cscreg;\n\n\tcscreg = pcic_read(h, PCIC_CSC);\n\n\tcscreg &= (PCIC_CSC_GPI |\n\t\t   PCIC_CSC_CD |\n\t\t   PCIC_CSC_READY |\n\t\t   PCIC_CSC_BATTWARN |\n\t\t   PCIC_CSC_BATTDEAD);\n\n\tif (cscreg & PCIC_CSC_GPI) {\n\t\tDPRINTF((\"%s: %02x GPI\\n\", h->ph_parent->dv_xname, h->sock));\n\t}\n\tif (cscreg & PCIC_CSC_CD) {\n\t\tint statreg;\n\n\t\tstatreg = pcic_read(h, PCIC_IF_STATUS);\n\n\t\tDPRINTF((\"%s: %02x CD %x\\n\", h->ph_parent->dv_xname, h->sock,\n\t\t    statreg));\n\n\t\tif ((statreg & PCIC_IF_STATUS_CARDDETECT_MASK) ==\n\t\t    PCIC_IF_STATUS_CARDDETECT_PRESENT) {\n\t\t\tif (h->laststate != PCIC_LASTSTATE_PRESENT) {\n\t\t\t\tDPRINTF((\"%s: enqueing INSERTION event\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_queue_event(h, PCIC_EVENT_INSERTION);\n\t\t\t}\n\t\t\th->laststate = PCIC_LASTSTATE_PRESENT;\n\t\t} else {\n\t\t\tif (h->laststate == PCIC_LASTSTATE_PRESENT) {\n\t\t\t\t/* Deactivate the card now. */\n\t\t\t\tDPRINTF((\"%s: deactivating card\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_deactivate_card(h);\n\n\t\t\t\tDPRINTF((\"%s: enqueing REMOVAL event\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_queue_event(h, PCIC_EVENT_REMOVAL);\n\t\t\t}\n\t\t\th->laststate =\n\t\t\t    ((statreg & PCIC_IF_STATUS_CARDDETECT_MASK) == 0)\n\t\t\t    ? PCIC_LASTSTATE_EMPTY : PCIC_LASTSTATE_HALF;\n\t\t}\n\t}\n\tif (cscreg & PCIC_CSC_READY) {\n\t\tDPRINTF((\"%s: %02x READY\\n\", h->ph_parent->dv_xname, h->sock));\n\t\t/* shouldn't happen */\n\t}\n\tif (cscreg & PCIC_CSC_BATTWARN) {\n\t\tDPRINTF((\"%s: %02x BATTWARN\\n\", h->ph_parent->dv_xname,\n\t\t    h->sock));\n\t}\n\tif (cscreg & PCIC_CSC_BATTDEAD) {\n\t\tDPRINTF((\"%s: %02x BATTDEAD\\n\", h->ph_parent->dv_xname,\n\t\t    h->sock));\n\t}\n\treturn (cscreg ? 1 : 0);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpcic_intr_socket",
            "void\tpcic_deactivate_card",
            "void\tpcic_queue_event"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcic_intr_socket;\nvoid\tpcic_deactivate_card;\nvoid\tpcic_queue_event;\n\nint\npcic_intr_socket(h)\n\tstruct pcic_handle *h;\n{\n\tint cscreg;\n\n\tcscreg = pcic_read(h, PCIC_CSC);\n\n\tcscreg &= (PCIC_CSC_GPI |\n\t\t   PCIC_CSC_CD |\n\t\t   PCIC_CSC_READY |\n\t\t   PCIC_CSC_BATTWARN |\n\t\t   PCIC_CSC_BATTDEAD);\n\n\tif (cscreg & PCIC_CSC_GPI) {\n\t\tDPRINTF((\"%s: %02x GPI\\n\", h->ph_parent->dv_xname, h->sock));\n\t}\n\tif (cscreg & PCIC_CSC_CD) {\n\t\tint statreg;\n\n\t\tstatreg = pcic_read(h, PCIC_IF_STATUS);\n\n\t\tDPRINTF((\"%s: %02x CD %x\\n\", h->ph_parent->dv_xname, h->sock,\n\t\t    statreg));\n\n\t\tif ((statreg & PCIC_IF_STATUS_CARDDETECT_MASK) ==\n\t\t    PCIC_IF_STATUS_CARDDETECT_PRESENT) {\n\t\t\tif (h->laststate != PCIC_LASTSTATE_PRESENT) {\n\t\t\t\tDPRINTF((\"%s: enqueing INSERTION event\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_queue_event(h, PCIC_EVENT_INSERTION);\n\t\t\t}\n\t\t\th->laststate = PCIC_LASTSTATE_PRESENT;\n\t\t} else {\n\t\t\tif (h->laststate == PCIC_LASTSTATE_PRESENT) {\n\t\t\t\t/* Deactivate the card now. */\n\t\t\t\tDPRINTF((\"%s: deactivating card\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_deactivate_card(h);\n\n\t\t\t\tDPRINTF((\"%s: enqueing REMOVAL event\\n\",\n\t\t\t\t    h->ph_parent->dv_xname));\n\t\t\t\tpcic_queue_event(h, PCIC_EVENT_REMOVAL);\n\t\t\t}\n\t\t\th->laststate =\n\t\t\t    ((statreg & PCIC_IF_STATUS_CARDDETECT_MASK) == 0)\n\t\t\t    ? PCIC_LASTSTATE_EMPTY : PCIC_LASTSTATE_HALF;\n\t\t}\n\t}\n\tif (cscreg & PCIC_CSC_READY) {\n\t\tDPRINTF((\"%s: %02x READY\\n\", h->ph_parent->dv_xname, h->sock));\n\t\t/* shouldn't happen */\n\t}\n\tif (cscreg & PCIC_CSC_BATTWARN) {\n\t\tDPRINTF((\"%s: %02x BATTWARN\\n\", h->ph_parent->dv_xname,\n\t\t    h->sock));\n\t}\n\tif (cscreg & PCIC_CSC_BATTDEAD) {\n\t\tDPRINTF((\"%s: %02x BATTDEAD\\n\", h->ph_parent->dv_xname,\n\t\t    h->sock));\n\t}\n\treturn (cscreg ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: intr\\n\", sc->dev.dv_xname)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcic_intr_socket;\n\nint\npcic_intr(arg)\n\tvoid *arg;\n{\n\tstruct pcic_softc *sc = arg;\n\tint i, ret = 0;\n\n\tDPRINTF((\"%s: intr\\n\", sc->dev.dv_xname));\n\n\tfor (i = 0; i < PCIC_NSLOTS; i++)\n\t\tif (sc->handle[i].flags & PCIC_FLAG_SOCKETP)\n\t\t\tret += pcic_intr_socket(&sc->handle[i]);\n\n\treturn (ret ? 1 : 0);\n}"
  },
  {
    "function_name": "pcic_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "619-649",
    "snippet": "int\npcic_print(arg, pnp)\n\tvoid *arg;\n\tconst char *pnp;\n{\n\tstruct pcmciabus_attach_args *paa = arg;\n\tstruct pcic_handle *h = (struct pcic_handle *) paa->pch;\n\n\t/* Only \"pcmcia\"s can attach to \"pcic\"s... easy. */\n\tif (pnp)\n\t\tprintf(\"pcmcia at %s\", pnp);\n\n\tswitch (h->sock) {\n\tcase C0SA:\n\t\tprintf(\" controller 0 socket 0\");\n\t\tbreak;\n\tcase C0SB:\n\t\tprintf(\" controller 0 socket 1\");\n\t\tbreak;\n\tcase C1SA:\n\t\tprintf(\" controller 1 socket 0\");\n\t\tbreak;\n\tcase C1SB:\n\t\tprintf(\" controller 1 socket 1\");\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"unknown pcic socket\");\n\t}\n\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcic_print"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"unknown pcic socket\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" controller 1 socket 1\""
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcic_print;\n\nint\npcic_print(arg, pnp)\n\tvoid *arg;\n\tconst char *pnp;\n{\n\tstruct pcmciabus_attach_args *paa = arg;\n\tstruct pcic_handle *h = (struct pcic_handle *) paa->pch;\n\n\t/* Only \"pcmcia\"s can attach to \"pcic\"s... easy. */\n\tif (pnp)\n\t\tprintf(\"pcmcia at %s\", pnp);\n\n\tswitch (h->sock) {\n\tcase C0SA:\n\t\tprintf(\" controller 0 socket 0\");\n\t\tbreak;\n\tcase C0SB:\n\t\tprintf(\" controller 0 socket 1\");\n\t\tbreak;\n\tcase C1SA:\n\t\tprintf(\" controller 1 socket 0\");\n\t\tbreak;\n\tcase C1SB:\n\t\tprintf(\" controller 1 socket 1\");\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"unknown pcic socket\");\n\t}\n\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "pcic_submatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "558-617",
    "snippet": "int\npcic_submatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct pcmciabus_attach_args *paa = aux;\n\tstruct pcic_handle *h = (struct pcic_handle *) paa->pch;\n\n\tswitch (h->sock) {\n\tcase C0SA:\n\t\tif (cf->cf_loc[0 /* PCICCF_CONTROLLER */] !=\n\t\t    -1 /* PCICCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCICCF_CONTROLLER */] != 0)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCICCF_SOCKET */] !=\n\t\t    -1 /* PCICCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCICCF_SOCKET */] != 0)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tcase C0SB:\n\t\tif (cf->cf_loc[0 /* PCICCF_CONTROLLER */] !=\n\t\t    -1 /* PCICCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCICCF_CONTROLLER */] != 0)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCICCF_SOCKET */] !=\n\t\t    -1 /* PCICCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCICCF_SOCKET */] != 1)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tcase C1SA:\n\t\tif (cf->cf_loc[0 /* PCICCF_CONTROLLER */] !=\n\t\t    -1 /* PCICCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCICCF_CONTROLLER */] != 1)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCICCF_SOCKET */] !=\n\t\t    -1 /* PCICCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCICCF_SOCKET */] != 0)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tcase C1SB:\n\t\tif (cf->cf_loc[0 /* PCICCF_CONTROLLER */] !=\n\t\t    -1 /* PCICCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCICCF_CONTROLLER */] != 1)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCICCF_SOCKET */] !=\n\t\t    -1 /* PCICCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCICCF_SOCKET */] != 1)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"unknown pcic socket\");\n\t}\n\n\treturn ((*cf->cf_attach->ca_match)(parent, cf, aux));\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcic_submatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "cf",
            "aux"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"unknown pcic socket\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcic_submatch;\n\nint\npcic_submatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct pcmciabus_attach_args *paa = aux;\n\tstruct pcic_handle *h = (struct pcic_handle *) paa->pch;\n\n\tswitch (h->sock) {\n\tcase C0SA:\n\t\tif (cf->cf_loc[0 /* PCICCF_CONTROLLER */] !=\n\t\t    -1 /* PCICCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCICCF_CONTROLLER */] != 0)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCICCF_SOCKET */] !=\n\t\t    -1 /* PCICCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCICCF_SOCKET */] != 0)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tcase C0SB:\n\t\tif (cf->cf_loc[0 /* PCICCF_CONTROLLER */] !=\n\t\t    -1 /* PCICCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCICCF_CONTROLLER */] != 0)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCICCF_SOCKET */] !=\n\t\t    -1 /* PCICCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCICCF_SOCKET */] != 1)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tcase C1SA:\n\t\tif (cf->cf_loc[0 /* PCICCF_CONTROLLER */] !=\n\t\t    -1 /* PCICCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCICCF_CONTROLLER */] != 1)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCICCF_SOCKET */] !=\n\t\t    -1 /* PCICCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCICCF_SOCKET */] != 0)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tcase C1SB:\n\t\tif (cf->cf_loc[0 /* PCICCF_CONTROLLER */] !=\n\t\t    -1 /* PCICCF_CONTROLLER_DEFAULT */ &&\n\t\t    cf->cf_loc[0 /* PCICCF_CONTROLLER */] != 1)\n\t\t\treturn 0;\n\t\tif (cf->cf_loc[1 /* PCICCF_SOCKET */] !=\n\t\t    -1 /* PCICCF_SOCKET_DEFAULT */ &&\n\t\t    cf->cf_loc[1 /* PCICCF_SOCKET */] != 1)\n\t\t\treturn 0;\n\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"unknown pcic socket\");\n\t}\n\n\treturn ((*cf->cf_attach->ca_match)(parent, cf, aux));\n}"
  },
  {
    "function_name": "pcic_init_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "511-556",
    "snippet": "void\npcic_init_socket(h)\n\tstruct pcic_handle *h;\n{\n\tint reg;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/*\n\t * queue creation of a kernel thread to handle insert/removal events.\n\t */\n#ifdef DIAGNOSTIC\n\tif (h->event_thread != NULL)\n\t\tpanic(\"pcic_attach_socket: event thread\");\n#endif\n\tkthread_create_deferred(pcic_create_event_thread, h);\n\n\t/* set up the card to interrupt on card detect */\n\n\tpcic_write(h, PCIC_CSC_INTR, (sc->irq << PCIC_CSC_INTR_IRQ_SHIFT) |\n\t    PCIC_CSC_INTR_CD_ENABLE);\n\tpcic_write(h, PCIC_INTR, 0);\n\tpcic_read(h, PCIC_CSC);\n\n\t/* unsleep the cirrus controller */\n\n\tif ((h->vendor == PCIC_VENDOR_CIRRUS_PD6710) ||\n\t    (h->vendor == PCIC_VENDOR_CIRRUS_PD672X)) {\n\t\treg = pcic_read(h, PCIC_CIRRUS_MISC_CTL_2);\n\t\tif (reg & PCIC_CIRRUS_MISC_CTL_2_SUSPEND) {\n\t\t\tDPRINTF((\"%s: socket %02x was suspended\\n\",\n\t\t\t    h->ph_parent->dv_xname, h->sock));\n\t\t\treg &= ~PCIC_CIRRUS_MISC_CTL_2_SUSPEND;\n\t\t\tpcic_write(h, PCIC_CIRRUS_MISC_CTL_2, reg);\n\t\t}\n\t}\n\t/* if there's a card there, then attach it. */\n\n\treg = pcic_read(h, PCIC_IF_STATUS);\n\n\tif ((reg & PCIC_IF_STATUS_CARDDETECT_MASK) ==\n\t    PCIC_IF_STATUS_CARDDETECT_PRESENT) {\n\t\tpcic_attach_card(h);\n\t\th->laststate = PCIC_LASTSTATE_PRESENT;\n\t} else\n\t\th->laststate = PCIC_LASTSTATE_EMPTY;\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tPCIC_VENDOR_CIRRUS_PD672X\t5",
      "#define\tPCIC_VENDOR_CIRRUS_PD6710\t4"
    ],
    "globals_used": [
      "void\tpcic_attach_socket",
      "void\tpcic_init_socket",
      "void\tpcic_attach_card",
      "void\tpcic_create_event_thread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_attach_card",
          "args": [
            "h"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_attach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "750-762",
          "snippet": "void\npcic_attach_card(h)\n\tstruct pcic_handle *h;\n{\n\tif (h->flags & PCIC_FLAG_CARDP)\n\t\tpanic(\"pcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= PCIC_FLAG_CARDP;\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_attach_card"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_attach_card;\n\nvoid\npcic_attach_card(h)\n\tstruct pcic_handle *h;\n{\n\tif (h->flags & PCIC_FLAG_CARDP)\n\t\tpanic(\"pcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= PCIC_FLAG_CARDP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_read",
          "args": [
            "h",
            "PCIC_IF_STATUS"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1442-1451",
          "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t st_pcic_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_write",
          "args": [
            "h",
            "PCIC_CIRRUS_MISC_CTL_2",
            "reg"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1453-1465",
          "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tst_pcic_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: socket %02x was suspended\\n\",\n\t\t\t    h->ph_parent->dv_xname, h->sock)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create_deferred",
          "args": [
            "pcic_create_event_thread",
            "h"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcic_attach_socket: event thread\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCIC_VENDOR_CIRRUS_PD672X\t5\n#define\tPCIC_VENDOR_CIRRUS_PD6710\t4\n\nvoid\tpcic_attach_socket;\nvoid\tpcic_init_socket;\nvoid\tpcic_attach_card;\nvoid\tpcic_create_event_thread;\n\nvoid\npcic_init_socket(h)\n\tstruct pcic_handle *h;\n{\n\tint reg;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/*\n\t * queue creation of a kernel thread to handle insert/removal events.\n\t */\n#ifdef DIAGNOSTIC\n\tif (h->event_thread != NULL)\n\t\tpanic(\"pcic_attach_socket: event thread\");\n#endif\n\tkthread_create_deferred(pcic_create_event_thread, h);\n\n\t/* set up the card to interrupt on card detect */\n\n\tpcic_write(h, PCIC_CSC_INTR, (sc->irq << PCIC_CSC_INTR_IRQ_SHIFT) |\n\t    PCIC_CSC_INTR_CD_ENABLE);\n\tpcic_write(h, PCIC_INTR, 0);\n\tpcic_read(h, PCIC_CSC);\n\n\t/* unsleep the cirrus controller */\n\n\tif ((h->vendor == PCIC_VENDOR_CIRRUS_PD6710) ||\n\t    (h->vendor == PCIC_VENDOR_CIRRUS_PD672X)) {\n\t\treg = pcic_read(h, PCIC_CIRRUS_MISC_CTL_2);\n\t\tif (reg & PCIC_CIRRUS_MISC_CTL_2_SUSPEND) {\n\t\t\tDPRINTF((\"%s: socket %02x was suspended\\n\",\n\t\t\t    h->ph_parent->dv_xname, h->sock));\n\t\t\treg &= ~PCIC_CIRRUS_MISC_CTL_2_SUSPEND;\n\t\t\tpcic_write(h, PCIC_CIRRUS_MISC_CTL_2, reg);\n\t\t}\n\t}\n\t/* if there's a card there, then attach it. */\n\n\treg = pcic_read(h, PCIC_IF_STATUS);\n\n\tif ((reg & PCIC_IF_STATUS_CARDDETECT_MASK) ==\n\t    PCIC_IF_STATUS_CARDDETECT_PRESENT) {\n\t\tpcic_attach_card(h);\n\t\th->laststate = PCIC_LASTSTATE_PRESENT;\n\t} else\n\t\th->laststate = PCIC_LASTSTATE_EMPTY;\n}"
  },
  {
    "function_name": "pcic_event_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "416-509",
    "snippet": "void\npcic_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct pcic_handle *h = arg;\n\tstruct pcic_event *pe;\n\tint s;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\twhile (h->shutdown == 0) {\n\t\ts = splhigh();\n\t\tif ((pe = SIMPLEQ_FIRST(&h->events)) == NULL) {\n\t\t\tsplx(s);\n\t\t\t(void) tsleep(&h->events, PWAIT, \"pcicev\", 0);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tsplx(s);\n\t\t\t/* sleep .25s to be enqueued chatterling interrupts */\n\t\t\t(void) tsleep((caddr_t)pcic_event_thread, PWAIT,\n\t\t\t    \"pcicss\", hz/4);\n\t\t}\n\t\ts = splhigh();\n\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe, pe_q);\n\t\tsplx(s);\n\n\t\tswitch (pe->pe_type) {\n\t\tcase PCIC_EVENT_INSERTION:\n\t\t\ts = splhigh();\n\t\t\twhile (1) {\n\t\t\t\tstruct pcic_event *pe1, *pe2;\n\n\t\t\t\tif ((pe1 = SIMPLEQ_FIRST(&h->events)) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pe1->pe_type != PCIC_EVENT_REMOVAL)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((pe2 = SIMPLEQ_NEXT(pe1, pe_q)) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pe2->pe_type == PCIC_EVENT_INSERTION) {\n\t\t\t\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe1,\n\t\t\t\t\t    pe_q);\n\t\t\t\t\tfree(pe1, M_TEMP);\n\t\t\t\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe2,\n\t\t\t\t\t    pe_q);\n\t\t\t\t\tfree(pe2, M_TEMP);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsplx(s);\n\t\t\t\t\n\t\t\tDPRINTF((\"%s: insertion event\\n\",\n\t\t\t    h->ph_parent->dv_xname));\n\t\t\tpcic_attach_card(h);\n\t\t\tbreak;\n\n\t\tcase PCIC_EVENT_REMOVAL:\n\t\t\ts = splhigh();\n\t\t\twhile (1) {\n\t\t\t\tstruct pcic_event *pe1, *pe2;\n\n\t\t\t\tif ((pe1 = SIMPLEQ_FIRST(&h->events)) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pe1->pe_type != PCIC_EVENT_INSERTION)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((pe2 = SIMPLEQ_NEXT(pe1, pe_q)) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pe2->pe_type == PCIC_EVENT_REMOVAL) {\n\t\t\t\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe1,\n\t\t\t\t\t    pe_q);\n\t\t\t\t\tfree(pe1, M_TEMP);\n\t\t\t\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe2,\n\t\t\t\t\t    pe_q);\n\t\t\t\t\tfree(pe2, M_TEMP);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsplx(s);\n\n\t\t\tDPRINTF((\"%s: removal event\\n\",\n\t\t\t    h->ph_parent->dv_xname));\n\t\t\tpcic_detach_card(h, DETACH_FORCE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpanic(\"pcic_event_thread: unknown event %d\",\n\t\t\t    pe->pe_type);\n\t\t}\n\t\tfree(pe, M_TEMP);\n\t}\n\n\th->event_thread = NULL;\n\n\t/* In case parent is waiting for us to exit. */\n\twakeup(sc);\n\n\tkthread_exit(0);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_attach_card",
      "void\tpcic_detach_card",
      "void\tpcic_event_thread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_exit",
          "args": [
            "0"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "sc"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pe",
            "M_TEMP"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_chip_io_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1147-1160",
          "snippet": "void \npcic_chip_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tbus_space_tag_t iot = pcihp->iot;\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid \npcic_chip_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tbus_space_tag_t iot = pcihp->iot;\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcic_event_thread: unknown event %d\"",
            "pe->pe_type"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcic_detach_card",
          "args": [
            "h",
            "DETACH_FORCE"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_detach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "764-778",
          "snippet": "void\npcic_detach_card(h, flags)\n\tstruct pcic_handle *h;\n\tint flags;\t\t/* DETACH_* */\n{\n\n\tif (h->flags & PCIC_FLAG_CARDP) {\n\t\th->flags &= ~PCIC_FLAG_CARDP;\n\n\t\t/* call the MI detach function */\n\t\tpcmcia_card_detach(h->pcmcia, flags);\n\t} else {\n\t\tDPRINTF((\"pcic_detach_card: already detached\"));\n\t}\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_detach_card"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_detach_card;\n\nvoid\npcic_detach_card(h, flags)\n\tstruct pcic_handle *h;\n\tint flags;\t\t/* DETACH_* */\n{\n\n\tif (h->flags & PCIC_FLAG_CARDP) {\n\t\th->flags &= ~PCIC_FLAG_CARDP;\n\n\t\t/* call the MI detach function */\n\t\tpcmcia_card_detach(h->pcmcia, flags);\n\t} else {\n\t\tDPRINTF((\"pcic_detach_card: already detached\"));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: removal event\\n\",\n\t\t\t    h->ph_parent->dv_xname)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&h->events",
            "pe2",
            "pe_q"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&h->events",
            "pe1",
            "pe_q"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "pe1",
            "pe_q"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&h->events"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcic_attach_card",
          "args": [
            "h"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_attach_card",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "750-762",
          "snippet": "void\npcic_attach_card(h)\n\tstruct pcic_handle *h;\n{\n\tif (h->flags & PCIC_FLAG_CARDP)\n\t\tpanic(\"pcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= PCIC_FLAG_CARDP;\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_attach_card"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_attach_card;\n\nvoid\npcic_attach_card(h)\n\tstruct pcic_handle *h;\n{\n\tif (h->flags & PCIC_FLAG_CARDP)\n\t\tpanic(\"pcic_attach_card: already attached\");\n\n\t/* call the MI attach function */\n\n\tpcmcia_card_attach(h->pcmcia);\n\n\th->flags |= PCIC_FLAG_CARDP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"%s: insertion event\\n\",\n\t\t\t    h->ph_parent->dv_xname)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&h->events",
            "pe2",
            "pe_q"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&h->events",
            "pe1",
            "pe_q"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_NEXT",
          "args": [
            "pe1",
            "pe_q"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&h->events"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_REMOVE_HEAD",
          "args": [
            "&h->events",
            "pe",
            "pe_q"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)pcic_event_thread",
            "PWAIT",
            "\"pcicss\"",
            "hz/4"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "&h->events",
            "PWAIT",
            "\"pcicev\"",
            "0"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_FIRST",
          "args": [
            "&h->events"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_attach_card;\nvoid\tpcic_detach_card;\nvoid\tpcic_event_thread;\n\nvoid\npcic_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct pcic_handle *h = arg;\n\tstruct pcic_event *pe;\n\tint s;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\twhile (h->shutdown == 0) {\n\t\ts = splhigh();\n\t\tif ((pe = SIMPLEQ_FIRST(&h->events)) == NULL) {\n\t\t\tsplx(s);\n\t\t\t(void) tsleep(&h->events, PWAIT, \"pcicev\", 0);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tsplx(s);\n\t\t\t/* sleep .25s to be enqueued chatterling interrupts */\n\t\t\t(void) tsleep((caddr_t)pcic_event_thread, PWAIT,\n\t\t\t    \"pcicss\", hz/4);\n\t\t}\n\t\ts = splhigh();\n\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe, pe_q);\n\t\tsplx(s);\n\n\t\tswitch (pe->pe_type) {\n\t\tcase PCIC_EVENT_INSERTION:\n\t\t\ts = splhigh();\n\t\t\twhile (1) {\n\t\t\t\tstruct pcic_event *pe1, *pe2;\n\n\t\t\t\tif ((pe1 = SIMPLEQ_FIRST(&h->events)) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pe1->pe_type != PCIC_EVENT_REMOVAL)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((pe2 = SIMPLEQ_NEXT(pe1, pe_q)) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pe2->pe_type == PCIC_EVENT_INSERTION) {\n\t\t\t\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe1,\n\t\t\t\t\t    pe_q);\n\t\t\t\t\tfree(pe1, M_TEMP);\n\t\t\t\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe2,\n\t\t\t\t\t    pe_q);\n\t\t\t\t\tfree(pe2, M_TEMP);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsplx(s);\n\t\t\t\t\n\t\t\tDPRINTF((\"%s: insertion event\\n\",\n\t\t\t    h->ph_parent->dv_xname));\n\t\t\tpcic_attach_card(h);\n\t\t\tbreak;\n\n\t\tcase PCIC_EVENT_REMOVAL:\n\t\t\ts = splhigh();\n\t\t\twhile (1) {\n\t\t\t\tstruct pcic_event *pe1, *pe2;\n\n\t\t\t\tif ((pe1 = SIMPLEQ_FIRST(&h->events)) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pe1->pe_type != PCIC_EVENT_INSERTION)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((pe2 = SIMPLEQ_NEXT(pe1, pe_q)) == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pe2->pe_type == PCIC_EVENT_REMOVAL) {\n\t\t\t\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe1,\n\t\t\t\t\t    pe_q);\n\t\t\t\t\tfree(pe1, M_TEMP);\n\t\t\t\t\tSIMPLEQ_REMOVE_HEAD(&h->events, pe2,\n\t\t\t\t\t    pe_q);\n\t\t\t\t\tfree(pe2, M_TEMP);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsplx(s);\n\n\t\t\tDPRINTF((\"%s: removal event\\n\",\n\t\t\t    h->ph_parent->dv_xname));\n\t\t\tpcic_detach_card(h, DETACH_FORCE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpanic(\"pcic_event_thread: unknown event %d\",\n\t\t\t    pe->pe_type);\n\t\t}\n\t\tfree(pe, M_TEMP);\n\t}\n\n\th->event_thread = NULL;\n\n\t/* In case parent is waiting for us to exit. */\n\twakeup(sc);\n\n\tkthread_exit(0);\n}"
  },
  {
    "function_name": "pcic_create_event_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "384-414",
    "snippet": "void\npcic_create_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct pcic_handle *h = arg;\n\tconst char *cs;\n\n\tswitch (h->sock) {\n\tcase C0SA:\n\t\tcs = \"0,0\";\n\t\tbreak;\n\tcase C0SB:\n\t\tcs = \"0,1\";\n\t\tbreak;\n\tcase C1SA:\n\t\tcs = \"1,0\";\n\t\tbreak;\n\tcase C1SB:\n\t\tcs = \"1,1\";\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"pcic_create_event_thread: unknown pcic socket\");\n\t}\n\n\tif (kthread_create(pcic_event_thread, h, &h->event_thread,\n\t    \"%s,%s\", h->ph_parent->dv_xname, cs)) {\n\t\tprintf(\"%s: unable to create event thread for sock 0x%02x\\n\",\n\t\t    h->ph_parent->dv_xname, h->sock);\n\t\tpanic(\"pcic_create_event_thread\");\n\t}\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_create_event_thread",
      "void\tpcic_event_thread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcic_create_event_thread\""
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to create event thread for sock 0x%02x\\n\"",
            "h->ph_parent->dv_xname",
            "h->sock"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "pcic_event_thread",
            "h",
            "&h->event_thread",
            "\"%s,%s\"",
            "h->ph_parent->dv_xname",
            "cs"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pcic_create_event_thread: unknown pcic socket\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_create_event_thread;\nvoid\tpcic_event_thread;\n\nvoid\npcic_create_event_thread(arg)\n\tvoid *arg;\n{\n\tstruct pcic_handle *h = arg;\n\tconst char *cs;\n\n\tswitch (h->sock) {\n\tcase C0SA:\n\t\tcs = \"0,0\";\n\t\tbreak;\n\tcase C0SB:\n\t\tcs = \"0,1\";\n\t\tbreak;\n\tcase C1SA:\n\t\tcs = \"1,0\";\n\t\tbreak;\n\tcase C1SB:\n\t\tcs = \"1,1\";\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"pcic_create_event_thread: unknown pcic socket\");\n\t}\n\n\tif (kthread_create(pcic_event_thread, h, &h->event_thread,\n\t    \"%s,%s\", h->ph_parent->dv_xname, cs)) {\n\t\tprintf(\"%s: unable to create event thread for sock 0x%02x\\n\",\n\t\t    h->ph_parent->dv_xname, h->sock);\n\t\tpanic(\"pcic_create_event_thread\");\n\t}\n}"
  },
  {
    "function_name": "pcic_attach_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "351-382",
    "snippet": "void\npcic_attach_socket(h)\n\tstruct pcic_handle *h;\n{\n\tstruct pcmciabus_attach_args paa;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/* initialize the rest of the handle */\n\n\th->shutdown = 0;\n\th->memalloc = 0;\n\th->ioalloc = 0;\n\th->ih_irq = 0;\n\n\t/* now, config one pcmcia device per socket */\n\n\tpaa.paa_busname = \"pcmcia\";\n\tpaa.pct = (pcmcia_chipset_tag_t) sc->pct;\n\tpaa.pch = (pcmcia_chipset_handle_t) h;\n\tpaa.iobase = sc->iobase;\n\tpaa.iosize = sc->iosize;\n\n\th->pcmcia = config_found_sm(&sc->dev, &paa, pcic_print,\n\t    pcic_submatch);\n\n\t/* if there's actually a pcmcia device attached, initialize the slot */\n\n\tif (h->pcmcia)\n\t\tpcic_init_socket(h);\n\telse\n\t\th->flags &= ~PCIC_FLAG_SOCKETP;\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_attach_socket",
      "void\tpcic_init_socket",
      "int\tpcic_submatch",
      "int\tpcic_print"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_init_socket",
          "args": [
            "h"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_init_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "511-556",
          "snippet": "void\npcic_init_socket(h)\n\tstruct pcic_handle *h;\n{\n\tint reg;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/*\n\t * queue creation of a kernel thread to handle insert/removal events.\n\t */\n#ifdef DIAGNOSTIC\n\tif (h->event_thread != NULL)\n\t\tpanic(\"pcic_attach_socket: event thread\");\n#endif\n\tkthread_create_deferred(pcic_create_event_thread, h);\n\n\t/* set up the card to interrupt on card detect */\n\n\tpcic_write(h, PCIC_CSC_INTR, (sc->irq << PCIC_CSC_INTR_IRQ_SHIFT) |\n\t    PCIC_CSC_INTR_CD_ENABLE);\n\tpcic_write(h, PCIC_INTR, 0);\n\tpcic_read(h, PCIC_CSC);\n\n\t/* unsleep the cirrus controller */\n\n\tif ((h->vendor == PCIC_VENDOR_CIRRUS_PD6710) ||\n\t    (h->vendor == PCIC_VENDOR_CIRRUS_PD672X)) {\n\t\treg = pcic_read(h, PCIC_CIRRUS_MISC_CTL_2);\n\t\tif (reg & PCIC_CIRRUS_MISC_CTL_2_SUSPEND) {\n\t\t\tDPRINTF((\"%s: socket %02x was suspended\\n\",\n\t\t\t    h->ph_parent->dv_xname, h->sock));\n\t\t\treg &= ~PCIC_CIRRUS_MISC_CTL_2_SUSPEND;\n\t\t\tpcic_write(h, PCIC_CIRRUS_MISC_CTL_2, reg);\n\t\t}\n\t}\n\t/* if there's a card there, then attach it. */\n\n\treg = pcic_read(h, PCIC_IF_STATUS);\n\n\tif ((reg & PCIC_IF_STATUS_CARDDETECT_MASK) ==\n\t    PCIC_IF_STATUS_CARDDETECT_PRESENT) {\n\t\tpcic_attach_card(h);\n\t\th->laststate = PCIC_LASTSTATE_PRESENT;\n\t} else\n\t\th->laststate = PCIC_LASTSTATE_EMPTY;\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tPCIC_VENDOR_CIRRUS_PD672X\t5",
            "#define\tPCIC_VENDOR_CIRRUS_PD6710\t4"
          ],
          "globals_used": [
            "void\tpcic_attach_socket",
            "void\tpcic_init_socket",
            "void\tpcic_attach_card",
            "void\tpcic_create_event_thread"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCIC_VENDOR_CIRRUS_PD672X\t5\n#define\tPCIC_VENDOR_CIRRUS_PD6710\t4\n\nvoid\tpcic_attach_socket;\nvoid\tpcic_init_socket;\nvoid\tpcic_attach_card;\nvoid\tpcic_create_event_thread;\n\nvoid\npcic_init_socket(h)\n\tstruct pcic_handle *h;\n{\n\tint reg;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/*\n\t * queue creation of a kernel thread to handle insert/removal events.\n\t */\n#ifdef DIAGNOSTIC\n\tif (h->event_thread != NULL)\n\t\tpanic(\"pcic_attach_socket: event thread\");\n#endif\n\tkthread_create_deferred(pcic_create_event_thread, h);\n\n\t/* set up the card to interrupt on card detect */\n\n\tpcic_write(h, PCIC_CSC_INTR, (sc->irq << PCIC_CSC_INTR_IRQ_SHIFT) |\n\t    PCIC_CSC_INTR_CD_ENABLE);\n\tpcic_write(h, PCIC_INTR, 0);\n\tpcic_read(h, PCIC_CSC);\n\n\t/* unsleep the cirrus controller */\n\n\tif ((h->vendor == PCIC_VENDOR_CIRRUS_PD6710) ||\n\t    (h->vendor == PCIC_VENDOR_CIRRUS_PD672X)) {\n\t\treg = pcic_read(h, PCIC_CIRRUS_MISC_CTL_2);\n\t\tif (reg & PCIC_CIRRUS_MISC_CTL_2_SUSPEND) {\n\t\t\tDPRINTF((\"%s: socket %02x was suspended\\n\",\n\t\t\t    h->ph_parent->dv_xname, h->sock));\n\t\t\treg &= ~PCIC_CIRRUS_MISC_CTL_2_SUSPEND;\n\t\t\tpcic_write(h, PCIC_CIRRUS_MISC_CTL_2, reg);\n\t\t}\n\t}\n\t/* if there's a card there, then attach it. */\n\n\treg = pcic_read(h, PCIC_IF_STATUS);\n\n\tif ((reg & PCIC_IF_STATUS_CARDDETECT_MASK) ==\n\t    PCIC_IF_STATUS_CARDDETECT_PRESENT) {\n\t\tpcic_attach_card(h);\n\t\th->laststate = PCIC_LASTSTATE_PRESENT;\n\t} else\n\t\th->laststate = PCIC_LASTSTATE_EMPTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_found_sm",
          "args": [
            "&sc->dev",
            "&paa",
            "pcic_print",
            "pcic_submatch"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_attach_socket;\nvoid\tpcic_init_socket;\nint\tpcic_submatch;\nint\tpcic_print;\n\nvoid\npcic_attach_socket(h)\n\tstruct pcic_handle *h;\n{\n\tstruct pcmciabus_attach_args paa;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/* initialize the rest of the handle */\n\n\th->shutdown = 0;\n\th->memalloc = 0;\n\th->ioalloc = 0;\n\th->ih_irq = 0;\n\n\t/* now, config one pcmcia device per socket */\n\n\tpaa.paa_busname = \"pcmcia\";\n\tpaa.pct = (pcmcia_chipset_tag_t) sc->pct;\n\tpaa.pch = (pcmcia_chipset_handle_t) h;\n\tpaa.iobase = sc->iobase;\n\tpaa.iosize = sc->iosize;\n\n\th->pcmcia = config_found_sm(&sc->dev, &paa, pcic_print,\n\t    pcic_submatch);\n\n\t/* if there's actually a pcmcia device attached, initialize the slot */\n\n\tif (h->pcmcia)\n\t\tpcic_init_socket(h);\n\telse\n\t\th->flags &= ~PCIC_FLAG_SOCKETP;\n}"
  },
  {
    "function_name": "pcic_attach_sockets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "340-349",
    "snippet": "void\npcic_attach_sockets(sc)\n\tstruct pcic_softc *sc;\n{\n\tint i;\n\n\tfor (i = 0; i < PCIC_NSLOTS; i++)\n\t\tif (sc->handle[i].flags & PCIC_FLAG_SOCKETP)\n\t\t\tpcic_attach_socket(&sc->handle[i]);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tpcic_attach_socket"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_attach_socket",
          "args": [
            "&sc->handle[i]"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_attach_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "351-382",
          "snippet": "void\npcic_attach_socket(h)\n\tstruct pcic_handle *h;\n{\n\tstruct pcmciabus_attach_args paa;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/* initialize the rest of the handle */\n\n\th->shutdown = 0;\n\th->memalloc = 0;\n\th->ioalloc = 0;\n\th->ih_irq = 0;\n\n\t/* now, config one pcmcia device per socket */\n\n\tpaa.paa_busname = \"pcmcia\";\n\tpaa.pct = (pcmcia_chipset_tag_t) sc->pct;\n\tpaa.pch = (pcmcia_chipset_handle_t) h;\n\tpaa.iobase = sc->iobase;\n\tpaa.iosize = sc->iosize;\n\n\th->pcmcia = config_found_sm(&sc->dev, &paa, pcic_print,\n\t    pcic_submatch);\n\n\t/* if there's actually a pcmcia device attached, initialize the slot */\n\n\tif (h->pcmcia)\n\t\tpcic_init_socket(h);\n\telse\n\t\th->flags &= ~PCIC_FLAG_SOCKETP;\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tpcic_attach_socket",
            "void\tpcic_init_socket",
            "int\tpcic_submatch",
            "int\tpcic_print"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_attach_socket;\nvoid\tpcic_init_socket;\nint\tpcic_submatch;\nint\tpcic_print;\n\nvoid\npcic_attach_socket(h)\n\tstruct pcic_handle *h;\n{\n\tstruct pcmciabus_attach_args paa;\n\tstruct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);\n\n\t/* initialize the rest of the handle */\n\n\th->shutdown = 0;\n\th->memalloc = 0;\n\th->ioalloc = 0;\n\th->ih_irq = 0;\n\n\t/* now, config one pcmcia device per socket */\n\n\tpaa.paa_busname = \"pcmcia\";\n\tpaa.pct = (pcmcia_chipset_tag_t) sc->pct;\n\tpaa.pch = (pcmcia_chipset_handle_t) h;\n\tpaa.iobase = sc->iobase;\n\tpaa.iosize = sc->iosize;\n\n\th->pcmcia = config_found_sm(&sc->dev, &paa, pcic_print,\n\t    pcic_submatch);\n\n\t/* if there's actually a pcmcia device attached, initialize the slot */\n\n\tif (h->pcmcia)\n\t\tpcic_init_socket(h);\n\telse\n\t\th->flags &= ~PCIC_FLAG_SOCKETP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tpcic_attach_socket;\n\nvoid\npcic_attach_sockets(sc)\n\tstruct pcic_softc *sc;\n{\n\tint i;\n\n\tfor (i = 0; i < PCIC_NSLOTS; i++)\n\t\tif (sc->handle[i].flags & PCIC_FLAG_SOCKETP)\n\t\t\tpcic_attach_socket(&sc->handle[i]);\n}"
  },
  {
    "function_name": "pcic_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "198-338",
    "snippet": "void\npcic_attach(sc)\n\tstruct pcic_softc *sc;\n{\n\tint vendor, count, i, reg;\n\n\t/* now check for each controller/socket */\n\n\t/*\n\t * this could be done with a loop, but it would violate the\n\t * abstraction\n\t */\n\n\tcount = 0;\n\n\tDPRINTF((\"pcic ident regs:\"));\n\n\tsc->handle[0].ph_parent = (struct device *)sc;\n\tsc->handle[0].sock = C0SA;\n\t/* initialise pcic_read and pcic_write functions */\n\tsc->handle[0].ph_read = st_pcic_read;\n\tsc->handle[0].ph_write = st_pcic_write;\n\tsc->handle[0].ph_bus_t = sc->iot;\n\tsc->handle[0].ph_bus_h = sc->ioh;\n\tif (pcic_ident_ok(reg = pcic_read(&sc->handle[0], PCIC_IDENT))) {\n\t\tsc->handle[0].flags = PCIC_FLAG_SOCKETP;\n\t\tcount++;\n\t} else {\n\t\tsc->handle[0].flags = 0;\n\t}\n\tsc->handle[0].laststate = PCIC_LASTSTATE_EMPTY;\n\n\tDPRINTF((\" 0x%02x\", reg));\n\n\tsc->handle[1].ph_parent = (struct device *)sc;\n\tsc->handle[1].sock = C0SB;\n\t/* initialise pcic_read and pcic_write functions */\n\tsc->handle[1].ph_read = st_pcic_read;\n\tsc->handle[1].ph_write = st_pcic_write;\n\tsc->handle[1].ph_bus_t = sc->iot;\n\tsc->handle[1].ph_bus_h = sc->ioh;\n\tif (pcic_ident_ok(reg = pcic_read(&sc->handle[1], PCIC_IDENT))) {\n\t\tsc->handle[1].flags = PCIC_FLAG_SOCKETP;\n\t\tcount++;\n\t} else {\n\t\tsc->handle[1].flags = 0;\n\t}\n\tsc->handle[1].laststate = PCIC_LASTSTATE_EMPTY;\n\n\tDPRINTF((\" 0x%02x\", reg));\n\n\t/*\n\t * The CL-PD6729 has only one controller and always returns 0\n\t * if you try to read from the second one. Maybe pcic_ident_ok\n\t * shouldn't accept 0?\n\t */\n\tsc->handle[2].ph_parent = (struct device *)sc;\n\tsc->handle[2].sock = C1SA;\n\t/* initialise pcic_read and pcic_write functions */\n\tsc->handle[2].ph_read = st_pcic_read;\n\tsc->handle[2].ph_write = st_pcic_write;\n\tsc->handle[2].ph_bus_t = sc->iot;\n\tsc->handle[2].ph_bus_h = sc->ioh;\n\tif (pcic_vendor(&sc->handle[0]) != PCIC_VENDOR_CIRRUS_PD672X ||\n\t    pcic_read(&sc->handle[2], PCIC_IDENT) != 0) {\n\t\tif (pcic_ident_ok(reg = pcic_read(&sc->handle[2],\n\t\t    PCIC_IDENT))) {\n\t\t\tsc->handle[2].flags = PCIC_FLAG_SOCKETP;\n\t\t\tcount++;\n\t\t} else {\n\t\t\tsc->handle[2].flags = 0;\n\t\t}\n\t\tsc->handle[2].laststate = PCIC_LASTSTATE_EMPTY;\n\n\t\tDPRINTF((\" 0x%02x\", reg));\n\n\t\tsc->handle[3].ph_parent = (struct device *)sc;\n\t\tsc->handle[3].sock = C1SB;\n\t\t/* initialise pcic_read and pcic_write functions */\n\t\tsc->handle[3].ph_read = st_pcic_read;\n\t\tsc->handle[3].ph_write = st_pcic_write;\n\t\tsc->handle[3].ph_bus_t = sc->iot;\n\t\tsc->handle[3].ph_bus_h = sc->ioh;\n\t\tif (pcic_ident_ok(reg = pcic_read(&sc->handle[3],\n\t\t    PCIC_IDENT))) {\n\t\t\tsc->handle[3].flags = PCIC_FLAG_SOCKETP;\n\t\t\tcount++;\n\t\t} else {\n\t\t\tsc->handle[3].flags = 0;\n\t\t}\n\t\tsc->handle[3].laststate = PCIC_LASTSTATE_EMPTY;\n\n\t\tDPRINTF((\" 0x%02x\\n\", reg));\n\t} else {\n\t\tsc->handle[2].flags = 0;\n\t\tsc->handle[3].flags = 0;\n\t}\n\n\tif (count == 0)\n\t\treturn;\n\n\t/* establish the interrupt */\n\n\t/* XXX block interrupts? */\n\n\tfor (i = 0; i < PCIC_NSLOTS; i++) {\n\t\t/*\n\t\t * this should work, but w/o it, setting tty flags hangs at\n\t\t * boot time.\n\t\t */\n\t\tif (sc->handle[i].flags & PCIC_FLAG_SOCKETP) {\n\t\t\tSIMPLEQ_INIT(&sc->handle[i].events);\n\t\t\tpcic_write(&sc->handle[i], PCIC_CSC_INTR, 0);\n\t\t\tpcic_read(&sc->handle[i], PCIC_CSC);\n\t\t}\n\t}\n\n\tfor (i = 0; i < PCIC_NSLOTS; i += 2) {\n\t\tif ((sc->handle[i+0].flags & PCIC_FLAG_SOCKETP) ||\n\t\t    (sc->handle[i+1].flags & PCIC_FLAG_SOCKETP)) {\n\t\t\tvendor = pcic_vendor(&sc->handle[i]);\n\n\t\t\tprintf(\"%s controller %d: <%s> has socket\",\n\t\t\t    sc->dev.dv_xname, i/2,\n\t\t\t    pcic_vendor_to_string[vendor]);\n\n\t\t\tif ((sc->handle[i+0].flags & PCIC_FLAG_SOCKETP) &&\n\t\t\t    (sc->handle[i+1].flags & PCIC_FLAG_SOCKETP))\n\t\t\t\tprintf(\"s A and B\\n\");\n\t\t\telse if (sc->handle[i+0].flags & PCIC_FLAG_SOCKETP)\n\t\t\t\tprintf(\" A only\\n\");\n\t\t\telse\n\t\t\t\tprintf(\" B only\\n\");\n\n\t\t\tif (sc->handle[i+0].flags & PCIC_FLAG_SOCKETP)\n\t\t\t\tsc->handle[i+0].vendor = vendor;\n\t\t\tif (sc->handle[i+1].flags & PCIC_FLAG_SOCKETP)\n\t\t\t\tsc->handle[i+1].vendor = vendor;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tPCIC_VENDOR_CIRRUS_PD672X\t5"
    ],
    "globals_used": [
      "static char *pcic_vendor_to_string[] = {\n\t\"Unknown\",\n\t\"Intel 82365SL rev 0\",\n\t\"Intel 82365SL rev 1\",\n\t\"Intel 82365SL rev 2\",\n\t\"Cirrus PD6710\",\n\t\"Cirrus PD672X\",\n\t\"Vadem VG468\",\n\t\"Vadem VG469\",\n};",
      "u_int8_t st_pcic_read",
      "void\tst_pcic_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" B only\\n\""
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_vendor",
          "args": [
            "&sc->handle[i]"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_vendor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "133-196",
          "snippet": "int\npcic_vendor(h)\n\tstruct pcic_handle *h;\n{\n\tint vendor, reg;\n\n\t/*\n\t * the chip_id of the cirrus toggles between 11 and 00 after a write.\n\t * weird.\n\t */\n\n\tpcic_write(h, PCIC_CIRRUS_CHIP_INFO, 0);\n\treg = pcic_read(h, -1);\n\n\tif ((reg & PCIC_CIRRUS_CHIP_INFO_CHIP_ID) ==\n\t    PCIC_CIRRUS_CHIP_INFO_CHIP_ID) {\n\t\treg = pcic_read(h, -1);\n\t\tif ((reg & PCIC_CIRRUS_CHIP_INFO_CHIP_ID) == 0) {\n\t\t\tif (reg & PCIC_CIRRUS_CHIP_INFO_SLOTS)\n\t\t\t\treturn (PCIC_VENDOR_CIRRUS_PD672X);\n\t\t\telse\n\t\t\t\treturn (PCIC_VENDOR_CIRRUS_PD6710);\n\t\t}\n\t}\n\n\treg = pcic_read(h, PCIC_IDENT);\n\n\tswitch (reg) {\n\tcase PCIC_IDENT_REV_I82365SLR0:\n\t\tvendor = PCIC_VENDOR_I82365SLR0;\n\t\tbreak;\n\tcase PCIC_IDENT_REV_I82365SLR1:\n\t\tvendor = PCIC_VENDOR_I82365SLR1;\n\t\tbreak;\n\tcase PCIC_IDENT_REV_I82365SLR2:\n\t\tvendor = PCIC_VENDOR_I82365SLR2;\n\t\tbreak;\n\tdefault:\n\t\tvendor = PCIC_VENDOR_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tpcic_write(h, 0x0e, -1);\n\tpcic_write(h, 0x37, -1);\n\n\treg = pcic_read(h, PCIC_VG468_MISC);\n\treg |= PCIC_VG468_MISC_VADEMREV;\n\tpcic_write(h, PCIC_VG468_MISC, reg);\n\n\treg = pcic_read(h, PCIC_IDENT);\n\n\tif (reg & PCIC_IDENT_VADEM_MASK) {\n\t\tif ((reg & 7) >= 4)\n\t\t\tvendor = PCIC_VENDOR_VADEM_VG469;\n\t\telse\n\t\t\tvendor = PCIC_VENDOR_VADEM_VG468;\n\n\t\treg = pcic_read(h, PCIC_VG468_MISC);\n\t\treg &= ~PCIC_VG468_MISC_VADEMREV;\n\t\tpcic_write(h, PCIC_VG468_MISC, reg);\n\t}\n\n\treturn (vendor);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tPCIC_VENDOR_VADEM_VG469\t\t7",
            "#define\tPCIC_VENDOR_VADEM_VG468\t\t6",
            "#define\tPCIC_VENDOR_CIRRUS_PD672X\t5",
            "#define\tPCIC_VENDOR_CIRRUS_PD6710\t4",
            "#define\tPCIC_VENDOR_I82365SLR2\t\t3",
            "#define\tPCIC_VENDOR_I82365SLR1\t\t2",
            "#define\tPCIC_VENDOR_I82365SLR0\t\t1",
            "#define\tPCIC_VENDOR_UNKNOWN\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCIC_VENDOR_VADEM_VG469\t\t7\n#define\tPCIC_VENDOR_VADEM_VG468\t\t6\n#define\tPCIC_VENDOR_CIRRUS_PD672X\t5\n#define\tPCIC_VENDOR_CIRRUS_PD6710\t4\n#define\tPCIC_VENDOR_I82365SLR2\t\t3\n#define\tPCIC_VENDOR_I82365SLR1\t\t2\n#define\tPCIC_VENDOR_I82365SLR0\t\t1\n#define\tPCIC_VENDOR_UNKNOWN\t\t0\n\nint\npcic_vendor(h)\n\tstruct pcic_handle *h;\n{\n\tint vendor, reg;\n\n\t/*\n\t * the chip_id of the cirrus toggles between 11 and 00 after a write.\n\t * weird.\n\t */\n\n\tpcic_write(h, PCIC_CIRRUS_CHIP_INFO, 0);\n\treg = pcic_read(h, -1);\n\n\tif ((reg & PCIC_CIRRUS_CHIP_INFO_CHIP_ID) ==\n\t    PCIC_CIRRUS_CHIP_INFO_CHIP_ID) {\n\t\treg = pcic_read(h, -1);\n\t\tif ((reg & PCIC_CIRRUS_CHIP_INFO_CHIP_ID) == 0) {\n\t\t\tif (reg & PCIC_CIRRUS_CHIP_INFO_SLOTS)\n\t\t\t\treturn (PCIC_VENDOR_CIRRUS_PD672X);\n\t\t\telse\n\t\t\t\treturn (PCIC_VENDOR_CIRRUS_PD6710);\n\t\t}\n\t}\n\n\treg = pcic_read(h, PCIC_IDENT);\n\n\tswitch (reg) {\n\tcase PCIC_IDENT_REV_I82365SLR0:\n\t\tvendor = PCIC_VENDOR_I82365SLR0;\n\t\tbreak;\n\tcase PCIC_IDENT_REV_I82365SLR1:\n\t\tvendor = PCIC_VENDOR_I82365SLR1;\n\t\tbreak;\n\tcase PCIC_IDENT_REV_I82365SLR2:\n\t\tvendor = PCIC_VENDOR_I82365SLR2;\n\t\tbreak;\n\tdefault:\n\t\tvendor = PCIC_VENDOR_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tpcic_write(h, 0x0e, -1);\n\tpcic_write(h, 0x37, -1);\n\n\treg = pcic_read(h, PCIC_VG468_MISC);\n\treg |= PCIC_VG468_MISC_VADEMREV;\n\tpcic_write(h, PCIC_VG468_MISC, reg);\n\n\treg = pcic_read(h, PCIC_IDENT);\n\n\tif (reg & PCIC_IDENT_VADEM_MASK) {\n\t\tif ((reg & 7) >= 4)\n\t\t\tvendor = PCIC_VENDOR_VADEM_VG469;\n\t\telse\n\t\t\tvendor = PCIC_VENDOR_VADEM_VG468;\n\n\t\treg = pcic_read(h, PCIC_VG468_MISC);\n\t\treg &= ~PCIC_VG468_MISC_VADEMREV;\n\t\tpcic_write(h, PCIC_VG468_MISC, reg);\n\t}\n\n\treturn (vendor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_read",
          "args": [
            "&sc->handle[i]",
            "PCIC_CSC"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1442-1451",
          "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t st_pcic_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_write",
          "args": [
            "&sc->handle[i]",
            "PCIC_CSC_INTR",
            "0"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1453-1465",
          "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tst_pcic_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "&sc->handle[i].events"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" 0x%02x\\n\", reg)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcic_ident_ok",
          "args": [
            "reg = pcic_read(&sc->handle[3],\n\t\t    PCIC_IDENT)"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "pcic_ident_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "114-131",
          "snippet": "int\npcic_ident_ok(ident)\n\tint ident;\n{\n\t/* this is very empirical and heuristic */\n\n\tif (ident == 0 || ident == 0xff || (ident & PCIC_IDENT_ZERO))\n\t\treturn (0);\n\n\tif ((ident & PCIC_IDENT_IFTYPE_MASK) != PCIC_IDENT_IFTYPE_MEM_AND_IO) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"pcic: does not support memory and I/O cards, \"\n\t\t    \"ignored (ident=%0x)\\n\", ident);\n#endif\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\npcic_ident_ok(ident)\n\tint ident;\n{\n\t/* this is very empirical and heuristic */\n\n\tif (ident == 0 || ident == 0xff || (ident & PCIC_IDENT_ZERO))\n\t\treturn (0);\n\n\tif ((ident & PCIC_IDENT_IFTYPE_MASK) != PCIC_IDENT_IFTYPE_MEM_AND_IO) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"pcic: does not support memory and I/O cards, \"\n\t\t    \"ignored (ident=%0x)\\n\", ident);\n#endif\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" 0x%02x\", reg)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" 0x%02x\", reg)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\" 0x%02x\", reg)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"pcic ident regs:\")"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCIC_VENDOR_CIRRUS_PD672X\t5\n\nstatic char *pcic_vendor_to_string[] = {\n\t\"Unknown\",\n\t\"Intel 82365SL rev 0\",\n\t\"Intel 82365SL rev 1\",\n\t\"Intel 82365SL rev 2\",\n\t\"Cirrus PD6710\",\n\t\"Cirrus PD672X\",\n\t\"Vadem VG468\",\n\t\"Vadem VG469\",\n};\nu_int8_t st_pcic_read;\nvoid\tst_pcic_write;\n\nvoid\npcic_attach(sc)\n\tstruct pcic_softc *sc;\n{\n\tint vendor, count, i, reg;\n\n\t/* now check for each controller/socket */\n\n\t/*\n\t * this could be done with a loop, but it would violate the\n\t * abstraction\n\t */\n\n\tcount = 0;\n\n\tDPRINTF((\"pcic ident regs:\"));\n\n\tsc->handle[0].ph_parent = (struct device *)sc;\n\tsc->handle[0].sock = C0SA;\n\t/* initialise pcic_read and pcic_write functions */\n\tsc->handle[0].ph_read = st_pcic_read;\n\tsc->handle[0].ph_write = st_pcic_write;\n\tsc->handle[0].ph_bus_t = sc->iot;\n\tsc->handle[0].ph_bus_h = sc->ioh;\n\tif (pcic_ident_ok(reg = pcic_read(&sc->handle[0], PCIC_IDENT))) {\n\t\tsc->handle[0].flags = PCIC_FLAG_SOCKETP;\n\t\tcount++;\n\t} else {\n\t\tsc->handle[0].flags = 0;\n\t}\n\tsc->handle[0].laststate = PCIC_LASTSTATE_EMPTY;\n\n\tDPRINTF((\" 0x%02x\", reg));\n\n\tsc->handle[1].ph_parent = (struct device *)sc;\n\tsc->handle[1].sock = C0SB;\n\t/* initialise pcic_read and pcic_write functions */\n\tsc->handle[1].ph_read = st_pcic_read;\n\tsc->handle[1].ph_write = st_pcic_write;\n\tsc->handle[1].ph_bus_t = sc->iot;\n\tsc->handle[1].ph_bus_h = sc->ioh;\n\tif (pcic_ident_ok(reg = pcic_read(&sc->handle[1], PCIC_IDENT))) {\n\t\tsc->handle[1].flags = PCIC_FLAG_SOCKETP;\n\t\tcount++;\n\t} else {\n\t\tsc->handle[1].flags = 0;\n\t}\n\tsc->handle[1].laststate = PCIC_LASTSTATE_EMPTY;\n\n\tDPRINTF((\" 0x%02x\", reg));\n\n\t/*\n\t * The CL-PD6729 has only one controller and always returns 0\n\t * if you try to read from the second one. Maybe pcic_ident_ok\n\t * shouldn't accept 0?\n\t */\n\tsc->handle[2].ph_parent = (struct device *)sc;\n\tsc->handle[2].sock = C1SA;\n\t/* initialise pcic_read and pcic_write functions */\n\tsc->handle[2].ph_read = st_pcic_read;\n\tsc->handle[2].ph_write = st_pcic_write;\n\tsc->handle[2].ph_bus_t = sc->iot;\n\tsc->handle[2].ph_bus_h = sc->ioh;\n\tif (pcic_vendor(&sc->handle[0]) != PCIC_VENDOR_CIRRUS_PD672X ||\n\t    pcic_read(&sc->handle[2], PCIC_IDENT) != 0) {\n\t\tif (pcic_ident_ok(reg = pcic_read(&sc->handle[2],\n\t\t    PCIC_IDENT))) {\n\t\t\tsc->handle[2].flags = PCIC_FLAG_SOCKETP;\n\t\t\tcount++;\n\t\t} else {\n\t\t\tsc->handle[2].flags = 0;\n\t\t}\n\t\tsc->handle[2].laststate = PCIC_LASTSTATE_EMPTY;\n\n\t\tDPRINTF((\" 0x%02x\", reg));\n\n\t\tsc->handle[3].ph_parent = (struct device *)sc;\n\t\tsc->handle[3].sock = C1SB;\n\t\t/* initialise pcic_read and pcic_write functions */\n\t\tsc->handle[3].ph_read = st_pcic_read;\n\t\tsc->handle[3].ph_write = st_pcic_write;\n\t\tsc->handle[3].ph_bus_t = sc->iot;\n\t\tsc->handle[3].ph_bus_h = sc->ioh;\n\t\tif (pcic_ident_ok(reg = pcic_read(&sc->handle[3],\n\t\t    PCIC_IDENT))) {\n\t\t\tsc->handle[3].flags = PCIC_FLAG_SOCKETP;\n\t\t\tcount++;\n\t\t} else {\n\t\t\tsc->handle[3].flags = 0;\n\t\t}\n\t\tsc->handle[3].laststate = PCIC_LASTSTATE_EMPTY;\n\n\t\tDPRINTF((\" 0x%02x\\n\", reg));\n\t} else {\n\t\tsc->handle[2].flags = 0;\n\t\tsc->handle[3].flags = 0;\n\t}\n\n\tif (count == 0)\n\t\treturn;\n\n\t/* establish the interrupt */\n\n\t/* XXX block interrupts? */\n\n\tfor (i = 0; i < PCIC_NSLOTS; i++) {\n\t\t/*\n\t\t * this should work, but w/o it, setting tty flags hangs at\n\t\t * boot time.\n\t\t */\n\t\tif (sc->handle[i].flags & PCIC_FLAG_SOCKETP) {\n\t\t\tSIMPLEQ_INIT(&sc->handle[i].events);\n\t\t\tpcic_write(&sc->handle[i], PCIC_CSC_INTR, 0);\n\t\t\tpcic_read(&sc->handle[i], PCIC_CSC);\n\t\t}\n\t}\n\n\tfor (i = 0; i < PCIC_NSLOTS; i += 2) {\n\t\tif ((sc->handle[i+0].flags & PCIC_FLAG_SOCKETP) ||\n\t\t    (sc->handle[i+1].flags & PCIC_FLAG_SOCKETP)) {\n\t\t\tvendor = pcic_vendor(&sc->handle[i]);\n\n\t\t\tprintf(\"%s controller %d: <%s> has socket\",\n\t\t\t    sc->dev.dv_xname, i/2,\n\t\t\t    pcic_vendor_to_string[vendor]);\n\n\t\t\tif ((sc->handle[i+0].flags & PCIC_FLAG_SOCKETP) &&\n\t\t\t    (sc->handle[i+1].flags & PCIC_FLAG_SOCKETP))\n\t\t\t\tprintf(\"s A and B\\n\");\n\t\t\telse if (sc->handle[i+0].flags & PCIC_FLAG_SOCKETP)\n\t\t\t\tprintf(\" A only\\n\");\n\t\t\telse\n\t\t\t\tprintf(\" B only\\n\");\n\n\t\t\tif (sc->handle[i+0].flags & PCIC_FLAG_SOCKETP)\n\t\t\t\tsc->handle[i+0].vendor = vendor;\n\t\t\tif (sc->handle[i+1].flags & PCIC_FLAG_SOCKETP)\n\t\t\t\tsc->handle[i+1].vendor = vendor;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pcic_vendor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "133-196",
    "snippet": "int\npcic_vendor(h)\n\tstruct pcic_handle *h;\n{\n\tint vendor, reg;\n\n\t/*\n\t * the chip_id of the cirrus toggles between 11 and 00 after a write.\n\t * weird.\n\t */\n\n\tpcic_write(h, PCIC_CIRRUS_CHIP_INFO, 0);\n\treg = pcic_read(h, -1);\n\n\tif ((reg & PCIC_CIRRUS_CHIP_INFO_CHIP_ID) ==\n\t    PCIC_CIRRUS_CHIP_INFO_CHIP_ID) {\n\t\treg = pcic_read(h, -1);\n\t\tif ((reg & PCIC_CIRRUS_CHIP_INFO_CHIP_ID) == 0) {\n\t\t\tif (reg & PCIC_CIRRUS_CHIP_INFO_SLOTS)\n\t\t\t\treturn (PCIC_VENDOR_CIRRUS_PD672X);\n\t\t\telse\n\t\t\t\treturn (PCIC_VENDOR_CIRRUS_PD6710);\n\t\t}\n\t}\n\n\treg = pcic_read(h, PCIC_IDENT);\n\n\tswitch (reg) {\n\tcase PCIC_IDENT_REV_I82365SLR0:\n\t\tvendor = PCIC_VENDOR_I82365SLR0;\n\t\tbreak;\n\tcase PCIC_IDENT_REV_I82365SLR1:\n\t\tvendor = PCIC_VENDOR_I82365SLR1;\n\t\tbreak;\n\tcase PCIC_IDENT_REV_I82365SLR2:\n\t\tvendor = PCIC_VENDOR_I82365SLR2;\n\t\tbreak;\n\tdefault:\n\t\tvendor = PCIC_VENDOR_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tpcic_write(h, 0x0e, -1);\n\tpcic_write(h, 0x37, -1);\n\n\treg = pcic_read(h, PCIC_VG468_MISC);\n\treg |= PCIC_VG468_MISC_VADEMREV;\n\tpcic_write(h, PCIC_VG468_MISC, reg);\n\n\treg = pcic_read(h, PCIC_IDENT);\n\n\tif (reg & PCIC_IDENT_VADEM_MASK) {\n\t\tif ((reg & 7) >= 4)\n\t\t\tvendor = PCIC_VENDOR_VADEM_VG469;\n\t\telse\n\t\t\tvendor = PCIC_VENDOR_VADEM_VG468;\n\n\t\treg = pcic_read(h, PCIC_VG468_MISC);\n\t\treg &= ~PCIC_VG468_MISC_VADEMREV;\n\t\tpcic_write(h, PCIC_VG468_MISC, reg);\n\t}\n\n\treturn (vendor);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tPCIC_VENDOR_VADEM_VG469\t\t7",
      "#define\tPCIC_VENDOR_VADEM_VG468\t\t6",
      "#define\tPCIC_VENDOR_CIRRUS_PD672X\t5",
      "#define\tPCIC_VENDOR_CIRRUS_PD6710\t4",
      "#define\tPCIC_VENDOR_I82365SLR2\t\t3",
      "#define\tPCIC_VENDOR_I82365SLR1\t\t2",
      "#define\tPCIC_VENDOR_I82365SLR0\t\t1",
      "#define\tPCIC_VENDOR_UNKNOWN\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcic_write",
          "args": [
            "h",
            "PCIC_VG468_MISC",
            "reg"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1453-1465",
          "snippet": "void\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tst_pcic_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tst_pcic_write;\n\nvoid\nst_pcic_write(h, idx, data)\n\tstruct pcic_handle *h;\n\tint idx;\n\tint data;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\tif (data != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA,\n\t\t    data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcic_read",
          "args": [
            "h",
            "PCIC_VG468_MISC"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "st_pcic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
          "lines": "1442-1451",
          "snippet": "u_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}",
          "includes": [
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t st_pcic_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nu_int8_t st_pcic_read;\n\nu_int8_t\nst_pcic_read(h, idx)\n\tstruct pcic_handle *h;\n\tint idx;\n{\n\tif (idx != -1)\n\t\tbus_space_write_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_INDEX,\n\t\t    h->sock + idx);\n\treturn bus_space_read_1(h->ph_bus_t, h->ph_bus_h, PCIC_REG_DATA);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tPCIC_VENDOR_VADEM_VG469\t\t7\n#define\tPCIC_VENDOR_VADEM_VG468\t\t6\n#define\tPCIC_VENDOR_CIRRUS_PD672X\t5\n#define\tPCIC_VENDOR_CIRRUS_PD6710\t4\n#define\tPCIC_VENDOR_I82365SLR2\t\t3\n#define\tPCIC_VENDOR_I82365SLR1\t\t2\n#define\tPCIC_VENDOR_I82365SLR0\t\t1\n#define\tPCIC_VENDOR_UNKNOWN\t\t0\n\nint\npcic_vendor(h)\n\tstruct pcic_handle *h;\n{\n\tint vendor, reg;\n\n\t/*\n\t * the chip_id of the cirrus toggles between 11 and 00 after a write.\n\t * weird.\n\t */\n\n\tpcic_write(h, PCIC_CIRRUS_CHIP_INFO, 0);\n\treg = pcic_read(h, -1);\n\n\tif ((reg & PCIC_CIRRUS_CHIP_INFO_CHIP_ID) ==\n\t    PCIC_CIRRUS_CHIP_INFO_CHIP_ID) {\n\t\treg = pcic_read(h, -1);\n\t\tif ((reg & PCIC_CIRRUS_CHIP_INFO_CHIP_ID) == 0) {\n\t\t\tif (reg & PCIC_CIRRUS_CHIP_INFO_SLOTS)\n\t\t\t\treturn (PCIC_VENDOR_CIRRUS_PD672X);\n\t\t\telse\n\t\t\t\treturn (PCIC_VENDOR_CIRRUS_PD6710);\n\t\t}\n\t}\n\n\treg = pcic_read(h, PCIC_IDENT);\n\n\tswitch (reg) {\n\tcase PCIC_IDENT_REV_I82365SLR0:\n\t\tvendor = PCIC_VENDOR_I82365SLR0;\n\t\tbreak;\n\tcase PCIC_IDENT_REV_I82365SLR1:\n\t\tvendor = PCIC_VENDOR_I82365SLR1;\n\t\tbreak;\n\tcase PCIC_IDENT_REV_I82365SLR2:\n\t\tvendor = PCIC_VENDOR_I82365SLR2;\n\t\tbreak;\n\tdefault:\n\t\tvendor = PCIC_VENDOR_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tpcic_write(h, 0x0e, -1);\n\tpcic_write(h, 0x37, -1);\n\n\treg = pcic_read(h, PCIC_VG468_MISC);\n\treg |= PCIC_VG468_MISC_VADEMREV;\n\tpcic_write(h, PCIC_VG468_MISC, reg);\n\n\treg = pcic_read(h, PCIC_IDENT);\n\n\tif (reg & PCIC_IDENT_VADEM_MASK) {\n\t\tif ((reg & 7) >= 4)\n\t\t\tvendor = PCIC_VENDOR_VADEM_VG469;\n\t\telse\n\t\t\tvendor = PCIC_VENDOR_VADEM_VG468;\n\n\t\treg = pcic_read(h, PCIC_VG468_MISC);\n\t\treg &= ~PCIC_VG468_MISC_VADEMREV;\n\t\tpcic_write(h, PCIC_VG468_MISC, reg);\n\t}\n\n\treturn (vendor);\n}"
  },
  {
    "function_name": "pcic_ident_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82365.c",
    "lines": "114-131",
    "snippet": "int\npcic_ident_ok(ident)\n\tint ident;\n{\n\t/* this is very empirical and heuristic */\n\n\tif (ident == 0 || ident == 0xff || (ident & PCIC_IDENT_ZERO))\n\t\treturn (0);\n\n\tif ((ident & PCIC_IDENT_IFTYPE_MASK) != PCIC_IDENT_IFTYPE_MEM_AND_IO) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"pcic: does not support memory and I/O cards, \"\n\t\t    \"ignored (ident=%0x)\\n\", ident);\n#endif\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/i82365var.h>",
      "#include <dev/ic/i82365reg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm.h>",
      "#include <sys/kthread.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/extent.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"pcic: does not support memory and I/O cards, \"\n\t\t    \"ignored (ident=%0x)\\n\"",
            "ident"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\npcic_ident_ok(ident)\n\tint ident;\n{\n\t/* this is very empirical and heuristic */\n\n\tif (ident == 0 || ident == 0xff || (ident & PCIC_IDENT_ZERO))\n\t\treturn (0);\n\n\tif ((ident & PCIC_IDENT_IFTYPE_MASK) != PCIC_IDENT_IFTYPE_MEM_AND_IO) {\n#ifdef DIAGNOSTIC\n\t\tprintf(\"pcic: does not support memory and I/O cards, \"\n\t\t    \"ignored (ident=%0x)\\n\", ident);\n#endif\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  }
]