[
  {
    "function_name": "dpt_hba_inquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "1360-1441",
    "snippet": "void\ndpt_hba_inquire(sc, ei)\n\tstruct dpt_softc *sc;\n\tstruct eata_inquiry_data **ei;\n{\n\tstruct dpt_ccb *ccb;\n\tstruct eata_cp *cp;\n\tbus_dma_tag_t dmat;\n\t\n\t*ei = (struct eata_inquiry_data *)sc->sc_scr;\n\tdmat = sc->sc_dmat;\n\n\t/* Get a CCB and mark as private */\n\tif ((ccb = dpt_alloc_ccb(sc, 0)) == NULL)\n\t\tpanic(\"%s: no CCB for inquiry\", sc->sc_dv.dv_xname);\n\t\n\tccb->ccb_flg |= CCB_PRIVATE;\n\tccb->ccb_timeout = 200;\n\n\t/* Put all the arguments into the CCB */\n\tcp = &ccb->ccb_eata_cp;\n\tcp->cp_ccbid = ccb->ccb_id;\n\tcp->cp_id = sc->sc_hbaid[0];\n\tcp->cp_lun = 0;\n\tcp->cp_channel = 0;\n\tcp->cp_senselen = sizeof(ccb->ccb_sense);\n\tcp->cp_stataddr = htobe32(sc->sc_sppa);\n\tcp->cp_dispri = 1;\n\tcp->cp_identify = 1;\n\tcp->cp_autosense = 0;\n\tcp->cp_interpret = 1;\n\tcp->cp_nocache = 0;\n\tcp->cp_datain = 1;\n\tcp->cp_dataout = 0;\n\tcp->cp_senseaddr = 0;\n\tcp->cp_dataaddr = htobe32(sc->sc_scrpa);\n\tcp->cp_datalen = htobe32(sizeof(struct eata_inquiry_data));\n\tcp->cp_scatter = 0;\n\t\n\t/* Put together the SCSI inquiry command */\n\tmemset(&cp->cp_scsi_cmd, 0, 12);\t/* XXX */\n\tcp->cp_scsi_cmd = INQUIRY;\n\tcp->cp_len = sizeof(struct eata_inquiry_data);\n\n\t/* Sync up CCB, status packet and scratch area */\n#ifdef __NetBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, CCB_OFF(sc, ccb), \n\t    sizeof(struct dpt_ccb), BUS_DMASYNC_PREWRITE);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff, \n\t    sizeof(struct eata_sp), BUS_DMASYNC_PREREAD);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_scroff, \n\t    sizeof(struct eata_inquiry_data), BUS_DMASYNC_PREREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREWRITE);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);\n#endif /* __OpenBSD__ */\n\n\t/* Start the command and poll on completion */\n\tif (dpt_cmd(sc, &ccb->ccb_eata_cp, ccb->ccb_ccbpa, CP_DMA_CMD, 0))\n\t\tpanic(\"%s: dpt_cmd failed\", sc->sc_dv.dv_xname);\n\n\tif (dpt_poll(sc, ccb))\n\t\tpanic(\"%s: inquiry timed out\", sc->sc_dv.dv_xname);\n\n\tif (ccb->ccb_hba_status != HA_NO_ERROR ||\n\t    ccb->ccb_scsi_status != SCSI_OK)\n\t    \tpanic(\"%s: inquiry failed (hba:%02x scsi:%02x\", \n\t    \t    sc->sc_dv.dv_xname, ccb->ccb_hba_status,\n\t    \t    ccb->ccb_scsi_status);\n\t\n\t/* Sync up the DMA map and free CCB, returning */\n#ifdef __NetBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_scroff, \n\t    sizeof(struct eata_inquiry_data), BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\tdpt_free_ccb(sc, ccb);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "struct dpt_ccb *ccb;",
      "int s;",
      "struct dpt_softc *sc;",
      "struct dpt_ccb *ccb;",
      "struct eata_cp *cp;",
      "bus_dma_tag_t dmat;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dpt_free_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "686-701",
          "snippet": "void\ndpt_free_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\tccb->ccb_flg = 0;\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_chain);\n\n\t/* Wake anybody waiting for a free ccb */\n\tif (ccb->ccb_chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct dpt_ccb *ccb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nvoid\ndpt_free_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\tccb->ccb_flg = 0;\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_chain);\n\n\t/* Wake anybody waiting for a free ccb */\n\tif (ccb->ccb_chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "BUS_DMASYNC_POSTREAD"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "sc->sc_scroff",
            "sizeof(struct eata_inquiry_data)",
            "BUS_DMASYNC_POSTREAD"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: inquiry failed (hba:%02x scsi:%02x\"",
            "sc->sc_dv.dv_xname",
            "ccb->ccb_hba_status",
            "ccb->ccb_scsi_status"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: inquiry timed out\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_poll",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "535-558",
          "snippet": "int\ndpt_poll(sc, ccb)\n        struct dpt_softc *sc;\n        struct dpt_ccb *ccb;\n{\n\tint i;\n\n#ifdef DEBUG\n\tif ((ccb->ccb_flg & CCB_PRIVATE) == 0)\n\t\tpanic(\"dpt_poll: called for non-CCB_PRIVATE request\\n\");\n#endif\n\n \tif ((ccb->ccb_flg & CCB_INTR) != 0)\n        \treturn (0);                \n\n        for (i = ccb->ccb_timeout * 20; i; i--) {\n                if ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) != 0)\n                \tdpt_intr(sc);\n                if ((ccb->ccb_flg & CCB_INTR) != 0)\n                \treturn (0);\n                DELAY(50);\n        }\n        return (-1);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "struct dpt_softc *sc;",
            "struct dpt_ccb *ccb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nint\ndpt_poll(sc, ccb)\n        struct dpt_softc *sc;\n        struct dpt_ccb *ccb;\n{\n\tint i;\n\n#ifdef DEBUG\n\tif ((ccb->ccb_flg & CCB_PRIVATE) == 0)\n\t\tpanic(\"dpt_poll: called for non-CCB_PRIVATE request\\n\");\n#endif\n\n \tif ((ccb->ccb_flg & CCB_INTR) != 0)\n        \treturn (0);                \n\n        for (i = ccb->ccb_timeout * 20; i; i--) {\n                if ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) != 0)\n                \tdpt_intr(sc);\n                if ((ccb->ccb_flg & CCB_INTR) != 0)\n                \treturn (0);\n                DELAY(50);\n        }\n        return (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: dpt_cmd failed\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_cmd",
          "args": [
            "sc",
            "&ccb->ccb_eata_cp",
            "ccb->ccb_ccbpa",
            "CP_DMA_CMD",
            "0"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "467-508",
          "snippet": "int\ndpt_cmd(sc, cp, addr, eatacmd, icmd)\n\tstruct dpt_softc *sc;\n\tstruct eata_cp *cp;\n\tu_int32_t addr;\n\tint eatacmd, icmd;\n{\n\tint i;\n\t\n\tfor (i = 20000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)\n\t\t\tbreak;\n\t\tDELAY(50);\n\t}\n\n\t/* Not the most graceful way to handle this */\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA timeout on EATA command issue; aborting\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (cp == NULL)\n\t\taddr = 0;\n\n\tdpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);\n\tdpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);\n\tdpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);\n\tdpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);\n\n\tif (eatacmd == CP_IMMEDIATE) {\n\t\tif (cp == NULL) {\n\t\t\t/* XXX should really pass meaningful values */\n\t\t\tdpt_outb(sc, HA_ICMD_CODE2, 0);\n\t\t\tdpt_outb(sc, HA_ICMD_CODE1, 0);\n\t\t}\n\t\tdpt_outb(sc, HA_ICMD, icmd);\n\t}\n\n        dpt_outb(sc, HA_COMMAND, eatacmd);\n        return (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct eata_cp *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nint s;\nstruct dpt_softc *sc;\nstruct eata_cp *cp;\n\nint\ndpt_cmd(sc, cp, addr, eatacmd, icmd)\n\tstruct dpt_softc *sc;\n\tstruct eata_cp *cp;\n\tu_int32_t addr;\n\tint eatacmd, icmd;\n{\n\tint i;\n\t\n\tfor (i = 20000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)\n\t\t\tbreak;\n\t\tDELAY(50);\n\t}\n\n\t/* Not the most graceful way to handle this */\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA timeout on EATA command issue; aborting\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (cp == NULL)\n\t\taddr = 0;\n\n\tdpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);\n\tdpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);\n\tdpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);\n\tdpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);\n\n\tif (eatacmd == CP_IMMEDIATE) {\n\t\tif (cp == NULL) {\n\t\t\t/* XXX should really pass meaningful values */\n\t\t\tdpt_outb(sc, HA_ICMD_CODE2, 0);\n\t\t\tdpt_outb(sc, HA_ICMD_CODE1, 0);\n\t\t}\n\t\tdpt_outb(sc, HA_ICMD, icmd);\n\t}\n\n        dpt_outb(sc, HA_COMMAND, eatacmd);\n        return (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "BUS_DMASYNC_PREREAD"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "BUS_DMASYNC_PREREAD"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "BUS_DMASYNC_PREWRITE"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "sc->sc_scroff",
            "sizeof(struct eata_inquiry_data)",
            "BUS_DMASYNC_PREREAD"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "sc->sc_spoff",
            "sizeof(struct eata_sp)",
            "BUS_DMASYNC_PREREAD"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "CCB_OFF(sc, ccb)",
            "sizeof(struct dpt_ccb)",
            "BUS_DMASYNC_PREWRITE"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCB_OFF",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cp->cp_scsi_cmd",
            "0",
            "12"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "sizeof(struct eata_inquiry_data)"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "sc->sc_scrpa"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htobe32",
          "args": [
            "sc->sc_sppa"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: no CCB for inquiry\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_alloc_ccb",
          "args": [
            "sc",
            "0"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nstruct eata_cp *cp;\nbus_dma_tag_t dmat;\n\nvoid\ndpt_hba_inquire(sc, ei)\n\tstruct dpt_softc *sc;\n\tstruct eata_inquiry_data **ei;\n{\n\tstruct dpt_ccb *ccb;\n\tstruct eata_cp *cp;\n\tbus_dma_tag_t dmat;\n\t\n\t*ei = (struct eata_inquiry_data *)sc->sc_scr;\n\tdmat = sc->sc_dmat;\n\n\t/* Get a CCB and mark as private */\n\tif ((ccb = dpt_alloc_ccb(sc, 0)) == NULL)\n\t\tpanic(\"%s: no CCB for inquiry\", sc->sc_dv.dv_xname);\n\t\n\tccb->ccb_flg |= CCB_PRIVATE;\n\tccb->ccb_timeout = 200;\n\n\t/* Put all the arguments into the CCB */\n\tcp = &ccb->ccb_eata_cp;\n\tcp->cp_ccbid = ccb->ccb_id;\n\tcp->cp_id = sc->sc_hbaid[0];\n\tcp->cp_lun = 0;\n\tcp->cp_channel = 0;\n\tcp->cp_senselen = sizeof(ccb->ccb_sense);\n\tcp->cp_stataddr = htobe32(sc->sc_sppa);\n\tcp->cp_dispri = 1;\n\tcp->cp_identify = 1;\n\tcp->cp_autosense = 0;\n\tcp->cp_interpret = 1;\n\tcp->cp_nocache = 0;\n\tcp->cp_datain = 1;\n\tcp->cp_dataout = 0;\n\tcp->cp_senseaddr = 0;\n\tcp->cp_dataaddr = htobe32(sc->sc_scrpa);\n\tcp->cp_datalen = htobe32(sizeof(struct eata_inquiry_data));\n\tcp->cp_scatter = 0;\n\t\n\t/* Put together the SCSI inquiry command */\n\tmemset(&cp->cp_scsi_cmd, 0, 12);\t/* XXX */\n\tcp->cp_scsi_cmd = INQUIRY;\n\tcp->cp_len = sizeof(struct eata_inquiry_data);\n\n\t/* Sync up CCB, status packet and scratch area */\n#ifdef __NetBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, CCB_OFF(sc, ccb), \n\t    sizeof(struct dpt_ccb), BUS_DMASYNC_PREWRITE);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff, \n\t    sizeof(struct eata_sp), BUS_DMASYNC_PREREAD);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_scroff, \n\t    sizeof(struct eata_inquiry_data), BUS_DMASYNC_PREREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREWRITE);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);\n#endif /* __OpenBSD__ */\n\n\t/* Start the command and poll on completion */\n\tif (dpt_cmd(sc, &ccb->ccb_eata_cp, ccb->ccb_ccbpa, CP_DMA_CMD, 0))\n\t\tpanic(\"%s: dpt_cmd failed\", sc->sc_dv.dv_xname);\n\n\tif (dpt_poll(sc, ccb))\n\t\tpanic(\"%s: inquiry timed out\", sc->sc_dv.dv_xname);\n\n\tif (ccb->ccb_hba_status != HA_NO_ERROR ||\n\t    ccb->ccb_scsi_status != SCSI_OK)\n\t    \tpanic(\"%s: inquiry failed (hba:%02x scsi:%02x\", \n\t    \t    sc->sc_dv.dv_xname, ccb->ccb_hba_status,\n\t    \t    ccb->ccb_scsi_status);\n\t\n\t/* Sync up the DMA map and free CCB, returning */\n#ifdef __NetBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_scroff, \n\t    sizeof(struct eata_inquiry_data), BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\tdpt_free_ccb(sc, ccb);\n}"
  },
  {
    "function_name": "dpt_dump_sp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "1335-1354",
    "snippet": "void\ndpt_dump_sp(sp)\n\tstruct eata_sp *sp;\n{\n\tint i;\n\t\n\tprintf(\"\\thba_status\\t%02x\\n\", sp->sp_hba_status);\n\tprintf(\"\\tscsi_status\\t%02x\\n\", sp->sp_scsi_status);\t\n\tprintf(\"\\tinv_residue\\t%d\\n\", sp->sp_inv_residue);\t\n\tprintf(\"\\tccbid\\t\\t%d\\n\", sp->sp_ccbid);\n\tprintf(\"\\tid_message\\t%d\\n\", sp->sp_id_message);\n\tprintf(\"\\tque_message\\t%d\\n\", sp->sp_que_message);\t\n\tprintf(\"\\ttag_message\\t%d\\n\", sp->sp_tag_message);\n\tprintf(\"\\tmessages\\t\");\n\t\n\tfor (i = 0; i < 9; i++)\n\t\tprintf(\"%d \", sp->sp_messages[i]);\n\t\t\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\ndpt_dump_sp(sp)\n\tstruct eata_sp *sp;\n{\n\tint i;\n\t\n\tprintf(\"\\thba_status\\t%02x\\n\", sp->sp_hba_status);\n\tprintf(\"\\tscsi_status\\t%02x\\n\", sp->sp_scsi_status);\t\n\tprintf(\"\\tinv_residue\\t%d\\n\", sp->sp_inv_residue);\t\n\tprintf(\"\\tccbid\\t\\t%d\\n\", sp->sp_ccbid);\n\tprintf(\"\\tid_message\\t%d\\n\", sp->sp_id_message);\n\tprintf(\"\\tque_message\\t%d\\n\", sp->sp_que_message);\t\n\tprintf(\"\\ttag_message\\t%d\\n\", sp->sp_tag_message);\n\tprintf(\"\\tmessages\\t\");\n\t\n\tfor (i = 0; i < 9; i++)\n\t\tprintf(\"%d \", sp->sp_messages[i]);\n\t\t\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "dpt_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "1279-1329",
    "snippet": "void\ndpt_timeout(arg)\n\tvoid *arg;\n{\n#ifdef __NetBSD__\n\tstruct scsipi_link *sc_link;\n\tstruct scsipi_xfer *xs;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tstruct scsi_link *sc_link;\n\tstruct scsi_xfer *xs;\n#endif /* __OpenBSD__ */\n\tstruct dpt_softc *sc;\n \tstruct dpt_ccb *ccb;\n\tint s;\n\t\n\tccb = arg;\n\txs = ccb->ccb_xs;\n\tsc_link = xs->sc_link;\n\tsc  = sc_link->adapter_softc;\n\n#ifdef __NetBSD__\n\tscsi_print_addr(sc_link);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tsc_print_addr(sc_link);\n#endif /* __OpenBSD__ */\n\tprintf(\"timed out (status:%02x aux status:%02x)\", \n\t    dpt_inb(sc, HA_STATUS), dpt_inb(sc, HA_AUX_STATUS));\n\n\ts = splbio();\n\n\tif ((ccb->ccb_flg & CCB_ABORT) != 0) {\n\t\t/* Abort timed out, reset the HBA */\n\t\tprintf(\" AGAIN, resetting HBA\\n\");\n\t\tdpt_outb(sc, HA_COMMAND, CP_RESET);\n\t\tDELAY(750000);\n\t} else {\n\t\t/* Abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->ccb_xs->error = XS_TIMEOUT;\n\t\tccb->ccb_timeout = DPT_ABORT_TIMEOUT;\n\t\tccb->ccb_flg |= CCB_ABORT;\n\t\t/* Start the abort */\n\t\tif (dpt_cmd(sc, &ccb->ccb_eata_cp, ccb->ccb_ccbpa, \n\t\t    CP_IMMEDIATE, CPI_SPEC_ABORT))\n\t\t    printf(\"%s: dpt_cmd failed\\n\", sc->sc_dv.dv_xname);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "struct dpt_ccb *ccb;",
      "int s;",
      "struct dpt_softc *sc;",
      "struct dpt_ccb *ccb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: dpt_cmd failed\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpt_cmd",
          "args": [
            "sc",
            "&ccb->ccb_eata_cp",
            "ccb->ccb_ccbpa",
            "CP_IMMEDIATE",
            "CPI_SPEC_ABORT"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "467-508",
          "snippet": "int\ndpt_cmd(sc, cp, addr, eatacmd, icmd)\n\tstruct dpt_softc *sc;\n\tstruct eata_cp *cp;\n\tu_int32_t addr;\n\tint eatacmd, icmd;\n{\n\tint i;\n\t\n\tfor (i = 20000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)\n\t\t\tbreak;\n\t\tDELAY(50);\n\t}\n\n\t/* Not the most graceful way to handle this */\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA timeout on EATA command issue; aborting\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (cp == NULL)\n\t\taddr = 0;\n\n\tdpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);\n\tdpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);\n\tdpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);\n\tdpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);\n\n\tif (eatacmd == CP_IMMEDIATE) {\n\t\tif (cp == NULL) {\n\t\t\t/* XXX should really pass meaningful values */\n\t\t\tdpt_outb(sc, HA_ICMD_CODE2, 0);\n\t\t\tdpt_outb(sc, HA_ICMD_CODE1, 0);\n\t\t}\n\t\tdpt_outb(sc, HA_ICMD, icmd);\n\t}\n\n        dpt_outb(sc, HA_COMMAND, eatacmd);\n        return (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct eata_cp *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nint s;\nstruct dpt_softc *sc;\nstruct eata_cp *cp;\n\nint\ndpt_cmd(sc, cp, addr, eatacmd, icmd)\n\tstruct dpt_softc *sc;\n\tstruct eata_cp *cp;\n\tu_int32_t addr;\n\tint eatacmd, icmd;\n{\n\tint i;\n\t\n\tfor (i = 20000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)\n\t\t\tbreak;\n\t\tDELAY(50);\n\t}\n\n\t/* Not the most graceful way to handle this */\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA timeout on EATA command issue; aborting\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (cp == NULL)\n\t\taddr = 0;\n\n\tdpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);\n\tdpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);\n\tdpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);\n\tdpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);\n\n\tif (eatacmd == CP_IMMEDIATE) {\n\t\tif (cp == NULL) {\n\t\t\t/* XXX should really pass meaningful values */\n\t\t\tdpt_outb(sc, HA_ICMD_CODE2, 0);\n\t\t\tdpt_outb(sc, HA_ICMD_CODE1, 0);\n\t\t}\n\t\tdpt_outb(sc, HA_ICMD, icmd);\n\t}\n\n        dpt_outb(sc, HA_COMMAND, eatacmd);\n        return (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "750000"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_COMMAND",
            "CP_RESET"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_AUX_STATUS"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nvoid\ndpt_timeout(arg)\n\tvoid *arg;\n{\n#ifdef __NetBSD__\n\tstruct scsipi_link *sc_link;\n\tstruct scsipi_xfer *xs;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tstruct scsi_link *sc_link;\n\tstruct scsi_xfer *xs;\n#endif /* __OpenBSD__ */\n\tstruct dpt_softc *sc;\n \tstruct dpt_ccb *ccb;\n\tint s;\n\t\n\tccb = arg;\n\txs = ccb->ccb_xs;\n\tsc_link = xs->sc_link;\n\tsc  = sc_link->adapter_softc;\n\n#ifdef __NetBSD__\n\tscsi_print_addr(sc_link);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tsc_print_addr(sc_link);\n#endif /* __OpenBSD__ */\n\tprintf(\"timed out (status:%02x aux status:%02x)\", \n\t    dpt_inb(sc, HA_STATUS), dpt_inb(sc, HA_AUX_STATUS));\n\n\ts = splbio();\n\n\tif ((ccb->ccb_flg & CCB_ABORT) != 0) {\n\t\t/* Abort timed out, reset the HBA */\n\t\tprintf(\" AGAIN, resetting HBA\\n\");\n\t\tdpt_outb(sc, HA_COMMAND, CP_RESET);\n\t\tDELAY(750000);\n\t} else {\n\t\t/* Abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->ccb_xs->error = XS_TIMEOUT;\n\t\tccb->ccb_timeout = DPT_ABORT_TIMEOUT;\n\t\tccb->ccb_flg |= CCB_ABORT;\n\t\t/* Start the abort */\n\t\tif (dpt_cmd(sc, &ccb->ccb_eata_cp, ccb->ccb_ccbpa, \n\t\t    CP_IMMEDIATE, CPI_SPEC_ABORT))\n\t\t    printf(\"%s: dpt_cmd failed\\n\", sc->sc_dv.dv_xname);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "dpt_enqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "923-938",
    "snippet": "static void\ndpt_enqueue(sc, xs, infront)\n\tstruct dpt_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint             infront;\n{\n\n\tif (infront || sc->sc_queue.lh_first == NULL) {\n\t\tif (sc->sc_queue.lh_first == NULL)\n\t\t\tsc->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);\n\tsc->sc_queuelast = xs;\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "struct dpt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LIST_INSERT_AFTER",
          "args": [
            "sc->sc_queuelast",
            "xs",
            "free_list"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&sc->sc_queue",
            "xs",
            "free_list"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_softc *sc;\n\nstatic void\ndpt_enqueue(sc, xs, infront)\n\tstruct dpt_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint             infront;\n{\n\n\tif (infront || sc->sc_queue.lh_first == NULL) {\n\t\tif (sc->sc_queue.lh_first == NULL)\n\t\t\tsc->sc_queuelast = xs;\n\t\tLIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);\n\t\treturn;\n\t}\n\tLIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);\n\tsc->sc_queuelast = xs;\n}"
  },
  {
    "function_name": "dpt_done_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "800-915",
    "snippet": "void\ndpt_done_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n#ifdef __NetBSD__\n\tstruct scsipi_sense_data *s1, *s2;\n\tstruct scsipi_xfer *xs;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs;\n#endif /* __OpenBSD__ */\n\tbus_dma_tag_t dmat;\n\t\n\tdmat = sc->sc_dmat;\n\txs = ccb->ccb_xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"dpt_done_ccb\\n\"));\n\n\t/*\n\t * If we were a data transfer, unload the map that described the \n\t * data buffer.\n\t */\n\tif (xs->datalen) {\n#ifdef __NetBSD__\n\t\tbus_dmamap_sync(dmat, ccb->ccb_dmamap_xfer, 0,\n\t\t    ccb->ccb_dmamap_xfer->dm_mapsize,\n\t\t    (xs->xs_control & XS_CTL_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tbus_dmamap_sync(dmat, ccb->ccb_dmamap_xfer,\n\t\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __OpenBSD__ */\n\t\tbus_dmamap_unload(dmat, ccb->ccb_dmamap_xfer);\n\t}\n\n\t/*\n\t * Otherwise, put the results of the operation into the xfer and \n\t * call whoever started it.\n\t */\n#ifdef DIAGNOSTIC\n\tif ((ccb->ccb_flg & CCB_ALLOC) == 0) {\n\t\tpanic(\"%s: done ccb not allocated!\\n\", sc->sc_dv.dv_xname);\n\t\treturn;\n\t}\n#endif\n\t\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->ccb_hba_status != HA_NO_ERROR) {\n\t\t\tswitch (ccb->ccb_hba_status) {\n\t\t\tcase HA_ERROR_SEL_TO:\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tcase HA_ERROR_RESET:\n\t\t\t\txs->error = XS_RESET;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: HBA status %x\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, ccb->ccb_hba_status);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (ccb->ccb_scsi_status != SCSI_OK) {\n\t\t\tswitch (ccb->ccb_scsi_status) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ccb->ccb_sense;\n#ifdef __NetBSD__\n\t\t\t\ts2 = &xs->sense.scsi_sense;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\t\ts2 = &xs->sense;\n#endif /* __OpenBSD__ */\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: SCSI status %x\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, ccb->ccb_scsi_status);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t\t\t\n\t\txs->status = ccb->ccb_scsi_status;\n\t}\n\n\t/* Free up the CCB and mark the command as done */\n\tdpt_free_ccb(sc, ccb);\n#ifdef __NetBSD__\n\txs->xs_status |= XS_STS_DONE;\n\tscsipi_done(xs);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n#endif /* __OpenBSD__ */\n\n\t/*\n\t * If there are entries in the software queue, try to run the first\n\t * one. We should be more or less guaranteed to succeed, since we\n\t * just freed an CCB. NOTE: dpt_scsi_cmd() relies on our calling it\n\t * with the first entry in the queue.\n\t */\n#ifdef __NetBSD__\n\tif ((xs = TAILQ_FIRST(&sc->sc_queue)) != NULL)\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tif ((xs = sc->sc_queue.lh_first) != NULL)\n#endif /* __OpenBSD__ */\n\t\tdpt_scsi_cmd(xs);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "struct dpt_ccb *ccb;",
      "int s;",
      "struct dpt_softc *sc;",
      "struct dpt_ccb *ccb;",
      "bus_dma_tag_t dmat;",
      "bus_dmamap_t xfer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dpt_scsi_cmd",
          "args": [
            "xs"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&sc->sc_queue"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scsipi_done",
          "args": [
            "xs"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_free_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "686-701",
          "snippet": "void\ndpt_free_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\tccb->ccb_flg = 0;\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_chain);\n\n\t/* Wake anybody waiting for a free ccb */\n\tif (ccb->ccb_chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct dpt_ccb *ccb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nvoid\ndpt_free_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\tccb->ccb_flg = 0;\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_chain);\n\n\t/* Wake anybody waiting for a free ccb */\n\tif (ccb->ccb_chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: SCSI status %x\\n\"",
            "sc->sc_dv.dv_xname",
            "ccb->ccb_scsi_status"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: done ccb not allocated!\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "dmat",
            "ccb->ccb_dmamap_xfer"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "dmat",
            "ccb->ccb_dmamap_xfer",
            "(xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t    BUS_DMASYNC_POSTWRITE"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "dmat",
            "ccb->ccb_dmamap_xfer",
            "0",
            "ccb->ccb_dmamap_xfer->dm_mapsize",
            "(xs->xs_control & XS_CTL_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t    BUS_DMASYNC_POSTWRITE"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "xs->sc_link",
            "SDEV_DB2",
            "(\"dpt_done_ccb\\n\")"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nbus_dma_tag_t dmat;\nbus_dmamap_t xfer;\n\nvoid\ndpt_done_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n#ifdef __NetBSD__\n\tstruct scsipi_sense_data *s1, *s2;\n\tstruct scsipi_xfer *xs;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs;\n#endif /* __OpenBSD__ */\n\tbus_dma_tag_t dmat;\n\t\n\tdmat = sc->sc_dmat;\n\txs = ccb->ccb_xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"dpt_done_ccb\\n\"));\n\n\t/*\n\t * If we were a data transfer, unload the map that described the \n\t * data buffer.\n\t */\n\tif (xs->datalen) {\n#ifdef __NetBSD__\n\t\tbus_dmamap_sync(dmat, ccb->ccb_dmamap_xfer, 0,\n\t\t    ccb->ccb_dmamap_xfer->dm_mapsize,\n\t\t    (xs->xs_control & XS_CTL_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tbus_dmamap_sync(dmat, ccb->ccb_dmamap_xfer,\n\t\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __OpenBSD__ */\n\t\tbus_dmamap_unload(dmat, ccb->ccb_dmamap_xfer);\n\t}\n\n\t/*\n\t * Otherwise, put the results of the operation into the xfer and \n\t * call whoever started it.\n\t */\n#ifdef DIAGNOSTIC\n\tif ((ccb->ccb_flg & CCB_ALLOC) == 0) {\n\t\tpanic(\"%s: done ccb not allocated!\\n\", sc->sc_dv.dv_xname);\n\t\treturn;\n\t}\n#endif\n\t\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->ccb_hba_status != HA_NO_ERROR) {\n\t\t\tswitch (ccb->ccb_hba_status) {\n\t\t\tcase HA_ERROR_SEL_TO:\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tcase HA_ERROR_RESET:\n\t\t\t\txs->error = XS_RESET;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: HBA status %x\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, ccb->ccb_hba_status);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (ccb->ccb_scsi_status != SCSI_OK) {\n\t\t\tswitch (ccb->ccb_scsi_status) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ccb->ccb_sense;\n#ifdef __NetBSD__\n\t\t\t\ts2 = &xs->sense.scsi_sense;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\t\ts2 = &xs->sense;\n#endif /* __OpenBSD__ */\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: SCSI status %x\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, ccb->ccb_scsi_status);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t\t\t\n\t\txs->status = ccb->ccb_scsi_status;\n\t}\n\n\t/* Free up the CCB and mark the command as done */\n\tdpt_free_ccb(sc, ccb);\n#ifdef __NetBSD__\n\txs->xs_status |= XS_STS_DONE;\n\tscsipi_done(xs);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n#endif /* __OpenBSD__ */\n\n\t/*\n\t * If there are entries in the software queue, try to run the first\n\t * one. We should be more or less guaranteed to succeed, since we\n\t * just freed an CCB. NOTE: dpt_scsi_cmd() relies on our calling it\n\t * with the first entry in the queue.\n\t */\n#ifdef __NetBSD__\n\tif ((xs = TAILQ_FIRST(&sc->sc_queue)) != NULL)\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tif ((xs = sc->sc_queue.lh_first) != NULL)\n#endif /* __OpenBSD__ */\n\t\tdpt_scsi_cmd(xs);\n}"
  },
  {
    "function_name": "dpt_create_ccbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "733-755",
    "snippet": "int\ndpt_create_ccbs(sc, ccbstore, count)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccbstore;\n\tint count;\n{\n\tstruct dpt_ccb *ccb;\n\tint i, error;\n\n\tmemset(ccbstore, 0, sizeof(struct dpt_ccb) * count);\n\t\n\tfor (i = 0, ccb = ccbstore; i < count; i++, ccb++) {\n\t\tif ((error = dpt_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to init ccb, error = %d\\n\",\n\t\t\t    sc->sc_dv.dv_xname, error);\n\t\t\tbreak;\n\t\t}\n\t\tccb->ccb_id = i;\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_chain);\n\t}\n\n\treturn (i);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "struct dpt_ccb *ccb;",
      "int s;",
      "struct dpt_softc *sc;",
      "struct dpt_ccb *ccb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->sc_free_ccb",
            "ccb",
            "ccb_chain"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unable to init ccb, error = %d\\n\"",
            "sc->sc_dv.dv_xname",
            "error"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpt_init_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_init_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "706-728",
          "snippet": "int\ndpt_init_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint error;\n\t\n\t/* Create the DMA map for this CCB's data */\n\terror = bus_dmamap_create(sc->sc_dmat, DPT_MAX_XFER, DPT_SG_SIZE, \n\t    DPT_MAX_XFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &ccb->ccb_dmamap_xfer);\n\t\n\tif (error) {\n\t\tprintf(\"%s: can't create ccb dmamap (%d)\\n\", \n\t\t   sc->sc_dv.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tccb->ccb_flg = 0;\n\tccb->ccb_ccbpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr +\n\t    CCB_OFF(sc, ccb);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct dpt_ccb *ccb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nint\ndpt_init_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint error;\n\t\n\t/* Create the DMA map for this CCB's data */\n\terror = bus_dmamap_create(sc->sc_dmat, DPT_MAX_XFER, DPT_SG_SIZE, \n\t    DPT_MAX_XFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &ccb->ccb_dmamap_xfer);\n\t\n\tif (error) {\n\t\tprintf(\"%s: can't create ccb dmamap (%d)\\n\", \n\t\t   sc->sc_dv.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tccb->ccb_flg = 0;\n\tccb->ccb_ccbpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr +\n\t    CCB_OFF(sc, ccb);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ccbstore",
            "0",
            "sizeof(struct dpt_ccb) * count"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nint\ndpt_create_ccbs(sc, ccbstore, count)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccbstore;\n\tint count;\n{\n\tstruct dpt_ccb *ccb;\n\tint i, error;\n\n\tmemset(ccbstore, 0, sizeof(struct dpt_ccb) * count);\n\t\n\tfor (i = 0, ccb = ccbstore; i < count; i++, ccb++) {\n\t\tif ((error = dpt_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to init ccb, error = %d\\n\",\n\t\t\t    sc->sc_dv.dv_xname, error);\n\t\t\tbreak;\n\t\t}\n\t\tccb->ccb_id = i;\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_chain);\n\t}\n\n\treturn (i);\n}"
  },
  {
    "function_name": "dpt_init_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "706-728",
    "snippet": "int\ndpt_init_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint error;\n\t\n\t/* Create the DMA map for this CCB's data */\n\terror = bus_dmamap_create(sc->sc_dmat, DPT_MAX_XFER, DPT_SG_SIZE, \n\t    DPT_MAX_XFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &ccb->ccb_dmamap_xfer);\n\t\n\tif (error) {\n\t\tprintf(\"%s: can't create ccb dmamap (%d)\\n\", \n\t\t   sc->sc_dv.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tccb->ccb_flg = 0;\n\tccb->ccb_ccbpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr +\n\t    CCB_OFF(sc, ccb);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "struct dpt_ccb *ccb;",
      "int s;",
      "struct dpt_softc *sc;",
      "struct dpt_ccb *ccb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CCB_OFF",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't create ccb dmamap (%d)\\n\"",
            "sc->sc_dv.dv_xname",
            "error"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "DPT_MAX_XFER",
            "DPT_SG_SIZE",
            "DPT_MAX_XFER",
            "0",
            "BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW",
            "&ccb->ccb_dmamap_xfer"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nint\ndpt_init_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint error;\n\t\n\t/* Create the DMA map for this CCB's data */\n\terror = bus_dmamap_create(sc->sc_dmat, DPT_MAX_XFER, DPT_SG_SIZE, \n\t    DPT_MAX_XFER, 0, BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW,\n\t    &ccb->ccb_dmamap_xfer);\n\t\n\tif (error) {\n\t\tprintf(\"%s: can't create ccb dmamap (%d)\\n\", \n\t\t   sc->sc_dv.dv_xname, error);\n\t\treturn (error);\n\t}\n\n\tccb->ccb_flg = 0;\n\tccb->ccb_ccbpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr +\n\t    CCB_OFF(sc, ccb);\n\treturn (0);\n}"
  },
  {
    "function_name": "dpt_free_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "686-701",
    "snippet": "void\ndpt_free_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\tccb->ccb_flg = 0;\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_chain);\n\n\t/* Wake anybody waiting for a free ccb */\n\tif (ccb->ccb_chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "struct dpt_ccb *ccb;",
      "int s;",
      "struct dpt_softc *sc;",
      "struct dpt_ccb *ccb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->sc_free_ccb"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->sc_free_ccb",
            "ccb",
            "ccb_chain"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nvoid\ndpt_free_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\tccb->ccb_flg = 0;\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, ccb_chain);\n\n\t/* Wake anybody waiting for a free ccb */\n\tif (ccb->ccb_chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\tsplx(s);\n}"
  },
  {
    "function_name": "dpt_minphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "673-681",
    "snippet": "void\ndpt_minphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > DPT_MAX_XFER)\n\t\tbp->b_bcount = DPT_MAX_XFER;\n\tminphys(bp);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "673-681",
          "snippet": "void\ndpt_minphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > DPT_MAX_XFER)\n\t\tbp->b_bcount = DPT_MAX_XFER;\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\ndpt_minphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > DPT_MAX_XFER)\n\t\tbp->b_bcount = DPT_MAX_XFER;\n\tminphys(bp);\n}"
  },
  {
    "function_name": "dpt_readcfg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "563-668",
    "snippet": "int\ndpt_readcfg(sc)\n\tstruct dpt_softc *sc;\n{\n\tstruct eata_cfg *ec;\n\tint i, j, stat;\n\tu_int16_t *p;\n\n\tec = &sc->sc_ec;\n\n\t/* Older firmware may puke if we talk to it too soon after reset */\n\tdpt_outb(sc, HA_COMMAND, CP_RESET);\n        DELAY(750000);\n\n\tfor (i = 1000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_STATUS) & HA_ST_READY) != 0)\n\t\t\tbreak;\n\t\tDELAY(2000);\n\t}\n\t\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA not ready after reset: %02x\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n\t\treturn (-1);\n\t}\n\n\twhile((((stat = dpt_inb(sc, HA_STATUS))\n            != (HA_ST_READY|HA_ST_SEEK_COMPLETE))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR|HA_ST_DRQ)))\n            || (dpt_wait(sc, HA_ST_BUSY, 0, 2000))) {\n        \t/* RAID drives still spinning up? */\n                if((dpt_inb(sc, HA_ERROR) != 'D')\n                    || (dpt_inb(sc, HA_ERROR + 1) != 'P')\n                    || (dpt_inb(sc, HA_ERROR + 2) != 'T')) {\n                    \tprintf(\"%s: HBA not ready\\n\", sc->sc_dv.dv_xname);\n                        return (-1);\n\t\t}\n        }\n\n\t/* \n\t * Issue the read-config command and wait for the data to appear.\n\t * XXX we shouldn't be doing this with PIO, but it makes it a lot\n\t * easier as no DMA setup is required.\n\t */\n\tdpt_outb(sc, HA_COMMAND, CP_PIO_GETCFG);\n\tmemset(ec, 0, sizeof(*ec));\n\ti = ((int)&((struct eata_cfg *)0)->ec_cfglen + \n\t    sizeof(ec->ec_cfglen)) >> 1;\n\tp = (u_int16_t *)ec;\n\t\n\tif (dpt_wait(sc, 0xFF, HA_ST_DATA_RDY, 2000)) {\n\t\tprintf(\"%s: cfg data didn't appear (status:%02x)\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n  \t\treturn (-1);\n  \t}\n\n\t/* Begin reading */\n \twhile (i--)\n\t\t*p++ = dpt_inw(sc, HA_DATA);\n\n        if ((i = ec->ec_cfglen) > (sizeof(struct eata_cfg)\n            - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n            - sizeof(ec->ec_cfglen)))\n                i = sizeof(struct eata_cfg)\n                  - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n                  - sizeof(ec->ec_cfglen);\n\n        j = i + (int)(&(((struct eata_cfg *)0L)->ec_cfglen)) + \n            sizeof(ec->ec_cfglen);\n        i >>= 1;\n\n\twhile (i--)\n                *p++ = dpt_inw(sc, HA_DATA);\n        \n        /* Flush until we have read 512 bytes. */\n        i = (512 - j + 1) >> 1;\n\twhile (i--)\n \t\tdpt_inw(sc, HA_DATA);\n        \n        /* Defaults for older Firmware */\n\tif (p <= (u_short *)&ec->ec_hba[DPT_MAX_CHANNELS - 1])\n\t\tec->ec_hba[DPT_MAX_CHANNELS - 1] = 7;\n\n        if ((dpt_inb(sc, HA_STATUS) & HA_ST_ERROR) != 0) {\n        \tprintf(\"%s: HBA error\\n\", sc->sc_dv.dv_xname);\n        \treturn (-1);\n        }\n        \n        if (!ec->ec_hbavalid) {\n                printf(\"%s: ec_hba field invalid\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (memcmp(ec->ec_eatasig, \"EATA\", 4) != 0) {\n\t        printf(\"%s: EATA signature mismatch\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (!ec->ec_dmasupported) {\n\t        printf(\"%s: DMA not supported\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "int s;",
      "struct dpt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: DMA not supported\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ec->ec_eatasig",
            "\"EATA\"",
            "4"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inw",
          "args": [
            "sc",
            "HA_DATA"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inw",
          "args": [
            "sc",
            "HA_DATA"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inw",
          "args": [
            "sc",
            "HA_DATA"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_wait",
          "args": [
            "sc",
            "0xFF",
            "HA_ST_DATA_RDY",
            "2000"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "513-526",
          "snippet": "int\ndpt_wait(sc, mask, state, ms)\n        struct dpt_softc *sc;\n        u_int8_t mask, state;\n        int ms;\n{\n     \n        for (ms *= 10; ms; ms--) {\n                if ((dpt_inb(sc, HA_STATUS) & mask) == state)\n                \treturn (0);\n                DELAY(100);\n        }\n        return (-1);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_softc *sc;\n\nint\ndpt_wait(sc, mask, state, ms)\n        struct dpt_softc *sc;\n        u_int8_t mask, state;\n        int ms;\n{\n     \n        for (ms *= 10; ms; ms--) {\n                if ((dpt_inb(sc, HA_STATUS) & mask) == state)\n                \treturn (0);\n                DELAY(100);\n        }\n        return (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ec",
            "0",
            "sizeof(*ec)"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_COMMAND",
            "CP_PIO_GETCFG"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_ERROR + 2"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_ERROR + 1"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_ERROR"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "2000"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "750000"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_COMMAND",
            "CP_RESET"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nint s;\nstruct dpt_softc *sc;\n\nint\ndpt_readcfg(sc)\n\tstruct dpt_softc *sc;\n{\n\tstruct eata_cfg *ec;\n\tint i, j, stat;\n\tu_int16_t *p;\n\n\tec = &sc->sc_ec;\n\n\t/* Older firmware may puke if we talk to it too soon after reset */\n\tdpt_outb(sc, HA_COMMAND, CP_RESET);\n        DELAY(750000);\n\n\tfor (i = 1000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_STATUS) & HA_ST_READY) != 0)\n\t\t\tbreak;\n\t\tDELAY(2000);\n\t}\n\t\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA not ready after reset: %02x\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n\t\treturn (-1);\n\t}\n\n\twhile((((stat = dpt_inb(sc, HA_STATUS))\n            != (HA_ST_READY|HA_ST_SEEK_COMPLETE))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR))\n            && (stat != (HA_ST_READY|HA_ST_SEEK_COMPLETE|HA_ST_ERROR|HA_ST_DRQ)))\n            || (dpt_wait(sc, HA_ST_BUSY, 0, 2000))) {\n        \t/* RAID drives still spinning up? */\n                if((dpt_inb(sc, HA_ERROR) != 'D')\n                    || (dpt_inb(sc, HA_ERROR + 1) != 'P')\n                    || (dpt_inb(sc, HA_ERROR + 2) != 'T')) {\n                    \tprintf(\"%s: HBA not ready\\n\", sc->sc_dv.dv_xname);\n                        return (-1);\n\t\t}\n        }\n\n\t/* \n\t * Issue the read-config command and wait for the data to appear.\n\t * XXX we shouldn't be doing this with PIO, but it makes it a lot\n\t * easier as no DMA setup is required.\n\t */\n\tdpt_outb(sc, HA_COMMAND, CP_PIO_GETCFG);\n\tmemset(ec, 0, sizeof(*ec));\n\ti = ((int)&((struct eata_cfg *)0)->ec_cfglen + \n\t    sizeof(ec->ec_cfglen)) >> 1;\n\tp = (u_int16_t *)ec;\n\t\n\tif (dpt_wait(sc, 0xFF, HA_ST_DATA_RDY, 2000)) {\n\t\tprintf(\"%s: cfg data didn't appear (status:%02x)\\n\", \n\t\t    sc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS));\n  \t\treturn (-1);\n  \t}\n\n\t/* Begin reading */\n \twhile (i--)\n\t\t*p++ = dpt_inw(sc, HA_DATA);\n\n        if ((i = ec->ec_cfglen) > (sizeof(struct eata_cfg)\n            - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n            - sizeof(ec->ec_cfglen)))\n                i = sizeof(struct eata_cfg)\n                  - (int)(&(((struct eata_cfg *)0L)->ec_cfglen))\n                  - sizeof(ec->ec_cfglen);\n\n        j = i + (int)(&(((struct eata_cfg *)0L)->ec_cfglen)) + \n            sizeof(ec->ec_cfglen);\n        i >>= 1;\n\n\twhile (i--)\n                *p++ = dpt_inw(sc, HA_DATA);\n        \n        /* Flush until we have read 512 bytes. */\n        i = (512 - j + 1) >> 1;\n\twhile (i--)\n \t\tdpt_inw(sc, HA_DATA);\n        \n        /* Defaults for older Firmware */\n\tif (p <= (u_short *)&ec->ec_hba[DPT_MAX_CHANNELS - 1])\n\t\tec->ec_hba[DPT_MAX_CHANNELS - 1] = 7;\n\n        if ((dpt_inb(sc, HA_STATUS) & HA_ST_ERROR) != 0) {\n        \tprintf(\"%s: HBA error\\n\", sc->sc_dv.dv_xname);\n        \treturn (-1);\n        }\n        \n        if (!ec->ec_hbavalid) {\n                printf(\"%s: ec_hba field invalid\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (memcmp(ec->ec_eatasig, \"EATA\", 4) != 0) {\n\t        printf(\"%s: EATA signature mismatch\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (!ec->ec_dmasupported) {\n\t        printf(\"%s: DMA not supported\\n\", sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "dpt_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "535-558",
    "snippet": "int\ndpt_poll(sc, ccb)\n        struct dpt_softc *sc;\n        struct dpt_ccb *ccb;\n{\n\tint i;\n\n#ifdef DEBUG\n\tif ((ccb->ccb_flg & CCB_PRIVATE) == 0)\n\t\tpanic(\"dpt_poll: called for non-CCB_PRIVATE request\\n\");\n#endif\n\n \tif ((ccb->ccb_flg & CCB_INTR) != 0)\n        \treturn (0);                \n\n        for (i = ccb->ccb_timeout * 20; i; i--) {\n                if ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) != 0)\n                \tdpt_intr(sc);\n                if ((ccb->ccb_flg & CCB_INTR) != 0)\n                \treturn (0);\n                DELAY(50);\n        }\n        return (-1);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "struct dpt_ccb *ccb;",
      "struct dpt_softc *sc;",
      "struct dpt_ccb *ccb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_intr",
          "args": [
            "sc"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "154-290",
          "snippet": "int\ndpt_intr(xxx_sc)\n\tvoid *xxx_sc;\n{\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n\tstruct eata_sp *sp;\n\tstatic int moretimo;\n\tint more;\n\n\tsc = xxx_sc;\n\tsp = sc->sc_statpack;\n\n\tif (!sp) {\n#ifdef DEBUG\n\t\tprintf(\"%s: premature intr (st:%02x aux:%02x)\\n\",\n\t\t\tsc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS),\n\t\t\tdpt_inb(sc, HA_AUX_STATUS));\n#else /* DEBUG */\n\t\t(void) dpt_inb(sc, HA_STATUS);\n#endif /* DEBUG */\n\t\treturn (0);\n\t}\n\n\tmore = 0;\n\n#ifdef DEBUG\n\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0)\n\t\tprintf(\"%s: spurious intr\\n\", sc->sc_dv.dv_xname);\n#endif\n\n\t/* Don't get stalled by HA_ST_MORE */\n\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\tmoretimo = 0;\n\t\n\tfor (;;) {\n\t\t/*\n\t\t * HBA might have interrupted while we were dealing with the\n\t\t * last completed command, since we ACK before we deal; keep \n\t\t * polling. If no interrupt is signalled, but the HBA has\n\t\t * indicated that more data will be available soon, hang \n\t\t * around. \n\t\t */ \n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0) {\n\t\t\tif (more != 0 && moretimo++ < DPT_MORE_TIMEOUT / 100) {\n\t\t\t\tDELAY(10);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n#ifdef __NetBSD__\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff,\n\t\t    sizeof(struct eata_sp), BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb,\n\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\n\t\tif (!sp) {\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\n\t\t\t/* Don't get stalled by HA_ST_MORE */\n\t\t\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\t\t\tmoretimo = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Might have looped before HBA can reset HBA_AUX_INTR */\n\t\tif (sp->sp_ccbid == -1) {\n\t\t\tDELAY(50);\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: slow reset of HA_AUX_STATUS?\",\n\t\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0)\n\t\t\t\treturn (0);\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: was a slow reset of HA_AUX_STATUS\",\n\t\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\t\t/* Re-sync DMA map */\n#ifdef __NetBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    sc->sc_spoff, sizeof(struct eata_sp),\n\t\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\t\t}\n\n\t\t/* Make sure CCB ID from status packet is realistic */\n\t\tif (sp->sp_ccbid >= 0 && sp->sp_ccbid < sc->sc_nccbs) {\n\t\t\t/* Sync up DMA map and cache cmd status */\n\t\t\tccb = sc->sc_ccbs + sp->sp_ccbid;\n\n#ifdef __NetBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    CCB_OFF(sc, ccb), sizeof(struct dpt_ccb), \n\t\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __OpenBSD__ */\n\n\t\t\tccb->ccb_hba_status = sp->sp_hba_status & 0x7F;\n\t\t\tccb->ccb_scsi_status = sp->sp_scsi_status;\n\n\t\t\t/* \n\t\t\t * Ack the interrupt and process the CCB. If this\n\t\t\t * is a private CCB it's up to dpt_poll() to notice.\n\t\t\t */\n\t\t\tsp->sp_ccbid = -1;\n\t\t\tccb->ccb_flg |= CCB_INTR;\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\t\t\tif ((ccb->ccb_flg & CCB_PRIVATE) == 0)\n\t\t\t\tdpt_done_ccb(sc, ccb);\n\t\t} else {\n\t\t\tprintf(\"%s: bogus status (returned CCB id %d)\\n\", \n\t\t\t    sc->sc_dv.dv_xname, sp->sp_ccbid);\n\n\t\t\t/* Ack the interrupt */\n\t\t\tsp->sp_ccbid = -1;\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\t\t}\n\t\t\n\t\t/* Don't get stalled by HA_ST_MORE */\n\t\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\t\tmoretimo = 0;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct dpt_ccb *ccb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nint\ndpt_intr(xxx_sc)\n\tvoid *xxx_sc;\n{\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n\tstruct eata_sp *sp;\n\tstatic int moretimo;\n\tint more;\n\n\tsc = xxx_sc;\n\tsp = sc->sc_statpack;\n\n\tif (!sp) {\n#ifdef DEBUG\n\t\tprintf(\"%s: premature intr (st:%02x aux:%02x)\\n\",\n\t\t\tsc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS),\n\t\t\tdpt_inb(sc, HA_AUX_STATUS));\n#else /* DEBUG */\n\t\t(void) dpt_inb(sc, HA_STATUS);\n#endif /* DEBUG */\n\t\treturn (0);\n\t}\n\n\tmore = 0;\n\n#ifdef DEBUG\n\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0)\n\t\tprintf(\"%s: spurious intr\\n\", sc->sc_dv.dv_xname);\n#endif\n\n\t/* Don't get stalled by HA_ST_MORE */\n\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\tmoretimo = 0;\n\t\n\tfor (;;) {\n\t\t/*\n\t\t * HBA might have interrupted while we were dealing with the\n\t\t * last completed command, since we ACK before we deal; keep \n\t\t * polling. If no interrupt is signalled, but the HBA has\n\t\t * indicated that more data will be available soon, hang \n\t\t * around. \n\t\t */ \n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0) {\n\t\t\tif (more != 0 && moretimo++ < DPT_MORE_TIMEOUT / 100) {\n\t\t\t\tDELAY(10);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n#ifdef __NetBSD__\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff,\n\t\t    sizeof(struct eata_sp), BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb,\n\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\n\t\tif (!sp) {\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\n\t\t\t/* Don't get stalled by HA_ST_MORE */\n\t\t\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\t\t\tmoretimo = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Might have looped before HBA can reset HBA_AUX_INTR */\n\t\tif (sp->sp_ccbid == -1) {\n\t\t\tDELAY(50);\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: slow reset of HA_AUX_STATUS?\",\n\t\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0)\n\t\t\t\treturn (0);\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: was a slow reset of HA_AUX_STATUS\",\n\t\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\t\t/* Re-sync DMA map */\n#ifdef __NetBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    sc->sc_spoff, sizeof(struct eata_sp),\n\t\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\t\t}\n\n\t\t/* Make sure CCB ID from status packet is realistic */\n\t\tif (sp->sp_ccbid >= 0 && sp->sp_ccbid < sc->sc_nccbs) {\n\t\t\t/* Sync up DMA map and cache cmd status */\n\t\t\tccb = sc->sc_ccbs + sp->sp_ccbid;\n\n#ifdef __NetBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    CCB_OFF(sc, ccb), sizeof(struct dpt_ccb), \n\t\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __OpenBSD__ */\n\n\t\t\tccb->ccb_hba_status = sp->sp_hba_status & 0x7F;\n\t\t\tccb->ccb_scsi_status = sp->sp_scsi_status;\n\n\t\t\t/* \n\t\t\t * Ack the interrupt and process the CCB. If this\n\t\t\t * is a private CCB it's up to dpt_poll() to notice.\n\t\t\t */\n\t\t\tsp->sp_ccbid = -1;\n\t\t\tccb->ccb_flg |= CCB_INTR;\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\t\t\tif ((ccb->ccb_flg & CCB_PRIVATE) == 0)\n\t\t\t\tdpt_done_ccb(sc, ccb);\n\t\t} else {\n\t\t\tprintf(\"%s: bogus status (returned CCB id %d)\\n\", \n\t\t\t    sc->sc_dv.dv_xname, sp->sp_ccbid);\n\n\t\t\t/* Ack the interrupt */\n\t\t\tsp->sp_ccbid = -1;\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\t\t}\n\t\t\n\t\t/* Don't get stalled by HA_ST_MORE */\n\t\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\t\tmoretimo = 0;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_AUX_STATUS"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"dpt_poll: called for non-CCB_PRIVATE request\\n\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nint\ndpt_poll(sc, ccb)\n        struct dpt_softc *sc;\n        struct dpt_ccb *ccb;\n{\n\tint i;\n\n#ifdef DEBUG\n\tif ((ccb->ccb_flg & CCB_PRIVATE) == 0)\n\t\tpanic(\"dpt_poll: called for non-CCB_PRIVATE request\\n\");\n#endif\n\n \tif ((ccb->ccb_flg & CCB_INTR) != 0)\n        \treturn (0);                \n\n        for (i = ccb->ccb_timeout * 20; i; i--) {\n                if ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) != 0)\n                \tdpt_intr(sc);\n                if ((ccb->ccb_flg & CCB_INTR) != 0)\n                \treturn (0);\n                DELAY(50);\n        }\n        return (-1);\n}"
  },
  {
    "function_name": "dpt_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "513-526",
    "snippet": "int\ndpt_wait(sc, mask, state, ms)\n        struct dpt_softc *sc;\n        u_int8_t mask, state;\n        int ms;\n{\n     \n        for (ms *= 10; ms; ms--) {\n                if ((dpt_inb(sc, HA_STATUS) & mask) == state)\n                \treturn (0);\n                DELAY(100);\n        }\n        return (-1);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "struct dpt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_softc *sc;\n\nint\ndpt_wait(sc, mask, state, ms)\n        struct dpt_softc *sc;\n        u_int8_t mask, state;\n        int ms;\n{\n     \n        for (ms *= 10; ms; ms--) {\n                if ((dpt_inb(sc, HA_STATUS) & mask) == state)\n                \treturn (0);\n                DELAY(100);\n        }\n        return (-1);\n}"
  },
  {
    "function_name": "dpt_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "467-508",
    "snippet": "int\ndpt_cmd(sc, cp, addr, eatacmd, icmd)\n\tstruct dpt_softc *sc;\n\tstruct eata_cp *cp;\n\tu_int32_t addr;\n\tint eatacmd, icmd;\n{\n\tint i;\n\t\n\tfor (i = 20000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)\n\t\t\tbreak;\n\t\tDELAY(50);\n\t}\n\n\t/* Not the most graceful way to handle this */\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA timeout on EATA command issue; aborting\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (cp == NULL)\n\t\taddr = 0;\n\n\tdpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);\n\tdpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);\n\tdpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);\n\tdpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);\n\n\tif (eatacmd == CP_IMMEDIATE) {\n\t\tif (cp == NULL) {\n\t\t\t/* XXX should really pass meaningful values */\n\t\t\tdpt_outb(sc, HA_ICMD_CODE2, 0);\n\t\t\tdpt_outb(sc, HA_ICMD_CODE1, 0);\n\t\t}\n\t\tdpt_outb(sc, HA_ICMD, icmd);\n\t}\n\n        dpt_outb(sc, HA_COMMAND, eatacmd);\n        return (0);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "int s;",
      "struct dpt_softc *sc;",
      "struct eata_cp *cp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_COMMAND",
            "eatacmd"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_ICMD",
            "icmd"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_ICMD_CODE1",
            "0"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_ICMD_CODE2",
            "0"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_DMA_BASE + 3",
            "(u_int32_t)addr >> 24"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_DMA_BASE + 2",
            "(u_int32_t)addr >> 16"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_DMA_BASE + 1",
            "(u_int32_t)addr >> 8"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_outb",
          "args": [
            "sc",
            "HA_DMA_BASE + 0",
            "(u_int32_t)addr"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: HBA timeout on EATA command issue; aborting\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_AUX_STATUS"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nint s;\nstruct dpt_softc *sc;\nstruct eata_cp *cp;\n\nint\ndpt_cmd(sc, cp, addr, eatacmd, icmd)\n\tstruct dpt_softc *sc;\n\tstruct eata_cp *cp;\n\tu_int32_t addr;\n\tint eatacmd, icmd;\n{\n\tint i;\n\t\n\tfor (i = 20000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)\n\t\t\tbreak;\n\t\tDELAY(50);\n\t}\n\n\t/* Not the most graceful way to handle this */\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA timeout on EATA command issue; aborting\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (cp == NULL)\n\t\taddr = 0;\n\n\tdpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);\n\tdpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);\n\tdpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);\n\tdpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);\n\n\tif (eatacmd == CP_IMMEDIATE) {\n\t\tif (cp == NULL) {\n\t\t\t/* XXX should really pass meaningful values */\n\t\t\tdpt_outb(sc, HA_ICMD_CODE2, 0);\n\t\t\tdpt_outb(sc, HA_ICMD_CODE1, 0);\n\t\t}\n\t\tdpt_outb(sc, HA_ICMD, icmd);\n\t}\n\n        dpt_outb(sc, HA_COMMAND, eatacmd);\n        return (0);\n}"
  },
  {
    "function_name": "dpt_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "451-462",
    "snippet": "void\ndpt_shutdown(xxx_sc)\n\tvoid *xxx_sc;\n{\n\tstruct dpt_softc *sc;\n\n\tsc = xxx_sc;\n\tprintf(\"shutting down %s...\", sc->sc_dv.dv_xname);\n\tdpt_cmd(sc, NULL, 0, CP_IMMEDIATE, CPI_POWEROFF_WARN);\n\tDELAY(5000*1000);\n\tprintf(\" done\\n\");\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "int s;",
      "struct dpt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" done\\n\""
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "5000*1000"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_cmd",
          "args": [
            "sc",
            "NULL",
            "0",
            "CP_IMMEDIATE",
            "CPI_POWEROFF_WARN"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "467-508",
          "snippet": "int\ndpt_cmd(sc, cp, addr, eatacmd, icmd)\n\tstruct dpt_softc *sc;\n\tstruct eata_cp *cp;\n\tu_int32_t addr;\n\tint eatacmd, icmd;\n{\n\tint i;\n\t\n\tfor (i = 20000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)\n\t\t\tbreak;\n\t\tDELAY(50);\n\t}\n\n\t/* Not the most graceful way to handle this */\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA timeout on EATA command issue; aborting\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (cp == NULL)\n\t\taddr = 0;\n\n\tdpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);\n\tdpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);\n\tdpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);\n\tdpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);\n\n\tif (eatacmd == CP_IMMEDIATE) {\n\t\tif (cp == NULL) {\n\t\t\t/* XXX should really pass meaningful values */\n\t\t\tdpt_outb(sc, HA_ICMD_CODE2, 0);\n\t\t\tdpt_outb(sc, HA_ICMD_CODE1, 0);\n\t\t}\n\t\tdpt_outb(sc, HA_ICMD, icmd);\n\t}\n\n        dpt_outb(sc, HA_COMMAND, eatacmd);\n        return (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct eata_cp *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nint s;\nstruct dpt_softc *sc;\nstruct eata_cp *cp;\n\nint\ndpt_cmd(sc, cp, addr, eatacmd, icmd)\n\tstruct dpt_softc *sc;\n\tstruct eata_cp *cp;\n\tu_int32_t addr;\n\tint eatacmd, icmd;\n{\n\tint i;\n\t\n\tfor (i = 20000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)\n\t\t\tbreak;\n\t\tDELAY(50);\n\t}\n\n\t/* Not the most graceful way to handle this */\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA timeout on EATA command issue; aborting\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (cp == NULL)\n\t\taddr = 0;\n\n\tdpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);\n\tdpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);\n\tdpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);\n\tdpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);\n\n\tif (eatacmd == CP_IMMEDIATE) {\n\t\tif (cp == NULL) {\n\t\t\t/* XXX should really pass meaningful values */\n\t\t\tdpt_outb(sc, HA_ICMD_CODE2, 0);\n\t\t\tdpt_outb(sc, HA_ICMD_CODE1, 0);\n\t\t}\n\t\tdpt_outb(sc, HA_ICMD, icmd);\n\t}\n\n        dpt_outb(sc, HA_COMMAND, eatacmd);\n        return (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nint s;\nstruct dpt_softc *sc;\n\nvoid\ndpt_shutdown(xxx_sc)\n\tvoid *xxx_sc;\n{\n\tstruct dpt_softc *sc;\n\n\tsc = xxx_sc;\n\tprintf(\"shutting down %s...\", sc->sc_dv.dv_xname);\n\tdpt_cmd(sc, NULL, 0, CP_IMMEDIATE, CPI_POWEROFF_WARN);\n\tDELAY(5000*1000);\n\tprintf(\" done\\n\");\n}"
  },
  {
    "function_name": "dpt_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "296-445",
    "snippet": "void\ndpt_init(sc, intrstr)\n\tstruct dpt_softc *sc;\n\tconst char *intrstr;\n{\n\tstruct eata_inquiry_data *ei;\n\tint i, j, error, rseg, mapsize;\n\tbus_dma_segment_t seg;\n\tstruct eata_cfg *ec;\n\tchar model[16];\n\n\tec = &sc->sc_ec;\n\t\n\t/* Allocate the CCB/status packet/scratch DMA map and load */\n\tsc->sc_nccbs = min(betoh16(*(int16_t *)ec->ec_queuedepth),\n\t\t\t   DPT_MAX_CCBS);\n\tsc->sc_spoff = sc->sc_nccbs * sizeof(struct dpt_ccb);\n\tsc->sc_scroff = sc->sc_spoff + sizeof(struct eata_sp);\n\tsc->sc_scrlen = 256; /* XXX */\n\tmapsize = sc->sc_nccbs * sizeof(struct dpt_ccb) + sc->sc_scrlen +\n\t    sizeof(struct eata_sp);\n\t\t\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, mapsize, NBPG, 0, \n\t    &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate CCBs, error = %d\\n\",\n\t\t    sc->sc_dv.dv_xname, error);\n\t\treturn;\n\t}\n\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg, mapsize,\n\t    (caddr_t *)&sc->sc_ccbs, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map CCBs, error = %d\\n\",\n\t\t    sc->sc_dv.dv_xname, error);\n\t\treturn;\n\t}\n\n\tif ((error = bus_dmamap_create(sc->sc_dmat, mapsize, mapsize, 1, 0, \n\t    BUS_DMA_NOWAIT, &sc->sc_dmamap_ccb)) != 0) {\n\t\tprintf(\"%s: unable to create CCB DMA map, error = %d\\n\",\n\t\t    sc->sc_dv.dv_xname, error);\n\t\treturn;\n\t}\n\n\tif ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_ccb,\n\t    sc->sc_ccbs, mapsize, NULL, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load CCB DMA map, error = %d\\n\",\n\t\t    sc->sc_dv.dv_xname, error);\n\t\treturn;\n\t}\n\n\tsc->sc_statpack = (struct eata_sp *)((caddr_t)sc->sc_ccbs +\n\t    sc->sc_spoff);\n\tsc->sc_sppa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr + sc->sc_spoff;\n\tsc->sc_scr = (caddr_t)sc->sc_ccbs + sc->sc_scroff;\n\tsc->sc_scrpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr + sc->sc_scroff;\n\tsc->sc_statpack->sp_ccbid = -1;\n\n\t/* Initialize the CCBs */\n\tTAILQ_INIT(&sc->sc_free_ccb);\n\ti = dpt_create_ccbs(sc, sc->sc_ccbs, sc->sc_nccbs);\n\n\tif (i == 0) {\n\t\tprintf(\"%s: unable to create CCBs\\n\", sc->sc_dv.dv_xname);\n\t\treturn;\n\t} else if (i != sc->sc_nccbs) {\n\t\tprintf(\"%s: %d/%d CCBs created!\\n\", sc->sc_dv.dv_xname, i, \n\t\t    sc->sc_nccbs);\n\t\tsc->sc_nccbs = i;\n\t}\n\n\t/* Set shutdownhook before we start any device activity */\n\tsc->sc_sdh = shutdownhook_establish(dpt_shutdown, sc);\n\n\t/* Get the page 0 inquiry data from the HBA */\n\tdpt_hba_inquire(sc, &ei);\n\n\t/* \n\t * dpt0 at pci0 dev 12 function 0: DPT SmartRAID III (PM3224A/9X-R)\n\t * dpt0: interrupting at irq 10\n\t * dpt0: 64 queued commands, 1 channel(s), adapter on ID(s) 7\n\t */\n\tfor (i = 0; ei->ei_vendor[i] != ' ' && i < 8; i++)\n\t\t;\n\tei->ei_vendor[i] = '\\0';\n\n\tfor (i = 0; ei->ei_model[i] != ' ' && i < 7; i++)\n\t\tmodel[i] = ei->ei_model[i];\n\tfor (j = 0; ei->ei_suffix[j] != ' ' && j < 7; j++)\n\t\tmodel[i++] = ei->ei_model[i];\n\tmodel[i] = '\\0';\n\n\t/* Find the cannonical name for the board */\n\tfor (i = 0; dpt_cname[i] != NULL; i += 2)\n\t\tif (memcmp(ei->ei_model, dpt_cname[i], 6) == 0)\n\t\t\tbreak;\n\t\t\t\n\tprintf(\"%s %s (%s)\\n\", ei->ei_vendor, dpt_cname[i + 1], model);\n\n\tif (intrstr != NULL)\n\t\tprintf(\"%s: interrupting at %s\\n\", sc->sc_dv.dv_xname, intrstr);\n\n\tprintf(\"%s: %d queued commands, %d channel(s), adapter on ID(s)\", \n\t    sc->sc_dv.dv_xname, sc->sc_nccbs, ec->ec_maxchannel + 1);\n\n\tfor (i = 0; i <= ec->ec_maxchannel; i++)\n\t\tprintf(\" %d\", ec->ec_hba[3 - i]);\n\tprintf(\"\\n\");\n\n\t/* Reset the SCSI bus */\n\tif (dpt_cmd(sc, NULL, 0, CP_IMMEDIATE, CPI_BUS_RESET))\n\t\tpanic(\"%s: dpt_cmd failed\", sc->sc_dv.dv_xname);\n        DELAY(20000);\n\t\n\t/* Fill in the adapter, each link and attach in turn */\n#ifdef __NetBSD__\n\tsc->sc_adapter.scsipi_cmd = dpt_scsi_cmd;\n\tsc->sc_adapter.scsipi_minphys = dpt_minphys;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tsc->sc_adapter.scsi_cmd = dpt_scsi_cmd;\n\tsc->sc_adapter.scsi_minphys = dpt_minphys;\n#endif /* __OpenBSD__ */\n\n\tfor (i = 0; i <= ec->ec_maxchannel; i++) {\n#ifdef __NetBSD__\n\t\tstruct scsipi_link *link;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tstruct scsi_link *link;\n#endif /* __OpenBSD__ */\n\t\tsc->sc_hbaid[i] = ec->ec_hba[3 - i];\n\t\tlink = &sc->sc_link[i];\n#ifdef __NetBSD__\n\t\tlink->scsipi_scsi.scsibus = i;\n\t\tlink->scsipi_scsi.adapter_target = sc->sc_hbaid[i];\n\t\tlink->scsipi_scsi.max_lun = ec->ec_maxlun;\n\t\tlink->scsipi_scsi.max_target = ec->ec_maxtarget;\n\t\tlink->type = BUS_SCSI;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tlink->scsibus = i;\n\t\tlink->adapter_target = sc->sc_hbaid[i];\n#endif /* __OpenBSD__ */\n\t\tlink->device = &dpt_dev;\n\t\tlink->adapter = &sc->sc_adapter;\n\t\tlink->adapter_softc = sc;\n\t\tlink->openings = sc->sc_nccbs;\n\t\tconfig_found(&sc->sc_dv, link, scsiprint);\n\t}\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct scsi_device dpt_dev = {\n#endif /* __OpenBSD__ */\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
      "static char *dpt_cname[] = {\n\t\"PM3334\", \"SmartRAID IV\",\n\t\"PM3332\", \"SmartRAID IV\",\n\t\"PM2144\", \"SmartCache IV\",\n\t\"PM2044\", \"SmartCache IV\",\n\t\"PM2142\", \"SmartCache IV\",\n\t\"PM2042\", \"SmartCache IV\",\n\t\"PM2041\", \"SmartCache IV\",\n\t\"PM3224\", \"SmartRAID III\",\n\t\"PM3222\", \"SmartRAID III\", \n\t\"PM3021\", \"SmartRAID III\",\n\t\"PM2124\", \"SmartCache III\",\n\t\"PM2024\", \"SmartCache III\",\n\t\"PM2122\", \"SmartCache III\",\n\t\"PM2022\", \"SmartCache III\",\n\t\"PM2021\", \"SmartCache III\",\n\t\"SK2012\", \"SmartCache Plus\", \n\t\"SK2011\", \"SmartCache Plus\",\n\tNULL,     \"unknown adapter, please report using send-pr(1)\",\n};",
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "int s;",
      "struct dpt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&sc->sc_dv",
            "link",
            "scsiprint"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20000"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: dpt_cmd failed\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_cmd",
          "args": [
            "sc",
            "NULL",
            "0",
            "CP_IMMEDIATE",
            "CPI_BUS_RESET"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "467-508",
          "snippet": "int\ndpt_cmd(sc, cp, addr, eatacmd, icmd)\n\tstruct dpt_softc *sc;\n\tstruct eata_cp *cp;\n\tu_int32_t addr;\n\tint eatacmd, icmd;\n{\n\tint i;\n\t\n\tfor (i = 20000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)\n\t\t\tbreak;\n\t\tDELAY(50);\n\t}\n\n\t/* Not the most graceful way to handle this */\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA timeout on EATA command issue; aborting\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (cp == NULL)\n\t\taddr = 0;\n\n\tdpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);\n\tdpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);\n\tdpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);\n\tdpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);\n\n\tif (eatacmd == CP_IMMEDIATE) {\n\t\tif (cp == NULL) {\n\t\t\t/* XXX should really pass meaningful values */\n\t\t\tdpt_outb(sc, HA_ICMD_CODE2, 0);\n\t\t\tdpt_outb(sc, HA_ICMD_CODE1, 0);\n\t\t}\n\t\tdpt_outb(sc, HA_ICMD, icmd);\n\t}\n\n        dpt_outb(sc, HA_COMMAND, eatacmd);\n        return (0);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct eata_cp *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nint s;\nstruct dpt_softc *sc;\nstruct eata_cp *cp;\n\nint\ndpt_cmd(sc, cp, addr, eatacmd, icmd)\n\tstruct dpt_softc *sc;\n\tstruct eata_cp *cp;\n\tu_int32_t addr;\n\tint eatacmd, icmd;\n{\n\tint i;\n\t\n\tfor (i = 20000; i; i--) {\n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_BUSY) == 0)\n\t\t\tbreak;\n\t\tDELAY(50);\n\t}\n\n\t/* Not the most graceful way to handle this */\n\tif (i == 0) {\n\t\tprintf(\"%s: HBA timeout on EATA command issue; aborting\\n\", \n\t\t    sc->sc_dv.dv_xname);\n\t\treturn (-1);\n\t}\n\t\n\tif (cp == NULL)\n\t\taddr = 0;\n\n\tdpt_outb(sc, HA_DMA_BASE + 0, (u_int32_t)addr);\n\tdpt_outb(sc, HA_DMA_BASE + 1, (u_int32_t)addr >> 8);\n\tdpt_outb(sc, HA_DMA_BASE + 2, (u_int32_t)addr >> 16);\n\tdpt_outb(sc, HA_DMA_BASE + 3, (u_int32_t)addr >> 24);\n\n\tif (eatacmd == CP_IMMEDIATE) {\n\t\tif (cp == NULL) {\n\t\t\t/* XXX should really pass meaningful values */\n\t\t\tdpt_outb(sc, HA_ICMD_CODE2, 0);\n\t\t\tdpt_outb(sc, HA_ICMD_CODE1, 0);\n\t\t}\n\t\tdpt_outb(sc, HA_ICMD, icmd);\n\t}\n\n        dpt_outb(sc, HA_COMMAND, eatacmd);\n        return (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ei->ei_model",
            "dpt_cname[i]",
            "6"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_hba_inquire",
          "args": [
            "sc",
            "&ei"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_hba_inquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "1360-1441",
          "snippet": "void\ndpt_hba_inquire(sc, ei)\n\tstruct dpt_softc *sc;\n\tstruct eata_inquiry_data **ei;\n{\n\tstruct dpt_ccb *ccb;\n\tstruct eata_cp *cp;\n\tbus_dma_tag_t dmat;\n\t\n\t*ei = (struct eata_inquiry_data *)sc->sc_scr;\n\tdmat = sc->sc_dmat;\n\n\t/* Get a CCB and mark as private */\n\tif ((ccb = dpt_alloc_ccb(sc, 0)) == NULL)\n\t\tpanic(\"%s: no CCB for inquiry\", sc->sc_dv.dv_xname);\n\t\n\tccb->ccb_flg |= CCB_PRIVATE;\n\tccb->ccb_timeout = 200;\n\n\t/* Put all the arguments into the CCB */\n\tcp = &ccb->ccb_eata_cp;\n\tcp->cp_ccbid = ccb->ccb_id;\n\tcp->cp_id = sc->sc_hbaid[0];\n\tcp->cp_lun = 0;\n\tcp->cp_channel = 0;\n\tcp->cp_senselen = sizeof(ccb->ccb_sense);\n\tcp->cp_stataddr = htobe32(sc->sc_sppa);\n\tcp->cp_dispri = 1;\n\tcp->cp_identify = 1;\n\tcp->cp_autosense = 0;\n\tcp->cp_interpret = 1;\n\tcp->cp_nocache = 0;\n\tcp->cp_datain = 1;\n\tcp->cp_dataout = 0;\n\tcp->cp_senseaddr = 0;\n\tcp->cp_dataaddr = htobe32(sc->sc_scrpa);\n\tcp->cp_datalen = htobe32(sizeof(struct eata_inquiry_data));\n\tcp->cp_scatter = 0;\n\t\n\t/* Put together the SCSI inquiry command */\n\tmemset(&cp->cp_scsi_cmd, 0, 12);\t/* XXX */\n\tcp->cp_scsi_cmd = INQUIRY;\n\tcp->cp_len = sizeof(struct eata_inquiry_data);\n\n\t/* Sync up CCB, status packet and scratch area */\n#ifdef __NetBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, CCB_OFF(sc, ccb), \n\t    sizeof(struct dpt_ccb), BUS_DMASYNC_PREWRITE);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff, \n\t    sizeof(struct eata_sp), BUS_DMASYNC_PREREAD);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_scroff, \n\t    sizeof(struct eata_inquiry_data), BUS_DMASYNC_PREREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREWRITE);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);\n#endif /* __OpenBSD__ */\n\n\t/* Start the command and poll on completion */\n\tif (dpt_cmd(sc, &ccb->ccb_eata_cp, ccb->ccb_ccbpa, CP_DMA_CMD, 0))\n\t\tpanic(\"%s: dpt_cmd failed\", sc->sc_dv.dv_xname);\n\n\tif (dpt_poll(sc, ccb))\n\t\tpanic(\"%s: inquiry timed out\", sc->sc_dv.dv_xname);\n\n\tif (ccb->ccb_hba_status != HA_NO_ERROR ||\n\t    ccb->ccb_scsi_status != SCSI_OK)\n\t    \tpanic(\"%s: inquiry failed (hba:%02x scsi:%02x\", \n\t    \t    sc->sc_dv.dv_xname, ccb->ccb_hba_status,\n\t    \t    ccb->ccb_scsi_status);\n\t\n\t/* Sync up the DMA map and free CCB, returning */\n#ifdef __NetBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_scroff, \n\t    sizeof(struct eata_inquiry_data), BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\tdpt_free_ccb(sc, ccb);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "struct eata_cp *cp;",
            "bus_dma_tag_t dmat;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nstruct eata_cp *cp;\nbus_dma_tag_t dmat;\n\nvoid\ndpt_hba_inquire(sc, ei)\n\tstruct dpt_softc *sc;\n\tstruct eata_inquiry_data **ei;\n{\n\tstruct dpt_ccb *ccb;\n\tstruct eata_cp *cp;\n\tbus_dma_tag_t dmat;\n\t\n\t*ei = (struct eata_inquiry_data *)sc->sc_scr;\n\tdmat = sc->sc_dmat;\n\n\t/* Get a CCB and mark as private */\n\tif ((ccb = dpt_alloc_ccb(sc, 0)) == NULL)\n\t\tpanic(\"%s: no CCB for inquiry\", sc->sc_dv.dv_xname);\n\t\n\tccb->ccb_flg |= CCB_PRIVATE;\n\tccb->ccb_timeout = 200;\n\n\t/* Put all the arguments into the CCB */\n\tcp = &ccb->ccb_eata_cp;\n\tcp->cp_ccbid = ccb->ccb_id;\n\tcp->cp_id = sc->sc_hbaid[0];\n\tcp->cp_lun = 0;\n\tcp->cp_channel = 0;\n\tcp->cp_senselen = sizeof(ccb->ccb_sense);\n\tcp->cp_stataddr = htobe32(sc->sc_sppa);\n\tcp->cp_dispri = 1;\n\tcp->cp_identify = 1;\n\tcp->cp_autosense = 0;\n\tcp->cp_interpret = 1;\n\tcp->cp_nocache = 0;\n\tcp->cp_datain = 1;\n\tcp->cp_dataout = 0;\n\tcp->cp_senseaddr = 0;\n\tcp->cp_dataaddr = htobe32(sc->sc_scrpa);\n\tcp->cp_datalen = htobe32(sizeof(struct eata_inquiry_data));\n\tcp->cp_scatter = 0;\n\t\n\t/* Put together the SCSI inquiry command */\n\tmemset(&cp->cp_scsi_cmd, 0, 12);\t/* XXX */\n\tcp->cp_scsi_cmd = INQUIRY;\n\tcp->cp_len = sizeof(struct eata_inquiry_data);\n\n\t/* Sync up CCB, status packet and scratch area */\n#ifdef __NetBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, CCB_OFF(sc, ccb), \n\t    sizeof(struct dpt_ccb), BUS_DMASYNC_PREWRITE);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff, \n\t    sizeof(struct eata_sp), BUS_DMASYNC_PREREAD);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_scroff, \n\t    sizeof(struct eata_inquiry_data), BUS_DMASYNC_PREREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREWRITE);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_PREREAD);\n#endif /* __OpenBSD__ */\n\n\t/* Start the command and poll on completion */\n\tif (dpt_cmd(sc, &ccb->ccb_eata_cp, ccb->ccb_ccbpa, CP_DMA_CMD, 0))\n\t\tpanic(\"%s: dpt_cmd failed\", sc->sc_dv.dv_xname);\n\n\tif (dpt_poll(sc, ccb))\n\t\tpanic(\"%s: inquiry timed out\", sc->sc_dv.dv_xname);\n\n\tif (ccb->ccb_hba_status != HA_NO_ERROR ||\n\t    ccb->ccb_scsi_status != SCSI_OK)\n\t    \tpanic(\"%s: inquiry failed (hba:%02x scsi:%02x\", \n\t    \t    sc->sc_dv.dv_xname, ccb->ccb_hba_status,\n\t    \t    ccb->ccb_scsi_status);\n\t\n\t/* Sync up the DMA map and free CCB, returning */\n#ifdef __NetBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_scroff, \n\t    sizeof(struct eata_inquiry_data), BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\tdpt_free_ccb(sc, ccb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "dpt_shutdown",
            "sc"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_create_ccbs",
          "args": [
            "sc",
            "sc->sc_ccbs",
            "sc->sc_nccbs"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_create_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "733-755",
          "snippet": "int\ndpt_create_ccbs(sc, ccbstore, count)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccbstore;\n\tint count;\n{\n\tstruct dpt_ccb *ccb;\n\tint i, error;\n\n\tmemset(ccbstore, 0, sizeof(struct dpt_ccb) * count);\n\t\n\tfor (i = 0, ccb = ccbstore; i < count; i++, ccb++) {\n\t\tif ((error = dpt_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to init ccb, error = %d\\n\",\n\t\t\t    sc->sc_dv.dv_xname, error);\n\t\t\tbreak;\n\t\t}\n\t\tccb->ccb_id = i;\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_chain);\n\t}\n\n\treturn (i);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct dpt_ccb *ccb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nint\ndpt_create_ccbs(sc, ccbstore, count)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccbstore;\n\tint count;\n{\n\tstruct dpt_ccb *ccb;\n\tint i, error;\n\n\tmemset(ccbstore, 0, sizeof(struct dpt_ccb) * count);\n\t\n\tfor (i = 0, ccb = ccbstore; i < count; i++, ccb++) {\n\t\tif ((error = dpt_init_ccb(sc, ccb)) != 0) {\n\t\t\tprintf(\"%s: unable to init ccb, error = %d\\n\",\n\t\t\t    sc->sc_dv.dv_xname, error);\n\t\t\tbreak;\n\t\t}\n\t\tccb->ccb_id = i;\n\t\tTAILQ_INSERT_TAIL(&sc->sc_free_ccb, ccb, ccb_chain);\n\t}\n\n\treturn (i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_free_ccb"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "sc->sc_ccbs",
            "mapsize",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmat",
            "mapsize",
            "mapsize",
            "1",
            "0",
            "BUS_DMA_NOWAIT",
            "&sc->sc_dmamap_ccb"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmat",
            "&seg",
            "rseg",
            "mapsize",
            "(caddr_t *)&sc->sc_ccbs",
            "BUS_DMA_NOWAIT|BUS_DMA_COHERENT"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmat",
            "mapsize",
            "NBPG",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "betoh16(*(int16_t *)ec->ec_queuedepth)",
            "DPT_MAX_CCBS"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "673-681",
          "snippet": "void\ndpt_minphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > DPT_MAX_XFER)\n\t\tbp->b_bcount = DPT_MAX_XFER;\n\tminphys(bp);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\ndpt_minphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > DPT_MAX_XFER)\n\t\tbp->b_bcount = DPT_MAX_XFER;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "betoh16",
          "args": [
            "*(int16_t *)ec->ec_queuedepth"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic struct scsi_device dpt_dev = {\n#endif /* __OpenBSD__ */\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nstatic char *dpt_cname[] = {\n\t\"PM3334\", \"SmartRAID IV\",\n\t\"PM3332\", \"SmartRAID IV\",\n\t\"PM2144\", \"SmartCache IV\",\n\t\"PM2044\", \"SmartCache IV\",\n\t\"PM2142\", \"SmartCache IV\",\n\t\"PM2042\", \"SmartCache IV\",\n\t\"PM2041\", \"SmartCache IV\",\n\t\"PM3224\", \"SmartRAID III\",\n\t\"PM3222\", \"SmartRAID III\", \n\t\"PM3021\", \"SmartRAID III\",\n\t\"PM2124\", \"SmartCache III\",\n\t\"PM2024\", \"SmartCache III\",\n\t\"PM2122\", \"SmartCache III\",\n\t\"PM2022\", \"SmartCache III\",\n\t\"PM2021\", \"SmartCache III\",\n\t\"SK2012\", \"SmartCache Plus\", \n\t\"SK2011\", \"SmartCache Plus\",\n\tNULL,     \"unknown adapter, please report using send-pr(1)\",\n};\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nint s;\nstruct dpt_softc *sc;\n\nvoid\ndpt_init(sc, intrstr)\n\tstruct dpt_softc *sc;\n\tconst char *intrstr;\n{\n\tstruct eata_inquiry_data *ei;\n\tint i, j, error, rseg, mapsize;\n\tbus_dma_segment_t seg;\n\tstruct eata_cfg *ec;\n\tchar model[16];\n\n\tec = &sc->sc_ec;\n\t\n\t/* Allocate the CCB/status packet/scratch DMA map and load */\n\tsc->sc_nccbs = min(betoh16(*(int16_t *)ec->ec_queuedepth),\n\t\t\t   DPT_MAX_CCBS);\n\tsc->sc_spoff = sc->sc_nccbs * sizeof(struct dpt_ccb);\n\tsc->sc_scroff = sc->sc_spoff + sizeof(struct eata_sp);\n\tsc->sc_scrlen = 256; /* XXX */\n\tmapsize = sc->sc_nccbs * sizeof(struct dpt_ccb) + sc->sc_scrlen +\n\t    sizeof(struct eata_sp);\n\t\t\n\tif ((error = bus_dmamem_alloc(sc->sc_dmat, mapsize, NBPG, 0, \n\t    &seg, 1, &rseg, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to allocate CCBs, error = %d\\n\",\n\t\t    sc->sc_dv.dv_xname, error);\n\t\treturn;\n\t}\n\n\tif ((error = bus_dmamem_map(sc->sc_dmat, &seg, rseg, mapsize,\n\t    (caddr_t *)&sc->sc_ccbs, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) != 0) {\n\t\tprintf(\"%s: unable to map CCBs, error = %d\\n\",\n\t\t    sc->sc_dv.dv_xname, error);\n\t\treturn;\n\t}\n\n\tif ((error = bus_dmamap_create(sc->sc_dmat, mapsize, mapsize, 1, 0, \n\t    BUS_DMA_NOWAIT, &sc->sc_dmamap_ccb)) != 0) {\n\t\tprintf(\"%s: unable to create CCB DMA map, error = %d\\n\",\n\t\t    sc->sc_dv.dv_xname, error);\n\t\treturn;\n\t}\n\n\tif ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmamap_ccb,\n\t    sc->sc_ccbs, mapsize, NULL, BUS_DMA_NOWAIT)) != 0) {\n\t\tprintf(\"%s: unable to load CCB DMA map, error = %d\\n\",\n\t\t    sc->sc_dv.dv_xname, error);\n\t\treturn;\n\t}\n\n\tsc->sc_statpack = (struct eata_sp *)((caddr_t)sc->sc_ccbs +\n\t    sc->sc_spoff);\n\tsc->sc_sppa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr + sc->sc_spoff;\n\tsc->sc_scr = (caddr_t)sc->sc_ccbs + sc->sc_scroff;\n\tsc->sc_scrpa = sc->sc_dmamap_ccb->dm_segs[0].ds_addr + sc->sc_scroff;\n\tsc->sc_statpack->sp_ccbid = -1;\n\n\t/* Initialize the CCBs */\n\tTAILQ_INIT(&sc->sc_free_ccb);\n\ti = dpt_create_ccbs(sc, sc->sc_ccbs, sc->sc_nccbs);\n\n\tif (i == 0) {\n\t\tprintf(\"%s: unable to create CCBs\\n\", sc->sc_dv.dv_xname);\n\t\treturn;\n\t} else if (i != sc->sc_nccbs) {\n\t\tprintf(\"%s: %d/%d CCBs created!\\n\", sc->sc_dv.dv_xname, i, \n\t\t    sc->sc_nccbs);\n\t\tsc->sc_nccbs = i;\n\t}\n\n\t/* Set shutdownhook before we start any device activity */\n\tsc->sc_sdh = shutdownhook_establish(dpt_shutdown, sc);\n\n\t/* Get the page 0 inquiry data from the HBA */\n\tdpt_hba_inquire(sc, &ei);\n\n\t/* \n\t * dpt0 at pci0 dev 12 function 0: DPT SmartRAID III (PM3224A/9X-R)\n\t * dpt0: interrupting at irq 10\n\t * dpt0: 64 queued commands, 1 channel(s), adapter on ID(s) 7\n\t */\n\tfor (i = 0; ei->ei_vendor[i] != ' ' && i < 8; i++)\n\t\t;\n\tei->ei_vendor[i] = '\\0';\n\n\tfor (i = 0; ei->ei_model[i] != ' ' && i < 7; i++)\n\t\tmodel[i] = ei->ei_model[i];\n\tfor (j = 0; ei->ei_suffix[j] != ' ' && j < 7; j++)\n\t\tmodel[i++] = ei->ei_model[i];\n\tmodel[i] = '\\0';\n\n\t/* Find the cannonical name for the board */\n\tfor (i = 0; dpt_cname[i] != NULL; i += 2)\n\t\tif (memcmp(ei->ei_model, dpt_cname[i], 6) == 0)\n\t\t\tbreak;\n\t\t\t\n\tprintf(\"%s %s (%s)\\n\", ei->ei_vendor, dpt_cname[i + 1], model);\n\n\tif (intrstr != NULL)\n\t\tprintf(\"%s: interrupting at %s\\n\", sc->sc_dv.dv_xname, intrstr);\n\n\tprintf(\"%s: %d queued commands, %d channel(s), adapter on ID(s)\", \n\t    sc->sc_dv.dv_xname, sc->sc_nccbs, ec->ec_maxchannel + 1);\n\n\tfor (i = 0; i <= ec->ec_maxchannel; i++)\n\t\tprintf(\" %d\", ec->ec_hba[3 - i]);\n\tprintf(\"\\n\");\n\n\t/* Reset the SCSI bus */\n\tif (dpt_cmd(sc, NULL, 0, CP_IMMEDIATE, CPI_BUS_RESET))\n\t\tpanic(\"%s: dpt_cmd failed\", sc->sc_dv.dv_xname);\n        DELAY(20000);\n\t\n\t/* Fill in the adapter, each link and attach in turn */\n#ifdef __NetBSD__\n\tsc->sc_adapter.scsipi_cmd = dpt_scsi_cmd;\n\tsc->sc_adapter.scsipi_minphys = dpt_minphys;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tsc->sc_adapter.scsi_cmd = dpt_scsi_cmd;\n\tsc->sc_adapter.scsi_minphys = dpt_minphys;\n#endif /* __OpenBSD__ */\n\n\tfor (i = 0; i <= ec->ec_maxchannel; i++) {\n#ifdef __NetBSD__\n\t\tstruct scsipi_link *link;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tstruct scsi_link *link;\n#endif /* __OpenBSD__ */\n\t\tsc->sc_hbaid[i] = ec->ec_hba[3 - i];\n\t\tlink = &sc->sc_link[i];\n#ifdef __NetBSD__\n\t\tlink->scsipi_scsi.scsibus = i;\n\t\tlink->scsipi_scsi.adapter_target = sc->sc_hbaid[i];\n\t\tlink->scsipi_scsi.max_lun = ec->ec_maxlun;\n\t\tlink->scsipi_scsi.max_target = ec->ec_maxtarget;\n\t\tlink->type = BUS_SCSI;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tlink->scsibus = i;\n\t\tlink->adapter_target = sc->sc_hbaid[i];\n#endif /* __OpenBSD__ */\n\t\tlink->device = &dpt_dev;\n\t\tlink->adapter = &sc->sc_adapter;\n\t\tlink->adapter_softc = sc;\n\t\tlink->openings = sc->sc_nccbs;\n\t\tconfig_found(&sc->sc_dv, link, scsiprint);\n\t}\n}"
  },
  {
    "function_name": "dpt_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
    "lines": "154-290",
    "snippet": "int\ndpt_intr(xxx_sc)\n\tvoid *xxx_sc;\n{\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n\tstruct eata_sp *sp;\n\tstatic int moretimo;\n\tint more;\n\n\tsc = xxx_sc;\n\tsp = sc->sc_statpack;\n\n\tif (!sp) {\n#ifdef DEBUG\n\t\tprintf(\"%s: premature intr (st:%02x aux:%02x)\\n\",\n\t\t\tsc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS),\n\t\t\tdpt_inb(sc, HA_AUX_STATUS));\n#else /* DEBUG */\n\t\t(void) dpt_inb(sc, HA_STATUS);\n#endif /* DEBUG */\n\t\treturn (0);\n\t}\n\n\tmore = 0;\n\n#ifdef DEBUG\n\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0)\n\t\tprintf(\"%s: spurious intr\\n\", sc->sc_dv.dv_xname);\n#endif\n\n\t/* Don't get stalled by HA_ST_MORE */\n\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\tmoretimo = 0;\n\t\n\tfor (;;) {\n\t\t/*\n\t\t * HBA might have interrupted while we were dealing with the\n\t\t * last completed command, since we ACK before we deal; keep \n\t\t * polling. If no interrupt is signalled, but the HBA has\n\t\t * indicated that more data will be available soon, hang \n\t\t * around. \n\t\t */ \n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0) {\n\t\t\tif (more != 0 && moretimo++ < DPT_MORE_TIMEOUT / 100) {\n\t\t\t\tDELAY(10);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n#ifdef __NetBSD__\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff,\n\t\t    sizeof(struct eata_sp), BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb,\n\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\n\t\tif (!sp) {\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\n\t\t\t/* Don't get stalled by HA_ST_MORE */\n\t\t\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\t\t\tmoretimo = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Might have looped before HBA can reset HBA_AUX_INTR */\n\t\tif (sp->sp_ccbid == -1) {\n\t\t\tDELAY(50);\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: slow reset of HA_AUX_STATUS?\",\n\t\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0)\n\t\t\t\treturn (0);\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: was a slow reset of HA_AUX_STATUS\",\n\t\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\t\t/* Re-sync DMA map */\n#ifdef __NetBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    sc->sc_spoff, sizeof(struct eata_sp),\n\t\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\t\t}\n\n\t\t/* Make sure CCB ID from status packet is realistic */\n\t\tif (sp->sp_ccbid >= 0 && sp->sp_ccbid < sc->sc_nccbs) {\n\t\t\t/* Sync up DMA map and cache cmd status */\n\t\t\tccb = sc->sc_ccbs + sp->sp_ccbid;\n\n#ifdef __NetBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    CCB_OFF(sc, ccb), sizeof(struct dpt_ccb), \n\t\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __OpenBSD__ */\n\n\t\t\tccb->ccb_hba_status = sp->sp_hba_status & 0x7F;\n\t\t\tccb->ccb_scsi_status = sp->sp_scsi_status;\n\n\t\t\t/* \n\t\t\t * Ack the interrupt and process the CCB. If this\n\t\t\t * is a private CCB it's up to dpt_poll() to notice.\n\t\t\t */\n\t\t\tsp->sp_ccbid = -1;\n\t\t\tccb->ccb_flg |= CCB_INTR;\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\t\t\tif ((ccb->ccb_flg & CCB_PRIVATE) == 0)\n\t\t\t\tdpt_done_ccb(sc, ccb);\n\t\t} else {\n\t\t\tprintf(\"%s: bogus status (returned CCB id %d)\\n\", \n\t\t\t    sc->sc_dv.dv_xname, sp->sp_ccbid);\n\n\t\t\t/* Ack the interrupt */\n\t\t\tsp->sp_ccbid = -1;\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\t\t}\n\t\t\n\t\t/* Don't get stalled by HA_ST_MORE */\n\t\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\t\tmoretimo = 0;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/dptvar.h>",
      "#include <dev/ic/dptreg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/scsipi/scsiconf.h>",
      "#include <dev/scsipi/scsipi_all.h>",
      "#include <dev/scsipi/scsi_all.h>",
      "#include <machine/bus.h>",
      "#include <machine/bswap.h>",
      "#include <machine/endian.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
      "struct dpt_ccb *ccb;",
      "int s;",
      "struct dpt_softc *sc;",
      "struct dpt_ccb *ccb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bogus status (returned CCB id %d)\\n\"",
            "sc->sc_dv.dv_xname",
            "sp->sp_ccbid"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpt_done_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "dpt_done_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dpt.c",
          "lines": "800-915",
          "snippet": "void\ndpt_done_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n#ifdef __NetBSD__\n\tstruct scsipi_sense_data *s1, *s2;\n\tstruct scsipi_xfer *xs;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs;\n#endif /* __OpenBSD__ */\n\tbus_dma_tag_t dmat;\n\t\n\tdmat = sc->sc_dmat;\n\txs = ccb->ccb_xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"dpt_done_ccb\\n\"));\n\n\t/*\n\t * If we were a data transfer, unload the map that described the \n\t * data buffer.\n\t */\n\tif (xs->datalen) {\n#ifdef __NetBSD__\n\t\tbus_dmamap_sync(dmat, ccb->ccb_dmamap_xfer, 0,\n\t\t    ccb->ccb_dmamap_xfer->dm_mapsize,\n\t\t    (xs->xs_control & XS_CTL_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tbus_dmamap_sync(dmat, ccb->ccb_dmamap_xfer,\n\t\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __OpenBSD__ */\n\t\tbus_dmamap_unload(dmat, ccb->ccb_dmamap_xfer);\n\t}\n\n\t/*\n\t * Otherwise, put the results of the operation into the xfer and \n\t * call whoever started it.\n\t */\n#ifdef DIAGNOSTIC\n\tif ((ccb->ccb_flg & CCB_ALLOC) == 0) {\n\t\tpanic(\"%s: done ccb not allocated!\\n\", sc->sc_dv.dv_xname);\n\t\treturn;\n\t}\n#endif\n\t\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->ccb_hba_status != HA_NO_ERROR) {\n\t\t\tswitch (ccb->ccb_hba_status) {\n\t\t\tcase HA_ERROR_SEL_TO:\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tcase HA_ERROR_RESET:\n\t\t\t\txs->error = XS_RESET;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: HBA status %x\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, ccb->ccb_hba_status);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (ccb->ccb_scsi_status != SCSI_OK) {\n\t\t\tswitch (ccb->ccb_scsi_status) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ccb->ccb_sense;\n#ifdef __NetBSD__\n\t\t\t\ts2 = &xs->sense.scsi_sense;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\t\ts2 = &xs->sense;\n#endif /* __OpenBSD__ */\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: SCSI status %x\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, ccb->ccb_scsi_status);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t\t\t\n\t\txs->status = ccb->ccb_scsi_status;\n\t}\n\n\t/* Free up the CCB and mark the command as done */\n\tdpt_free_ccb(sc, ccb);\n#ifdef __NetBSD__\n\txs->xs_status |= XS_STS_DONE;\n\tscsipi_done(xs);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n#endif /* __OpenBSD__ */\n\n\t/*\n\t * If there are entries in the software queue, try to run the first\n\t * one. We should be more or less guaranteed to succeed, since we\n\t * just freed an CCB. NOTE: dpt_scsi_cmd() relies on our calling it\n\t * with the first entry in the queue.\n\t */\n#ifdef __NetBSD__\n\tif ((xs = TAILQ_FIRST(&sc->sc_queue)) != NULL)\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tif ((xs = sc->sc_queue.lh_first) != NULL)\n#endif /* __OpenBSD__ */\n\t\tdpt_scsi_cmd(xs);\n}",
          "includes": [
            "#include <dev/ic/dptvar.h>",
            "#include <dev/ic/dptreg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <machine/bus.h>",
            "#include <machine/bswap.h>",
            "#include <machine/endian.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "int s;",
            "struct dpt_softc *sc;",
            "struct dpt_ccb *ccb;",
            "bus_dma_tag_t dmat;",
            "bus_dmamap_t xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nbus_dma_tag_t dmat;\nbus_dmamap_t xfer;\n\nvoid\ndpt_done_ccb(sc, ccb)\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n{\n#ifdef __NetBSD__\n\tstruct scsipi_sense_data *s1, *s2;\n\tstruct scsipi_xfer *xs;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs;\n#endif /* __OpenBSD__ */\n\tbus_dma_tag_t dmat;\n\t\n\tdmat = sc->sc_dmat;\n\txs = ccb->ccb_xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"dpt_done_ccb\\n\"));\n\n\t/*\n\t * If we were a data transfer, unload the map that described the \n\t * data buffer.\n\t */\n\tif (xs->datalen) {\n#ifdef __NetBSD__\n\t\tbus_dmamap_sync(dmat, ccb->ccb_dmamap_xfer, 0,\n\t\t    ccb->ccb_dmamap_xfer->dm_mapsize,\n\t\t    (xs->xs_control & XS_CTL_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tbus_dmamap_sync(dmat, ccb->ccb_dmamap_xfer,\n\t\t    (xs->flags & SCSI_DATA_IN) ? BUS_DMASYNC_POSTREAD :\n\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __OpenBSD__ */\n\t\tbus_dmamap_unload(dmat, ccb->ccb_dmamap_xfer);\n\t}\n\n\t/*\n\t * Otherwise, put the results of the operation into the xfer and \n\t * call whoever started it.\n\t */\n#ifdef DIAGNOSTIC\n\tif ((ccb->ccb_flg & CCB_ALLOC) == 0) {\n\t\tpanic(\"%s: done ccb not allocated!\\n\", sc->sc_dv.dv_xname);\n\t\treturn;\n\t}\n#endif\n\t\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->ccb_hba_status != HA_NO_ERROR) {\n\t\t\tswitch (ccb->ccb_hba_status) {\n\t\t\tcase HA_ERROR_SEL_TO:\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tcase HA_ERROR_RESET:\n\t\t\t\txs->error = XS_RESET;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: HBA status %x\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, ccb->ccb_hba_status);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (ccb->ccb_scsi_status != SCSI_OK) {\n\t\t\tswitch (ccb->ccb_scsi_status) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ccb->ccb_sense;\n#ifdef __NetBSD__\n\t\t\t\ts2 = &xs->sense.scsi_sense;\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\t\ts2 = &xs->sense;\n#endif /* __OpenBSD__ */\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: SCSI status %x\\n\",\n\t\t\t\t    sc->sc_dv.dv_xname, ccb->ccb_scsi_status);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t\t\t\n\t\txs->status = ccb->ccb_scsi_status;\n\t}\n\n\t/* Free up the CCB and mark the command as done */\n\tdpt_free_ccb(sc, ccb);\n#ifdef __NetBSD__\n\txs->xs_status |= XS_STS_DONE;\n\tscsipi_done(xs);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n#endif /* __OpenBSD__ */\n\n\t/*\n\t * If there are entries in the software queue, try to run the first\n\t * one. We should be more or less guaranteed to succeed, since we\n\t * just freed an CCB. NOTE: dpt_scsi_cmd() relies on our calling it\n\t * with the first entry in the queue.\n\t */\n#ifdef __NetBSD__\n\tif ((xs = TAILQ_FIRST(&sc->sc_queue)) != NULL)\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\tif ((xs = sc->sc_queue.lh_first) != NULL)\n#endif /* __OpenBSD__ */\n\t\tdpt_scsi_cmd(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "BUS_DMASYNC_POSTWRITE"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "CCB_OFF(sc, ccb)",
            "sizeof(struct dpt_ccb)",
            "BUS_DMASYNC_POSTWRITE"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCB_OFF",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "BUS_DMASYNC_POSTREAD"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "sc->sc_spoff",
            "sizeof(struct eata_sp)",
            "BUS_DMASYNC_POSTREAD"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_AUX_STATUS"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "BUS_DMASYNC_POSTREAD"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_sync",
          "args": [
            "sc->sc_dmat",
            "sc->sc_dmamap_ccb",
            "sc->sc_spoff",
            "sizeof(struct eata_sp)",
            "BUS_DMASYNC_POSTREAD"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_AUX_STATUS"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_AUX_STATUS"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_AUX_STATUS"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dpt_inb",
          "args": [
            "sc",
            "HA_STATUS"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dptvar.h>\n#include <dev/ic/dptreg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <machine/bus.h>\n#include <machine/bswap.h>\n#include <machine/endian.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct dpt_ccb *\ndpt_alloc_ccb(sc, flg)\n\tstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\nint s;\nstruct dpt_softc *sc;\nstruct dpt_ccb *ccb;\n\nint\ndpt_intr(xxx_sc)\n\tvoid *xxx_sc;\n{\n\tstruct dpt_softc *sc;\n\tstruct dpt_ccb *ccb;\n\tstruct eata_sp *sp;\n\tstatic int moretimo;\n\tint more;\n\n\tsc = xxx_sc;\n\tsp = sc->sc_statpack;\n\n\tif (!sp) {\n#ifdef DEBUG\n\t\tprintf(\"%s: premature intr (st:%02x aux:%02x)\\n\",\n\t\t\tsc->sc_dv.dv_xname, dpt_inb(sc, HA_STATUS),\n\t\t\tdpt_inb(sc, HA_AUX_STATUS));\n#else /* DEBUG */\n\t\t(void) dpt_inb(sc, HA_STATUS);\n#endif /* DEBUG */\n\t\treturn (0);\n\t}\n\n\tmore = 0;\n\n#ifdef DEBUG\n\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0)\n\t\tprintf(\"%s: spurious intr\\n\", sc->sc_dv.dv_xname);\n#endif\n\n\t/* Don't get stalled by HA_ST_MORE */\n\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\tmoretimo = 0;\n\t\n\tfor (;;) {\n\t\t/*\n\t\t * HBA might have interrupted while we were dealing with the\n\t\t * last completed command, since we ACK before we deal; keep \n\t\t * polling. If no interrupt is signalled, but the HBA has\n\t\t * indicated that more data will be available soon, hang \n\t\t * around. \n\t\t */ \n\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0) {\n\t\t\tif (more != 0 && moretimo++ < DPT_MORE_TIMEOUT / 100) {\n\t\t\t\tDELAY(10);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n#ifdef __NetBSD__\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, sc->sc_spoff,\n\t\t    sizeof(struct eata_sp), BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb,\n\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\n\t\tif (!sp) {\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\n\t\t\t/* Don't get stalled by HA_ST_MORE */\n\t\t\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\t\t\tmoretimo = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Might have looped before HBA can reset HBA_AUX_INTR */\n\t\tif (sp->sp_ccbid == -1) {\n\t\t\tDELAY(50);\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: slow reset of HA_AUX_STATUS?\",\n\t\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\t\tif ((dpt_inb(sc, HA_AUX_STATUS) & HA_AUX_INTR) == 0)\n\t\t\t\treturn (0);\n#ifdef DIAGNOSTIC\n\t\t\tprintf(\"%s: was a slow reset of HA_AUX_STATUS\",\n\t\t\t    sc->sc_dv.dv_xname);\n#endif\n\t\t\t/* Re-sync DMA map */\n#ifdef __NetBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    sc->sc_spoff, sizeof(struct eata_sp),\n\t\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    BUS_DMASYNC_POSTREAD);\n#endif /* __OpenBSD__ */\n\t\t}\n\n\t\t/* Make sure CCB ID from status packet is realistic */\n\t\tif (sp->sp_ccbid >= 0 && sp->sp_ccbid < sc->sc_nccbs) {\n\t\t\t/* Sync up DMA map and cache cmd status */\n\t\t\tccb = sc->sc_ccbs + sp->sp_ccbid;\n\n#ifdef __NetBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    CCB_OFF(sc, ccb), sizeof(struct dpt_ccb), \n\t\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __NetBSD__ */\n#ifdef __OpenBSD__\n\t\t\tbus_dmamap_sync(sc->sc_dmat, sc->sc_dmamap_ccb, \n\t\t\t    BUS_DMASYNC_POSTWRITE);\n#endif /* __OpenBSD__ */\n\n\t\t\tccb->ccb_hba_status = sp->sp_hba_status & 0x7F;\n\t\t\tccb->ccb_scsi_status = sp->sp_scsi_status;\n\n\t\t\t/* \n\t\t\t * Ack the interrupt and process the CCB. If this\n\t\t\t * is a private CCB it's up to dpt_poll() to notice.\n\t\t\t */\n\t\t\tsp->sp_ccbid = -1;\n\t\t\tccb->ccb_flg |= CCB_INTR;\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\t\t\tif ((ccb->ccb_flg & CCB_PRIVATE) == 0)\n\t\t\t\tdpt_done_ccb(sc, ccb);\n\t\t} else {\n\t\t\tprintf(\"%s: bogus status (returned CCB id %d)\\n\", \n\t\t\t    sc->sc_dv.dv_xname, sp->sp_ccbid);\n\n\t\t\t/* Ack the interrupt */\n\t\t\tsp->sp_ccbid = -1;\n\t\t\tmore = dpt_inb(sc, HA_STATUS) & HA_ST_MORE;\n\t\t}\n\t\t\n\t\t/* Don't get stalled by HA_ST_MORE */\n\t\tif (moretimo < DPT_MORE_TIMEOUT / 100)\n\t\t\tmoretimo = 0;\n\t}\n\n\treturn (0);\n}"
  }
]