[
  {
    "function_name": "pci_get_capability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci.c",
    "lines": "279-312",
    "snippet": "int\npci_get_capability(pc, tag, capid, offset, value)\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tint capid;\n\tint *offset;\n\tpcireg_t *value;\n{\n\tpcireg_t reg;\n\tunsigned int ofs;\n\n\treg = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);\n\tif (!(reg & PCI_STATUS_CAPLIST_SUPPORT))\n\t\treturn (0);\n\n\tofs = PCI_CAPLIST_PTR(pci_conf_read(pc, tag, PCI_CAPLISTPTR_REG));\n\twhile (ofs != 0) {\n#ifdef DIAGNOSTIC\n\t\tif ((ofs & 3) || (ofs < 0x40))\n\t\t\tpanic(\"pci_get_capability\");\n#endif\n\t\treg = pci_conf_read(pc, tag, ofs);\n\t\tif (PCI_CAPLIST_CAP(reg) == capid) {\n\t\t\tif (offset)\n\t\t\t\t*offset = ofs;\n\t\t\tif (value)\n\t\t\t\t*value = reg;\n\t\t\treturn (1);\n\t\t}\n\t\tofs = PCI_CAPLIST_NEXT(reg);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_CAPLIST_NEXT",
          "args": [
            "reg"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CAPLIST_CAP",
          "args": [
            "reg"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "ofs"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"pci_get_capability\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CAPLIST_PTR",
          "args": [
            "pci_conf_read(pc, tag, PCI_CAPLISTPTR_REG)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_CAPLISTPTR_REG"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\npci_get_capability(pc, tag, capid, offset, value)\n\tpci_chipset_tag_t pc;\n\tpcitag_t tag;\n\tint capid;\n\tint *offset;\n\tpcireg_t *value;\n{\n\tpcireg_t reg;\n\tunsigned int ofs;\n\n\treg = pci_conf_read(pc, tag, PCI_COMMAND_STATUS_REG);\n\tif (!(reg & PCI_STATUS_CAPLIST_SUPPORT))\n\t\treturn (0);\n\n\tofs = PCI_CAPLIST_PTR(pci_conf_read(pc, tag, PCI_CAPLISTPTR_REG));\n\twhile (ofs != 0) {\n#ifdef DIAGNOSTIC\n\t\tif ((ofs & 3) || (ofs < 0x40))\n\t\t\tpanic(\"pci_get_capability\");\n#endif\n\t\treg = pci_conf_read(pc, tag, ofs);\n\t\tif (PCI_CAPLIST_CAP(reg) == capid) {\n\t\t\tif (offset)\n\t\t\t\t*offset = ofs;\n\t\t\tif (value)\n\t\t\t\t*value = reg;\n\t\t\treturn (1);\n\t\t}\n\t\tofs = PCI_CAPLIST_NEXT(reg);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "set_pci_isa_bridge_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci.c",
    "lines": "267-277",
    "snippet": "void\nset_pci_isa_bridge_callback(fn, arg)\n\tvoid (*fn) __P((void *));\n\tvoid *arg;\n{\n\n\tif (pci_isa_bridge_callback != NULL)\n\t\tpanic(\"set_pci_isa_bridge_callback\");\n\tpci_isa_bridge_callback = fn;\n\tpci_isa_bridge_callback_arg = arg;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\t(*pci_isa_bridge_callback)",
      "static void\t*pci_isa_bridge_callback_arg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"set_pci_isa_bridge_callback\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\t(*pci_isa_bridge_callback);\nstatic void\t*pci_isa_bridge_callback_arg;\n\nvoid\nset_pci_isa_bridge_callback(fn, arg)\n\tvoid (*fn) __P((void *));\n\tvoid *arg;\n{\n\n\tif (pci_isa_bridge_callback != NULL)\n\t\tpanic(\"set_pci_isa_bridge_callback\");\n\tpci_isa_bridge_callback = fn;\n\tpci_isa_bridge_callback_arg = arg;\n}"
  },
  {
    "function_name": "pcisubmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci.c",
    "lines": "231-265",
    "snippet": "int\npcisubmatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct pci_attach_args *pa = aux;\n\tint success;\n\n\tif (cf->pcicf_dev != PCI_UNK_DEV &&\n\t    cf->pcicf_dev != pa->pa_device)\n\t\treturn 0;\n\tif (cf->pcicf_function != PCI_UNK_FUNCTION &&\n\t    cf->pcicf_function != pa->pa_function)\n\t\treturn 0;\n\n\tsuccess = (*cf->cf_attach->ca_match)(parent, match, aux);\n\n\t/* My Dell BIOS does not enable certain non-critical PCI devices\n\t   for IO and memory cycles (e.g. network card). This is\n\t   the generic approach to fixing this problem. Basically, if\n\t   we support the card, then we enable its IO cycles.\n\t*/\n\tif (success) {\n\t\tu_int32_t csr = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t      PCI_COMMAND_STATUS_REG);\n\n\t\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t       csr | PCI_COMMAND_MASTER_ENABLE |\n\t\t\t       PCI_COMMAND_IO_ENABLE |\n\t\t\t       PCI_COMMAND_MEM_ENABLE);\n\t}\n\n\treturn (success);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpcisubmatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "csr | PCI_COMMAND_MASTER_ENABLE |\n\t\t\t       PCI_COMMAND_IO_ENABLE |\n\t\t\t       PCI_COMMAND_MEM_ENABLE"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "parent",
            "match",
            "aux"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpcisubmatch;\n\nint\npcisubmatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct pci_attach_args *pa = aux;\n\tint success;\n\n\tif (cf->pcicf_dev != PCI_UNK_DEV &&\n\t    cf->pcicf_dev != pa->pa_device)\n\t\treturn 0;\n\tif (cf->pcicf_function != PCI_UNK_FUNCTION &&\n\t    cf->pcicf_function != pa->pa_function)\n\t\treturn 0;\n\n\tsuccess = (*cf->cf_attach->ca_match)(parent, match, aux);\n\n\t/* My Dell BIOS does not enable certain non-critical PCI devices\n\t   for IO and memory cycles (e.g. network card). This is\n\t   the generic approach to fixing this problem. Basically, if\n\t   we support the card, then we enable its IO cycles.\n\t*/\n\tif (success) {\n\t\tu_int32_t csr = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t      PCI_COMMAND_STATUS_REG);\n\n\t\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t\t       csr | PCI_COMMAND_MASTER_ENABLE |\n\t\t\t       PCI_COMMAND_IO_ENABLE |\n\t\t\t       PCI_COMMAND_MEM_ENABLE);\n\t}\n\n\treturn (success);\n}"
  },
  {
    "function_name": "pciprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci.c",
    "lines": "210-229",
    "snippet": "int\npciprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tregister struct pci_attach_args *pa = aux;\n\tchar devinfo[256];\n\n\tif (pnp) {\n\t\tpci_devinfo(pa->pa_id, pa->pa_class, 1, devinfo);\n\t\tprintf(\"%s at %s\", devinfo, pnp);\n\t}\n\tprintf(\" dev %d function %d\", pa->pa_device, pa->pa_function);\n\tif (!pnp) {\n\t\tpci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);\n\t\tprintf(\" %s\", devinfo);\n\t}\n\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tpciprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %s\"",
            "devinfo"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_devinfo",
          "args": [
            "pa->pa_id",
            "pa->pa_class",
            "0",
            "devinfo"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "pci_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_subr.c",
          "lines": "215-306",
          "snippet": "void\npci_devinfo(id_reg, class_reg, showclass, cp)\n\tpcireg_t id_reg, class_reg;\n\tint showclass;\n\tchar *cp;\n{\n\tpci_vendor_id_t vendor;\n\tpci_product_id_t product;\n\tpci_class_t class;\n\tpci_subclass_t subclass;\n\tpci_interface_t interface;\n\tpci_revision_t revision;\n\tchar *vendor_namep, *product_namep;\n\tstruct pci_class *classp, *subclassp;\n#ifdef PCIVERBOSE\n\tstruct pci_knowndev *kdp;\n\tconst char *unmatched = \"unknown \";\n#else\n\tconst char *unmatched = \"\";\n#endif\n\n\tvendor = PCI_VENDOR(id_reg);\n\tproduct = PCI_PRODUCT(id_reg);\n\n\tclass = PCI_CLASS(class_reg);\n\tsubclass = PCI_SUBCLASS(class_reg);\n\tinterface = PCI_INTERFACE(class_reg);\n\trevision = PCI_REVISION(class_reg);\n\n#ifdef PCIVERBOSE\n\tkdp = pci_knowndevs;\n        while (kdp->vendorname != NULL) {\t/* all have vendor name */\n                if (kdp->vendor == vendor && (kdp->product == product ||\n\t\t    (kdp->flags & PCI_KNOWNDEV_NOPROD) != 0))\n                        break;\n\t\tkdp++;\n\t}\n        if (kdp->vendorname == NULL)\n\t\tvendor_namep = product_namep = NULL;\n\telse {\n\t\tvendor_namep = kdp->vendorname;\n\t\tproduct_namep = (kdp->flags & PCI_KNOWNDEV_NOPROD) == 0 ?\n\t\t    kdp->productname : NULL;\n        }\n#else /* PCIVERBOSE */\n\tvendor_namep = product_namep = NULL;\n#endif /* PCIVERBOSE */\n\n\tclassp = pci_class;\n\twhile (classp->name != NULL) {\n\t\tif (class == classp->val)\n\t\t\tbreak;\n\t\tclassp++;\n\t}\n\n\tsubclassp = (classp->name != NULL) ? classp->subclasses : NULL;\n\twhile (subclassp && subclassp->name != NULL) {\n\t\tif (subclass == subclassp->val)\n\t\t\tbreak;\n\t\tsubclassp++;\n\t}\n\n\tif (vendor_namep == NULL)\n\t\tcp += sprintf(cp, \"%svendor 0x%04x product 0x%04x\",\n\t\t    unmatched, vendor, product);\n\telse if (product_namep != NULL)\n\t\tcp += sprintf(cp, \"\\\"%s %s\\\"\", vendor_namep, product_namep);\n\telse\n\t\tcp += sprintf(cp, \"vendor \\\"%s\\\", unknown product 0x%x\",\n\t\t    vendor_namep, product);\n\tif (showclass && product_namep == NULL) {\n\t\tcp += sprintf(cp, \" (\");\n\t\tif (classp->name == NULL)\n\t\t\tcp += sprintf(cp,\n\t\t\t    \"unknown class 0x%2x, subclass 0x%02x\",\n\t\t\t    class, subclass);\n\t\telse {\n\t\t\tcp += sprintf(cp, \"class %s, \", classp->name);\n\t\t\tif (subclassp == NULL || subclassp->name == NULL)\n\t\t\t\tcp += sprintf(cp, \"unknown subclass 0x%02x\",\n\t\t\t\t    subclass);\n\t\t\telse\n\t\t\t\tcp += sprintf(cp, \"subclass %s\",\n\t\t\t\t    subclassp->name);\n\t\t}\n#if 0 /* not very useful */\n\t\tcp += sprintf(cp, \", interface 0x%02x\", interface);\n#endif\n\t\tcp += sprintf(cp, \", rev 0x%02x)\", revision);\n\t} else\n\t\tcp += sprintf(cp, \" rev 0x%02x\", revision);\n}",
          "includes": [
            "#include <dev/pci/pcidevs_data.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tPCI_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */"
          ],
          "globals_used": [
            "struct pci_class pci_class[] = {\n\t{ \"prehistoric\",\tPCI_CLASS_PREHISTORIC,\n\t    pci_subclass_prehistoric,\t\t\t\t},\n\t{ \"mass storage\",\tPCI_CLASS_MASS_STORAGE,\n\t    pci_subclass_mass_storage,\t\t\t\t},\n\t{ \"network\",\t\tPCI_CLASS_NETWORK,\n\t    pci_subclass_network,\t\t\t\t},\n\t{ \"display\",\t\tPCI_CLASS_DISPLAY,\n\t    pci_subclass_display,\t\t\t\t},\n\t{ \"multimedia\",\t\tPCI_CLASS_MULTIMEDIA,\n\t    pci_subclass_multimedia,\t\t\t\t},\n\t{ \"memory\",\t\tPCI_CLASS_MEMORY,\n\t    pci_subclass_memory,\t\t\t\t},\n\t{ \"bridge\",\t\tPCI_CLASS_BRIDGE,\n\t    pci_subclass_bridge,\t\t\t\t},\n\t{ \"communications\",\tPCI_CLASS_COMMUNICATIONS,\n\t    pci_subclass_communications,\t\t\t},\n\t{ \"system\",\t\tPCI_CLASS_SYSTEM,\n\t    pci_subclass_system,\t\t\t\t},\n\t{ \"input\",\t\tPCI_CLASS_INPUT,\n\t    pci_subclass_input,\t\t\t\t\t},\n\t{ \"dock\",\t\tPCI_CLASS_DOCK,\n\t    pci_subclass_dock,\t\t\t\t\t},\n\t{ \"processor\",\t\tPCI_CLASS_PROCESSOR,\n\t    pci_subclass_processor,\t\t\t\t},\n\t{ \"serial bus\",\t\tPCI_CLASS_SERIALBUS,\n\t    pci_subclass_serialbus,\t\t\t\t},\n\t{ \"undefined\",\t\tPCI_CLASS_UNDEFINED,\n\t    0,\t\t\t\t\t\t\t},\n\t{ 0 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs_data.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tPCI_KNOWNDEV_NOPROD\t0x01\t\t/* match on vendor only */\n\nstruct pci_class pci_class[] = {\n\t{ \"prehistoric\",\tPCI_CLASS_PREHISTORIC,\n\t    pci_subclass_prehistoric,\t\t\t\t},\n\t{ \"mass storage\",\tPCI_CLASS_MASS_STORAGE,\n\t    pci_subclass_mass_storage,\t\t\t\t},\n\t{ \"network\",\t\tPCI_CLASS_NETWORK,\n\t    pci_subclass_network,\t\t\t\t},\n\t{ \"display\",\t\tPCI_CLASS_DISPLAY,\n\t    pci_subclass_display,\t\t\t\t},\n\t{ \"multimedia\",\t\tPCI_CLASS_MULTIMEDIA,\n\t    pci_subclass_multimedia,\t\t\t\t},\n\t{ \"memory\",\t\tPCI_CLASS_MEMORY,\n\t    pci_subclass_memory,\t\t\t\t},\n\t{ \"bridge\",\t\tPCI_CLASS_BRIDGE,\n\t    pci_subclass_bridge,\t\t\t\t},\n\t{ \"communications\",\tPCI_CLASS_COMMUNICATIONS,\n\t    pci_subclass_communications,\t\t\t},\n\t{ \"system\",\t\tPCI_CLASS_SYSTEM,\n\t    pci_subclass_system,\t\t\t\t},\n\t{ \"input\",\t\tPCI_CLASS_INPUT,\n\t    pci_subclass_input,\t\t\t\t\t},\n\t{ \"dock\",\t\tPCI_CLASS_DOCK,\n\t    pci_subclass_dock,\t\t\t\t\t},\n\t{ \"processor\",\t\tPCI_CLASS_PROCESSOR,\n\t    pci_subclass_processor,\t\t\t\t},\n\t{ \"serial bus\",\t\tPCI_CLASS_SERIALBUS,\n\t    pci_subclass_serialbus,\t\t\t\t},\n\t{ \"undefined\",\t\tPCI_CLASS_UNDEFINED,\n\t    0,\t\t\t\t\t\t\t},\n\t{ 0 },\n};\n\nvoid\npci_devinfo(id_reg, class_reg, showclass, cp)\n\tpcireg_t id_reg, class_reg;\n\tint showclass;\n\tchar *cp;\n{\n\tpci_vendor_id_t vendor;\n\tpci_product_id_t product;\n\tpci_class_t class;\n\tpci_subclass_t subclass;\n\tpci_interface_t interface;\n\tpci_revision_t revision;\n\tchar *vendor_namep, *product_namep;\n\tstruct pci_class *classp, *subclassp;\n#ifdef PCIVERBOSE\n\tstruct pci_knowndev *kdp;\n\tconst char *unmatched = \"unknown \";\n#else\n\tconst char *unmatched = \"\";\n#endif\n\n\tvendor = PCI_VENDOR(id_reg);\n\tproduct = PCI_PRODUCT(id_reg);\n\n\tclass = PCI_CLASS(class_reg);\n\tsubclass = PCI_SUBCLASS(class_reg);\n\tinterface = PCI_INTERFACE(class_reg);\n\trevision = PCI_REVISION(class_reg);\n\n#ifdef PCIVERBOSE\n\tkdp = pci_knowndevs;\n        while (kdp->vendorname != NULL) {\t/* all have vendor name */\n                if (kdp->vendor == vendor && (kdp->product == product ||\n\t\t    (kdp->flags & PCI_KNOWNDEV_NOPROD) != 0))\n                        break;\n\t\tkdp++;\n\t}\n        if (kdp->vendorname == NULL)\n\t\tvendor_namep = product_namep = NULL;\n\telse {\n\t\tvendor_namep = kdp->vendorname;\n\t\tproduct_namep = (kdp->flags & PCI_KNOWNDEV_NOPROD) == 0 ?\n\t\t    kdp->productname : NULL;\n        }\n#else /* PCIVERBOSE */\n\tvendor_namep = product_namep = NULL;\n#endif /* PCIVERBOSE */\n\n\tclassp = pci_class;\n\twhile (classp->name != NULL) {\n\t\tif (class == classp->val)\n\t\t\tbreak;\n\t\tclassp++;\n\t}\n\n\tsubclassp = (classp->name != NULL) ? classp->subclasses : NULL;\n\twhile (subclassp && subclassp->name != NULL) {\n\t\tif (subclass == subclassp->val)\n\t\t\tbreak;\n\t\tsubclassp++;\n\t}\n\n\tif (vendor_namep == NULL)\n\t\tcp += sprintf(cp, \"%svendor 0x%04x product 0x%04x\",\n\t\t    unmatched, vendor, product);\n\telse if (product_namep != NULL)\n\t\tcp += sprintf(cp, \"\\\"%s %s\\\"\", vendor_namep, product_namep);\n\telse\n\t\tcp += sprintf(cp, \"vendor \\\"%s\\\", unknown product 0x%x\",\n\t\t    vendor_namep, product);\n\tif (showclass && product_namep == NULL) {\n\t\tcp += sprintf(cp, \" (\");\n\t\tif (classp->name == NULL)\n\t\t\tcp += sprintf(cp,\n\t\t\t    \"unknown class 0x%2x, subclass 0x%02x\",\n\t\t\t    class, subclass);\n\t\telse {\n\t\t\tcp += sprintf(cp, \"class %s, \", classp->name);\n\t\t\tif (subclassp == NULL || subclassp->name == NULL)\n\t\t\t\tcp += sprintf(cp, \"unknown subclass 0x%02x\",\n\t\t\t\t    subclass);\n\t\t\telse\n\t\t\t\tcp += sprintf(cp, \"subclass %s\",\n\t\t\t\t    subclassp->name);\n\t\t}\n#if 0 /* not very useful */\n\t\tcp += sprintf(cp, \", interface 0x%02x\", interface);\n#endif\n\t\tcp += sprintf(cp, \", rev 0x%02x)\", revision);\n\t} else\n\t\tcp += sprintf(cp, \" rev 0x%02x\", revision);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tpciprint;\n\nint\npciprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tregister struct pci_attach_args *pa = aux;\n\tchar devinfo[256];\n\n\tif (pnp) {\n\t\tpci_devinfo(pa->pa_id, pa->pa_class, 1, devinfo);\n\t\tprintf(\"%s at %s\", devinfo, pnp);\n\t}\n\tprintf(\" dev %d function %d\", pa->pa_device, pa->pa_function);\n\tif (!pnp) {\n\t\tpci_devinfo(pa->pa_id, pa->pa_class, 0, devinfo);\n\t\tprintf(\" %s\", devinfo);\n\t}\n\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "pciattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci.c",
    "lines": "111-208",
    "snippet": "void\npciattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pcibus_attach_args *pba = aux;\n\tbus_space_tag_t iot, memt;\n\tpci_chipset_tag_t pc;\n\tint bus, device, maxndevs, function, nfunctions;\n\n\tpci_attach_hook(parent, self, pba);\n\tprintf(\"\\n\");\n\n\tiot = pba->pba_iot;\n\tmemt = pba->pba_memt;\n\tpc = pba->pba_pc;\n\tbus = pba->pba_bus;\n\tmaxndevs = pci_bus_maxdevs(pc, bus);\n\n\tif (bus == 0)\n\t\tpci_isa_bridge_callback = NULL;\n\n\tfor (device = 0; device < maxndevs; device++) {\n\t\tpcitag_t tag;\n\t\tpcireg_t id, class, intr, bhlcr;\n\t\tstruct pci_attach_args pa;\n\t\tint pin;\n\n\t\ttag = pci_make_tag(pc, bus, device, 0);\n\t\tid = pci_conf_read(pc, tag, PCI_ID_REG);\n\n\t\t/* Invalid vendor ID value? */\n\t\tif (PCI_VENDOR(id) == PCI_VENDOR_INVALID)\n\t\t\tcontinue;\n\t\t/* XXX Not invalid, but we've done this ~forever. */\n\t\tif (PCI_VENDOR(id) == 0)\n\t\t\tcontinue;\n\n\t\tbhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);\n\t\tnfunctions = PCI_HDRTYPE_MULTIFN(bhlcr) ? 8 : 1;\n\n\t\tfor (function = 0; function < nfunctions; function++) {\n\t\t\ttag = pci_make_tag(pc, bus, device, function);\n\t\t\tid = pci_conf_read(pc, tag, PCI_ID_REG);\n\n\t\t\t/* Invalid vendor ID value? */\n\t\t\tif (PCI_VENDOR(id) == PCI_VENDOR_INVALID)\n\t\t\t\tcontinue;\n\t\t\t/* XXX Not invalid, but we've done this ~forever. */\n\t\t\tif (PCI_VENDOR(id) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tclass = pci_conf_read(pc, tag, PCI_CLASS_REG);\n\t\t\tintr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);\n\n\t\t\tpa.pa_iot = iot;\n\t\t\tpa.pa_memt = memt;\n\t\t\tpa.pa_dmat = pba->pba_dmat;\n\t\t\tpa.pa_pc = pc;\n\t\t\tpa.pa_device = device;\n\t\t\tpa.pa_function = function;\n\t\t\tpa.pa_tag = tag;\n\t\t\tpa.pa_id = id;\n\t\t\tpa.pa_class = class;\n\n\t\t\t/* This is a simplification of the NetBSD code.\n\t\t\t   We don't support turning off I/O or memory\n\t\t\t   on broken hardware. <csapuntz@stanford.edu> */\n\t\t\tpa.pa_flags = PCI_FLAGS_IO_ENABLED | PCI_FLAGS_MEM_ENABLED;\n\t\t\tif (bus == 0) {\n\t\t\t\tpa.pa_intrswiz = 0;\n\t\t\t\tpa.pa_intrtag = tag;\n\t\t\t} else {\n\t\t\t\tpa.pa_intrswiz = pba->pba_intrswiz + device;\n\t\t\t\tpa.pa_intrtag = pba->pba_intrtag;\n\t\t\t}\n\t\t\tpin = PCI_INTERRUPT_PIN(intr);\n\t\t\tif (pin == PCI_INTERRUPT_PIN_NONE) {\n\t\t\t\t/* no interrupt */\n\t\t\t\tpa.pa_intrpin = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * swizzle it based on the number of\n\t\t\t\t * busses we're behind and our device\n\t\t\t\t * number.\n\t\t\t\t */\n\t\t\t\tpa.pa_intrpin =\t\t\t/* XXX */\n\t\t\t\t    ((pin + pa.pa_intrswiz - 1) % 4) + 1;\n\t\t\t}\n\t\t\tpa.pa_intrline = PCI_INTERRUPT_LINE(intr);\n\n\t\t\tconfig_found_sm(self, &pa, pciprint, pcisubmatch);\n\t\t}\n\t}\n\n\tif (bus == 0 && pci_isa_bridge_callback != NULL)\n\t\t(*pci_isa_bridge_callback)(pci_isa_bridge_callback_arg);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void pciattach",
      "int\tpciprint",
      "int\tpcisubmatch",
      "static void\t(*pci_isa_bridge_callback)",
      "static void\t*pci_isa_bridge_callback_arg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "pci_isa_bridge_callback_arg"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found_sm",
          "args": [
            "self",
            "&pa",
            "pciprint",
            "pcisubmatch"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_INTERRUPT_LINE",
          "args": [
            "intr"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_INTERRUPT_PIN",
          "args": [
            "intr"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_INTERRUPT_REG"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_CLASS_REG"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "id"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "id"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_ID_REG"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_make_tag",
          "args": [
            "pc",
            "bus",
            "device",
            "function"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_HDRTYPE_MULTIFN",
          "args": [
            "bhlcr"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_BHLC_REG"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "id"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "id"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "tag",
            "PCI_ID_REG"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_make_tag",
          "args": [
            "pc",
            "bus",
            "device",
            "0"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_maxdevs",
          "args": [
            "pc",
            "bus"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_attach_hook",
          "args": [
            "parent",
            "self",
            "pba"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid pciattach;\nint\tpciprint;\nint\tpcisubmatch;\nstatic void\t(*pci_isa_bridge_callback);\nstatic void\t*pci_isa_bridge_callback_arg;\n\nvoid\npciattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pcibus_attach_args *pba = aux;\n\tbus_space_tag_t iot, memt;\n\tpci_chipset_tag_t pc;\n\tint bus, device, maxndevs, function, nfunctions;\n\n\tpci_attach_hook(parent, self, pba);\n\tprintf(\"\\n\");\n\n\tiot = pba->pba_iot;\n\tmemt = pba->pba_memt;\n\tpc = pba->pba_pc;\n\tbus = pba->pba_bus;\n\tmaxndevs = pci_bus_maxdevs(pc, bus);\n\n\tif (bus == 0)\n\t\tpci_isa_bridge_callback = NULL;\n\n\tfor (device = 0; device < maxndevs; device++) {\n\t\tpcitag_t tag;\n\t\tpcireg_t id, class, intr, bhlcr;\n\t\tstruct pci_attach_args pa;\n\t\tint pin;\n\n\t\ttag = pci_make_tag(pc, bus, device, 0);\n\t\tid = pci_conf_read(pc, tag, PCI_ID_REG);\n\n\t\t/* Invalid vendor ID value? */\n\t\tif (PCI_VENDOR(id) == PCI_VENDOR_INVALID)\n\t\t\tcontinue;\n\t\t/* XXX Not invalid, but we've done this ~forever. */\n\t\tif (PCI_VENDOR(id) == 0)\n\t\t\tcontinue;\n\n\t\tbhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);\n\t\tnfunctions = PCI_HDRTYPE_MULTIFN(bhlcr) ? 8 : 1;\n\n\t\tfor (function = 0; function < nfunctions; function++) {\n\t\t\ttag = pci_make_tag(pc, bus, device, function);\n\t\t\tid = pci_conf_read(pc, tag, PCI_ID_REG);\n\n\t\t\t/* Invalid vendor ID value? */\n\t\t\tif (PCI_VENDOR(id) == PCI_VENDOR_INVALID)\n\t\t\t\tcontinue;\n\t\t\t/* XXX Not invalid, but we've done this ~forever. */\n\t\t\tif (PCI_VENDOR(id) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tclass = pci_conf_read(pc, tag, PCI_CLASS_REG);\n\t\t\tintr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);\n\n\t\t\tpa.pa_iot = iot;\n\t\t\tpa.pa_memt = memt;\n\t\t\tpa.pa_dmat = pba->pba_dmat;\n\t\t\tpa.pa_pc = pc;\n\t\t\tpa.pa_device = device;\n\t\t\tpa.pa_function = function;\n\t\t\tpa.pa_tag = tag;\n\t\t\tpa.pa_id = id;\n\t\t\tpa.pa_class = class;\n\n\t\t\t/* This is a simplification of the NetBSD code.\n\t\t\t   We don't support turning off I/O or memory\n\t\t\t   on broken hardware. <csapuntz@stanford.edu> */\n\t\t\tpa.pa_flags = PCI_FLAGS_IO_ENABLED | PCI_FLAGS_MEM_ENABLED;\n\t\t\tif (bus == 0) {\n\t\t\t\tpa.pa_intrswiz = 0;\n\t\t\t\tpa.pa_intrtag = tag;\n\t\t\t} else {\n\t\t\t\tpa.pa_intrswiz = pba->pba_intrswiz + device;\n\t\t\t\tpa.pa_intrtag = pba->pba_intrtag;\n\t\t\t}\n\t\t\tpin = PCI_INTERRUPT_PIN(intr);\n\t\t\tif (pin == PCI_INTERRUPT_PIN_NONE) {\n\t\t\t\t/* no interrupt */\n\t\t\t\tpa.pa_intrpin = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * swizzle it based on the number of\n\t\t\t\t * busses we're behind and our device\n\t\t\t\t * number.\n\t\t\t\t */\n\t\t\t\tpa.pa_intrpin =\t\t\t/* XXX */\n\t\t\t\t    ((pin + pa.pa_intrswiz - 1) % 4) + 1;\n\t\t\t}\n\t\t\tpa.pa_intrline = PCI_INTERRUPT_LINE(intr);\n\n\t\t\tconfig_found_sm(self, &pa, pciprint, pcisubmatch);\n\t\t}\n\t}\n\n\tif (bus == 0 && pci_isa_bridge_callback != NULL)\n\t\t(*pci_isa_bridge_callback)(pci_isa_bridge_callback_arg);\n}"
  },
  {
    "function_name": "pcimatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci.c",
    "lines": "84-109",
    "snippet": "int\npcimatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct pcibus_attach_args *pba = aux;\n\n\tif (strcmp(pba->pba_busname, cf->cf_driver->cd_name))\n\t\treturn (0);\n\n\t/* Check the locators */\n\tif (cf->pcibuscf_bus != PCIBUS_UNK_BUS &&\n\t    cf->pcibuscf_bus != pba->pba_bus)\n\t\treturn (0);\n\n\t/* sanity */\n\tif (pba->pba_bus < 0 || pba->pba_bus > 255)\n\t\treturn (0);\n\n\t/*\n\t * XXX check other (hardware?) indicators\n\t */\n\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pcimatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pba->pba_busname",
            "cf->cf_driver->cd_name"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint pcimatch;\n\nint\npcimatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct pcibus_attach_args *pba = aux;\n\n\tif (strcmp(pba->pba_busname, cf->cf_driver->cd_name))\n\t\treturn (0);\n\n\t/* Check the locators */\n\tif (cf->pcibuscf_bus != PCIBUS_UNK_BUS &&\n\t    cf->pcibuscf_bus != pba->pba_bus)\n\t\treturn (0);\n\n\t/* sanity */\n\tif (pba->pba_bus < 0 || pba->pba_bus > 255)\n\t\treturn (0);\n\n\t/*\n\t * XXX check other (hardware?) indicators\n\t */\n\n\treturn 1;\n}"
  }
]