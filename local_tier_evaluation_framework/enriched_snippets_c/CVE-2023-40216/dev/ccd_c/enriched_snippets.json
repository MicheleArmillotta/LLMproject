[
  {
    "function_name": "printiinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1680-1693",
    "snippet": "void\nprintiinfo(ii)\n\tstruct ccdiinfo *ii;\n{\n\tint ix, i;\n\n\tfor (ix = 0; ii->ii_ndisk; ix++, ii++) {\n\t\tprintf(\" itab[%d]: #dk %d sblk %d soff %d\",\n\t\t       ix, ii->ii_ndisk, ii->ii_startblk, ii->ii_startoff);\n\t\tfor (i = 0; i < ii->ii_ndisk; i++)\n\t\t\tprintf(\" %d\", ii->ii_index[i]);\n\t\tprintf(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nINLINE struct;\n\nvoid\nprintiinfo(ii)\n\tstruct ccdiinfo *ii;\n{\n\tint ix, i;\n\n\tfor (ix = 0; ii->ii_ndisk; ix++, ii++) {\n\t\tprintf(\" itab[%d]: #dk %d sblk %d soff %d\",\n\t\t       ix, ii->ii_ndisk, ii->ii_startblk, ii->ii_startoff);\n\t\tfor (i = 0; i < ii->ii_ndisk; i++)\n\t\t\tprintf(\" %d\", ii->ii_index[i]);\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "ccdunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1667-1677",
    "snippet": "void\nccdunlock(cs)\n\tstruct ccd_softc *cs;\n{\n\n\tcs->sc_flags &= ~CCDF_LOCKED;\n\tif ((cs->sc_flags & CCDF_WANTED) != 0) {\n\t\tcs->sc_flags &= ~CCDF_WANTED;\n\t\twakeup(cs);\n\t}\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tccdunlock",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "cs"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tccdunlock;\nINLINE struct;\n\nvoid\nccdunlock(cs)\n\tstruct ccd_softc *cs;\n{\n\n\tcs->sc_flags &= ~CCDF_LOCKED;\n\tif ((cs->sc_flags & CCDF_WANTED) != 0) {\n\t\tcs->sc_flags &= ~CCDF_WANTED;\n\t\twakeup(cs);\n\t}\n}"
  },
  {
    "function_name": "ccdlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1649-1662",
    "snippet": "int\nccdlock(cs)\n\tstruct ccd_softc *cs;\n{\n\tint error;\n\n\twhile ((cs->sc_flags & CCDF_LOCKED) != 0) {\n\t\tcs->sc_flags |= CCDF_WANTED;\n\t\tif ((error = tsleep(cs, PRIBIO | PCATCH, \"ccdlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tcs->sc_flags |= CCDF_LOCKED;\n\treturn (0);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tccdlock",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "cs",
            "PRIBIO | PCATCH",
            "\"ccdlck\"",
            "0"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tccdlock;\nINLINE struct;\n\nint\nccdlock(cs)\n\tstruct ccd_softc *cs;\n{\n\tint error;\n\n\twhile ((cs->sc_flags & CCDF_LOCKED) != 0) {\n\t\tcs->sc_flags |= CCDF_WANTED;\n\t\tif ((error = tsleep(cs, PRIBIO | PCATCH, \"ccdlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tcs->sc_flags |= CCDF_LOCKED;\n\treturn (0);\n}"
  },
  {
    "function_name": "ccdmakedisklabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1628-1641",
    "snippet": "void\nccdmakedisklabel(cs)\n\tstruct ccd_softc *cs;\n{\n\tstruct disklabel *lp = cs->sc_dkdev.dk_label;\n\n\t/*\n\t * For historical reasons, if there's no disklabel present\n\t * the raw partition must be marked FS_BSDFFS.\n\t */\n\tlp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;\n\n\tstrncpy(lp->d_packname, \"default label\", sizeof(lp->d_packname));\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tccdmakedisklabel",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_packname",
            "\"default label\"",
            "sizeof(lp->d_packname)"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tccdmakedisklabel;\nINLINE struct;\n\nvoid\nccdmakedisklabel(cs)\n\tstruct ccd_softc *cs;\n{\n\tstruct disklabel *lp = cs->sc_dkdev.dk_label;\n\n\t/*\n\t * For historical reasons, if there's no disklabel present\n\t * the raw partition must be marked FS_BSDFFS.\n\t */\n\tlp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;\n\n\tstrncpy(lp->d_packname, \"default label\", sizeof(lp->d_packname));\n}"
  },
  {
    "function_name": "ccdgetdisklabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1571-1622",
    "snippet": "void\nccdgetdisklabel(dev)\n\tdev_t dev;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs = &ccd_softc[unit];\n\tchar *errstring;\n\tstruct disklabel *lp = cs->sc_dkdev.dk_label;\n\tstruct cpu_disklabel *clp = cs->sc_dkdev.dk_cpulabel;\n\tstruct ccdgeom *ccg = &cs->sc_geom;\n\n\tbzero(lp, sizeof(*lp));\n\tbzero(clp, sizeof(*clp));\n\n\tlp->d_secperunit = cs->sc_size;\n\tlp->d_secsize = ccg->ccg_secsize;\n\tlp->d_nsectors = ccg->ccg_nsectors;\n\tlp->d_ntracks = ccg->ccg_ntracks;\n\tlp->d_ncylinders = ccg->ccg_ncylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"ccd\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_CCD;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = cs->sc_size;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(cs->sc_dkdev.dk_label);\n\n\t/*\n\t * Call the generic disklabel extraction routine.\n\t */\n\terrstring = readdisklabel(CCDLABELDEV(dev), ccdstrategy,\n\t    cs->sc_dkdev.dk_label, cs->sc_dkdev.dk_cpulabel, 0);\n\tif (errstring)\n\t\tccdmakedisklabel(cs);\n\n#ifdef DEBUG\n\t/* It's actually extremely common to have unlabeled ccds. */\n\tif (ccddebug & CCDB_LABEL)\n\t\tif (errstring != NULL)\n\t\t\tprintf(\"%s: %s\\n\", cs->sc_xname, errstring);\n#endif\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_LABEL\t0x08",
      "#define DEBUG"
    ],
    "globals_used": [
      "void\tccdgetdisklabel",
      "void\tccdmakedisklabel",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s\\n\"",
            "cs->sc_xname",
            "errstring"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ccdmakedisklabel",
          "args": [
            "cs"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "ccdmakedisklabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1628-1641",
          "snippet": "void\nccdmakedisklabel(cs)\n\tstruct ccd_softc *cs;\n{\n\tstruct disklabel *lp = cs->sc_dkdev.dk_label;\n\n\t/*\n\t * For historical reasons, if there's no disklabel present\n\t * the raw partition must be marked FS_BSDFFS.\n\t */\n\tlp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;\n\n\tstrncpy(lp->d_packname, \"default label\", sizeof(lp->d_packname));\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tccdmakedisklabel",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tccdmakedisklabel;\nINLINE struct;\n\nvoid\nccdmakedisklabel(cs)\n\tstruct ccd_softc *cs;\n{\n\tstruct disklabel *lp = cs->sc_dkdev.dk_label;\n\n\t/*\n\t * For historical reasons, if there's no disklabel present\n\t * the raw partition must be marked FS_BSDFFS.\n\t */\n\tlp->d_partitions[RAW_PART].p_fstype = FS_BSDFFS;\n\n\tstrncpy(lp->d_packname, \"default label\", sizeof(lp->d_packname));\n}"
        }
      },
      {
        "call_info": {
          "callee": "readdisklabel",
          "args": [
            "CCDLABELDEV(dev)",
            "ccdstrategy",
            "cs->sc_dkdev.dk_label",
            "cs->sc_dkdev.dk_cpulabel",
            "0"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCDLABELDEV",
          "args": [
            "dev"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dkcksum",
          "args": [
            "cs->sc_dkdev.dk_label"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_packname",
            "\"fictitious\"",
            "sizeof(lp->d_packname)"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_typename",
            "\"ccd\"",
            "sizeof(lp->d_typename)"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "clp",
            "sizeof(*clp)"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "lp",
            "sizeof(*lp)"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdunit",
          "args": [
            "dev"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_LABEL\t0x08\n#define DEBUG\n\nvoid\tccdgetdisklabel;\nvoid\tccdmakedisklabel;\nINLINE struct;\n\nvoid\nccdgetdisklabel(dev)\n\tdev_t dev;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs = &ccd_softc[unit];\n\tchar *errstring;\n\tstruct disklabel *lp = cs->sc_dkdev.dk_label;\n\tstruct cpu_disklabel *clp = cs->sc_dkdev.dk_cpulabel;\n\tstruct ccdgeom *ccg = &cs->sc_geom;\n\n\tbzero(lp, sizeof(*lp));\n\tbzero(clp, sizeof(*clp));\n\n\tlp->d_secperunit = cs->sc_size;\n\tlp->d_secsize = ccg->ccg_secsize;\n\tlp->d_nsectors = ccg->ccg_nsectors;\n\tlp->d_ntracks = ccg->ccg_ntracks;\n\tlp->d_ncylinders = ccg->ccg_ncylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"ccd\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_CCD;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = cs->sc_size;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(cs->sc_dkdev.dk_label);\n\n\t/*\n\t * Call the generic disklabel extraction routine.\n\t */\n\terrstring = readdisklabel(CCDLABELDEV(dev), ccdstrategy,\n\t    cs->sc_dkdev.dk_label, cs->sc_dkdev.dk_cpulabel, 0);\n\tif (errstring)\n\t\tccdmakedisklabel(cs);\n\n#ifdef DEBUG\n\t/* It's actually extremely common to have unlabeled ccds. */\n\tif (ccddebug & CCDB_LABEL)\n\t\tif (errstring != NULL)\n\t\t\tprintf(\"%s: %s\\n\", cs->sc_xname, errstring);\n#endif\n}"
  },
  {
    "function_name": "ccdlookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1513-1565",
    "snippet": "int\nccdlookup(path, p, vpp)\n\tchar *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tif (ccddebug & (CCDB_FOLLOW|CCDB_INIT))\n\t\t\tprintf(\"ccdlookup: vn_open error = %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n#ifdef DEBUG\n\t\tif (ccddebug & (CCDB_FOLLOW|CCDB_INIT))\n\t\t\tprintf(\"ccdlookup: getattr error = %d\\n\", error);\n#endif\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_VNODE)\n\t\tvprint(\"ccdlookup: vnode info\", vp);\n#endif\n\n\tVOP_UNLOCK(vp, 0, p);\n\t*vpp = vp;\n\treturn (0);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_VNODE\t0x10",
      "#define CCDB_INIT\t0x02",
      "#define CCDB_FOLLOW\t0x01",
      "#define DEBUG"
    ],
    "globals_used": [
      "int\tccdlookup",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vp",
            "0",
            "p"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprint",
          "args": [
            "\"ccdlookup: vnode info\"",
            "vp"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "wskbddevprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "303-319",
          "snippet": "int\nwskbddevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if 0\n\tstruct wskbddev_attach_args *ap = aux;\n#endif\n\n\tif (pnp)\n\t\tprintf(\"wskbd at %s\", pnp);\n#if 0\n\tprintf(\" console %d\", ap->console);\n#endif\n\n\treturn (UNCONF);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwskbddevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if 0\n\tstruct wskbddev_attach_args *ap = aux;\n#endif\n\n\tif (pnp)\n\t\tprintf(\"wskbd at %s\", pnp);\n#if 0\n\tprintf(\" console %d\", ap->console);\n#endif\n\n\treturn (UNCONF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "vp",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vp",
            "0",
            "p"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "vp",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vp",
            "0",
            "p"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdlookup: getattr error = %d\\n\"",
            "error"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VOP_GETATTR",
          "args": [
            "vp",
            "&va",
            "p->p_ucred",
            "p"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "vp",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_UNLOCK",
          "args": [
            "vp",
            "0",
            "p"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_open",
          "args": [
            "&nd",
            "FREAD|FWRITE",
            "0"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NDINIT",
          "args": [
            "&nd",
            "LOOKUP",
            "FOLLOW",
            "UIO_USERSPACE",
            "path",
            "p"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_VNODE\t0x10\n#define CCDB_INIT\t0x02\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nint\tccdlookup;\nINLINE struct;\n\nint\nccdlookup(path, p, vpp)\n\tchar *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tif (ccddebug & (CCDB_FOLLOW|CCDB_INIT))\n\t\t\tprintf(\"ccdlookup: vn_open error = %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n#ifdef DEBUG\n\t\tif (ccddebug & (CCDB_FOLLOW|CCDB_INIT))\n\t\t\tprintf(\"ccdlookup: getattr error = %d\\n\", error);\n#endif\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_VNODE)\n\t\tvprint(\"ccdlookup: vnode info\", vp);\n#endif\n\n\tVOP_UNLOCK(vp, 0, p);\n\t*vpp = vp;\n\treturn (0);\n}"
  },
  {
    "function_name": "ccddump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1496-1506",
    "snippet": "int\nccddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nccddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}"
  },
  {
    "function_name": "ccdsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1469-1494",
    "snippet": "int\nccdsize(dev)\n\tdev_t dev;\n{\n\tstruct ccd_softc *cs;\n\tint part, size;\n\n\tif (ccdopen(dev, 0, S_IFBLK, curproc))\n\t\treturn (-1);\n\n\tcs = &ccd_softc[ccdunit(dev)];\n\tpart = DISKPART(dev);\n\n\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\treturn (-1);\n\n\tif (cs->sc_dkdev.dk_label->d_partitions[part].p_fstype != FS_SWAP)\n\t\tsize = -1;\n\telse\n\t\tsize = cs->sc_dkdev.dk_label->d_partitions[part].p_size;\n\n\tif (ccdclose(dev, 0, S_IFBLK, curproc))\n\t\treturn (-1);\n\n\treturn (size);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tccdsize",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ccdclose",
          "args": [
            "dev",
            "0",
            "S_IFBLK",
            "curproc"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "ccdclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "653-692",
          "snippet": "int\nccdclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\tint error = 0, part;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdclose(%x, %x)\\n\", dev, flags);\n#endif\n\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((error = ccdlock(cs)) != 0)\n\t\treturn (error);\n\n\tpart = DISKPART(dev);\n\n\t/* ...that much closer to allowing unconfiguration... */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tcs->sc_dkdev.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tcs->sc_dkdev.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\tcs->sc_dkdev.dk_openmask =\n\t    cs->sc_dkdev.dk_copenmask | cs->sc_dkdev.dk_bopenmask;\n\n\tccdunlock(cs);\n\treturn (0);\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define CCDB_FOLLOW\t0x01",
            "#define DEBUG"
          ],
          "globals_used": [
            "int\tccdlock",
            "void\tccdunlock",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nint\tccdlock;\nvoid\tccdunlock;\nINLINE struct;\n\nint\nccdclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\tint error = 0, part;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdclose(%x, %x)\\n\", dev, flags);\n#endif\n\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((error = ccdlock(cs)) != 0)\n\t\treturn (error);\n\n\tpart = DISKPART(dev);\n\n\t/* ...that much closer to allowing unconfiguration... */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tcs->sc_dkdev.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tcs->sc_dkdev.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\tcs->sc_dkdev.dk_openmask =\n\t    cs->sc_dkdev.dk_copenmask | cs->sc_dkdev.dk_bopenmask;\n\n\tccdunlock(cs);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdunit",
          "args": [
            "dev"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdopen",
          "args": [
            "dev",
            "0",
            "S_IFBLK",
            "curproc"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "ccdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "589-650",
          "snippet": "int\nccdopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\tstruct disklabel *lp;\n\tint error = 0, part, pmask;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdopen(%x, %x)\\n\", dev, flags);\n#endif\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((error = ccdlock(cs)) != 0)\n\t\treturn (error);\n\n\tlp = cs->sc_dkdev.dk_label;\n\n\tpart = DISKPART(dev);\n\tpmask = (1 << part);\n\n\t/*\n\t * If we're initialized, check to see if there are any other\n\t * open partitions.  If not, then it's safe to update\n\t * the in-core disklabel.\n\t */\n\tif ((cs->sc_flags & CCDF_INITED) && (cs->sc_dkdev.dk_openmask == 0))\n\t\tccdgetdisklabel(dev);\n\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART) {\n\t\tif (((cs->sc_flags & CCDF_INITED) == 0) ||\n\t\t    ((part >= lp->d_npartitions) ||\n\t\t    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {\n\t\t\terror = ENXIO;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Prevent our unit from being unconfigured while open. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tcs->sc_dkdev.dk_copenmask |= pmask;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tcs->sc_dkdev.dk_bopenmask |= pmask;\n\t\tbreak;\n\t}\n\tcs->sc_dkdev.dk_openmask =\n\t    cs->sc_dkdev.dk_copenmask | cs->sc_dkdev.dk_bopenmask;\n\n done:\n\tccdunlock(cs);\n\treturn (error);\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define CCDB_FOLLOW\t0x01",
            "#define DEBUG"
          ],
          "globals_used": [
            "void\tccdgetdisklabel",
            "int\tccdlock",
            "void\tccdunlock",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nvoid\tccdgetdisklabel;\nint\tccdlock;\nvoid\tccdunlock;\nINLINE struct;\n\nint\nccdopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\tstruct disklabel *lp;\n\tint error = 0, part, pmask;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdopen(%x, %x)\\n\", dev, flags);\n#endif\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((error = ccdlock(cs)) != 0)\n\t\treturn (error);\n\n\tlp = cs->sc_dkdev.dk_label;\n\n\tpart = DISKPART(dev);\n\tpmask = (1 << part);\n\n\t/*\n\t * If we're initialized, check to see if there are any other\n\t * open partitions.  If not, then it's safe to update\n\t * the in-core disklabel.\n\t */\n\tif ((cs->sc_flags & CCDF_INITED) && (cs->sc_dkdev.dk_openmask == 0))\n\t\tccdgetdisklabel(dev);\n\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART) {\n\t\tif (((cs->sc_flags & CCDF_INITED) == 0) ||\n\t\t    ((part >= lp->d_npartitions) ||\n\t\t    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {\n\t\t\terror = ENXIO;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Prevent our unit from being unconfigured while open. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tcs->sc_dkdev.dk_copenmask |= pmask;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tcs->sc_dkdev.dk_bopenmask |= pmask;\n\t\tbreak;\n\t}\n\tcs->sc_dkdev.dk_openmask =\n\t    cs->sc_dkdev.dk_copenmask | cs->sc_dkdev.dk_bopenmask;\n\n done:\n\tccdunlock(cs);\n\treturn (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tccdsize;\nINLINE struct;\n\nint\nccdsize(dev)\n\tdev_t dev;\n{\n\tstruct ccd_softc *cs;\n\tint part, size;\n\n\tif (ccdopen(dev, 0, S_IFBLK, curproc))\n\t\treturn (-1);\n\n\tcs = &ccd_softc[ccdunit(dev)];\n\tpart = DISKPART(dev);\n\n\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\treturn (-1);\n\n\tif (cs->sc_dkdev.dk_label->d_partitions[part].p_fstype != FS_SWAP)\n\t\tsize = -1;\n\telse\n\t\tsize = cs->sc_dkdev.dk_label->d_partitions[part].p_size;\n\n\tif (ccdclose(dev, 0, S_IFBLK, curproc))\n\t\treturn (-1);\n\n\treturn (size);\n}"
  },
  {
    "function_name": "ccdioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1181-1467",
    "snippet": "int\nccdioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = ccdunit(dev);\n\tint i, j, lookedup = 0, error = 0;\n\tint part, pmask, s;\n\tstruct ccd_softc *cs;\n\tstruct ccd_ioctl *ccio = (struct ccd_ioctl *)data;\n\tstruct ccddevice ccd;\n\tchar **cpp;\n\tstruct vnode **vpp;\n\tvaddr_t min, max;\n\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tbzero(&ccd, sizeof(ccd));\n\n\tswitch (cmd) {\n\tcase CCDIOCSET:\n\t\tif (cs->sc_flags & CCDF_INITED)\n\t\t\treturn (EBUSY);\n\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EBADF);\n\n\t\tif ((error = ccdlock(cs)) != 0)\n\t\t\treturn (error);\n\n\t\t/* Fill in some important bits. */\n\t\tccd.ccd_unit = unit;\n\t\tccd.ccd_interleave = ccio->ccio_ileave;\n\t\tccd.ccd_flags = ccio->ccio_flags & CCDF_USERMASK;\n\n\t\t/* XXX the new code is unstable still */\n\t\tccd.ccd_flags |= CCDF_OLD;\n\n\t\t/*\n\t\t * Interleaving which is not a multiple of the click size\n\t\t * must use the old I/O code (by design), as must mirror\n\t\t * setups (until implemented in the new code).\n\t\t */\n\t\tif (ccio->ccio_ileave % (CLBYTES / DEV_BSIZE) != 0 ||\n\t\t    (ccd.ccd_flags & CCDF_MIRROR))\n\t\t\tccd.ccd_flags |= CCDF_OLD;\n\n\t\t/*\n\t\t * Allocate space for and copy in the array of\n\t\t * componet pathnames and device numbers.\n\t\t */\n\t\tcpp = malloc(ccio->ccio_ndisks * sizeof(char *),\n\t\t    M_DEVBUF, M_WAITOK);\n\t\tvpp = malloc(ccio->ccio_ndisks * sizeof(struct vnode *),\n\t\t    M_DEVBUF, M_WAITOK);\n\n\t\terror = copyin((caddr_t)ccio->ccio_disks, (caddr_t)cpp,\n\t\t    ccio->ccio_ndisks * sizeof(char **));\n\t\tif (error) {\n\t\t\tfree(vpp, M_DEVBUF);\n\t\t\tfree(cpp, M_DEVBUF);\n\t\t\tccdunlock(cs);\n\t\t\treturn (error);\n\t\t}\n\n#ifdef DEBUG\n\t\tif (ccddebug & CCDB_INIT)\n\t\t\tfor (i = 0; i < ccio->ccio_ndisks; ++i)\n\t\t\t\tprintf(\"ccdioctl: component %d: 0x%p\\n\",\n\t\t\t\t    i, cpp[i]);\n#endif\n\n\t\tfor (i = 0; i < ccio->ccio_ndisks; ++i) {\n#ifdef DEBUG\n\t\t\tif (ccddebug & CCDB_INIT)\n\t\t\t\tprintf(\"ccdioctl: lookedup = %d\\n\", lookedup);\n#endif\n\t\t\tif ((error = ccdlookup(cpp[i], p, &vpp[i])) != 0) {\n\t\t\t\tfor (j = 0; j < lookedup; ++j)\n\t\t\t\t\t(void)vn_close(vpp[j], FREAD|FWRITE,\n\t\t\t\t\t    p->p_ucred, p);\n\t\t\t\tfree(vpp, M_DEVBUF);\n\t\t\t\tfree(cpp, M_DEVBUF);\n\t\t\t\tccdunlock(cs);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t\t++lookedup;\n\t\t}\n\t\tccd.ccd_cpp = cpp;\n\t\tccd.ccd_vpp = vpp;\n\t\tccd.ccd_ndev = ccio->ccio_ndisks;\n\n\t\t/*\n\t\t * Initialize the ccd.  Fills in the softc for us.\n\t\t */\n\t\tif ((error = ccdinit(&ccd, cpp, p)) != 0) {\n\t\t\tfor (j = 0; j < lookedup; ++j)\n\t\t\t\t(void)vn_close(vpp[j], FREAD|FWRITE,\n\t\t\t\t    p->p_ucred, p);\n\t\t\tbzero(&ccd_softc[unit], sizeof(struct ccd_softc));\n\t\t\tfree(vpp, M_DEVBUF);\n\t\t\tfree(cpp, M_DEVBUF);\n\t\t\tccdunlock(cs);\n\t\t\treturn (error);\n\t\t}\n\n\t\t/*\n\t\t * The ccd has been successfully initialized, so\n\t\t * we can place it into the array.  Don't try to\n\t\t * read the disklabel until the disk has been attached,\n\t\t * because space for the disklabel is allocated\n\t\t * in disk_attach();\n\t\t */\n\t\tbcopy(&ccd, &ccddevs[unit], sizeof(ccd));\n\t\tccio->ccio_unit = unit;\n\t\tccio->ccio_size = cs->sc_size;\n\n\t\t/*\n\t\t * If we use the optimized protocol we need some kvm space\n\t\t * for the component buffers.  Allocate it here.\n\t\t *\n\t\t * XXX I'd like to have a more dynamic way of acquiring kvm\n\t\t * XXX space, but that is problematic as we are not allowed\n\t\t * XXX to lock the kernel_map in interrupt context.  It is\n\t\t * XXX doable via a freelist implementation though.\n\t\t */\n\t\tif (!ccdmap && !(ccd.ccd_flags & CCDF_OLD))\n#if defined(UVM)\n\t\t\tccdmap = uvm_km_suballoc(kernel_map, &min, &max,\n\t\t\t    CCD_CLUSTERS * MAXBSIZE, FALSE, FALSE, NULL);\n#else\n\t\t\tccdmap = kmem_suballoc(kernel_map, &min, &max,\n\t\t\t    CCD_CLUSTERS * MAXBSIZE, FALSE);\n#endif\n\n\t\t/* Attach the disk. */\n\t\tcs->sc_dkdev.dk_name = cs->sc_xname;\n\t\tdisk_attach(&cs->sc_dkdev);\n\n\t\t/* Try and read the disklabel. */\n\t\tccdgetdisklabel(dev);\n\n\t\tccdunlock(cs);\n\n\t\tbreak;\n\n\tcase CCDIOCCLR:\n\t\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EBADF);\n\n\t\tif ((error = ccdlock(cs)) != 0)\n\t\t\treturn (error);\n\n\t\t/*\n\t\t * Don't unconfigure if any other partitions are open\n\t\t * or if both the character and block flavors of this\n\t\t * partition are open.\n\t\t */\n\t\tpart = DISKPART(dev);\n\t\tpmask = (1 << part);\n\t\tif ((cs->sc_dkdev.dk_openmask & ~pmask) ||\n\t\t    ((cs->sc_dkdev.dk_bopenmask & pmask) &&\n\t\t    (cs->sc_dkdev.dk_copenmask & pmask))) {\n\t\t\tccdunlock(cs);\n\t\t\treturn (EBUSY);\n\t\t}\n\n\t\t/*\n\t\t * Free ccd_softc information and clear entry.\n\t\t */\n\n\t\t/* Close the components and free their pathnames. */\n\t\tfor (i = 0; i < cs->sc_nccdisks; ++i) {\n\t\t\t/*\n\t\t\t * XXX: this close could potentially fail and\n\t\t\t * cause Bad Things.  Maybe we need to force\n\t\t\t * the close to happen?\n\t\t\t */\n#ifdef DEBUG\n\t\t\tif (ccddebug & CCDB_VNODE)\n\t\t\t\tvprint(\"CCDIOCCLR: vnode info\",\n\t\t\t\t    cs->sc_cinfo[i].ci_vp);\n#endif\n\t\t\t(void)vn_close(cs->sc_cinfo[i].ci_vp, FREAD|FWRITE,\n\t\t\t    p->p_ucred, p);\n\t\t\tfree(cs->sc_cinfo[i].ci_path, M_DEVBUF);\n\t\t}\n\n\t\t/* Free interleave index. */\n\t\tfor (i = 0; cs->sc_itable[i].ii_ndisk; ++i)\n\t\t\tfree(cs->sc_itable[i].ii_index, M_DEVBUF);\n\n\t\t/* Free component info and interleave table. */\n\t\tfree(cs->sc_cinfo, M_DEVBUF);\n\t\tfree(cs->sc_itable, M_DEVBUF);\n\t\tcs->sc_flags &= ~CCDF_INITED;\n\n\t\t/*\n\t\t * Free ccddevice information and clear entry.\n\t\t */\n\t\tfree(ccddevs[unit].ccd_cpp, M_DEVBUF);\n\t\tfree(ccddevs[unit].ccd_vpp, M_DEVBUF);\n\t\tbcopy(&ccd, &ccddevs[unit], sizeof(ccd));\n\n\t\t/* Detatch the disk. */\n\t\tdisk_detach(&cs->sc_dkdev);\n\n\t\t/* This must be atomic. */\n\t\ts = splhigh();\n\t\tccdunlock(cs);\n\t\tbzero(cs, sizeof(struct ccd_softc));\n\t\tsplx(s);\n\n\t\tbreak;\n\n\tcase DIOCGDINFO:\n\t\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\t*(struct disklabel *)data = *(cs->sc_dkdev.dk_label);\n\t\tbreak;\n\n\tcase DIOCGPART:\n\t\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\t((struct partinfo *)data)->disklab = cs->sc_dkdev.dk_label;\n\t\t((struct partinfo *)data)->part =\n\t\t    &cs->sc_dkdev.dk_label->d_partitions[DISKPART(dev)];\n\t\tbreak;\n\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EBADF);\n\n\t\tif ((error = ccdlock(cs)) != 0)\n\t\t\treturn (error);\n\n\t\tcs->sc_flags |= CCDF_LABELLING;\n\n\t\terror = setdisklabel(cs->sc_dkdev.dk_label,\n\t\t    (struct disklabel *)data, 0, cs->sc_dkdev.dk_cpulabel);\n\t\tif (error == 0) {\n\t\t\tif (cmd == DIOCWDINFO)\n\t\t\t\terror = writedisklabel(CCDLABELDEV(dev),\n\t\t\t\t    ccdstrategy, cs->sc_dkdev.dk_label,\n\t\t\t\t    cs->sc_dkdev.dk_cpulabel);\n\t\t}\n\n\t\tcs->sc_flags &= ~CCDF_LABELLING;\n\n\t\tccdunlock(cs);\n\n\t\tif (error)\n\t\t\treturn (error);\n\t\tbreak;\n\n\tcase DIOCWLABEL:\n\t\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EBADF);\n\t\tif (*(int *)data != 0)\n\t\t\tcs->sc_flags |= CCDF_WLABEL;\n\t\telse\n\t\t\tcs->sc_flags &= ~CCDF_WLABEL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (ENOTTY);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_VNODE\t0x10",
      "#define CCDB_INIT\t0x02",
      "#define DEBUG",
      "#define CCD_CLUSTERS 16"
    ],
    "globals_used": [
      "int\tccdinit",
      "int\tccdlookup",
      "void\tccdgetdisklabel",
      "int\tccdlock",
      "void\tccdunlock",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ccdunlock",
          "args": [
            "cs"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "ccdunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1667-1677",
          "snippet": "void\nccdunlock(cs)\n\tstruct ccd_softc *cs;\n{\n\n\tcs->sc_flags &= ~CCDF_LOCKED;\n\tif ((cs->sc_flags & CCDF_WANTED) != 0) {\n\t\tcs->sc_flags &= ~CCDF_WANTED;\n\t\twakeup(cs);\n\t}\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tccdunlock",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tccdunlock;\nINLINE struct;\n\nvoid\nccdunlock(cs)\n\tstruct ccd_softc *cs;\n{\n\n\tcs->sc_flags &= ~CCDF_LOCKED;\n\tif ((cs->sc_flags & CCDF_WANTED) != 0) {\n\t\tcs->sc_flags &= ~CCDF_WANTED;\n\t\twakeup(cs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "writedisklabel",
          "args": [
            "CCDLABELDEV(dev)",
            "ccdstrategy",
            "cs->sc_dkdev.dk_label",
            "cs->sc_dkdev.dk_cpulabel"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CCDLABELDEV",
          "args": [
            "dev"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setdisklabel",
          "args": [
            "cs->sc_dkdev.dk_label",
            "(struct disklabel *)data",
            "0",
            "cs->sc_dkdev.dk_cpulabel"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdlock",
          "args": [
            "cs"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "ccdlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1649-1662",
          "snippet": "int\nccdlock(cs)\n\tstruct ccd_softc *cs;\n{\n\tint error;\n\n\twhile ((cs->sc_flags & CCDF_LOCKED) != 0) {\n\t\tcs->sc_flags |= CCDF_WANTED;\n\t\tif ((error = tsleep(cs, PRIBIO | PCATCH, \"ccdlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tcs->sc_flags |= CCDF_LOCKED;\n\treturn (0);\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tccdlock",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tccdlock;\nINLINE struct;\n\nint\nccdlock(cs)\n\tstruct ccd_softc *cs;\n{\n\tint error;\n\n\twhile ((cs->sc_flags & CCDF_LOCKED) != 0) {\n\t\tcs->sc_flags |= CCDF_WANTED;\n\t\tif ((error = tsleep(cs, PRIBIO | PCATCH, \"ccdlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tcs->sc_flags |= CCDF_LOCKED;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "cs",
            "sizeof(struct ccd_softc)"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_detach",
          "args": [
            "&cs->sc_dkdev"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "&ccd",
            "&ccddevs[unit]",
            "sizeof(ccd)"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ccddevs[unit].ccd_vpp",
            "M_DEVBUF"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "audio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "493-503",
          "snippet": "void\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "cs->sc_cinfo[i].ci_vp",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprint",
          "args": [
            "\"CCDIOCCLR: vnode info\"",
            "cs->sc_cinfo[i].ci_vp"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "wskbddevprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "303-319",
          "snippet": "int\nwskbddevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if 0\n\tstruct wskbddev_attach_args *ap = aux;\n#endif\n\n\tif (pnp)\n\t\tprintf(\"wskbd at %s\", pnp);\n#if 0\n\tprintf(\" console %d\", ap->console);\n#endif\n\n\treturn (UNCONF);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwskbddevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if 0\n\tstruct wskbddev_attach_args *ap = aux;\n#endif\n\n\tif (pnp)\n\t\tprintf(\"wskbd at %s\", pnp);\n#if 0\n\tprintf(\" console %d\", ap->console);\n#endif\n\n\treturn (UNCONF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdgetdisklabel",
          "args": [
            "dev"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "ccdgetdisklabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1571-1622",
          "snippet": "void\nccdgetdisklabel(dev)\n\tdev_t dev;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs = &ccd_softc[unit];\n\tchar *errstring;\n\tstruct disklabel *lp = cs->sc_dkdev.dk_label;\n\tstruct cpu_disklabel *clp = cs->sc_dkdev.dk_cpulabel;\n\tstruct ccdgeom *ccg = &cs->sc_geom;\n\n\tbzero(lp, sizeof(*lp));\n\tbzero(clp, sizeof(*clp));\n\n\tlp->d_secperunit = cs->sc_size;\n\tlp->d_secsize = ccg->ccg_secsize;\n\tlp->d_nsectors = ccg->ccg_nsectors;\n\tlp->d_ntracks = ccg->ccg_ntracks;\n\tlp->d_ncylinders = ccg->ccg_ncylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"ccd\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_CCD;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = cs->sc_size;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(cs->sc_dkdev.dk_label);\n\n\t/*\n\t * Call the generic disklabel extraction routine.\n\t */\n\terrstring = readdisklabel(CCDLABELDEV(dev), ccdstrategy,\n\t    cs->sc_dkdev.dk_label, cs->sc_dkdev.dk_cpulabel, 0);\n\tif (errstring)\n\t\tccdmakedisklabel(cs);\n\n#ifdef DEBUG\n\t/* It's actually extremely common to have unlabeled ccds. */\n\tif (ccddebug & CCDB_LABEL)\n\t\tif (errstring != NULL)\n\t\t\tprintf(\"%s: %s\\n\", cs->sc_xname, errstring);\n#endif\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define CCDB_LABEL\t0x08",
            "#define DEBUG"
          ],
          "globals_used": [
            "void\tccdgetdisklabel",
            "void\tccdmakedisklabel",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_LABEL\t0x08\n#define DEBUG\n\nvoid\tccdgetdisklabel;\nvoid\tccdmakedisklabel;\nINLINE struct;\n\nvoid\nccdgetdisklabel(dev)\n\tdev_t dev;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs = &ccd_softc[unit];\n\tchar *errstring;\n\tstruct disklabel *lp = cs->sc_dkdev.dk_label;\n\tstruct cpu_disklabel *clp = cs->sc_dkdev.dk_cpulabel;\n\tstruct ccdgeom *ccg = &cs->sc_geom;\n\n\tbzero(lp, sizeof(*lp));\n\tbzero(clp, sizeof(*clp));\n\n\tlp->d_secperunit = cs->sc_size;\n\tlp->d_secsize = ccg->ccg_secsize;\n\tlp->d_nsectors = ccg->ccg_nsectors;\n\tlp->d_ntracks = ccg->ccg_ntracks;\n\tlp->d_ncylinders = ccg->ccg_ncylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"ccd\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_CCD;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = cs->sc_size;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(cs->sc_dkdev.dk_label);\n\n\t/*\n\t * Call the generic disklabel extraction routine.\n\t */\n\terrstring = readdisklabel(CCDLABELDEV(dev), ccdstrategy,\n\t    cs->sc_dkdev.dk_label, cs->sc_dkdev.dk_cpulabel, 0);\n\tif (errstring)\n\t\tccdmakedisklabel(cs);\n\n#ifdef DEBUG\n\t/* It's actually extremely common to have unlabeled ccds. */\n\tif (ccddebug & CCDB_LABEL)\n\t\tif (errstring != NULL)\n\t\t\tprintf(\"%s: %s\\n\", cs->sc_xname, errstring);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_attach",
          "args": [
            "&cs->sc_dkdev"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_suballoc",
          "args": [
            "kernel_map",
            "&min",
            "&max",
            "CCD_CLUSTERS * MAXBSIZE",
            "FALSE"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uvm_km_suballoc",
          "args": [
            "kernel_map",
            "&min",
            "&max",
            "CCD_CLUSTERS * MAXBSIZE",
            "FALSE",
            "FALSE",
            "NULL"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&ccd_softc[unit]",
            "sizeof(struct ccd_softc)"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "vpp[j]",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdinit",
          "args": [
            "&ccd",
            "cpp",
            "p"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vn_close",
          "args": [
            "vpp[j]",
            "FREAD|FWRITE",
            "p->p_ucred",
            "p"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdlookup",
          "args": [
            "cpp[i]",
            "p",
            "&vpp[i]"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "ccdlookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1513-1565",
          "snippet": "int\nccdlookup(path, p, vpp)\n\tchar *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tif (ccddebug & (CCDB_FOLLOW|CCDB_INIT))\n\t\t\tprintf(\"ccdlookup: vn_open error = %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n#ifdef DEBUG\n\t\tif (ccddebug & (CCDB_FOLLOW|CCDB_INIT))\n\t\t\tprintf(\"ccdlookup: getattr error = %d\\n\", error);\n#endif\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_VNODE)\n\t\tvprint(\"ccdlookup: vnode info\", vp);\n#endif\n\n\tVOP_UNLOCK(vp, 0, p);\n\t*vpp = vp;\n\treturn (0);\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define CCDB_VNODE\t0x10",
            "#define CCDB_INIT\t0x02",
            "#define CCDB_FOLLOW\t0x01",
            "#define DEBUG"
          ],
          "globals_used": [
            "int\tccdlookup",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_VNODE\t0x10\n#define CCDB_INIT\t0x02\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nint\tccdlookup;\nINLINE struct;\n\nint\nccdlookup(path, p, vpp)\n\tchar *path;\n\tstruct proc *p;\n\tstruct vnode **vpp;\t/* result */\n{\n\tstruct nameidata nd;\n\tstruct vnode *vp;\n\tstruct vattr va;\n\tint error;\n\n\tNDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, path, p);\n\tif ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {\n#ifdef DEBUG\n\t\tif (ccddebug & (CCDB_FOLLOW|CCDB_INIT))\n\t\t\tprintf(\"ccdlookup: vn_open error = %d\\n\", error);\n#endif\n\t\treturn (error);\n\t}\n\tvp = nd.ni_vp;\n\n\tif (vp->v_usecount > 1) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (EBUSY);\n\t}\n\n\tif ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) != 0) {\n#ifdef DEBUG\n\t\tif (ccddebug & (CCDB_FOLLOW|CCDB_INIT))\n\t\t\tprintf(\"ccdlookup: getattr error = %d\\n\", error);\n#endif\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (error);\n\t}\n\n\t/* XXX: eventually we should handle VREG, too. */\n\tif (va.va_type != VBLK) {\n\t\tVOP_UNLOCK(vp, 0, p);\n\t\t(void)vn_close(vp, FREAD|FWRITE, p->p_ucred, p);\n\t\treturn (ENOTBLK);\n\t}\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_VNODE)\n\t\tvprint(\"ccdlookup: vnode info\", vp);\n#endif\n\n\tVOP_UNLOCK(vp, 0, p);\n\t*vpp = vp;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdioctl: lookedup = %d\\n\"",
            "lookedup"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "(caddr_t)ccio->ccio_disks",
            "(caddr_t)cpp",
            "ccio->ccio_ndisks * sizeof(char **)"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "ccio->ccio_ndisks * sizeof(struct vnode *)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&ccd",
            "sizeof(ccd)"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdunit",
          "args": [
            "dev"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_VNODE\t0x10\n#define CCDB_INIT\t0x02\n#define DEBUG\n#define CCD_CLUSTERS 16\n\nint\tccdinit;\nint\tccdlookup;\nvoid\tccdgetdisklabel;\nint\tccdlock;\nvoid\tccdunlock;\nINLINE struct;\n\nint\nccdioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint unit = ccdunit(dev);\n\tint i, j, lookedup = 0, error = 0;\n\tint part, pmask, s;\n\tstruct ccd_softc *cs;\n\tstruct ccd_ioctl *ccio = (struct ccd_ioctl *)data;\n\tstruct ccddevice ccd;\n\tchar **cpp;\n\tstruct vnode **vpp;\n\tvaddr_t min, max;\n\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tbzero(&ccd, sizeof(ccd));\n\n\tswitch (cmd) {\n\tcase CCDIOCSET:\n\t\tif (cs->sc_flags & CCDF_INITED)\n\t\t\treturn (EBUSY);\n\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EBADF);\n\n\t\tif ((error = ccdlock(cs)) != 0)\n\t\t\treturn (error);\n\n\t\t/* Fill in some important bits. */\n\t\tccd.ccd_unit = unit;\n\t\tccd.ccd_interleave = ccio->ccio_ileave;\n\t\tccd.ccd_flags = ccio->ccio_flags & CCDF_USERMASK;\n\n\t\t/* XXX the new code is unstable still */\n\t\tccd.ccd_flags |= CCDF_OLD;\n\n\t\t/*\n\t\t * Interleaving which is not a multiple of the click size\n\t\t * must use the old I/O code (by design), as must mirror\n\t\t * setups (until implemented in the new code).\n\t\t */\n\t\tif (ccio->ccio_ileave % (CLBYTES / DEV_BSIZE) != 0 ||\n\t\t    (ccd.ccd_flags & CCDF_MIRROR))\n\t\t\tccd.ccd_flags |= CCDF_OLD;\n\n\t\t/*\n\t\t * Allocate space for and copy in the array of\n\t\t * componet pathnames and device numbers.\n\t\t */\n\t\tcpp = malloc(ccio->ccio_ndisks * sizeof(char *),\n\t\t    M_DEVBUF, M_WAITOK);\n\t\tvpp = malloc(ccio->ccio_ndisks * sizeof(struct vnode *),\n\t\t    M_DEVBUF, M_WAITOK);\n\n\t\terror = copyin((caddr_t)ccio->ccio_disks, (caddr_t)cpp,\n\t\t    ccio->ccio_ndisks * sizeof(char **));\n\t\tif (error) {\n\t\t\tfree(vpp, M_DEVBUF);\n\t\t\tfree(cpp, M_DEVBUF);\n\t\t\tccdunlock(cs);\n\t\t\treturn (error);\n\t\t}\n\n#ifdef DEBUG\n\t\tif (ccddebug & CCDB_INIT)\n\t\t\tfor (i = 0; i < ccio->ccio_ndisks; ++i)\n\t\t\t\tprintf(\"ccdioctl: component %d: 0x%p\\n\",\n\t\t\t\t    i, cpp[i]);\n#endif\n\n\t\tfor (i = 0; i < ccio->ccio_ndisks; ++i) {\n#ifdef DEBUG\n\t\t\tif (ccddebug & CCDB_INIT)\n\t\t\t\tprintf(\"ccdioctl: lookedup = %d\\n\", lookedup);\n#endif\n\t\t\tif ((error = ccdlookup(cpp[i], p, &vpp[i])) != 0) {\n\t\t\t\tfor (j = 0; j < lookedup; ++j)\n\t\t\t\t\t(void)vn_close(vpp[j], FREAD|FWRITE,\n\t\t\t\t\t    p->p_ucred, p);\n\t\t\t\tfree(vpp, M_DEVBUF);\n\t\t\t\tfree(cpp, M_DEVBUF);\n\t\t\t\tccdunlock(cs);\n\t\t\t\treturn (error);\n\t\t\t}\n\t\t\t++lookedup;\n\t\t}\n\t\tccd.ccd_cpp = cpp;\n\t\tccd.ccd_vpp = vpp;\n\t\tccd.ccd_ndev = ccio->ccio_ndisks;\n\n\t\t/*\n\t\t * Initialize the ccd.  Fills in the softc for us.\n\t\t */\n\t\tif ((error = ccdinit(&ccd, cpp, p)) != 0) {\n\t\t\tfor (j = 0; j < lookedup; ++j)\n\t\t\t\t(void)vn_close(vpp[j], FREAD|FWRITE,\n\t\t\t\t    p->p_ucred, p);\n\t\t\tbzero(&ccd_softc[unit], sizeof(struct ccd_softc));\n\t\t\tfree(vpp, M_DEVBUF);\n\t\t\tfree(cpp, M_DEVBUF);\n\t\t\tccdunlock(cs);\n\t\t\treturn (error);\n\t\t}\n\n\t\t/*\n\t\t * The ccd has been successfully initialized, so\n\t\t * we can place it into the array.  Don't try to\n\t\t * read the disklabel until the disk has been attached,\n\t\t * because space for the disklabel is allocated\n\t\t * in disk_attach();\n\t\t */\n\t\tbcopy(&ccd, &ccddevs[unit], sizeof(ccd));\n\t\tccio->ccio_unit = unit;\n\t\tccio->ccio_size = cs->sc_size;\n\n\t\t/*\n\t\t * If we use the optimized protocol we need some kvm space\n\t\t * for the component buffers.  Allocate it here.\n\t\t *\n\t\t * XXX I'd like to have a more dynamic way of acquiring kvm\n\t\t * XXX space, but that is problematic as we are not allowed\n\t\t * XXX to lock the kernel_map in interrupt context.  It is\n\t\t * XXX doable via a freelist implementation though.\n\t\t */\n\t\tif (!ccdmap && !(ccd.ccd_flags & CCDF_OLD))\n#if defined(UVM)\n\t\t\tccdmap = uvm_km_suballoc(kernel_map, &min, &max,\n\t\t\t    CCD_CLUSTERS * MAXBSIZE, FALSE, FALSE, NULL);\n#else\n\t\t\tccdmap = kmem_suballoc(kernel_map, &min, &max,\n\t\t\t    CCD_CLUSTERS * MAXBSIZE, FALSE);\n#endif\n\n\t\t/* Attach the disk. */\n\t\tcs->sc_dkdev.dk_name = cs->sc_xname;\n\t\tdisk_attach(&cs->sc_dkdev);\n\n\t\t/* Try and read the disklabel. */\n\t\tccdgetdisklabel(dev);\n\n\t\tccdunlock(cs);\n\n\t\tbreak;\n\n\tcase CCDIOCCLR:\n\t\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EBADF);\n\n\t\tif ((error = ccdlock(cs)) != 0)\n\t\t\treturn (error);\n\n\t\t/*\n\t\t * Don't unconfigure if any other partitions are open\n\t\t * or if both the character and block flavors of this\n\t\t * partition are open.\n\t\t */\n\t\tpart = DISKPART(dev);\n\t\tpmask = (1 << part);\n\t\tif ((cs->sc_dkdev.dk_openmask & ~pmask) ||\n\t\t    ((cs->sc_dkdev.dk_bopenmask & pmask) &&\n\t\t    (cs->sc_dkdev.dk_copenmask & pmask))) {\n\t\t\tccdunlock(cs);\n\t\t\treturn (EBUSY);\n\t\t}\n\n\t\t/*\n\t\t * Free ccd_softc information and clear entry.\n\t\t */\n\n\t\t/* Close the components and free their pathnames. */\n\t\tfor (i = 0; i < cs->sc_nccdisks; ++i) {\n\t\t\t/*\n\t\t\t * XXX: this close could potentially fail and\n\t\t\t * cause Bad Things.  Maybe we need to force\n\t\t\t * the close to happen?\n\t\t\t */\n#ifdef DEBUG\n\t\t\tif (ccddebug & CCDB_VNODE)\n\t\t\t\tvprint(\"CCDIOCCLR: vnode info\",\n\t\t\t\t    cs->sc_cinfo[i].ci_vp);\n#endif\n\t\t\t(void)vn_close(cs->sc_cinfo[i].ci_vp, FREAD|FWRITE,\n\t\t\t    p->p_ucred, p);\n\t\t\tfree(cs->sc_cinfo[i].ci_path, M_DEVBUF);\n\t\t}\n\n\t\t/* Free interleave index. */\n\t\tfor (i = 0; cs->sc_itable[i].ii_ndisk; ++i)\n\t\t\tfree(cs->sc_itable[i].ii_index, M_DEVBUF);\n\n\t\t/* Free component info and interleave table. */\n\t\tfree(cs->sc_cinfo, M_DEVBUF);\n\t\tfree(cs->sc_itable, M_DEVBUF);\n\t\tcs->sc_flags &= ~CCDF_INITED;\n\n\t\t/*\n\t\t * Free ccddevice information and clear entry.\n\t\t */\n\t\tfree(ccddevs[unit].ccd_cpp, M_DEVBUF);\n\t\tfree(ccddevs[unit].ccd_vpp, M_DEVBUF);\n\t\tbcopy(&ccd, &ccddevs[unit], sizeof(ccd));\n\n\t\t/* Detatch the disk. */\n\t\tdisk_detach(&cs->sc_dkdev);\n\n\t\t/* This must be atomic. */\n\t\ts = splhigh();\n\t\tccdunlock(cs);\n\t\tbzero(cs, sizeof(struct ccd_softc));\n\t\tsplx(s);\n\n\t\tbreak;\n\n\tcase DIOCGDINFO:\n\t\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\t*(struct disklabel *)data = *(cs->sc_dkdev.dk_label);\n\t\tbreak;\n\n\tcase DIOCGPART:\n\t\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\t((struct partinfo *)data)->disklab = cs->sc_dkdev.dk_label;\n\t\t((struct partinfo *)data)->part =\n\t\t    &cs->sc_dkdev.dk_label->d_partitions[DISKPART(dev)];\n\t\tbreak;\n\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EBADF);\n\n\t\tif ((error = ccdlock(cs)) != 0)\n\t\t\treturn (error);\n\n\t\tcs->sc_flags |= CCDF_LABELLING;\n\n\t\terror = setdisklabel(cs->sc_dkdev.dk_label,\n\t\t    (struct disklabel *)data, 0, cs->sc_dkdev.dk_cpulabel);\n\t\tif (error == 0) {\n\t\t\tif (cmd == DIOCWDINFO)\n\t\t\t\terror = writedisklabel(CCDLABELDEV(dev),\n\t\t\t\t    ccdstrategy, cs->sc_dkdev.dk_label,\n\t\t\t\t    cs->sc_dkdev.dk_cpulabel);\n\t\t}\n\n\t\tcs->sc_flags &= ~CCDF_LABELLING;\n\n\t\tccdunlock(cs);\n\n\t\tif (error)\n\t\t\treturn (error);\n\t\tbreak;\n\n\tcase DIOCWLABEL:\n\t\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\t\treturn (ENXIO);\n\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EBADF);\n\t\tif (*(int *)data != 0)\n\t\t\tcs->sc_flags |= CCDF_WLABEL;\n\t\telse\n\t\t\tcs->sc_flags &= ~CCDF_WLABEL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (ENOTTY);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ccdwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1153-1179",
    "snippet": "int\nccdwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdwrite(%x, %p)\\n\", dev, uio);\n#endif\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\treturn (ENXIO);\n\n\t/*\n\t * XXX: It's not clear that using minphys() is completely safe,\n\t * in particular, for raw I/O.  Underlying devices might have some\n\t * non-obvious limits, because of the copy to user-space.\n\t */\n\treturn (physio(ccdstrategy, NULL, dev, B_WRITE, minphys, uio));\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_FOLLOW\t0x01",
      "#define DEBUG"
    ],
    "globals_used": [
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "ccdstrategy",
            "NULL",
            "dev",
            "B_WRITE",
            "minphys",
            "uio"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdwrite(%x, %p)\\n\"",
            "dev",
            "uio"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ccdunit",
          "args": [
            "dev"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nINLINE struct;\n\nint\nccdwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdwrite(%x, %p)\\n\", dev, uio);\n#endif\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\treturn (ENXIO);\n\n\t/*\n\t * XXX: It's not clear that using minphys() is completely safe,\n\t * in particular, for raw I/O.  Underlying devices might have some\n\t * non-obvious limits, because of the copy to user-space.\n\t */\n\treturn (physio(ccdstrategy, NULL, dev, B_WRITE, minphys, uio));\n}"
  },
  {
    "function_name": "ccdread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1124-1150",
    "snippet": "int\nccdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdread(%x, %p)\\n\", dev, uio);\n#endif\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\treturn (ENXIO);\n\n\t/*\n\t * XXX: It's not clear that using minphys() is completely safe,\n\t * in particular, for raw I/O.  Underlying devices might have some\n\t * non-obvious limits, because of the copy to user-space.\n\t */\n\treturn (physio(ccdstrategy, NULL, dev, B_READ, minphys, uio));\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_FOLLOW\t0x01",
      "#define DEBUG"
    ],
    "globals_used": [
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "ccdstrategy",
            "NULL",
            "dev",
            "B_READ",
            "minphys",
            "uio"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdread(%x, %p)\\n\"",
            "dev",
            "uio"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ccdunit",
          "args": [
            "dev"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nINLINE struct;\n\nint\nccdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdread(%x, %p)\\n\", dev, uio);\n#endif\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((cs->sc_flags & CCDF_INITED) == 0)\n\t\treturn (ENXIO);\n\n\t/*\n\t * XXX: It's not clear that using minphys() is completely safe,\n\t * in particular, for raw I/O.  Underlying devices might have some\n\t * non-obvious limits, because of the copy to user-space.\n\t */\n\treturn (physio(ccdstrategy, NULL, dev, B_READ, minphys, uio));\n}"
  },
  {
    "function_name": "ccdiodone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1034-1121",
    "snippet": "void\nccdiodone(vbp)\n\tstruct buf *vbp;\n{\n\tstruct ccdbuf *cbp = (struct ccdbuf *)vbp;\n\tstruct buf *bp = cbp->cb_obp;\n\tint unit = cbp->cb_unit;\n\tstruct ccd_softc *cs = &ccd_softc[unit];\n\tint old_io = cbp->cb_flags & CBF_OLD;\n\tint cbflags, s, i;\n\tlong count = bp->b_bcount, off;\n\tchar *comptype;\n\n\ts = splbio();\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdiodone(%p)\\n\", cbp);\n\tif (ccddebug & CCDB_IO) {\n\t\tif (cbp->cb_flags & CBF_MIRROR)\n\t\t\tprintf(\"ccdiodone: mirror component\\n\");\n\t\telse\n\t\t\tprintf(\"ccdiodone: bp %p bcount %ld resid %ld\\n\",\n\t\t\t    bp, bp->b_bcount, bp->b_resid);\n\t\tprintf(\" dev %x(u%d), cbp %p bn %d addr %p bcnt %ld\\n\",\n\t\t    vbp->b_dev, cbp->cb_comp, cbp, vbp->b_blkno,\n\t\t    vbp->b_data, vbp->b_bcount);\n\t}\n#endif\n\n\tif (vbp->b_flags & B_ERROR) {\n\t\tif (cbp->cb_flags & CBF_MIRROR)\n\t\t\tcomptype = \" (mirror)\";\n\t\telse {\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_error = vbp->b_error ?\n\t\t\t    vbp->b_error : EIO;\n\t\t\tcomptype = \"\";\n\t\t}\n\n\t\tprintf(\"%s: error %d on component %d%s\\n\",\n\t\t    cs->sc_xname, bp->b_error, cbp->cb_comp, comptype);\n\t}\n\tcbflags = cbp->cb_flags;\n\n\tif (!old_io) {\n\t\t/*\n\t\t * Gather all the pieces and put them where they should be.\n\t\t */\n\t\tfor (i = 0, off = 0; i < cbp->cb_sgcnt; i++) {\n#ifdef DEBUG\n\t\t\tif (ccddebug & CCDB_IO)\n\t\t\t\tprintf(\"ccdiodone: sg %d (%p/%x) off %x\\n\", i,\n\t\t\t\t    cbp->cb_sg[i].cs_sgaddr,\n\t\t\t\t    cbp->cb_sg[i].cs_sglen, off);\n#endif\n\t\t\tpagemove(vbp->b_data + off, cbp->cb_sg[i].cs_sgaddr,\n\t\t\t    clrnd(round_page(cbp->cb_sg[i].cs_sglen)));\n\t\t\toff += cbp->cb_sg[i].cs_sglen;\n\t\t}\n\n#if defined(UVM)\n\t\tuvm_km_free(ccdmap, (vaddr_t)vbp->b_data, count);\n#else\n\t\tkmem_free(ccdmap, (vaddr_t)vbp->b_data, count);\n#endif\n\t\tif (ccd_need_kvm) {\n\t\t\tccd_need_kvm = 0;\n\t\t\twakeup(ccdmap);\n\t\t}\n\t}\n\tcount = vbp->b_bcount;\n\tputccdbuf(cbp);\n\n\tif ((cbflags & CBF_MIRROR) == 0) {\n\t\t/*\n\t\t * If all done, \"interrupt\".\n\t\t *\n\t\t * Note that mirror component buffers aren't counted against\n\t\t * the original I/O buffer.\n\t\t */\n\t\tif (count > bp->b_resid)\n\t\t\tpanic(\"ccdiodone: count\");\n\t\tbp->b_resid -= count;\n\t\tif (bp->b_resid == 0)\n\t\t\tccdintr(&ccd_softc[unit], bp);\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CBF_OLD\t\t0x02\t\t/* use old I/O protocol */",
      "#define CBF_MIRROR\t0x01\t\t/* we're for a mirror component */",
      "#define CCDB_IO\t\t0x04",
      "#define CCDB_FOLLOW\t0x01",
      "#define DEBUG"
    ],
    "globals_used": [
      "void\tccdiodone",
      "void\tccdintr",
      "long\tccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,\n    long, struct ccdbuf **, int));",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdintr",
          "args": [
            "&ccd_softc[unit]",
            "bp"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ccdintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1010-1027",
          "snippet": "void\nccdintr(cs, bp)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n{\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdintr(%p, %p)\\n\", cs, bp);\n#endif\n\t/*\n\t * Request is done for better or worse, wakeup the top half.\n\t */\n\tif (bp->b_flags & B_ERROR)\n\t\tbp->b_resid = bp->b_bcount;\n\tdisk_unbusy(&cs->sc_dkdev, (bp->b_bcount - bp->b_resid));\n\tbiodone(bp);\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define CCDB_FOLLOW\t0x01",
            "#define DEBUG"
          ],
          "globals_used": [
            "void\tccdintr",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nvoid\tccdintr;\nINLINE struct;\n\nvoid\nccdintr(cs, bp)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n{\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdintr(%p, %p)\\n\", cs, bp);\n#endif\n\t/*\n\t * Request is done for better or worse, wakeup the top half.\n\t */\n\tif (bp->b_flags & B_ERROR)\n\t\tbp->b_resid = bp->b_bcount;\n\tdisk_unbusy(&cs->sc_dkdev, (bp->b_bcount - bp->b_resid));\n\tbiodone(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ccdiodone: count\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putccdbuf",
          "args": [
            "cbp"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "ccdmap"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ccdmap",
            "(vaddr_t)vbp->b_data",
            "count"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uvm_km_free",
          "args": [
            "ccdmap",
            "(vaddr_t)vbp->b_data",
            "count"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagemove",
          "args": [
            "vbp->b_data + off",
            "cbp->cb_sg[i].cs_sgaddr",
            "clrnd(round_page(cbp->cb_sg[i].cs_sglen))"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clrnd",
          "args": [
            "round_page(cbp->cb_sg[i].cs_sglen)"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_page",
          "args": [
            "cbp->cb_sg[i].cs_sglen"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdiodone: sg %d (%p/%x) off %x\\n\"",
            "i",
            "cbp->cb_sg[i].cs_sgaddr",
            "cbp->cb_sg[i].cs_sglen",
            "off"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CBF_OLD\t\t0x02\t\t/* use old I/O protocol */\n#define CBF_MIRROR\t0x01\t\t/* we're for a mirror component */\n#define CCDB_IO\t\t0x04\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nvoid\tccdiodone;\nvoid\tccdintr;\nlong\tccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,\n    long, struct ccdbuf **, int));\nINLINE struct;\n\nvoid\nccdiodone(vbp)\n\tstruct buf *vbp;\n{\n\tstruct ccdbuf *cbp = (struct ccdbuf *)vbp;\n\tstruct buf *bp = cbp->cb_obp;\n\tint unit = cbp->cb_unit;\n\tstruct ccd_softc *cs = &ccd_softc[unit];\n\tint old_io = cbp->cb_flags & CBF_OLD;\n\tint cbflags, s, i;\n\tlong count = bp->b_bcount, off;\n\tchar *comptype;\n\n\ts = splbio();\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdiodone(%p)\\n\", cbp);\n\tif (ccddebug & CCDB_IO) {\n\t\tif (cbp->cb_flags & CBF_MIRROR)\n\t\t\tprintf(\"ccdiodone: mirror component\\n\");\n\t\telse\n\t\t\tprintf(\"ccdiodone: bp %p bcount %ld resid %ld\\n\",\n\t\t\t    bp, bp->b_bcount, bp->b_resid);\n\t\tprintf(\" dev %x(u%d), cbp %p bn %d addr %p bcnt %ld\\n\",\n\t\t    vbp->b_dev, cbp->cb_comp, cbp, vbp->b_blkno,\n\t\t    vbp->b_data, vbp->b_bcount);\n\t}\n#endif\n\n\tif (vbp->b_flags & B_ERROR) {\n\t\tif (cbp->cb_flags & CBF_MIRROR)\n\t\t\tcomptype = \" (mirror)\";\n\t\telse {\n\t\t\tbp->b_flags |= B_ERROR;\n\t\t\tbp->b_error = vbp->b_error ?\n\t\t\t    vbp->b_error : EIO;\n\t\t\tcomptype = \"\";\n\t\t}\n\n\t\tprintf(\"%s: error %d on component %d%s\\n\",\n\t\t    cs->sc_xname, bp->b_error, cbp->cb_comp, comptype);\n\t}\n\tcbflags = cbp->cb_flags;\n\n\tif (!old_io) {\n\t\t/*\n\t\t * Gather all the pieces and put them where they should be.\n\t\t */\n\t\tfor (i = 0, off = 0; i < cbp->cb_sgcnt; i++) {\n#ifdef DEBUG\n\t\t\tif (ccddebug & CCDB_IO)\n\t\t\t\tprintf(\"ccdiodone: sg %d (%p/%x) off %x\\n\", i,\n\t\t\t\t    cbp->cb_sg[i].cs_sgaddr,\n\t\t\t\t    cbp->cb_sg[i].cs_sglen, off);\n#endif\n\t\t\tpagemove(vbp->b_data + off, cbp->cb_sg[i].cs_sgaddr,\n\t\t\t    clrnd(round_page(cbp->cb_sg[i].cs_sglen)));\n\t\t\toff += cbp->cb_sg[i].cs_sglen;\n\t\t}\n\n#if defined(UVM)\n\t\tuvm_km_free(ccdmap, (vaddr_t)vbp->b_data, count);\n#else\n\t\tkmem_free(ccdmap, (vaddr_t)vbp->b_data, count);\n#endif\n\t\tif (ccd_need_kvm) {\n\t\t\tccd_need_kvm = 0;\n\t\t\twakeup(ccdmap);\n\t\t}\n\t}\n\tcount = vbp->b_bcount;\n\tputccdbuf(cbp);\n\n\tif ((cbflags & CBF_MIRROR) == 0) {\n\t\t/*\n\t\t * If all done, \"interrupt\".\n\t\t *\n\t\t * Note that mirror component buffers aren't counted against\n\t\t * the original I/O buffer.\n\t\t */\n\t\tif (count > bp->b_resid)\n\t\t\tpanic(\"ccdiodone: count\");\n\t\tbp->b_resid -= count;\n\t\tif (bp->b_resid == 0)\n\t\t\tccdintr(&ccd_softc[unit], bp);\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "ccdintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "1010-1027",
    "snippet": "void\nccdintr(cs, bp)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n{\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdintr(%p, %p)\\n\", cs, bp);\n#endif\n\t/*\n\t * Request is done for better or worse, wakeup the top half.\n\t */\n\tif (bp->b_flags & B_ERROR)\n\t\tbp->b_resid = bp->b_bcount;\n\tdisk_unbusy(&cs->sc_dkdev, (bp->b_bcount - bp->b_resid));\n\tbiodone(bp);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_FOLLOW\t0x01",
      "#define DEBUG"
    ],
    "globals_used": [
      "void\tccdintr",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unbusy",
          "args": [
            "&cs->sc_dkdev",
            "(bp->b_bcount - bp->b_resid)"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdintr(%p, %p)\\n\"",
            "cs",
            "bp"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nvoid\tccdintr;\nINLINE struct;\n\nvoid\nccdintr(cs, bp)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n{\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdintr(%p, %p)\\n\", cs, bp);\n#endif\n\t/*\n\t * Request is done for better or worse, wakeup the top half.\n\t */\n\tif (bp->b_flags & B_ERROR)\n\t\tbp->b_resid = bp->b_bcount;\n\tdisk_unbusy(&cs->sc_dkdev, (bp->b_bcount - bp->b_resid));\n\tbiodone(bp);\n}"
  },
  {
    "function_name": "ccdbuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "827-1008",
    "snippet": "long\nccdbuffer(cs, bp, bn, addr, bcount, cbpp, old_io)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n\tdaddr_t bn;\n\tcaddr_t addr;\n\tlong bcount;\n\tstruct ccdbuf **cbpp;\n\tint old_io;\n{\n\tstruct ccdcinfo *ci, *ci2 = NULL;\n\tstruct ccdbuf *cbp;\n\tdaddr_t cbn, cboff, sblk;\n\tint ccdisk, off;\n\tlong old_bcount, cnt;\n\tstruct ccdiinfo *ii;\n\tstruct buf *nbp;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_IO)\n\t\tprintf(\"ccdbuffer(%p, %p, %d, %p, %ld)\\n\", cs, bp, bn, addr,\n\t\t    bcount);\n#endif\n\n\t/*\n\t * Determine which component bn falls in.\n\t */\n\tcbn = bn;\n\tcboff = 0;\n\n\tif (cs->sc_ileave == 0) {\n\t\t/*\n\t\t * Serially concatenated\n\t\t */\n\t\tsblk = 0;\n\t\tfor (ccdisk = 0, ci = &cs->sc_cinfo[ccdisk];\n\t\t    cbn >= sblk + ci->ci_size;\n\t\t    ccdisk++, ci = &cs->sc_cinfo[ccdisk])\n\t\t\tsblk += ci->ci_size;\n\t\tcbn -= sblk;\n\t} else {\n\t\t/*\n\t\t * Interleaved\n\t\t */\n\t\tcboff = cbn % cs->sc_ileave;\n\t\tcbn /= cs->sc_ileave;\n\t\tfor (ii = cs->sc_itable; ii->ii_ndisk; ii++)\n\t\t\tif (ii->ii_startblk > cbn)\n\t\t\t\tbreak;\n\t\tii--;\n\t\toff = cbn - ii->ii_startblk;\n\t\tif (ii->ii_ndisk == 1) {\n\t\t\tccdisk = ii->ii_index[0];\n\t\t\tcbn = ii->ii_startoff + off;\n\t\t} else {\n\t\t\tif (cs->sc_cflags & CCDF_MIRROR) {\n\t\t\t\tccdisk =\n\t\t\t\t    ii->ii_index[off % (ii->ii_ndisk / 2)];\n\t\t\t\tcbn = ii->ii_startoff +\n\t\t\t\t    (off / (ii->ii_ndisk / 2));\n\t\t\t\t/* Mirrored data */\n\t\t\t\tci2 =\n\t\t\t\t    &cs->sc_cinfo[ccdisk + (ii->ii_ndisk / 2)];\n\t\t\t} else {\n\t\t\t\t/* Normal case. */\n\t\t\t\tccdisk = ii->ii_index[off % ii->ii_ndisk];\n\t\t\t\tcbn = ii->ii_startoff + off / ii->ii_ndisk;\n\t\t\t}\n\t\t}\n\t\tcbn *= cs->sc_ileave;\n\t\tci = &cs->sc_cinfo[ccdisk];\n\t}\n\n\t/* Limit the operation at next component border */\n\tif (cs->sc_ileave == 0)\n\t\tcnt = dbtob(ci->ci_size - cbn);\n\telse\n\t\tcnt = dbtob(cs->sc_ileave - cboff);\n\tif (cnt < bcount)\n\t\tbcount = cnt;\n\n\tif (old_io || cbpp[ccdisk] == NULL) {\n\t\t/*\n\t\t * Setup new component buffer.\n\t\t */\n\t\tcbp = cbpp[old_io ? 0 : ccdisk] = getccdbuf();\n\t\tcbp->cb_flags = old_io ? CBF_OLD : 0;\n\t\tnbp = &cbp->cb_buf;\n\t\tnbp->b_flags = bp->b_flags | B_CALL;\n\t\tnbp->b_iodone = ccdiodone;\n\t\tnbp->b_proc = bp->b_proc;\n\t\tnbp->b_dev = ci->ci_dev;\t\t/* XXX */\n\t\tnbp->b_blkno = cbn + cboff;\n\t\tnbp->b_vp = ci->ci_vp;\n\t\tnbp->b_bcount = bcount;\n\t\tLIST_INIT(&nbp->b_dep);\n\n\t\t/*\n\t\t * context for ccdiodone\n\t\t */\n\t\tcbp->cb_obp = bp;\n\t\tcbp->cb_unit = cs->sc_unit;\n\t\tcbp->cb_comp = ccdisk;\n\n\t\t/* Deal with the different algorithms */\n\t\tif (old_io)\n\t\t\tnbp->b_data = addr;\n\t\telse {\n\t\t\tdo {\n#if defined(UVM)\n\t\t\t\tnbp->b_data = (caddr_t) uvm_km_valloc(ccdmap,\n\t\t\t\t\t\t\t    bp->b_bcount);\n#else\n\t\t\t\tnbp->b_data = (caddr_t) kmem_alloc_pageable(\n\t\t\t\t\t\t\t ccdmap, bp->b_bcount);\n#endif\n\n\t\t\t\t/*\n\t\t\t\t * XXX Instead of sleeping, we might revert\n\t\t\t\t * XXX to old I/O policy for this buffer set.\n\t\t\t\t */\n\t\t\t\tif (nbp->b_data == NULL) {\n\t\t\t\t\tccd_need_kvm++;\n\t\t\t\t\ttsleep(ccdmap, PRIBIO, \"ccdbuffer\", 0);\n\t\t\t\t}\n\t\t\t} while (nbp->b_data == NULL);\n\t\t\tcbp->cb_sgcnt = 0;\n\t\t\told_bcount = 0;\n\t\t}\n\n\t\t/*\n\t\t * Mirrors have an additional write operation that is nearly\n\t\t * identical to the first.\n\t\t */\n\t\tif ((cs->sc_cflags & CCDF_MIRROR) &&\n\t\t    ((cbp->cb_buf.b_flags & B_READ) == 0)) {\n\t\t\tcbp = getccdbuf();\n\t\t\t*cbp = *cbpp[0];\n\t\t\tcbp->cb_flags = CBF_MIRROR | (old_io ? CBF_OLD : 0);\n\t\t\tcbp->cb_buf.b_dev = ci2->ci_dev;\t/* XXX */\n\t\t\tcbp->cb_buf.b_vp = ci2->ci_vp;\n\t\t\tLIST_INIT(&cbp->cb_buf.b_dep);\n\t\t\tcbp->cb_comp = ci2 - cs->sc_cinfo;\n\t\t\tcbpp[1] = cbp;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Continue on an already started component buffer\n\t\t */\n\t\tcbp = cbpp[ccdisk];\n\t\tnbp = &cbp->cb_buf;\n\n\t\t/*\n\t\t * Map the new pages at the end of the buffer.\n\t\t */\n\t\told_bcount = nbp->b_bcount;\n\t\tnbp->b_bcount += bcount;\n\t}\n\n\tif (!old_io) {\n#ifdef DEBUG\n\t\tif (ccddebug & CCDB_IO)\n\t\t\tprintf(\"ccdbuffer: sg %d (%p/%x) off %x\\n\",\n\t\t\t    cbp->cb_sgcnt, addr, bcount, old_bcount);\n#endif\n\t\tpagemove(addr, nbp->b_data + old_bcount,\n\t\t    clrnd(round_page(bcount)));\n\t\tnbp->b_bufsize += clrnd(round_page(bcount));\n\t\tcbp->cb_sg[cbp->cb_sgcnt].cs_sgaddr = addr;\n\t\tcbp->cb_sg[cbp->cb_sgcnt].cs_sglen = bcount;\n\t\tcbp->cb_sgcnt++;\n\t}\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_IO)\n\t\tprintf(\" dev %x(u%d): cbp %p bn %d addr %p bcnt %ld\\n\",\n\t\t    ci->ci_dev, ci-cs->sc_cinfo, cbp, bp->b_blkno,\n\t\t    bp->b_data, bp->b_bcount);\n#endif\n\n\treturn (bcount);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CBF_OLD\t\t0x02\t\t/* use old I/O protocol */",
      "#define CBF_MIRROR\t0x01\t\t/* we're for a mirror component */",
      "#define CCDB_IO\t\t0x04",
      "#define DEBUG"
    ],
    "globals_used": [
      "void\tccdiodone",
      "long\tccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,\n    long, struct ccdbuf **, int));",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" dev %x(u%d): cbp %p bn %d addr %p bcnt %ld\\n\"",
            "ci->ci_dev",
            "ci-cs->sc_cinfo",
            "cbp",
            "bp->b_blkno",
            "bp->b_data",
            "bp->b_bcount"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clrnd",
          "args": [
            "round_page(bcount)"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_page",
          "args": [
            "bcount"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagemove",
          "args": [
            "addr",
            "nbp->b_data + old_bcount",
            "clrnd(round_page(bcount))"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clrnd",
          "args": [
            "round_page(bcount)"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_page",
          "args": [
            "bcount"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&cbp->cb_buf.b_dep"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getccdbuf",
          "args": [],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "ccdmap",
            "PRIBIO",
            "\"ccdbuffer\"",
            "0"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc_pageable",
          "args": [
            "ccdmap",
            "bp->b_bcount"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uvm_km_valloc",
          "args": [
            "ccdmap",
            "bp->b_bcount"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&nbp->b_dep"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getccdbuf",
          "args": [],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbtob",
          "args": [
            "cs->sc_ileave - cboff"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbtob",
          "args": [
            "ci->ci_size - cbn"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CBF_OLD\t\t0x02\t\t/* use old I/O protocol */\n#define CBF_MIRROR\t0x01\t\t/* we're for a mirror component */\n#define CCDB_IO\t\t0x04\n#define DEBUG\n\nvoid\tccdiodone;\nlong\tccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,\n    long, struct ccdbuf **, int));\nINLINE struct;\n\nlong\nccdbuffer(cs, bp, bn, addr, bcount, cbpp, old_io)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n\tdaddr_t bn;\n\tcaddr_t addr;\n\tlong bcount;\n\tstruct ccdbuf **cbpp;\n\tint old_io;\n{\n\tstruct ccdcinfo *ci, *ci2 = NULL;\n\tstruct ccdbuf *cbp;\n\tdaddr_t cbn, cboff, sblk;\n\tint ccdisk, off;\n\tlong old_bcount, cnt;\n\tstruct ccdiinfo *ii;\n\tstruct buf *nbp;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_IO)\n\t\tprintf(\"ccdbuffer(%p, %p, %d, %p, %ld)\\n\", cs, bp, bn, addr,\n\t\t    bcount);\n#endif\n\n\t/*\n\t * Determine which component bn falls in.\n\t */\n\tcbn = bn;\n\tcboff = 0;\n\n\tif (cs->sc_ileave == 0) {\n\t\t/*\n\t\t * Serially concatenated\n\t\t */\n\t\tsblk = 0;\n\t\tfor (ccdisk = 0, ci = &cs->sc_cinfo[ccdisk];\n\t\t    cbn >= sblk + ci->ci_size;\n\t\t    ccdisk++, ci = &cs->sc_cinfo[ccdisk])\n\t\t\tsblk += ci->ci_size;\n\t\tcbn -= sblk;\n\t} else {\n\t\t/*\n\t\t * Interleaved\n\t\t */\n\t\tcboff = cbn % cs->sc_ileave;\n\t\tcbn /= cs->sc_ileave;\n\t\tfor (ii = cs->sc_itable; ii->ii_ndisk; ii++)\n\t\t\tif (ii->ii_startblk > cbn)\n\t\t\t\tbreak;\n\t\tii--;\n\t\toff = cbn - ii->ii_startblk;\n\t\tif (ii->ii_ndisk == 1) {\n\t\t\tccdisk = ii->ii_index[0];\n\t\t\tcbn = ii->ii_startoff + off;\n\t\t} else {\n\t\t\tif (cs->sc_cflags & CCDF_MIRROR) {\n\t\t\t\tccdisk =\n\t\t\t\t    ii->ii_index[off % (ii->ii_ndisk / 2)];\n\t\t\t\tcbn = ii->ii_startoff +\n\t\t\t\t    (off / (ii->ii_ndisk / 2));\n\t\t\t\t/* Mirrored data */\n\t\t\t\tci2 =\n\t\t\t\t    &cs->sc_cinfo[ccdisk + (ii->ii_ndisk / 2)];\n\t\t\t} else {\n\t\t\t\t/* Normal case. */\n\t\t\t\tccdisk = ii->ii_index[off % ii->ii_ndisk];\n\t\t\t\tcbn = ii->ii_startoff + off / ii->ii_ndisk;\n\t\t\t}\n\t\t}\n\t\tcbn *= cs->sc_ileave;\n\t\tci = &cs->sc_cinfo[ccdisk];\n\t}\n\n\t/* Limit the operation at next component border */\n\tif (cs->sc_ileave == 0)\n\t\tcnt = dbtob(ci->ci_size - cbn);\n\telse\n\t\tcnt = dbtob(cs->sc_ileave - cboff);\n\tif (cnt < bcount)\n\t\tbcount = cnt;\n\n\tif (old_io || cbpp[ccdisk] == NULL) {\n\t\t/*\n\t\t * Setup new component buffer.\n\t\t */\n\t\tcbp = cbpp[old_io ? 0 : ccdisk] = getccdbuf();\n\t\tcbp->cb_flags = old_io ? CBF_OLD : 0;\n\t\tnbp = &cbp->cb_buf;\n\t\tnbp->b_flags = bp->b_flags | B_CALL;\n\t\tnbp->b_iodone = ccdiodone;\n\t\tnbp->b_proc = bp->b_proc;\n\t\tnbp->b_dev = ci->ci_dev;\t\t/* XXX */\n\t\tnbp->b_blkno = cbn + cboff;\n\t\tnbp->b_vp = ci->ci_vp;\n\t\tnbp->b_bcount = bcount;\n\t\tLIST_INIT(&nbp->b_dep);\n\n\t\t/*\n\t\t * context for ccdiodone\n\t\t */\n\t\tcbp->cb_obp = bp;\n\t\tcbp->cb_unit = cs->sc_unit;\n\t\tcbp->cb_comp = ccdisk;\n\n\t\t/* Deal with the different algorithms */\n\t\tif (old_io)\n\t\t\tnbp->b_data = addr;\n\t\telse {\n\t\t\tdo {\n#if defined(UVM)\n\t\t\t\tnbp->b_data = (caddr_t) uvm_km_valloc(ccdmap,\n\t\t\t\t\t\t\t    bp->b_bcount);\n#else\n\t\t\t\tnbp->b_data = (caddr_t) kmem_alloc_pageable(\n\t\t\t\t\t\t\t ccdmap, bp->b_bcount);\n#endif\n\n\t\t\t\t/*\n\t\t\t\t * XXX Instead of sleeping, we might revert\n\t\t\t\t * XXX to old I/O policy for this buffer set.\n\t\t\t\t */\n\t\t\t\tif (nbp->b_data == NULL) {\n\t\t\t\t\tccd_need_kvm++;\n\t\t\t\t\ttsleep(ccdmap, PRIBIO, \"ccdbuffer\", 0);\n\t\t\t\t}\n\t\t\t} while (nbp->b_data == NULL);\n\t\t\tcbp->cb_sgcnt = 0;\n\t\t\told_bcount = 0;\n\t\t}\n\n\t\t/*\n\t\t * Mirrors have an additional write operation that is nearly\n\t\t * identical to the first.\n\t\t */\n\t\tif ((cs->sc_cflags & CCDF_MIRROR) &&\n\t\t    ((cbp->cb_buf.b_flags & B_READ) == 0)) {\n\t\t\tcbp = getccdbuf();\n\t\t\t*cbp = *cbpp[0];\n\t\t\tcbp->cb_flags = CBF_MIRROR | (old_io ? CBF_OLD : 0);\n\t\t\tcbp->cb_buf.b_dev = ci2->ci_dev;\t/* XXX */\n\t\t\tcbp->cb_buf.b_vp = ci2->ci_vp;\n\t\t\tLIST_INIT(&cbp->cb_buf.b_dep);\n\t\t\tcbp->cb_comp = ci2 - cs->sc_cinfo;\n\t\t\tcbpp[1] = cbp;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Continue on an already started component buffer\n\t\t */\n\t\tcbp = cbpp[ccdisk];\n\t\tnbp = &cbp->cb_buf;\n\n\t\t/*\n\t\t * Map the new pages at the end of the buffer.\n\t\t */\n\t\told_bcount = nbp->b_bcount;\n\t\tnbp->b_bcount += bcount;\n\t}\n\n\tif (!old_io) {\n#ifdef DEBUG\n\t\tif (ccddebug & CCDB_IO)\n\t\t\tprintf(\"ccdbuffer: sg %d (%p/%x) off %x\\n\",\n\t\t\t    cbp->cb_sgcnt, addr, bcount, old_bcount);\n#endif\n\t\tpagemove(addr, nbp->b_data + old_bcount,\n\t\t    clrnd(round_page(bcount)));\n\t\tnbp->b_bufsize += clrnd(round_page(bcount));\n\t\tcbp->cb_sg[cbp->cb_sgcnt].cs_sgaddr = addr;\n\t\tcbp->cb_sg[cbp->cb_sgcnt].cs_sglen = bcount;\n\t\tcbp->cb_sgcnt++;\n\t}\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_IO)\n\t\tprintf(\" dev %x(u%d): cbp %p bn %d addr %p bcnt %ld\\n\",\n\t\t    ci->ci_dev, ci-cs->sc_cinfo, cbp, bp->b_blkno,\n\t\t    bp->b_data, bp->b_bcount);\n#endif\n\n\treturn (bcount);\n}"
  },
  {
    "function_name": "ccdstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "744-822",
    "snippet": "void\nccdstart(cs, bp)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n{\n\tlong bcount, rcount;\n\tstruct ccdbuf **cbpp, *cbp;\n\tcaddr_t addr;\n\tdaddr_t bn;\n\tstruct partition *pp;\n\tint i, old_io = ccddevs[cs->sc_unit].ccd_flags & CCDF_OLD;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdstart(%p, %p)\\n\", cs, bp);\n#endif\n\n\t/* Instrumentation. */\n\tdisk_busy(&cs->sc_dkdev);\n\n\t/*\n\t * Translate the partition-relative block number to an absolute.\n\t */\n\tbn = bp->b_blkno;\n\tif (DISKPART(bp->b_dev) != RAW_PART) {\n\t\tpp = &cs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];\n\t\tbn += pp->p_offset;\n\t}\n\n\t/*\n\t * Allocate component buffers\n\t */\n\tcbpp = malloc(2 * cs->sc_nccdisks * sizeof(struct ccdbuf *), M_DEVBUF,\n\t    M_WAITOK);\n\tbzero(cbpp, 2 * cs->sc_nccdisks * sizeof(struct ccdbuf *));\n\taddr = bp->b_data;\n\told_io = old_io || ((vaddr_t)addr & CLOFSET); /* XXX !claligned */\n\tfor (bcount = bp->b_bcount; bcount > 0; bcount -= rcount) {\n\t\trcount = ccdbuffer(cs, bp, bn, addr, bcount, cbpp, old_io);\n\t\t\n\t\t/*\n\t\t * This is the old, slower, but less restrictive, mode of\n\t\t * operation.  It allows interleaves which are not multiples\n\t\t * of CLBYTES and mirroring.\n\t\t */\n\t\tif (old_io) {\n\t\t\tif ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)\n\t\t\t\tcbpp[0]->cb_buf.b_vp->v_numoutput++;\n\t\t\tVOP_STRATEGY(&cbpp[0]->cb_buf);\n\n\t\t\t/*\n\t\t\t * Mirror requires additional write.\n\t\t\t */\n\t\t\tif ((cs->sc_cflags & CCDF_MIRROR) &&\n\t\t\t    ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)) {\n\t\t\t\tcbpp[1]->cb_buf.b_vp->v_numoutput++;\n\t\t\t\tVOP_STRATEGY(&cbpp[1]->cb_buf);\n\t\t\t}\n\t\t}\n\n\t\tbn += btodb(rcount);\n\t\taddr += rcount;\n\t}\n\n\t/* The new leaner mode of operation */\n\tif (!old_io)\n\t\t/*\n\t\t * Fire off the requests\n\t\t */\n\t\tfor (i = 0; i < cs->sc_nccdisks; i++) {\n\t\t\tcbp = cbpp[i];\n\t\t\tif (cbp) {\n\t\t\t\tif ((cbp->cb_buf.b_flags & B_READ) == 0)\n\t\t\t\t\tcbp->cb_buf.b_vp->v_numoutput++;\n\t\t\t\tVOP_STRATEGY(&cbp->cb_buf);\n\t\t\t}\n\t\t}\n\tfree(cbpp, M_DEVBUF);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_FOLLOW\t0x01",
      "#define DEBUG"
    ],
    "globals_used": [
      "void\tccdstart",
      "long\tccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,\n    long, struct ccdbuf **, int));",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cbpp",
            "M_DEVBUF"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "audio_free_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "493-503",
          "snippet": "void\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_free_ring(sc, r)\n\tstruct audio_softc *sc;\n\tstruct audio_ringbuffer *r;\n{\n\tif (sc->hw_if->freem) {\n\t    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);\n\t} else {\n\t    free(r->start, M_DEVBUF);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VOP_STRATEGY",
          "args": [
            "&cbp->cb_buf"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btodb",
          "args": [
            "rcount"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_STRATEGY",
          "args": [
            "&cbpp[1]->cb_buf"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOP_STRATEGY",
          "args": [
            "&cbpp[0]->cb_buf"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdbuffer",
          "args": [
            "cs",
            "bp",
            "bn",
            "addr",
            "bcount",
            "cbpp",
            "old_io"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "ccdbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "827-1008",
          "snippet": "long\nccdbuffer(cs, bp, bn, addr, bcount, cbpp, old_io)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n\tdaddr_t bn;\n\tcaddr_t addr;\n\tlong bcount;\n\tstruct ccdbuf **cbpp;\n\tint old_io;\n{\n\tstruct ccdcinfo *ci, *ci2 = NULL;\n\tstruct ccdbuf *cbp;\n\tdaddr_t cbn, cboff, sblk;\n\tint ccdisk, off;\n\tlong old_bcount, cnt;\n\tstruct ccdiinfo *ii;\n\tstruct buf *nbp;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_IO)\n\t\tprintf(\"ccdbuffer(%p, %p, %d, %p, %ld)\\n\", cs, bp, bn, addr,\n\t\t    bcount);\n#endif\n\n\t/*\n\t * Determine which component bn falls in.\n\t */\n\tcbn = bn;\n\tcboff = 0;\n\n\tif (cs->sc_ileave == 0) {\n\t\t/*\n\t\t * Serially concatenated\n\t\t */\n\t\tsblk = 0;\n\t\tfor (ccdisk = 0, ci = &cs->sc_cinfo[ccdisk];\n\t\t    cbn >= sblk + ci->ci_size;\n\t\t    ccdisk++, ci = &cs->sc_cinfo[ccdisk])\n\t\t\tsblk += ci->ci_size;\n\t\tcbn -= sblk;\n\t} else {\n\t\t/*\n\t\t * Interleaved\n\t\t */\n\t\tcboff = cbn % cs->sc_ileave;\n\t\tcbn /= cs->sc_ileave;\n\t\tfor (ii = cs->sc_itable; ii->ii_ndisk; ii++)\n\t\t\tif (ii->ii_startblk > cbn)\n\t\t\t\tbreak;\n\t\tii--;\n\t\toff = cbn - ii->ii_startblk;\n\t\tif (ii->ii_ndisk == 1) {\n\t\t\tccdisk = ii->ii_index[0];\n\t\t\tcbn = ii->ii_startoff + off;\n\t\t} else {\n\t\t\tif (cs->sc_cflags & CCDF_MIRROR) {\n\t\t\t\tccdisk =\n\t\t\t\t    ii->ii_index[off % (ii->ii_ndisk / 2)];\n\t\t\t\tcbn = ii->ii_startoff +\n\t\t\t\t    (off / (ii->ii_ndisk / 2));\n\t\t\t\t/* Mirrored data */\n\t\t\t\tci2 =\n\t\t\t\t    &cs->sc_cinfo[ccdisk + (ii->ii_ndisk / 2)];\n\t\t\t} else {\n\t\t\t\t/* Normal case. */\n\t\t\t\tccdisk = ii->ii_index[off % ii->ii_ndisk];\n\t\t\t\tcbn = ii->ii_startoff + off / ii->ii_ndisk;\n\t\t\t}\n\t\t}\n\t\tcbn *= cs->sc_ileave;\n\t\tci = &cs->sc_cinfo[ccdisk];\n\t}\n\n\t/* Limit the operation at next component border */\n\tif (cs->sc_ileave == 0)\n\t\tcnt = dbtob(ci->ci_size - cbn);\n\telse\n\t\tcnt = dbtob(cs->sc_ileave - cboff);\n\tif (cnt < bcount)\n\t\tbcount = cnt;\n\n\tif (old_io || cbpp[ccdisk] == NULL) {\n\t\t/*\n\t\t * Setup new component buffer.\n\t\t */\n\t\tcbp = cbpp[old_io ? 0 : ccdisk] = getccdbuf();\n\t\tcbp->cb_flags = old_io ? CBF_OLD : 0;\n\t\tnbp = &cbp->cb_buf;\n\t\tnbp->b_flags = bp->b_flags | B_CALL;\n\t\tnbp->b_iodone = ccdiodone;\n\t\tnbp->b_proc = bp->b_proc;\n\t\tnbp->b_dev = ci->ci_dev;\t\t/* XXX */\n\t\tnbp->b_blkno = cbn + cboff;\n\t\tnbp->b_vp = ci->ci_vp;\n\t\tnbp->b_bcount = bcount;\n\t\tLIST_INIT(&nbp->b_dep);\n\n\t\t/*\n\t\t * context for ccdiodone\n\t\t */\n\t\tcbp->cb_obp = bp;\n\t\tcbp->cb_unit = cs->sc_unit;\n\t\tcbp->cb_comp = ccdisk;\n\n\t\t/* Deal with the different algorithms */\n\t\tif (old_io)\n\t\t\tnbp->b_data = addr;\n\t\telse {\n\t\t\tdo {\n#if defined(UVM)\n\t\t\t\tnbp->b_data = (caddr_t) uvm_km_valloc(ccdmap,\n\t\t\t\t\t\t\t    bp->b_bcount);\n#else\n\t\t\t\tnbp->b_data = (caddr_t) kmem_alloc_pageable(\n\t\t\t\t\t\t\t ccdmap, bp->b_bcount);\n#endif\n\n\t\t\t\t/*\n\t\t\t\t * XXX Instead of sleeping, we might revert\n\t\t\t\t * XXX to old I/O policy for this buffer set.\n\t\t\t\t */\n\t\t\t\tif (nbp->b_data == NULL) {\n\t\t\t\t\tccd_need_kvm++;\n\t\t\t\t\ttsleep(ccdmap, PRIBIO, \"ccdbuffer\", 0);\n\t\t\t\t}\n\t\t\t} while (nbp->b_data == NULL);\n\t\t\tcbp->cb_sgcnt = 0;\n\t\t\told_bcount = 0;\n\t\t}\n\n\t\t/*\n\t\t * Mirrors have an additional write operation that is nearly\n\t\t * identical to the first.\n\t\t */\n\t\tif ((cs->sc_cflags & CCDF_MIRROR) &&\n\t\t    ((cbp->cb_buf.b_flags & B_READ) == 0)) {\n\t\t\tcbp = getccdbuf();\n\t\t\t*cbp = *cbpp[0];\n\t\t\tcbp->cb_flags = CBF_MIRROR | (old_io ? CBF_OLD : 0);\n\t\t\tcbp->cb_buf.b_dev = ci2->ci_dev;\t/* XXX */\n\t\t\tcbp->cb_buf.b_vp = ci2->ci_vp;\n\t\t\tLIST_INIT(&cbp->cb_buf.b_dep);\n\t\t\tcbp->cb_comp = ci2 - cs->sc_cinfo;\n\t\t\tcbpp[1] = cbp;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Continue on an already started component buffer\n\t\t */\n\t\tcbp = cbpp[ccdisk];\n\t\tnbp = &cbp->cb_buf;\n\n\t\t/*\n\t\t * Map the new pages at the end of the buffer.\n\t\t */\n\t\told_bcount = nbp->b_bcount;\n\t\tnbp->b_bcount += bcount;\n\t}\n\n\tif (!old_io) {\n#ifdef DEBUG\n\t\tif (ccddebug & CCDB_IO)\n\t\t\tprintf(\"ccdbuffer: sg %d (%p/%x) off %x\\n\",\n\t\t\t    cbp->cb_sgcnt, addr, bcount, old_bcount);\n#endif\n\t\tpagemove(addr, nbp->b_data + old_bcount,\n\t\t    clrnd(round_page(bcount)));\n\t\tnbp->b_bufsize += clrnd(round_page(bcount));\n\t\tcbp->cb_sg[cbp->cb_sgcnt].cs_sgaddr = addr;\n\t\tcbp->cb_sg[cbp->cb_sgcnt].cs_sglen = bcount;\n\t\tcbp->cb_sgcnt++;\n\t}\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_IO)\n\t\tprintf(\" dev %x(u%d): cbp %p bn %d addr %p bcnt %ld\\n\",\n\t\t    ci->ci_dev, ci-cs->sc_cinfo, cbp, bp->b_blkno,\n\t\t    bp->b_data, bp->b_bcount);\n#endif\n\n\treturn (bcount);\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define CBF_OLD\t\t0x02\t\t/* use old I/O protocol */",
            "#define CBF_MIRROR\t0x01\t\t/* we're for a mirror component */",
            "#define CCDB_IO\t\t0x04",
            "#define DEBUG"
          ],
          "globals_used": [
            "void\tccdiodone",
            "long\tccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,\n    long, struct ccdbuf **, int));",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CBF_OLD\t\t0x02\t\t/* use old I/O protocol */\n#define CBF_MIRROR\t0x01\t\t/* we're for a mirror component */\n#define CCDB_IO\t\t0x04\n#define DEBUG\n\nvoid\tccdiodone;\nlong\tccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,\n    long, struct ccdbuf **, int));\nINLINE struct;\n\nlong\nccdbuffer(cs, bp, bn, addr, bcount, cbpp, old_io)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n\tdaddr_t bn;\n\tcaddr_t addr;\n\tlong bcount;\n\tstruct ccdbuf **cbpp;\n\tint old_io;\n{\n\tstruct ccdcinfo *ci, *ci2 = NULL;\n\tstruct ccdbuf *cbp;\n\tdaddr_t cbn, cboff, sblk;\n\tint ccdisk, off;\n\tlong old_bcount, cnt;\n\tstruct ccdiinfo *ii;\n\tstruct buf *nbp;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_IO)\n\t\tprintf(\"ccdbuffer(%p, %p, %d, %p, %ld)\\n\", cs, bp, bn, addr,\n\t\t    bcount);\n#endif\n\n\t/*\n\t * Determine which component bn falls in.\n\t */\n\tcbn = bn;\n\tcboff = 0;\n\n\tif (cs->sc_ileave == 0) {\n\t\t/*\n\t\t * Serially concatenated\n\t\t */\n\t\tsblk = 0;\n\t\tfor (ccdisk = 0, ci = &cs->sc_cinfo[ccdisk];\n\t\t    cbn >= sblk + ci->ci_size;\n\t\t    ccdisk++, ci = &cs->sc_cinfo[ccdisk])\n\t\t\tsblk += ci->ci_size;\n\t\tcbn -= sblk;\n\t} else {\n\t\t/*\n\t\t * Interleaved\n\t\t */\n\t\tcboff = cbn % cs->sc_ileave;\n\t\tcbn /= cs->sc_ileave;\n\t\tfor (ii = cs->sc_itable; ii->ii_ndisk; ii++)\n\t\t\tif (ii->ii_startblk > cbn)\n\t\t\t\tbreak;\n\t\tii--;\n\t\toff = cbn - ii->ii_startblk;\n\t\tif (ii->ii_ndisk == 1) {\n\t\t\tccdisk = ii->ii_index[0];\n\t\t\tcbn = ii->ii_startoff + off;\n\t\t} else {\n\t\t\tif (cs->sc_cflags & CCDF_MIRROR) {\n\t\t\t\tccdisk =\n\t\t\t\t    ii->ii_index[off % (ii->ii_ndisk / 2)];\n\t\t\t\tcbn = ii->ii_startoff +\n\t\t\t\t    (off / (ii->ii_ndisk / 2));\n\t\t\t\t/* Mirrored data */\n\t\t\t\tci2 =\n\t\t\t\t    &cs->sc_cinfo[ccdisk + (ii->ii_ndisk / 2)];\n\t\t\t} else {\n\t\t\t\t/* Normal case. */\n\t\t\t\tccdisk = ii->ii_index[off % ii->ii_ndisk];\n\t\t\t\tcbn = ii->ii_startoff + off / ii->ii_ndisk;\n\t\t\t}\n\t\t}\n\t\tcbn *= cs->sc_ileave;\n\t\tci = &cs->sc_cinfo[ccdisk];\n\t}\n\n\t/* Limit the operation at next component border */\n\tif (cs->sc_ileave == 0)\n\t\tcnt = dbtob(ci->ci_size - cbn);\n\telse\n\t\tcnt = dbtob(cs->sc_ileave - cboff);\n\tif (cnt < bcount)\n\t\tbcount = cnt;\n\n\tif (old_io || cbpp[ccdisk] == NULL) {\n\t\t/*\n\t\t * Setup new component buffer.\n\t\t */\n\t\tcbp = cbpp[old_io ? 0 : ccdisk] = getccdbuf();\n\t\tcbp->cb_flags = old_io ? CBF_OLD : 0;\n\t\tnbp = &cbp->cb_buf;\n\t\tnbp->b_flags = bp->b_flags | B_CALL;\n\t\tnbp->b_iodone = ccdiodone;\n\t\tnbp->b_proc = bp->b_proc;\n\t\tnbp->b_dev = ci->ci_dev;\t\t/* XXX */\n\t\tnbp->b_blkno = cbn + cboff;\n\t\tnbp->b_vp = ci->ci_vp;\n\t\tnbp->b_bcount = bcount;\n\t\tLIST_INIT(&nbp->b_dep);\n\n\t\t/*\n\t\t * context for ccdiodone\n\t\t */\n\t\tcbp->cb_obp = bp;\n\t\tcbp->cb_unit = cs->sc_unit;\n\t\tcbp->cb_comp = ccdisk;\n\n\t\t/* Deal with the different algorithms */\n\t\tif (old_io)\n\t\t\tnbp->b_data = addr;\n\t\telse {\n\t\t\tdo {\n#if defined(UVM)\n\t\t\t\tnbp->b_data = (caddr_t) uvm_km_valloc(ccdmap,\n\t\t\t\t\t\t\t    bp->b_bcount);\n#else\n\t\t\t\tnbp->b_data = (caddr_t) kmem_alloc_pageable(\n\t\t\t\t\t\t\t ccdmap, bp->b_bcount);\n#endif\n\n\t\t\t\t/*\n\t\t\t\t * XXX Instead of sleeping, we might revert\n\t\t\t\t * XXX to old I/O policy for this buffer set.\n\t\t\t\t */\n\t\t\t\tif (nbp->b_data == NULL) {\n\t\t\t\t\tccd_need_kvm++;\n\t\t\t\t\ttsleep(ccdmap, PRIBIO, \"ccdbuffer\", 0);\n\t\t\t\t}\n\t\t\t} while (nbp->b_data == NULL);\n\t\t\tcbp->cb_sgcnt = 0;\n\t\t\told_bcount = 0;\n\t\t}\n\n\t\t/*\n\t\t * Mirrors have an additional write operation that is nearly\n\t\t * identical to the first.\n\t\t */\n\t\tif ((cs->sc_cflags & CCDF_MIRROR) &&\n\t\t    ((cbp->cb_buf.b_flags & B_READ) == 0)) {\n\t\t\tcbp = getccdbuf();\n\t\t\t*cbp = *cbpp[0];\n\t\t\tcbp->cb_flags = CBF_MIRROR | (old_io ? CBF_OLD : 0);\n\t\t\tcbp->cb_buf.b_dev = ci2->ci_dev;\t/* XXX */\n\t\t\tcbp->cb_buf.b_vp = ci2->ci_vp;\n\t\t\tLIST_INIT(&cbp->cb_buf.b_dep);\n\t\t\tcbp->cb_comp = ci2 - cs->sc_cinfo;\n\t\t\tcbpp[1] = cbp;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Continue on an already started component buffer\n\t\t */\n\t\tcbp = cbpp[ccdisk];\n\t\tnbp = &cbp->cb_buf;\n\n\t\t/*\n\t\t * Map the new pages at the end of the buffer.\n\t\t */\n\t\told_bcount = nbp->b_bcount;\n\t\tnbp->b_bcount += bcount;\n\t}\n\n\tif (!old_io) {\n#ifdef DEBUG\n\t\tif (ccddebug & CCDB_IO)\n\t\t\tprintf(\"ccdbuffer: sg %d (%p/%x) off %x\\n\",\n\t\t\t    cbp->cb_sgcnt, addr, bcount, old_bcount);\n#endif\n\t\tpagemove(addr, nbp->b_data + old_bcount,\n\t\t    clrnd(round_page(bcount)));\n\t\tnbp->b_bufsize += clrnd(round_page(bcount));\n\t\tcbp->cb_sg[cbp->cb_sgcnt].cs_sgaddr = addr;\n\t\tcbp->cb_sg[cbp->cb_sgcnt].cs_sglen = bcount;\n\t\tcbp->cb_sgcnt++;\n\t}\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_IO)\n\t\tprintf(\" dev %x(u%d): cbp %p bn %d addr %p bcnt %ld\\n\",\n\t\t    ci->ci_dev, ci-cs->sc_cinfo, cbp, bp->b_blkno,\n\t\t    bp->b_data, bp->b_bcount);\n#endif\n\n\treturn (bcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "cbpp",
            "2 * cs->sc_nccdisks * sizeof(struct ccdbuf *)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "2 * cs->sc_nccdisks * sizeof(struct ccdbuf *)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_busy",
          "args": [
            "&cs->sc_dkdev"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdstart(%p, %p)\\n\"",
            "cs",
            "bp"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nvoid\tccdstart;\nlong\tccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,\n    long, struct ccdbuf **, int));\nINLINE struct;\n\nvoid\nccdstart(cs, bp)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n{\n\tlong bcount, rcount;\n\tstruct ccdbuf **cbpp, *cbp;\n\tcaddr_t addr;\n\tdaddr_t bn;\n\tstruct partition *pp;\n\tint i, old_io = ccddevs[cs->sc_unit].ccd_flags & CCDF_OLD;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdstart(%p, %p)\\n\", cs, bp);\n#endif\n\n\t/* Instrumentation. */\n\tdisk_busy(&cs->sc_dkdev);\n\n\t/*\n\t * Translate the partition-relative block number to an absolute.\n\t */\n\tbn = bp->b_blkno;\n\tif (DISKPART(bp->b_dev) != RAW_PART) {\n\t\tpp = &cs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];\n\t\tbn += pp->p_offset;\n\t}\n\n\t/*\n\t * Allocate component buffers\n\t */\n\tcbpp = malloc(2 * cs->sc_nccdisks * sizeof(struct ccdbuf *), M_DEVBUF,\n\t    M_WAITOK);\n\tbzero(cbpp, 2 * cs->sc_nccdisks * sizeof(struct ccdbuf *));\n\taddr = bp->b_data;\n\told_io = old_io || ((vaddr_t)addr & CLOFSET); /* XXX !claligned */\n\tfor (bcount = bp->b_bcount; bcount > 0; bcount -= rcount) {\n\t\trcount = ccdbuffer(cs, bp, bn, addr, bcount, cbpp, old_io);\n\t\t\n\t\t/*\n\t\t * This is the old, slower, but less restrictive, mode of\n\t\t * operation.  It allows interleaves which are not multiples\n\t\t * of CLBYTES and mirroring.\n\t\t */\n\t\tif (old_io) {\n\t\t\tif ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)\n\t\t\t\tcbpp[0]->cb_buf.b_vp->v_numoutput++;\n\t\t\tVOP_STRATEGY(&cbpp[0]->cb_buf);\n\n\t\t\t/*\n\t\t\t * Mirror requires additional write.\n\t\t\t */\n\t\t\tif ((cs->sc_cflags & CCDF_MIRROR) &&\n\t\t\t    ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)) {\n\t\t\t\tcbpp[1]->cb_buf.b_vp->v_numoutput++;\n\t\t\t\tVOP_STRATEGY(&cbpp[1]->cb_buf);\n\t\t\t}\n\t\t}\n\n\t\tbn += btodb(rcount);\n\t\taddr += rcount;\n\t}\n\n\t/* The new leaner mode of operation */\n\tif (!old_io)\n\t\t/*\n\t\t * Fire off the requests\n\t\t */\n\t\tfor (i = 0; i < cs->sc_nccdisks; i++) {\n\t\t\tcbp = cbpp[i];\n\t\t\tif (cbp) {\n\t\t\t\tif ((cbp->cb_buf.b_flags & B_READ) == 0)\n\t\t\t\t\tcbp->cb_buf.b_vp->v_numoutput++;\n\t\t\t\tVOP_STRATEGY(&cbp->cb_buf);\n\t\t\t}\n\t\t}\n\tfree(cbpp, M_DEVBUF);\n}"
  },
  {
    "function_name": "ccdstrategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "694-742",
    "snippet": "void\nccdstrategy(bp)\n\tstruct buf *bp;\n{\n\tint unit = ccdunit(bp->b_dev);\n\tstruct ccd_softc *cs = &ccd_softc[unit];\n\tint s;\n\tint wlabel;\n\tstruct disklabel *lp;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdstrategy(%p): unit %d\\n\", bp, unit);\n#endif\n\tif ((cs->sc_flags & CCDF_INITED) == 0) {\n\t\tbp->b_error = ENXIO;\n\t\tbp->b_resid = bp->b_bcount;\n\t\tbp->b_flags |= B_ERROR;\n\t\tgoto done;\n\t}\n\n\t/* If it's a nil transfer, wake up the top half now. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\n\tlp = cs->sc_dkdev.dk_label;\n\n\t/*\n\t * Do bounds checking and adjust transfer.  If there's an\n\t * error, the bounds check will flag that for us.\n\t */\n\twlabel = cs->sc_flags & (CCDF_WLABEL|CCDF_LABELLING);\n\tif (DISKPART(bp->b_dev) != RAW_PART &&\n\t    bounds_check_with_label(bp, lp, cs->sc_dkdev.dk_cpulabel,\n\t    wlabel) <= 0)\n\t\tgoto done;\n\n\tbp->b_resid = bp->b_bcount;\n\n\t/*\n\t * \"Start\" the unit.\n\t */\n\ts = splbio();\n\tccdstart(cs, bp);\n\tsplx(s);\n\treturn;\ndone:\n\tbiodone(bp);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_FOLLOW\t0x01",
      "#define DEBUG"
    ],
    "globals_used": [
      "void\tccdstart",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdstart",
          "args": [
            "cs",
            "bp"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "ccdstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "744-822",
          "snippet": "void\nccdstart(cs, bp)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n{\n\tlong bcount, rcount;\n\tstruct ccdbuf **cbpp, *cbp;\n\tcaddr_t addr;\n\tdaddr_t bn;\n\tstruct partition *pp;\n\tint i, old_io = ccddevs[cs->sc_unit].ccd_flags & CCDF_OLD;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdstart(%p, %p)\\n\", cs, bp);\n#endif\n\n\t/* Instrumentation. */\n\tdisk_busy(&cs->sc_dkdev);\n\n\t/*\n\t * Translate the partition-relative block number to an absolute.\n\t */\n\tbn = bp->b_blkno;\n\tif (DISKPART(bp->b_dev) != RAW_PART) {\n\t\tpp = &cs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];\n\t\tbn += pp->p_offset;\n\t}\n\n\t/*\n\t * Allocate component buffers\n\t */\n\tcbpp = malloc(2 * cs->sc_nccdisks * sizeof(struct ccdbuf *), M_DEVBUF,\n\t    M_WAITOK);\n\tbzero(cbpp, 2 * cs->sc_nccdisks * sizeof(struct ccdbuf *));\n\taddr = bp->b_data;\n\told_io = old_io || ((vaddr_t)addr & CLOFSET); /* XXX !claligned */\n\tfor (bcount = bp->b_bcount; bcount > 0; bcount -= rcount) {\n\t\trcount = ccdbuffer(cs, bp, bn, addr, bcount, cbpp, old_io);\n\t\t\n\t\t/*\n\t\t * This is the old, slower, but less restrictive, mode of\n\t\t * operation.  It allows interleaves which are not multiples\n\t\t * of CLBYTES and mirroring.\n\t\t */\n\t\tif (old_io) {\n\t\t\tif ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)\n\t\t\t\tcbpp[0]->cb_buf.b_vp->v_numoutput++;\n\t\t\tVOP_STRATEGY(&cbpp[0]->cb_buf);\n\n\t\t\t/*\n\t\t\t * Mirror requires additional write.\n\t\t\t */\n\t\t\tif ((cs->sc_cflags & CCDF_MIRROR) &&\n\t\t\t    ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)) {\n\t\t\t\tcbpp[1]->cb_buf.b_vp->v_numoutput++;\n\t\t\t\tVOP_STRATEGY(&cbpp[1]->cb_buf);\n\t\t\t}\n\t\t}\n\n\t\tbn += btodb(rcount);\n\t\taddr += rcount;\n\t}\n\n\t/* The new leaner mode of operation */\n\tif (!old_io)\n\t\t/*\n\t\t * Fire off the requests\n\t\t */\n\t\tfor (i = 0; i < cs->sc_nccdisks; i++) {\n\t\t\tcbp = cbpp[i];\n\t\t\tif (cbp) {\n\t\t\t\tif ((cbp->cb_buf.b_flags & B_READ) == 0)\n\t\t\t\t\tcbp->cb_buf.b_vp->v_numoutput++;\n\t\t\t\tVOP_STRATEGY(&cbp->cb_buf);\n\t\t\t}\n\t\t}\n\tfree(cbpp, M_DEVBUF);\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define CCDB_FOLLOW\t0x01",
            "#define DEBUG"
          ],
          "globals_used": [
            "void\tccdstart",
            "long\tccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,\n    long, struct ccdbuf **, int));",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nvoid\tccdstart;\nlong\tccdbuffer __P((struct ccd_softc *, struct buf *, daddr_t, caddr_t,\n    long, struct ccdbuf **, int));\nINLINE struct;\n\nvoid\nccdstart(cs, bp)\n\tstruct ccd_softc *cs;\n\tstruct buf *bp;\n{\n\tlong bcount, rcount;\n\tstruct ccdbuf **cbpp, *cbp;\n\tcaddr_t addr;\n\tdaddr_t bn;\n\tstruct partition *pp;\n\tint i, old_io = ccddevs[cs->sc_unit].ccd_flags & CCDF_OLD;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdstart(%p, %p)\\n\", cs, bp);\n#endif\n\n\t/* Instrumentation. */\n\tdisk_busy(&cs->sc_dkdev);\n\n\t/*\n\t * Translate the partition-relative block number to an absolute.\n\t */\n\tbn = bp->b_blkno;\n\tif (DISKPART(bp->b_dev) != RAW_PART) {\n\t\tpp = &cs->sc_dkdev.dk_label->d_partitions[DISKPART(bp->b_dev)];\n\t\tbn += pp->p_offset;\n\t}\n\n\t/*\n\t * Allocate component buffers\n\t */\n\tcbpp = malloc(2 * cs->sc_nccdisks * sizeof(struct ccdbuf *), M_DEVBUF,\n\t    M_WAITOK);\n\tbzero(cbpp, 2 * cs->sc_nccdisks * sizeof(struct ccdbuf *));\n\taddr = bp->b_data;\n\told_io = old_io || ((vaddr_t)addr & CLOFSET); /* XXX !claligned */\n\tfor (bcount = bp->b_bcount; bcount > 0; bcount -= rcount) {\n\t\trcount = ccdbuffer(cs, bp, bn, addr, bcount, cbpp, old_io);\n\t\t\n\t\t/*\n\t\t * This is the old, slower, but less restrictive, mode of\n\t\t * operation.  It allows interleaves which are not multiples\n\t\t * of CLBYTES and mirroring.\n\t\t */\n\t\tif (old_io) {\n\t\t\tif ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)\n\t\t\t\tcbpp[0]->cb_buf.b_vp->v_numoutput++;\n\t\t\tVOP_STRATEGY(&cbpp[0]->cb_buf);\n\n\t\t\t/*\n\t\t\t * Mirror requires additional write.\n\t\t\t */\n\t\t\tif ((cs->sc_cflags & CCDF_MIRROR) &&\n\t\t\t    ((cbpp[0]->cb_buf.b_flags & B_READ) == 0)) {\n\t\t\t\tcbpp[1]->cb_buf.b_vp->v_numoutput++;\n\t\t\t\tVOP_STRATEGY(&cbpp[1]->cb_buf);\n\t\t\t}\n\t\t}\n\n\t\tbn += btodb(rcount);\n\t\taddr += rcount;\n\t}\n\n\t/* The new leaner mode of operation */\n\tif (!old_io)\n\t\t/*\n\t\t * Fire off the requests\n\t\t */\n\t\tfor (i = 0; i < cs->sc_nccdisks; i++) {\n\t\t\tcbp = cbpp[i];\n\t\t\tif (cbp) {\n\t\t\t\tif ((cbp->cb_buf.b_flags & B_READ) == 0)\n\t\t\t\t\tcbp->cb_buf.b_vp->v_numoutput++;\n\t\t\t\tVOP_STRATEGY(&cbp->cb_buf);\n\t\t\t}\n\t\t}\n\tfree(cbpp, M_DEVBUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bounds_check_with_label",
          "args": [
            "bp",
            "lp",
            "cs->sc_dkdev.dk_cpulabel",
            "wlabel"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdstrategy(%p): unit %d\\n\"",
            "bp",
            "unit"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ccdunit",
          "args": [
            "bp->b_dev"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nvoid\tccdstart;\nINLINE struct;\n\nvoid\nccdstrategy(bp)\n\tstruct buf *bp;\n{\n\tint unit = ccdunit(bp->b_dev);\n\tstruct ccd_softc *cs = &ccd_softc[unit];\n\tint s;\n\tint wlabel;\n\tstruct disklabel *lp;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdstrategy(%p): unit %d\\n\", bp, unit);\n#endif\n\tif ((cs->sc_flags & CCDF_INITED) == 0) {\n\t\tbp->b_error = ENXIO;\n\t\tbp->b_resid = bp->b_bcount;\n\t\tbp->b_flags |= B_ERROR;\n\t\tgoto done;\n\t}\n\n\t/* If it's a nil transfer, wake up the top half now. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\n\tlp = cs->sc_dkdev.dk_label;\n\n\t/*\n\t * Do bounds checking and adjust transfer.  If there's an\n\t * error, the bounds check will flag that for us.\n\t */\n\twlabel = cs->sc_flags & (CCDF_WLABEL|CCDF_LABELLING);\n\tif (DISKPART(bp->b_dev) != RAW_PART &&\n\t    bounds_check_with_label(bp, lp, cs->sc_dkdev.dk_cpulabel,\n\t    wlabel) <= 0)\n\t\tgoto done;\n\n\tbp->b_resid = bp->b_bcount;\n\n\t/*\n\t * \"Start\" the unit.\n\t */\n\ts = splbio();\n\tccdstart(cs, bp);\n\tsplx(s);\n\treturn;\ndone:\n\tbiodone(bp);\n}"
  },
  {
    "function_name": "ccdclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "653-692",
    "snippet": "int\nccdclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\tint error = 0, part;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdclose(%x, %x)\\n\", dev, flags);\n#endif\n\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((error = ccdlock(cs)) != 0)\n\t\treturn (error);\n\n\tpart = DISKPART(dev);\n\n\t/* ...that much closer to allowing unconfiguration... */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tcs->sc_dkdev.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tcs->sc_dkdev.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\tcs->sc_dkdev.dk_openmask =\n\t    cs->sc_dkdev.dk_copenmask | cs->sc_dkdev.dk_bopenmask;\n\n\tccdunlock(cs);\n\treturn (0);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_FOLLOW\t0x01",
      "#define DEBUG"
    ],
    "globals_used": [
      "int\tccdlock",
      "void\tccdunlock",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ccdunlock",
          "args": [
            "cs"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "ccdunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1667-1677",
          "snippet": "void\nccdunlock(cs)\n\tstruct ccd_softc *cs;\n{\n\n\tcs->sc_flags &= ~CCDF_LOCKED;\n\tif ((cs->sc_flags & CCDF_WANTED) != 0) {\n\t\tcs->sc_flags &= ~CCDF_WANTED;\n\t\twakeup(cs);\n\t}\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tccdunlock",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tccdunlock;\nINLINE struct;\n\nvoid\nccdunlock(cs)\n\tstruct ccd_softc *cs;\n{\n\n\tcs->sc_flags &= ~CCDF_LOCKED;\n\tif ((cs->sc_flags & CCDF_WANTED) != 0) {\n\t\tcs->sc_flags &= ~CCDF_WANTED;\n\t\twakeup(cs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdlock",
          "args": [
            "cs"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ccdlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1649-1662",
          "snippet": "int\nccdlock(cs)\n\tstruct ccd_softc *cs;\n{\n\tint error;\n\n\twhile ((cs->sc_flags & CCDF_LOCKED) != 0) {\n\t\tcs->sc_flags |= CCDF_WANTED;\n\t\tif ((error = tsleep(cs, PRIBIO | PCATCH, \"ccdlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tcs->sc_flags |= CCDF_LOCKED;\n\treturn (0);\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tccdlock",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tccdlock;\nINLINE struct;\n\nint\nccdlock(cs)\n\tstruct ccd_softc *cs;\n{\n\tint error;\n\n\twhile ((cs->sc_flags & CCDF_LOCKED) != 0) {\n\t\tcs->sc_flags |= CCDF_WANTED;\n\t\tif ((error = tsleep(cs, PRIBIO | PCATCH, \"ccdlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tcs->sc_flags |= CCDF_LOCKED;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdclose(%x, %x)\\n\"",
            "dev",
            "flags"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ccdunit",
          "args": [
            "dev"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nint\tccdlock;\nvoid\tccdunlock;\nINLINE struct;\n\nint\nccdclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\tint error = 0, part;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdclose(%x, %x)\\n\", dev, flags);\n#endif\n\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((error = ccdlock(cs)) != 0)\n\t\treturn (error);\n\n\tpart = DISKPART(dev);\n\n\t/* ...that much closer to allowing unconfiguration... */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tcs->sc_dkdev.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tcs->sc_dkdev.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\tcs->sc_dkdev.dk_openmask =\n\t    cs->sc_dkdev.dk_copenmask | cs->sc_dkdev.dk_bopenmask;\n\n\tccdunlock(cs);\n\treturn (0);\n}"
  },
  {
    "function_name": "ccdopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "589-650",
    "snippet": "int\nccdopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\tstruct disklabel *lp;\n\tint error = 0, part, pmask;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdopen(%x, %x)\\n\", dev, flags);\n#endif\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((error = ccdlock(cs)) != 0)\n\t\treturn (error);\n\n\tlp = cs->sc_dkdev.dk_label;\n\n\tpart = DISKPART(dev);\n\tpmask = (1 << part);\n\n\t/*\n\t * If we're initialized, check to see if there are any other\n\t * open partitions.  If not, then it's safe to update\n\t * the in-core disklabel.\n\t */\n\tif ((cs->sc_flags & CCDF_INITED) && (cs->sc_dkdev.dk_openmask == 0))\n\t\tccdgetdisklabel(dev);\n\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART) {\n\t\tif (((cs->sc_flags & CCDF_INITED) == 0) ||\n\t\t    ((part >= lp->d_npartitions) ||\n\t\t    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {\n\t\t\terror = ENXIO;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Prevent our unit from being unconfigured while open. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tcs->sc_dkdev.dk_copenmask |= pmask;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tcs->sc_dkdev.dk_bopenmask |= pmask;\n\t\tbreak;\n\t}\n\tcs->sc_dkdev.dk_openmask =\n\t    cs->sc_dkdev.dk_copenmask | cs->sc_dkdev.dk_bopenmask;\n\n done:\n\tccdunlock(cs);\n\treturn (error);\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_FOLLOW\t0x01",
      "#define DEBUG"
    ],
    "globals_used": [
      "void\tccdgetdisklabel",
      "int\tccdlock",
      "void\tccdunlock",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ccdunlock",
          "args": [
            "cs"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "ccdunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1667-1677",
          "snippet": "void\nccdunlock(cs)\n\tstruct ccd_softc *cs;\n{\n\n\tcs->sc_flags &= ~CCDF_LOCKED;\n\tif ((cs->sc_flags & CCDF_WANTED) != 0) {\n\t\tcs->sc_flags &= ~CCDF_WANTED;\n\t\twakeup(cs);\n\t}\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tccdunlock",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tccdunlock;\nINLINE struct;\n\nvoid\nccdunlock(cs)\n\tstruct ccd_softc *cs;\n{\n\n\tcs->sc_flags &= ~CCDF_LOCKED;\n\tif ((cs->sc_flags & CCDF_WANTED) != 0) {\n\t\tcs->sc_flags &= ~CCDF_WANTED;\n\t\twakeup(cs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ccdgetdisklabel",
          "args": [
            "dev"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "ccdgetdisklabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1571-1622",
          "snippet": "void\nccdgetdisklabel(dev)\n\tdev_t dev;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs = &ccd_softc[unit];\n\tchar *errstring;\n\tstruct disklabel *lp = cs->sc_dkdev.dk_label;\n\tstruct cpu_disklabel *clp = cs->sc_dkdev.dk_cpulabel;\n\tstruct ccdgeom *ccg = &cs->sc_geom;\n\n\tbzero(lp, sizeof(*lp));\n\tbzero(clp, sizeof(*clp));\n\n\tlp->d_secperunit = cs->sc_size;\n\tlp->d_secsize = ccg->ccg_secsize;\n\tlp->d_nsectors = ccg->ccg_nsectors;\n\tlp->d_ntracks = ccg->ccg_ntracks;\n\tlp->d_ncylinders = ccg->ccg_ncylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"ccd\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_CCD;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = cs->sc_size;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(cs->sc_dkdev.dk_label);\n\n\t/*\n\t * Call the generic disklabel extraction routine.\n\t */\n\terrstring = readdisklabel(CCDLABELDEV(dev), ccdstrategy,\n\t    cs->sc_dkdev.dk_label, cs->sc_dkdev.dk_cpulabel, 0);\n\tif (errstring)\n\t\tccdmakedisklabel(cs);\n\n#ifdef DEBUG\n\t/* It's actually extremely common to have unlabeled ccds. */\n\tif (ccddebug & CCDB_LABEL)\n\t\tif (errstring != NULL)\n\t\t\tprintf(\"%s: %s\\n\", cs->sc_xname, errstring);\n#endif\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define CCDB_LABEL\t0x08",
            "#define DEBUG"
          ],
          "globals_used": [
            "void\tccdgetdisklabel",
            "void\tccdmakedisklabel",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_LABEL\t0x08\n#define DEBUG\n\nvoid\tccdgetdisklabel;\nvoid\tccdmakedisklabel;\nINLINE struct;\n\nvoid\nccdgetdisklabel(dev)\n\tdev_t dev;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs = &ccd_softc[unit];\n\tchar *errstring;\n\tstruct disklabel *lp = cs->sc_dkdev.dk_label;\n\tstruct cpu_disklabel *clp = cs->sc_dkdev.dk_cpulabel;\n\tstruct ccdgeom *ccg = &cs->sc_geom;\n\n\tbzero(lp, sizeof(*lp));\n\tbzero(clp, sizeof(*clp));\n\n\tlp->d_secperunit = cs->sc_size;\n\tlp->d_secsize = ccg->ccg_secsize;\n\tlp->d_nsectors = ccg->ccg_nsectors;\n\tlp->d_ntracks = ccg->ccg_ntracks;\n\tlp->d_ncylinders = ccg->ccg_ncylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\n\tstrncpy(lp->d_typename, \"ccd\", sizeof(lp->d_typename));\n\tlp->d_type = DTYPE_CCD;\n\tstrncpy(lp->d_packname, \"fictitious\", sizeof(lp->d_packname));\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size = cs->sc_size;\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(cs->sc_dkdev.dk_label);\n\n\t/*\n\t * Call the generic disklabel extraction routine.\n\t */\n\terrstring = readdisklabel(CCDLABELDEV(dev), ccdstrategy,\n\t    cs->sc_dkdev.dk_label, cs->sc_dkdev.dk_cpulabel, 0);\n\tif (errstring)\n\t\tccdmakedisklabel(cs);\n\n#ifdef DEBUG\n\t/* It's actually extremely common to have unlabeled ccds. */\n\tif (ccddebug & CCDB_LABEL)\n\t\tif (errstring != NULL)\n\t\t\tprintf(\"%s: %s\\n\", cs->sc_xname, errstring);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccdlock",
          "args": [
            "cs"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ccdlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1649-1662",
          "snippet": "int\nccdlock(cs)\n\tstruct ccd_softc *cs;\n{\n\tint error;\n\n\twhile ((cs->sc_flags & CCDF_LOCKED) != 0) {\n\t\tcs->sc_flags |= CCDF_WANTED;\n\t\tif ((error = tsleep(cs, PRIBIO | PCATCH, \"ccdlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tcs->sc_flags |= CCDF_LOCKED;\n\treturn (0);\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tccdlock",
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tccdlock;\nINLINE struct;\n\nint\nccdlock(cs)\n\tstruct ccd_softc *cs;\n{\n\tint error;\n\n\twhile ((cs->sc_flags & CCDF_LOCKED) != 0) {\n\t\tcs->sc_flags |= CCDF_WANTED;\n\t\tif ((error = tsleep(cs, PRIBIO | PCATCH, \"ccdlck\", 0)) != 0)\n\t\t\treturn (error);\n\t}\n\tcs->sc_flags |= CCDF_LOCKED;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdopen(%x, %x)\\n\"",
            "dev",
            "flags"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ccdunit",
          "args": [
            "dev"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_FOLLOW\t0x01\n#define DEBUG\n\nvoid\tccdgetdisklabel;\nint\tccdlock;\nvoid\tccdunlock;\nINLINE struct;\n\nint\nccdopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags, fmt;\n\tstruct proc *p;\n{\n\tint unit = ccdunit(dev);\n\tstruct ccd_softc *cs;\n\tstruct disklabel *lp;\n\tint error = 0, part, pmask;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_FOLLOW)\n\t\tprintf(\"ccdopen(%x, %x)\\n\", dev, flags);\n#endif\n\tif (unit >= numccd)\n\t\treturn (ENXIO);\n\tcs = &ccd_softc[unit];\n\n\tif ((error = ccdlock(cs)) != 0)\n\t\treturn (error);\n\n\tlp = cs->sc_dkdev.dk_label;\n\n\tpart = DISKPART(dev);\n\tpmask = (1 << part);\n\n\t/*\n\t * If we're initialized, check to see if there are any other\n\t * open partitions.  If not, then it's safe to update\n\t * the in-core disklabel.\n\t */\n\tif ((cs->sc_flags & CCDF_INITED) && (cs->sc_dkdev.dk_openmask == 0))\n\t\tccdgetdisklabel(dev);\n\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART) {\n\t\tif (((cs->sc_flags & CCDF_INITED) == 0) ||\n\t\t    ((part >= lp->d_npartitions) ||\n\t\t    (lp->d_partitions[part].p_fstype == FS_UNUSED))) {\n\t\t\terror = ENXIO;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Prevent our unit from being unconfigured while open. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tcs->sc_dkdev.dk_copenmask |= pmask;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\t\tcs->sc_dkdev.dk_bopenmask |= pmask;\n\t\tbreak;\n\t}\n\tcs->sc_dkdev.dk_openmask =\n\t    cs->sc_dkdev.dk_copenmask | cs->sc_dkdev.dk_bopenmask;\n\n done:\n\tccdunlock(cs);\n\treturn (error);\n}"
  },
  {
    "function_name": "ccdinterleave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
    "lines": "484-586",
    "snippet": "void\nccdinterleave(cs, unit)\n\tstruct ccd_softc *cs;\n\tint unit;\n{\n\tstruct ccdcinfo *ci, *smallci;\n\tstruct ccdiinfo *ii;\n\tdaddr_t bn, lbn;\n\tint ix;\n\tu_long size;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_INIT)\n\t\tprintf(\"ccdinterleave(%p): ileave %d\\n\", cs, cs->sc_ileave);\n#endif\n\t/*\n\t * Allocate an interleave table.\n\t * Chances are this is too big, but we don't care.\n\t */\n\tsize = (cs->sc_nccdisks + 1) * sizeof(struct ccdiinfo);\n\tcs->sc_itable = (struct ccdiinfo *)malloc(size, M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)cs->sc_itable, size);\n\n\t/*\n\t * Trivial case: no interleave (actually interleave of disk size).\n\t * Each table entry represents a single component in its entirety.\n\t */\n\tif (cs->sc_ileave == 0) {\n\t\tbn = 0;\n\t\tii = cs->sc_itable;\n\n\t\tfor (ix = 0; ix < cs->sc_nccdisks; ix++) {\n\t\t\t/* Allocate space for ii_index. */\n\t\t\tii->ii_index = malloc(sizeof(int), M_DEVBUF, M_WAITOK);\n\t\t\tii->ii_ndisk = 1;\n\t\t\tii->ii_startblk = bn;\n\t\t\tii->ii_startoff = 0;\n\t\t\tii->ii_index[0] = ix;\n\t\t\tbn += cs->sc_cinfo[ix].ci_size;\n\t\t\tii++;\n\t\t}\n\t\tii->ii_ndisk = 0;\n#ifdef DEBUG\n\t\tif (ccddebug & CCDB_INIT)\n\t\t\tprintiinfo(cs->sc_itable);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * The following isn't fast or pretty; it doesn't have to be.\n\t */\n\tsize = 0;\n\tbn = lbn = 0;\n\tfor (ii = cs->sc_itable; ; ii++) {\n\t\t/* Allocate space for ii_index. */\n\t\tii->ii_index = malloc((sizeof(int) * cs->sc_nccdisks),\n\t\t    M_DEVBUF, M_WAITOK);\n\n\t\t/*\n\t\t * Locate the smallest of the remaining components\n\t\t */\n\t\tsmallci = NULL;\n\t\tfor (ci = cs->sc_cinfo;\n\t\t    ci < &cs->sc_cinfo[cs->sc_nccdisks]; ci++)\n\t\t\tif (ci->ci_size > size &&\n\t\t\t    (smallci == NULL ||\n\t\t\t    ci->ci_size < smallci->ci_size))\n\t\t\t\tsmallci = ci;\n\n\t\t/*\n\t\t * Nobody left, all done\n\t\t */\n\t\tif (smallci == NULL) {\n\t\t\tii->ii_ndisk = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Record starting logical block and component offset\n\t\t */\n\t\tii->ii_startblk = bn / cs->sc_ileave;\n\t\tii->ii_startoff = lbn;\n\n\t\t/*\n\t\t * Determine how many disks take part in this interleave\n\t\t * and record their indices.\n\t\t */\n\t\tix = 0;\n\t\tfor (ci = cs->sc_cinfo;\n\t\t    ci < &cs->sc_cinfo[cs->sc_nccdisks]; ci++)\n\t\t\tif (ci->ci_size >= smallci->ci_size)\n\t\t\t\tii->ii_index[ix++] = ci - cs->sc_cinfo;\n\t\tii->ii_ndisk = ix;\n\t\tbn += ix * (smallci->ci_size - size);\n\t\tlbn = smallci->ci_size / cs->sc_ileave;\n\t\tsize = smallci->ci_size;\n\t}\n#ifdef DEBUG\n\tif (ccddebug & CCDB_INIT)\n\t\tprintiinfo(cs->sc_itable);\n#endif\n}",
    "includes": [
      "#include <uvm/uvm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <dev/ccdvar.h>",
      "#include <sys/conf.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/namei.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/errno.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define CCDB_INIT\t0x02",
      "#define DEBUG"
    ],
    "globals_used": [
      "void\tccdinterleave",
      "INLINE struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printiinfo",
          "args": [
            "cs->sc_itable"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "printiinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ccd.c",
          "lines": "1680-1693",
          "snippet": "void\nprintiinfo(ii)\n\tstruct ccdiinfo *ii;\n{\n\tint ix, i;\n\n\tfor (ix = 0; ii->ii_ndisk; ix++, ii++) {\n\t\tprintf(\" itab[%d]: #dk %d sblk %d soff %d\",\n\t\t       ix, ii->ii_ndisk, ii->ii_startblk, ii->ii_startoff);\n\t\tfor (i = 0; i < ii->ii_ndisk; i++)\n\t\t\tprintf(\" %d\", ii->ii_index[i]);\n\t\tprintf(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <uvm/uvm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <dev/ccdvar.h>",
            "#include <sys/conf.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/namei.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/errno.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "INLINE struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nINLINE struct;\n\nvoid\nprintiinfo(ii)\n\tstruct ccdiinfo *ii;\n{\n\tint ix, i;\n\n\tfor (ix = 0; ii->ii_ndisk; ix++, ii++) {\n\t\tprintf(\" itab[%d]: #dk %d sblk %d soff %d\",\n\t\t       ix, ii->ii_ndisk, ii->ii_startblk, ii->ii_startoff);\n\t\tfor (i = 0; i < ii->ii_ndisk; i++)\n\t\t\tprintf(\" %d\", ii->ii_index[i]);\n\t\tprintf(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(sizeof(int) * cs->sc_nccdisks)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t)cs->sc_itable",
            "size"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccdinterleave(%p): ileave %d\\n\"",
            "cs",
            "cs->sc_ileave"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uvm/uvm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <dev/ccdvar.h>\n#include <sys/conf.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/namei.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/errno.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define CCDB_INIT\t0x02\n#define DEBUG\n\nvoid\tccdinterleave;\nINLINE struct;\n\nvoid\nccdinterleave(cs, unit)\n\tstruct ccd_softc *cs;\n\tint unit;\n{\n\tstruct ccdcinfo *ci, *smallci;\n\tstruct ccdiinfo *ii;\n\tdaddr_t bn, lbn;\n\tint ix;\n\tu_long size;\n\n#ifdef DEBUG\n\tif (ccddebug & CCDB_INIT)\n\t\tprintf(\"ccdinterleave(%p): ileave %d\\n\", cs, cs->sc_ileave);\n#endif\n\t/*\n\t * Allocate an interleave table.\n\t * Chances are this is too big, but we don't care.\n\t */\n\tsize = (cs->sc_nccdisks + 1) * sizeof(struct ccdiinfo);\n\tcs->sc_itable = (struct ccdiinfo *)malloc(size, M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)cs->sc_itable, size);\n\n\t/*\n\t * Trivial case: no interleave (actually interleave of disk size).\n\t * Each table entry represents a single component in its entirety.\n\t */\n\tif (cs->sc_ileave == 0) {\n\t\tbn = 0;\n\t\tii = cs->sc_itable;\n\n\t\tfor (ix = 0; ix < cs->sc_nccdisks; ix++) {\n\t\t\t/* Allocate space for ii_index. */\n\t\t\tii->ii_index = malloc(sizeof(int), M_DEVBUF, M_WAITOK);\n\t\t\tii->ii_ndisk = 1;\n\t\t\tii->ii_startblk = bn;\n\t\t\tii->ii_startoff = 0;\n\t\t\tii->ii_index[0] = ix;\n\t\t\tbn += cs->sc_cinfo[ix].ci_size;\n\t\t\tii++;\n\t\t}\n\t\tii->ii_ndisk = 0;\n#ifdef DEBUG\n\t\tif (ccddebug & CCDB_INIT)\n\t\t\tprintiinfo(cs->sc_itable);\n#endif\n\t\treturn;\n\t}\n\n\t/*\n\t * The following isn't fast or pretty; it doesn't have to be.\n\t */\n\tsize = 0;\n\tbn = lbn = 0;\n\tfor (ii = cs->sc_itable; ; ii++) {\n\t\t/* Allocate space for ii_index. */\n\t\tii->ii_index = malloc((sizeof(int) * cs->sc_nccdisks),\n\t\t    M_DEVBUF, M_WAITOK);\n\n\t\t/*\n\t\t * Locate the smallest of the remaining components\n\t\t */\n\t\tsmallci = NULL;\n\t\tfor (ci = cs->sc_cinfo;\n\t\t    ci < &cs->sc_cinfo[cs->sc_nccdisks]; ci++)\n\t\t\tif (ci->ci_size > size &&\n\t\t\t    (smallci == NULL ||\n\t\t\t    ci->ci_size < smallci->ci_size))\n\t\t\t\tsmallci = ci;\n\n\t\t/*\n\t\t * Nobody left, all done\n\t\t */\n\t\tif (smallci == NULL) {\n\t\t\tii->ii_ndisk = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Record starting logical block and component offset\n\t\t */\n\t\tii->ii_startblk = bn / cs->sc_ileave;\n\t\tii->ii_startoff = lbn;\n\n\t\t/*\n\t\t * Determine how many disks take part in this interleave\n\t\t * and record their indices.\n\t\t */\n\t\tix = 0;\n\t\tfor (ci = cs->sc_cinfo;\n\t\t    ci < &cs->sc_cinfo[cs->sc_nccdisks]; ci++)\n\t\t\tif (ci->ci_size >= smallci->ci_size)\n\t\t\t\tii->ii_index[ix++] = ci - cs->sc_cinfo;\n\t\tii->ii_ndisk = ix;\n\t\tbn += ix * (smallci->ci_size - size);\n\t\tlbn = smallci->ci_size / cs->sc_ileave;\n\t\tsize = smallci->ci_size;\n\t}\n#ifdef DEBUG\n\tif (ccddebug & CCDB_INIT)\n\t\tprintiinfo(cs->sc_itable);\n#endif\n}"
  }
]