[
  {
    "function_name": "bt_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "1300-1345",
    "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
    ],
    "globals_used": [
      "bt_finish_ccbs __P((struct bt_softc *));",
      "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "void bt_queue_ccb",
      "void bt_collect_mbo",
      "void bt_timeout",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "int flags;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_queue_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "bt_queue_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "640-648",
          "snippet": "void\nbt_queue_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\tbt_start_ccbs(sc);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_start_ccbs",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_start_ccbs;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_queue_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\tbt_start_ccbs(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_collect_mbo",
          "args": [
            "sc"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "bt_collect_mbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "653-677",
          "snippet": "void\nbt_collect_mbo(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef BTDIAG\n\tstruct bt_ccb *ccb;\n#endif\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != BT_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef BTDIAG\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "struct bt_ccb *bt_ccb_phys_kv",
            "void bt_collect_mbo",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *bt_ccb_phys_kv;\nvoid bt_collect_mbo;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_collect_mbo(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef BTDIAG\n\tstruct bt_ccb *ccb;\n#endif\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != BT_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef BTDIAG\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "bt_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "1276-1298",
    "snippet": "int\nbt_poll(sc, xs, count)\n\tstruct bt_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint iobase = sc->sc_iobase;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (inb(iobase + BT_INTR_PORT) & BT_INTR_ANYINTR)\n\t\t\tbtintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bt_finish_ccbs __P((struct bt_softc *));",
      "int btintr",
      "int bt_poll",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "int flags;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btintr",
          "args": [
            "sc"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "btintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "471-513",
          "snippet": "int\nbtintr(arg)\n\tvoid *arg;\n{\n\tstruct bt_softc *sc = arg;\n\tint iobase = sc->sc_iobase;\n\tu_char sts;\n\n#ifdef BTDEBUG\n\tprintf(\"%s: btintr \", sc->sc_dev.dv_xname);\n#endif /* BTDEBUG */\n\n\t/*\n\t * First acknowlege the interrupt, Then if it's not telling about\n\t * a completed operation just return.\n\t */\n\tsts = inb(iobase + BT_INTR_PORT);\n\tif ((sts & BT_INTR_ANYINTR) == 0)\n\t\treturn 0;\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\n#ifdef BTDIAG\n\t/* Make sure we clear CCB_SENDING before finishing a CCB. */\n\tbt_collect_mbo(sc);\n#endif\n\n\t/* Mail box out empty? */\n\tif (sts & BT_INTR_MBOA) {\n\t\tstruct bt_toggle toggle;\n\n\t\ttoggle.cmd.opcode = BT_MBO_INTR_EN;\n\t\ttoggle.cmd.enable = 0;\n\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd, 0,\n\t\t    (u_char *)0);\n\t\tbt_start_ccbs(sc);\n\t}\n\n\t/* Mail box in full? */\n\tif (sts & BT_INTR_MBIF)\n\t\tbt_finish_ccbs(sc);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "int btintr",
            "void bt_collect_mbo",
            "void bt_start_ccbs",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nint btintr;\nvoid bt_collect_mbo;\nvoid bt_start_ccbs;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbtintr(arg)\n\tvoid *arg;\n{\n\tstruct bt_softc *sc = arg;\n\tint iobase = sc->sc_iobase;\n\tu_char sts;\n\n#ifdef BTDEBUG\n\tprintf(\"%s: btintr \", sc->sc_dev.dv_xname);\n#endif /* BTDEBUG */\n\n\t/*\n\t * First acknowlege the interrupt, Then if it's not telling about\n\t * a completed operation just return.\n\t */\n\tsts = inb(iobase + BT_INTR_PORT);\n\tif ((sts & BT_INTR_ANYINTR) == 0)\n\t\treturn 0;\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\n#ifdef BTDIAG\n\t/* Make sure we clear CCB_SENDING before finishing a CCB. */\n\tbt_collect_mbo(sc);\n#endif\n\n\t/* Mail box out empty? */\n\tif (sts & BT_INTR_MBOA) {\n\t\tstruct bt_toggle toggle;\n\n\t\ttoggle.cmd.opcode = BT_MBO_INTR_EN;\n\t\ttoggle.cmd.enable = 0;\n\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd, 0,\n\t\t    (u_char *)0);\n\t\tbt_start_ccbs(sc);\n\t}\n\n\t/* Mail box in full? */\n\tif (sts & BT_INTR_MBIF)\n\t\tbt_finish_ccbs(sc);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + BT_INTR_PORT"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nint btintr;\nint bt_poll;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_poll(sc, xs, count)\n\tstruct bt_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint iobase = sc->sc_iobase;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (inb(iobase + BT_INTR_PORT) & BT_INTR_ANYINTR)\n\t\t\tbtintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "bt_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "1102-1271",
    "snippet": "int\nbt_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tstruct bt_ccb *ccb;\n\tstruct bt_scat_gath *sg;\n\tint seg;\t\t/* scatter gather seg being worked on */\n\tu_long thiskv, thisphys, nextphys;\n\tint bytes_this_seg, bytes_this_page, datalen, flags;\n#ifdef TFS\n\tstruct iovec *iovp;\n#endif\n\tint s;\n\n\tSC_DEBUG(sc_link, SDEV_DB2, (\"bt_scsi_cmd\\n\"));\n\t/*\n\t * get a ccb to use. If the transfer\n\t * is from a buf (possibly from interrupt time)\n\t * then we can't allow it to sleep\n\t */\n\tflags = xs->flags;\n\tif ((ccb = bt_get_ccb(sc, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\t/*\n\t * Put all the arguments for the xfer in the ccb\n\t */\n\tif (flags & SCSI_RESET) {\n\t\tccb->opcode = BT_RESET_CCB;\n\t\tccb->scsi_cmd_length = 0;\n\t} else {\n\t\t/* can't use S/G if zero length */\n\t\tccb->opcode = (xs->datalen ? BT_INIT_SCAT_GATH_CCB\n\t\t\t\t\t   : BT_INITIATOR_CCB);\n\t\tbcopy(xs->cmd, &ccb->scsi_cmd,\n\t\t    ccb->scsi_cmd_length = xs->cmdlen);\n\t}\n\n\tif (xs->datalen) {\n\t\tsg = ccb->scat_gath;\n\t\tseg = 0;\n#ifdef\tTFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\tiovp = ((struct uio *)xs->data)->uio_iov;\n\t\t\tdatalen = ((struct uio *)xs->data)->uio_iovcnt;\n\t\t\txs->datalen = 0;\n\t\t\twhile (datalen && seg < BT_NSEG) {\n\t\t\t\tltophys(iovp->iov_base, sg->seg_addr);\n\t\t\t\tltophys(iovp->iov_len, sg->seg_len);\n\t\t\t\txs->datalen += iovp->iov_len;\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base));\n\t\t\t\tsg++;\n\t\t\t\tiovp++;\n\t\t\t\tseg++;\n\t\t\t\tdatalen--;\n\t\t\t}\n\t\t} else\n#endif\t/* TFS */\n\t\t{\n\t\t\t/*\n\t\t\t * Set up the scatter-gather block.\n\t\t\t */\n\t\t\tSC_DEBUG(sc_link, SDEV_DB4,\n\t\t\t    (\"%d @0x%x:- \", xs->datalen, xs->data));\n\n\t\t\tdatalen = xs->datalen;\n\t\t\tthiskv = (int)xs->data;\n\t\t\tthisphys = KVTOPHYS(thiskv);\n\n\t\t\twhile (datalen && seg < BT_NSEG) {\n\t\t\t\tbytes_this_seg = 0;\n\n\t\t\t\t/* put in the base address */\n\t\t\t\tltophys(thisphys, sg->seg_addr);\n\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"0x%x\", thisphys));\n\n\t\t\t\t/* do it at least once */\n\t\t\t\tnextphys = thisphys;\n\t\t\t\twhile (datalen && thisphys == nextphys) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This page is contiguous (physically)\n\t\t\t\t\t * with the the last, just extend the\n\t\t\t\t\t * length\n\t\t\t\t\t */\n\t\t\t\t\t/* how far to the end of the page */\n\t\t\t\t\tnextphys = (thisphys & ~PGOFSET) + NBPG;\n\t\t\t\t\tbytes_this_page = nextphys - thisphys;\n\t\t\t\t\t/**** or the data ****/\n\t\t\t\t\tbytes_this_page = min(bytes_this_page,\n\t\t\t\t\t\t\t      datalen);\n\t\t\t\t\tbytes_this_seg += bytes_this_page;\n\t\t\t\t\tdatalen -= bytes_this_page;\n\n\t\t\t\t\t/* get more ready for the next page */\n\t\t\t\t\tthiskv = (thiskv & ~PGOFSET) + NBPG;\n\t\t\t\t\tif (datalen)\n\t\t\t\t\t\tthisphys = KVTOPHYS(thiskv);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * next page isn't contiguous, finish the seg\n\t\t\t\t */\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4,\n\t\t\t\t    (\"(0x%x)\", bytes_this_seg));\n\t\t\t\tltophys(bytes_this_seg, sg->seg_len);\n\t\t\t\tsg++;\n\t\t\t\tseg++;\n\t\t\t}\n\t\t}\n\t\t/* end of iov/kv decision */\n\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"\\n\"));\n\t\tif (datalen) {\n\t\t\t/*\n\t\t\t * there's still data, must have run out of segs!\n\t\t\t */\n\t\t\tprintf(\"%s: bt_scsi_cmd, more than %d dma segs\\n\",\n\t\t\t    sc->sc_dev.dv_xname, BT_NSEG);\n\t\t\tgoto bad;\n\t\t}\n\t\tltophys(KVTOPHYS(ccb->scat_gath), ccb->data_addr);\n\t\tltophys(seg * sizeof(struct bt_scat_gath), ccb->data_length);\n\t} else {\t\t/* No data xfer, use non S/G values */\n\t\tltophys(0, ccb->data_addr);\n\t\tltophys(0, ccb->data_length);\n\t}\n\n\tccb->data_out = 0;\n\tccb->data_in = 0;\n\tccb->target = sc_link->target;\n\tccb->lun = sc_link->lun;\n\tltophys(KVTOPHYS(&ccb->scsi_sense), ccb->sense_ptr);\n\tccb->req_sense_length = sizeof(ccb->scsi_sense);\n\tccb->host_stat = 0x00;\n\tccb->target_stat = 0x00;\n\tccb->link_id = 0;\n\tltophys(0, ccb->link_addr);\n\n\ts = splbio();\n\tbt_queue_ccb(sc, ccb);\n\tsplx(s);\n\n\t/*\n\t * Usually return SUCCESSFULLY QUEUED\n\t */\n\tSC_DEBUG(sc_link, SDEV_DB3, (\"cmd_sent\\n\"));\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn SUCCESSFULLY_QUEUED;\n\n\t/*\n\t * If we can't use interrupts, poll on completion\n\t */\n\tif (bt_poll(sc, xs, ccb->timeout)) {\n\t\tbt_timeout(ccb);\n\t\tif (bt_poll(sc, xs, ccb->timeout))\n\t\t\tbt_timeout(ccb);\n\t}\n\treturn COMPLETE;\n\nbad:\n\txs->error = XS_DRIVER_STUFFUP;\n\tbt_free_ccb(sc, ccb);\n\treturn COMPLETE;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bt_finish_ccbs __P((struct bt_softc *));",
      "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "void bt_free_ccb",
      "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "struct bt_ccb *bt_get_ccb",
      "void bt_queue_ccb",
      "int bt_scsi_cmd",
      "int bt_poll",
      "void bt_timeout",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "int flags;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_free_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "bt_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "527-547",
          "snippet": "void\nbt_free_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\n\tbt_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_free_ccb",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_free_ccb;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_free_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\n\tbt_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt_timeout",
          "args": [
            "ccb"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt_poll",
          "args": [
            "sc",
            "xs",
            "ccb->timeout"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "bt_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1276-1298",
          "snippet": "int\nbt_poll(sc, xs, count)\n\tstruct bt_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint iobase = sc->sc_iobase;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (inb(iobase + BT_INTR_PORT) & BT_INTR_ANYINTR)\n\t\t\tbtintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "int btintr",
            "int bt_poll",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nint btintr;\nint bt_poll;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_poll(sc, xs, count)\n\tstruct bt_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint iobase = sc->sc_iobase;\n\n\t/* timeouts are in msec, so we loop in 1000 usec cycles */\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (inb(iobase + BT_INTR_PORT) & BT_INTR_ANYINTR)\n\t\t\tbtintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\t/* only happens in boot so ok */\n\t\tcount--;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB3",
            "(\"cmd_sent\\n\")"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_queue_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "bt_queue_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "640-648",
          "snippet": "void\nbt_queue_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\tbt_start_ccbs(sc);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_start_ccbs",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_start_ccbs;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_queue_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\tbt_start_ccbs(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "0",
            "ccb->link_addr"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "KVTOPHYS(&ccb->scsi_sense)",
            "ccb->sense_ptr"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "&ccb->scsi_sense"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "0",
            "ccb->data_length"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "0",
            "ccb->data_addr"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "seg * sizeof(struct bt_scat_gath)",
            "ccb->data_length"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "KVTOPHYS(ccb->scat_gath)",
            "ccb->data_addr"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "ccb->scat_gath"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bt_scsi_cmd, more than %d dma segs\\n\"",
            "sc->sc_dev.dv_xname",
            "BT_NSEG"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"\\n\")"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "bytes_this_seg",
            "sg->seg_len"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"(0x%x)\", bytes_this_seg)"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "thiskv"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes_this_page",
            "datalen"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "btminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1088-1096",
          "snippet": "void\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void btminphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid btminphys;\n\nvoid\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"0x%x\", thisphys)"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "thisphys",
            "sg->seg_addr"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "thiskv"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"%d @0x%x:- \", xs->datalen, xs->data)"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base)"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "iovp->iov_len",
            "sg->seg_len"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "iovp->iov_base",
            "sg->seg_addr"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "xs->cmd",
            "&ccb->scsi_cmd",
            "ccb->scsi_cmd_length = xs->cmdlen"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt_get_ccb",
          "args": [
            "sc",
            "flags"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB2",
            "(\"bt_scsi_cmd\\n\")"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_free_ccb;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *bt_get_ccb;\nvoid bt_queue_ccb;\nint bt_scsi_cmd;\nint bt_poll;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tstruct bt_ccb *ccb;\n\tstruct bt_scat_gath *sg;\n\tint seg;\t\t/* scatter gather seg being worked on */\n\tu_long thiskv, thisphys, nextphys;\n\tint bytes_this_seg, bytes_this_page, datalen, flags;\n#ifdef TFS\n\tstruct iovec *iovp;\n#endif\n\tint s;\n\n\tSC_DEBUG(sc_link, SDEV_DB2, (\"bt_scsi_cmd\\n\"));\n\t/*\n\t * get a ccb to use. If the transfer\n\t * is from a buf (possibly from interrupt time)\n\t * then we can't allow it to sleep\n\t */\n\tflags = xs->flags;\n\tif ((ccb = bt_get_ccb(sc, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\tccb->xs = xs;\n\tccb->timeout = xs->timeout;\n\n\t/*\n\t * Put all the arguments for the xfer in the ccb\n\t */\n\tif (flags & SCSI_RESET) {\n\t\tccb->opcode = BT_RESET_CCB;\n\t\tccb->scsi_cmd_length = 0;\n\t} else {\n\t\t/* can't use S/G if zero length */\n\t\tccb->opcode = (xs->datalen ? BT_INIT_SCAT_GATH_CCB\n\t\t\t\t\t   : BT_INITIATOR_CCB);\n\t\tbcopy(xs->cmd, &ccb->scsi_cmd,\n\t\t    ccb->scsi_cmd_length = xs->cmdlen);\n\t}\n\n\tif (xs->datalen) {\n\t\tsg = ccb->scat_gath;\n\t\tseg = 0;\n#ifdef\tTFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\tiovp = ((struct uio *)xs->data)->uio_iov;\n\t\t\tdatalen = ((struct uio *)xs->data)->uio_iovcnt;\n\t\t\txs->datalen = 0;\n\t\t\twhile (datalen && seg < BT_NSEG) {\n\t\t\t\tltophys(iovp->iov_base, sg->seg_addr);\n\t\t\t\tltophys(iovp->iov_len, sg->seg_len);\n\t\t\t\txs->datalen += iovp->iov_len;\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base));\n\t\t\t\tsg++;\n\t\t\t\tiovp++;\n\t\t\t\tseg++;\n\t\t\t\tdatalen--;\n\t\t\t}\n\t\t} else\n#endif\t/* TFS */\n\t\t{\n\t\t\t/*\n\t\t\t * Set up the scatter-gather block.\n\t\t\t */\n\t\t\tSC_DEBUG(sc_link, SDEV_DB4,\n\t\t\t    (\"%d @0x%x:- \", xs->datalen, xs->data));\n\n\t\t\tdatalen = xs->datalen;\n\t\t\tthiskv = (int)xs->data;\n\t\t\tthisphys = KVTOPHYS(thiskv);\n\n\t\t\twhile (datalen && seg < BT_NSEG) {\n\t\t\t\tbytes_this_seg = 0;\n\n\t\t\t\t/* put in the base address */\n\t\t\t\tltophys(thisphys, sg->seg_addr);\n\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"0x%x\", thisphys));\n\n\t\t\t\t/* do it at least once */\n\t\t\t\tnextphys = thisphys;\n\t\t\t\twhile (datalen && thisphys == nextphys) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This page is contiguous (physically)\n\t\t\t\t\t * with the the last, just extend the\n\t\t\t\t\t * length\n\t\t\t\t\t */\n\t\t\t\t\t/* how far to the end of the page */\n\t\t\t\t\tnextphys = (thisphys & ~PGOFSET) + NBPG;\n\t\t\t\t\tbytes_this_page = nextphys - thisphys;\n\t\t\t\t\t/**** or the data ****/\n\t\t\t\t\tbytes_this_page = min(bytes_this_page,\n\t\t\t\t\t\t\t      datalen);\n\t\t\t\t\tbytes_this_seg += bytes_this_page;\n\t\t\t\t\tdatalen -= bytes_this_page;\n\n\t\t\t\t\t/* get more ready for the next page */\n\t\t\t\t\tthiskv = (thiskv & ~PGOFSET) + NBPG;\n\t\t\t\t\tif (datalen)\n\t\t\t\t\t\tthisphys = KVTOPHYS(thiskv);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * next page isn't contiguous, finish the seg\n\t\t\t\t */\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4,\n\t\t\t\t    (\"(0x%x)\", bytes_this_seg));\n\t\t\t\tltophys(bytes_this_seg, sg->seg_len);\n\t\t\t\tsg++;\n\t\t\t\tseg++;\n\t\t\t}\n\t\t}\n\t\t/* end of iov/kv decision */\n\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"\\n\"));\n\t\tif (datalen) {\n\t\t\t/*\n\t\t\t * there's still data, must have run out of segs!\n\t\t\t */\n\t\t\tprintf(\"%s: bt_scsi_cmd, more than %d dma segs\\n\",\n\t\t\t    sc->sc_dev.dv_xname, BT_NSEG);\n\t\t\tgoto bad;\n\t\t}\n\t\tltophys(KVTOPHYS(ccb->scat_gath), ccb->data_addr);\n\t\tltophys(seg * sizeof(struct bt_scat_gath), ccb->data_length);\n\t} else {\t\t/* No data xfer, use non S/G values */\n\t\tltophys(0, ccb->data_addr);\n\t\tltophys(0, ccb->data_length);\n\t}\n\n\tccb->data_out = 0;\n\tccb->data_in = 0;\n\tccb->target = sc_link->target;\n\tccb->lun = sc_link->lun;\n\tltophys(KVTOPHYS(&ccb->scsi_sense), ccb->sense_ptr);\n\tccb->req_sense_length = sizeof(ccb->scsi_sense);\n\tccb->host_stat = 0x00;\n\tccb->target_stat = 0x00;\n\tccb->link_id = 0;\n\tltophys(0, ccb->link_addr);\n\n\ts = splbio();\n\tbt_queue_ccb(sc, ccb);\n\tsplx(s);\n\n\t/*\n\t * Usually return SUCCESSFULLY QUEUED\n\t */\n\tSC_DEBUG(sc_link, SDEV_DB3, (\"cmd_sent\\n\"));\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn SUCCESSFULLY_QUEUED;\n\n\t/*\n\t * If we can't use interrupts, poll on completion\n\t */\n\tif (bt_poll(sc, xs, ccb->timeout)) {\n\t\tbt_timeout(ccb);\n\t\tif (bt_poll(sc, xs, ccb->timeout))\n\t\t\tbt_timeout(ccb);\n\t}\n\treturn COMPLETE;\n\nbad:\n\txs->error = XS_DRIVER_STUFFUP;\n\tbt_free_ccb(sc, ccb);\n\treturn COMPLETE;\n}"
  },
  {
    "function_name": "btminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "1088-1096",
    "snippet": "void\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void btminphys"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "btminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1088-1096",
          "snippet": "void\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid btminphys;\n\nvoid\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
  },
  {
    "function_name": "bt_inquire_setup_information",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "1027-1086",
    "snippet": "void\nbt_inquire_setup_information(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_model model;\n\tstruct bt_revision revision;\n\tstruct bt_digit digit;\n\tchar *p;\n\n\t/*\n\t * Get the firmware revision.\n\t */\n\tp = sc->sc_firmware;\n\trevision.cmd.opcode = BT_INQUIRE_REVISION;\n\tbt_cmd(iobase, sc, sizeof(revision.cmd), (u_char *)&revision.cmd,\n\t    sizeof(revision.reply), (u_char *)&revision.reply);\n\t*p++ = revision.reply.firm_revision;\n\t*p++ = '.';\n\t*p++ = revision.reply.firm_version;\n\tdigit.cmd.opcode = BT_INQUIRE_REVISION_3;\n\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\t*p++ = digit.reply.digit;\n\tif (revision.reply.firm_revision >= '3' ||\n\t    (revision.reply.firm_revision == '3' && revision.reply.firm_version >= '3')) {\n\t\tdigit.cmd.opcode = BT_INQUIRE_REVISION_4;\n\t\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\t\t*p++ = digit.reply.digit;\n\t}\n\twhile (p > sc->sc_firmware && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\tp--;\n\t*p = '\\0';\n\n\t/*\n\t * Get the model number.\n\t */\n\tif (revision.reply.firm_revision >= '3') {\n\t\tp = sc->sc_model;\n\t\tmodel.cmd.opcode = BT_INQUIRE_MODEL;\n\t\tmodel.cmd.len = sizeof(model.reply);\n\t\tbt_cmd(iobase, sc, sizeof(model.cmd), (u_char *)&model.cmd,\n\t\t    sizeof(model.reply), (u_char *)&model.reply);\n\t\t*p++ = model.reply.id[0];\n\t\t*p++ = model.reply.id[1];\n\t\t*p++ = model.reply.id[2];\n\t\t*p++ = model.reply.id[3];\n\t\twhile (p > sc->sc_model && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\t\tp--;\n\t\t*p++ = model.reply.version[0];\n\t\t*p++ = model.reply.version[1];\n\t\twhile (p > sc->sc_model && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\t\tp--;\n\t\t*p = '\\0';\n\t} else\n\t\tstrcpy(sc->sc_model, \"542B\");\n\n\tprintf(\": model BT-%s, firmware %s\\n\", sc->sc_model, sc->sc_firmware);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int bt_cmd",
      "struct bt_softc *, int, u_char *, int, u_char *));",
      "bt_finish_ccbs __P((struct bt_softc *));",
      "void bt_inquire_setup_information",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": model BT-%s, firmware %s\\n\"",
            "sc->sc_model",
            "sc->sc_firmware"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->sc_model",
            "\"542B\""
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_cmd",
          "args": [
            "iobase",
            "sc",
            "sizeof(model.cmd)",
            "(u_char *)&model.cmd",
            "sizeof(model.reply)",
            "(u_char *)&model.reply"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "bt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "198-315",
          "snippet": "int\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nvoid bt_inquire_setup_information;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_inquire_setup_information(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_model model;\n\tstruct bt_revision revision;\n\tstruct bt_digit digit;\n\tchar *p;\n\n\t/*\n\t * Get the firmware revision.\n\t */\n\tp = sc->sc_firmware;\n\trevision.cmd.opcode = BT_INQUIRE_REVISION;\n\tbt_cmd(iobase, sc, sizeof(revision.cmd), (u_char *)&revision.cmd,\n\t    sizeof(revision.reply), (u_char *)&revision.reply);\n\t*p++ = revision.reply.firm_revision;\n\t*p++ = '.';\n\t*p++ = revision.reply.firm_version;\n\tdigit.cmd.opcode = BT_INQUIRE_REVISION_3;\n\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\t*p++ = digit.reply.digit;\n\tif (revision.reply.firm_revision >= '3' ||\n\t    (revision.reply.firm_revision == '3' && revision.reply.firm_version >= '3')) {\n\t\tdigit.cmd.opcode = BT_INQUIRE_REVISION_4;\n\t\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\t\t*p++ = digit.reply.digit;\n\t}\n\twhile (p > sc->sc_firmware && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\tp--;\n\t*p = '\\0';\n\n\t/*\n\t * Get the model number.\n\t */\n\tif (revision.reply.firm_revision >= '3') {\n\t\tp = sc->sc_model;\n\t\tmodel.cmd.opcode = BT_INQUIRE_MODEL;\n\t\tmodel.cmd.len = sizeof(model.reply);\n\t\tbt_cmd(iobase, sc, sizeof(model.cmd), (u_char *)&model.cmd,\n\t\t    sizeof(model.reply), (u_char *)&model.reply);\n\t\t*p++ = model.reply.id[0];\n\t\t*p++ = model.reply.id[1];\n\t\t*p++ = model.reply.id[2];\n\t\t*p++ = model.reply.id[3];\n\t\twhile (p > sc->sc_model && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\t\tp--;\n\t\t*p++ = model.reply.version[0];\n\t\t*p++ = model.reply.version[1];\n\t\twhile (p > sc->sc_model && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\t\tp--;\n\t\t*p = '\\0';\n\t} else\n\t\tstrcpy(sc->sc_model, \"542B\");\n\n\tprintf(\": model BT-%s, firmware %s\\n\", sc->sc_model, sc->sc_firmware);\n}"
  },
  {
    "function_name": "bt_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "952-1025",
    "snippet": "void\nbt_init(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_devices devices;\n\tstruct bt_setup setup;\n\tstruct bt_mailbox mailbox;\n\tstruct bt_period period;\n\tint i;\n\n\t/* Enable round-robin scheme - appeared at firmware rev. 3.31. */\n\tif (strcmp(sc->sc_firmware, \"3.31\") >= 0) {\n\t\tstruct bt_toggle toggle;\n\n\t\ttoggle.cmd.opcode = BT_ROUND_ROBIN;\n\t\ttoggle.cmd.enable = 1;\n\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd,\n\t\t    0, (u_char *)0);\n\t}\n\n\t/* Inquire Installed Devices (to force synchronous negotiation). */\n\tdevices.cmd.opcode = BT_INQUIRE_DEVICES;\n\tbt_cmd(iobase, sc, sizeof(devices.cmd), (u_char *)&devices.cmd,\n\t    sizeof(devices.reply), (u_char *)&devices.reply);\n\n\t/* Obtain setup information from. */\n\tsetup.cmd.opcode = BT_INQUIRE_SETUP;\n\tsetup.cmd.len = sizeof(setup.reply);\n\tbt_cmd(iobase, sc, sizeof(setup.cmd), (u_char *)&setup.cmd,\n\t    sizeof(setup.reply), (u_char *)&setup.reply);\n\n\tprintf(\"%s: %s, %s\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    setup.reply.sync_neg ? \"sync\" : \"async\",\n\t    setup.reply.parity ? \"parity\" : \"no parity\");\n\n\tfor (i = 0; i < 8; i++)\n\t\tperiod.reply.period[i] = setup.reply.sync[i].period * 5 + 20;\n\n\tif (sc->sc_firmware[0] >= '3') {\n\t\tperiod.cmd.opcode = BT_INQUIRE_PERIOD;\n\t\tperiod.cmd.len = sizeof(period.reply);\n\t\tbt_cmd(iobase, sc, sizeof(period.cmd), (u_char *)&period.cmd,\n\t\t    sizeof(period.reply), (u_char *)&period.reply);\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!setup.reply.sync[i].valid ||\n\t\t    (!setup.reply.sync[i].offset && !setup.reply.sync[i].period))\n\t\t\tcontinue;\n\t\tprintf(\"%s targ %d: sync, offset %d, period %dnsec\\n\",\n\t\t    sc->sc_dev.dv_xname, i,\n\t\t    setup.reply.sync[i].offset, period.reply.period[i] * 10);\n\t}\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\tfor (i = 0; i < BT_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = BT_MBO_FREE;\n\t\twmbx->mbi[i].stat = BT_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Initialize mail box. */\n\tmailbox.cmd.opcode = BT_MBX_INIT_EXTENDED;\n\tmailbox.cmd.nmbx = BT_MBX_SIZE;\n\tltophys(KVTOPHYS(wmbx), mailbox.cmd.addr);\n\tbt_cmd(iobase, sc, sizeof(mailbox.cmd), (u_char *)&mailbox.cmd,\n\t    0, (u_char *)0);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(&sc->sc_mbx)",
      "#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */"
    ],
    "globals_used": [
      "int bt_cmd",
      "struct bt_softc *, int, u_char *, int, u_char *));",
      "bt_finish_ccbs __P((struct bt_softc *));",
      "void bt_init",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_cmd",
          "args": [
            "iobase",
            "sc",
            "sizeof(mailbox.cmd)",
            "(u_char *)&mailbox.cmd",
            "0",
            "(u_char *)0"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "bt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "198-315",
          "snippet": "int\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "KVTOPHYS(wmbx)",
            "mailbox.cmd.addr"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "wmbx"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s targ %d: sync, offset %d, period %dnsec\\n\"",
            "sc->sc_dev.dv_xname",
            "i",
            "setup.reply.sync[i].offset",
            "period.reply.period[i] * 10"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sc->sc_firmware",
            "\"3.31\""
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nvoid bt_init;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_init(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_devices devices;\n\tstruct bt_setup setup;\n\tstruct bt_mailbox mailbox;\n\tstruct bt_period period;\n\tint i;\n\n\t/* Enable round-robin scheme - appeared at firmware rev. 3.31. */\n\tif (strcmp(sc->sc_firmware, \"3.31\") >= 0) {\n\t\tstruct bt_toggle toggle;\n\n\t\ttoggle.cmd.opcode = BT_ROUND_ROBIN;\n\t\ttoggle.cmd.enable = 1;\n\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd,\n\t\t    0, (u_char *)0);\n\t}\n\n\t/* Inquire Installed Devices (to force synchronous negotiation). */\n\tdevices.cmd.opcode = BT_INQUIRE_DEVICES;\n\tbt_cmd(iobase, sc, sizeof(devices.cmd), (u_char *)&devices.cmd,\n\t    sizeof(devices.reply), (u_char *)&devices.reply);\n\n\t/* Obtain setup information from. */\n\tsetup.cmd.opcode = BT_INQUIRE_SETUP;\n\tsetup.cmd.len = sizeof(setup.reply);\n\tbt_cmd(iobase, sc, sizeof(setup.cmd), (u_char *)&setup.cmd,\n\t    sizeof(setup.reply), (u_char *)&setup.reply);\n\n\tprintf(\"%s: %s, %s\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    setup.reply.sync_neg ? \"sync\" : \"async\",\n\t    setup.reply.parity ? \"parity\" : \"no parity\");\n\n\tfor (i = 0; i < 8; i++)\n\t\tperiod.reply.period[i] = setup.reply.sync[i].period * 5 + 20;\n\n\tif (sc->sc_firmware[0] >= '3') {\n\t\tperiod.cmd.opcode = BT_INQUIRE_PERIOD;\n\t\tperiod.cmd.len = sizeof(period.reply);\n\t\tbt_cmd(iobase, sc, sizeof(period.cmd), (u_char *)&period.cmd,\n\t\t    sizeof(period.reply), (u_char *)&period.reply);\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!setup.reply.sync[i].valid ||\n\t\t    (!setup.reply.sync[i].offset && !setup.reply.sync[i].period))\n\t\t\tcontinue;\n\t\tprintf(\"%s targ %d: sync, offset %d, period %dnsec\\n\",\n\t\t    sc->sc_dev.dv_xname, i,\n\t\t    setup.reply.sync[i].offset, period.reply.period[i] * 10);\n\t}\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\tfor (i = 0; i < BT_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = BT_MBO_FREE;\n\t\twmbx->mbi[i].stat = BT_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Initialize mail box. */\n\tmailbox.cmd.opcode = BT_MBX_INIT_EXTENDED;\n\tmailbox.cmd.nmbx = BT_MBX_SIZE;\n\tltophys(KVTOPHYS(wmbx), mailbox.cmd.addr);\n\tbt_cmd(iobase, sc, sizeof(mailbox.cmd), (u_char *)&mailbox.cmd,\n\t    0, (u_char *)0);\n}"
  },
  {
    "function_name": "bt_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "801-947",
    "snippet": "int\nbt_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct bt_softc *sc;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct bt_extended_inquire inquire;\n\tstruct bt_config config;\n#if NAHA > 0\n\tstruct bt_digit digit;\n#endif\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_HRST | BT_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = BT_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\tif (sts == (BT_STAT_IDLE | BT_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!i) {\n#ifdef BTDEBUG\n\t\tif (bt_debug)\n\t\t\tprintf(\"bt_find: No answer from buslogic board\\n\");\n#endif /* BTDEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Check that we actually know how to use this board.\n\t */\n\tdelay(1000);\n\tbzero(&inquire, sizeof inquire);\n\tinquire.cmd.opcode = BT_INQUIRE_EXTENDED;\n\tinquire.cmd.len = sizeof(inquire.reply);\n\tbt_cmd(iobase, sc, sizeof(inquire.cmd), (u_char *)&inquire.cmd,\n\t    sizeof(inquire.reply), (u_char *)&inquire.reply);\n\tswitch (inquire.reply.bus_type) {\n\tcase BT_BUS_TYPE_24BIT:\n\tcase BT_BUS_TYPE_32BIT:\n\t\tbreak;\n\tcase BT_BUS_TYPE_MCA:\n\t\t/* We don't grok MicroChannel (yet). */\n\t\treturn 1;\n\tdefault:\n\t\tif (inquire.reply.bus_type != 'F')\n\t\t\tprintf(\"bt_find: illegal bus type %c\\n\",\n\t\t\t    inquire.reply.bus_type);\n\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* Adaptec 1542 cards do not support this */\n\tdigit.reply.digit = '@';\n\tdigit.cmd.opcode = BT_INQUIRE_REVISION_3;\n\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\tif (digit.reply.digit == '@')\n\t\treturn 1;\n#endif\n\n\t/*\n\t * Assume we have a board at this stage setup dma channel from\n\t * jumpers and save int level\n\t */\n\tdelay(1000);\n\tconfig.cmd.opcode = BT_INQUIRE_CONFIG;\n\tbt_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal drq setting %x\\n\", config.reply.chan);\n\t\treturn 1;\n\t}\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal irq setting %x\\n\", config.reply.intr);\n\t\treturn 1;\n\t}\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* XXXX To avoid conflicting with the aha1542 probe */\n\tbtports[nbtports++] = iobase;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define BT_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */"
    ],
    "globals_used": [
      "int bt_cmd",
      "struct bt_softc *, int, u_char *, int, u_char *));",
      "bt_finish_ccbs __P((struct bt_softc *));",
      "int bt_find",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bt_find: illegal irq setting %x\\n\"",
            "config.reply.intr"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt_cmd",
          "args": [
            "iobase",
            "sc",
            "sizeof(config.cmd)",
            "(u_char *)&config.cmd",
            "sizeof(config.reply)",
            "(u_char *)&config.reply"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "bt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "198-315",
          "snippet": "int\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&inquire",
            "sizeof inquire"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + BT_STAT_PORT"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + BT_CTRL_PORT",
            "BT_CTRL_HRST | BT_CTRL_SRST"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define BT_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nint bt_find;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct bt_softc *sc;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct bt_extended_inquire inquire;\n\tstruct bt_config config;\n#if NAHA > 0\n\tstruct bt_digit digit;\n#endif\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_HRST | BT_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = BT_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\tif (sts == (BT_STAT_IDLE | BT_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!i) {\n#ifdef BTDEBUG\n\t\tif (bt_debug)\n\t\t\tprintf(\"bt_find: No answer from buslogic board\\n\");\n#endif /* BTDEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Check that we actually know how to use this board.\n\t */\n\tdelay(1000);\n\tbzero(&inquire, sizeof inquire);\n\tinquire.cmd.opcode = BT_INQUIRE_EXTENDED;\n\tinquire.cmd.len = sizeof(inquire.reply);\n\tbt_cmd(iobase, sc, sizeof(inquire.cmd), (u_char *)&inquire.cmd,\n\t    sizeof(inquire.reply), (u_char *)&inquire.reply);\n\tswitch (inquire.reply.bus_type) {\n\tcase BT_BUS_TYPE_24BIT:\n\tcase BT_BUS_TYPE_32BIT:\n\t\tbreak;\n\tcase BT_BUS_TYPE_MCA:\n\t\t/* We don't grok MicroChannel (yet). */\n\t\treturn 1;\n\tdefault:\n\t\tif (inquire.reply.bus_type != 'F')\n\t\t\tprintf(\"bt_find: illegal bus type %c\\n\",\n\t\t\t    inquire.reply.bus_type);\n\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* Adaptec 1542 cards do not support this */\n\tdigit.reply.digit = '@';\n\tdigit.cmd.opcode = BT_INQUIRE_REVISION_3;\n\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\tif (digit.reply.digit == '@')\n\t\treturn 1;\n#endif\n\n\t/*\n\t * Assume we have a board at this stage setup dma channel from\n\t * jumpers and save int level\n\t */\n\tdelay(1000);\n\tconfig.cmd.opcode = BT_INQUIRE_CONFIG;\n\tbt_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal drq setting %x\\n\", config.reply.chan);\n\t\treturn 1;\n\t}\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal irq setting %x\\n\", config.reply.intr);\n\t\treturn 1;\n\t}\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* XXXX To avoid conflicting with the aha1542 probe */\n\tbtports[nbtports++] = iobase;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "bt_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "736-796",
    "snippet": "void\nbt_done(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ccb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"bt_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n#ifdef BTDIAG\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: exiting ccb still in transit!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n#endif\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->host_stat != BT_OK) {\n\t\t\tswitch (ccb->host_stat) {\n\t\t\tcase BT_SEL_TIMEOUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ccb->target_stat != SCSI_OK) {\n\t\t\tswitch (ccb->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ccb->scsi_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\tbt_free_ccb(sc, ccb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bt_finish_ccbs __P((struct bt_softc *));",
      "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "void bt_free_ccb",
      "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "void bt_done",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "int flags;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_free_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "bt_free_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "527-547",
          "snippet": "void\nbt_free_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\n\tbt_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_free_ccb",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_free_ccb;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_free_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\n\tbt_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: target_stat %x\\n\"",
            "sc->sc_dev.dv_xname",
            "ccb->target_stat"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "xs->sc_link",
            "SDEV_DB2",
            "(\"bt_done\\n\")"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_free_ccb;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_done;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_done(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ccb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"bt_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n#ifdef BTDIAG\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: exiting ccb still in transit!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n#endif\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->host_stat != BT_OK) {\n\t\t\tswitch (ccb->host_stat) {\n\t\t\tcase BT_SEL_TIMEOUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ccb->target_stat != SCSI_OK) {\n\t\t\tswitch (ccb->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ccb->scsi_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\tbt_free_ccb(sc, ccb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}"
  },
  {
    "function_name": "bt_start_ccbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "682-729",
    "snippet": "void\nbt_start_ccbs(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct bt_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\tbt_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\t\tstruct bt_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = BT_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef BTDIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tltophys(KVTOPHYS(ccb), wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = BT_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = BT_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + BT_CMD_PORT, BT_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(bt_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(&sc->sc_mbx)",
      "#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */"
    ],
    "globals_used": [
      "int bt_cmd",
      "struct bt_softc *, int, u_char *, int, u_char *));",
      "bt_finish_ccbs __P((struct bt_softc *));",
      "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "void bt_collect_mbo",
      "void bt_start_ccbs",
      "void bt_timeout",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "int flags;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_nextmbx",
          "args": [
            "wmbo",
            "wmbx",
            "mbo"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "bt_timeout",
            "ccb",
            "(ccb->timeout * hz) / 1000"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + BT_CMD_PORT",
            "BT_START_SCSI"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ltophys",
          "args": [
            "KVTOPHYS(ccb)",
            "wmbo->ccb_addr"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "ccb"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->sc_waiting_ccb",
            "ccb",
            "chain"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_cmd",
          "args": [
            "iobase",
            "sc",
            "sizeof(toggle.cmd)",
            "(u_char *)&toggle.cmd",
            "0",
            "(u_char *)0"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "bt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "198-315",
          "snippet": "int\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt_collect_mbo",
          "args": [
            "sc"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "bt_collect_mbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "653-677",
          "snippet": "void\nbt_collect_mbo(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef BTDIAG\n\tstruct bt_ccb *ccb;\n#endif\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != BT_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef BTDIAG\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "struct bt_ccb *bt_ccb_phys_kv",
            "void bt_collect_mbo",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *bt_ccb_phys_kv;\nvoid bt_collect_mbo;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_collect_mbo(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef BTDIAG\n\tstruct bt_ccb *ccb;\n#endif\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != BT_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef BTDIAG\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_collect_mbo;\nvoid bt_start_ccbs;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_start_ccbs(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct bt_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\tbt_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\t\tstruct bt_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = BT_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef BTDIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tltophys(KVTOPHYS(ccb), wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = BT_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = BT_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + BT_CMD_PORT, BT_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(bt_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}"
  },
  {
    "function_name": "bt_collect_mbo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "653-677",
    "snippet": "void\nbt_collect_mbo(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef BTDIAG\n\tstruct bt_ccb *ccb;\n#endif\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != BT_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef BTDIAG\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(&sc->sc_mbx)"
    ],
    "globals_used": [
      "bt_finish_ccbs __P((struct bt_softc *));",
      "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "struct bt_ccb *bt_ccb_phys_kv",
      "void bt_collect_mbo",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "int flags;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_nextmbx",
          "args": [
            "wmbo",
            "wmbx",
            "mbo"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_ccb_phys_kv",
          "args": [
            "sc",
            "phystol(wmbo->ccb_addr)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phystol",
          "args": [
            "wmbo->ccb_addr"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *bt_ccb_phys_kv;\nvoid bt_collect_mbo;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_collect_mbo(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef BTDIAG\n\tstruct bt_ccb *ccb;\n#endif\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != BT_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef BTDIAG\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
  },
  {
    "function_name": "bt_queue_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "640-648",
    "snippet": "void\nbt_queue_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\tbt_start_ccbs(sc);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bt_finish_ccbs __P((struct bt_softc *));",
      "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "void bt_queue_ccb",
      "void bt_start_ccbs",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_start_ccbs",
          "args": [
            "sc"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "bt_start_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "682-729",
          "snippet": "void\nbt_start_ccbs(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct bt_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\tbt_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\t\tstruct bt_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = BT_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef BTDIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tltophys(KVTOPHYS(ccb), wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = BT_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = BT_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + BT_CMD_PORT, BT_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(bt_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)",
            "#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */"
          ],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_collect_mbo",
            "void bt_start_ccbs",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_collect_mbo;\nvoid bt_start_ccbs;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_start_ccbs(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct bt_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\tbt_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\t\tstruct bt_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = BT_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef BTDIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tltophys(KVTOPHYS(ccb), wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = BT_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = BT_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + BT_CMD_PORT, BT_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(bt_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->sc_waiting_ccb",
            "ccb",
            "chain"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_start_ccbs;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_queue_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tTAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);\n\tbt_start_ccbs(sc);\n}"
  },
  {
    "function_name": "bt_init_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "549-566",
    "snippet": "integrate void\nbt_init_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tint hashnum;\n\n\tbzero(ccb, sizeof(struct bt_ccb));\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tccb->hashkey = KVTOPHYS(ccb);\n\thashnum = CCB_HASH(ccb->hashkey);\n\tccb->nexthash = sc->sc_ccbhash[hashnum];\n\tsc->sc_ccbhash[hashnum] = ccb;\n\tbt_reset_ccb(sc, ccb);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define integrate"
    ],
    "globals_used": [
      "integrate void",
      "bt_finish_ccbs __P((struct bt_softc *));",
      "integrate void",
      "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "integrate void",
      "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_reset_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "bt_reset_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "515-522",
          "snippet": "integrate void\nbt_reset_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define integrate"
          ],
          "globals_used": [
            "integrate void",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "integrate void",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "integrate void",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define integrate\n\nintegrate void;\nbt_finish_ccbs __P((struct bt_softc *));\nintegrate void;\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nintegrate void;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nintegrate void\nbt_reset_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CCB_HASH",
          "args": [
            "ccb->hashkey"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "ccb"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ccb",
            "sizeof(struct bt_ccb)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define integrate\n\nintegrate void;\nbt_finish_ccbs __P((struct bt_softc *));\nintegrate void;\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nintegrate void;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nintegrate void\nbt_init_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tint hashnum;\n\n\tbzero(ccb, sizeof(struct bt_ccb));\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tccb->hashkey = KVTOPHYS(ccb);\n\thashnum = CCB_HASH(ccb->hashkey);\n\tccb->nexthash = sc->sc_ccbhash[hashnum];\n\tsc->sc_ccbhash[hashnum] = ccb;\n\tbt_reset_ccb(sc, ccb);\n}"
  },
  {
    "function_name": "bt_free_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "527-547",
    "snippet": "void\nbt_free_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\n\tbt_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bt_finish_ccbs __P((struct bt_softc *));",
      "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "void bt_free_ccb",
      "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->sc_free_ccb"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->sc_free_ccb",
            "ccb",
            "chain"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_reset_ccb",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "bt_reset_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "515-522",
          "snippet": "integrate void\nbt_reset_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define integrate"
          ],
          "globals_used": [
            "integrate void",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "integrate void",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "integrate void",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define integrate\n\nintegrate void;\nbt_finish_ccbs __P((struct bt_softc *));\nintegrate void;\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nintegrate void;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nintegrate void\nbt_reset_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_free_ccb;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_free_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tint s;\n\n\ts = splbio();\n\n\tbt_reset_ccb(sc, ccb);\n\tTAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ccb->chain.tqe_next == 0)\n\t\twakeup(&sc->sc_free_ccb);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "bt_reset_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "515-522",
    "snippet": "integrate void\nbt_reset_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define integrate"
    ],
    "globals_used": [
      "integrate void",
      "bt_finish_ccbs __P((struct bt_softc *));",
      "integrate void",
      "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "integrate void",
      "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "int flags;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define integrate\n\nintegrate void;\nbt_finish_ccbs __P((struct bt_softc *));\nintegrate void;\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nintegrate void;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nintegrate void\nbt_reset_ccb(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\n\tccb->flags = 0;\n}"
  },
  {
    "function_name": "btintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "471-513",
    "snippet": "int\nbtintr(arg)\n\tvoid *arg;\n{\n\tstruct bt_softc *sc = arg;\n\tint iobase = sc->sc_iobase;\n\tu_char sts;\n\n#ifdef BTDEBUG\n\tprintf(\"%s: btintr \", sc->sc_dev.dv_xname);\n#endif /* BTDEBUG */\n\n\t/*\n\t * First acknowlege the interrupt, Then if it's not telling about\n\t * a completed operation just return.\n\t */\n\tsts = inb(iobase + BT_INTR_PORT);\n\tif ((sts & BT_INTR_ANYINTR) == 0)\n\t\treturn 0;\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\n#ifdef BTDIAG\n\t/* Make sure we clear CCB_SENDING before finishing a CCB. */\n\tbt_collect_mbo(sc);\n#endif\n\n\t/* Mail box out empty? */\n\tif (sts & BT_INTR_MBOA) {\n\t\tstruct bt_toggle toggle;\n\n\t\ttoggle.cmd.opcode = BT_MBO_INTR_EN;\n\t\ttoggle.cmd.enable = 0;\n\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd, 0,\n\t\t    (u_char *)0);\n\t\tbt_start_ccbs(sc);\n\t}\n\n\t/* Mail box in full? */\n\tif (sts & BT_INTR_MBIF)\n\t\tbt_finish_ccbs(sc);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int bt_cmd",
      "struct bt_softc *, int, u_char *, int, u_char *));",
      "bt_finish_ccbs __P((struct bt_softc *));",
      "int btintr",
      "void bt_collect_mbo",
      "void bt_start_ccbs",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_finish_ccbs",
          "args": [
            "sc"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "bt_finish_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "381-466",
          "snippet": "integrate void\nbt_finish_ccbs(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_in *wmbi;\n\tstruct bt_ccb *ccb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == BT_MBI_FREE) {\n\t\tfor (i = 0; i < BT_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != BT_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\tbt_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef BTDIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbi->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbi ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef BTDEBUG\n\t\tif (bt_debug) {\n\t\t\tu_char *cp = &ccb->scsi_cmd;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"ccb addr = 0x%x\\n\", ccb);\n\t\t}\n#endif /* BTDEBUG */\n\n\t\tswitch (wmbi->stat) {\n\t\tcase BT_MBI_OK:\n\t\tcase BT_MBI_ERROR:\n\t\t\tif ((ccb->flags & CCB_ABORT) != 0) {\n\t\t\t\t/*\n\t\t\t\t * If we already started an abort, wait for it\n\t\t\t\t * to complete before clearing the CCB.  We\n\t\t\t\t * could instead just clear CCB_SENDING, but\n\t\t\t\t * what if the mailbox was already received?\n\t\t\t\t * The worst that happens here is that we clear\n\t\t\t\t * the CCB a bit later than we need to.  BFD.\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BT_MBI_ABORT:\n\t\tcase BT_MBI_UNKNOWN:\n\t\t\t/*\n\t\t\t * Even if the CCB wasn't found, we clear it anyway.\n\t\t\t * See preceeding comment.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: bad mbi status %02x; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname, wmbi->stat);\n\t\t\tgoto next;\n\t\t}\n\n\t\tuntimeout(bt_timeout, ccb);\n\t\tbt_done(sc, ccb);\n\n\tnext:\n\t\twmbi->stat = BT_MBI_FREE;\n\t\tbt_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != BT_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)",
            "#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */",
            "#define integrate"
          ],
          "globals_used": [
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "integrate void",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "integrate void",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "integrate void",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "struct bt_ccb *bt_ccb_phys_kv",
            "void bt_done",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */\n#define integrate\n\nstruct bt_softc *, int, u_char *, int, u_char *));\nintegrate void;\nbt_finish_ccbs __P((struct bt_softc *));\nintegrate void;\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nintegrate void;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *bt_ccb_phys_kv;\nvoid bt_done;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nintegrate void\nbt_finish_ccbs(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_in *wmbi;\n\tstruct bt_ccb *ccb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == BT_MBI_FREE) {\n\t\tfor (i = 0; i < BT_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != BT_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\tbt_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef BTDIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbi->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbi ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef BTDEBUG\n\t\tif (bt_debug) {\n\t\t\tu_char *cp = &ccb->scsi_cmd;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"ccb addr = 0x%x\\n\", ccb);\n\t\t}\n#endif /* BTDEBUG */\n\n\t\tswitch (wmbi->stat) {\n\t\tcase BT_MBI_OK:\n\t\tcase BT_MBI_ERROR:\n\t\t\tif ((ccb->flags & CCB_ABORT) != 0) {\n\t\t\t\t/*\n\t\t\t\t * If we already started an abort, wait for it\n\t\t\t\t * to complete before clearing the CCB.  We\n\t\t\t\t * could instead just clear CCB_SENDING, but\n\t\t\t\t * what if the mailbox was already received?\n\t\t\t\t * The worst that happens here is that we clear\n\t\t\t\t * the CCB a bit later than we need to.  BFD.\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BT_MBI_ABORT:\n\t\tcase BT_MBI_UNKNOWN:\n\t\t\t/*\n\t\t\t * Even if the CCB wasn't found, we clear it anyway.\n\t\t\t * See preceeding comment.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: bad mbi status %02x; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname, wmbi->stat);\n\t\t\tgoto next;\n\t\t}\n\n\t\tuntimeout(bt_timeout, ccb);\n\t\tbt_done(sc, ccb);\n\n\tnext:\n\t\twmbi->stat = BT_MBI_FREE;\n\t\tbt_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != BT_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt_start_ccbs",
          "args": [
            "sc"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "bt_start_ccbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "682-729",
          "snippet": "void\nbt_start_ccbs(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct bt_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\tbt_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\t\tstruct bt_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = BT_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef BTDIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tltophys(KVTOPHYS(ccb), wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = BT_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = BT_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + BT_CMD_PORT, BT_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(bt_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)",
            "#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */"
          ],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_collect_mbo",
            "void bt_start_ccbs",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_collect_mbo;\nvoid bt_start_ccbs;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_start_ccbs(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n\tstruct bt_ccb *ccb;\n\n\twmbo = wmbx->tmbo;\n\n\twhile ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {\n\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\tbt_collect_mbo(sc);\n\t\t\tif (sc->sc_mbofull >= BT_MBX_SIZE) {\n\t\t\t\tstruct bt_toggle toggle;\n\n\t\t\t\ttoggle.cmd.opcode = BT_MBO_INTR_EN;\n\t\t\t\ttoggle.cmd.enable = 1;\n\t\t\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd),\n\t\t\t\t    (u_char *)&toggle.cmd, 0, (u_char *)0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tTAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);\n#ifdef BTDIAG\n\t\tccb->flags |= CCB_SENDING;\n#endif\n\n\t\t/* Link ccb to mbo. */\n\t\tltophys(KVTOPHYS(ccb), wmbo->ccb_addr);\n\t\tif (ccb->flags & CCB_ABORT)\n\t\t\twmbo->cmd = BT_MBO_ABORT;\n\t\telse\n\t\t\twmbo->cmd = BT_MBO_START;\n\n\t\t/* Tell the card to poll immediately. */\n\t\toutb(iobase + BT_CMD_PORT, BT_START_SCSI);\n\n\t\tif ((ccb->xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(bt_timeout, ccb, (ccb->timeout * hz) / 1000);\n\n\t\t++sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->tmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt_cmd",
          "args": [
            "iobase",
            "sc",
            "sizeof(toggle.cmd)",
            "(u_char *)&toggle.cmd",
            "0",
            "(u_char *)0"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "bt_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "198-315",
          "snippet": "int\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt_collect_mbo",
          "args": [
            "sc"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "bt_collect_mbo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "653-677",
          "snippet": "void\nbt_collect_mbo(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef BTDIAG\n\tstruct bt_ccb *ccb;\n#endif\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != BT_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef BTDIAG\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "struct bt_ccb *bt_ccb_phys_kv",
            "void bt_collect_mbo",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *bt_ccb_phys_kv;\nvoid bt_collect_mbo;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_collect_mbo(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_out *wmbo;\t/* Mail Box Out pointer */\n#ifdef BTDIAG\n\tstruct bt_ccb *ccb;\n#endif\n\twmbo = wmbx->cmbo;\n\n\twhile (sc->sc_mbofull > 0) {\n\t\tif (wmbo->cmd != BT_MBO_FREE)\n\t\t\tbreak;\n\n#ifdef BTDIAG\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));\n\t\tccb->flags &= ~CCB_SENDING;\n#endif\n\n\t\t--sc->sc_mbofull;\n\t\tbt_nextmbx(wmbo, wmbx, mbo);\n\t}\n\n\twmbx->cmbo = wmbo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + BT_CTRL_PORT",
            "BT_CTRL_IRST"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + BT_INTR_PORT"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: btintr \"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nint btintr;\nvoid bt_collect_mbo;\nvoid bt_start_ccbs;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbtintr(arg)\n\tvoid *arg;\n{\n\tstruct bt_softc *sc = arg;\n\tint iobase = sc->sc_iobase;\n\tu_char sts;\n\n#ifdef BTDEBUG\n\tprintf(\"%s: btintr \", sc->sc_dev.dv_xname);\n#endif /* BTDEBUG */\n\n\t/*\n\t * First acknowlege the interrupt, Then if it's not telling about\n\t * a completed operation just return.\n\t */\n\tsts = inb(iobase + BT_INTR_PORT);\n\tif ((sts & BT_INTR_ANYINTR) == 0)\n\t\treturn 0;\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\n#ifdef BTDIAG\n\t/* Make sure we clear CCB_SENDING before finishing a CCB. */\n\tbt_collect_mbo(sc);\n#endif\n\n\t/* Mail box out empty? */\n\tif (sts & BT_INTR_MBOA) {\n\t\tstruct bt_toggle toggle;\n\n\t\ttoggle.cmd.opcode = BT_MBO_INTR_EN;\n\t\ttoggle.cmd.enable = 0;\n\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd, 0,\n\t\t    (u_char *)0);\n\t\tbt_start_ccbs(sc);\n\t}\n\n\t/* Mail box in full? */\n\tif (sts & BT_INTR_MBIF)\n\t\tbt_finish_ccbs(sc);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "bt_finish_ccbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "381-466",
    "snippet": "integrate void\nbt_finish_ccbs(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_in *wmbi;\n\tstruct bt_ccb *ccb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == BT_MBI_FREE) {\n\t\tfor (i = 0; i < BT_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != BT_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\tbt_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef BTDIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbi->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbi ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef BTDEBUG\n\t\tif (bt_debug) {\n\t\t\tu_char *cp = &ccb->scsi_cmd;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"ccb addr = 0x%x\\n\", ccb);\n\t\t}\n#endif /* BTDEBUG */\n\n\t\tswitch (wmbi->stat) {\n\t\tcase BT_MBI_OK:\n\t\tcase BT_MBI_ERROR:\n\t\t\tif ((ccb->flags & CCB_ABORT) != 0) {\n\t\t\t\t/*\n\t\t\t\t * If we already started an abort, wait for it\n\t\t\t\t * to complete before clearing the CCB.  We\n\t\t\t\t * could instead just clear CCB_SENDING, but\n\t\t\t\t * what if the mailbox was already received?\n\t\t\t\t * The worst that happens here is that we clear\n\t\t\t\t * the CCB a bit later than we need to.  BFD.\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BT_MBI_ABORT:\n\t\tcase BT_MBI_UNKNOWN:\n\t\t\t/*\n\t\t\t * Even if the CCB wasn't found, we clear it anyway.\n\t\t\t * See preceeding comment.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: bad mbi status %02x; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname, wmbi->stat);\n\t\t\tgoto next;\n\t\t}\n\n\t\tuntimeout(bt_timeout, ccb);\n\t\tbt_done(sc, ccb);\n\n\tnext:\n\t\twmbi->stat = BT_MBI_FREE;\n\t\tbt_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != BT_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\twmbx\t(&sc->sc_mbx)",
      "#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */",
      "#define integrate"
    ],
    "globals_used": [
      "struct bt_softc *, int, u_char *, int, u_char *));",
      "integrate void",
      "bt_finish_ccbs __P((struct bt_softc *));",
      "integrate void",
      "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "integrate void",
      "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
      "struct bt_ccb *bt_ccb_phys_kv",
      "void bt_done",
      "void bt_timeout",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "int flags;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_nextmbx",
          "args": [
            "wmbi",
            "wmbx",
            "mbi"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_done",
          "args": [
            "sc",
            "ccb"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "bt_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "736-796",
          "snippet": "void\nbt_done(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ccb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"bt_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n#ifdef BTDIAG\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: exiting ccb still in transit!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n#endif\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->host_stat != BT_OK) {\n\t\t\tswitch (ccb->host_stat) {\n\t\t\tcase BT_SEL_TIMEOUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ccb->target_stat != SCSI_OK) {\n\t\t\tswitch (ccb->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ccb->scsi_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\tbt_free_ccb(sc, ccb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_free_ccb",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_done",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_free_ccb;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_done;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_done(sc, ccb)\n\tstruct bt_softc *sc;\n\tstruct bt_ccb *ccb;\n{\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ccb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"bt_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n#ifdef BTDIAG\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: exiting ccb still in transit!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n#endif\n\tif ((ccb->flags & CCB_ALLOC) == 0) {\n\t\tprintf(\"%s: exiting ccb not allocated!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t\treturn;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (ccb->host_stat != BT_OK) {\n\t\t\tswitch (ccb->host_stat) {\n\t\t\tcase BT_SEL_TIMEOUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ccb->target_stat != SCSI_OK) {\n\t\t\tswitch (ccb->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ccb->scsi_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ccb->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\n\tbt_free_ccb(sc, ccb);\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "bt_timeout",
            "ccb"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bad mbi status %02x; skipping\\n\"",
            "sc->sc_dev.dv_xname",
            "wmbi->stat"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt_ccb_phys_kv",
          "args": [
            "sc",
            "phystol(wmbi->ccb_addr)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phystol",
          "args": [
            "wmbi->ccb_addr"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_nextmbx",
          "args": [
            "wmbi",
            "wmbx",
            "mbi"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */\n#define integrate\n\nstruct bt_softc *, int, u_char *, int, u_char *));\nintegrate void;\nbt_finish_ccbs __P((struct bt_softc *));\nintegrate void;\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nintegrate void;\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nstruct bt_ccb *bt_ccb_phys_kv;\nvoid bt_done;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nintegrate void\nbt_finish_ccbs(sc)\n\tstruct bt_softc *sc;\n{\n\tstruct bt_mbx_in *wmbi;\n\tstruct bt_ccb *ccb;\n\tint i;\n\n\twmbi = wmbx->tmbi;\n\n\tif (wmbi->stat == BT_MBI_FREE) {\n\t\tfor (i = 0; i < BT_MBX_SIZE; i++) {\n\t\t\tif (wmbi->stat != BT_MBI_FREE) {\n\t\t\t\tprintf(\"%s: mbi not in round-robin order\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tgoto AGAIN;\n\t\t\t}\n\t\t\tbt_nextmbx(wmbi, wmbx, mbi);\n\t\t}\n#ifdef BTDIAGnot\n\t\tprintf(\"%s: mbi interrupt with no full mailboxes\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\treturn;\n\t}\n\nAGAIN:\n\tdo {\n\t\tccb = bt_ccb_phys_kv(sc, phystol(wmbi->ccb_addr));\n\t\tif (!ccb) {\n\t\t\tprintf(\"%s: bad mbi ccb pointer; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto next;\n\t\t}\n\n#ifdef BTDEBUG\n\t\tif (bt_debug) {\n\t\t\tu_char *cp = &ccb->scsi_cmd;\n\t\t\tprintf(\"op=%x %x %x %x %x %x\\n\",\n\t\t\t    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);\n\t\t\tprintf(\"stat %x for mbi addr = 0x%08x, \",\n\t\t\t    wmbi->stat, wmbi);\n\t\t\tprintf(\"ccb addr = 0x%x\\n\", ccb);\n\t\t}\n#endif /* BTDEBUG */\n\n\t\tswitch (wmbi->stat) {\n\t\tcase BT_MBI_OK:\n\t\tcase BT_MBI_ERROR:\n\t\t\tif ((ccb->flags & CCB_ABORT) != 0) {\n\t\t\t\t/*\n\t\t\t\t * If we already started an abort, wait for it\n\t\t\t\t * to complete before clearing the CCB.  We\n\t\t\t\t * could instead just clear CCB_SENDING, but\n\t\t\t\t * what if the mailbox was already received?\n\t\t\t\t * The worst that happens here is that we clear\n\t\t\t\t * the CCB a bit later than we need to.  BFD.\n\t\t\t\t */\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BT_MBI_ABORT:\n\t\tcase BT_MBI_UNKNOWN:\n\t\t\t/*\n\t\t\t * Even if the CCB wasn't found, we clear it anyway.\n\t\t\t * See preceeding comment.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: bad mbi status %02x; skipping\\n\",\n\t\t\t    sc->sc_dev.dv_xname, wmbi->stat);\n\t\t\tgoto next;\n\t\t}\n\n\t\tuntimeout(bt_timeout, ccb);\n\t\tbt_done(sc, ccb);\n\n\tnext:\n\t\twmbi->stat = BT_MBI_FREE;\n\t\tbt_nextmbx(wmbi, wmbx, mbi);\n\t} while (wmbi->stat != BT_MBI_FREE);\n\n\twmbx->tmbi = wmbi;\n}"
  },
  {
    "function_name": "btattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "343-379",
    "snippet": "void\nbtattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct bt_softc *sc = (void *)self;\n\n\tif (bt_find(ia, sc) != 0)\n\t\tpanic(\"btattach: bt_find of %s failed\", self->dv_xname);\n\tsc->sc_iobase = ia->ia_iobase;\n\n\tif (sc->sc_drq != DRQUNK)\n\t\tisadma_cascade(sc->sc_drq);\n\n\tbt_inquire_setup_information(sc);\n\tbt_init(sc);\n\tTAILQ_INIT(&sc->sc_free_ccb);\n\tTAILQ_INIT(&sc->sc_waiting_ccb);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &bt_switch;\n\tsc->sc_link.device = &bt_dev;\n\tsc->sc_link.openings = 4;\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, sc->sc_irq, IST_EDGE,\n\t    IPL_BIO, btintr, sc, sc->sc_dev.dv_xname);\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tconfig_found(self, &sc->sc_link, scsiprint);\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bt_finish_ccbs __P((struct bt_softc *));",
      "int btintr",
      "int bt_find",
      "void bt_init",
      "void bt_inquire_setup_information",
      "struct scsi_adapter bt_switch = {\n\tbt_scsi_cmd,\n\tbtminphys,\n\t0,\n\t0,\n};",
      "struct scsi_device bt_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
      "void\tbtattach",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "&sc->sc_link",
            "scsiprint"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "sc->sc_irq",
            "IST_EDGE",
            "IPL_BIO",
            "btintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_waiting_ccb"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->sc_free_ccb"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_init",
          "args": [
            "sc"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "bt_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "952-1025",
          "snippet": "void\nbt_init(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_devices devices;\n\tstruct bt_setup setup;\n\tstruct bt_mailbox mailbox;\n\tstruct bt_period period;\n\tint i;\n\n\t/* Enable round-robin scheme - appeared at firmware rev. 3.31. */\n\tif (strcmp(sc->sc_firmware, \"3.31\") >= 0) {\n\t\tstruct bt_toggle toggle;\n\n\t\ttoggle.cmd.opcode = BT_ROUND_ROBIN;\n\t\ttoggle.cmd.enable = 1;\n\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd,\n\t\t    0, (u_char *)0);\n\t}\n\n\t/* Inquire Installed Devices (to force synchronous negotiation). */\n\tdevices.cmd.opcode = BT_INQUIRE_DEVICES;\n\tbt_cmd(iobase, sc, sizeof(devices.cmd), (u_char *)&devices.cmd,\n\t    sizeof(devices.reply), (u_char *)&devices.reply);\n\n\t/* Obtain setup information from. */\n\tsetup.cmd.opcode = BT_INQUIRE_SETUP;\n\tsetup.cmd.len = sizeof(setup.reply);\n\tbt_cmd(iobase, sc, sizeof(setup.cmd), (u_char *)&setup.cmd,\n\t    sizeof(setup.reply), (u_char *)&setup.reply);\n\n\tprintf(\"%s: %s, %s\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    setup.reply.sync_neg ? \"sync\" : \"async\",\n\t    setup.reply.parity ? \"parity\" : \"no parity\");\n\n\tfor (i = 0; i < 8; i++)\n\t\tperiod.reply.period[i] = setup.reply.sync[i].period * 5 + 20;\n\n\tif (sc->sc_firmware[0] >= '3') {\n\t\tperiod.cmd.opcode = BT_INQUIRE_PERIOD;\n\t\tperiod.cmd.len = sizeof(period.reply);\n\t\tbt_cmd(iobase, sc, sizeof(period.cmd), (u_char *)&period.cmd,\n\t\t    sizeof(period.reply), (u_char *)&period.reply);\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!setup.reply.sync[i].valid ||\n\t\t    (!setup.reply.sync[i].offset && !setup.reply.sync[i].period))\n\t\t\tcontinue;\n\t\tprintf(\"%s targ %d: sync, offset %d, period %dnsec\\n\",\n\t\t    sc->sc_dev.dv_xname, i,\n\t\t    setup.reply.sync[i].offset, period.reply.period[i] * 10);\n\t}\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\tfor (i = 0; i < BT_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = BT_MBO_FREE;\n\t\twmbx->mbi[i].stat = BT_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Initialize mail box. */\n\tmailbox.cmd.opcode = BT_MBX_INIT_EXTENDED;\n\tmailbox.cmd.nmbx = BT_MBX_SIZE;\n\tltophys(KVTOPHYS(wmbx), mailbox.cmd.addr);\n\tbt_cmd(iobase, sc, sizeof(mailbox.cmd), (u_char *)&mailbox.cmd,\n\t    0, (u_char *)0);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\twmbx\t(&sc->sc_mbx)",
            "#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */"
          ],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "void bt_init",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\twmbx\t(&sc->sc_mbx)\n#define BT_MBX_SIZE\t32\t/* mail box size  (MAX 255 MBxs) */\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nvoid bt_init;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_init(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_devices devices;\n\tstruct bt_setup setup;\n\tstruct bt_mailbox mailbox;\n\tstruct bt_period period;\n\tint i;\n\n\t/* Enable round-robin scheme - appeared at firmware rev. 3.31. */\n\tif (strcmp(sc->sc_firmware, \"3.31\") >= 0) {\n\t\tstruct bt_toggle toggle;\n\n\t\ttoggle.cmd.opcode = BT_ROUND_ROBIN;\n\t\ttoggle.cmd.enable = 1;\n\t\tbt_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd,\n\t\t    0, (u_char *)0);\n\t}\n\n\t/* Inquire Installed Devices (to force synchronous negotiation). */\n\tdevices.cmd.opcode = BT_INQUIRE_DEVICES;\n\tbt_cmd(iobase, sc, sizeof(devices.cmd), (u_char *)&devices.cmd,\n\t    sizeof(devices.reply), (u_char *)&devices.reply);\n\n\t/* Obtain setup information from. */\n\tsetup.cmd.opcode = BT_INQUIRE_SETUP;\n\tsetup.cmd.len = sizeof(setup.reply);\n\tbt_cmd(iobase, sc, sizeof(setup.cmd), (u_char *)&setup.cmd,\n\t    sizeof(setup.reply), (u_char *)&setup.reply);\n\n\tprintf(\"%s: %s, %s\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    setup.reply.sync_neg ? \"sync\" : \"async\",\n\t    setup.reply.parity ? \"parity\" : \"no parity\");\n\n\tfor (i = 0; i < 8; i++)\n\t\tperiod.reply.period[i] = setup.reply.sync[i].period * 5 + 20;\n\n\tif (sc->sc_firmware[0] >= '3') {\n\t\tperiod.cmd.opcode = BT_INQUIRE_PERIOD;\n\t\tperiod.cmd.len = sizeof(period.reply);\n\t\tbt_cmd(iobase, sc, sizeof(period.cmd), (u_char *)&period.cmd,\n\t\t    sizeof(period.reply), (u_char *)&period.reply);\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (!setup.reply.sync[i].valid ||\n\t\t    (!setup.reply.sync[i].offset && !setup.reply.sync[i].period))\n\t\t\tcontinue;\n\t\tprintf(\"%s targ %d: sync, offset %d, period %dnsec\\n\",\n\t\t    sc->sc_dev.dv_xname, i,\n\t\t    setup.reply.sync[i].offset, period.reply.period[i] * 10);\n\t}\n\n\t/*\n\t * Set up initial mail box for round-robin operation.\n\t */\n\tfor (i = 0; i < BT_MBX_SIZE; i++) {\n\t\twmbx->mbo[i].cmd = BT_MBO_FREE;\n\t\twmbx->mbi[i].stat = BT_MBI_FREE;\n\t}\n\twmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];\n\twmbx->tmbi = &wmbx->mbi[0];\n\tsc->sc_mbofull = 0;\n\n\t/* Initialize mail box. */\n\tmailbox.cmd.opcode = BT_MBX_INIT_EXTENDED;\n\tmailbox.cmd.nmbx = BT_MBX_SIZE;\n\tltophys(KVTOPHYS(wmbx), mailbox.cmd.addr);\n\tbt_cmd(iobase, sc, sizeof(mailbox.cmd), (u_char *)&mailbox.cmd,\n\t    0, (u_char *)0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt_inquire_setup_information",
          "args": [
            "sc"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "bt_inquire_setup_information",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1027-1086",
          "snippet": "void\nbt_inquire_setup_information(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_model model;\n\tstruct bt_revision revision;\n\tstruct bt_digit digit;\n\tchar *p;\n\n\t/*\n\t * Get the firmware revision.\n\t */\n\tp = sc->sc_firmware;\n\trevision.cmd.opcode = BT_INQUIRE_REVISION;\n\tbt_cmd(iobase, sc, sizeof(revision.cmd), (u_char *)&revision.cmd,\n\t    sizeof(revision.reply), (u_char *)&revision.reply);\n\t*p++ = revision.reply.firm_revision;\n\t*p++ = '.';\n\t*p++ = revision.reply.firm_version;\n\tdigit.cmd.opcode = BT_INQUIRE_REVISION_3;\n\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\t*p++ = digit.reply.digit;\n\tif (revision.reply.firm_revision >= '3' ||\n\t    (revision.reply.firm_revision == '3' && revision.reply.firm_version >= '3')) {\n\t\tdigit.cmd.opcode = BT_INQUIRE_REVISION_4;\n\t\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\t\t*p++ = digit.reply.digit;\n\t}\n\twhile (p > sc->sc_firmware && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\tp--;\n\t*p = '\\0';\n\n\t/*\n\t * Get the model number.\n\t */\n\tif (revision.reply.firm_revision >= '3') {\n\t\tp = sc->sc_model;\n\t\tmodel.cmd.opcode = BT_INQUIRE_MODEL;\n\t\tmodel.cmd.len = sizeof(model.reply);\n\t\tbt_cmd(iobase, sc, sizeof(model.cmd), (u_char *)&model.cmd,\n\t\t    sizeof(model.reply), (u_char *)&model.reply);\n\t\t*p++ = model.reply.id[0];\n\t\t*p++ = model.reply.id[1];\n\t\t*p++ = model.reply.id[2];\n\t\t*p++ = model.reply.id[3];\n\t\twhile (p > sc->sc_model && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\t\tp--;\n\t\t*p++ = model.reply.version[0];\n\t\t*p++ = model.reply.version[1];\n\t\twhile (p > sc->sc_model && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\t\tp--;\n\t\t*p = '\\0';\n\t} else\n\t\tstrcpy(sc->sc_model, \"542B\");\n\n\tprintf(\": model BT-%s, firmware %s\\n\", sc->sc_model, sc->sc_firmware);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "void bt_inquire_setup_information",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nvoid bt_inquire_setup_information;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_inquire_setup_information(sc)\n\tstruct bt_softc *sc;\n{\n\tint iobase = sc->sc_iobase;\n\tstruct bt_model model;\n\tstruct bt_revision revision;\n\tstruct bt_digit digit;\n\tchar *p;\n\n\t/*\n\t * Get the firmware revision.\n\t */\n\tp = sc->sc_firmware;\n\trevision.cmd.opcode = BT_INQUIRE_REVISION;\n\tbt_cmd(iobase, sc, sizeof(revision.cmd), (u_char *)&revision.cmd,\n\t    sizeof(revision.reply), (u_char *)&revision.reply);\n\t*p++ = revision.reply.firm_revision;\n\t*p++ = '.';\n\t*p++ = revision.reply.firm_version;\n\tdigit.cmd.opcode = BT_INQUIRE_REVISION_3;\n\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\t*p++ = digit.reply.digit;\n\tif (revision.reply.firm_revision >= '3' ||\n\t    (revision.reply.firm_revision == '3' && revision.reply.firm_version >= '3')) {\n\t\tdigit.cmd.opcode = BT_INQUIRE_REVISION_4;\n\t\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\t\t*p++ = digit.reply.digit;\n\t}\n\twhile (p > sc->sc_firmware && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\tp--;\n\t*p = '\\0';\n\n\t/*\n\t * Get the model number.\n\t */\n\tif (revision.reply.firm_revision >= '3') {\n\t\tp = sc->sc_model;\n\t\tmodel.cmd.opcode = BT_INQUIRE_MODEL;\n\t\tmodel.cmd.len = sizeof(model.reply);\n\t\tbt_cmd(iobase, sc, sizeof(model.cmd), (u_char *)&model.cmd,\n\t\t    sizeof(model.reply), (u_char *)&model.reply);\n\t\t*p++ = model.reply.id[0];\n\t\t*p++ = model.reply.id[1];\n\t\t*p++ = model.reply.id[2];\n\t\t*p++ = model.reply.id[3];\n\t\twhile (p > sc->sc_model && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\t\tp--;\n\t\t*p++ = model.reply.version[0];\n\t\t*p++ = model.reply.version[1];\n\t\twhile (p > sc->sc_model && (p[-1] == ' ' || p[-1] == '\\0'))\n\t\t\tp--;\n\t\t*p = '\\0';\n\t} else\n\t\tstrcpy(sc->sc_model, \"542B\");\n\n\tprintf(\": model BT-%s, firmware %s\\n\", sc->sc_model, sc->sc_firmware);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isadma_cascade",
          "args": [
            "sc->sc_drq"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"btattach: bt_find of %s failed\"",
            "self->dv_xname"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt_find",
          "args": [
            "ia",
            "sc"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "bt_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "801-947",
          "snippet": "int\nbt_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct bt_softc *sc;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct bt_extended_inquire inquire;\n\tstruct bt_config config;\n#if NAHA > 0\n\tstruct bt_digit digit;\n#endif\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_HRST | BT_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = BT_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\tif (sts == (BT_STAT_IDLE | BT_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!i) {\n#ifdef BTDEBUG\n\t\tif (bt_debug)\n\t\t\tprintf(\"bt_find: No answer from buslogic board\\n\");\n#endif /* BTDEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Check that we actually know how to use this board.\n\t */\n\tdelay(1000);\n\tbzero(&inquire, sizeof inquire);\n\tinquire.cmd.opcode = BT_INQUIRE_EXTENDED;\n\tinquire.cmd.len = sizeof(inquire.reply);\n\tbt_cmd(iobase, sc, sizeof(inquire.cmd), (u_char *)&inquire.cmd,\n\t    sizeof(inquire.reply), (u_char *)&inquire.reply);\n\tswitch (inquire.reply.bus_type) {\n\tcase BT_BUS_TYPE_24BIT:\n\tcase BT_BUS_TYPE_32BIT:\n\t\tbreak;\n\tcase BT_BUS_TYPE_MCA:\n\t\t/* We don't grok MicroChannel (yet). */\n\t\treturn 1;\n\tdefault:\n\t\tif (inquire.reply.bus_type != 'F')\n\t\t\tprintf(\"bt_find: illegal bus type %c\\n\",\n\t\t\t    inquire.reply.bus_type);\n\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* Adaptec 1542 cards do not support this */\n\tdigit.reply.digit = '@';\n\tdigit.cmd.opcode = BT_INQUIRE_REVISION_3;\n\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\tif (digit.reply.digit == '@')\n\t\treturn 1;\n#endif\n\n\t/*\n\t * Assume we have a board at this stage setup dma channel from\n\t * jumpers and save int level\n\t */\n\tdelay(1000);\n\tconfig.cmd.opcode = BT_INQUIRE_CONFIG;\n\tbt_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal drq setting %x\\n\", config.reply.chan);\n\t\treturn 1;\n\t}\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal irq setting %x\\n\", config.reply.intr);\n\t\treturn 1;\n\t}\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* XXXX To avoid conflicting with the aha1542 probe */\n\tbtports[nbtports++] = iobase;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define BT_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */"
          ],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "int bt_find",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define BT_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nint bt_find;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct bt_softc *sc;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct bt_extended_inquire inquire;\n\tstruct bt_config config;\n#if NAHA > 0\n\tstruct bt_digit digit;\n#endif\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_HRST | BT_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = BT_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\tif (sts == (BT_STAT_IDLE | BT_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!i) {\n#ifdef BTDEBUG\n\t\tif (bt_debug)\n\t\t\tprintf(\"bt_find: No answer from buslogic board\\n\");\n#endif /* BTDEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Check that we actually know how to use this board.\n\t */\n\tdelay(1000);\n\tbzero(&inquire, sizeof inquire);\n\tinquire.cmd.opcode = BT_INQUIRE_EXTENDED;\n\tinquire.cmd.len = sizeof(inquire.reply);\n\tbt_cmd(iobase, sc, sizeof(inquire.cmd), (u_char *)&inquire.cmd,\n\t    sizeof(inquire.reply), (u_char *)&inquire.reply);\n\tswitch (inquire.reply.bus_type) {\n\tcase BT_BUS_TYPE_24BIT:\n\tcase BT_BUS_TYPE_32BIT:\n\t\tbreak;\n\tcase BT_BUS_TYPE_MCA:\n\t\t/* We don't grok MicroChannel (yet). */\n\t\treturn 1;\n\tdefault:\n\t\tif (inquire.reply.bus_type != 'F')\n\t\t\tprintf(\"bt_find: illegal bus type %c\\n\",\n\t\t\t    inquire.reply.bus_type);\n\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* Adaptec 1542 cards do not support this */\n\tdigit.reply.digit = '@';\n\tdigit.cmd.opcode = BT_INQUIRE_REVISION_3;\n\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\tif (digit.reply.digit == '@')\n\t\treturn 1;\n#endif\n\n\t/*\n\t * Assume we have a board at this stage setup dma channel from\n\t * jumpers and save int level\n\t */\n\tdelay(1000);\n\tconfig.cmd.opcode = BT_INQUIRE_CONFIG;\n\tbt_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal drq setting %x\\n\", config.reply.chan);\n\t\treturn 1;\n\t}\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal irq setting %x\\n\", config.reply.intr);\n\t\treturn 1;\n\t}\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* XXXX To avoid conflicting with the aha1542 probe */\n\tbtports[nbtports++] = iobase;\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nbt_finish_ccbs __P((struct bt_softc *));\nint btintr;\nint bt_find;\nvoid bt_init;\nvoid bt_inquire_setup_information;\nstruct scsi_adapter bt_switch = {\n\tbt_scsi_cmd,\n\tbtminphys,\n\t0,\n\t0,\n};\nstruct scsi_device bt_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nvoid\tbtattach;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbtattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct bt_softc *sc = (void *)self;\n\n\tif (bt_find(ia, sc) != 0)\n\t\tpanic(\"btattach: bt_find of %s failed\", self->dv_xname);\n\tsc->sc_iobase = ia->ia_iobase;\n\n\tif (sc->sc_drq != DRQUNK)\n\t\tisadma_cascade(sc->sc_drq);\n\n\tbt_inquire_setup_information(sc);\n\tbt_init(sc);\n\tTAILQ_INIT(&sc->sc_free_ccb);\n\tTAILQ_INIT(&sc->sc_waiting_ccb);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_scsi_dev;\n\tsc->sc_link.adapter = &bt_switch;\n\tsc->sc_link.device = &bt_dev;\n\tsc->sc_link.openings = 4;\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, sc->sc_irq, IST_EDGE,\n\t    IPL_BIO, btintr, sc, sc->sc_dev.dv_xname);\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tconfig_found(self, &sc->sc_link, scsiprint);\n}"
  },
  {
    "function_name": "btprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "323-338",
    "snippet": "int\nbtprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tregister struct isa_attach_args *ia = aux;\n\n\t/* See if there is a unit at this location. */\n\tif (bt_find(ia, NULL) != 0)\n\t\treturn 0;\n\n\tia->ia_msize = 0;\n\tia->ia_iosize = 4;\n\t/* IRQ and DRQ set by bt_find(). */\n\treturn 1;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int bt_find",
      "int\tbtprobe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bt_find",
          "args": [
            "ia",
            "NULL"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "bt_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "801-947",
          "snippet": "int\nbt_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct bt_softc *sc;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct bt_extended_inquire inquire;\n\tstruct bt_config config;\n#if NAHA > 0\n\tstruct bt_digit digit;\n#endif\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_HRST | BT_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = BT_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\tif (sts == (BT_STAT_IDLE | BT_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!i) {\n#ifdef BTDEBUG\n\t\tif (bt_debug)\n\t\t\tprintf(\"bt_find: No answer from buslogic board\\n\");\n#endif /* BTDEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Check that we actually know how to use this board.\n\t */\n\tdelay(1000);\n\tbzero(&inquire, sizeof inquire);\n\tinquire.cmd.opcode = BT_INQUIRE_EXTENDED;\n\tinquire.cmd.len = sizeof(inquire.reply);\n\tbt_cmd(iobase, sc, sizeof(inquire.cmd), (u_char *)&inquire.cmd,\n\t    sizeof(inquire.reply), (u_char *)&inquire.reply);\n\tswitch (inquire.reply.bus_type) {\n\tcase BT_BUS_TYPE_24BIT:\n\tcase BT_BUS_TYPE_32BIT:\n\t\tbreak;\n\tcase BT_BUS_TYPE_MCA:\n\t\t/* We don't grok MicroChannel (yet). */\n\t\treturn 1;\n\tdefault:\n\t\tif (inquire.reply.bus_type != 'F')\n\t\t\tprintf(\"bt_find: illegal bus type %c\\n\",\n\t\t\t    inquire.reply.bus_type);\n\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* Adaptec 1542 cards do not support this */\n\tdigit.reply.digit = '@';\n\tdigit.cmd.opcode = BT_INQUIRE_REVISION_3;\n\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\tif (digit.reply.digit == '@')\n\t\treturn 1;\n#endif\n\n\t/*\n\t * Assume we have a board at this stage setup dma channel from\n\t * jumpers and save int level\n\t */\n\tdelay(1000);\n\tconfig.cmd.opcode = BT_INQUIRE_CONFIG;\n\tbt_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal drq setting %x\\n\", config.reply.chan);\n\t\treturn 1;\n\t}\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal irq setting %x\\n\", config.reply.intr);\n\t\treturn 1;\n\t}\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* XXXX To avoid conflicting with the aha1542 probe */\n\tbtports[nbtports++] = iobase;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define BT_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */"
          ],
          "globals_used": [
            "int bt_cmd",
            "struct bt_softc *, int, u_char *, int, u_char *));",
            "bt_finish_ccbs __P((struct bt_softc *));",
            "int bt_find",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define BT_RESET_TIMEOUT\t2000\t/* time to wait for reset (mSec) */\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nint bt_find;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_find(ia, sc)\n\tstruct isa_attach_args *ia;\n\tstruct bt_softc *sc;\n{\n\tint iobase = ia->ia_iobase;\n\tint i;\n\tu_char sts;\n\tstruct bt_extended_inquire inquire;\n\tstruct bt_config config;\n#if NAHA > 0\n\tstruct bt_digit digit;\n#endif\n\tint irq, drq;\n\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_HRST | BT_CTRL_SRST);\n\n\tdelay(100);\n\tfor (i = BT_RESET_TIMEOUT; i; i--) {\n\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\tif (sts == (BT_STAT_IDLE | BT_STAT_INIT))\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!i) {\n#ifdef BTDEBUG\n\t\tif (bt_debug)\n\t\t\tprintf(\"bt_find: No answer from buslogic board\\n\");\n#endif /* BTDEBUG */\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Check that we actually know how to use this board.\n\t */\n\tdelay(1000);\n\tbzero(&inquire, sizeof inquire);\n\tinquire.cmd.opcode = BT_INQUIRE_EXTENDED;\n\tinquire.cmd.len = sizeof(inquire.reply);\n\tbt_cmd(iobase, sc, sizeof(inquire.cmd), (u_char *)&inquire.cmd,\n\t    sizeof(inquire.reply), (u_char *)&inquire.reply);\n\tswitch (inquire.reply.bus_type) {\n\tcase BT_BUS_TYPE_24BIT:\n\tcase BT_BUS_TYPE_32BIT:\n\t\tbreak;\n\tcase BT_BUS_TYPE_MCA:\n\t\t/* We don't grok MicroChannel (yet). */\n\t\treturn 1;\n\tdefault:\n\t\tif (inquire.reply.bus_type != 'F')\n\t\t\tprintf(\"bt_find: illegal bus type %c\\n\",\n\t\t\t    inquire.reply.bus_type);\n\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* Adaptec 1542 cards do not support this */\n\tdigit.reply.digit = '@';\n\tdigit.cmd.opcode = BT_INQUIRE_REVISION_3;\n\tbt_cmd(iobase, sc, sizeof(digit.cmd), (u_char *)&digit.cmd,\n\t    sizeof(digit.reply), (u_char *)&digit.reply);\n\tif (digit.reply.digit == '@')\n\t\treturn 1;\n#endif\n\n\t/*\n\t * Assume we have a board at this stage setup dma channel from\n\t * jumpers and save int level\n\t */\n\tdelay(1000);\n\tconfig.cmd.opcode = BT_INQUIRE_CONFIG;\n\tbt_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,\n\t    sizeof(config.reply), (u_char *)&config.reply);\n\tswitch (config.reply.chan) {\n\tcase EISADMA:\n\t\tdrq = DRQUNK;\n\t\tbreak;\n\tcase CHAN0:\n\t\tdrq = 0;\n\t\tbreak;\n\tcase CHAN5:\n\t\tdrq = 5;\n\t\tbreak;\n\tcase CHAN6:\n\t\tdrq = 6;\n\t\tbreak;\n\tcase CHAN7:\n\t\tdrq = 7;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal drq setting %x\\n\", config.reply.chan);\n\t\treturn 1;\n\t}\n\n\tswitch (config.reply.intr) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bt_find: illegal irq setting %x\\n\", config.reply.intr);\n\t\treturn 1;\n\t}\n\n\tif (sc != NULL) {\n\t\t/* who are we on the scsi bus? */\n\t\tsc->sc_scsi_dev = config.reply.scsi_dev;\n\n\t\tsc->sc_iobase = iobase;\n\t\tsc->sc_irq = irq;\n\t\tsc->sc_drq = drq;\n\t} else {\n\t\tif (ia->ia_irq == IRQUNK)\n\t\t\tia->ia_irq = irq;\n\t\telse if (ia->ia_irq != irq)\n\t\t\treturn 1;\n\t\tif (ia->ia_drq == DRQUNK)\n\t\t\tia->ia_drq = drq;\n\t\telse if (ia->ia_drq != drq)\n\t\t\treturn 1;\n\t}\n\n#if NAHA > 0\n\t/* XXXX To avoid conflicting with the aha1542 probe */\n\tbtports[nbtports++] = iobase;\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_find;\nint\tbtprobe;\n\nint\nbtprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tregister struct isa_attach_args *ia = aux;\n\n\t/* See if there is a unit at this location. */\n\tif (bt_find(ia, NULL) != 0)\n\t\treturn 0;\n\n\tia->ia_msize = 0;\n\tia->ia_iosize = 4;\n\t/* IRQ and DRQ set by bt_find(). */\n\treturn 1;\n}"
  },
  {
    "function_name": "bt_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
    "lines": "198-315",
    "snippet": "int\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}",
    "includes": [
      "#include \"bt.h\"",
      "#include \"aha.h\"",
      "#include <dev/isa/btreg.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int bt_cmd",
      "struct bt_softc *, int, u_char *, int, u_char *));",
      "bt_finish_ccbs __P((struct bt_softc *));",
      "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
      "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + BT_CTRL_PORT",
            "BT_CTRL_IRST"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bt_cmd, host not finished(0x%x)\\n\"",
            "name",
            "sts"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "50"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + BT_INTR_PORT"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint bt_cmd;\nstruct bt_softc *, int, u_char *, int, u_char *));\nbt_finish_ccbs __P((struct bt_softc *));\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nint\nbt_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)\n\tint iobase;\n\tstruct bt_softc *sc;\n\tint icnt, ocnt;\n\tu_char *ibuf, *obuf;\n{\n\tconst char *name;\n\tregister int i;\n\tint wait;\n\tu_char sts;\n\tu_char opcode = ibuf[0];\n\n\tif (sc != NULL)\n\t\tname = sc->sc_dev.dv_xname;\n\telse\n\t\tname = \"(bt probe)\";\n\n\t/*\n\t * Calculate a reasonable timeout for the command.\n\t */\n\tswitch (opcode) {\n\tcase BT_INQUIRE_DEVICES:\n\t\twait = 15 * 20000;\n\t\tbreak;\n\tdefault:\n\t\twait = 1 * 20000;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Wait for the adapter to go idle, unless it's one of\n\t * the commands which don't need this\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_IDLE)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not idle(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\t/*\n\t * Now that it is idle, if we expect output, preflush the\n\t * queue feeding to us.\n\t */\n\tif (ocnt) {\n\t\twhile ((inb(iobase + BT_STAT_PORT)) & BT_STAT_DF)\n\t\t\tinb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Output the command and the number of arguments given\n\t * for each byte, first check the port is empty.\n\t */\n\twhile (icnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (!(sts & BT_STAT_CDF))\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port full\\n\", name);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\toutb(iobase + BT_CMD_PORT, *ibuf++);\n\t}\n\t/*\n\t * If we expect input, loop that many times, each time,\n\t * looking for the data register to have valid data\n\t */\n\twhile (ocnt--) {\n\t\tfor (i = wait; i; i--) {\n\t\t\tsts = inb(iobase + BT_STAT_PORT);\n\t\t\tif (sts & BT_STAT_DF)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tif (opcode != BT_INQUIRE_REVISION &&\n\t\t\t    opcode != BT_INQUIRE_REVISION_3)\n\t\t\t\tprintf(\"%s: bt_cmd, cmd/data port empty %d\\n\",\n\t\t\t\t    name, ocnt);\n\t\t\toutb(iobase + BT_CTRL_PORT, BT_CTRL_SRST);\n\t\t\treturn ENXIO;\n\t\t}\n\t\t*obuf++ = inb(iobase + BT_DATA_PORT);\n\t}\n\t/*\n\t * Wait for the board to report a finished instruction.\n\t * We may get an extra interrupt for the HACC signal, but this is\n\t * unimportant.\n\t */\n\tif (opcode != BT_MBO_INTR_EN) {\n\t\tfor (i = 20000; i; i--) {\t/* 1 sec? */\n\t\t\tsts = inb(iobase + BT_INTR_PORT);\n\t\t\t/* XXX Need to save this in the interrupt handler? */\n\t\t\tif (sts & BT_INTR_HACC)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (!i) {\n\t\t\tprintf(\"%s: bt_cmd, host not finished(0x%x)\\n\",\n\t\t\t    name, sts);\n\t\t\treturn ENXIO;\n\t\t}\n\t}\n\toutb(iobase + BT_CTRL_PORT, BT_CTRL_IRST);\n\treturn 0;\n}"
  }
]