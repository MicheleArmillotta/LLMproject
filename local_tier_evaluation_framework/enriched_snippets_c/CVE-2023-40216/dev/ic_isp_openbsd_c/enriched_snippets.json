[
  {
    "function_name": "isp_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
    "lines": "559-785",
    "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_internal_restart(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no more space for fabric devices\\n\"",
            "isp->isp_name"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\"",
            "isp->isp_name",
            "pt",
            "portid",
            "((u_int32_t) (wwnn >> 32))",
            "((u_int32_t) wwnn)",
            "((u_int32_t) (wwpn >> 32))",
            "((u_int32_t) wwpn)"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "wwpn >> 32"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "wwnn >> 32"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "lp->node_wwn & 0xffffffffLL"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "lp->node_wwn >> 32"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "lp->port_wwn & 0xffffffffLL"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "lp->port_wwn >> 32"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "isp_internal_restart",
            "isp",
            "1"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: Bus %d Target %d Async Mode%s\"",
            "isp->isp_name",
            "bus",
            "tgt",
            "wt"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\"",
            "isp->isp_name",
            "bus",
            "tgt",
            "mhz",
            "sdp->isp_devparam[tgt].cur_offset",
            "wt"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "isp_internal_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
    "lines": "530-557",
    "snippet": "static void\nisp_internal_restart(void *arg)\n{\n\tstruct ispsoftc *isp = arg;\n\tint result, nrestarted = 0, s;\n\n\ts = splbio();\n\tif (isp->isp_osinfo.blocked == 0) {\n\t\tstruct scsi_xfer *xs;\n\t\twhile ((xs = isp->isp_osinfo.wqf) != NULL) {\n\t\t\tisp->isp_osinfo.wqf = xs->free_list.le_next;\n\t\t\txs->free_list.le_next = NULL;\n\t\t\tDISABLE_INTS(isp);\n\t\t\tresult = ispscsicmd(xs);\n\t\t\tENABLE_INTS(isp);\n\t\t\tif (result != CMD_QUEUED) {\n\t\t\t\tprintf(\"%s: botched command restart (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, result);\n\t\t\t\tif (XS_NOERR(xs))\n\t\t\t\t\tXS_SETERR(xs, XS_DRIVER_STUFFUP);\n\t\t\t\tXS_CMD_DONE(xs);\n\t\t\t}\n\t\t\tnrestarted++;\n\t\t}\n\t\tprintf(\"%s: requeued %d commands\\n\", isp->isp_name, nrestarted);\n\t}\n\t(void) splx(s);\n}",
    "includes": [
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_internal_restart(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: requeued %d commands\\n\"",
            "isp->isp_name",
            "nrestarted"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_CMD_DONE",
          "args": [
            "xs"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "XS_DRIVER_STUFFUP"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_NOERR",
          "args": [
            "xs"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ispscsicmd",
          "args": [
            "xs"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ispscsicmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1862-2143",
          "snippet": "int32_t\nispscsicmd(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tstruct ispsoftc *isp;\n\tu_int16_t iptr, optr;\n\tunion {\n\t\tispreq_t *_reqp;\n\t\tispreqt2_t *_t2reqp;\n\t} _u;\n#define\treqp\t_u._reqp\n#define\tt2reqp\t_u._t2reqp\n#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))\n\tint target, i;\n\n\tXS_INITERR(xs);\n\tisp = XS_ISP(xs);\n\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: adapter not ready\\n\", isp->isp_name);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check command CDB length, etc.. We really are limited to 16 bytes\n\t * for Fibre Channel, but can do up to 44 bytes in parallel SCSI,\n\t * but probably only if we're running fairly new firmware (we'll\n\t * let the old f/w choke on an extended command queue entry).\n\t */\n\n\tif (XS_CDBLEN(xs) > (IS_FC(isp)? 16 : 44) || XS_CDBLEN(xs) == 0) {\n\t\tPRINTF(\"%s: unsupported cdb length (%d, CDB[0]=0x%x)\\n\",\n\t\t    isp->isp_name, XS_CDBLEN(xs), XS_CDBP(xs)[0] & 0xff);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check to see whether we have good firmware state still or\n\t * need to refresh our port database for this target.\n\t */\n\ttarget = XS_TGT(xs);\n\tif (IS_FC(isp)) {\n\t\tfcparam *fcp = isp->isp_param;\n\t\tstruct lportdb *lp;\n#if\tdefined(ISP2100_FABRIC)\n\t\t/*\n\t\t * If we're not on a Fabric, we can't have a target\n\t\t * above FL_PORT_ID-1. If we're on a fabric and\n\t\t * connected as an F-port, we can't have a target\n\t\t * less than FC_SNS_ID+1.\n\t\t */\n\t\tif (fcp->isp_onfabric == 0) {\n\t\t\tif (target >= FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (target >= FL_PORT_ID && target <= FC_SNS_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t\tif (fcp->isp_topo == TOPO_F_PORT &&\n\t\t\t    target < FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n#endif\n\t\t/*\n\t\t * Check for f/w being in ready state. If the f/w\n\t\t * isn't in ready state, then we don't know our\n\t\t * loop ID and the f/w hasn't completed logging\n\t\t * into all targets on the loop. If this is the\n\t\t * case, then bounce the command. We pretend this is\n\t\t * a SELECTION TIMEOUT error if we've never gone to\n\t\t * FW_READY state at all- in this case we may not\n\t\t * be hooked to a loop at all and we shouldn't hang\n\t\t * the machine for this. Otherwise, defer this command\n\t\t * until later.\n\t\t */\n\t\tif (fcp->isp_fwstate != FW_READY) {\n\t\t\tif (isp_fclink_test(isp, FC_FW_READY_DELAY)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\t\treturn (CMD_RQLATER);\n\t\t\t\t} else {\n\t\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is such that we haven't yet received\n\t\t * a \"Port Database Changed\" notification (after a LIP or\n\t\t * a Loop Reset or firmware initialization), then defer\n\t\t * sending commands for a little while, but only if we've\n\t\t * seen a valid loop at one point (otherwise we can get\n\t\t * stuck at initialization time).\n\t\t */\n\t\tif (fcp->isp_loopstate < LOOP_PDB_RCVD) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\treturn (CMD_RQLATER);\n\t\t\t} else {\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is now such that we've just now\n\t\t * received a Port Database Change notification, then\n\t\t * we have to go off and (re)synchronize our port\n\t\t * database.\n\t\t */\n\t\tif (fcp->isp_loopstate == LOOP_PDB_RCVD) {\n\t\t\tif (isp_pdb_sync(isp, target)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Now check whether we should even think about pursuing this.\n\t\t */\n\t\tlp = &fcp->portdb[target];\n\t\tif (lp->valid == 0) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\tif ((lp->roles & (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT)) == 0) {\n\t\t\tIDPRINTF(3, (\"%s: target %d is not a target\\n\",\n\t\t\t    isp->isp_name, target));\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\t/*\n\t\t * Now turn target into what the actual loop ID is.\n\t\t */\n\t\ttarget = lp->loopid;\n\t}\n\n\t/*\n\t * Next check to see if any HBA or Device\n\t * parameters need to be updated.\n\t */\n\tif (isp->isp_update != 0) {\n\t\tisp_update(isp);\n\t}\n\n\tif (isp_getrqentry(isp, &iptr, &optr, (void **) &reqp)) {\n\t\tIDPRINTF(1, (\"%s: Request Queue Overflow\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\n\t/*\n\t * Now see if we need to synchronize the ISP with respect to anything.\n\t * We do dual duty here (cough) for synchronizing for busses other\n\t * than which we got here to send a command to.\n\t */\n\tif (isp->isp_sendmarker) {\n\t\tu_int8_t n = (IS_DUALBUS(isp)? 2: 1);\n\t\t/*\n\t\t * Check ports to send markers for...\n\t\t */\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif ((isp->isp_sendmarker & (1 << i)) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tMEMZERO((void *) reqp, sizeof (*reqp));\n\t\t\treqp->req_header.rqs_entry_count = 1;\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_MARKER;\n\t\t\treqp->req_modifier = SYNC_ALL;\n\t\t\treqp->req_target = i << 7;\t/* insert bus number */\n\t\t\tISP_SWIZZLE_REQUEST(isp, reqp);\n\t\t\tMemoryBarrier();\n\t\t\tISP_ADD_REQUEST(isp, iptr);\n\n\t\t\tif (isp_getrqentry(isp, &iptr, &optr, (void **)&reqp)) {\n\t\t\t\tIDPRINTF(1, (\"%s: Request Queue Overflow+\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t\treturn (CMD_EAGAIN);\n\t\t\t}\n\t\t}\n\t}\n\n\tMEMZERO((void *) reqp, UZSIZE);\n\treqp->req_header.rqs_entry_count = 1;\n\tif (IS_FC(isp)) {\n\t\treqp->req_header.rqs_entry_type = RQSTYPE_T2RQS;\n\t} else {\n\t\tif (XS_CDBLEN(xs) > 12)\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_CMDONLY;\n\t\telse\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_REQUEST;\n\t}\n\treqp->req_header.rqs_flags = 0;\n\treqp->req_header.rqs_seqno = 0;\n\tif (IS_FC(isp)) {\n\t\t/*\n\t\t * See comment in isp_intr\n\t\t */\n\t\tXS_RESID(xs) = 0;\n\n\t\t/*\n\t\t * Fibre Channel always requires some kind of tag.\n\t\t * The Qlogic drivers seem be happy not to use a tag,\n\t\t * but this breaks for some devices (IBM drives).\n\t\t */\n\t\tif (XS_CANTAG(xs)) {\n\t\t\tt2reqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t} else {\n\t\t\tif (XS_CDBP(xs)[0] == 0x3)\t/* REQUEST SENSE */\n\t\t\t\tt2reqp->req_flags = REQFLAG_HTAG;\n\t\t\telse\n\t\t\t\tt2reqp->req_flags = REQFLAG_OTAG;\n\t\t}\n\t} else {\n\t\tsdparam *sdp = (sdparam *)isp->isp_param;\n\t\tif ((sdp->isp_devparam[target].cur_dflags & DPARM_TQING) &&\n\t\t    XS_CANTAG(xs)) {\n\t\t\treqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t}\n\t}\n\treqp->req_target = target | (XS_CHANNEL(xs) << 7);\n\tif (IS_SCSI(isp)) {\n\t\treqp->req_lun_trn = XS_LUN(xs);\n\t\treqp->req_cdblen = XS_CDBLEN(xs);\n\t} else {\n#ifdef\tISP2100_SCCLUN\n\t\tt2reqp->req_scclun = XS_LUN(xs);\n#else\n\t\tt2reqp->req_lun_trn = XS_LUN(xs);\n#endif\n\t}\n\tMEMCPY(reqp->req_cdb, XS_CDBP(xs), XS_CDBLEN(xs));\n\n\treqp->req_time = XS_TIME(xs) / 1000;\n\tif (reqp->req_time == 0 && XS_TIME(xs))\n\t\treqp->req_time = 1;\n\n\t/*\n\t * Always give a bit more leeway to commands after a bus reset.\n\t * XXX: DOES NOT DISTINGUISH WHICH PORT MAY HAVE BEEN SYNCED\n\t */\n\tif (isp->isp_sendmarker && reqp->req_time < 5) {\n\t\treqp->req_time = 5;\n\t}\n\tif (isp_save_xs(isp, xs, &reqp->req_handle)) {\n\t\tIDPRINTF(2, (\"%s: out of xflist pointers\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\t/*\n\t * Set up DMA and/or do any bus swizzling of the request entry\n\t * so that the Qlogic F/W understands what is being asked of it.\n \t*/\n\ti = ISP_DMASETUP(isp, xs, reqp, &iptr, optr);\n\tif (i != CMD_QUEUED) {\n\t\tisp_destroy_handle(isp, reqp->req_handle);\n\t\t/*\n\t\t * dmasetup sets actual error in packet, and\n\t\t * return what we were given to return.\n\t\t */\n\t\treturn (i);\n\t}\n\tXS_SETERR(xs, HBA_NOERROR);\n\tIDPRINTF(5, (\"%s(%d.%d.%d): START cmd 0x%x datalen %d\\n\",\n\t    isp->isp_name, XS_CHANNEL(xs), target, XS_LUN(xs),\n\t    reqp->req_cdb[0], XS_XFRLEN(xs)));\n\tMemoryBarrier();\n\tISP_ADD_REQUEST(isp, iptr);\n\tisp->isp_nactive++;\n\tif (isp->isp_sendmarker)\n\t\tisp->isp_sendmarker = 0;\n\treturn (CMD_QUEUED);\n#undef\treqp\n#undef\tt2reqp\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))",
            "#define\tt2reqp\t_u._t2reqp",
            "#define\treqp\t_u._reqp"
          ],
          "globals_used": [
            "static int isp_fclink_test",
            "static int isp_pdb_sync",
            "static void isp_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))\n#define\tt2reqp\t_u._t2reqp\n#define\treqp\t_u._reqp\n\nstatic int isp_fclink_test;\nstatic int isp_pdb_sync;\nstatic void isp_update;\n\nint32_t\nispscsicmd(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tstruct ispsoftc *isp;\n\tu_int16_t iptr, optr;\n\tunion {\n\t\tispreq_t *_reqp;\n\t\tispreqt2_t *_t2reqp;\n\t} _u;\n#define\treqp\t_u._reqp\n#define\tt2reqp\t_u._t2reqp\n#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))\n\tint target, i;\n\n\tXS_INITERR(xs);\n\tisp = XS_ISP(xs);\n\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: adapter not ready\\n\", isp->isp_name);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check command CDB length, etc.. We really are limited to 16 bytes\n\t * for Fibre Channel, but can do up to 44 bytes in parallel SCSI,\n\t * but probably only if we're running fairly new firmware (we'll\n\t * let the old f/w choke on an extended command queue entry).\n\t */\n\n\tif (XS_CDBLEN(xs) > (IS_FC(isp)? 16 : 44) || XS_CDBLEN(xs) == 0) {\n\t\tPRINTF(\"%s: unsupported cdb length (%d, CDB[0]=0x%x)\\n\",\n\t\t    isp->isp_name, XS_CDBLEN(xs), XS_CDBP(xs)[0] & 0xff);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check to see whether we have good firmware state still or\n\t * need to refresh our port database for this target.\n\t */\n\ttarget = XS_TGT(xs);\n\tif (IS_FC(isp)) {\n\t\tfcparam *fcp = isp->isp_param;\n\t\tstruct lportdb *lp;\n#if\tdefined(ISP2100_FABRIC)\n\t\t/*\n\t\t * If we're not on a Fabric, we can't have a target\n\t\t * above FL_PORT_ID-1. If we're on a fabric and\n\t\t * connected as an F-port, we can't have a target\n\t\t * less than FC_SNS_ID+1.\n\t\t */\n\t\tif (fcp->isp_onfabric == 0) {\n\t\t\tif (target >= FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (target >= FL_PORT_ID && target <= FC_SNS_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t\tif (fcp->isp_topo == TOPO_F_PORT &&\n\t\t\t    target < FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n#endif\n\t\t/*\n\t\t * Check for f/w being in ready state. If the f/w\n\t\t * isn't in ready state, then we don't know our\n\t\t * loop ID and the f/w hasn't completed logging\n\t\t * into all targets on the loop. If this is the\n\t\t * case, then bounce the command. We pretend this is\n\t\t * a SELECTION TIMEOUT error if we've never gone to\n\t\t * FW_READY state at all- in this case we may not\n\t\t * be hooked to a loop at all and we shouldn't hang\n\t\t * the machine for this. Otherwise, defer this command\n\t\t * until later.\n\t\t */\n\t\tif (fcp->isp_fwstate != FW_READY) {\n\t\t\tif (isp_fclink_test(isp, FC_FW_READY_DELAY)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\t\treturn (CMD_RQLATER);\n\t\t\t\t} else {\n\t\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is such that we haven't yet received\n\t\t * a \"Port Database Changed\" notification (after a LIP or\n\t\t * a Loop Reset or firmware initialization), then defer\n\t\t * sending commands for a little while, but only if we've\n\t\t * seen a valid loop at one point (otherwise we can get\n\t\t * stuck at initialization time).\n\t\t */\n\t\tif (fcp->isp_loopstate < LOOP_PDB_RCVD) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\treturn (CMD_RQLATER);\n\t\t\t} else {\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is now such that we've just now\n\t\t * received a Port Database Change notification, then\n\t\t * we have to go off and (re)synchronize our port\n\t\t * database.\n\t\t */\n\t\tif (fcp->isp_loopstate == LOOP_PDB_RCVD) {\n\t\t\tif (isp_pdb_sync(isp, target)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Now check whether we should even think about pursuing this.\n\t\t */\n\t\tlp = &fcp->portdb[target];\n\t\tif (lp->valid == 0) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\tif ((lp->roles & (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT)) == 0) {\n\t\t\tIDPRINTF(3, (\"%s: target %d is not a target\\n\",\n\t\t\t    isp->isp_name, target));\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\t/*\n\t\t * Now turn target into what the actual loop ID is.\n\t\t */\n\t\ttarget = lp->loopid;\n\t}\n\n\t/*\n\t * Next check to see if any HBA or Device\n\t * parameters need to be updated.\n\t */\n\tif (isp->isp_update != 0) {\n\t\tisp_update(isp);\n\t}\n\n\tif (isp_getrqentry(isp, &iptr, &optr, (void **) &reqp)) {\n\t\tIDPRINTF(1, (\"%s: Request Queue Overflow\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\n\t/*\n\t * Now see if we need to synchronize the ISP with respect to anything.\n\t * We do dual duty here (cough) for synchronizing for busses other\n\t * than which we got here to send a command to.\n\t */\n\tif (isp->isp_sendmarker) {\n\t\tu_int8_t n = (IS_DUALBUS(isp)? 2: 1);\n\t\t/*\n\t\t * Check ports to send markers for...\n\t\t */\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif ((isp->isp_sendmarker & (1 << i)) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tMEMZERO((void *) reqp, sizeof (*reqp));\n\t\t\treqp->req_header.rqs_entry_count = 1;\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_MARKER;\n\t\t\treqp->req_modifier = SYNC_ALL;\n\t\t\treqp->req_target = i << 7;\t/* insert bus number */\n\t\t\tISP_SWIZZLE_REQUEST(isp, reqp);\n\t\t\tMemoryBarrier();\n\t\t\tISP_ADD_REQUEST(isp, iptr);\n\n\t\t\tif (isp_getrqentry(isp, &iptr, &optr, (void **)&reqp)) {\n\t\t\t\tIDPRINTF(1, (\"%s: Request Queue Overflow+\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t\treturn (CMD_EAGAIN);\n\t\t\t}\n\t\t}\n\t}\n\n\tMEMZERO((void *) reqp, UZSIZE);\n\treqp->req_header.rqs_entry_count = 1;\n\tif (IS_FC(isp)) {\n\t\treqp->req_header.rqs_entry_type = RQSTYPE_T2RQS;\n\t} else {\n\t\tif (XS_CDBLEN(xs) > 12)\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_CMDONLY;\n\t\telse\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_REQUEST;\n\t}\n\treqp->req_header.rqs_flags = 0;\n\treqp->req_header.rqs_seqno = 0;\n\tif (IS_FC(isp)) {\n\t\t/*\n\t\t * See comment in isp_intr\n\t\t */\n\t\tXS_RESID(xs) = 0;\n\n\t\t/*\n\t\t * Fibre Channel always requires some kind of tag.\n\t\t * The Qlogic drivers seem be happy not to use a tag,\n\t\t * but this breaks for some devices (IBM drives).\n\t\t */\n\t\tif (XS_CANTAG(xs)) {\n\t\t\tt2reqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t} else {\n\t\t\tif (XS_CDBP(xs)[0] == 0x3)\t/* REQUEST SENSE */\n\t\t\t\tt2reqp->req_flags = REQFLAG_HTAG;\n\t\t\telse\n\t\t\t\tt2reqp->req_flags = REQFLAG_OTAG;\n\t\t}\n\t} else {\n\t\tsdparam *sdp = (sdparam *)isp->isp_param;\n\t\tif ((sdp->isp_devparam[target].cur_dflags & DPARM_TQING) &&\n\t\t    XS_CANTAG(xs)) {\n\t\t\treqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t}\n\t}\n\treqp->req_target = target | (XS_CHANNEL(xs) << 7);\n\tif (IS_SCSI(isp)) {\n\t\treqp->req_lun_trn = XS_LUN(xs);\n\t\treqp->req_cdblen = XS_CDBLEN(xs);\n\t} else {\n#ifdef\tISP2100_SCCLUN\n\t\tt2reqp->req_scclun = XS_LUN(xs);\n#else\n\t\tt2reqp->req_lun_trn = XS_LUN(xs);\n#endif\n\t}\n\tMEMCPY(reqp->req_cdb, XS_CDBP(xs), XS_CDBLEN(xs));\n\n\treqp->req_time = XS_TIME(xs) / 1000;\n\tif (reqp->req_time == 0 && XS_TIME(xs))\n\t\treqp->req_time = 1;\n\n\t/*\n\t * Always give a bit more leeway to commands after a bus reset.\n\t * XXX: DOES NOT DISTINGUISH WHICH PORT MAY HAVE BEEN SYNCED\n\t */\n\tif (isp->isp_sendmarker && reqp->req_time < 5) {\n\t\treqp->req_time = 5;\n\t}\n\tif (isp_save_xs(isp, xs, &reqp->req_handle)) {\n\t\tIDPRINTF(2, (\"%s: out of xflist pointers\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\t/*\n\t * Set up DMA and/or do any bus swizzling of the request entry\n\t * so that the Qlogic F/W understands what is being asked of it.\n \t*/\n\ti = ISP_DMASETUP(isp, xs, reqp, &iptr, optr);\n\tif (i != CMD_QUEUED) {\n\t\tisp_destroy_handle(isp, reqp->req_handle);\n\t\t/*\n\t\t * dmasetup sets actual error in packet, and\n\t\t * return what we were given to return.\n\t\t */\n\t\treturn (i);\n\t}\n\tXS_SETERR(xs, HBA_NOERROR);\n\tIDPRINTF(5, (\"%s(%d.%d.%d): START cmd 0x%x datalen %d\\n\",\n\t    isp->isp_name, XS_CHANNEL(xs), target, XS_LUN(xs),\n\t    reqp->req_cdb[0], XS_XFRLEN(xs)));\n\tMemoryBarrier();\n\tISP_ADD_REQUEST(isp, iptr);\n\tisp->isp_nactive++;\n\tif (isp->isp_sendmarker)\n\t\tisp->isp_sendmarker = 0;\n\treturn (CMD_QUEUED);\n#undef\treqp\n#undef\tt2reqp\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nstatic void\nisp_internal_restart(void *arg)\n{\n\tstruct ispsoftc *isp = arg;\n\tint result, nrestarted = 0, s;\n\n\ts = splbio();\n\tif (isp->isp_osinfo.blocked == 0) {\n\t\tstruct scsi_xfer *xs;\n\t\twhile ((xs = isp->isp_osinfo.wqf) != NULL) {\n\t\t\tisp->isp_osinfo.wqf = xs->free_list.le_next;\n\t\t\txs->free_list.le_next = NULL;\n\t\t\tDISABLE_INTS(isp);\n\t\t\tresult = ispscsicmd(xs);\n\t\t\tENABLE_INTS(isp);\n\t\t\tif (result != CMD_QUEUED) {\n\t\t\t\tprintf(\"%s: botched command restart (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, result);\n\t\t\t\tif (XS_NOERR(xs))\n\t\t\t\t\tXS_SETERR(xs, XS_DRIVER_STUFFUP);\n\t\t\t\tXS_CMD_DONE(xs);\n\t\t\t}\n\t\t\tnrestarted++;\n\t\t}\n\t\tprintf(\"%s: requeued %d commands\\n\", isp->isp_name, nrestarted);\n\t}\n\t(void) splx(s);\n}"
  },
  {
    "function_name": "isp_command_requeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
    "lines": "501-524",
    "snippet": "static void\nisp_command_requeue(void *arg)\n{\n\tstruct scsi_xfer *xs = arg;\n\tstruct ispsoftc *isp = XS_ISP(xs);\n\tint s = splbio();\n\tswitch (ispcmd_slow(xs)) {\n\tcase SUCCESSFULLY_QUEUED:\n\t\tprintf(\"%s: isp_command_reque: queued %d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\tcase TRY_AGAIN_LATER:\n\t\tprintf(\"%s: EAGAIN for %d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\t/* FALLTHROUGH */\n\tcase COMPLETE:\n\t\t/* can only be an error */\n\t\tif (XS_NOERR(xs))\n\t\t\tXS_SETERR(xs, XS_DRIVER_STUFFUP);\n\t\tXS_CMD_DONE(xs);\n\t\tbreak;\n\t}\n\t(void) splx(s);\n}",
    "includes": [
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int32_t ispcmd_slow",
      "static void isp_command_requeue(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_CMD_DONE",
          "args": [
            "xs"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "XS_DRIVER_STUFFUP"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_NOERR",
          "args": [
            "xs"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: EAGAIN for %d.%d\\n\"",
            "isp->isp_name",
            "XS_TGT(xs)",
            "XS_LUN(xs)"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_LUN",
          "args": [
            "xs"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ispcmd_slow",
          "args": [
            "xs"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ispcmd_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "209-292",
          "snippet": "static int32_t\nispcmd_slow(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tsdparam *sdp;\n\tint tgt, chan;\n\tu_int16_t f;\n\tstruct ispsoftc *isp = XS_ISP(xs);\n\n\t/*\n\t * Have we completed discovery for this target on this adapter?\n\t */\n\tsdp = isp->isp_param;\n\ttgt = XS_TGT(xs);\n\tchan = XS_CHANNEL(xs);\n\tsdp += chan;\n\tif ((xs->flags & SCSI_POLL) != 0 ||\n\t    (isp->isp_osinfo.discovered[chan] & (1 << tgt)) != 0) {\n\t\treturn (ispcmd(xs));\n\t}\n\n\tf = DPARM_DEFAULT;\n\tif (xs->sc_link->quirks & SDEV_NOSYNC) {\n\t\tf ^= DPARM_SYNC;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do SYNC xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\tif (xs->sc_link->quirks & SDEV_NOWIDE) {\n\t\tf ^= DPARM_WIDE;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do WIDE xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\tif (xs->sc_link->quirks & SDEV_NOTAGS) {\n\t\tf ^= DPARM_TQING;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do TAGGED xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\n\t/*\n\t * Okay, we know about this device now,\n\t * so mark parameters to be updated for it.\n\t */\n\tsdp->isp_devparam[tgt].dev_flags = f;\n\tsdp->isp_devparam[tgt].dev_update = 1;\n\tisp->isp_update |= (1 << chan);\n\n\t/*\n\t * Now check to see whether we can get out of this checking mode now.\n\t * XXX: WE CANNOT AS YET BECAUSE THERE IS NO MECHANISM TO TELL US\n\t * XXX: WHEN WE'RE DONE DISCOVERY BECAUSE WE NEED ONE COMMAND AFTER\n\t * XXX: DISCOVERY IS DONE FOR EACH TARGET TO TELL US THAT WE'RE DONE\n\t * XXX: AND THAT DOESN'T HAPPEN HERE. AT BEST WE CAN MARK OURSELVES\n\t * XXX: DONE WITH DISCOVERY FOR THIS TARGET AND SO SAVE MAYBE 20\n\t * XXX: LINES OF C CODE.\n\t */\n\tisp->isp_osinfo.discovered[chan] |= (1 << tgt);\n\t/* do not bother with these lines- they'll never execute correctly */\n#if\t0\n\tsdp = isp->isp_param;\n\tfor (chan = 0; chan < (IS_12X0(isp)? 2 : 1); chan++, sdp++) {\n\t\tf = 0xffff & ~(1 << sdp->isp_initiator_id);\n\t\tif (isp->isp_osinfo.discovered[chan] != f) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (chan == (IS_12X0(isp)? 2 : 1)) {\n\t\tCFGPRINTF(\"%s: allowing sync/wide negotiation and \"\n\t\t    \"tag usage\\n\", isp->isp_name);\n\t\tisp->isp_osinfo._adapter.scsipi_cmd = ispcmd;\n\t\tif (IS_12X0(isp))\n\t\t\tisp->isp_update |= 2;\n\t}\n#endif\n\treturn (ispcmd(xs));\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int32_t ispcmd_slow",
            "static int32_t ispcmd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic int32_t ispcmd_slow;\nstatic int32_t ispcmd;\n\nstatic int32_t\nispcmd_slow(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tsdparam *sdp;\n\tint tgt, chan;\n\tu_int16_t f;\n\tstruct ispsoftc *isp = XS_ISP(xs);\n\n\t/*\n\t * Have we completed discovery for this target on this adapter?\n\t */\n\tsdp = isp->isp_param;\n\ttgt = XS_TGT(xs);\n\tchan = XS_CHANNEL(xs);\n\tsdp += chan;\n\tif ((xs->flags & SCSI_POLL) != 0 ||\n\t    (isp->isp_osinfo.discovered[chan] & (1 << tgt)) != 0) {\n\t\treturn (ispcmd(xs));\n\t}\n\n\tf = DPARM_DEFAULT;\n\tif (xs->sc_link->quirks & SDEV_NOSYNC) {\n\t\tf ^= DPARM_SYNC;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do SYNC xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\tif (xs->sc_link->quirks & SDEV_NOWIDE) {\n\t\tf ^= DPARM_WIDE;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do WIDE xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\tif (xs->sc_link->quirks & SDEV_NOTAGS) {\n\t\tf ^= DPARM_TQING;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do TAGGED xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\n\t/*\n\t * Okay, we know about this device now,\n\t * so mark parameters to be updated for it.\n\t */\n\tsdp->isp_devparam[tgt].dev_flags = f;\n\tsdp->isp_devparam[tgt].dev_update = 1;\n\tisp->isp_update |= (1 << chan);\n\n\t/*\n\t * Now check to see whether we can get out of this checking mode now.\n\t * XXX: WE CANNOT AS YET BECAUSE THERE IS NO MECHANISM TO TELL US\n\t * XXX: WHEN WE'RE DONE DISCOVERY BECAUSE WE NEED ONE COMMAND AFTER\n\t * XXX: DISCOVERY IS DONE FOR EACH TARGET TO TELL US THAT WE'RE DONE\n\t * XXX: AND THAT DOESN'T HAPPEN HERE. AT BEST WE CAN MARK OURSELVES\n\t * XXX: DONE WITH DISCOVERY FOR THIS TARGET AND SO SAVE MAYBE 20\n\t * XXX: LINES OF C CODE.\n\t */\n\tisp->isp_osinfo.discovered[chan] |= (1 << tgt);\n\t/* do not bother with these lines- they'll never execute correctly */\n#if\t0\n\tsdp = isp->isp_param;\n\tfor (chan = 0; chan < (IS_12X0(isp)? 2 : 1); chan++, sdp++) {\n\t\tf = 0xffff & ~(1 << sdp->isp_initiator_id);\n\t\tif (isp->isp_osinfo.discovered[chan] != f) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (chan == (IS_12X0(isp)? 2 : 1)) {\n\t\tCFGPRINTF(\"%s: allowing sync/wide negotiation and \"\n\t\t    \"tag usage\\n\", isp->isp_name);\n\t\tisp->isp_osinfo._adapter.scsipi_cmd = ispcmd;\n\t\tif (IS_12X0(isp))\n\t\t\tisp->isp_update |= 2;\n\t}\n#endif\n\treturn (ispcmd(xs));\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_ISP",
          "args": [
            "xs"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic int32_t ispcmd_slow;\nstatic void isp_command_requeue(void *);\n\nstatic void\nisp_command_requeue(void *arg)\n{\n\tstruct scsi_xfer *xs = arg;\n\tstruct ispsoftc *isp = XS_ISP(xs);\n\tint s = splbio();\n\tswitch (ispcmd_slow(xs)) {\n\tcase SUCCESSFULLY_QUEUED:\n\t\tprintf(\"%s: isp_command_reque: queued %d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\tbreak;\n\tcase TRY_AGAIN_LATER:\n\t\tprintf(\"%s: EAGAIN for %d.%d\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\t/* FALLTHROUGH */\n\tcase COMPLETE:\n\t\t/* can only be an error */\n\t\tif (XS_NOERR(xs))\n\t\t\tXS_SETERR(xs, XS_DRIVER_STUFFUP);\n\t\tXS_CMD_DONE(xs);\n\t\tbreak;\n\t}\n\t(void) splx(s);\n}"
  },
  {
    "function_name": "isp_uninit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
    "lines": "477-496",
    "snippet": "void\nisp_uninit(isp)\n\tstruct ispsoftc *isp;\n{\n\tint s = splbio();\n\t/*\n\t * Leave with interrupts disabled.\n\t */\n\tDISABLE_INTS(isp);\n\n\t/*\n\t * Turn off the watchdog (if active).\n\t */\n\tif (isp->isp_dogactive) {\n\t\tuntimeout(isp_watch, isp);\n\t\tisp->isp_dogactive = 0;\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_watch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "isp_watch",
            "isp"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_watch;\n\nvoid\nisp_uninit(isp)\n\tstruct ispsoftc *isp;\n{\n\tint s = splbio();\n\t/*\n\t * Leave with interrupts disabled.\n\t */\n\tDISABLE_INTS(isp);\n\n\t/*\n\t * Turn off the watchdog (if active).\n\t */\n\tif (isp->isp_dogactive) {\n\t\tuntimeout(isp_watch, isp);\n\t\tisp->isp_dogactive = 0;\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "isp_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
    "lines": "425-468",
    "snippet": "static void\nisp_watch(arg)\n\tvoid *arg;\n{\n\tint i;\n\tstruct ispsoftc *isp = arg;\n\tstruct scsi_xfer *xs;\n\tint s;\n\n\t/*\n\t * Look for completely dead commands (but not polled ones).\n\t */\n\ts = splbio();\n\tfor (i = 0; i < isp->isp_maxcmds; i++) {\n\t\tif ((xs = (struct scsi_xfer *) isp->isp_xflist[i]) == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (xs->timeout == 0 || (xs->flags & SCSI_POLL)) {\n\t\t\tcontinue;\n\t\t}\n\t\txs->timeout -= (WATCH_INTERVAL * 1000);\n\n\t\t/*\n\t\t * Avoid later thinking that this\n\t\t * transaction is not being timed.\n\t\t * Then give ourselves to watchdog\n\t\t * periods of grace.\n\t\t */\n\t\tif (xs->timeout == 0) {\n\t\t\txs->timeout = 1;\n\t\t} else if (xs->timeout > -(2 * WATCH_INTERVAL * 1000)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (isp_control(isp, ISPCTL_ABORT_CMD, xs)) {\n\t\t\tprintf(\"%s: isp_watch failed to abort command\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tisp_restart(isp);\n\t\t\tbreak;\n\t\t}\n\t}\n        timeout(isp_watch, isp, WATCH_INTERVAL * hz);\n\tisp->isp_dogactive = 1;\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void isp_watch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "isp_watch",
            "isp",
            "WATCH_INTERVAL * hz"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_restart",
          "args": [
            "isp"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "isp_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "4063-4100",
          "snippet": "void\nisp_restart(isp)\n\tstruct ispsoftc *isp;\n{\n\tISP_SCSI_XFER_T *xs;\n\tu_int32_t handle;\n\n#if\t0\n\tisp->isp_gotdparms = 0;\n#endif\n\tisp_reset(isp);\n\tif (isp->isp_state == ISP_RESETSTATE) {\n\t\tisp_init(isp);\n\t\tif (isp->isp_state == ISP_INITSTATE) {\n\t\t\tisp->isp_state = ISP_RUNSTATE;\n\t\t}\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: isp_restart cannot restart ISP\\n\", isp->isp_name);\n\t}\n\tisp->isp_nactive = 0;\n\n\tfor (handle = 1; handle <= (int) isp->isp_maxcmds; handle++) {\n\t\txs = isp_find_xs(isp, handle);\n\t\tif (xs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, handle);\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, handle);\n\t\t\tXS_RESID(xs) = XS_XFRLEN(xs);\n\t\t} else {\n\t\t\tXS_RESID(xs) = 0;\n\t\t}\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\tXS_CMD_DONE(xs);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nvoid\nisp_restart(isp)\n\tstruct ispsoftc *isp;\n{\n\tISP_SCSI_XFER_T *xs;\n\tu_int32_t handle;\n\n#if\t0\n\tisp->isp_gotdparms = 0;\n#endif\n\tisp_reset(isp);\n\tif (isp->isp_state == ISP_RESETSTATE) {\n\t\tisp_init(isp);\n\t\tif (isp->isp_state == ISP_INITSTATE) {\n\t\t\tisp->isp_state = ISP_RUNSTATE;\n\t\t}\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: isp_restart cannot restart ISP\\n\", isp->isp_name);\n\t}\n\tisp->isp_nactive = 0;\n\n\tfor (handle = 1; handle <= (int) isp->isp_maxcmds; handle++) {\n\t\txs = isp_find_xs(isp, handle);\n\t\tif (xs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, handle);\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, handle);\n\t\t\tXS_RESID(xs) = XS_XFRLEN(xs);\n\t\t} else {\n\t\t\tXS_RESID(xs) = 0;\n\t\t}\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\tXS_CMD_DONE(xs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: isp_watch failed to abort command\\n\"",
            "isp->isp_name"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_control",
          "args": [
            "isp",
            "ISPCTL_ABORT_CMD",
            "xs"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "isp_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "2150-2275",
          "snippet": "int\nisp_control(isp, ctl, arg)\n\tstruct ispsoftc *isp;\n\tispctl_t ctl;\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *xs;\n\tmbreg_t mbs;\n\tint bus, tgt;\n\tu_int32_t handle;\n\n\tswitch (ctl) {\n\tdefault:\n\t\tPRINTF(\"%s: isp_control unknown control op %x\\n\",\n\t\t    isp->isp_name, ctl);\n\t\tbreak;\n\n\tcase ISPCTL_RESET_BUS:\n\t\t/*\n\t\t * Issue a bus reset.\n\t\t */\n\t\tmbs.param[0] = MBOX_BUS_RESET;\n\t\tmbs.param[2] = 0;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tmbs.param[1] =\n\t\t\t    ((sdparam *) isp->isp_param)->isp_bus_reset_delay;\n\t\t\tif (mbs.param[1] < 2)\n\t\t\t\tmbs.param[1] = 2;\n\t\t\tbus = *((int *) arg);\n\t\t\tif (IS_DUALBUS(isp))\n\t\t\t\tmbs.param[2] = bus;\n\t\t} else {\n\t\t\tmbs.param[1] = 10;\n\t\t\tbus = 0;\n\t\t}\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"isp_control SCSI bus reset failed\");\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: driver initiated bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\treturn (0);\n\n\tcase ISPCTL_RESET_DEV:\n\t\ttgt = (*((int *) arg)) & 0xffff;\n\t\tbus = (*((int *) arg)) >> 16;\n\t\tmbs.param[0] = MBOX_ABORT_TARGET;\n\t\tmbs.param[1] = (tgt << 8) | (bus << 15);\n\t\tmbs.param[2] = 3;\t/* 'delay', in seconds */\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_RESET_DEV failure (code \"\n\t\t\t    \"%x)\\n\", isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: Target %d on Bus %d Reset Succeeded\\n\",\n\t\t    isp->isp_name, tgt, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\treturn (0);\n\n\tcase ISPCTL_ABORT_CMD:\n\t\txs = (ISP_SCSI_XFER_T *) arg;\n\t\thandle = isp_find_handle(isp, xs);\n\t\tif (handle == 0) {\n\t\t\tPRINTF(\"%s: isp_control- cannot find command to abort \"\n\t\t\t    \"in active list\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tbus = XS_CHANNEL(xs);\n\t\tmbs.param[0] = MBOX_ABORT;\n\t\tif (IS_FC(isp)) {\n#ifdef\tISP2100_SCCLUN\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8;\n\t\t\tmbs.param[4] = 0;\n\t\t\tmbs.param[5] = 0;\n\t\t\tmbs.param[6] = XS_LUN(xs);\n#else\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);\n#endif\n\t\t} else {\n\t\t\tmbs.param[1] =\n\t\t\t    (bus << 15) | (XS_TGT(xs) << 8) | XS_LUN(xs);\n\t\t}\n\t\tmbs.param[3] = handle >> 16;\n\t\tmbs.param[2] = handle & 0xffff;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_ABORT failure (code %x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: command for target %d lun %d was aborted\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\treturn (0);\n\n\tcase ISPCTL_UPDATE_PARAMS:\n\t\tisp_update(isp);\n\t\treturn (0);\n\n\tcase ISPCTL_FCLINK_TEST:\n\t\treturn (isp_fclink_test(isp, FC_FW_READY_DELAY));\n\n\tcase ISPCTL_PDB_SYNC:\n\t\treturn (isp_pdb_sync(isp, -1));\n\n#ifdef\tISP_TARGET_MODE\n\tcase ISPCTL_TOGGLE_TMODE:\n\t\tif (IS_SCSI(isp)) {\n\t\t\tint ena = *(int *)arg;\n\t\t\tmbs.param[0] = MBOX_ENABLE_TARGET_MODE;\n\t\t\tmbs.param[1] = (ena)? ENABLE_TARGET_FLAG : 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: cannot %sable target mode (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, ena? \"en\" : \"dis\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (0);\n#endif\n\t}\n\treturn (-1);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_fclink_test",
            "static int isp_pdb_sync",
            "static void isp_dumpregs",
            "static void isp_mboxcmd",
            "static void isp_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_fclink_test;\nstatic int isp_pdb_sync;\nstatic void isp_dumpregs;\nstatic void isp_mboxcmd;\nstatic void isp_update;\n\nint\nisp_control(isp, ctl, arg)\n\tstruct ispsoftc *isp;\n\tispctl_t ctl;\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *xs;\n\tmbreg_t mbs;\n\tint bus, tgt;\n\tu_int32_t handle;\n\n\tswitch (ctl) {\n\tdefault:\n\t\tPRINTF(\"%s: isp_control unknown control op %x\\n\",\n\t\t    isp->isp_name, ctl);\n\t\tbreak;\n\n\tcase ISPCTL_RESET_BUS:\n\t\t/*\n\t\t * Issue a bus reset.\n\t\t */\n\t\tmbs.param[0] = MBOX_BUS_RESET;\n\t\tmbs.param[2] = 0;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tmbs.param[1] =\n\t\t\t    ((sdparam *) isp->isp_param)->isp_bus_reset_delay;\n\t\t\tif (mbs.param[1] < 2)\n\t\t\t\tmbs.param[1] = 2;\n\t\t\tbus = *((int *) arg);\n\t\t\tif (IS_DUALBUS(isp))\n\t\t\t\tmbs.param[2] = bus;\n\t\t} else {\n\t\t\tmbs.param[1] = 10;\n\t\t\tbus = 0;\n\t\t}\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"isp_control SCSI bus reset failed\");\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: driver initiated bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\treturn (0);\n\n\tcase ISPCTL_RESET_DEV:\n\t\ttgt = (*((int *) arg)) & 0xffff;\n\t\tbus = (*((int *) arg)) >> 16;\n\t\tmbs.param[0] = MBOX_ABORT_TARGET;\n\t\tmbs.param[1] = (tgt << 8) | (bus << 15);\n\t\tmbs.param[2] = 3;\t/* 'delay', in seconds */\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_RESET_DEV failure (code \"\n\t\t\t    \"%x)\\n\", isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: Target %d on Bus %d Reset Succeeded\\n\",\n\t\t    isp->isp_name, tgt, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\treturn (0);\n\n\tcase ISPCTL_ABORT_CMD:\n\t\txs = (ISP_SCSI_XFER_T *) arg;\n\t\thandle = isp_find_handle(isp, xs);\n\t\tif (handle == 0) {\n\t\t\tPRINTF(\"%s: isp_control- cannot find command to abort \"\n\t\t\t    \"in active list\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tbus = XS_CHANNEL(xs);\n\t\tmbs.param[0] = MBOX_ABORT;\n\t\tif (IS_FC(isp)) {\n#ifdef\tISP2100_SCCLUN\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8;\n\t\t\tmbs.param[4] = 0;\n\t\t\tmbs.param[5] = 0;\n\t\t\tmbs.param[6] = XS_LUN(xs);\n#else\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);\n#endif\n\t\t} else {\n\t\t\tmbs.param[1] =\n\t\t\t    (bus << 15) | (XS_TGT(xs) << 8) | XS_LUN(xs);\n\t\t}\n\t\tmbs.param[3] = handle >> 16;\n\t\tmbs.param[2] = handle & 0xffff;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_ABORT failure (code %x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: command for target %d lun %d was aborted\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\treturn (0);\n\n\tcase ISPCTL_UPDATE_PARAMS:\n\t\tisp_update(isp);\n\t\treturn (0);\n\n\tcase ISPCTL_FCLINK_TEST:\n\t\treturn (isp_fclink_test(isp, FC_FW_READY_DELAY));\n\n\tcase ISPCTL_PDB_SYNC:\n\t\treturn (isp_pdb_sync(isp, -1));\n\n#ifdef\tISP_TARGET_MODE\n\tcase ISPCTL_TOGGLE_TMODE:\n\t\tif (IS_SCSI(isp)) {\n\t\t\tint ena = *(int *)arg;\n\t\t\tmbs.param[0] = MBOX_ENABLE_TARGET_MODE;\n\t\t\tmbs.param[1] = (ena)? ENABLE_TARGET_FLAG : 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: cannot %sable target mode (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, ena? \"en\" : \"dis\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (0);\n#endif\n\t}\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_watch;\n\nstatic void\nisp_watch(arg)\n\tvoid *arg;\n{\n\tint i;\n\tstruct ispsoftc *isp = arg;\n\tstruct scsi_xfer *xs;\n\tint s;\n\n\t/*\n\t * Look for completely dead commands (but not polled ones).\n\t */\n\ts = splbio();\n\tfor (i = 0; i < isp->isp_maxcmds; i++) {\n\t\tif ((xs = (struct scsi_xfer *) isp->isp_xflist[i]) == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (xs->timeout == 0 || (xs->flags & SCSI_POLL)) {\n\t\t\tcontinue;\n\t\t}\n\t\txs->timeout -= (WATCH_INTERVAL * 1000);\n\n\t\t/*\n\t\t * Avoid later thinking that this\n\t\t * transaction is not being timed.\n\t\t * Then give ourselves to watchdog\n\t\t * periods of grace.\n\t\t */\n\t\tif (xs->timeout == 0) {\n\t\t\txs->timeout = 1;\n\t\t} else if (xs->timeout > -(2 * WATCH_INTERVAL * 1000)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (isp_control(isp, ISPCTL_ABORT_CMD, xs)) {\n\t\t\tprintf(\"%s: isp_watch failed to abort command\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tisp_restart(isp);\n\t\t\tbreak;\n\t\t}\n\t}\n        timeout(isp_watch, isp, WATCH_INTERVAL * hz);\n\tisp->isp_dogactive = 1;\n\tsplx(s);\n}"
  },
  {
    "function_name": "isp_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
    "lines": "403-422",
    "snippet": "static int\nisp_poll(isp, xs, mswait)\n\tstruct ispsoftc *isp;\n\tISP_SCSI_XFER_T *xs;\n\tint mswait;\n{\n\n\twhile (mswait) {\n\t\t/* Try the interrupt handling routine */\n\t\t(void)isp_intr((void *)isp);\n\n\t\t/* See if the xs is now done */\n\t\tif (XS_IS_CMD_DONE(xs)) {\n\t\t\treturn (0);\n\t\t}\n\t\tdelay(1000);\t/* wait one millisecond */\n\t\tmswait--;\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int isp_poll"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_IS_CMD_DONE",
          "args": [
            "xs"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_intr",
          "args": [
            "(void *)isp"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "isp_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "2284-2561",
          "snippet": "int\nisp_intr(arg)\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *complist[RESULT_QUEUE_LEN], *xs;\n\tstruct ispsoftc *isp = arg;\n\tu_int16_t iptr, optr;\n\tu_int16_t isr, isrb, sema;\n\tint i, nlooked = 0, ndone = 0;\n\n\t/*\n\t * Well, if we've disabled interrupts, we may get a case where\n\t * isr isn't set, but sema is. In any case, debounce isr reads.\n\t */\n\tdo {\n\t\tisr = ISP_READ(isp, BIU_ISR);\n\t\tisrb = ISP_READ(isp, BIU_ISR);\n\t} while (isr != isrb);\n\tsema = ISP_READ(isp, BIU_SEMA) & 0x1;\n\tIDPRINTF(5, (\"%s: isp_intr isr %x sem %x\\n\", isp->isp_name, isr, sema));\n\tif (isr == 0) {\n\t\treturn (0);\n\t}\n\tif (!INT_PENDING(isp, isr)) {\n\t\tIDPRINTF(4, (\"%s: isp_intr isr=%x\\n\", isp->isp_name, isr));\n\t\treturn (0);\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tIDPRINTF(3, (\"%s: interrupt (isr=%x,sema=%x) when not ready\\n\",\n\t\t    isp->isp_name, isr, sema));\n\t\tISP_WRITE(isp, INMAILBOX5, ISP_READ(isp, OUTMAILBOX5));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\tif (sema) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox & 0x4000) {\n\t\t\tIDPRINTF(4, (\"%s: Command Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t} else {\n\t\t\tu_int32_t fhandle = isp_parse_async(isp, (int) mbox);\n\t\t\tIDPRINTF(4, (\"%s: Async Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t\tif (fhandle > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fhandle);\n\t\t\t}\n\t\t}\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\t/*\n\t * You *must* read OUTMAILBOX5 prior to clearing the RISC interrupt.\n\t */\n\toptr = isp->isp_residx;\n\tiptr = ISP_READ(isp, OUTMAILBOX5);\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\tif (optr == iptr) {\n\t\tIDPRINTF(4, (\"why intr? isr %x iptr %x optr %x\\n\",\n\t\t    isr, optr, iptr));\n\t}\n\n\twhile (optr != iptr) {\n\t\tispstatusreq_t *sp;\n\t\tu_int16_t oop;\n\t\tint buddaboom = 0;\n\n\t\tsp = (ispstatusreq_t *) ISP_QUEUE_ENTRY(isp->isp_result, optr);\n\t\toop = optr;\n\t\toptr = ISP_NXT_QENTRY(optr, RESULT_QUEUE_LEN);\n\t\tnlooked++;\n\t\tMemoryBarrier();\n\t\t/*\n\t\t * Do any appropriate unswizzling of what the Qlogic f/w has\n\t\t * written into memory so it makes sense to us. This is a\n\t\t * per-platform thing.\n\t\t */\n\t\tISP_UNSWIZZLE_RESPONSE(isp, sp);\n\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {\n\t\t\tif (isp_handle_other_response(isp, sp, &optr) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It really has to be a bounced request just copied\n\t\t\t * from the request queue to the response queue. If\n\t\t\t * not, something bad has happened.\n\t\t\t */\n\t\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_REQUEST) {\n\t\t\t\tPRINTF(\"%s: not RESPONSE in RESPONSE Queue \"\n\t\t\t\t    \"(type 0x%x) @ idx %d (next %d)\\n\",\n\t\t\t\t    isp->isp_name,\n\t\t\t\t    sp->req_header.rqs_entry_type, oop, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbuddaboom = 1;\n\t\t}\n\n\t\tif (sp->req_header.rqs_flags & 0xf) {\n#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_CONTINUATION) {\n\t\t\t\tIDPRINTF(4, (\"%s: continuation segment\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\tIDPRINTF(2, (\"%s: internal queues full\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\t/*\n\t\t\t\t * We'll synthesize a QUEUE FULL message below.\n\t\t\t\t */\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADHEADER) {\n\t\t\t\tPRINTF(\"%s: bad header\\n\", isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADPACKET) {\n\t\t\t\tPRINTF(\"%s: bad request packet\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & _RQS_OFLAGS) {\n\t\t\t\tPRINTF(\"%s: unknown flags in response (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, sp->req_header.rqs_flags);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n#undef\t_RQS_OFLAGS\n\t\t}\n\t\tif (sp->req_handle > isp->isp_maxcmds || sp->req_handle < 1) {\n\t\t\tPRINTF(\"%s: bad request handle %d\\n\", isp->isp_name,\n\t\t\t    sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\txs = isp_find_xs(isp, sp->req_handle);\n\t\tif (xs == NULL) {\n\t\t\tPRINTF(\"%s: NULL xs in xflist (handle 0x%x)\\n\",\n\t\t\t    isp->isp_name, sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, sp->req_handle);\n\t\tif (sp->req_status_flags & RQSTF_BUS_RESET) {\n\t\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tif (buddaboom) {\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t}\n\t\tXS_STS(xs) = sp->req_scsi_status & 0xff;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data,\n\t\t\t\t\tXS_SNSLEN(xs));\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t}\n\t\t\t/*\n\t\t\t * A new synchronous rate was negotiated for this\n\t\t\t * target. Mark state such that we'll go look up\n\t\t\t * that which has changed later.\n\t\t\t */\n\t\t\tif (sp->req_status_flags & RQSTF_NEGOTIATION) {\n\t\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_refresh = 1;\n\t\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t\t}\n\t\t} else {\n\t\t\tif (sp->req_scsi_status & RQCS_SV) {\n\t\t\t\tint amt = min(XS_SNSLEN(xs), sp->req_sense_len);\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data, amt);\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t\tsp->req_state_flags |= RQSF_GOT_SENSE;\n\t\t\t} else if (XS_STS(xs) == SCSI_CHECK) {\n\t\t\t\tIDPRINTF(1, (\"%s: check condition with no sense\"\n\t\t\t\t    \" data\\n\", isp->isp_name));\n\t\t\t}\n\t\t}\n\t\tif (XS_NOERR(xs) && XS_STS(xs) == SCSI_BUSY) {\n\t\t\tXS_SETERR(xs, HBA_TGTBSY);\n\t\t}\n\n\t\tif (sp->req_header.rqs_entry_type == RQSTYPE_RESPONSE) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t    if (sp->req_completion_status != RQCS_COMPLETE) {\n\t\t\t\tisp_parse_status(isp, sp, xs);\n\t\t\t    } else {\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t    }\n\t\t\t}\n\t\t} else if (sp->req_header.rqs_entry_type == RQSTYPE_REQUEST) {\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\t/*\n\t\t\t\t * Force Queue Full status.\n\t\t\t\t */\n\t\t\t\tXS_STS(xs) = SCSI_QFULL;\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t} else if (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t} else {\n\t\t\tPRINTF(\"%s: unhandled respose queue type 0x%x\\n\",\n\t\t\t    isp->isp_name, sp->req_header.rqs_entry_type);\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t}\n\t\tif (IS_SCSI(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t} else if (sp->req_scsi_status & RQCS_RU) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t\tIDPRINTF(4, (\"%s: cnt %d rsd %d\\n\", isp->isp_name,\n\t\t\t\tXS_XFRLEN(xs), sp->req_resid));\n\t\t}\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, sp->req_handle);\n\t\t}\n\t\t/*\n\t\t * Let the platforms cope.\n\t\t */\n#if\t0\n\t\t/*\n\t\t * XXX: If we have a check condition, but no Sense Data,\n\t\t * XXX: mark it as an error (ARQ failed). We need to\n\t\t * XXX: to do a more distinct job because there may\n\t\t * XXX: cases where ARQ is disabled.\n\t\t */\n\t\tif (XS_STS(xs) == SCSI_CHECK && !(XS_IS_SNS_VALID(xs))) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tPRINTF(\"%s: ARQ failure for target %d lun %d\\n\",\n\t\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\t\t\tXS_SETERR(xs, HBA_ARQFAIL);\n\t\t\t}\n\t\t}\n#endif\n\t\tif ((isp->isp_dblev >= 5) ||\n\t\t    (isp->isp_dblev > 2 && !XS_NOERR(xs))) {\n\t\t\tPRINTF(\"%s(%d.%d): FIN dl%d resid%d STS %x\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_XFRLEN(xs), XS_RESID(xs), XS_STS(xs));\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tPRINTF(\" Skey: %x\", XS_SNSKEY(xs));\n\t\t\t\tif (!(XS_IS_SNS_VALID(xs))) {\n\t\t\t\t\tPRINTF(\" BUT NOT SET\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tPRINTF(\" XS_ERR=0x%x\\n\", (unsigned int) XS_ERR(xs));\n\t\t}\n\n\t\tif (isp->isp_nactive > 0)\n\t\t    isp->isp_nactive--;\n\t\tcomplist[ndone++] = xs;\t/* defer completion call until later */\n\t}\n\n\t/*\n\t * If we looked at any commands, then it's valid to find out\n\t * what the outpointer is. It also is a trigger to update the\n\t * ISP's notion of what we've seen so far.\n\t */\n\tif (nlooked) {\n\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\tisp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\t}\n\tisp->isp_residx = optr;\n\tfor (i = 0; i < ndone; i++) {\n\t\txs = complist[i];\n\t\tif (xs) {\n\t\t\tXS_CMD_DONE(xs);\n\t\t}\n\t}\n\tENABLE_INTS(isp);\n\treturn (1);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)"
          ],
          "globals_used": [
            "static int isp_parse_async",
            "static int isp_handle_other_response",
            "static void isp_parse_status",
            "static void isp_fastpost_complete",
            "static void isp_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)\n\nstatic int isp_parse_async;\nstatic int isp_handle_other_response;\nstatic void isp_parse_status;\nstatic void isp_fastpost_complete;\nstatic void isp_update;\n\nint\nisp_intr(arg)\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *complist[RESULT_QUEUE_LEN], *xs;\n\tstruct ispsoftc *isp = arg;\n\tu_int16_t iptr, optr;\n\tu_int16_t isr, isrb, sema;\n\tint i, nlooked = 0, ndone = 0;\n\n\t/*\n\t * Well, if we've disabled interrupts, we may get a case where\n\t * isr isn't set, but sema is. In any case, debounce isr reads.\n\t */\n\tdo {\n\t\tisr = ISP_READ(isp, BIU_ISR);\n\t\tisrb = ISP_READ(isp, BIU_ISR);\n\t} while (isr != isrb);\n\tsema = ISP_READ(isp, BIU_SEMA) & 0x1;\n\tIDPRINTF(5, (\"%s: isp_intr isr %x sem %x\\n\", isp->isp_name, isr, sema));\n\tif (isr == 0) {\n\t\treturn (0);\n\t}\n\tif (!INT_PENDING(isp, isr)) {\n\t\tIDPRINTF(4, (\"%s: isp_intr isr=%x\\n\", isp->isp_name, isr));\n\t\treturn (0);\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tIDPRINTF(3, (\"%s: interrupt (isr=%x,sema=%x) when not ready\\n\",\n\t\t    isp->isp_name, isr, sema));\n\t\tISP_WRITE(isp, INMAILBOX5, ISP_READ(isp, OUTMAILBOX5));\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\tif (sema) {\n\t\tu_int16_t mbox = ISP_READ(isp, OUTMAILBOX0);\n\t\tif (mbox & 0x4000) {\n\t\t\tIDPRINTF(4, (\"%s: Command Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t} else {\n\t\t\tu_int32_t fhandle = isp_parse_async(isp, (int) mbox);\n\t\t\tIDPRINTF(4, (\"%s: Async Mbox 0x%x\\n\",\n\t\t\t    isp->isp_name, mbox));\n\t\t\tif (fhandle > 0) {\n\t\t\t\tisp_fastpost_complete(isp, fhandle);\n\t\t\t}\n\t\t}\n\t\tISP_WRITE(isp, BIU_SEMA, 0);\n\t\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\t\tENABLE_INTS(isp);\n\t\treturn (1);\n\t}\n\n\t/*\n\t * You *must* read OUTMAILBOX5 prior to clearing the RISC interrupt.\n\t */\n\toptr = isp->isp_residx;\n\tiptr = ISP_READ(isp, OUTMAILBOX5);\n\tISP_WRITE(isp, HCCR, HCCR_CMD_CLEAR_RISC_INT);\n\tif (optr == iptr) {\n\t\tIDPRINTF(4, (\"why intr? isr %x iptr %x optr %x\\n\",\n\t\t    isr, optr, iptr));\n\t}\n\n\twhile (optr != iptr) {\n\t\tispstatusreq_t *sp;\n\t\tu_int16_t oop;\n\t\tint buddaboom = 0;\n\n\t\tsp = (ispstatusreq_t *) ISP_QUEUE_ENTRY(isp->isp_result, optr);\n\t\toop = optr;\n\t\toptr = ISP_NXT_QENTRY(optr, RESULT_QUEUE_LEN);\n\t\tnlooked++;\n\t\tMemoryBarrier();\n\t\t/*\n\t\t * Do any appropriate unswizzling of what the Qlogic f/w has\n\t\t * written into memory so it makes sense to us. This is a\n\t\t * per-platform thing.\n\t\t */\n\t\tISP_UNSWIZZLE_RESPONSE(isp, sp);\n\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_RESPONSE) {\n\t\t\tif (isp_handle_other_response(isp, sp, &optr) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It really has to be a bounced request just copied\n\t\t\t * from the request queue to the response queue. If\n\t\t\t * not, something bad has happened.\n\t\t\t */\n\t\t\tif (sp->req_header.rqs_entry_type != RQSTYPE_REQUEST) {\n\t\t\t\tPRINTF(\"%s: not RESPONSE in RESPONSE Queue \"\n\t\t\t\t    \"(type 0x%x) @ idx %d (next %d)\\n\",\n\t\t\t\t    isp->isp_name,\n\t\t\t\t    sp->req_header.rqs_entry_type, oop, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbuddaboom = 1;\n\t\t}\n\n\t\tif (sp->req_header.rqs_flags & 0xf) {\n#define\t_RQS_OFLAGS\t\\\n\t~(RQSFLAG_CONTINUATION|RQSFLAG_FULL|RQSFLAG_BADHEADER|RQSFLAG_BADPACKET)\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_CONTINUATION) {\n\t\t\t\tIDPRINTF(4, (\"%s: continuation segment\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\tIDPRINTF(2, (\"%s: internal queues full\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\t/*\n\t\t\t\t * We'll synthesize a QUEUE FULL message below.\n\t\t\t\t */\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADHEADER) {\n\t\t\t\tPRINTF(\"%s: bad header\\n\", isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_BADPACKET) {\n\t\t\t\tPRINTF(\"%s: bad request packet\\n\",\n\t\t\t\t    isp->isp_name);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n\t\t\tif (sp->req_header.rqs_flags & _RQS_OFLAGS) {\n\t\t\t\tPRINTF(\"%s: unknown flags in response (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, sp->req_header.rqs_flags);\n\t\t\t\tbuddaboom++;\n\t\t\t}\n#undef\t_RQS_OFLAGS\n\t\t}\n\t\tif (sp->req_handle > isp->isp_maxcmds || sp->req_handle < 1) {\n\t\t\tPRINTF(\"%s: bad request handle %d\\n\", isp->isp_name,\n\t\t\t    sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\txs = isp_find_xs(isp, sp->req_handle);\n\t\tif (xs == NULL) {\n\t\t\tPRINTF(\"%s: NULL xs in xflist (handle 0x%x)\\n\",\n\t\t\t    isp->isp_name, sp->req_handle);\n\t\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, sp->req_handle);\n\t\tif (sp->req_status_flags & RQSTF_BUS_RESET) {\n\t\t\tisp->isp_sendmarker |= (1 << XS_CHANNEL(xs));\n\t\t}\n\t\tif (buddaboom) {\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t}\n\t\tXS_STS(xs) = sp->req_scsi_status & 0xff;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data,\n\t\t\t\t\tXS_SNSLEN(xs));\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t}\n\t\t\t/*\n\t\t\t * A new synchronous rate was negotiated for this\n\t\t\t * target. Mark state such that we'll go look up\n\t\t\t * that which has changed later.\n\t\t\t */\n\t\t\tif (sp->req_status_flags & RQSTF_NEGOTIATION) {\n\t\t\t\tsdparam *sdp = isp->isp_param;\n\t\t\t\tsdp += XS_CHANNEL(xs);\n\t\t\t\tsdp->isp_devparam[XS_TGT(xs)].dev_refresh = 1;\n\t\t\t\tisp->isp_update |= (1 << XS_CHANNEL(xs));\n\t\t\t}\n\t\t} else {\n\t\t\tif (sp->req_scsi_status & RQCS_SV) {\n\t\t\t\tint amt = min(XS_SNSLEN(xs), sp->req_sense_len);\n\t\t\t\tMEMCPY(XS_SNSP(xs), sp->req_sense_data, amt);\n\t\t\t\tXS_SNS_IS_VALID(xs);\n\t\t\t\tsp->req_state_flags |= RQSF_GOT_SENSE;\n\t\t\t} else if (XS_STS(xs) == SCSI_CHECK) {\n\t\t\t\tIDPRINTF(1, (\"%s: check condition with no sense\"\n\t\t\t\t    \" data\\n\", isp->isp_name));\n\t\t\t}\n\t\t}\n\t\tif (XS_NOERR(xs) && XS_STS(xs) == SCSI_BUSY) {\n\t\t\tXS_SETERR(xs, HBA_TGTBSY);\n\t\t}\n\n\t\tif (sp->req_header.rqs_entry_type == RQSTYPE_RESPONSE) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t    if (sp->req_completion_status != RQCS_COMPLETE) {\n\t\t\t\tisp_parse_status(isp, sp, xs);\n\t\t\t    } else {\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t    }\n\t\t\t}\n\t\t} else if (sp->req_header.rqs_entry_type == RQSTYPE_REQUEST) {\n\t\t\tif (sp->req_header.rqs_flags & RQSFLAG_FULL) {\n\t\t\t\t/*\n\t\t\t\t * Force Queue Full status.\n\t\t\t\t */\n\t\t\t\tXS_STS(xs) = SCSI_QFULL;\n\t\t\t\tXS_SETERR(xs, HBA_NOERROR);\n\t\t\t} else if (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t} else {\n\t\t\tPRINTF(\"%s: unhandled respose queue type 0x%x\\n\",\n\t\t\t    isp->isp_name, sp->req_header.rqs_entry_type);\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t}\n\t\t}\n\t\tif (IS_SCSI(isp)) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t} else if (sp->req_scsi_status & RQCS_RU) {\n\t\t\tXS_RESID(xs) = sp->req_resid;\n\t\t\tIDPRINTF(4, (\"%s: cnt %d rsd %d\\n\", isp->isp_name,\n\t\t\t\tXS_XFRLEN(xs), sp->req_resid));\n\t\t}\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, sp->req_handle);\n\t\t}\n\t\t/*\n\t\t * Let the platforms cope.\n\t\t */\n#if\t0\n\t\t/*\n\t\t * XXX: If we have a check condition, but no Sense Data,\n\t\t * XXX: mark it as an error (ARQ failed). We need to\n\t\t * XXX: to do a more distinct job because there may\n\t\t * XXX: cases where ARQ is disabled.\n\t\t */\n\t\tif (XS_STS(xs) == SCSI_CHECK && !(XS_IS_SNS_VALID(xs))) {\n\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\tPRINTF(\"%s: ARQ failure for target %d lun %d\\n\",\n\t\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\t\t\tXS_SETERR(xs, HBA_ARQFAIL);\n\t\t\t}\n\t\t}\n#endif\n\t\tif ((isp->isp_dblev >= 5) ||\n\t\t    (isp->isp_dblev > 2 && !XS_NOERR(xs))) {\n\t\t\tPRINTF(\"%s(%d.%d): FIN dl%d resid%d STS %x\",\n\t\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs),\n\t\t\t    XS_XFRLEN(xs), XS_RESID(xs), XS_STS(xs));\n\t\t\tif (sp->req_state_flags & RQSF_GOT_SENSE) {\n\t\t\t\tPRINTF(\" Skey: %x\", XS_SNSKEY(xs));\n\t\t\t\tif (!(XS_IS_SNS_VALID(xs))) {\n\t\t\t\t\tPRINTF(\" BUT NOT SET\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tPRINTF(\" XS_ERR=0x%x\\n\", (unsigned int) XS_ERR(xs));\n\t\t}\n\n\t\tif (isp->isp_nactive > 0)\n\t\t    isp->isp_nactive--;\n\t\tcomplist[ndone++] = xs;\t/* defer completion call until later */\n\t}\n\n\t/*\n\t * If we looked at any commands, then it's valid to find out\n\t * what the outpointer is. It also is a trigger to update the\n\t * ISP's notion of what we've seen so far.\n\t */\n\tif (nlooked) {\n\t\tISP_WRITE(isp, INMAILBOX5, optr);\n\t\tisp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\t}\n\tisp->isp_residx = optr;\n\tfor (i = 0; i < ndone; i++) {\n\t\txs = complist[i];\n\t\tif (xs) {\n\t\t\tXS_CMD_DONE(xs);\n\t\t}\n\t}\n\tENABLE_INTS(isp);\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic int isp_poll;\n\nstatic int\nisp_poll(isp, xs, mswait)\n\tstruct ispsoftc *isp;\n\tISP_SCSI_XFER_T *xs;\n\tint mswait;\n{\n\n\twhile (mswait) {\n\t\t/* Try the interrupt handling routine */\n\t\t(void)isp_intr((void *)isp);\n\n\t\t/* See if the xs is now done */\n\t\tif (XS_IS_CMD_DONE(xs)) {\n\t\t\treturn (0);\n\t\t}\n\t\tdelay(1000);\t/* wait one millisecond */\n\t\tmswait--;\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "ispcmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
    "lines": "294-401",
    "snippet": "static int32_t\nispcmd(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tstruct ispsoftc *isp;\n\tint result;\n\tint s;\n\n\tisp = xs->sc_link->adapter_softc;\n\ts = splbio();\n\n\tif (isp->isp_state < ISP_RUNSTATE) {\n\t\tDISABLE_INTS(isp);\n\t\tisp_init(isp);\n\t\tif (isp->isp_state != ISP_INITSTATE) {\n\t\t\tENABLE_INTS(isp);\n\t\t\t(void) splx(s);\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\tisp->isp_state = ISP_RUNSTATE;\n\t\tENABLE_INTS(isp);\n\t}\n\n\t/*\n\t * Check for queue blockage...\n\t */\n\tif (isp->isp_osinfo.blocked) {\n\t\tIDPRINTF(2, (\"%s: blocked\\n\", isp->isp_name));\n\t\tif (xs->flags & SCSI_POLL) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\tif (isp->isp_osinfo.wqf != NULL) {\n\t\t\tisp->isp_osinfo.wqt->free_list.le_next = xs;\n\t\t} else {\n\t\t\tisp->isp_osinfo.wqf = xs;\n\t\t}\n\t\tisp->isp_osinfo.wqt = xs;\n\t\txs->free_list.le_next = NULL;\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tDISABLE_INTS(isp);\n\tresult = ispscsicmd(xs);\n\tENABLE_INTS(isp);\n\n\tif ((xs->flags & SCSI_POLL) == 0) {\n\t\tswitch (result) {\n\t\tcase CMD_QUEUED:\n\t\t\tresult = SUCCESSFULLY_QUEUED;\n\t\t\tbreak;\n\t\tcase CMD_EAGAIN:\n\t\t\tresult = TRY_AGAIN_LATER;\n\t\t\tbreak;\n\t\tcase CMD_RQLATER:\n\t\t\tresult = SUCCESSFULLY_QUEUED;\n\t\t\ttimeout(isp_command_requeue, xs, hz);\n\t\t\tbreak;\n\t\tcase CMD_COMPLETE:\n\t\t\tresult = COMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\t(void) splx(s);\n\t\treturn (result);\n\t}\n\n\tswitch (result) {\n\tcase CMD_QUEUED:\n\t\tresult = SUCCESSFULLY_QUEUED;\n\t\tbreak;\n\tcase CMD_RQLATER:\n\tcase CMD_EAGAIN:\n\t\tif (XS_NOERR(xs)) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t}\n\t\tresult = TRY_AGAIN_LATER;\n\t\tbreak;\n\tcase CMD_COMPLETE:\n\t\tresult = COMPLETE;\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * We can't use interrupts so poll on completion.\n\t */\n\tif (result == SUCCESSFULLY_QUEUED) {\n\t\tif (isp_poll(isp, xs, xs->timeout)) {\n\t\t\t/*\n\t\t\t * If no other error occurred but we didn't finish,\n\t\t\t * something bad happened.\n\t\t\t */\n\t\t\tif (XS_IS_CMD_DONE(xs) == 0) {\n\t\t\t\tif (isp_control(isp, ISPCTL_ABORT_CMD, xs)) {\n\t\t\t\t\tisp_restart(isp);\n\t\t\t\t}\n\t\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult = COMPLETE;\n\t}\n\t(void) splx(s);\n\treturn (result);\n}",
    "includes": [
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int32_t ispcmd",
      "static int isp_poll",
      "static void isp_command_requeue(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_NOERR",
          "args": [
            "xs"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_restart",
          "args": [
            "isp"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "isp_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "4063-4100",
          "snippet": "void\nisp_restart(isp)\n\tstruct ispsoftc *isp;\n{\n\tISP_SCSI_XFER_T *xs;\n\tu_int32_t handle;\n\n#if\t0\n\tisp->isp_gotdparms = 0;\n#endif\n\tisp_reset(isp);\n\tif (isp->isp_state == ISP_RESETSTATE) {\n\t\tisp_init(isp);\n\t\tif (isp->isp_state == ISP_INITSTATE) {\n\t\t\tisp->isp_state = ISP_RUNSTATE;\n\t\t}\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: isp_restart cannot restart ISP\\n\", isp->isp_name);\n\t}\n\tisp->isp_nactive = 0;\n\n\tfor (handle = 1; handle <= (int) isp->isp_maxcmds; handle++) {\n\t\txs = isp_find_xs(isp, handle);\n\t\tif (xs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, handle);\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, handle);\n\t\t\tXS_RESID(xs) = XS_XFRLEN(xs);\n\t\t} else {\n\t\t\tXS_RESID(xs) = 0;\n\t\t}\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\tXS_CMD_DONE(xs);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nvoid\nisp_restart(isp)\n\tstruct ispsoftc *isp;\n{\n\tISP_SCSI_XFER_T *xs;\n\tu_int32_t handle;\n\n#if\t0\n\tisp->isp_gotdparms = 0;\n#endif\n\tisp_reset(isp);\n\tif (isp->isp_state == ISP_RESETSTATE) {\n\t\tisp_init(isp);\n\t\tif (isp->isp_state == ISP_INITSTATE) {\n\t\t\tisp->isp_state = ISP_RUNSTATE;\n\t\t}\n\t}\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: isp_restart cannot restart ISP\\n\", isp->isp_name);\n\t}\n\tisp->isp_nactive = 0;\n\n\tfor (handle = 1; handle <= (int) isp->isp_maxcmds; handle++) {\n\t\txs = isp_find_xs(isp, handle);\n\t\tif (xs == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tisp_destroy_handle(isp, handle);\n\t\tif (XS_XFRLEN(xs)) {\n\t\t\tISP_DMAFREE(isp, xs, handle);\n\t\t\tXS_RESID(xs) = XS_XFRLEN(xs);\n\t\t} else {\n\t\t\tXS_RESID(xs) = 0;\n\t\t}\n\t\tXS_SETERR(xs, HBA_BUSRESET);\n\t\tXS_CMD_DONE(xs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_control",
          "args": [
            "isp",
            "ISPCTL_ABORT_CMD",
            "xs"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "isp_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "2150-2275",
          "snippet": "int\nisp_control(isp, ctl, arg)\n\tstruct ispsoftc *isp;\n\tispctl_t ctl;\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *xs;\n\tmbreg_t mbs;\n\tint bus, tgt;\n\tu_int32_t handle;\n\n\tswitch (ctl) {\n\tdefault:\n\t\tPRINTF(\"%s: isp_control unknown control op %x\\n\",\n\t\t    isp->isp_name, ctl);\n\t\tbreak;\n\n\tcase ISPCTL_RESET_BUS:\n\t\t/*\n\t\t * Issue a bus reset.\n\t\t */\n\t\tmbs.param[0] = MBOX_BUS_RESET;\n\t\tmbs.param[2] = 0;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tmbs.param[1] =\n\t\t\t    ((sdparam *) isp->isp_param)->isp_bus_reset_delay;\n\t\t\tif (mbs.param[1] < 2)\n\t\t\t\tmbs.param[1] = 2;\n\t\t\tbus = *((int *) arg);\n\t\t\tif (IS_DUALBUS(isp))\n\t\t\t\tmbs.param[2] = bus;\n\t\t} else {\n\t\t\tmbs.param[1] = 10;\n\t\t\tbus = 0;\n\t\t}\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"isp_control SCSI bus reset failed\");\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: driver initiated bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\treturn (0);\n\n\tcase ISPCTL_RESET_DEV:\n\t\ttgt = (*((int *) arg)) & 0xffff;\n\t\tbus = (*((int *) arg)) >> 16;\n\t\tmbs.param[0] = MBOX_ABORT_TARGET;\n\t\tmbs.param[1] = (tgt << 8) | (bus << 15);\n\t\tmbs.param[2] = 3;\t/* 'delay', in seconds */\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_RESET_DEV failure (code \"\n\t\t\t    \"%x)\\n\", isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: Target %d on Bus %d Reset Succeeded\\n\",\n\t\t    isp->isp_name, tgt, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\treturn (0);\n\n\tcase ISPCTL_ABORT_CMD:\n\t\txs = (ISP_SCSI_XFER_T *) arg;\n\t\thandle = isp_find_handle(isp, xs);\n\t\tif (handle == 0) {\n\t\t\tPRINTF(\"%s: isp_control- cannot find command to abort \"\n\t\t\t    \"in active list\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tbus = XS_CHANNEL(xs);\n\t\tmbs.param[0] = MBOX_ABORT;\n\t\tif (IS_FC(isp)) {\n#ifdef\tISP2100_SCCLUN\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8;\n\t\t\tmbs.param[4] = 0;\n\t\t\tmbs.param[5] = 0;\n\t\t\tmbs.param[6] = XS_LUN(xs);\n#else\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);\n#endif\n\t\t} else {\n\t\t\tmbs.param[1] =\n\t\t\t    (bus << 15) | (XS_TGT(xs) << 8) | XS_LUN(xs);\n\t\t}\n\t\tmbs.param[3] = handle >> 16;\n\t\tmbs.param[2] = handle & 0xffff;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_ABORT failure (code %x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: command for target %d lun %d was aborted\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\treturn (0);\n\n\tcase ISPCTL_UPDATE_PARAMS:\n\t\tisp_update(isp);\n\t\treturn (0);\n\n\tcase ISPCTL_FCLINK_TEST:\n\t\treturn (isp_fclink_test(isp, FC_FW_READY_DELAY));\n\n\tcase ISPCTL_PDB_SYNC:\n\t\treturn (isp_pdb_sync(isp, -1));\n\n#ifdef\tISP_TARGET_MODE\n\tcase ISPCTL_TOGGLE_TMODE:\n\t\tif (IS_SCSI(isp)) {\n\t\t\tint ena = *(int *)arg;\n\t\t\tmbs.param[0] = MBOX_ENABLE_TARGET_MODE;\n\t\t\tmbs.param[1] = (ena)? ENABLE_TARGET_FLAG : 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: cannot %sable target mode (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, ena? \"en\" : \"dis\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (0);\n#endif\n\t}\n\treturn (-1);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_fclink_test",
            "static int isp_pdb_sync",
            "static void isp_dumpregs",
            "static void isp_mboxcmd",
            "static void isp_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_fclink_test;\nstatic int isp_pdb_sync;\nstatic void isp_dumpregs;\nstatic void isp_mboxcmd;\nstatic void isp_update;\n\nint\nisp_control(isp, ctl, arg)\n\tstruct ispsoftc *isp;\n\tispctl_t ctl;\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *xs;\n\tmbreg_t mbs;\n\tint bus, tgt;\n\tu_int32_t handle;\n\n\tswitch (ctl) {\n\tdefault:\n\t\tPRINTF(\"%s: isp_control unknown control op %x\\n\",\n\t\t    isp->isp_name, ctl);\n\t\tbreak;\n\n\tcase ISPCTL_RESET_BUS:\n\t\t/*\n\t\t * Issue a bus reset.\n\t\t */\n\t\tmbs.param[0] = MBOX_BUS_RESET;\n\t\tmbs.param[2] = 0;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tmbs.param[1] =\n\t\t\t    ((sdparam *) isp->isp_param)->isp_bus_reset_delay;\n\t\t\tif (mbs.param[1] < 2)\n\t\t\t\tmbs.param[1] = 2;\n\t\t\tbus = *((int *) arg);\n\t\t\tif (IS_DUALBUS(isp))\n\t\t\t\tmbs.param[2] = bus;\n\t\t} else {\n\t\t\tmbs.param[1] = 10;\n\t\t\tbus = 0;\n\t\t}\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"isp_control SCSI bus reset failed\");\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: driver initiated bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\treturn (0);\n\n\tcase ISPCTL_RESET_DEV:\n\t\ttgt = (*((int *) arg)) & 0xffff;\n\t\tbus = (*((int *) arg)) >> 16;\n\t\tmbs.param[0] = MBOX_ABORT_TARGET;\n\t\tmbs.param[1] = (tgt << 8) | (bus << 15);\n\t\tmbs.param[2] = 3;\t/* 'delay', in seconds */\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_RESET_DEV failure (code \"\n\t\t\t    \"%x)\\n\", isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: Target %d on Bus %d Reset Succeeded\\n\",\n\t\t    isp->isp_name, tgt, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\treturn (0);\n\n\tcase ISPCTL_ABORT_CMD:\n\t\txs = (ISP_SCSI_XFER_T *) arg;\n\t\thandle = isp_find_handle(isp, xs);\n\t\tif (handle == 0) {\n\t\t\tPRINTF(\"%s: isp_control- cannot find command to abort \"\n\t\t\t    \"in active list\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tbus = XS_CHANNEL(xs);\n\t\tmbs.param[0] = MBOX_ABORT;\n\t\tif (IS_FC(isp)) {\n#ifdef\tISP2100_SCCLUN\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8;\n\t\t\tmbs.param[4] = 0;\n\t\t\tmbs.param[5] = 0;\n\t\t\tmbs.param[6] = XS_LUN(xs);\n#else\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);\n#endif\n\t\t} else {\n\t\t\tmbs.param[1] =\n\t\t\t    (bus << 15) | (XS_TGT(xs) << 8) | XS_LUN(xs);\n\t\t}\n\t\tmbs.param[3] = handle >> 16;\n\t\tmbs.param[2] = handle & 0xffff;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_ABORT failure (code %x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: command for target %d lun %d was aborted\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\treturn (0);\n\n\tcase ISPCTL_UPDATE_PARAMS:\n\t\tisp_update(isp);\n\t\treturn (0);\n\n\tcase ISPCTL_FCLINK_TEST:\n\t\treturn (isp_fclink_test(isp, FC_FW_READY_DELAY));\n\n\tcase ISPCTL_PDB_SYNC:\n\t\treturn (isp_pdb_sync(isp, -1));\n\n#ifdef\tISP_TARGET_MODE\n\tcase ISPCTL_TOGGLE_TMODE:\n\t\tif (IS_SCSI(isp)) {\n\t\t\tint ena = *(int *)arg;\n\t\t\tmbs.param[0] = MBOX_ENABLE_TARGET_MODE;\n\t\t\tmbs.param[1] = (ena)? ENABLE_TARGET_FLAG : 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: cannot %sable target mode (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, ena? \"en\" : \"dis\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (0);\n#endif\n\t}\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_IS_CMD_DONE",
          "args": [
            "xs"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_poll",
          "args": [
            "isp",
            "xs",
            "xs->timeout"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "isp_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "403-422",
          "snippet": "static int\nisp_poll(isp, xs, mswait)\n\tstruct ispsoftc *isp;\n\tISP_SCSI_XFER_T *xs;\n\tint mswait;\n{\n\n\twhile (mswait) {\n\t\t/* Try the interrupt handling routine */\n\t\t(void)isp_intr((void *)isp);\n\n\t\t/* See if the xs is now done */\n\t\tif (XS_IS_CMD_DONE(xs)) {\n\t\t\treturn (0);\n\t\t}\n\t\tdelay(1000);\t/* wait one millisecond */\n\t\tmswait--;\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_poll"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic int isp_poll;\n\nstatic int\nisp_poll(isp, xs, mswait)\n\tstruct ispsoftc *isp;\n\tISP_SCSI_XFER_T *xs;\n\tint mswait;\n{\n\n\twhile (mswait) {\n\t\t/* Try the interrupt handling routine */\n\t\t(void)isp_intr((void *)isp);\n\n\t\t/* See if the xs is now done */\n\t\tif (XS_IS_CMD_DONE(xs)) {\n\t\t\treturn (0);\n\t\t}\n\t\tdelay(1000);\t/* wait one millisecond */\n\t\tmswait--;\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_NOERR",
          "args": [
            "xs"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "isp_command_requeue",
            "xs",
            "hz"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ENABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ispscsicmd",
          "args": [
            "xs"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ispscsicmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "1862-2143",
          "snippet": "int32_t\nispscsicmd(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tstruct ispsoftc *isp;\n\tu_int16_t iptr, optr;\n\tunion {\n\t\tispreq_t *_reqp;\n\t\tispreqt2_t *_t2reqp;\n\t} _u;\n#define\treqp\t_u._reqp\n#define\tt2reqp\t_u._t2reqp\n#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))\n\tint target, i;\n\n\tXS_INITERR(xs);\n\tisp = XS_ISP(xs);\n\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: adapter not ready\\n\", isp->isp_name);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check command CDB length, etc.. We really are limited to 16 bytes\n\t * for Fibre Channel, but can do up to 44 bytes in parallel SCSI,\n\t * but probably only if we're running fairly new firmware (we'll\n\t * let the old f/w choke on an extended command queue entry).\n\t */\n\n\tif (XS_CDBLEN(xs) > (IS_FC(isp)? 16 : 44) || XS_CDBLEN(xs) == 0) {\n\t\tPRINTF(\"%s: unsupported cdb length (%d, CDB[0]=0x%x)\\n\",\n\t\t    isp->isp_name, XS_CDBLEN(xs), XS_CDBP(xs)[0] & 0xff);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check to see whether we have good firmware state still or\n\t * need to refresh our port database for this target.\n\t */\n\ttarget = XS_TGT(xs);\n\tif (IS_FC(isp)) {\n\t\tfcparam *fcp = isp->isp_param;\n\t\tstruct lportdb *lp;\n#if\tdefined(ISP2100_FABRIC)\n\t\t/*\n\t\t * If we're not on a Fabric, we can't have a target\n\t\t * above FL_PORT_ID-1. If we're on a fabric and\n\t\t * connected as an F-port, we can't have a target\n\t\t * less than FC_SNS_ID+1.\n\t\t */\n\t\tif (fcp->isp_onfabric == 0) {\n\t\t\tif (target >= FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (target >= FL_PORT_ID && target <= FC_SNS_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t\tif (fcp->isp_topo == TOPO_F_PORT &&\n\t\t\t    target < FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n#endif\n\t\t/*\n\t\t * Check for f/w being in ready state. If the f/w\n\t\t * isn't in ready state, then we don't know our\n\t\t * loop ID and the f/w hasn't completed logging\n\t\t * into all targets on the loop. If this is the\n\t\t * case, then bounce the command. We pretend this is\n\t\t * a SELECTION TIMEOUT error if we've never gone to\n\t\t * FW_READY state at all- in this case we may not\n\t\t * be hooked to a loop at all and we shouldn't hang\n\t\t * the machine for this. Otherwise, defer this command\n\t\t * until later.\n\t\t */\n\t\tif (fcp->isp_fwstate != FW_READY) {\n\t\t\tif (isp_fclink_test(isp, FC_FW_READY_DELAY)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\t\treturn (CMD_RQLATER);\n\t\t\t\t} else {\n\t\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is such that we haven't yet received\n\t\t * a \"Port Database Changed\" notification (after a LIP or\n\t\t * a Loop Reset or firmware initialization), then defer\n\t\t * sending commands for a little while, but only if we've\n\t\t * seen a valid loop at one point (otherwise we can get\n\t\t * stuck at initialization time).\n\t\t */\n\t\tif (fcp->isp_loopstate < LOOP_PDB_RCVD) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\treturn (CMD_RQLATER);\n\t\t\t} else {\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is now such that we've just now\n\t\t * received a Port Database Change notification, then\n\t\t * we have to go off and (re)synchronize our port\n\t\t * database.\n\t\t */\n\t\tif (fcp->isp_loopstate == LOOP_PDB_RCVD) {\n\t\t\tif (isp_pdb_sync(isp, target)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Now check whether we should even think about pursuing this.\n\t\t */\n\t\tlp = &fcp->portdb[target];\n\t\tif (lp->valid == 0) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\tif ((lp->roles & (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT)) == 0) {\n\t\t\tIDPRINTF(3, (\"%s: target %d is not a target\\n\",\n\t\t\t    isp->isp_name, target));\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\t/*\n\t\t * Now turn target into what the actual loop ID is.\n\t\t */\n\t\ttarget = lp->loopid;\n\t}\n\n\t/*\n\t * Next check to see if any HBA or Device\n\t * parameters need to be updated.\n\t */\n\tif (isp->isp_update != 0) {\n\t\tisp_update(isp);\n\t}\n\n\tif (isp_getrqentry(isp, &iptr, &optr, (void **) &reqp)) {\n\t\tIDPRINTF(1, (\"%s: Request Queue Overflow\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\n\t/*\n\t * Now see if we need to synchronize the ISP with respect to anything.\n\t * We do dual duty here (cough) for synchronizing for busses other\n\t * than which we got here to send a command to.\n\t */\n\tif (isp->isp_sendmarker) {\n\t\tu_int8_t n = (IS_DUALBUS(isp)? 2: 1);\n\t\t/*\n\t\t * Check ports to send markers for...\n\t\t */\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif ((isp->isp_sendmarker & (1 << i)) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tMEMZERO((void *) reqp, sizeof (*reqp));\n\t\t\treqp->req_header.rqs_entry_count = 1;\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_MARKER;\n\t\t\treqp->req_modifier = SYNC_ALL;\n\t\t\treqp->req_target = i << 7;\t/* insert bus number */\n\t\t\tISP_SWIZZLE_REQUEST(isp, reqp);\n\t\t\tMemoryBarrier();\n\t\t\tISP_ADD_REQUEST(isp, iptr);\n\n\t\t\tif (isp_getrqentry(isp, &iptr, &optr, (void **)&reqp)) {\n\t\t\t\tIDPRINTF(1, (\"%s: Request Queue Overflow+\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t\treturn (CMD_EAGAIN);\n\t\t\t}\n\t\t}\n\t}\n\n\tMEMZERO((void *) reqp, UZSIZE);\n\treqp->req_header.rqs_entry_count = 1;\n\tif (IS_FC(isp)) {\n\t\treqp->req_header.rqs_entry_type = RQSTYPE_T2RQS;\n\t} else {\n\t\tif (XS_CDBLEN(xs) > 12)\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_CMDONLY;\n\t\telse\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_REQUEST;\n\t}\n\treqp->req_header.rqs_flags = 0;\n\treqp->req_header.rqs_seqno = 0;\n\tif (IS_FC(isp)) {\n\t\t/*\n\t\t * See comment in isp_intr\n\t\t */\n\t\tXS_RESID(xs) = 0;\n\n\t\t/*\n\t\t * Fibre Channel always requires some kind of tag.\n\t\t * The Qlogic drivers seem be happy not to use a tag,\n\t\t * but this breaks for some devices (IBM drives).\n\t\t */\n\t\tif (XS_CANTAG(xs)) {\n\t\t\tt2reqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t} else {\n\t\t\tif (XS_CDBP(xs)[0] == 0x3)\t/* REQUEST SENSE */\n\t\t\t\tt2reqp->req_flags = REQFLAG_HTAG;\n\t\t\telse\n\t\t\t\tt2reqp->req_flags = REQFLAG_OTAG;\n\t\t}\n\t} else {\n\t\tsdparam *sdp = (sdparam *)isp->isp_param;\n\t\tif ((sdp->isp_devparam[target].cur_dflags & DPARM_TQING) &&\n\t\t    XS_CANTAG(xs)) {\n\t\t\treqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t}\n\t}\n\treqp->req_target = target | (XS_CHANNEL(xs) << 7);\n\tif (IS_SCSI(isp)) {\n\t\treqp->req_lun_trn = XS_LUN(xs);\n\t\treqp->req_cdblen = XS_CDBLEN(xs);\n\t} else {\n#ifdef\tISP2100_SCCLUN\n\t\tt2reqp->req_scclun = XS_LUN(xs);\n#else\n\t\tt2reqp->req_lun_trn = XS_LUN(xs);\n#endif\n\t}\n\tMEMCPY(reqp->req_cdb, XS_CDBP(xs), XS_CDBLEN(xs));\n\n\treqp->req_time = XS_TIME(xs) / 1000;\n\tif (reqp->req_time == 0 && XS_TIME(xs))\n\t\treqp->req_time = 1;\n\n\t/*\n\t * Always give a bit more leeway to commands after a bus reset.\n\t * XXX: DOES NOT DISTINGUISH WHICH PORT MAY HAVE BEEN SYNCED\n\t */\n\tif (isp->isp_sendmarker && reqp->req_time < 5) {\n\t\treqp->req_time = 5;\n\t}\n\tif (isp_save_xs(isp, xs, &reqp->req_handle)) {\n\t\tIDPRINTF(2, (\"%s: out of xflist pointers\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\t/*\n\t * Set up DMA and/or do any bus swizzling of the request entry\n\t * so that the Qlogic F/W understands what is being asked of it.\n \t*/\n\ti = ISP_DMASETUP(isp, xs, reqp, &iptr, optr);\n\tif (i != CMD_QUEUED) {\n\t\tisp_destroy_handle(isp, reqp->req_handle);\n\t\t/*\n\t\t * dmasetup sets actual error in packet, and\n\t\t * return what we were given to return.\n\t\t */\n\t\treturn (i);\n\t}\n\tXS_SETERR(xs, HBA_NOERROR);\n\tIDPRINTF(5, (\"%s(%d.%d.%d): START cmd 0x%x datalen %d\\n\",\n\t    isp->isp_name, XS_CHANNEL(xs), target, XS_LUN(xs),\n\t    reqp->req_cdb[0], XS_XFRLEN(xs)));\n\tMemoryBarrier();\n\tISP_ADD_REQUEST(isp, iptr);\n\tisp->isp_nactive++;\n\tif (isp->isp_sendmarker)\n\t\tisp->isp_sendmarker = 0;\n\treturn (CMD_QUEUED);\n#undef\treqp\n#undef\tt2reqp\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [
            "#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))",
            "#define\tt2reqp\t_u._t2reqp",
            "#define\treqp\t_u._reqp"
          ],
          "globals_used": [
            "static int isp_fclink_test",
            "static int isp_pdb_sync",
            "static void isp_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))\n#define\tt2reqp\t_u._t2reqp\n#define\treqp\t_u._reqp\n\nstatic int isp_fclink_test;\nstatic int isp_pdb_sync;\nstatic void isp_update;\n\nint32_t\nispscsicmd(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tstruct ispsoftc *isp;\n\tu_int16_t iptr, optr;\n\tunion {\n\t\tispreq_t *_reqp;\n\t\tispreqt2_t *_t2reqp;\n\t} _u;\n#define\treqp\t_u._reqp\n#define\tt2reqp\t_u._t2reqp\n#define\tUZSIZE\tmax(sizeof (ispreq_t), sizeof (ispreqt2_t))\n\tint target, i;\n\n\tXS_INITERR(xs);\n\tisp = XS_ISP(xs);\n\n\tif (isp->isp_state != ISP_RUNSTATE) {\n\t\tPRINTF(\"%s: adapter not ready\\n\", isp->isp_name);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check command CDB length, etc.. We really are limited to 16 bytes\n\t * for Fibre Channel, but can do up to 44 bytes in parallel SCSI,\n\t * but probably only if we're running fairly new firmware (we'll\n\t * let the old f/w choke on an extended command queue entry).\n\t */\n\n\tif (XS_CDBLEN(xs) > (IS_FC(isp)? 16 : 44) || XS_CDBLEN(xs) == 0) {\n\t\tPRINTF(\"%s: unsupported cdb length (%d, CDB[0]=0x%x)\\n\",\n\t\t    isp->isp_name, XS_CDBLEN(xs), XS_CDBP(xs)[0] & 0xff);\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_COMPLETE);\n\t}\n\n\t/*\n\t * Check to see whether we have good firmware state still or\n\t * need to refresh our port database for this target.\n\t */\n\ttarget = XS_TGT(xs);\n\tif (IS_FC(isp)) {\n\t\tfcparam *fcp = isp->isp_param;\n\t\tstruct lportdb *lp;\n#if\tdefined(ISP2100_FABRIC)\n\t\t/*\n\t\t * If we're not on a Fabric, we can't have a target\n\t\t * above FL_PORT_ID-1. If we're on a fabric and\n\t\t * connected as an F-port, we can't have a target\n\t\t * less than FC_SNS_ID+1.\n\t\t */\n\t\tif (fcp->isp_onfabric == 0) {\n\t\t\tif (target >= FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (target >= FL_PORT_ID && target <= FC_SNS_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t\tif (fcp->isp_topo == TOPO_F_PORT &&\n\t\t\t    target < FL_PORT_ID) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n#endif\n\t\t/*\n\t\t * Check for f/w being in ready state. If the f/w\n\t\t * isn't in ready state, then we don't know our\n\t\t * loop ID and the f/w hasn't completed logging\n\t\t * into all targets on the loop. If this is the\n\t\t * case, then bounce the command. We pretend this is\n\t\t * a SELECTION TIMEOUT error if we've never gone to\n\t\t * FW_READY state at all- in this case we may not\n\t\t * be hooked to a loop at all and we shouldn't hang\n\t\t * the machine for this. Otherwise, defer this command\n\t\t * until later.\n\t\t */\n\t\tif (fcp->isp_fwstate != FW_READY) {\n\t\t\tif (isp_fclink_test(isp, FC_FW_READY_DELAY)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\t\treturn (CMD_RQLATER);\n\t\t\t\t} else {\n\t\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is such that we haven't yet received\n\t\t * a \"Port Database Changed\" notification (after a LIP or\n\t\t * a Loop Reset or firmware initialization), then defer\n\t\t * sending commands for a little while, but only if we've\n\t\t * seen a valid loop at one point (otherwise we can get\n\t\t * stuck at initialization time).\n\t\t */\n\t\tif (fcp->isp_loopstate < LOOP_PDB_RCVD) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\tif (fcp->loop_seen_once) {\n\t\t\t\treturn (CMD_RQLATER);\n\t\t\t} else {\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If our loop state is now such that we've just now\n\t\t * received a Port Database Change notification, then\n\t\t * we have to go off and (re)synchronize our port\n\t\t * database.\n\t\t */\n\t\tif (fcp->isp_loopstate == LOOP_PDB_RCVD) {\n\t\t\tif (isp_pdb_sync(isp, target)) {\n\t\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\t\treturn (CMD_COMPLETE);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Now check whether we should even think about pursuing this.\n\t\t */\n\t\tlp = &fcp->portdb[target];\n\t\tif (lp->valid == 0) {\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\tif ((lp->roles & (SVC3_TGT_ROLE >> SVC3_ROLE_SHIFT)) == 0) {\n\t\t\tIDPRINTF(3, (\"%s: target %d is not a target\\n\",\n\t\t\t    isp->isp_name, target));\n\t\t\tXS_SETERR(xs, HBA_SELTIMEOUT);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\t/*\n\t\t * Now turn target into what the actual loop ID is.\n\t\t */\n\t\ttarget = lp->loopid;\n\t}\n\n\t/*\n\t * Next check to see if any HBA or Device\n\t * parameters need to be updated.\n\t */\n\tif (isp->isp_update != 0) {\n\t\tisp_update(isp);\n\t}\n\n\tif (isp_getrqentry(isp, &iptr, &optr, (void **) &reqp)) {\n\t\tIDPRINTF(1, (\"%s: Request Queue Overflow\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\n\t/*\n\t * Now see if we need to synchronize the ISP with respect to anything.\n\t * We do dual duty here (cough) for synchronizing for busses other\n\t * than which we got here to send a command to.\n\t */\n\tif (isp->isp_sendmarker) {\n\t\tu_int8_t n = (IS_DUALBUS(isp)? 2: 1);\n\t\t/*\n\t\t * Check ports to send markers for...\n\t\t */\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif ((isp->isp_sendmarker & (1 << i)) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tMEMZERO((void *) reqp, sizeof (*reqp));\n\t\t\treqp->req_header.rqs_entry_count = 1;\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_MARKER;\n\t\t\treqp->req_modifier = SYNC_ALL;\n\t\t\treqp->req_target = i << 7;\t/* insert bus number */\n\t\t\tISP_SWIZZLE_REQUEST(isp, reqp);\n\t\t\tMemoryBarrier();\n\t\t\tISP_ADD_REQUEST(isp, iptr);\n\n\t\t\tif (isp_getrqentry(isp, &iptr, &optr, (void **)&reqp)) {\n\t\t\t\tIDPRINTF(1, (\"%s: Request Queue Overflow+\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t\treturn (CMD_EAGAIN);\n\t\t\t}\n\t\t}\n\t}\n\n\tMEMZERO((void *) reqp, UZSIZE);\n\treqp->req_header.rqs_entry_count = 1;\n\tif (IS_FC(isp)) {\n\t\treqp->req_header.rqs_entry_type = RQSTYPE_T2RQS;\n\t} else {\n\t\tif (XS_CDBLEN(xs) > 12)\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_CMDONLY;\n\t\telse\n\t\t\treqp->req_header.rqs_entry_type = RQSTYPE_REQUEST;\n\t}\n\treqp->req_header.rqs_flags = 0;\n\treqp->req_header.rqs_seqno = 0;\n\tif (IS_FC(isp)) {\n\t\t/*\n\t\t * See comment in isp_intr\n\t\t */\n\t\tXS_RESID(xs) = 0;\n\n\t\t/*\n\t\t * Fibre Channel always requires some kind of tag.\n\t\t * The Qlogic drivers seem be happy not to use a tag,\n\t\t * but this breaks for some devices (IBM drives).\n\t\t */\n\t\tif (XS_CANTAG(xs)) {\n\t\t\tt2reqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t} else {\n\t\t\tif (XS_CDBP(xs)[0] == 0x3)\t/* REQUEST SENSE */\n\t\t\t\tt2reqp->req_flags = REQFLAG_HTAG;\n\t\t\telse\n\t\t\t\tt2reqp->req_flags = REQFLAG_OTAG;\n\t\t}\n\t} else {\n\t\tsdparam *sdp = (sdparam *)isp->isp_param;\n\t\tif ((sdp->isp_devparam[target].cur_dflags & DPARM_TQING) &&\n\t\t    XS_CANTAG(xs)) {\n\t\t\treqp->req_flags = XS_KINDOF_TAG(xs);\n\t\t}\n\t}\n\treqp->req_target = target | (XS_CHANNEL(xs) << 7);\n\tif (IS_SCSI(isp)) {\n\t\treqp->req_lun_trn = XS_LUN(xs);\n\t\treqp->req_cdblen = XS_CDBLEN(xs);\n\t} else {\n#ifdef\tISP2100_SCCLUN\n\t\tt2reqp->req_scclun = XS_LUN(xs);\n#else\n\t\tt2reqp->req_lun_trn = XS_LUN(xs);\n#endif\n\t}\n\tMEMCPY(reqp->req_cdb, XS_CDBP(xs), XS_CDBLEN(xs));\n\n\treqp->req_time = XS_TIME(xs) / 1000;\n\tif (reqp->req_time == 0 && XS_TIME(xs))\n\t\treqp->req_time = 1;\n\n\t/*\n\t * Always give a bit more leeway to commands after a bus reset.\n\t * XXX: DOES NOT DISTINGUISH WHICH PORT MAY HAVE BEEN SYNCED\n\t */\n\tif (isp->isp_sendmarker && reqp->req_time < 5) {\n\t\treqp->req_time = 5;\n\t}\n\tif (isp_save_xs(isp, xs, &reqp->req_handle)) {\n\t\tIDPRINTF(2, (\"%s: out of xflist pointers\\n\", isp->isp_name));\n\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\treturn (CMD_EAGAIN);\n\t}\n\t/*\n\t * Set up DMA and/or do any bus swizzling of the request entry\n\t * so that the Qlogic F/W understands what is being asked of it.\n \t*/\n\ti = ISP_DMASETUP(isp, xs, reqp, &iptr, optr);\n\tif (i != CMD_QUEUED) {\n\t\tisp_destroy_handle(isp, reqp->req_handle);\n\t\t/*\n\t\t * dmasetup sets actual error in packet, and\n\t\t * return what we were given to return.\n\t\t */\n\t\treturn (i);\n\t}\n\tXS_SETERR(xs, HBA_NOERROR);\n\tIDPRINTF(5, (\"%s(%d.%d.%d): START cmd 0x%x datalen %d\\n\",\n\t    isp->isp_name, XS_CHANNEL(xs), target, XS_LUN(xs),\n\t    reqp->req_cdb[0], XS_XFRLEN(xs)));\n\tMemoryBarrier();\n\tISP_ADD_REQUEST(isp, iptr);\n\tisp->isp_nactive++;\n\tif (isp->isp_sendmarker)\n\t\tisp->isp_sendmarker = 0;\n\treturn (CMD_QUEUED);\n#undef\treqp\n#undef\tt2reqp\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "2",
            "(\"%s: blocked\\n\", isp->isp_name)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_SETERR",
          "args": [
            "xs",
            "HBA_BOTCH"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_init",
          "args": [
            "isp"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "isp_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "647-664",
          "snippet": "void\nisp_init(isp)\n\tstruct ispsoftc *isp;\n{\n\t/*\n\t * Must do this first to get defaults established.\n\t */\n\tisp_setdfltparm(isp, 0);\n\tif (IS_DUALBUS(isp)) {\n\t\tisp_setdfltparm(isp, 1);\n\t}\n\n\tif (IS_FC(isp)) {\n\t\tisp_fibre_init(isp);\n\t} else {\n\t\tisp_scsi_init(isp);\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_scsi_init",
            "static void isp_fibre_init",
            "static void isp_setdfltparm"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void isp_scsi_init;\nstatic void isp_fibre_init;\nstatic void isp_setdfltparm;\n\nvoid\nisp_init(isp)\n\tstruct ispsoftc *isp;\n{\n\t/*\n\t * Must do this first to get defaults established.\n\t */\n\tisp_setdfltparm(isp, 0);\n\tif (IS_DUALBUS(isp)) {\n\t\tisp_setdfltparm(isp, 1);\n\t}\n\n\tif (IS_FC(isp)) {\n\t\tisp_fibre_init(isp);\n\t} else {\n\t\tisp_scsi_init(isp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISABLE_INTS",
          "args": [
            "isp"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic int32_t ispcmd;\nstatic int isp_poll;\nstatic void isp_command_requeue(void *);\n\nstatic int32_t\nispcmd(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tstruct ispsoftc *isp;\n\tint result;\n\tint s;\n\n\tisp = xs->sc_link->adapter_softc;\n\ts = splbio();\n\n\tif (isp->isp_state < ISP_RUNSTATE) {\n\t\tDISABLE_INTS(isp);\n\t\tisp_init(isp);\n\t\tif (isp->isp_state != ISP_INITSTATE) {\n\t\t\tENABLE_INTS(isp);\n\t\t\t(void) splx(s);\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\tisp->isp_state = ISP_RUNSTATE;\n\t\tENABLE_INTS(isp);\n\t}\n\n\t/*\n\t * Check for queue blockage...\n\t */\n\tif (isp->isp_osinfo.blocked) {\n\t\tIDPRINTF(2, (\"%s: blocked\\n\", isp->isp_name));\n\t\tif (xs->flags & SCSI_POLL) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\tif (isp->isp_osinfo.wqf != NULL) {\n\t\t\tisp->isp_osinfo.wqt->free_list.le_next = xs;\n\t\t} else {\n\t\t\tisp->isp_osinfo.wqf = xs;\n\t\t}\n\t\tisp->isp_osinfo.wqt = xs;\n\t\txs->free_list.le_next = NULL;\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tDISABLE_INTS(isp);\n\tresult = ispscsicmd(xs);\n\tENABLE_INTS(isp);\n\n\tif ((xs->flags & SCSI_POLL) == 0) {\n\t\tswitch (result) {\n\t\tcase CMD_QUEUED:\n\t\t\tresult = SUCCESSFULLY_QUEUED;\n\t\t\tbreak;\n\t\tcase CMD_EAGAIN:\n\t\t\tresult = TRY_AGAIN_LATER;\n\t\t\tbreak;\n\t\tcase CMD_RQLATER:\n\t\t\tresult = SUCCESSFULLY_QUEUED;\n\t\t\ttimeout(isp_command_requeue, xs, hz);\n\t\t\tbreak;\n\t\tcase CMD_COMPLETE:\n\t\t\tresult = COMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\t(void) splx(s);\n\t\treturn (result);\n\t}\n\n\tswitch (result) {\n\tcase CMD_QUEUED:\n\t\tresult = SUCCESSFULLY_QUEUED;\n\t\tbreak;\n\tcase CMD_RQLATER:\n\tcase CMD_EAGAIN:\n\t\tif (XS_NOERR(xs)) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t}\n\t\tresult = TRY_AGAIN_LATER;\n\t\tbreak;\n\tcase CMD_COMPLETE:\n\t\tresult = COMPLETE;\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * We can't use interrupts so poll on completion.\n\t */\n\tif (result == SUCCESSFULLY_QUEUED) {\n\t\tif (isp_poll(isp, xs, xs->timeout)) {\n\t\t\t/*\n\t\t\t * If no other error occurred but we didn't finish,\n\t\t\t * something bad happened.\n\t\t\t */\n\t\t\tif (XS_IS_CMD_DONE(xs) == 0) {\n\t\t\t\tif (isp_control(isp, ISPCTL_ABORT_CMD, xs)) {\n\t\t\t\t\tisp_restart(isp);\n\t\t\t\t}\n\t\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult = COMPLETE;\n\t}\n\t(void) splx(s);\n\treturn (result);\n}"
  },
  {
    "function_name": "ispcmd_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
    "lines": "209-292",
    "snippet": "static int32_t\nispcmd_slow(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tsdparam *sdp;\n\tint tgt, chan;\n\tu_int16_t f;\n\tstruct ispsoftc *isp = XS_ISP(xs);\n\n\t/*\n\t * Have we completed discovery for this target on this adapter?\n\t */\n\tsdp = isp->isp_param;\n\ttgt = XS_TGT(xs);\n\tchan = XS_CHANNEL(xs);\n\tsdp += chan;\n\tif ((xs->flags & SCSI_POLL) != 0 ||\n\t    (isp->isp_osinfo.discovered[chan] & (1 << tgt)) != 0) {\n\t\treturn (ispcmd(xs));\n\t}\n\n\tf = DPARM_DEFAULT;\n\tif (xs->sc_link->quirks & SDEV_NOSYNC) {\n\t\tf ^= DPARM_SYNC;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do SYNC xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\tif (xs->sc_link->quirks & SDEV_NOWIDE) {\n\t\tf ^= DPARM_WIDE;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do WIDE xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\tif (xs->sc_link->quirks & SDEV_NOTAGS) {\n\t\tf ^= DPARM_TQING;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do TAGGED xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\n\t/*\n\t * Okay, we know about this device now,\n\t * so mark parameters to be updated for it.\n\t */\n\tsdp->isp_devparam[tgt].dev_flags = f;\n\tsdp->isp_devparam[tgt].dev_update = 1;\n\tisp->isp_update |= (1 << chan);\n\n\t/*\n\t * Now check to see whether we can get out of this checking mode now.\n\t * XXX: WE CANNOT AS YET BECAUSE THERE IS NO MECHANISM TO TELL US\n\t * XXX: WHEN WE'RE DONE DISCOVERY BECAUSE WE NEED ONE COMMAND AFTER\n\t * XXX: DISCOVERY IS DONE FOR EACH TARGET TO TELL US THAT WE'RE DONE\n\t * XXX: AND THAT DOESN'T HAPPEN HERE. AT BEST WE CAN MARK OURSELVES\n\t * XXX: DONE WITH DISCOVERY FOR THIS TARGET AND SO SAVE MAYBE 20\n\t * XXX: LINES OF C CODE.\n\t */\n\tisp->isp_osinfo.discovered[chan] |= (1 << tgt);\n\t/* do not bother with these lines- they'll never execute correctly */\n#if\t0\n\tsdp = isp->isp_param;\n\tfor (chan = 0; chan < (IS_12X0(isp)? 2 : 1); chan++, sdp++) {\n\t\tf = 0xffff & ~(1 << sdp->isp_initiator_id);\n\t\tif (isp->isp_osinfo.discovered[chan] != f) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (chan == (IS_12X0(isp)? 2 : 1)) {\n\t\tCFGPRINTF(\"%s: allowing sync/wide negotiation and \"\n\t\t    \"tag usage\\n\", isp->isp_name);\n\t\tisp->isp_osinfo._adapter.scsipi_cmd = ispcmd;\n\t\tif (IS_12X0(isp))\n\t\t\tisp->isp_update |= 2;\n\t}\n#endif\n\treturn (ispcmd(xs));\n}",
    "includes": [
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int32_t ispcmd_slow",
      "static int32_t ispcmd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ispcmd",
          "args": [
            "xs"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ispcmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "294-401",
          "snippet": "static int32_t\nispcmd(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tstruct ispsoftc *isp;\n\tint result;\n\tint s;\n\n\tisp = xs->sc_link->adapter_softc;\n\ts = splbio();\n\n\tif (isp->isp_state < ISP_RUNSTATE) {\n\t\tDISABLE_INTS(isp);\n\t\tisp_init(isp);\n\t\tif (isp->isp_state != ISP_INITSTATE) {\n\t\t\tENABLE_INTS(isp);\n\t\t\t(void) splx(s);\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\tisp->isp_state = ISP_RUNSTATE;\n\t\tENABLE_INTS(isp);\n\t}\n\n\t/*\n\t * Check for queue blockage...\n\t */\n\tif (isp->isp_osinfo.blocked) {\n\t\tIDPRINTF(2, (\"%s: blocked\\n\", isp->isp_name));\n\t\tif (xs->flags & SCSI_POLL) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\tif (isp->isp_osinfo.wqf != NULL) {\n\t\t\tisp->isp_osinfo.wqt->free_list.le_next = xs;\n\t\t} else {\n\t\t\tisp->isp_osinfo.wqf = xs;\n\t\t}\n\t\tisp->isp_osinfo.wqt = xs;\n\t\txs->free_list.le_next = NULL;\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tDISABLE_INTS(isp);\n\tresult = ispscsicmd(xs);\n\tENABLE_INTS(isp);\n\n\tif ((xs->flags & SCSI_POLL) == 0) {\n\t\tswitch (result) {\n\t\tcase CMD_QUEUED:\n\t\t\tresult = SUCCESSFULLY_QUEUED;\n\t\t\tbreak;\n\t\tcase CMD_EAGAIN:\n\t\t\tresult = TRY_AGAIN_LATER;\n\t\t\tbreak;\n\t\tcase CMD_RQLATER:\n\t\t\tresult = SUCCESSFULLY_QUEUED;\n\t\t\ttimeout(isp_command_requeue, xs, hz);\n\t\t\tbreak;\n\t\tcase CMD_COMPLETE:\n\t\t\tresult = COMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\t(void) splx(s);\n\t\treturn (result);\n\t}\n\n\tswitch (result) {\n\tcase CMD_QUEUED:\n\t\tresult = SUCCESSFULLY_QUEUED;\n\t\tbreak;\n\tcase CMD_RQLATER:\n\tcase CMD_EAGAIN:\n\t\tif (XS_NOERR(xs)) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t}\n\t\tresult = TRY_AGAIN_LATER;\n\t\tbreak;\n\tcase CMD_COMPLETE:\n\t\tresult = COMPLETE;\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * We can't use interrupts so poll on completion.\n\t */\n\tif (result == SUCCESSFULLY_QUEUED) {\n\t\tif (isp_poll(isp, xs, xs->timeout)) {\n\t\t\t/*\n\t\t\t * If no other error occurred but we didn't finish,\n\t\t\t * something bad happened.\n\t\t\t */\n\t\t\tif (XS_IS_CMD_DONE(xs) == 0) {\n\t\t\t\tif (isp_control(isp, ISPCTL_ABORT_CMD, xs)) {\n\t\t\t\t\tisp_restart(isp);\n\t\t\t\t}\n\t\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult = COMPLETE;\n\t}\n\t(void) splx(s);\n\treturn (result);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int32_t ispcmd",
            "static int isp_poll",
            "static void isp_command_requeue(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic int32_t ispcmd;\nstatic int isp_poll;\nstatic void isp_command_requeue(void *);\n\nstatic int32_t\nispcmd(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tstruct ispsoftc *isp;\n\tint result;\n\tint s;\n\n\tisp = xs->sc_link->adapter_softc;\n\ts = splbio();\n\n\tif (isp->isp_state < ISP_RUNSTATE) {\n\t\tDISABLE_INTS(isp);\n\t\tisp_init(isp);\n\t\tif (isp->isp_state != ISP_INITSTATE) {\n\t\t\tENABLE_INTS(isp);\n\t\t\t(void) splx(s);\n\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\treturn (CMD_COMPLETE);\n\t\t}\n\t\tisp->isp_state = ISP_RUNSTATE;\n\t\tENABLE_INTS(isp);\n\t}\n\n\t/*\n\t * Check for queue blockage...\n\t */\n\tif (isp->isp_osinfo.blocked) {\n\t\tIDPRINTF(2, (\"%s: blocked\\n\", isp->isp_name));\n\t\tif (xs->flags & SCSI_POLL) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tsplx(s);\n\t\t\treturn (TRY_AGAIN_LATER);\n\t\t}\n\t\tif (isp->isp_osinfo.wqf != NULL) {\n\t\t\tisp->isp_osinfo.wqt->free_list.le_next = xs;\n\t\t} else {\n\t\t\tisp->isp_osinfo.wqf = xs;\n\t\t}\n\t\tisp->isp_osinfo.wqt = xs;\n\t\txs->free_list.le_next = NULL;\n\t\tsplx(s);\n\t\treturn (SUCCESSFULLY_QUEUED);\n\t}\n\tDISABLE_INTS(isp);\n\tresult = ispscsicmd(xs);\n\tENABLE_INTS(isp);\n\n\tif ((xs->flags & SCSI_POLL) == 0) {\n\t\tswitch (result) {\n\t\tcase CMD_QUEUED:\n\t\t\tresult = SUCCESSFULLY_QUEUED;\n\t\t\tbreak;\n\t\tcase CMD_EAGAIN:\n\t\t\tresult = TRY_AGAIN_LATER;\n\t\t\tbreak;\n\t\tcase CMD_RQLATER:\n\t\t\tresult = SUCCESSFULLY_QUEUED;\n\t\t\ttimeout(isp_command_requeue, xs, hz);\n\t\t\tbreak;\n\t\tcase CMD_COMPLETE:\n\t\t\tresult = COMPLETE;\n\t\t\tbreak;\n\t\t}\n\t\t(void) splx(s);\n\t\treturn (result);\n\t}\n\n\tswitch (result) {\n\tcase CMD_QUEUED:\n\t\tresult = SUCCESSFULLY_QUEUED;\n\t\tbreak;\n\tcase CMD_RQLATER:\n\tcase CMD_EAGAIN:\n\t\tif (XS_NOERR(xs)) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t}\n\t\tresult = TRY_AGAIN_LATER;\n\t\tbreak;\n\tcase CMD_COMPLETE:\n\t\tresult = COMPLETE;\n\t\tbreak;\n\t\t\n\t}\n\n\t/*\n\t * We can't use interrupts so poll on completion.\n\t */\n\tif (result == SUCCESSFULLY_QUEUED) {\n\t\tif (isp_poll(isp, xs, xs->timeout)) {\n\t\t\t/*\n\t\t\t * If no other error occurred but we didn't finish,\n\t\t\t * something bad happened.\n\t\t\t */\n\t\t\tif (XS_IS_CMD_DONE(xs) == 0) {\n\t\t\t\tif (isp_control(isp, ISPCTL_ABORT_CMD, xs)) {\n\t\t\t\t\tisp_restart(isp);\n\t\t\t\t}\n\t\t\t\tif (XS_NOERR(xs)) {\n\t\t\t\t\tXS_SETERR(xs, HBA_BOTCH);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult = COMPLETE;\n\t}\n\t(void) splx(s);\n\treturn (result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_12X0",
          "args": [
            "isp"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFGPRINTF",
          "args": [
            "\"%s: allowing sync/wide negotiation and \"\n\t\t    \"tag usage\\n\"",
            "isp->isp_name"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_12X0",
          "args": [
            "isp"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_12X0",
          "args": [
            "isp"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: channel %d target %d can do TAGGED xfers\\n\"",
            "isp->isp_name",
            "chan",
            "tgt"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XS_CHANNEL",
          "args": [
            "xs"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_TGT",
          "args": [
            "xs"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XS_ISP",
          "args": [
            "xs"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic int32_t ispcmd_slow;\nstatic int32_t ispcmd;\n\nstatic int32_t\nispcmd_slow(xs)\n\tISP_SCSI_XFER_T *xs;\n{\n\tsdparam *sdp;\n\tint tgt, chan;\n\tu_int16_t f;\n\tstruct ispsoftc *isp = XS_ISP(xs);\n\n\t/*\n\t * Have we completed discovery for this target on this adapter?\n\t */\n\tsdp = isp->isp_param;\n\ttgt = XS_TGT(xs);\n\tchan = XS_CHANNEL(xs);\n\tsdp += chan;\n\tif ((xs->flags & SCSI_POLL) != 0 ||\n\t    (isp->isp_osinfo.discovered[chan] & (1 << tgt)) != 0) {\n\t\treturn (ispcmd(xs));\n\t}\n\n\tf = DPARM_DEFAULT;\n\tif (xs->sc_link->quirks & SDEV_NOSYNC) {\n\t\tf ^= DPARM_SYNC;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do SYNC xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\tif (xs->sc_link->quirks & SDEV_NOWIDE) {\n\t\tf ^= DPARM_WIDE;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do WIDE xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\tif (xs->sc_link->quirks & SDEV_NOTAGS) {\n\t\tf ^= DPARM_TQING;\n#ifdef\tDEBUG\n\t} else {\n\t\tprintf(\"%s: channel %d target %d can do TAGGED xfers\\n\",\n\t\t    isp->isp_name, chan, tgt);\n#endif\n\t}\n\n\t/*\n\t * Okay, we know about this device now,\n\t * so mark parameters to be updated for it.\n\t */\n\tsdp->isp_devparam[tgt].dev_flags = f;\n\tsdp->isp_devparam[tgt].dev_update = 1;\n\tisp->isp_update |= (1 << chan);\n\n\t/*\n\t * Now check to see whether we can get out of this checking mode now.\n\t * XXX: WE CANNOT AS YET BECAUSE THERE IS NO MECHANISM TO TELL US\n\t * XXX: WHEN WE'RE DONE DISCOVERY BECAUSE WE NEED ONE COMMAND AFTER\n\t * XXX: DISCOVERY IS DONE FOR EACH TARGET TO TELL US THAT WE'RE DONE\n\t * XXX: AND THAT DOESN'T HAPPEN HERE. AT BEST WE CAN MARK OURSELVES\n\t * XXX: DONE WITH DISCOVERY FOR THIS TARGET AND SO SAVE MAYBE 20\n\t * XXX: LINES OF C CODE.\n\t */\n\tisp->isp_osinfo.discovered[chan] |= (1 << tgt);\n\t/* do not bother with these lines- they'll never execute correctly */\n#if\t0\n\tsdp = isp->isp_param;\n\tfor (chan = 0; chan < (IS_12X0(isp)? 2 : 1); chan++, sdp++) {\n\t\tf = 0xffff & ~(1 << sdp->isp_initiator_id);\n\t\tif (isp->isp_osinfo.discovered[chan] != f) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (chan == (IS_12X0(isp)? 2 : 1)) {\n\t\tCFGPRINTF(\"%s: allowing sync/wide negotiation and \"\n\t\t    \"tag usage\\n\", isp->isp_name);\n\t\tisp->isp_osinfo._adapter.scsipi_cmd = ispcmd;\n\t\tif (IS_12X0(isp))\n\t\t\tisp->isp_update |= 2;\n\t}\n#endif\n\treturn (ispcmd(xs));\n}"
  },
  {
    "function_name": "ispminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
    "lines": "196-207",
    "snippet": "static void\nispminphys(bp)\n\tstruct buf *bp;\n{\n\t/*\n\t * XX: Only the 1020 has a 24 bit limit.\n\t */\n\tif (bp->b_bcount >= (1 << 24)) {\n\t\tbp->b_bcount = (1 << 24);\n\t}\n\tminphys(bp);\n}",
    "includes": [
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ispminphys"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ispminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "196-207",
          "snippet": "static void\nispminphys(bp)\n\tstruct buf *bp;\n{\n\t/*\n\t * XX: Only the 1020 has a 24 bit limit.\n\t */\n\tif (bp->b_bcount >= (1 << 24)) {\n\t\tbp->b_bcount = (1 << 24);\n\t}\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void ispminphys;\n\nstatic void\nispminphys(bp)\n\tstruct buf *bp;\n{\n\t/*\n\t * XX: Only the 1020 has a 24 bit limit.\n\t */\n\tif (bp->b_bcount >= (1 << 24)) {\n\t\tbp->b_bcount = (1 << 24);\n\t}\n\tminphys(bp);\n}"
  },
  {
    "function_name": "isp_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
    "lines": "70-186",
    "snippet": "void\nisp_attach(isp)\n\tstruct ispsoftc *isp;\n{\n\tstruct scsi_link *lptr = &isp->isp_osinfo._link[0];\n\tisp->isp_osinfo._adapter.scsi_minphys = ispminphys;\n\n\tisp->isp_state = ISP_RUNSTATE;\n\n\t/*\n\t * We only manage a single wait queues for dual bus controllers.\n\t * This is arguably broken.\n\t */\n\tisp->isp_osinfo.wqf = isp->isp_osinfo.wqt = NULL;\n\n\tlptr->adapter_softc = isp;\n\tlptr->device = &isp_dev;\n\tlptr->adapter = &isp->isp_osinfo._adapter;\n\tlptr->openings = isp->isp_maxcmds;\n\tif (IS_FC(isp)) {\n\t\tisp->isp_osinfo._adapter.scsi_cmd = ispcmd;\n\t\tlptr->adapter_buswidth = MAX_FC_TARG;\n\t\t/* We can set max lun width here */\n\t\t/* loopid set below */\n\t} else {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tisp->isp_osinfo._adapter.scsi_cmd = ispcmd_slow;\n\t\tlptr->adapter_buswidth = MAX_TARGETS;\n\t\t/* We can set max lun width here */\n\t\tlptr->adapter_target = sdp->isp_initiator_id;\n\t\tisp->isp_osinfo.discovered[0] = 1 << sdp->isp_initiator_id;\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tstruct scsi_link *lptrb = &isp->isp_osinfo._link[1];\n\t\t\tlptrb->adapter_softc = isp;\n\t\t\tlptrb->device = &isp_dev;\n\t\t\tlptrb->adapter = &isp->isp_osinfo._adapter;\n\t\t\tlptrb->openings = isp->isp_maxcmds;\n\t\t\tlptrb->adapter_buswidth = MAX_TARGETS;\n\t\t\tlptrb->adapter_target = sdp->isp_initiator_id;\n\t\t\tlptrb->flags = SDEV_2NDBUS;\n\t\t\tisp->isp_osinfo.discovered[1] =\n\t\t\t    1 << (sdp+1)->isp_initiator_id;\n\t\t}\n\t}\n\n\t/*\n\t * Send a SCSI Bus Reset (used to be done as part of attach,\n\t * but now left to the OS outer layers).\n\t *\n\t * We don't do 'bus resets' for FC because the LIP that occurs\n\t * when we start the firmware does all that for us.\n\t */\n\tif (IS_SCSI(isp)) {\n\t\tint bus = 0;\n\t\t(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tbus++;\n\t\t\t(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);\n\t\t}\n\t\t/*\n\t\t * wait for the bus to settle.\n\t\t */\n\t\tprintf(\"%s: waiting 4 seconds for bus reset settling\\n\",\n\t\t    isp->isp_name);\n\t\tdelay(4 * 1000000);\n\t} else {\n\t\tint i, j;\n\t\tfcparam *fcp = isp->isp_param;\n\t\t/*\n\t\t * wait for the loop to settle.\n\t\t */\n\t\tprintf(\"%s: waiting 2 seconds for loop reset settling\\n\",\n\t\t    isp->isp_name);\n\t\tdelay(2 * 1000000);\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (isp_control(isp, ISPCTL_FCLINK_TEST, NULL))\n\t\t\t\t\tcontinue;\n#ifdef\tISP2100_FABRIC\n\t\t\t\t/*\n\t\t\t\t * Wait extra time to see if the f/w\n\t\t\t\t * eventually completed an FLOGI that\n\t\t\t\t * will allow us to know we're on a\n\t\t\t\t * fabric.\n\t\t\t\t */\n\t\t\t\tif (fcp->isp_onfabric == 0) {\n\t\t\t\t\tdelay(1 * 1000000);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fcp->isp_fwstate == FW_READY &&\n\t\t\t    fcp->isp_loopstate >= LOOP_PDB_RCVD) { \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlptr->adapter_target = fcp->isp_loopid;\n\t}\n\n\t/*\n\t * Start the watchdog.\n\t *\n\t * The watchdog will, ridiculously enough, also enable Sync negotiation.\n\t */\n\tisp->isp_dogactive = 1;\n\ttimeout(isp_watch, isp, WATCH_INTERVAL * hz);\n\n\t/*\n\t * And attach children (if any).\n\t */\n\tconfig_found((void *)isp, lptr, scsiprint);\n\tif (IS_DUALBUS(isp)) {\n\t\tlptr++;\n\t\tconfig_found((void *)isp, lptr, scsiprint);\n\t}\n}",
    "includes": [
      "#include <dev/ic/isp_openbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ispminphys",
      "static int32_t ispcmd_slow",
      "static int32_t ispcmd",
      "static struct scsi_device isp_dev = { NULL, NULL, NULL, NULL };",
      "static void isp_watch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "(void *)isp",
            "lptr",
            "scsiprint"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "(void *)isp",
            "lptr",
            "scsiprint"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "isp_watch",
            "isp",
            "WATCH_INTERVAL * hz"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1 * 1000000"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_control",
          "args": [
            "isp",
            "ISPCTL_FCLINK_TEST",
            "NULL"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "isp_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp.c",
          "lines": "2150-2275",
          "snippet": "int\nisp_control(isp, ctl, arg)\n\tstruct ispsoftc *isp;\n\tispctl_t ctl;\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *xs;\n\tmbreg_t mbs;\n\tint bus, tgt;\n\tu_int32_t handle;\n\n\tswitch (ctl) {\n\tdefault:\n\t\tPRINTF(\"%s: isp_control unknown control op %x\\n\",\n\t\t    isp->isp_name, ctl);\n\t\tbreak;\n\n\tcase ISPCTL_RESET_BUS:\n\t\t/*\n\t\t * Issue a bus reset.\n\t\t */\n\t\tmbs.param[0] = MBOX_BUS_RESET;\n\t\tmbs.param[2] = 0;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tmbs.param[1] =\n\t\t\t    ((sdparam *) isp->isp_param)->isp_bus_reset_delay;\n\t\t\tif (mbs.param[1] < 2)\n\t\t\t\tmbs.param[1] = 2;\n\t\t\tbus = *((int *) arg);\n\t\t\tif (IS_DUALBUS(isp))\n\t\t\t\tmbs.param[2] = bus;\n\t\t} else {\n\t\t\tmbs.param[1] = 10;\n\t\t\tbus = 0;\n\t\t}\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"isp_control SCSI bus reset failed\");\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: driver initiated bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\treturn (0);\n\n\tcase ISPCTL_RESET_DEV:\n\t\ttgt = (*((int *) arg)) & 0xffff;\n\t\tbus = (*((int *) arg)) >> 16;\n\t\tmbs.param[0] = MBOX_ABORT_TARGET;\n\t\tmbs.param[1] = (tgt << 8) | (bus << 15);\n\t\tmbs.param[2] = 3;\t/* 'delay', in seconds */\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_RESET_DEV failure (code \"\n\t\t\t    \"%x)\\n\", isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: Target %d on Bus %d Reset Succeeded\\n\",\n\t\t    isp->isp_name, tgt, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\treturn (0);\n\n\tcase ISPCTL_ABORT_CMD:\n\t\txs = (ISP_SCSI_XFER_T *) arg;\n\t\thandle = isp_find_handle(isp, xs);\n\t\tif (handle == 0) {\n\t\t\tPRINTF(\"%s: isp_control- cannot find command to abort \"\n\t\t\t    \"in active list\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tbus = XS_CHANNEL(xs);\n\t\tmbs.param[0] = MBOX_ABORT;\n\t\tif (IS_FC(isp)) {\n#ifdef\tISP2100_SCCLUN\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8;\n\t\t\tmbs.param[4] = 0;\n\t\t\tmbs.param[5] = 0;\n\t\t\tmbs.param[6] = XS_LUN(xs);\n#else\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);\n#endif\n\t\t} else {\n\t\t\tmbs.param[1] =\n\t\t\t    (bus << 15) | (XS_TGT(xs) << 8) | XS_LUN(xs);\n\t\t}\n\t\tmbs.param[3] = handle >> 16;\n\t\tmbs.param[2] = handle & 0xffff;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_ABORT failure (code %x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: command for target %d lun %d was aborted\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\treturn (0);\n\n\tcase ISPCTL_UPDATE_PARAMS:\n\t\tisp_update(isp);\n\t\treturn (0);\n\n\tcase ISPCTL_FCLINK_TEST:\n\t\treturn (isp_fclink_test(isp, FC_FW_READY_DELAY));\n\n\tcase ISPCTL_PDB_SYNC:\n\t\treturn (isp_pdb_sync(isp, -1));\n\n#ifdef\tISP_TARGET_MODE\n\tcase ISPCTL_TOGGLE_TMODE:\n\t\tif (IS_SCSI(isp)) {\n\t\t\tint ena = *(int *)arg;\n\t\t\tmbs.param[0] = MBOX_ENABLE_TARGET_MODE;\n\t\t\tmbs.param[1] = (ena)? ENABLE_TARGET_FLAG : 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: cannot %sable target mode (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, ena? \"en\" : \"dis\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (0);\n#endif\n\t}\n\treturn (-1);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int isp_fclink_test",
            "static int isp_pdb_sync",
            "static void isp_dumpregs",
            "static void isp_mboxcmd",
            "static void isp_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic int isp_fclink_test;\nstatic int isp_pdb_sync;\nstatic void isp_dumpregs;\nstatic void isp_mboxcmd;\nstatic void isp_update;\n\nint\nisp_control(isp, ctl, arg)\n\tstruct ispsoftc *isp;\n\tispctl_t ctl;\n\tvoid *arg;\n{\n\tISP_SCSI_XFER_T *xs;\n\tmbreg_t mbs;\n\tint bus, tgt;\n\tu_int32_t handle;\n\n\tswitch (ctl) {\n\tdefault:\n\t\tPRINTF(\"%s: isp_control unknown control op %x\\n\",\n\t\t    isp->isp_name, ctl);\n\t\tbreak;\n\n\tcase ISPCTL_RESET_BUS:\n\t\t/*\n\t\t * Issue a bus reset.\n\t\t */\n\t\tmbs.param[0] = MBOX_BUS_RESET;\n\t\tmbs.param[2] = 0;\n\t\tif (IS_SCSI(isp)) {\n\t\t\tmbs.param[1] =\n\t\t\t    ((sdparam *) isp->isp_param)->isp_bus_reset_delay;\n\t\t\tif (mbs.param[1] < 2)\n\t\t\t\tmbs.param[1] = 2;\n\t\t\tbus = *((int *) arg);\n\t\t\tif (IS_DUALBUS(isp))\n\t\t\t\tmbs.param[2] = bus;\n\t\t} else {\n\t\t\tmbs.param[1] = 10;\n\t\t\tbus = 0;\n\t\t}\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tisp_dumpregs(isp, \"isp_control SCSI bus reset failed\");\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: driver initiated bus reset of bus %d\\n\",\n\t\t    isp->isp_name, bus);\n\t\treturn (0);\n\n\tcase ISPCTL_RESET_DEV:\n\t\ttgt = (*((int *) arg)) & 0xffff;\n\t\tbus = (*((int *) arg)) >> 16;\n\t\tmbs.param[0] = MBOX_ABORT_TARGET;\n\t\tmbs.param[1] = (tgt << 8) | (bus << 15);\n\t\tmbs.param[2] = 3;\t/* 'delay', in seconds */\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_RESET_DEV failure (code \"\n\t\t\t    \"%x)\\n\", isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: Target %d on Bus %d Reset Succeeded\\n\",\n\t\t    isp->isp_name, tgt, bus);\n\t\tisp->isp_sendmarker |= (1 << bus);\n\t\treturn (0);\n\n\tcase ISPCTL_ABORT_CMD:\n\t\txs = (ISP_SCSI_XFER_T *) arg;\n\t\thandle = isp_find_handle(isp, xs);\n\t\tif (handle == 0) {\n\t\t\tPRINTF(\"%s: isp_control- cannot find command to abort \"\n\t\t\t    \"in active list\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tbus = XS_CHANNEL(xs);\n\t\tmbs.param[0] = MBOX_ABORT;\n\t\tif (IS_FC(isp)) {\n#ifdef\tISP2100_SCCLUN\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8;\n\t\t\tmbs.param[4] = 0;\n\t\t\tmbs.param[5] = 0;\n\t\t\tmbs.param[6] = XS_LUN(xs);\n#else\n\t\t\tmbs.param[1] = XS_TGT(xs) << 8 | XS_LUN(xs);\n#endif\n\t\t} else {\n\t\t\tmbs.param[1] =\n\t\t\t    (bus << 15) | (XS_TGT(xs) << 8) | XS_LUN(xs);\n\t\t}\n\t\tmbs.param[3] = handle >> 16;\n\t\tmbs.param[2] = handle & 0xffff;\n\t\tisp_mboxcmd(isp, &mbs);\n\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\tPRINTF(\"%s: isp_control MBOX_ABORT failure (code %x)\\n\",\n\t\t\t    isp->isp_name, mbs.param[0]);\n\t\t\tbreak;\n\t\t}\n\t\tPRINTF(\"%s: command for target %d lun %d was aborted\\n\",\n\t\t    isp->isp_name, XS_TGT(xs), XS_LUN(xs));\n\t\treturn (0);\n\n\tcase ISPCTL_UPDATE_PARAMS:\n\t\tisp_update(isp);\n\t\treturn (0);\n\n\tcase ISPCTL_FCLINK_TEST:\n\t\treturn (isp_fclink_test(isp, FC_FW_READY_DELAY));\n\n\tcase ISPCTL_PDB_SYNC:\n\t\treturn (isp_pdb_sync(isp, -1));\n\n#ifdef\tISP_TARGET_MODE\n\tcase ISPCTL_TOGGLE_TMODE:\n\t\tif (IS_SCSI(isp)) {\n\t\t\tint ena = *(int *)arg;\n\t\t\tmbs.param[0] = MBOX_ENABLE_TARGET_MODE;\n\t\t\tmbs.param[1] = (ena)? ENABLE_TARGET_FLAG : 0;\n\t\t\tisp_mboxcmd(isp, &mbs);\n\t\t\tif (mbs.param[0] != MBOX_COMMAND_COMPLETE) {\n\t\t\t\tPRINTF(\"%s: cannot %sable target mode (0x%x)\\n\",\n\t\t\t\t    isp->isp_name, ena? \"en\" : \"dis\",\n\t\t\t\t    mbs.param[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (0);\n#endif\n\t}\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: waiting 2 seconds for loop reset settling\\n\"",
            "isp->isp_name"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void ispminphys;\nstatic int32_t ispcmd_slow;\nstatic int32_t ispcmd;\nstatic struct scsi_device isp_dev = { NULL, NULL, NULL, NULL };\nstatic void isp_watch;\n\nvoid\nisp_attach(isp)\n\tstruct ispsoftc *isp;\n{\n\tstruct scsi_link *lptr = &isp->isp_osinfo._link[0];\n\tisp->isp_osinfo._adapter.scsi_minphys = ispminphys;\n\n\tisp->isp_state = ISP_RUNSTATE;\n\n\t/*\n\t * We only manage a single wait queues for dual bus controllers.\n\t * This is arguably broken.\n\t */\n\tisp->isp_osinfo.wqf = isp->isp_osinfo.wqt = NULL;\n\n\tlptr->adapter_softc = isp;\n\tlptr->device = &isp_dev;\n\tlptr->adapter = &isp->isp_osinfo._adapter;\n\tlptr->openings = isp->isp_maxcmds;\n\tif (IS_FC(isp)) {\n\t\tisp->isp_osinfo._adapter.scsi_cmd = ispcmd;\n\t\tlptr->adapter_buswidth = MAX_FC_TARG;\n\t\t/* We can set max lun width here */\n\t\t/* loopid set below */\n\t} else {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tisp->isp_osinfo._adapter.scsi_cmd = ispcmd_slow;\n\t\tlptr->adapter_buswidth = MAX_TARGETS;\n\t\t/* We can set max lun width here */\n\t\tlptr->adapter_target = sdp->isp_initiator_id;\n\t\tisp->isp_osinfo.discovered[0] = 1 << sdp->isp_initiator_id;\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tstruct scsi_link *lptrb = &isp->isp_osinfo._link[1];\n\t\t\tlptrb->adapter_softc = isp;\n\t\t\tlptrb->device = &isp_dev;\n\t\t\tlptrb->adapter = &isp->isp_osinfo._adapter;\n\t\t\tlptrb->openings = isp->isp_maxcmds;\n\t\t\tlptrb->adapter_buswidth = MAX_TARGETS;\n\t\t\tlptrb->adapter_target = sdp->isp_initiator_id;\n\t\t\tlptrb->flags = SDEV_2NDBUS;\n\t\t\tisp->isp_osinfo.discovered[1] =\n\t\t\t    1 << (sdp+1)->isp_initiator_id;\n\t\t}\n\t}\n\n\t/*\n\t * Send a SCSI Bus Reset (used to be done as part of attach,\n\t * but now left to the OS outer layers).\n\t *\n\t * We don't do 'bus resets' for FC because the LIP that occurs\n\t * when we start the firmware does all that for us.\n\t */\n\tif (IS_SCSI(isp)) {\n\t\tint bus = 0;\n\t\t(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);\n\t\tif (IS_DUALBUS(isp)) {\n\t\t\tbus++;\n\t\t\t(void) isp_control(isp, ISPCTL_RESET_BUS, &bus);\n\t\t}\n\t\t/*\n\t\t * wait for the bus to settle.\n\t\t */\n\t\tprintf(\"%s: waiting 4 seconds for bus reset settling\\n\",\n\t\t    isp->isp_name);\n\t\tdelay(4 * 1000000);\n\t} else {\n\t\tint i, j;\n\t\tfcparam *fcp = isp->isp_param;\n\t\t/*\n\t\t * wait for the loop to settle.\n\t\t */\n\t\tprintf(\"%s: waiting 2 seconds for loop reset settling\\n\",\n\t\t    isp->isp_name);\n\t\tdelay(2 * 1000000);\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (isp_control(isp, ISPCTL_FCLINK_TEST, NULL))\n\t\t\t\t\tcontinue;\n#ifdef\tISP2100_FABRIC\n\t\t\t\t/*\n\t\t\t\t * Wait extra time to see if the f/w\n\t\t\t\t * eventually completed an FLOGI that\n\t\t\t\t * will allow us to know we're on a\n\t\t\t\t * fabric.\n\t\t\t\t */\n\t\t\t\tif (fcp->isp_onfabric == 0) {\n\t\t\t\t\tdelay(1 * 1000000);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fcp->isp_fwstate == FW_READY &&\n\t\t\t    fcp->isp_loopstate >= LOOP_PDB_RCVD) { \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlptr->adapter_target = fcp->isp_loopid;\n\t}\n\n\t/*\n\t * Start the watchdog.\n\t *\n\t * The watchdog will, ridiculously enough, also enable Sync negotiation.\n\t */\n\tisp->isp_dogactive = 1;\n\ttimeout(isp_watch, isp, WATCH_INTERVAL * hz);\n\n\t/*\n\t * And attach children (if any).\n\t */\n\tconfig_found((void *)isp, lptr, scsiprint);\n\tif (IS_DUALBUS(isp)) {\n\t\tlptr++;\n\t\tconfig_found((void *)isp, lptr, scsiprint);\n\t}\n}"
  }
]