[
  {
    "function_name": "uhci_pci_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/uhci_pci.c",
    "lines": "176-196",
    "snippet": "int\nuhci_pci_detach(self, flags)\n\tdevice_ptr_t self;\n\tint flags;\n{\n\tstruct uhci_pci_softc *sc = (struct uhci_pci_softc *)self;\n\tint rv;\n\n\trv = uhci_detach(&sc->sc, flags);\n\tif (rv)\n\t\treturn (rv);\n\tif (sc->sc_ih) {\n\t\tpci_intr_disestablish(sc->sc_pc, sc->sc_ih);\n\t\tsc->sc_ih = 0;\n\t}\n\tif (sc->sc_size) {\n\t\tbus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc_size);\n\t\tsc->sc_size = 0;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tuhci_pci_detach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc.iot",
            "sc->sc.ioh",
            "sc->sc_size"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_disestablish",
          "args": [
            "sc->sc_pc",
            "sc->sc_ih"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uhci_detach",
          "args": [
            "&sc->sc",
            "flags"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "502-533",
          "snippet": "int\nuhci_detach(sc, flags)\n\tstruct uhci_softc *sc;\n\tint flags;\n{\n\tusbd_xfer_handle xfer;\n\tint rv = 0;\n\n\tif (sc->sc_child != NULL)\n\t\trv = config_detach(sc->sc_child, flags);\n\t\n\tif (rv != 0)\n\t\treturn (rv);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tpowerhook_disestablish(sc->sc_powerhook);\n\tshutdownhook_disestablish(sc->sc_shutdownhook);\n#endif\n\n\t/* Free all xfers associated with this HC. */\n\tfor (;;) {\n\t\txfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);\n\t\tif (xfer == NULL)\n\t\t\tbreak;\n\t\tSIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);\n\t\tfree(xfer, M_USB);\n\t}\t\t\t\n\n\t/* XXX free other data structures XXX */\n\n\treturn (rv);\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));",
            "uhci_device_isoc_enter __P((usbd_xfer_handle));",
            "Static usbd_xfer_handle",
            "uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));",
            "uhci_device_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_device_ctrl_start __P((usbd_xfer_handle));",
            "uhci_device_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_device_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_device_intr_transfer __P((usbd_xfer_handle));",
            "uhci_device_intr_start __P((usbd_xfer_handle));",
            "uhci_device_intr_abort __P((usbd_xfer_handle));",
            "uhci_device_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_bulk_transfer __P((usbd_xfer_handle));",
            "uhci_device_bulk_start __P((usbd_xfer_handle));",
            "uhci_device_bulk_abort __P((usbd_xfer_handle));",
            "uhci_device_bulk_done  __P((usbd_xfer_handle));",
            "uhci_device_isoc_transfer __P((usbd_xfer_handle));",
            "uhci_device_isoc_start __P((usbd_xfer_handle));",
            "uhci_device_isoc_abort __P((usbd_xfer_handle));",
            "uhci_device_isoc_done  __P((usbd_xfer_handle));",
            "uhci_root_ctrl_transfer __P((usbd_xfer_handle));",
            "uhci_root_ctrl_start __P((usbd_xfer_handle));",
            "uhci_root_ctrl_abort __P((usbd_xfer_handle));",
            "uhci_root_ctrl_done  __P((usbd_xfer_handle));",
            "uhci_root_intr_transfer __P((usbd_xfer_handle));",
            "uhci_root_intr_start __P((usbd_xfer_handle));",
            "uhci_root_intr_abort __P((usbd_xfer_handle));",
            "uhci_root_intr_done  __P((usbd_xfer_handle));",
            "uhci_device_request __P((usbd_xfer_handle xfer));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_waitintr __P((uhci_softc_t *,\n\t\t\t    usbd_xfer_handle));\nuhci_device_isoc_enter __P((usbd_xfer_handle));\nStatic usbd_xfer_handle;\nuhci_freex __P((struct usbd_bus *, usbd_xfer_handle));\nuhci_device_ctrl_transfer __P((usbd_xfer_handle));\nuhci_device_ctrl_start __P((usbd_xfer_handle));\nuhci_device_ctrl_abort __P((usbd_xfer_handle));\nuhci_device_ctrl_done  __P((usbd_xfer_handle));\nuhci_device_intr_transfer __P((usbd_xfer_handle));\nuhci_device_intr_start __P((usbd_xfer_handle));\nuhci_device_intr_abort __P((usbd_xfer_handle));\nuhci_device_intr_done  __P((usbd_xfer_handle));\nuhci_device_bulk_transfer __P((usbd_xfer_handle));\nuhci_device_bulk_start __P((usbd_xfer_handle));\nuhci_device_bulk_abort __P((usbd_xfer_handle));\nuhci_device_bulk_done  __P((usbd_xfer_handle));\nuhci_device_isoc_transfer __P((usbd_xfer_handle));\nuhci_device_isoc_start __P((usbd_xfer_handle));\nuhci_device_isoc_abort __P((usbd_xfer_handle));\nuhci_device_isoc_done  __P((usbd_xfer_handle));\nuhci_root_ctrl_transfer __P((usbd_xfer_handle));\nuhci_root_ctrl_start __P((usbd_xfer_handle));\nuhci_root_ctrl_abort __P((usbd_xfer_handle));\nuhci_root_ctrl_done  __P((usbd_xfer_handle));\nuhci_root_intr_transfer __P((usbd_xfer_handle));\nuhci_root_intr_start __P((usbd_xfer_handle));\nuhci_root_intr_abort __P((usbd_xfer_handle));\nuhci_root_intr_done  __P((usbd_xfer_handle));\nuhci_device_request __P((usbd_xfer_handle xfer));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nint\nuhci_detach(sc, flags)\n\tstruct uhci_softc *sc;\n\tint flags;\n{\n\tusbd_xfer_handle xfer;\n\tint rv = 0;\n\n\tif (sc->sc_child != NULL)\n\t\trv = config_detach(sc->sc_child, flags);\n\t\n\tif (rv != 0)\n\t\treturn (rv);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tpowerhook_disestablish(sc->sc_powerhook);\n\tshutdownhook_disestablish(sc->sc_shutdownhook);\n#endif\n\n\t/* Free all xfers associated with this HC. */\n\tfor (;;) {\n\t\txfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);\n\t\tif (xfer == NULL)\n\t\t\tbreak;\n\t\tSIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);\n\t\tfree(xfer, M_USB);\n\t}\t\t\t\n\n\t/* XXX free other data structures XXX */\n\n\treturn (rv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tuhci_pci_detach;\n\nint\nuhci_pci_detach(self, flags)\n\tdevice_ptr_t self;\n\tint flags;\n{\n\tstruct uhci_pci_softc *sc = (struct uhci_pci_softc *)self;\n\tint rv;\n\n\trv = uhci_detach(&sc->sc, flags);\n\tif (rv)\n\t\treturn (rv);\n\tif (sc->sc_ih) {\n\t\tpci_intr_disestablish(sc->sc_pc, sc->sc_ih);\n\t\tsc->sc_ih = 0;\n\t}\n\tif (sc->sc_size) {\n\t\tbus_space_unmap(sc->sc.iot, sc->sc.ioh, sc->sc_size);\n\t\tsc->sc_size = 0;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "uhci_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/uhci_pci.c",
    "lines": "91-174",
    "snippet": "void\nuhci_pci_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct uhci_pci_softc *sc = (struct uhci_pci_softc *)self;\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tchar const *intrstr;\n\tpci_intr_handle_t ih;\n\tpcireg_t csr, legsup;\n\tusbd_status r;\n\n\n\t/* Map I/O registers */\n\tif (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,\n\t\t\t   &sc->sc.iot, &sc->sc.ioh, NULL, NULL)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\t/* Disable interrupts, so we don't get any spurious ones. */\n\tbus_space_write_2(sc->sc.iot, sc->sc.ioh, UHCI_INTR, 0);\n\n\tsc->sc_pc = pc;\n\tsc->sc.sc_bus.dmatag = pa->pa_dmat;\n\n\t/* Enable the device. */\n\tcsr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t       csr | PCI_COMMAND_MASTER_ENABLE);\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, uhci_intr, sc,\n\t    sc->sc.sc_bus.bdev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": %s\\n\", intrstr);\n\n\t/* Verify that the PIRQD enable bit is set, some BIOS's don't do that*/\n\tlegsup = pci_conf_read(pc, pa->pa_tag, PCI_LEGSUP);\n\tif (!(legsup & PCI_LEGSUP_USBPIRQDEN)) {\n\t\tlegsup = PCI_LEGSUP_USBPIRQDEN;\n\t\tpci_conf_write(pc, pa->pa_tag, PCI_LEGSUP, legsup);\n\t}\n\n\tswitch(pci_conf_read(pc, pa->pa_tag, PCI_USBREV) & PCI_USBREV_MASK) {\n\tcase PCI_USBREV_PRE_1_0:\n\t\tsc->sc.sc_bus.usbrev = USBREV_PRE_1_0;\n\t\tbreak;\n\tcase PCI_USBREV_1_0:\n\t\tsc->sc.sc_bus.usbrev = USBREV_1_0;\n\t\tbreak;\n\tcase PCI_USBREV_1_1:\n\t\tsc->sc.sc_bus.usbrev = USBREV_1_1;\n\t\tbreak;\n\tdefault:\n\t\tsc->sc.sc_bus.usbrev = USBREV_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tr = uhci_init(&sc->sc);\n\tif (r != USBD_NORMAL_COMPLETION) {\n\t\tprintf(\"%s: init failed, error=%d\\n\", \n\t\t       sc->sc.sc_bus.bdev.dv_xname, r);\n\t\treturn;\n\t}\n\n\t/* Attach usb device. */\n\tsc->sc.sc_child = config_found((void *)sc, &sc->sc.sc_bus,\n\t\t\t\t       usbctlprint);\n}",
    "includes": [
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tuhci_pci_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "(void *)sc",
            "&sc->sc.sc_bus",
            "usbctlprint"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: init failed, error=%d\\n\"",
            "sc->sc.sc_bus.bdev.dv_xname",
            "r"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uhci_init",
          "args": [
            "&sc->sc"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "376-478",
          "snippet": "usbd_status\nuhci_init(sc)\n\tuhci_softc_t *sc;\n{\n\tusbd_status err;\n\tint i, j;\n\tuhci_soft_qh_t *csqh, *bsqh, *sqh;\n\tuhci_soft_td_t *std;\n\n\tDPRINTFN(1,(\"uhci_init: start\\n\"));\n\n#ifdef UHCI_DEBUG\n\tthesc = sc;\n\n\tif (uhcidebug > 2)\n\t\tuhci_dumpregs(sc);\n#endif\n\n\tuhci_run(sc, 0);\t\t\t/* stop the controller */\n\tUWRITE2(sc, UHCI_INTR, 0);\t\t/* disable interrupts */\n\n\tuhci_busreset(sc);\n\n\t/* Allocate and initialize real frame array. */\n\terr = usb_allocmem(&sc->sc_bus, \n\t\t  UHCI_FRAMELIST_COUNT * sizeof(uhci_physaddr_t),\n\t\t  UHCI_FRAMELIST_ALIGN, &sc->sc_dma);\n\tif (err)\n\t\treturn (err);\n\tsc->sc_pframes = KERNADDR(&sc->sc_dma);\n\tUWRITE2(sc, UHCI_FRNUM, 0);\t\t/* set frame number to 0 */\n\tUWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma)); /* set frame list*/\n\n\t/* Allocate the dummy QH where bulk traffic will be queued. */\n\tbsqh = uhci_alloc_sqh(sc);\n\tif (bsqh == NULL)\n\t\treturn (USBD_NOMEM);\n\tbsqh->qh.qh_hlink = htole32(UHCI_PTR_T);\t/* end of QH chain */\n\tbsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\tsc->sc_bulk_start = sc->sc_bulk_end = bsqh;\n\n\t/* Allocate the dummy QH where control traffic will be queued. */\n\tcsqh = uhci_alloc_sqh(sc);\n\tif (csqh == NULL)\n\t\treturn (USBD_NOMEM);\n\tcsqh->hlink = bsqh;\n\tcsqh->qh.qh_hlink = htole32(bsqh->physaddr | UHCI_PTR_Q);\n\tcsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\tsc->sc_ctl_start = sc->sc_ctl_end = csqh;\n\n\t/* \n\t * Make all (virtual) frame list pointers point to the interrupt\n\t * queue heads and the interrupt queue heads at the control\n\t * queue head and point the physical frame list to the virtual.\n\t */\n\tfor(i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = uhci_alloc_std(sc);\n\t\tsqh = uhci_alloc_sqh(sc);\n\t\tif (std == NULL || sqh == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t\tstd->link.sqh = sqh;\n\t\tstd->td.td_link = htole32(sqh->physaddr | UHCI_PTR_Q);\n\t\tstd->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */\n\t\tstd->td.td_token = htole32(0);\n\t\tstd->td.td_buffer = htole32(0);\n\t\tsqh->hlink = csqh;\n\t\tsqh->qh.qh_hlink = htole32(csqh->physaddr | UHCI_PTR_Q);\n\t\tsqh->elink = 0;\n\t\tsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\t\tsc->sc_vframes[i].htd = std;\n\t\tsc->sc_vframes[i].etd = std;\n\t\tsc->sc_vframes[i].hqh = sqh;\n\t\tsc->sc_vframes[i].eqh = sqh;\n\t\tfor (j = i; \n\t\t     j < UHCI_FRAMELIST_COUNT; \n\t\t     j += UHCI_VFRAMELIST_COUNT)\n\t\t\tsc->sc_pframes[j] = htole32(std->physaddr);\n\t}\n\n\tLIST_INIT(&sc->sc_intrhead);\n\n\tSIMPLEQ_INIT(&sc->sc_free_xfers);\n\n\tusb_callout_init(sc->sc_poll_handle);\n\n\t/* Set up the bus struct. */\n\tsc->sc_bus.methods = &uhci_bus_methods;\n\tsc->sc_bus.pipe_size = sizeof(struct uhci_pipe);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tsc->sc_suspend = PWR_RESUME;\n\tsc->sc_powerhook = powerhook_establish(uhci_power, sc);\n\tsc->sc_shutdownhook = shutdownhook_establish(uhci_shutdown, sc);\n#endif\n\n\tDPRINTFN(1,(\"uhci_init: enabling\\n\"));\n\tUWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | \n\t\tUHCI_INTR_IOCE | UHCI_INTR_SPIE);\t/* enable interrupts */\n\n\tUHCICMD(sc, UHCI_CMD_MAXP); /* Assume 64 byte packets at frame end */\n\n\treturn (uhci_run(sc, 1));\t\t/* and here we go... */\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static usbd_status",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "Static uhci_soft_qh_t",
            "uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "Static usbd_status",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "Static usbd_status",
            "uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));",
            "uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));",
            "Static usbd_status",
            "Static __inline__ uhci_soft_qh_t",
            "struct usbd_bus_methods uhci_bus_methods = {\n\tuhci_open,\n\tuhci_softintr,\n\tuhci_poll,\n\tuhci_allocm,\n\tuhci_freem,\n\tuhci_allocx,\n\tuhci_freex,\n};",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic usbd_status;\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nStatic uhci_soft_qh_t;\nuhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nStatic usbd_status;\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));\nuhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nStatic usbd_status;\nuhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));\nuhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));\nStatic usbd_status;\nStatic __inline__ uhci_soft_qh_t;\nstruct usbd_bus_methods uhci_bus_methods = {\n\tuhci_open,\n\tuhci_softintr,\n\tuhci_poll,\n\tuhci_allocm,\n\tuhci_freem,\n\tuhci_allocx,\n\tuhci_freex,\n};\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nusbd_status\nuhci_init(sc)\n\tuhci_softc_t *sc;\n{\n\tusbd_status err;\n\tint i, j;\n\tuhci_soft_qh_t *csqh, *bsqh, *sqh;\n\tuhci_soft_td_t *std;\n\n\tDPRINTFN(1,(\"uhci_init: start\\n\"));\n\n#ifdef UHCI_DEBUG\n\tthesc = sc;\n\n\tif (uhcidebug > 2)\n\t\tuhci_dumpregs(sc);\n#endif\n\n\tuhci_run(sc, 0);\t\t\t/* stop the controller */\n\tUWRITE2(sc, UHCI_INTR, 0);\t\t/* disable interrupts */\n\n\tuhci_busreset(sc);\n\n\t/* Allocate and initialize real frame array. */\n\terr = usb_allocmem(&sc->sc_bus, \n\t\t  UHCI_FRAMELIST_COUNT * sizeof(uhci_physaddr_t),\n\t\t  UHCI_FRAMELIST_ALIGN, &sc->sc_dma);\n\tif (err)\n\t\treturn (err);\n\tsc->sc_pframes = KERNADDR(&sc->sc_dma);\n\tUWRITE2(sc, UHCI_FRNUM, 0);\t\t/* set frame number to 0 */\n\tUWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma)); /* set frame list*/\n\n\t/* Allocate the dummy QH where bulk traffic will be queued. */\n\tbsqh = uhci_alloc_sqh(sc);\n\tif (bsqh == NULL)\n\t\treturn (USBD_NOMEM);\n\tbsqh->qh.qh_hlink = htole32(UHCI_PTR_T);\t/* end of QH chain */\n\tbsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\tsc->sc_bulk_start = sc->sc_bulk_end = bsqh;\n\n\t/* Allocate the dummy QH where control traffic will be queued. */\n\tcsqh = uhci_alloc_sqh(sc);\n\tif (csqh == NULL)\n\t\treturn (USBD_NOMEM);\n\tcsqh->hlink = bsqh;\n\tcsqh->qh.qh_hlink = htole32(bsqh->physaddr | UHCI_PTR_Q);\n\tcsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\tsc->sc_ctl_start = sc->sc_ctl_end = csqh;\n\n\t/* \n\t * Make all (virtual) frame list pointers point to the interrupt\n\t * queue heads and the interrupt queue heads at the control\n\t * queue head and point the physical frame list to the virtual.\n\t */\n\tfor(i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {\n\t\tstd = uhci_alloc_std(sc);\n\t\tsqh = uhci_alloc_sqh(sc);\n\t\tif (std == NULL || sqh == NULL)\n\t\t\treturn (USBD_NOMEM);\n\t\tstd->link.sqh = sqh;\n\t\tstd->td.td_link = htole32(sqh->physaddr | UHCI_PTR_Q);\n\t\tstd->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */\n\t\tstd->td.td_token = htole32(0);\n\t\tstd->td.td_buffer = htole32(0);\n\t\tsqh->hlink = csqh;\n\t\tsqh->qh.qh_hlink = htole32(csqh->physaddr | UHCI_PTR_Q);\n\t\tsqh->elink = 0;\n\t\tsqh->qh.qh_elink = htole32(UHCI_PTR_T);\n\t\tsc->sc_vframes[i].htd = std;\n\t\tsc->sc_vframes[i].etd = std;\n\t\tsc->sc_vframes[i].hqh = sqh;\n\t\tsc->sc_vframes[i].eqh = sqh;\n\t\tfor (j = i; \n\t\t     j < UHCI_FRAMELIST_COUNT; \n\t\t     j += UHCI_VFRAMELIST_COUNT)\n\t\t\tsc->sc_pframes[j] = htole32(std->physaddr);\n\t}\n\n\tLIST_INIT(&sc->sc_intrhead);\n\n\tSIMPLEQ_INIT(&sc->sc_free_xfers);\n\n\tusb_callout_init(sc->sc_poll_handle);\n\n\t/* Set up the bus struct. */\n\tsc->sc_bus.methods = &uhci_bus_methods;\n\tsc->sc_bus.pipe_size = sizeof(struct uhci_pipe);\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tsc->sc_suspend = PWR_RESUME;\n\tsc->sc_powerhook = powerhook_establish(uhci_power, sc);\n\tsc->sc_shutdownhook = shutdownhook_establish(uhci_shutdown, sc);\n#endif\n\n\tDPRINTFN(1,(\"uhci_init: enabling\\n\"));\n\tUWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | \n\t\tUHCI_INTR_IOCE | UHCI_INTR_SPIE);\t/* enable interrupts */\n\n\tUHCICMD(sc, UHCI_CMD_MAXP); /* Assume 64 byte packets at frame end */\n\n\treturn (uhci_run(sc, 1));\t\t/* and here we go... */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_USBREV"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_LEGSUP",
            "legsup"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_LEGSUP"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_USB",
            "uhci_intr",
            "sc",
            "sc->sc.sc_bus.bdev.dv_xname"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "csr | PCI_COMMAND_MASTER_ENABLE"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "sc->sc.iot",
            "sc->sc.ioh",
            "UHCI_INTR",
            "0"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "PCI_CBIO",
            "PCI_MAPREG_TYPE_IO",
            "0",
            "&sc->sc.iot",
            "&sc->sc.ioh",
            "NULL",
            "NULL"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tuhci_pci_attach;\n\nvoid\nuhci_pci_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct uhci_pci_softc *sc = (struct uhci_pci_softc *)self;\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tchar const *intrstr;\n\tpci_intr_handle_t ih;\n\tpcireg_t csr, legsup;\n\tusbd_status r;\n\n\n\t/* Map I/O registers */\n\tif (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,\n\t\t\t   &sc->sc.iot, &sc->sc.ioh, NULL, NULL)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\t/* Disable interrupts, so we don't get any spurious ones. */\n\tbus_space_write_2(sc->sc.iot, sc->sc.ioh, UHCI_INTR, 0);\n\n\tsc->sc_pc = pc;\n\tsc->sc.sc_bus.dmatag = pa->pa_dmat;\n\n\t/* Enable the device. */\n\tcsr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t       csr | PCI_COMMAND_MASTER_ENABLE);\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_USB, uhci_intr, sc,\n\t    sc->sc.sc_bus.bdev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": %s\\n\", intrstr);\n\n\t/* Verify that the PIRQD enable bit is set, some BIOS's don't do that*/\n\tlegsup = pci_conf_read(pc, pa->pa_tag, PCI_LEGSUP);\n\tif (!(legsup & PCI_LEGSUP_USBPIRQDEN)) {\n\t\tlegsup = PCI_LEGSUP_USBPIRQDEN;\n\t\tpci_conf_write(pc, pa->pa_tag, PCI_LEGSUP, legsup);\n\t}\n\n\tswitch(pci_conf_read(pc, pa->pa_tag, PCI_USBREV) & PCI_USBREV_MASK) {\n\tcase PCI_USBREV_PRE_1_0:\n\t\tsc->sc.sc_bus.usbrev = USBREV_PRE_1_0;\n\t\tbreak;\n\tcase PCI_USBREV_1_0:\n\t\tsc->sc.sc_bus.usbrev = USBREV_1_0;\n\t\tbreak;\n\tcase PCI_USBREV_1_1:\n\t\tsc->sc.sc_bus.usbrev = USBREV_1_1;\n\t\tbreak;\n\tdefault:\n\t\tsc->sc.sc_bus.usbrev = USBREV_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tr = uhci_init(&sc->sc);\n\tif (r != USBD_NORMAL_COMPLETION) {\n\t\tprintf(\"%s: init failed, error=%d\\n\", \n\t\t       sc->sc.sc_bus.bdev.dv_xname, r);\n\t\treturn;\n\t}\n\n\t/* Attach usb device. */\n\tsc->sc.sc_child = config_found((void *)sc, &sc->sc.sc_bus,\n\t\t\t\t       usbctlprint);\n}"
  },
  {
    "function_name": "uhci_pci_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/uhci_pci.c",
    "lines": "76-89",
    "snippet": "int\nuhci_pci_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_CLASS(pa->pa_class) == PCI_CLASS_SERIALBUS &&\n\t    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_SERIALBUS_USB &&\n\t    PCI_INTERFACE(pa->pa_class) == PCI_INTERFACE_UHCI)\n\t\treturn (1);\n \n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/uhcivar.h>",
      "#include <dev/usb/uhcireg.h>",
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <machine/bus.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tuhci_pci_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_INTERFACE",
          "args": [
            "pa->pa_class"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SUBCLASS",
          "args": [
            "pa->pa_class"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CLASS",
          "args": [
            "pa->pa_class"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tuhci_pci_match;\n\nint\nuhci_pci_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_CLASS(pa->pa_class) == PCI_CLASS_SERIALBUS &&\n\t    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_SERIALBUS_USB &&\n\t    PCI_INTERFACE(pa->pa_class) == PCI_INTERFACE_UHCI)\n\t\treturn (1);\n \n\treturn (0);\n}"
  }
]