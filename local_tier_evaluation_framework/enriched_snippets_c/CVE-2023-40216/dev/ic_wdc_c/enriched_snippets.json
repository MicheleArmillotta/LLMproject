[
  {
    "function_name": "wdc_delref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1700-1713",
    "snippet": "void\nwdc_delref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt-- == 1 &&\n\t    adapter->scsipi_enable != NULL)\n\t\t(void) (*adapter->scsipi_enable)(wdc, 0);\n\tsplx(s);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "wdc",
            "0"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_delref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt-- == 1 &&\n\t    adapter->scsipi_enable != NULL)\n\t\t(void) (*adapter->scsipi_enable)(wdc, 0);\n\tsplx(s);\n}"
  },
  {
    "function_name": "wdc_addref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1681-1698",
    "snippet": "int\nwdc_addref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc; \n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s, error = 0;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt++ == 0 &&\n\t    adapter->scsipi_enable != NULL) {\n\t\terror = (*adapter->scsipi_enable)(wdc, 1);\n\t\tif (error)\n\t\t\tadapter->scsipi_refcnt--;\n\t}\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "wdc",
            "1"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwdc_addref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc; \n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s, error = 0;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt++ == 0 &&\n\t    adapter->scsipi_enable != NULL) {\n\t\terror = (*adapter->scsipi_enable)(wdc, 1);\n\t\tif (error)\n\t\t\tadapter->scsipi_refcnt--;\n\t}\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "wdcbit_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1672-1678",
    "snippet": "void\nwdcbit_bucket(chp, size)\n\tstruct channel_softc *chp; \n\tint size;\n{\n\tCHP_READ_RAW_MULTI_2(chp, NULL, size);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHP_READ_RAW_MULTI_2",
          "args": [
            "chp",
            "NULL",
            "size"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdcbit_bucket(chp, size)\n\tstruct channel_softc *chp; \n\tint size;\n{\n\tCHP_READ_RAW_MULTI_2(chp, NULL, size);\n}"
  },
  {
    "function_name": "__wdcerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1653-1667",
    "snippet": "static void\n__wdcerror(chp, msg) \n\tstruct channel_softc *chp;\n\tchar *msg;\n{\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tif (xfer == NULL)\n\t\tprintf(\"%s:%d: %s\\n\", chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t    msg);\n\telse \n\t\tprintf(\"%s(%s:%d:%d): %s\\n\", \n\t\t    chp->ch_drive[xfer->drive].drive_name,\n\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t    chp->channel, xfer->drive, msg);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void  __wdcerror"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s(%s:%d:%d): %s\\n\"",
            "chp->ch_drive[xfer->drive].drive_name",
            "chp->wdc->sc_dev.dv_xname",
            "chp->channel",
            "xfer->drive",
            "msg"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void  __wdcerror;\n\nstatic void\n__wdcerror(chp, msg) \n\tstruct channel_softc *chp;\n\tchar *msg;\n{\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tif (xfer == NULL)\n\t\tprintf(\"%s:%d: %s\\n\", chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t    msg);\n\telse \n\t\tprintf(\"%s(%s:%d:%d): %s\\n\", \n\t\t    chp->ch_drive[xfer->drive].drive_name,\n\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t    chp->channel, xfer->drive, msg);\n}"
  },
  {
    "function_name": "wdc_kill_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1641-1651",
    "snippet": "void\nwdc_kill_pending(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n\twhile ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) != NULL) {\n\t\tchp = xfer->chp;\n\t\t(*xfer->c_kill_xfer)(chp, xfer);\n\t}\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void  wdc_kill_pending"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&chp->ch_queue->sc_xfer"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid  wdc_kill_pending;\n\nvoid\nwdc_kill_pending(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n\twhile ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) != NULL) {\n\t\tchp = xfer->chp;\n\t\t(*xfer->c_kill_xfer)(chp, xfer);\n\t}\n}"
  },
  {
    "function_name": "wdc_free_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1617-1633",
    "snippet": "void\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&xfer_free_list",
            "xfer",
            "free_list"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&chp->ch_queue->sc_xfer",
            "xfer",
            "c_xferchain"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}"
  },
  {
    "function_name": "wdc_exec_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1552-1577",
    "snippet": "void\nwdc_exec_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tWDCDEBUG_PRINT((\"wdc_exec_xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\n\t/* complete xfer setup */\n\txfer->chp = chp;\n\n\t/*\n\t * If we are a polled command, and the list is not empty,\n\t * we are doing a dump. Drop the list to allow the polled command\n\t * to complete, we're going to reboot soon anyway.\n\t */\n\tif ((xfer->c_flags & C_POLL) != 0 &&\n\t    chp->ch_queue->sc_xfer.tqh_first != NULL) {\n\t\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t}\n\t/* insert at the end of command list */\n\tTAILQ_INSERT_TAIL(&chp->ch_queue->sc_xfer,xfer , c_xferchain);\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_exec_xfer, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdcstart",
          "args": [
            "chp"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "wdcstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "664-710",
          "snippet": "void\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdcstart from wdc_exec_xfer, flags 0x%x\\n\",\n\t    chp->ch_flags)",
            "DEBUG_XFERS"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&chp->ch_queue->sc_xfer",
            "xfer",
            "c_xferchain"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&chp->ch_queue->sc_xfer"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_exec_xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive)",
            "DEBUG_XFERS"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nvoid\nwdc_exec_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tWDCDEBUG_PRINT((\"wdc_exec_xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\n\t/* complete xfer setup */\n\txfer->chp = chp;\n\n\t/*\n\t * If we are a polled command, and the list is not empty,\n\t * we are doing a dump. Drop the list to allow the polled command\n\t * to complete, we're going to reboot soon anyway.\n\t */\n\tif ((xfer->c_flags & C_POLL) != 0 &&\n\t    chp->ch_queue->sc_xfer.tqh_first != NULL) {\n\t\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t}\n\t/* insert at the end of command list */\n\tTAILQ_INSERT_TAIL(&chp->ch_queue->sc_xfer,xfer , c_xferchain);\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_exec_xfer, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}"
  },
  {
    "function_name": "wdccommandshort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1534-1548",
    "snippet": "void\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_command",
            "command"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (drive << 4)"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command)",
            "DEBUG_FUNCS"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}"
  },
  {
    "function_name": "wdccommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1502-1528",
    "snippet": "void\nwdccommand(chp, drive, command, cylin, head, sector, count, precomp)\n\tstruct channel_softc *chp;\n\tu_int8_t drive;\n\tu_int8_t command;\n\tu_int16_t cylin;\n\tu_int8_t head, sector, count, precomp;\n{\n\tWDCDEBUG_PRINT((\"wdccommand %s:%d:%d: command=0x%x cylin=%d head=%d \"\n\t    \"sector=%d count=%d precomp=%d\\n\", chp->wdc->sc_dev.dv_xname,\n\t    chp->channel, drive, command, cylin, head, sector, count, precomp),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive, head, and addressing mode. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4) | head);\n\n\t/* Load parameters. wdr_features(ATA/ATAPI) = wdr_precomp(ST506) */\n\tCHP_WRITE_REG(chp, wdr_precomp, precomp);\n\tCHP_WRITE_REG(chp, wdr_cyl_lo, cylin);\n\tCHP_WRITE_REG(chp, wdr_cyl_hi, cylin >> 8);\n\tCHP_WRITE_REG(chp, wdr_sector, sector);\n\tCHP_WRITE_REG(chp, wdr_seccnt, count);\n\n\t/* Send command. */\n\tCHP_WRITE_REG(chp, wdr_command, command);\n\treturn;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_command",
            "command"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_seccnt",
            "count"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sector",
            "sector"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_cyl_hi",
            "cylin >> 8"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_cyl_lo",
            "cylin"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_precomp",
            "precomp"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (drive << 4) | head"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdccommand %s:%d:%d: command=0x%x cylin=%d head=%d \"\n\t    \"sector=%d count=%d precomp=%d\\n\", chp->wdc->sc_dev.dv_xname,\n\t    chp->channel, drive, command, cylin, head, sector, count, precomp)",
            "DEBUG_FUNCS"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid\nwdccommand(chp, drive, command, cylin, head, sector, count, precomp)\n\tstruct channel_softc *chp;\n\tu_int8_t drive;\n\tu_int8_t command;\n\tu_int16_t cylin;\n\tu_int8_t head, sector, count, precomp;\n{\n\tWDCDEBUG_PRINT((\"wdccommand %s:%d:%d: command=0x%x cylin=%d head=%d \"\n\t    \"sector=%d count=%d precomp=%d\\n\", chp->wdc->sc_dev.dv_xname,\n\t    chp->channel, drive, command, cylin, head, sector, count, precomp),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive, head, and addressing mode. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4) | head);\n\n\t/* Load parameters. wdr_features(ATA/ATAPI) = wdr_precomp(ST506) */\n\tCHP_WRITE_REG(chp, wdr_precomp, precomp);\n\tCHP_WRITE_REG(chp, wdr_cyl_lo, cylin);\n\tCHP_WRITE_REG(chp, wdr_cyl_hi, cylin >> 8);\n\tCHP_WRITE_REG(chp, wdr_sector, sector);\n\tCHP_WRITE_REG(chp, wdr_seccnt, count);\n\n\t/* Send command. */\n\tCHP_WRITE_REG(chp, wdr_command, command);\n\treturn;\n}"
  },
  {
    "function_name": "__wdccommand_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1454-1496",
    "snippet": "void\n__wdccommand_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_done %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_FUNCS);\n\tif (chp->ch_status & WDCS_DWF)\n\t\twdc_c->flags |= AT_DF;\n\tif (chp->ch_status & WDCS_ERR) {\n\t\twdc_c->flags |= AT_ERROR;\n\t\twdc_c->r_error = chp->ch_error;\n\t}\n\twdc_c->flags |= AT_DONE;\n\tif (wdc_c->flags & AT_READREG && (wdc_c->flags & (AT_ERROR | AT_DF))\n\t\t\t\t\t\t\t\t== 0) {\n\t\twdc_c->r_head = CHP_READ_REG(chp, wdr_sdh);\n\t\twdc_c->r_cyl = CHP_READ_REG(chp, wdr_cyl_hi) << 8;\n\t\twdc_c->r_cyl |= CHP_READ_REG(chp, wdr_cyl_lo);\n\t\twdc_c->r_sector = CHP_READ_REG(chp, wdr_sector);\n\t\twdc_c->r_count = CHP_READ_REG(chp, wdr_seccnt);\n\t\twdc_c->r_error = CHP_READ_REG(chp, wdr_error);\n\t\twdc_c->r_precomp = wdc_c->r_error; \n\t\t/* XXX CHP_READ_REG(chp, wdr_precomp); - precomp\n\t\t   isn't a readable register */\n\t}\n\tif (xfer->c_flags & C_POLL) {\n\t\twdc_enable_intr(chp);\n\t}\n\twdc_free_xfer(chp, xfer);\n\tWDCDEBUG_PRINT((\"__wdccommand_done before callback\\n\"), DEBUG_INTR);\n\n\tif (wdc_c->flags & AT_WAIT)\n\t\twakeup(wdc_c);\n\telse\n\t\tif (wdc_c->callback)\n\t\t\twdc_c->callback(wdc_c->callback_arg);\n\twdcstart(chp);\n\tWDCDEBUG_PRINT((\"__wdccommand_done returned\\n\"), DEBUG_INTR);\n\treturn;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08",
      "#define DEBUG_INTR   0x01"
    ],
    "globals_used": [
      "void  __wdccommand_done",
      "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"__wdccommand_done returned\\n\")",
            "DEBUG_INTR"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdcstart",
          "args": [
            "chp"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "wdcstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "664-710",
          "snippet": "void\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_c->callback",
          "args": [
            "wdc_c->callback_arg"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "wdc_c"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"__wdccommand_done before callback\\n\")",
            "DEBUG_INTR"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_free_xfer",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1617-1633",
          "snippet": "void\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_enable_intr",
          "args": [
            "chp"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_enable_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "314-319",
          "snippet": "void\nwdc_enable_intr(chp)\n\tstruct channel_softc *chp;\n{\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_enable_intr(chp)\n\tstruct channel_softc *chp;\n{\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_error"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_seccnt"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_sector"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_cyl_lo"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_cyl_hi"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_sdh"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"__wdccommand_done %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive)",
            "DEBUG_FUNCS"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n#define DEBUG_INTR   0x01\n\nvoid  __wdccommand_done;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nvoid\n__wdccommand_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_done %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_FUNCS);\n\tif (chp->ch_status & WDCS_DWF)\n\t\twdc_c->flags |= AT_DF;\n\tif (chp->ch_status & WDCS_ERR) {\n\t\twdc_c->flags |= AT_ERROR;\n\t\twdc_c->r_error = chp->ch_error;\n\t}\n\twdc_c->flags |= AT_DONE;\n\tif (wdc_c->flags & AT_READREG && (wdc_c->flags & (AT_ERROR | AT_DF))\n\t\t\t\t\t\t\t\t== 0) {\n\t\twdc_c->r_head = CHP_READ_REG(chp, wdr_sdh);\n\t\twdc_c->r_cyl = CHP_READ_REG(chp, wdr_cyl_hi) << 8;\n\t\twdc_c->r_cyl |= CHP_READ_REG(chp, wdr_cyl_lo);\n\t\twdc_c->r_sector = CHP_READ_REG(chp, wdr_sector);\n\t\twdc_c->r_count = CHP_READ_REG(chp, wdr_seccnt);\n\t\twdc_c->r_error = CHP_READ_REG(chp, wdr_error);\n\t\twdc_c->r_precomp = wdc_c->r_error; \n\t\t/* XXX CHP_READ_REG(chp, wdr_precomp); - precomp\n\t\t   isn't a readable register */\n\t}\n\tif (xfer->c_flags & C_POLL) {\n\t\twdc_enable_intr(chp);\n\t}\n\twdc_free_xfer(chp, xfer);\n\tWDCDEBUG_PRINT((\"__wdccommand_done before callback\\n\"), DEBUG_INTR);\n\n\tif (wdc_c->flags & AT_WAIT)\n\t\twakeup(wdc_c);\n\telse\n\t\tif (wdc_c->callback)\n\t\t\twdc_c->callback(wdc_c->callback_arg);\n\twdcstart(chp);\n\tWDCDEBUG_PRINT((\"__wdccommand_done returned\\n\"), DEBUG_INTR);\n\treturn;\n}"
  },
  {
    "function_name": "__wdccommand_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1422-1452",
    "snippet": "int\n__wdccommand_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\tint bcount = wdc_c->bcount;\n\tchar *data = wdc_c->data;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_intr %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_INTR);\n\tif (wdcwait(chp, wdc_c->r_st_pmask, wdc_c->r_st_pmask,\n\t     (irq == 0)  ? wdc_c->timeout : 0)) {\n\t\tif (irq && (xfer->c_flags & C_TIMEOU) == 0) \n\t\t\treturn 0; /* IRQ was not for us */\n\t\twdc_c->flags |= AT_TIMEOU;\n\t\t__wdccommand_done(chp, xfer);\n\t\tWDCDEBUG_PRINT((\"__wdccommand_intr returned\\n\"), DEBUG_INTR);\n\t\treturn 1;\n\t}\n\tif (wdc_c->flags & AT_READ) {\n\t\twdc_input_bytes(drvp, data, bcount);\n\t} else if (wdc_c->flags & AT_WRITE) {\n\t\twdc_output_bytes(drvp, data, bcount);\n\t}\n\t__wdccommand_done(chp, xfer);\n\tWDCDEBUG_PRINT((\"__wdccommand_intr returned\\n\"), DEBUG_INTR);\n\treturn 1;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_INTR   0x01"
    ],
    "globals_used": [
      "void  __wdccommand_done",
      "int   __wdccommand_intr",
      "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"__wdccommand_intr returned\\n\")",
            "DEBUG_INTR"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wdccommand_done",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "__wdccommand_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1454-1496",
          "snippet": "void\n__wdccommand_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_done %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_FUNCS);\n\tif (chp->ch_status & WDCS_DWF)\n\t\twdc_c->flags |= AT_DF;\n\tif (chp->ch_status & WDCS_ERR) {\n\t\twdc_c->flags |= AT_ERROR;\n\t\twdc_c->r_error = chp->ch_error;\n\t}\n\twdc_c->flags |= AT_DONE;\n\tif (wdc_c->flags & AT_READREG && (wdc_c->flags & (AT_ERROR | AT_DF))\n\t\t\t\t\t\t\t\t== 0) {\n\t\twdc_c->r_head = CHP_READ_REG(chp, wdr_sdh);\n\t\twdc_c->r_cyl = CHP_READ_REG(chp, wdr_cyl_hi) << 8;\n\t\twdc_c->r_cyl |= CHP_READ_REG(chp, wdr_cyl_lo);\n\t\twdc_c->r_sector = CHP_READ_REG(chp, wdr_sector);\n\t\twdc_c->r_count = CHP_READ_REG(chp, wdr_seccnt);\n\t\twdc_c->r_error = CHP_READ_REG(chp, wdr_error);\n\t\twdc_c->r_precomp = wdc_c->r_error; \n\t\t/* XXX CHP_READ_REG(chp, wdr_precomp); - precomp\n\t\t   isn't a readable register */\n\t}\n\tif (xfer->c_flags & C_POLL) {\n\t\twdc_enable_intr(chp);\n\t}\n\twdc_free_xfer(chp, xfer);\n\tWDCDEBUG_PRINT((\"__wdccommand_done before callback\\n\"), DEBUG_INTR);\n\n\tif (wdc_c->flags & AT_WAIT)\n\t\twakeup(wdc_c);\n\telse\n\t\tif (wdc_c->callback)\n\t\t\twdc_c->callback(wdc_c->callback_arg);\n\twdcstart(chp);\n\tWDCDEBUG_PRINT((\"__wdccommand_done returned\\n\"), DEBUG_INTR);\n\treturn;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08",
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [
            "void  __wdccommand_done",
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n#define DEBUG_INTR   0x01\n\nvoid  __wdccommand_done;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nvoid\n__wdccommand_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_done %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_FUNCS);\n\tif (chp->ch_status & WDCS_DWF)\n\t\twdc_c->flags |= AT_DF;\n\tif (chp->ch_status & WDCS_ERR) {\n\t\twdc_c->flags |= AT_ERROR;\n\t\twdc_c->r_error = chp->ch_error;\n\t}\n\twdc_c->flags |= AT_DONE;\n\tif (wdc_c->flags & AT_READREG && (wdc_c->flags & (AT_ERROR | AT_DF))\n\t\t\t\t\t\t\t\t== 0) {\n\t\twdc_c->r_head = CHP_READ_REG(chp, wdr_sdh);\n\t\twdc_c->r_cyl = CHP_READ_REG(chp, wdr_cyl_hi) << 8;\n\t\twdc_c->r_cyl |= CHP_READ_REG(chp, wdr_cyl_lo);\n\t\twdc_c->r_sector = CHP_READ_REG(chp, wdr_sector);\n\t\twdc_c->r_count = CHP_READ_REG(chp, wdr_seccnt);\n\t\twdc_c->r_error = CHP_READ_REG(chp, wdr_error);\n\t\twdc_c->r_precomp = wdc_c->r_error; \n\t\t/* XXX CHP_READ_REG(chp, wdr_precomp); - precomp\n\t\t   isn't a readable register */\n\t}\n\tif (xfer->c_flags & C_POLL) {\n\t\twdc_enable_intr(chp);\n\t}\n\twdc_free_xfer(chp, xfer);\n\tWDCDEBUG_PRINT((\"__wdccommand_done before callback\\n\"), DEBUG_INTR);\n\n\tif (wdc_c->flags & AT_WAIT)\n\t\twakeup(wdc_c);\n\telse\n\t\tif (wdc_c->callback)\n\t\t\twdc_c->callback(wdc_c->callback_arg);\n\twdcstart(chp);\n\tWDCDEBUG_PRINT((\"__wdccommand_done returned\\n\"), DEBUG_INTR);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_output_bytes",
          "args": [
            "drvp",
            "data",
            "bcount"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_output_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1164-1192",
          "snippet": "void\nwdc_output_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\t\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_WRITE_RAW_MULTI_4(chp, \n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t        CHP_WRITE_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_output_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\t\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_WRITE_RAW_MULTI_4(chp, \n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t        CHP_WRITE_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_input_bytes",
          "args": [
            "drvp",
            "data",
            "bcount"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_input_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1194-1222",
          "snippet": "void\nwdc_input_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_READ_RAW_MULTI_4(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t\tCHP_READ_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_input_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_READ_RAW_MULTI_4(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t\tCHP_READ_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"__wdccommand_intr returned\\n\")",
            "DEBUG_INTR"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdcwait",
          "args": [
            "chp",
            "wdc_c->r_st_pmask",
            "wdc_c->r_st_pmask",
            "(irq == 0)  ? wdc_c->timeout : 0"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "wdcwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "879-950",
          "snippet": "int\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_STATUSX 0x20",
            "#define DEBUG_STATUS 0x04",
            "#define WDCNDELAY_DEBUG\t50",
            "#define WDCDELAY  100 /* 100 microseconds */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_STATUSX 0x20\n#define DEBUG_STATUS 0x04\n#define WDCNDELAY_DEBUG\t50\n#define WDCDELAY  100 /* 100 microseconds */\n\nint\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"__wdccommand_intr %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive)",
            "DEBUG_INTR"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_INTR   0x01\n\nvoid  __wdccommand_done;\nint   __wdccommand_intr;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nint\n__wdccommand_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\tint bcount = wdc_c->bcount;\n\tchar *data = wdc_c->data;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_intr %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_INTR);\n\tif (wdcwait(chp, wdc_c->r_st_pmask, wdc_c->r_st_pmask,\n\t     (irq == 0)  ? wdc_c->timeout : 0)) {\n\t\tif (irq && (xfer->c_flags & C_TIMEOU) == 0) \n\t\t\treturn 0; /* IRQ was not for us */\n\t\twdc_c->flags |= AT_TIMEOU;\n\t\t__wdccommand_done(chp, xfer);\n\t\tWDCDEBUG_PRINT((\"__wdccommand_intr returned\\n\"), DEBUG_INTR);\n\t\treturn 1;\n\t}\n\tif (wdc_c->flags & AT_READ) {\n\t\twdc_input_bytes(drvp, data, bcount);\n\t} else if (wdc_c->flags & AT_WRITE) {\n\t\twdc_output_bytes(drvp, data, bcount);\n\t}\n\t__wdccommand_done(chp, xfer);\n\tWDCDEBUG_PRINT((\"__wdccommand_intr returned\\n\"), DEBUG_INTR);\n\treturn 1;\n}"
  },
  {
    "function_name": "__wdccommand_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1371-1420",
    "snippet": "void\n__wdccommand_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{   \n\tint drive = xfer->drive;\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_FUNCS);\n\n\t/*\n\t * Disable interrupts if we're polling\n\t */\n\n\tif (xfer->c_flags & C_POLL) {\n\t\twdc_disable_intr(chp);\n\t}\n\n\t/*\n\t * For resets, we don't really care to make sure that\n\t * the bus is free\n\t */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\n\tif (wdc_c->r_command != ATAPI_SOFT_RESET) {\n\t\tif (wdcwait(chp, wdc_c->r_st_bmask, wdc_c->r_st_bmask,\n\t\t    wdc_c->timeout) != 0) {\n\t\t\twdc_c->flags |= AT_TIMEOU;\n\t\t\t__wdccommand_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tDELAY(10);\n\n\twdccommand(chp, drive, wdc_c->r_command, wdc_c->r_cyl, wdc_c->r_head,\n\t    wdc_c->r_sector, wdc_c->r_count, wdc_c->r_precomp);\n\tif ((wdc_c->flags & AT_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT; /* wait for interrupt */\n\t\ttimeout(wdctimeout, chp, wdc_c->timeout / 1000 * hz);\n\t\treturn;\n\t}\n\t/*\n\t * Polled command. Wait for drive ready or drq. Done in intr().\n\t * Wait for at last 400ns for status bit to be valid.\n\t */\n\tdelay(10);\n\t__wdccommand_intr(chp, xfer, 0);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [
      "void  __wdccommand_done",
      "void  __wdccommand_start",
      "int   __wdccommand_intr",
      "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wdccommand_intr",
          "args": [
            "chp",
            "xfer",
            "0"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "__wdccommand_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1422-1452",
          "snippet": "int\n__wdccommand_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\tint bcount = wdc_c->bcount;\n\tchar *data = wdc_c->data;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_intr %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_INTR);\n\tif (wdcwait(chp, wdc_c->r_st_pmask, wdc_c->r_st_pmask,\n\t     (irq == 0)  ? wdc_c->timeout : 0)) {\n\t\tif (irq && (xfer->c_flags & C_TIMEOU) == 0) \n\t\t\treturn 0; /* IRQ was not for us */\n\t\twdc_c->flags |= AT_TIMEOU;\n\t\t__wdccommand_done(chp, xfer);\n\t\tWDCDEBUG_PRINT((\"__wdccommand_intr returned\\n\"), DEBUG_INTR);\n\t\treturn 1;\n\t}\n\tif (wdc_c->flags & AT_READ) {\n\t\twdc_input_bytes(drvp, data, bcount);\n\t} else if (wdc_c->flags & AT_WRITE) {\n\t\twdc_output_bytes(drvp, data, bcount);\n\t}\n\t__wdccommand_done(chp, xfer);\n\tWDCDEBUG_PRINT((\"__wdccommand_intr returned\\n\"), DEBUG_INTR);\n\treturn 1;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [
            "void  __wdccommand_done",
            "int   __wdccommand_intr",
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_INTR   0x01\n\nvoid  __wdccommand_done;\nint   __wdccommand_intr;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nint\n__wdccommand_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\tint bcount = wdc_c->bcount;\n\tchar *data = wdc_c->data;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_intr %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_INTR);\n\tif (wdcwait(chp, wdc_c->r_st_pmask, wdc_c->r_st_pmask,\n\t     (irq == 0)  ? wdc_c->timeout : 0)) {\n\t\tif (irq && (xfer->c_flags & C_TIMEOU) == 0) \n\t\t\treturn 0; /* IRQ was not for us */\n\t\twdc_c->flags |= AT_TIMEOU;\n\t\t__wdccommand_done(chp, xfer);\n\t\tWDCDEBUG_PRINT((\"__wdccommand_intr returned\\n\"), DEBUG_INTR);\n\t\treturn 1;\n\t}\n\tif (wdc_c->flags & AT_READ) {\n\t\twdc_input_bytes(drvp, data, bcount);\n\t} else if (wdc_c->flags & AT_WRITE) {\n\t\twdc_output_bytes(drvp, data, bcount);\n\t}\n\t__wdccommand_done(chp, xfer);\n\tWDCDEBUG_PRINT((\"__wdccommand_intr returned\\n\"), DEBUG_INTR);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "wdctimeout",
            "chp",
            "wdc_c->timeout / 1000 * hz"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdccommand",
          "args": [
            "chp",
            "drive",
            "wdc_c->r_command",
            "wdc_c->r_cyl",
            "wdc_c->r_head",
            "wdc_c->r_sector",
            "wdc_c->r_count",
            "wdc_c->r_precomp"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "wdccommandshort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1534-1548",
          "snippet": "void\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wdccommand_done",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "__wdccommand_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1454-1496",
          "snippet": "void\n__wdccommand_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_done %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_FUNCS);\n\tif (chp->ch_status & WDCS_DWF)\n\t\twdc_c->flags |= AT_DF;\n\tif (chp->ch_status & WDCS_ERR) {\n\t\twdc_c->flags |= AT_ERROR;\n\t\twdc_c->r_error = chp->ch_error;\n\t}\n\twdc_c->flags |= AT_DONE;\n\tif (wdc_c->flags & AT_READREG && (wdc_c->flags & (AT_ERROR | AT_DF))\n\t\t\t\t\t\t\t\t== 0) {\n\t\twdc_c->r_head = CHP_READ_REG(chp, wdr_sdh);\n\t\twdc_c->r_cyl = CHP_READ_REG(chp, wdr_cyl_hi) << 8;\n\t\twdc_c->r_cyl |= CHP_READ_REG(chp, wdr_cyl_lo);\n\t\twdc_c->r_sector = CHP_READ_REG(chp, wdr_sector);\n\t\twdc_c->r_count = CHP_READ_REG(chp, wdr_seccnt);\n\t\twdc_c->r_error = CHP_READ_REG(chp, wdr_error);\n\t\twdc_c->r_precomp = wdc_c->r_error; \n\t\t/* XXX CHP_READ_REG(chp, wdr_precomp); - precomp\n\t\t   isn't a readable register */\n\t}\n\tif (xfer->c_flags & C_POLL) {\n\t\twdc_enable_intr(chp);\n\t}\n\twdc_free_xfer(chp, xfer);\n\tWDCDEBUG_PRINT((\"__wdccommand_done before callback\\n\"), DEBUG_INTR);\n\n\tif (wdc_c->flags & AT_WAIT)\n\t\twakeup(wdc_c);\n\telse\n\t\tif (wdc_c->callback)\n\t\t\twdc_c->callback(wdc_c->callback_arg);\n\twdcstart(chp);\n\tWDCDEBUG_PRINT((\"__wdccommand_done returned\\n\"), DEBUG_INTR);\n\treturn;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08",
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [
            "void  __wdccommand_done",
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n#define DEBUG_INTR   0x01\n\nvoid  __wdccommand_done;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nvoid\n__wdccommand_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_done %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive), DEBUG_FUNCS);\n\tif (chp->ch_status & WDCS_DWF)\n\t\twdc_c->flags |= AT_DF;\n\tif (chp->ch_status & WDCS_ERR) {\n\t\twdc_c->flags |= AT_ERROR;\n\t\twdc_c->r_error = chp->ch_error;\n\t}\n\twdc_c->flags |= AT_DONE;\n\tif (wdc_c->flags & AT_READREG && (wdc_c->flags & (AT_ERROR | AT_DF))\n\t\t\t\t\t\t\t\t== 0) {\n\t\twdc_c->r_head = CHP_READ_REG(chp, wdr_sdh);\n\t\twdc_c->r_cyl = CHP_READ_REG(chp, wdr_cyl_hi) << 8;\n\t\twdc_c->r_cyl |= CHP_READ_REG(chp, wdr_cyl_lo);\n\t\twdc_c->r_sector = CHP_READ_REG(chp, wdr_sector);\n\t\twdc_c->r_count = CHP_READ_REG(chp, wdr_seccnt);\n\t\twdc_c->r_error = CHP_READ_REG(chp, wdr_error);\n\t\twdc_c->r_precomp = wdc_c->r_error; \n\t\t/* XXX CHP_READ_REG(chp, wdr_precomp); - precomp\n\t\t   isn't a readable register */\n\t}\n\tif (xfer->c_flags & C_POLL) {\n\t\twdc_enable_intr(chp);\n\t}\n\twdc_free_xfer(chp, xfer);\n\tWDCDEBUG_PRINT((\"__wdccommand_done before callback\\n\"), DEBUG_INTR);\n\n\tif (wdc_c->flags & AT_WAIT)\n\t\twakeup(wdc_c);\n\telse\n\t\tif (wdc_c->callback)\n\t\t\twdc_c->callback(wdc_c->callback_arg);\n\twdcstart(chp);\n\tWDCDEBUG_PRINT((\"__wdccommand_done returned\\n\"), DEBUG_INTR);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcwait",
          "args": [
            "chp",
            "wdc_c->r_st_bmask",
            "wdc_c->r_st_bmask",
            "wdc_c->timeout"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "wdcwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "879-950",
          "snippet": "int\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_STATUSX 0x20",
            "#define DEBUG_STATUS 0x04",
            "#define WDCNDELAY_DEBUG\t50",
            "#define WDCDELAY  100 /* 100 microseconds */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_STATUSX 0x20\n#define DEBUG_STATUS 0x04\n#define WDCNDELAY_DEBUG\t50\n#define WDCDELAY  100 /* 100 microseconds */\n\nint\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (drive << 4)"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_disable_intr",
          "args": [
            "chp"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_disable_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "307-312",
          "snippet": "void\nwdc_disable_intr(chp)\n\tstruct channel_softc *chp;\n{\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_disable_intr(chp)\n\tstruct channel_softc *chp;\n{\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"__wdccommand_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive)",
            "DEBUG_FUNCS"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid  __wdccommand_done;\nvoid  __wdccommand_start;\nint   __wdccommand_intr;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nvoid\n__wdccommand_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{   \n\tint drive = xfer->drive;\n\tstruct wdc_command *wdc_c = xfer->cmd;\n\n\tWDCDEBUG_PRINT((\"__wdccommand_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_FUNCS);\n\n\t/*\n\t * Disable interrupts if we're polling\n\t */\n\n\tif (xfer->c_flags & C_POLL) {\n\t\twdc_disable_intr(chp);\n\t}\n\n\t/*\n\t * For resets, we don't really care to make sure that\n\t * the bus is free\n\t */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\n\tif (wdc_c->r_command != ATAPI_SOFT_RESET) {\n\t\tif (wdcwait(chp, wdc_c->r_st_bmask, wdc_c->r_st_bmask,\n\t\t    wdc_c->timeout) != 0) {\n\t\t\twdc_c->flags |= AT_TIMEOU;\n\t\t\t__wdccommand_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tDELAY(10);\n\n\twdccommand(chp, drive, wdc_c->r_command, wdc_c->r_cyl, wdc_c->r_head,\n\t    wdc_c->r_sector, wdc_c->r_count, wdc_c->r_precomp);\n\tif ((wdc_c->flags & AT_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT; /* wait for interrupt */\n\t\ttimeout(wdctimeout, chp, wdc_c->timeout / 1000 * hz);\n\t\treturn;\n\t}\n\t/*\n\t * Polled command. Wait for drive ready or drq. Done in intr().\n\t * Wait for at last 400ns for status bit to be valid.\n\t */\n\tdelay(10);\n\t__wdccommand_intr(chp, xfer, 0);\n}"
  },
  {
    "function_name": "wdc_exec_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1306-1369",
    "snippet": "int\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [
      "void  __wdccommand_done",
      "void  __wdccommand_start",
      "int   __wdccommand_intr",
      "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_exec_command waking\")",
            "DEBUG_FUNCS"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tsleep error: %d\\n\"",
            "error"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "wdc_c",
            "PRIBIO",
            "\"wdccmd\"",
            "0"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_exec_command sleeping\")",
            "DEBUG_FUNCS"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wdc_exec_command: polled command not done\\n\""
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_exec_xfer",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_exec_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1552-1577",
          "snippet": "void\nwdc_exec_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tWDCDEBUG_PRINT((\"wdc_exec_xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\n\t/* complete xfer setup */\n\txfer->chp = chp;\n\n\t/*\n\t * If we are a polled command, and the list is not empty,\n\t * we are doing a dump. Drop the list to allow the polled command\n\t * to complete, we're going to reboot soon anyway.\n\t */\n\tif ((xfer->c_flags & C_POLL) != 0 &&\n\t    chp->ch_queue->sc_xfer.tqh_first != NULL) {\n\t\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t}\n\t/* insert at the end of command list */\n\tTAILQ_INSERT_TAIL(&chp->ch_queue->sc_xfer,xfer , c_xferchain);\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_exec_xfer, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nvoid\nwdc_exec_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tWDCDEBUG_PRINT((\"wdc_exec_xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\n\t/* complete xfer setup */\n\txfer->chp = chp;\n\n\t/*\n\t * If we are a polled command, and the list is not empty,\n\t * we are doing a dump. Drop the list to allow the polled command\n\t * to complete, we're going to reboot soon anyway.\n\t */\n\tif ((xfer->c_flags & C_POLL) != 0 &&\n\t    chp->ch_queue->sc_xfer.tqh_first != NULL) {\n\t\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t}\n\t/* insert at the end of command list */\n\tTAILQ_INSERT_TAIL(&chp->ch_queue->sc_xfer,xfer , c_xferchain);\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_exec_xfer, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_get_xfer",
          "args": [
            "wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive)",
            "DEBUG_FUNCS"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid  __wdccommand_done;\nvoid  __wdccommand_start;\nint   __wdccommand_intr;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nint\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}"
  },
  {
    "function_name": "wdc_downgrade_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1252-1304",
    "snippet": "int\nwdc_downgrade_mode(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint cf_flags = drvp->cf_flags;\n\n\t/* if drive or controller don't know its mode, we can't do much */\n\tif ((drvp->drive_flags & DRIVE_MODE) == 0 ||\n\t    (wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\treturn 0;\n\t/* current drive mode was set by a config flag, let it this way */\n\tif ((cf_flags & ATA_CONFIG_PIO_SET) ||\n\t    (cf_flags & ATA_CONFIG_DMA_SET) ||\n\t    (cf_flags & ATA_CONFIG_UDMA_SET))\n\t\treturn 0;\n\n\t/*\n\t * If we were using Ultra-DMA mode > 2, downgrade to mode 2 first.\n\t * Maybe we didn't properly notice the cable type\n\t */\n\tif ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode >= 2) {\n\t\tdrvp->UDMA_mode = (drvp->UDMA_mode == 2) ? 1 : 2;\n\t\tprintf(\"%s: transfer error, downgrading to Ultra-DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->UDMA_mode);\n\t} else \tif ((drvp->drive_flags & DRIVE_UDMA) &&\n\t    (drvp->drive_flags & DRIVE_DMAERR) == 0) {\n\t\t/* \n\t\t * If we were using ultra-DMA, don't downgrade to\n\t\t * multiword DMA if we noticed a CRC error. It has\n\t\t * been noticed that CRC errors in ultra-DMA lead to\n\t\t * silent data corruption in multiword DMA.  Data\n\t\t * corruption is less likely to occur in PIO mode.  \n\t\t */\n\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\tdrvp->DMA_mode = drvp->DMA_cap;\n\t\tprintf(\"%s: transfer error, downgrading to DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->DMA_mode);\n\t} else if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) {\n\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\tdrvp->PIO_mode = drvp->PIO_cap;\n\t\tprintf(\"%s: transfer error, downgrading to PIO mode %d\\n\",\n\t\t    drvp->drive_name, drvp->PIO_mode);\n\t} else /* already using PIO, can't downgrade */\n\t\treturn 0;\n\n\twdc->set_modes(chp);\n\t/* reset the channel, which will schedule all drives for setup */\n\twdc_reset_channel(drvp);\n\treturn 1;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_reset_channel",
          "args": [
            "drvp"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_reset_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "774-786",
          "snippet": "void wdc_reset_channel(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tint drive;\n\tWDCDEBUG_PRINT((\"ata_reset_channel %s:%d for drive %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\t(void) wdcreset(chp, VERBOSE);\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tchp->ch_drive[drive].state = 0;\n\t}\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid wdc_reset_channel(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tint drive;\n\tWDCDEBUG_PRINT((\"ata_reset_channel %s:%d for drive %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\t(void) wdcreset(chp, VERBOSE);\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tchp->ch_drive[drive].state = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc->set_modes",
          "args": [
            "chp"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: transfer error, downgrading to PIO mode %d\\n\"",
            "drvp->drive_name",
            "drvp->PIO_mode"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwdc_downgrade_mode(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint cf_flags = drvp->cf_flags;\n\n\t/* if drive or controller don't know its mode, we can't do much */\n\tif ((drvp->drive_flags & DRIVE_MODE) == 0 ||\n\t    (wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\treturn 0;\n\t/* current drive mode was set by a config flag, let it this way */\n\tif ((cf_flags & ATA_CONFIG_PIO_SET) ||\n\t    (cf_flags & ATA_CONFIG_DMA_SET) ||\n\t    (cf_flags & ATA_CONFIG_UDMA_SET))\n\t\treturn 0;\n\n\t/*\n\t * If we were using Ultra-DMA mode > 2, downgrade to mode 2 first.\n\t * Maybe we didn't properly notice the cable type\n\t */\n\tif ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode >= 2) {\n\t\tdrvp->UDMA_mode = (drvp->UDMA_mode == 2) ? 1 : 2;\n\t\tprintf(\"%s: transfer error, downgrading to Ultra-DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->UDMA_mode);\n\t} else \tif ((drvp->drive_flags & DRIVE_UDMA) &&\n\t    (drvp->drive_flags & DRIVE_DMAERR) == 0) {\n\t\t/* \n\t\t * If we were using ultra-DMA, don't downgrade to\n\t\t * multiword DMA if we noticed a CRC error. It has\n\t\t * been noticed that CRC errors in ultra-DMA lead to\n\t\t * silent data corruption in multiword DMA.  Data\n\t\t * corruption is less likely to occur in PIO mode.  \n\t\t */\n\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\tdrvp->DMA_mode = drvp->DMA_cap;\n\t\tprintf(\"%s: transfer error, downgrading to DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->DMA_mode);\n\t} else if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) {\n\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\tdrvp->PIO_mode = drvp->PIO_cap;\n\t\tprintf(\"%s: transfer error, downgrading to PIO mode %d\\n\",\n\t\t    drvp->drive_name, drvp->PIO_mode);\n\t} else /* already using PIO, can't downgrade */\n\t\treturn 0;\n\n\twdc->set_modes(chp);\n\t/* reset the channel, which will schedule all drives for setup */\n\twdc_reset_channel(drvp);\n\treturn 1;\n}"
  },
  {
    "function_name": "wdc_print_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1224-1246",
    "snippet": "void\nwdc_print_caps(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n \tprintf(\"%s: can use \", drvp->drive_name);\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\tprintf(\"32-bit\");\n\t} else \n\t\tprintf(\"16-bit\");\n\n\tprintf(\", PIO mode %d\", drvp->PIO_cap);\n\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\tprintf(\", DMA mode %d\", drvp->DMA_cap);\n\t}\n\n\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_cap);\n\t}\n\t\t\t\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_print_caps(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n \tprintf(\"%s: can use \", drvp->drive_name);\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\tprintf(\"32-bit\");\n\t} else \n\t\tprintf(\"16-bit\");\n\n\tprintf(\", PIO mode %d\", drvp->PIO_cap);\n\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\tprintf(\", DMA mode %d\", drvp->DMA_cap);\n\t}\n\n\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_cap);\n\t}\n\t\t\t\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "wdc_input_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1194-1222",
    "snippet": "void\nwdc_input_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_READ_RAW_MULTI_4(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t\tCHP_READ_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHP_READ_RAW_MULTI_2",
          "args": [
            "chp",
            "(void *)((u_int8_t *)bytes + off)",
            "roundlen"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_RAW_MULTI_4",
          "args": [
            "chp",
            "(void *)((u_int8_t *)bytes + off)",
            "roundlen"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_input_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_READ_RAW_MULTI_4(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t\tCHP_READ_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "wdc_output_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "1164-1192",
    "snippet": "void\nwdc_output_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\t\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_WRITE_RAW_MULTI_4(chp, \n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t        CHP_WRITE_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHP_WRITE_RAW_MULTI_2",
          "args": [
            "chp",
            "(void *)((u_int8_t *)bytes + off)",
            "roundlen"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_RAW_MULTI_4",
          "args": [
            "chp",
            "(void *)((u_int8_t *)bytes + off)",
            "roundlen"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_output_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\t\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_WRITE_RAW_MULTI_4(chp, \n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t        CHP_WRITE_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "wdc_probe_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "987-1162",
    "snippet": "void\nwdc_probe_caps(drvp, params)\n\tstruct ata_drive_datas *drvp;\n\tstruct ataparams *params;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint i, printed;\n\tint cf_flags = drvp->cf_flags;\n\n\tif ((wdc->cap & (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) {\n\t\tstruct ataparams params2;\n\n\t\t/*\n\t\t * Controller claims 16 and 32 bit transfers.\n\t\t * Re-do an IDENTIFY with 32-bit transfers,\n\t\t * and compare results.\n\t\t */\n\t\tdrvp->drive_flags |= DRIVE_CAP32;\n\t\tata_get_params(drvp, at_poll, &params2);\n\t\tif (bcmp(params, &params2, sizeof(struct ataparams)) != 0) {\n\t\t\t/* Not good. fall back to 16bits */\n\t\t\tdrvp->drive_flags &= ~DRIVE_CAP32;\n\t\t}\n\t}\n#if 0 /* Some ultra-DMA drives claims to only support ATA-3. sigh */\n\tif (params->atap_ata_major > 0x01 && \n\t    params->atap_ata_major != 0xffff) {\n\t\tfor (i = 14; i > 0; i--) {\n\t\t\tif (params->atap_ata_major & (1 << i)) {\n\t\t\t\tprintf(\"%sATA version %d\\n\", sep, i);\n\t\t\t\tdrvp->ata_vers = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else \n#endif\n\t/* An ATAPI device is at last PIO mode 3 */\n\tif (drvp->drive_flags & DRIVE_ATAPI)\n\t\tdrvp->PIO_mode = 3;\n\n\t/*\n\t * It's not in the specs, but it seems that some drive \n\t * returns 0xffff in atap_extensions when this field is invalid\n\t */\n\tif (params->atap_extensions != 0xffff &&\n\t    (params->atap_extensions & WDC_EXT_MODES)) {\n\t\tprinted = 0;\n\t\t/*\n\t\t * XXX some drives report something wrong here (they claim to\n\t\t * support PIO mode 8 !). As mode is coded on 3 bits in\n\t\t * SET FEATURE, limit it to 7 (so limit i to 4).\n\t\t * If higther mode than 7 is found, abort.\n\t\t */\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_piomode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i > 4) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * See if mode is accepted.\n\t\t\t * If the controller can't set its PIO mode,\n\t\t\t * assume the defaults are good, so don't try\n\t\t\t * to set it\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) != 0)\n\t\t\t\tif (ata_set_mode(drvp, 0x08 | (i + 3),\n\t\t\t\t   at_poll) != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) { \n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If controller's driver can't set its PIO mode,\n\t\t\t * get the highter one for the drive.\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) == 0 ||\n\t\t\t    wdc->PIO_cap >= i + 3) {\n\t\t\t\tdrvp->PIO_mode = i + 3;\n\t\t\t\tdrvp->PIO_cap = i + 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!printed) {\n\t\t\t/* \n\t\t\t * We didn't find a valid PIO mode.\n\t\t\t * Assume the values returned for DMA are buggy too\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t\tprinted = 0;\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_dmamode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_DMA) &&\n\t\t\t    (wdc->cap & WDC_CAPABILITY_MODE))\n\t\t\t\tif (ata_set_mode(drvp, 0x20 | i, at_poll)\n\t\t\t\t    != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) {\n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\tif (wdc->cap & WDC_CAPABILITY_DMA) {\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    wdc->DMA_cap < i)\n\t\t\t\t\tcontinue;\n\t\t\t\tdrvp->DMA_mode = i;\n\t\t\t\tdrvp->DMA_cap = i;\n\t\t\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (params->atap_extensions & WDC_EXT_UDMA_MODES) {\n\t\t\tfor (i = 7; i >= 0; i--) {\n\t\t\t\tif ((params->atap_udmamode_supp & (1 << i))\n\t\t\t\t    == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    (wdc->cap & WDC_CAPABILITY_UDMA))\n\t\t\t\t\tif (ata_set_mode(drvp, 0x40 | i,\n\t\t\t\t\t    at_poll) != CMD_OK)\n\t\t\t\t\t\tcontinue;\n\t\t\t\tif (wdc->cap & WDC_CAPABILITY_UDMA) {\n\t\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t\t    wdc->UDMA_cap < i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdrvp->UDMA_mode = i;\n\t\t\t\t\tdrvp->UDMA_cap = i;\n\t\t\t\t\tdrvp->drive_flags |= DRIVE_UDMA;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Try to guess ATA version here, if it didn't get reported */\n\tif (drvp->ata_vers == 0) {\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tdrvp->ata_vers = 4; /* should be at last ATA-4 */\n\t\telse if (drvp->PIO_cap > 2)\n\t\t\tdrvp->ata_vers = 2; /* should be at last ATA-2 */\n\t}\n\tif (cf_flags & ATA_CONFIG_PIO_SET) {\n\t\tdrvp->PIO_mode =\n\t\t    (cf_flags & ATA_CONFIG_PIO_MODES) >> ATA_CONFIG_PIO_OFF;\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t}\n\tif ((wdc->cap & WDC_CAPABILITY_DMA) == 0) {\n\t\t/* don't care about DMA modes */\n\t\treturn;\n\t}\n\tif (cf_flags & ATA_CONFIG_DMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_DMA_MODES) ==\n\t\t    ATA_CONFIG_DMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t} else {\n\t\t\tdrvp->DMA_mode = (cf_flags & ATA_CONFIG_DMA_MODES) >>\n\t\t\t    ATA_CONFIG_DMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_DMA | DRIVE_MODE;\n\t\t}\n\t}\n\tif (cf_flags & ATA_CONFIG_UDMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_UDMA_MODES) ==\n\t\t    ATA_CONFIG_UDMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t} else {\n\t\t\tdrvp->UDMA_mode = (cf_flags & ATA_CONFIG_UDMA_MODES) >>\n\t\t\t    ATA_CONFIG_UDMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_UDMA | DRIVE_MODE;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int at_poll = AT_POLL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ata_set_mode",
          "args": [
            "drvp",
            "0x40 | i",
            "at_poll"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "ata_set_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
          "lines": "151-175",
          "snippet": "int\nata_set_mode(drvp, mode, flags)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t mode;\n\tu_int8_t flags;\n{\n\tstruct wdc_command wdc_c;\n\n\tWDCDEBUG_PRINT((\"ata_set_mode=0x%x\\n\", mode), DEBUG_FUNCS);\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\twdc_c.r_command = SET_FEATURES;\n\twdc_c.r_st_bmask = 0;\n\twdc_c.r_st_pmask = 0;\n\twdc_c.r_precomp = WDSF_SET_MODE;\n\twdc_c.r_count = mode;\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.timeout = 1000; /* 1s */\n\tif (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE)\n\t\treturn CMD_AGAIN;\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t}\n\treturn CMD_OK;\n}",
          "includes": [
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nint\nata_set_mode(drvp, mode, flags)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t mode;\n\tu_int8_t flags;\n{\n\tstruct wdc_command wdc_c;\n\n\tWDCDEBUG_PRINT((\"ata_set_mode=0x%x\\n\", mode), DEBUG_FUNCS);\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\twdc_c.r_command = SET_FEATURES;\n\twdc_c.r_st_bmask = 0;\n\twdc_c.r_st_pmask = 0;\n\twdc_c.r_precomp = WDSF_SET_MODE;\n\twdc_c.r_count = mode;\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.timeout = 1000; /* 1s */\n\tif (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE)\n\t\treturn CMD_AGAIN;\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t}\n\treturn CMD_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%sATA version %d\\n\"",
            "sep",
            "i"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "params",
            "&params2",
            "sizeof(struct ataparams)"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata_get_params",
          "args": [
            "drvp",
            "at_poll",
            "&params2"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "ata_get_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
          "lines": "59-149",
          "snippet": "int\nata_get_params(drvp, flags, prms)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t flags;\n\tstruct ataparams *prms;\n{\n\tchar tb[ATAPARAMS_SIZE];\n\tstruct wdc_command wdc_c;\n\n\tint i;\n\tu_int16_t *p;\n\n\tWDCDEBUG_PRINT((\"ata_get_parms\\n\"), DEBUG_FUNCS);\n\n\tbzero(tb, sizeof(tb));\n\tbzero(prms, sizeof(struct ataparams));\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\tif (drvp->drive_flags & DRIVE_ATA) {\n\t\twdc_c.r_command = WDCC_IDENTIFY;\n\t\twdc_c.r_st_bmask = WDCS_DRDY;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 1000; /* 1s */\n\t} else if (drvp->drive_flags & DRIVE_ATAPI) {\n\t\twdc_c.r_command = ATAPI_IDENTIFY_DEVICE;\n\t\twdc_c.r_st_bmask = 0;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 10000; /* 10s */\n\t} else {\n\t\treturn CMD_ERR;\n\t}\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.data = tb;\n\twdc_c.bcount = ATAPARAMS_SIZE;\n\n\t{\n\t\tint ret;\n\t\tif ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {\n\t\t\tprintf (\"WDC_EXEC_COMMAND: %d\\n\");\n\t\t\treturn CMD_AGAIN;\n\t\t}\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t} else {\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t/* All the fields in the params structure are 16-bit\n\t\t   integers except for the ID strings which are char\n\t\t   strings.  The 16-bit integers are currently in\n\t\t   memory in little-endian, regardless of architecture.\n\t\t   So, they need to be swapped on big-endian architectures\n\t\t   before they are accessed through the ataparams structure.\n\n\t\t   The swaps below avoid touching the char strings.\n\t\t*/\n\t\t  \n\t\tswap16_multi((u_int16_t *)tb, 10);\n\t\tswap16_multi((u_int16_t *)tb + 20, 3);\n\t\tswap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);\n#endif\n\t\t/* Read in parameter block. */\n\t\tbcopy(tb, prms, sizeof(struct ataparams));\n\n\t\t/*\n\t\t * Shuffle string byte order.\n\t\t * ATAPI Mitsumi and NEC drives don't need this.\n\t\t */\n\t\tif ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==\n\t\t    WDC_CFG_ATAPI &&\n\t\t    ((prms->atap_model[0] == 'N' &&\n\t\t\tprms->atap_model[1] == 'E') ||\n\t\t     (prms->atap_model[0] == 'F' &&\n\t\t\t prms->atap_model[1] == 'X')))\n\t\t\treturn 0;\n\t\tfor (i = 0; i < sizeof(prms->atap_model); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_model + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_serial); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_serial + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_revision); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_revision + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\n\t\treturn CMD_OK;\n\t}\n}",
          "includes": [
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ATAPARAMS_SIZE 512",
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ATAPARAMS_SIZE 512\n#define DEBUG_FUNCS  0x08\n\nint\nata_get_params(drvp, flags, prms)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t flags;\n\tstruct ataparams *prms;\n{\n\tchar tb[ATAPARAMS_SIZE];\n\tstruct wdc_command wdc_c;\n\n\tint i;\n\tu_int16_t *p;\n\n\tWDCDEBUG_PRINT((\"ata_get_parms\\n\"), DEBUG_FUNCS);\n\n\tbzero(tb, sizeof(tb));\n\tbzero(prms, sizeof(struct ataparams));\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\tif (drvp->drive_flags & DRIVE_ATA) {\n\t\twdc_c.r_command = WDCC_IDENTIFY;\n\t\twdc_c.r_st_bmask = WDCS_DRDY;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 1000; /* 1s */\n\t} else if (drvp->drive_flags & DRIVE_ATAPI) {\n\t\twdc_c.r_command = ATAPI_IDENTIFY_DEVICE;\n\t\twdc_c.r_st_bmask = 0;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 10000; /* 10s */\n\t} else {\n\t\treturn CMD_ERR;\n\t}\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.data = tb;\n\twdc_c.bcount = ATAPARAMS_SIZE;\n\n\t{\n\t\tint ret;\n\t\tif ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {\n\t\t\tprintf (\"WDC_EXEC_COMMAND: %d\\n\");\n\t\t\treturn CMD_AGAIN;\n\t\t}\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t} else {\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t/* All the fields in the params structure are 16-bit\n\t\t   integers except for the ID strings which are char\n\t\t   strings.  The 16-bit integers are currently in\n\t\t   memory in little-endian, regardless of architecture.\n\t\t   So, they need to be swapped on big-endian architectures\n\t\t   before they are accessed through the ataparams structure.\n\n\t\t   The swaps below avoid touching the char strings.\n\t\t*/\n\t\t  \n\t\tswap16_multi((u_int16_t *)tb, 10);\n\t\tswap16_multi((u_int16_t *)tb + 20, 3);\n\t\tswap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);\n#endif\n\t\t/* Read in parameter block. */\n\t\tbcopy(tb, prms, sizeof(struct ataparams));\n\n\t\t/*\n\t\t * Shuffle string byte order.\n\t\t * ATAPI Mitsumi and NEC drives don't need this.\n\t\t */\n\t\tif ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==\n\t\t    WDC_CFG_ATAPI &&\n\t\t    ((prms->atap_model[0] == 'N' &&\n\t\t\tprms->atap_model[1] == 'E') ||\n\t\t     (prms->atap_model[0] == 'F' &&\n\t\t\t prms->atap_model[1] == 'X')))\n\t\t\treturn 0;\n\t\tfor (i = 0; i < sizeof(prms->atap_model); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_model + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_serial); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_serial + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_revision); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_revision + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\n\t\treturn CMD_OK;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint at_poll = AT_POLL;\n\nvoid\nwdc_probe_caps(drvp, params)\n\tstruct ata_drive_datas *drvp;\n\tstruct ataparams *params;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint i, printed;\n\tint cf_flags = drvp->cf_flags;\n\n\tif ((wdc->cap & (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) {\n\t\tstruct ataparams params2;\n\n\t\t/*\n\t\t * Controller claims 16 and 32 bit transfers.\n\t\t * Re-do an IDENTIFY with 32-bit transfers,\n\t\t * and compare results.\n\t\t */\n\t\tdrvp->drive_flags |= DRIVE_CAP32;\n\t\tata_get_params(drvp, at_poll, &params2);\n\t\tif (bcmp(params, &params2, sizeof(struct ataparams)) != 0) {\n\t\t\t/* Not good. fall back to 16bits */\n\t\t\tdrvp->drive_flags &= ~DRIVE_CAP32;\n\t\t}\n\t}\n#if 0 /* Some ultra-DMA drives claims to only support ATA-3. sigh */\n\tif (params->atap_ata_major > 0x01 && \n\t    params->atap_ata_major != 0xffff) {\n\t\tfor (i = 14; i > 0; i--) {\n\t\t\tif (params->atap_ata_major & (1 << i)) {\n\t\t\t\tprintf(\"%sATA version %d\\n\", sep, i);\n\t\t\t\tdrvp->ata_vers = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else \n#endif\n\t/* An ATAPI device is at last PIO mode 3 */\n\tif (drvp->drive_flags & DRIVE_ATAPI)\n\t\tdrvp->PIO_mode = 3;\n\n\t/*\n\t * It's not in the specs, but it seems that some drive \n\t * returns 0xffff in atap_extensions when this field is invalid\n\t */\n\tif (params->atap_extensions != 0xffff &&\n\t    (params->atap_extensions & WDC_EXT_MODES)) {\n\t\tprinted = 0;\n\t\t/*\n\t\t * XXX some drives report something wrong here (they claim to\n\t\t * support PIO mode 8 !). As mode is coded on 3 bits in\n\t\t * SET FEATURE, limit it to 7 (so limit i to 4).\n\t\t * If higther mode than 7 is found, abort.\n\t\t */\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_piomode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i > 4) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * See if mode is accepted.\n\t\t\t * If the controller can't set its PIO mode,\n\t\t\t * assume the defaults are good, so don't try\n\t\t\t * to set it\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) != 0)\n\t\t\t\tif (ata_set_mode(drvp, 0x08 | (i + 3),\n\t\t\t\t   at_poll) != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) { \n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If controller's driver can't set its PIO mode,\n\t\t\t * get the highter one for the drive.\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) == 0 ||\n\t\t\t    wdc->PIO_cap >= i + 3) {\n\t\t\t\tdrvp->PIO_mode = i + 3;\n\t\t\t\tdrvp->PIO_cap = i + 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!printed) {\n\t\t\t/* \n\t\t\t * We didn't find a valid PIO mode.\n\t\t\t * Assume the values returned for DMA are buggy too\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t\tprinted = 0;\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_dmamode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_DMA) &&\n\t\t\t    (wdc->cap & WDC_CAPABILITY_MODE))\n\t\t\t\tif (ata_set_mode(drvp, 0x20 | i, at_poll)\n\t\t\t\t    != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) {\n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\tif (wdc->cap & WDC_CAPABILITY_DMA) {\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    wdc->DMA_cap < i)\n\t\t\t\t\tcontinue;\n\t\t\t\tdrvp->DMA_mode = i;\n\t\t\t\tdrvp->DMA_cap = i;\n\t\t\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (params->atap_extensions & WDC_EXT_UDMA_MODES) {\n\t\t\tfor (i = 7; i >= 0; i--) {\n\t\t\t\tif ((params->atap_udmamode_supp & (1 << i))\n\t\t\t\t    == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    (wdc->cap & WDC_CAPABILITY_UDMA))\n\t\t\t\t\tif (ata_set_mode(drvp, 0x40 | i,\n\t\t\t\t\t    at_poll) != CMD_OK)\n\t\t\t\t\t\tcontinue;\n\t\t\t\tif (wdc->cap & WDC_CAPABILITY_UDMA) {\n\t\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t\t    wdc->UDMA_cap < i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdrvp->UDMA_mode = i;\n\t\t\t\t\tdrvp->UDMA_cap = i;\n\t\t\t\t\tdrvp->drive_flags |= DRIVE_UDMA;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Try to guess ATA version here, if it didn't get reported */\n\tif (drvp->ata_vers == 0) {\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tdrvp->ata_vers = 4; /* should be at last ATA-4 */\n\t\telse if (drvp->PIO_cap > 2)\n\t\t\tdrvp->ata_vers = 2; /* should be at last ATA-2 */\n\t}\n\tif (cf_flags & ATA_CONFIG_PIO_SET) {\n\t\tdrvp->PIO_mode =\n\t\t    (cf_flags & ATA_CONFIG_PIO_MODES) >> ATA_CONFIG_PIO_OFF;\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t}\n\tif ((wdc->cap & WDC_CAPABILITY_DMA) == 0) {\n\t\t/* don't care about DMA modes */\n\t\treturn;\n\t}\n\tif (cf_flags & ATA_CONFIG_DMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_DMA_MODES) ==\n\t\t    ATA_CONFIG_DMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t} else {\n\t\t\tdrvp->DMA_mode = (cf_flags & ATA_CONFIG_DMA_MODES) >>\n\t\t\t    ATA_CONFIG_DMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_DMA | DRIVE_MODE;\n\t\t}\n\t}\n\tif (cf_flags & ATA_CONFIG_UDMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_UDMA_MODES) ==\n\t\t    ATA_CONFIG_UDMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t} else {\n\t\t\tdrvp->UDMA_mode = (cf_flags & ATA_CONFIG_UDMA_MODES) >>\n\t\t\t    ATA_CONFIG_UDMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_UDMA | DRIVE_MODE;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "wdctimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "952-980",
    "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [
      "static void  __wdcerror"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wdcerror",
          "args": [
            "chp",
            "\"missing untimeout\""
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "__wdcerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1653-1667",
          "snippet": "static void\n__wdcerror(chp, msg) \n\tstruct channel_softc *chp;\n\tchar *msg;\n{\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tif (xfer == NULL)\n\t\tprintf(\"%s:%d: %s\\n\", chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t    msg);\n\telse \n\t\tprintf(\"%s(%s:%d:%d): %s\\n\", \n\t\t    chp->ch_drive[xfer->drive].drive_name,\n\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t    chp->channel, xfer->drive, msg);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void  __wdcerror;\n\nstatic void\n__wdcerror(chp, msg) \n\tstruct channel_softc *chp;\n\tchar *msg;\n{\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tif (xfer == NULL)\n\t\tprintf(\"%s:%d: %s\\n\", chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t    msg);\n\telse \n\t\tprintf(\"%s(%s:%d:%d): %s\\n\", \n\t\t    chp->ch_drive[xfer->drive].drive_name,\n\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t    chp->channel, xfer->drive, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfer->c_intr",
          "args": [
            "chp",
            "xfer",
            "1"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\tc_skip: %d\\n\"",
            "xfer->c_skip"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdctimeout\\n\")",
            "DEBUG_FUNCS"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
  },
  {
    "function_name": "wdcwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "879-950",
    "snippet": "int\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_STATUSX 0x20",
      "#define DEBUG_STATUS 0x04",
      "#define WDCNDELAY_DEBUG\t50",
      "#define WDCDELAY  100 /* 100 microseconds */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d:%d: warning: busy-wait took %dus\\n\"",
            "chp->wdc->sc_dev.dv_xname",
            "chp->channel",
            "xfer->drive",
            "WDCDELAY * time"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdcwait: error %x\\n\", chp->ch_error)",
            "DEBUG_STATUSX | DEBUG_STATUS"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_error"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_status"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "WDCDELAY"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error))",
            "DEBUG_STATUSX | DEBUG_STATUS"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_error"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_status"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_altsts"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | 0x10"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_status"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_altsts"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel)",
            "DEBUG_STATUS"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_STATUSX 0x20\n#define DEBUG_STATUS 0x04\n#define WDCNDELAY_DEBUG\t50\n#define WDCDELAY  100 /* 100 microseconds */\n\nint\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "__wdcwait_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "822-873",
    "snippet": "static int\n__wdcwait_reset(chp, drv_mask)\n\tstruct channel_softc *chp;\n\tint drv_mask;\n{\n\tint timeout;\n\tu_int8_t st0, st1;\n\n\t/* Wait 50ms for drive firmware to settle */\n\tdelay(50000);\n\n\t/* wait for BSY to deassert */\n\tfor (timeout = 0; timeout < WDCNDELAY_RST;timeout++) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10); /* slave */\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tif ((drv_mask & 0x01) == 0) {\n\t\t\t/* no master */\n\t\t\tif ((drv_mask & 0x02) != 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\t/* No master, slave is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else if ((drv_mask & 0x02) == 0) {\n\t\t\t/* no slave */\n\t\t\tif ((drv_mask & 0x01) != 0 && (st0 & WDCS_BSY) == 0) {\n\t\t\t\t/* No slave, master is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Wait for both master and slave to be ready */\n\t\t\tif ((st0 & WDCS_BSY) == 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n\t/* Reset timed out. Maybe it's because drv_mask was not rigth */\n\tif (st0 & WDCS_BSY)\n\t\tdrv_mask &= ~0x01;\n\tif (st1 & WDCS_BSY)\n\t\tdrv_mask &= ~0x02;\nend:\n\tWDCDEBUG_PRINT((\"%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    st0, st1), DEBUG_PROBE);\n\n\treturn drv_mask;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10",
      "#define WDCNDELAY_RST (WDC_RESET_WAIT * 1000 / WDCDELAY)",
      "#define WDCDELAY  100 /* 100 microseconds */"
    ],
    "globals_used": [
      "static int   __wdcwait_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    st0, st1)",
            "DEBUG_PROBE"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "WDCDELAY"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_status"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | 0x10"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_status"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n#define WDCNDELAY_RST (WDC_RESET_WAIT * 1000 / WDCDELAY)\n#define WDCDELAY  100 /* 100 microseconds */\n\nstatic int   __wdcwait_reset;\n\nstatic int\n__wdcwait_reset(chp, drv_mask)\n\tstruct channel_softc *chp;\n\tint drv_mask;\n{\n\tint timeout;\n\tu_int8_t st0, st1;\n\n\t/* Wait 50ms for drive firmware to settle */\n\tdelay(50000);\n\n\t/* wait for BSY to deassert */\n\tfor (timeout = 0; timeout < WDCNDELAY_RST;timeout++) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10); /* slave */\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tif ((drv_mask & 0x01) == 0) {\n\t\t\t/* no master */\n\t\t\tif ((drv_mask & 0x02) != 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\t/* No master, slave is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else if ((drv_mask & 0x02) == 0) {\n\t\t\t/* no slave */\n\t\t\tif ((drv_mask & 0x01) != 0 && (st0 & WDCS_BSY) == 0) {\n\t\t\t\t/* No slave, master is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Wait for both master and slave to be ready */\n\t\t\tif ((st0 & WDCS_BSY) == 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n\t/* Reset timed out. Maybe it's because drv_mask was not rigth */\n\tif (st0 & WDCS_BSY)\n\t\tdrv_mask &= ~0x01;\n\tif (st1 & WDCS_BSY)\n\t\tdrv_mask &= ~0x02;\nend:\n\tWDCDEBUG_PRINT((\"%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    st0, st1), DEBUG_PROBE);\n\n\treturn drv_mask;\n}"
  },
  {
    "function_name": "wdcreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "788-820",
    "snippet": "int\nwdcreset(chp, verb)\n\tstruct channel_softc *chp;\n\tint verb;\n{\n\tint drv_mask1, drv_mask2;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);\n\tdelay(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(2000);\n\t(void) CHP_READ_REG(chp,wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\n\tdrv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;\n\tdrv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;\n\tdrv_mask2 = __wdcwait_reset(chp, drv_mask1);\n\tif (verb && drv_mask2 != drv_mask1) {\n\t\tprintf(\"%s channel %d: reset failed for\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel);\n\t\tif ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)\n\t\t\tprintf(\" drive 0\");\n\t\tif ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)\n\t\t\tprintf(\" drive 1\");\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn  (drv_mask1 != drv_mask2) ? 1 : 0;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int   __wdcwait_reset",
      "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wdcwait_reset",
          "args": [
            "chp",
            "drv_mask1"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "__wdcwait_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "822-873",
          "snippet": "static int\n__wdcwait_reset(chp, drv_mask)\n\tstruct channel_softc *chp;\n\tint drv_mask;\n{\n\tint timeout;\n\tu_int8_t st0, st1;\n\n\t/* Wait 50ms for drive firmware to settle */\n\tdelay(50000);\n\n\t/* wait for BSY to deassert */\n\tfor (timeout = 0; timeout < WDCNDELAY_RST;timeout++) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10); /* slave */\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tif ((drv_mask & 0x01) == 0) {\n\t\t\t/* no master */\n\t\t\tif ((drv_mask & 0x02) != 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\t/* No master, slave is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else if ((drv_mask & 0x02) == 0) {\n\t\t\t/* no slave */\n\t\t\tif ((drv_mask & 0x01) != 0 && (st0 & WDCS_BSY) == 0) {\n\t\t\t\t/* No slave, master is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Wait for both master and slave to be ready */\n\t\t\tif ((st0 & WDCS_BSY) == 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n\t/* Reset timed out. Maybe it's because drv_mask was not rigth */\n\tif (st0 & WDCS_BSY)\n\t\tdrv_mask &= ~0x01;\n\tif (st1 & WDCS_BSY)\n\t\tdrv_mask &= ~0x02;\nend:\n\tWDCDEBUG_PRINT((\"%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    st0, st1), DEBUG_PROBE);\n\n\treturn drv_mask;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10",
            "#define WDCNDELAY_RST (WDC_RESET_WAIT * 1000 / WDCDELAY)",
            "#define WDCDELAY  100 /* 100 microseconds */"
          ],
          "globals_used": [
            "static int   __wdcwait_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n#define WDCNDELAY_RST (WDC_RESET_WAIT * 1000 / WDCDELAY)\n#define WDCDELAY  100 /* 100 microseconds */\n\nstatic int   __wdcwait_reset;\n\nstatic int\n__wdcwait_reset(chp, drv_mask)\n\tstruct channel_softc *chp;\n\tint drv_mask;\n{\n\tint timeout;\n\tu_int8_t st0, st1;\n\n\t/* Wait 50ms for drive firmware to settle */\n\tdelay(50000);\n\n\t/* wait for BSY to deassert */\n\tfor (timeout = 0; timeout < WDCNDELAY_RST;timeout++) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10); /* slave */\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tif ((drv_mask & 0x01) == 0) {\n\t\t\t/* no master */\n\t\t\tif ((drv_mask & 0x02) != 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\t/* No master, slave is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else if ((drv_mask & 0x02) == 0) {\n\t\t\t/* no slave */\n\t\t\tif ((drv_mask & 0x01) != 0 && (st0 & WDCS_BSY) == 0) {\n\t\t\t\t/* No slave, master is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Wait for both master and slave to be ready */\n\t\t\tif ((st0 & WDCS_BSY) == 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n\t/* Reset timed out. Maybe it's because drv_mask was not rigth */\n\tif (st0 & WDCS_BSY)\n\t\tdrv_mask &= ~0x01;\n\tif (st1 & WDCS_BSY)\n\t\tdrv_mask &= ~0x02;\nend:\n\tWDCDEBUG_PRINT((\"%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    st0, st1), DEBUG_PROBE);\n\n\treturn drv_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_ctlr",
            "WDCTL_4BIT"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_error"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2000"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_ctlr",
            "WDCTL_IDS"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_ctlr",
            "WDCTL_RST | WDCTL_IDS"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int   __wdcwait_reset;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nint\nwdcreset(chp, verb)\n\tstruct channel_softc *chp;\n\tint verb;\n{\n\tint drv_mask1, drv_mask2;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);\n\tdelay(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(2000);\n\t(void) CHP_READ_REG(chp,wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\n\tdrv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;\n\tdrv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;\n\tdrv_mask2 = __wdcwait_reset(chp, drv_mask1);\n\tif (verb && drv_mask2 != drv_mask1) {\n\t\tprintf(\"%s channel %d: reset failed for\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel);\n\t\tif ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)\n\t\t\tprintf(\" drive 0\");\n\t\tif ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)\n\t\t\tprintf(\" drive 1\");\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn  (drv_mask1 != drv_mask2) ? 1 : 0;\n}"
  },
  {
    "function_name": "wdc_reset_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "774-786",
    "snippet": "void wdc_reset_channel(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tint drive;\n\tWDCDEBUG_PRINT((\"ata_reset_channel %s:%d for drive %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\t(void) wdcreset(chp, VERBOSE);\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tchp->ch_drive[drive].state = 0;\n\t}\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdcreset",
          "args": [
            "chp",
            "VERBOSE"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "wdcreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "788-820",
          "snippet": "int\nwdcreset(chp, verb)\n\tstruct channel_softc *chp;\n\tint verb;\n{\n\tint drv_mask1, drv_mask2;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);\n\tdelay(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(2000);\n\t(void) CHP_READ_REG(chp,wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\n\tdrv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;\n\tdrv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;\n\tdrv_mask2 = __wdcwait_reset(chp, drv_mask1);\n\tif (verb && drv_mask2 != drv_mask1) {\n\t\tprintf(\"%s channel %d: reset failed for\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel);\n\t\tif ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)\n\t\t\tprintf(\" drive 0\");\n\t\tif ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)\n\t\t\tprintf(\" drive 1\");\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn  (drv_mask1 != drv_mask2) ? 1 : 0;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int   __wdcwait_reset",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int   __wdcwait_reset;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nint\nwdcreset(chp, verb)\n\tstruct channel_softc *chp;\n\tint verb;\n{\n\tint drv_mask1, drv_mask2;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);\n\tdelay(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(2000);\n\t(void) CHP_READ_REG(chp,wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\n\tdrv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;\n\tdrv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;\n\tdrv_mask2 = __wdcwait_reset(chp, drv_mask1);\n\tif (verb && drv_mask2 != drv_mask1) {\n\t\tprintf(\"%s channel %d: reset failed for\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel);\n\t\tif ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)\n\t\t\tprintf(\" drive 0\");\n\t\tif ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)\n\t\t\tprintf(\" drive 1\");\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn  (drv_mask1 != drv_mask2) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"ata_reset_channel %s:%d for drive %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive)",
            "DEBUG_FUNCS"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid wdc_reset_channel(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tint drive;\n\tWDCDEBUG_PRINT((\"ata_reset_channel %s:%d for drive %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\t(void) wdcreset(chp, VERBOSE);\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tchp->ch_drive[drive].state = 0;\n\t}\n}"
  },
  {
    "function_name": "wdcintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "748-771",
    "snippet": "int\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_INTR   0x01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfer->c_intr",
          "args": [
            "chp",
            "xfer",
            "1"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "wdctimeout",
            "chp"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdcintr\\n\")",
            "DEBUG_INTR"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdcintr: inactive controller\\n\")",
            "DEBUG_INTR"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_INTR   0x01\n\nint\nwdcintr(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = arg;\n\tstruct wdc_xfer *xfer;\n\tint ret;\n\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdcintr: inactive controller\\n\"), DEBUG_INTR);\n\t\treturn 0;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdcintr\\n\"), DEBUG_INTR);\n\tuntimeout(wdctimeout, chp);\n\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\txfer = chp->ch_queue->sc_xfer.tqh_first;\n        ret = xfer->c_intr(chp, xfer, 1);\n#if notyet\n\tif (ret == 0)\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n#endif\n\treturn (ret);\n}"
  },
  {
    "function_name": "wdcrestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "729-739",
    "snippet": "void\nwdcrestart(v)\n\tvoid *v;\n{\n\tstruct channel_softc *chp = v;\n\tint s;\n\n\ts = splbio();\n\twdcstart(chp);\n\tsplx(s);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdcstart",
          "args": [
            "chp"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "wdcstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "664-710",
          "snippet": "void\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdcrestart(v)\n\tvoid *v;\n{\n\tstruct channel_softc *chp = v;\n\tint s;\n\n\ts = splbio();\n\twdcstart(chp);\n\tsplx(s);\n}"
  },
  {
    "function_name": "wdcdetach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "712-726",
    "snippet": "int\nwdcdetach(chp, flags)\n\tstruct channel_softc *chp;\n\tint flags;\n{\n\tint s, rv;\n\n\ts = splbio();\n\twdc_kill_pending(chp);\n\n\trv = config_detach_children((struct device *)chp->wdc, flags);\n\tsplx(s);\n\n\treturn (rv);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void  wdc_kill_pending",
      "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_detach_children",
          "args": [
            "(struct device *)chp->wdc",
            "flags"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_kill_pending",
          "args": [
            "chp"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_kill_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1641-1651",
          "snippet": "void\nwdc_kill_pending(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n\twhile ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) != NULL) {\n\t\tchp = xfer->chp;\n\t\t(*xfer->c_kill_xfer)(chp, xfer);\n\t}\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void  wdc_kill_pending"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid  wdc_kill_pending;\n\nvoid\nwdc_kill_pending(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n\twhile ((xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer)) != NULL) {\n\t\tchp = xfer->chp;\n\t\t(*xfer->c_kill_xfer)(chp, xfer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid  wdc_kill_pending;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nint\nwdcdetach(chp, flags)\n\tstruct channel_softc *chp;\n\tint flags;\n{\n\tint s, rv;\n\n\ts = splbio();\n\twdc_kill_pending(chp);\n\n\trv = config_detach_children((struct device *)chp->wdc, flags);\n\tsplx(s);\n\n\treturn (rv);\n}"
  },
  {
    "function_name": "wdcstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "664-710",
    "snippet": "void\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfer->c_start",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive)",
            "DEBUG_XFERS"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp",
            "0"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wdcstart: channel waiting for irq\\n\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "spl1"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "spl2"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wdcstart\""
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wdcstart: not at splbio()\\n\""
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}"
  },
  {
    "function_name": "wdcattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "469-657",
    "snippet": "void\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "int   wdprint",
      "int at_poll = AT_POLL;",
      "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_delref",
          "args": [
            "chp"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_delref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1700-1713",
          "snippet": "void\nwdc_delref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt-- == 1 &&\n\t    adapter->scsipi_enable != NULL)\n\t\t(void) (*adapter->scsipi_enable)(wdc, 0);\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_delref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt-- == 1 &&\n\t    adapter->scsipi_enable != NULL)\n\t\t(void) (*adapter->scsipi_enable)(wdc, 0);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d:%d: device busy\\n\"",
            "chp->wdc->sc_dev.dv_xname",
            "chp->channel",
            "i"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_unbusy",
          "args": [
            "chp",
            "10000"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (i << 4)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdcreset",
          "args": [
            "chp",
            "VERBOSE"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "wdcreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "788-820",
          "snippet": "int\nwdcreset(chp, verb)\n\tstruct channel_softc *chp;\n\tint verb;\n{\n\tint drv_mask1, drv_mask2;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);\n\tdelay(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(2000);\n\t(void) CHP_READ_REG(chp,wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\n\tdrv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;\n\tdrv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;\n\tdrv_mask2 = __wdcwait_reset(chp, drv_mask1);\n\tif (verb && drv_mask2 != drv_mask1) {\n\t\tprintf(\"%s channel %d: reset failed for\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel);\n\t\tif ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)\n\t\t\tprintf(\" drive 0\");\n\t\tif ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)\n\t\t\tprintf(\" drive 1\");\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn  (drv_mask1 != drv_mask2) ? 1 : 0;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int   __wdcwait_reset",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int   __wdcwait_reset;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nint\nwdcreset(chp, verb)\n\tstruct channel_softc *chp;\n\tint verb;\n{\n\tint drv_mask1, drv_mask2;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_RST | WDCTL_IDS);\n\tdelay(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(2000);\n\t(void) CHP_READ_REG(chp,wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\n\tdrv_mask1 = (chp->ch_drive[0].drive_flags & DRIVE) ? 0x01:0x00;\n\tdrv_mask1 |= (chp->ch_drive[1].drive_flags & DRIVE) ? 0x02:0x00;\n\tdrv_mask2 = __wdcwait_reset(chp, drv_mask1);\n\tif (verb && drv_mask2 != drv_mask1) {\n\t\tprintf(\"%s channel %d: reset failed for\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel);\n\t\tif ((drv_mask1 & 0x01) != 0 && (drv_mask2 & 0x01) == 0)\n\t\t\tprintf(\" drive 0\");\n\t\tif ((drv_mask1 & 0x02) != 0 && (drv_mask2 & 0x02) == 0)\n\t\t\tprintf(\" drive 1\");\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn  (drv_mask1 != drv_mask2) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&chp->wdc->sc_dev",
            "(void *)&aa_link",
            "wdprint"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&aa_link",
            "sizeof(struct ata_atapi_attach)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&chp->wdc->sc_dev",
            "(void *)&aa_link",
            "atapi_print"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&aa_link",
            "sizeof(struct ata_atapi_attach)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_atapibus_attach",
          "args": [
            "chp"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_atapibus_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/atapiscsi/atapiscsi.c",
          "lines": "300-319",
          "snippet": "void\nwdc_atapibus_attach(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint channel = chp->channel;\n\tstruct ata_atapi_attach aa_link;\n\n\t/*\n\t * Fill in the adapter.\n\t */\n\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\taa_link.aa_type = T_ATAPI;\n\taa_link.aa_channel = channel;\n\taa_link.aa_openings = 1;\n\taa_link.aa_drv_data = NULL; \n\taa_link.aa_bus_private = chp;\n\n\t(void)config_found(&wdc->sc_dev, (void *)&aa_link, atapi_print);\n}",
          "includes": [
            "#include <dev/atapiscsi/atapiconf.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_tape.h>",
            "#include <scsi/scsi_disk.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/reboot.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/dkstat.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/atapiscsi/atapiconf.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_tape.h>\n#include <scsi/scsi_disk.h>\n#include <scsi/scsi_all.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/reboot.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/dkstat.h>\n#include <sys/disklabel.h>\n#include <sys/dkstat.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_atapibus_attach(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint channel = chp->channel;\n\tstruct ata_atapi_attach aa_link;\n\n\t/*\n\t * Fill in the adapter.\n\t */\n\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\taa_link.aa_type = T_ATAPI;\n\taa_link.aa_channel = channel;\n\taa_link.aa_openings = 1;\n\taa_link.aa_drv_data = NULL; \n\taa_link.aa_bus_private = chp;\n\n\t(void)config_found(&wdc->sc_dev, (void *)&aa_link, atapi_print);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags)",
            "DEBUG_PROBE"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i)",
            "DEBUG_PROBE"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_ready",
          "args": [
            "chp",
            "10000"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_command",
            "WDCC_RECAL"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i)",
            "DEBUG_PROBE"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_ready",
          "args": [
            "chp",
            "10000"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (i << 4)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i)",
            "DEBUG_PROBE"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_cyl_lo"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_error"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_cyl_lo",
            "0xa5"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_features",
            "0x58"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (i << 4)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i)",
            "DEBUG_PROBE"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata_get_params",
          "args": [
            "&chp->ch_drive[i]",
            "at_poll",
            "&params"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ata_get_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
          "lines": "59-149",
          "snippet": "int\nata_get_params(drvp, flags, prms)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t flags;\n\tstruct ataparams *prms;\n{\n\tchar tb[ATAPARAMS_SIZE];\n\tstruct wdc_command wdc_c;\n\n\tint i;\n\tu_int16_t *p;\n\n\tWDCDEBUG_PRINT((\"ata_get_parms\\n\"), DEBUG_FUNCS);\n\n\tbzero(tb, sizeof(tb));\n\tbzero(prms, sizeof(struct ataparams));\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\tif (drvp->drive_flags & DRIVE_ATA) {\n\t\twdc_c.r_command = WDCC_IDENTIFY;\n\t\twdc_c.r_st_bmask = WDCS_DRDY;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 1000; /* 1s */\n\t} else if (drvp->drive_flags & DRIVE_ATAPI) {\n\t\twdc_c.r_command = ATAPI_IDENTIFY_DEVICE;\n\t\twdc_c.r_st_bmask = 0;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 10000; /* 10s */\n\t} else {\n\t\treturn CMD_ERR;\n\t}\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.data = tb;\n\twdc_c.bcount = ATAPARAMS_SIZE;\n\n\t{\n\t\tint ret;\n\t\tif ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {\n\t\t\tprintf (\"WDC_EXEC_COMMAND: %d\\n\");\n\t\t\treturn CMD_AGAIN;\n\t\t}\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t} else {\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t/* All the fields in the params structure are 16-bit\n\t\t   integers except for the ID strings which are char\n\t\t   strings.  The 16-bit integers are currently in\n\t\t   memory in little-endian, regardless of architecture.\n\t\t   So, they need to be swapped on big-endian architectures\n\t\t   before they are accessed through the ataparams structure.\n\n\t\t   The swaps below avoid touching the char strings.\n\t\t*/\n\t\t  \n\t\tswap16_multi((u_int16_t *)tb, 10);\n\t\tswap16_multi((u_int16_t *)tb + 20, 3);\n\t\tswap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);\n#endif\n\t\t/* Read in parameter block. */\n\t\tbcopy(tb, prms, sizeof(struct ataparams));\n\n\t\t/*\n\t\t * Shuffle string byte order.\n\t\t * ATAPI Mitsumi and NEC drives don't need this.\n\t\t */\n\t\tif ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==\n\t\t    WDC_CFG_ATAPI &&\n\t\t    ((prms->atap_model[0] == 'N' &&\n\t\t\tprms->atap_model[1] == 'E') ||\n\t\t     (prms->atap_model[0] == 'F' &&\n\t\t\t prms->atap_model[1] == 'X')))\n\t\t\treturn 0;\n\t\tfor (i = 0; i < sizeof(prms->atap_model); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_model + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_serial); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_serial + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_revision); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_revision + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\n\t\treturn CMD_OK;\n\t}\n}",
          "includes": [
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ATAPARAMS_SIZE 512",
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ATAPARAMS_SIZE 512\n#define DEBUG_FUNCS  0x08\n\nint\nata_get_params(drvp, flags, prms)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t flags;\n\tstruct ataparams *prms;\n{\n\tchar tb[ATAPARAMS_SIZE];\n\tstruct wdc_command wdc_c;\n\n\tint i;\n\tu_int16_t *p;\n\n\tWDCDEBUG_PRINT((\"ata_get_parms\\n\"), DEBUG_FUNCS);\n\n\tbzero(tb, sizeof(tb));\n\tbzero(prms, sizeof(struct ataparams));\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\tif (drvp->drive_flags & DRIVE_ATA) {\n\t\twdc_c.r_command = WDCC_IDENTIFY;\n\t\twdc_c.r_st_bmask = WDCS_DRDY;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 1000; /* 1s */\n\t} else if (drvp->drive_flags & DRIVE_ATAPI) {\n\t\twdc_c.r_command = ATAPI_IDENTIFY_DEVICE;\n\t\twdc_c.r_st_bmask = 0;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 10000; /* 10s */\n\t} else {\n\t\treturn CMD_ERR;\n\t}\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.data = tb;\n\twdc_c.bcount = ATAPARAMS_SIZE;\n\n\t{\n\t\tint ret;\n\t\tif ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {\n\t\t\tprintf (\"WDC_EXEC_COMMAND: %d\\n\");\n\t\t\treturn CMD_AGAIN;\n\t\t}\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t} else {\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t/* All the fields in the params structure are 16-bit\n\t\t   integers except for the ID strings which are char\n\t\t   strings.  The 16-bit integers are currently in\n\t\t   memory in little-endian, regardless of architecture.\n\t\t   So, they need to be swapped on big-endian architectures\n\t\t   before they are accessed through the ataparams structure.\n\n\t\t   The swaps below avoid touching the char strings.\n\t\t*/\n\t\t  \n\t\tswap16_multi((u_int16_t *)tb, 10);\n\t\tswap16_multi((u_int16_t *)tb + 20, 3);\n\t\tswap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);\n#endif\n\t\t/* Read in parameter block. */\n\t\tbcopy(tb, prms, sizeof(struct ataparams));\n\n\t\t/*\n\t\t * Shuffle string byte order.\n\t\t * ATAPI Mitsumi and NEC drives don't need this.\n\t\t */\n\t\tif ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==\n\t\t    WDC_CFG_ATAPI &&\n\t\t    ((prms->atap_model[0] == 'N' &&\n\t\t\tprms->atap_model[1] == 'E') ||\n\t\t     (prms->atap_model[0] == 'F' &&\n\t\t\t prms->atap_model[1] == 'X')))\n\t\t\treturn 0;\n\t\tfor (i = 0; i < sizeof(prms->atap_model); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_model + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_serial); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_serial + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_revision); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_revision + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\n\t\treturn CMD_OK;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&chp->ch_queue->sc_xfer"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INIT",
          "args": [
            "&xfer_free_list"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdcprobe",
          "args": [
            "chp"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "wdcprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "358-449",
          "snippet": "int\nwdcprobe(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int8_t st0, st1, sc, sn, cl, ch;\n\tu_int8_t ret_value = 0x03;\n\tu_int8_t drive;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\t/*\n\t * Sanity check to see if the wdc channel responds at all.\n\t */\n\tif (chp->wdc == NULL ||\n\t    (chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d: before reset, st0=0x%x, st1=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t\t    chp->channel, st0, st1), DEBUG_PROBE);\n\n\t\tif (st0 == 0xff)\n\t\t\tret_value &= ~0x01;\n\t\tif (st1 == 0xff)\n\t\t\tret_value &= ~0x02;\n\t\tif (ret_value == 0) \n\t\t\treturn 0;\n\t}\n\n\t/* assert SRST, wait for reset to complete */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\tdelay(10);\n\tCHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_IDS); \n\tDELAY(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(1000);\n\t(void) CHP_READ_REG(chp, wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\tdelay(10);\n\n\tret_value = __wdcwait_reset(chp, ret_value);\n\tWDCDEBUG_PRINT((\"%s:%d: after reset, ret_value=0x%d\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    ret_value), DEBUG_PROBE);\n\n\t/* if reset failed, there's nothing here */\n\tif (ret_value == 0)\n\t\treturn 0;\n\n\t/*\n\t * Test presence of drives. First test register signatures looking for\n\t * ATAPI devices. If it's not an ATAPI and reset said there may be\n\t * something here assume it's ATA or OLD. Ghost will be killed later in\n\t * attach routine.\n\t */\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tif ((ret_value & (0x01 << drive)) == 0)\n\t\t\tcontinue;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\t\tdelay(10);\n\t\t/* Save registers contents */\n\t\tsc = CHP_READ_REG(chp, wdr_seccnt);\n\t\tsn = CHP_READ_REG(chp, wdr_sector);\n\t\tcl = CHP_READ_REG(chp, wdr_cyl_lo);\n\t\tch = CHP_READ_REG(chp, wdr_cyl_hi);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d:%d: after reset, sc=0x%x sn=0x%x \"\n\t\t    \"cl=0x%x ch=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t    \t    chp->channel, drive, sc, sn, cl, ch), DEBUG_PROBE);\n\t\t/*\n\t\t * This is a simplification of the test in the ATAPI\n\t\t * spec since not all drives seem to set the other regs\n\t\t * correctly.\n\t\t */\n\t\tif (cl == 0x14 && ch == 0xeb) {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATAPI;\n\t\t} else {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATA;\n\t\t\tif (chp->wdc == NULL ||\n\t\t\t    (chp->wdc->cap & WDC_CAPABILITY_PREATA) != 0)\n\t\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_OLD;\n\t\t}\n\t}\n\treturn (ret_value);\t\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "static int   __wdcwait_reset",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nstatic int   __wdcwait_reset;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nint\nwdcprobe(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int8_t st0, st1, sc, sn, cl, ch;\n\tu_int8_t ret_value = 0x03;\n\tu_int8_t drive;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\t/*\n\t * Sanity check to see if the wdc channel responds at all.\n\t */\n\tif (chp->wdc == NULL ||\n\t    (chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d: before reset, st0=0x%x, st1=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t\t    chp->channel, st0, st1), DEBUG_PROBE);\n\n\t\tif (st0 == 0xff)\n\t\t\tret_value &= ~0x01;\n\t\tif (st1 == 0xff)\n\t\t\tret_value &= ~0x02;\n\t\tif (ret_value == 0) \n\t\t\treturn 0;\n\t}\n\n\t/* assert SRST, wait for reset to complete */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\tdelay(10);\n\tCHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_IDS); \n\tDELAY(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(1000);\n\t(void) CHP_READ_REG(chp, wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\tdelay(10);\n\n\tret_value = __wdcwait_reset(chp, ret_value);\n\tWDCDEBUG_PRINT((\"%s:%d: after reset, ret_value=0x%d\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    ret_value), DEBUG_PROBE);\n\n\t/* if reset failed, there's nothing here */\n\tif (ret_value == 0)\n\t\treturn 0;\n\n\t/*\n\t * Test presence of drives. First test register signatures looking for\n\t * ATAPI devices. If it's not an ATAPI and reset said there may be\n\t * something here assume it's ATA or OLD. Ghost will be killed later in\n\t * attach routine.\n\t */\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tif ((ret_value & (0x01 << drive)) == 0)\n\t\t\tcontinue;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\t\tdelay(10);\n\t\t/* Save registers contents */\n\t\tsc = CHP_READ_REG(chp, wdr_seccnt);\n\t\tsn = CHP_READ_REG(chp, wdr_sector);\n\t\tcl = CHP_READ_REG(chp, wdr_cyl_lo);\n\t\tch = CHP_READ_REG(chp, wdr_cyl_hi);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d:%d: after reset, sc=0x%x sn=0x%x \"\n\t\t    \"cl=0x%x ch=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t    \t    chp->channel, drive, sc, sn, cl, ch), DEBUG_PROBE);\n\t\t/*\n\t\t * This is a simplification of the test in the ATAPI\n\t\t * spec since not all drives seem to set the other regs\n\t\t * correctly.\n\t\t */\n\t\tif (cl == 0x14 && ch == 0xeb) {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATAPI;\n\t\t} else {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATA;\n\t\t\tif (chp->wdc == NULL ||\n\t\t\t    (chp->wdc->cap & WDC_CAPABILITY_PREATA) != 0)\n\t\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_OLD;\n\t\t}\n\t}\n\treturn (ret_value);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_addref",
          "args": [
            "chp"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_addref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1681-1698",
          "snippet": "int\nwdc_addref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc; \n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s, error = 0;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt++ == 0 &&\n\t    adapter->scsipi_enable != NULL) {\n\t\terror = (*adapter->scsipi_enable)(wdc, 1);\n\t\tif (error)\n\t\t\tadapter->scsipi_refcnt--;\n\t}\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwdc_addref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc; \n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s, error = 0;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt++ == 0 &&\n\t    adapter->scsipi_enable != NULL) {\n\t\terror = (*adapter->scsipi_enable)(wdc, 1);\n\t\tif (error)\n\t\t\tadapter->scsipi_refcnt--;\n\t}\n\tsplx(s);\n\treturn (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nint   wdprint;\nint at_poll = AT_POLL;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nvoid\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}"
  },
  {
    "function_name": "wdcactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "454-467",
    "snippet": "int\nwdcactivate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\tint error = 0;\n\tint s;\n\n\ts = splbio();\n\tconfig_activate_children(self, act);\n\tsplx(s);\n\n\treturn (error);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_activate_children",
          "args": [
            "self",
            "act"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwdcactivate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\tint error = 0;\n\tint s;\n\n\ts = splbio();\n\tconfig_activate_children(self, act);\n\tsplx(s);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "wdcprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "358-449",
    "snippet": "int\nwdcprobe(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int8_t st0, st1, sc, sn, cl, ch;\n\tu_int8_t ret_value = 0x03;\n\tu_int8_t drive;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\t/*\n\t * Sanity check to see if the wdc channel responds at all.\n\t */\n\tif (chp->wdc == NULL ||\n\t    (chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d: before reset, st0=0x%x, st1=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t\t    chp->channel, st0, st1), DEBUG_PROBE);\n\n\t\tif (st0 == 0xff)\n\t\t\tret_value &= ~0x01;\n\t\tif (st1 == 0xff)\n\t\t\tret_value &= ~0x02;\n\t\tif (ret_value == 0) \n\t\t\treturn 0;\n\t}\n\n\t/* assert SRST, wait for reset to complete */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\tdelay(10);\n\tCHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_IDS); \n\tDELAY(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(1000);\n\t(void) CHP_READ_REG(chp, wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\tdelay(10);\n\n\tret_value = __wdcwait_reset(chp, ret_value);\n\tWDCDEBUG_PRINT((\"%s:%d: after reset, ret_value=0x%d\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    ret_value), DEBUG_PROBE);\n\n\t/* if reset failed, there's nothing here */\n\tif (ret_value == 0)\n\t\treturn 0;\n\n\t/*\n\t * Test presence of drives. First test register signatures looking for\n\t * ATAPI devices. If it's not an ATAPI and reset said there may be\n\t * something here assume it's ATA or OLD. Ghost will be killed later in\n\t * attach routine.\n\t */\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tif ((ret_value & (0x01 << drive)) == 0)\n\t\t\tcontinue;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\t\tdelay(10);\n\t\t/* Save registers contents */\n\t\tsc = CHP_READ_REG(chp, wdr_seccnt);\n\t\tsn = CHP_READ_REG(chp, wdr_sector);\n\t\tcl = CHP_READ_REG(chp, wdr_cyl_lo);\n\t\tch = CHP_READ_REG(chp, wdr_cyl_hi);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d:%d: after reset, sc=0x%x sn=0x%x \"\n\t\t    \"cl=0x%x ch=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t    \t    chp->channel, drive, sc, sn, cl, ch), DEBUG_PROBE);\n\t\t/*\n\t\t * This is a simplification of the test in the ATAPI\n\t\t * spec since not all drives seem to set the other regs\n\t\t * correctly.\n\t\t */\n\t\tif (cl == 0x14 && ch == 0xeb) {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATAPI;\n\t\t} else {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATA;\n\t\t\tif (chp->wdc == NULL ||\n\t\t\t    (chp->wdc->cap & WDC_CAPABILITY_PREATA) != 0)\n\t\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_OLD;\n\t\t}\n\t}\n\treturn (ret_value);\t\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_PROBE  0x10"
    ],
    "globals_used": [
      "static int   __wdcwait_reset",
      "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"%s:%d:%d: after reset, sc=0x%x sn=0x%x \"\n\t\t    \"cl=0x%x ch=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t    \t    chp->channel, drive, sc, sn, cl, ch)",
            "DEBUG_PROBE"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_cyl_hi"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_cyl_lo"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_sector"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_seccnt"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (drive << 4)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"%s:%d: after reset, ret_value=0x%d\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    ret_value)",
            "DEBUG_PROBE"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wdcwait_reset",
          "args": [
            "chp",
            "ret_value"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "__wdcwait_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "822-873",
          "snippet": "static int\n__wdcwait_reset(chp, drv_mask)\n\tstruct channel_softc *chp;\n\tint drv_mask;\n{\n\tint timeout;\n\tu_int8_t st0, st1;\n\n\t/* Wait 50ms for drive firmware to settle */\n\tdelay(50000);\n\n\t/* wait for BSY to deassert */\n\tfor (timeout = 0; timeout < WDCNDELAY_RST;timeout++) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10); /* slave */\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tif ((drv_mask & 0x01) == 0) {\n\t\t\t/* no master */\n\t\t\tif ((drv_mask & 0x02) != 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\t/* No master, slave is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else if ((drv_mask & 0x02) == 0) {\n\t\t\t/* no slave */\n\t\t\tif ((drv_mask & 0x01) != 0 && (st0 & WDCS_BSY) == 0) {\n\t\t\t\t/* No slave, master is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Wait for both master and slave to be ready */\n\t\t\tif ((st0 & WDCS_BSY) == 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n\t/* Reset timed out. Maybe it's because drv_mask was not rigth */\n\tif (st0 & WDCS_BSY)\n\t\tdrv_mask &= ~0x01;\n\tif (st1 & WDCS_BSY)\n\t\tdrv_mask &= ~0x02;\nend:\n\tWDCDEBUG_PRINT((\"%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    st0, st1), DEBUG_PROBE);\n\n\treturn drv_mask;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10",
            "#define WDCNDELAY_RST (WDC_RESET_WAIT * 1000 / WDCDELAY)",
            "#define WDCDELAY  100 /* 100 microseconds */"
          ],
          "globals_used": [
            "static int   __wdcwait_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n#define WDCNDELAY_RST (WDC_RESET_WAIT * 1000 / WDCDELAY)\n#define WDCDELAY  100 /* 100 microseconds */\n\nstatic int   __wdcwait_reset;\n\nstatic int\n__wdcwait_reset(chp, drv_mask)\n\tstruct channel_softc *chp;\n\tint drv_mask;\n{\n\tint timeout;\n\tu_int8_t st0, st1;\n\n\t/* Wait 50ms for drive firmware to settle */\n\tdelay(50000);\n\n\t/* wait for BSY to deassert */\n\tfor (timeout = 0; timeout < WDCNDELAY_RST;timeout++) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM); /* master */\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10); /* slave */\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tif ((drv_mask & 0x01) == 0) {\n\t\t\t/* no master */\n\t\t\tif ((drv_mask & 0x02) != 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\t/* No master, slave is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else if ((drv_mask & 0x02) == 0) {\n\t\t\t/* no slave */\n\t\t\tif ((drv_mask & 0x01) != 0 && (st0 & WDCS_BSY) == 0) {\n\t\t\t\t/* No slave, master is ready, it's done */\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Wait for both master and slave to be ready */\n\t\t\tif ((st0 & WDCS_BSY) == 0 && (st1 & WDCS_BSY) == 0) {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n\t/* Reset timed out. Maybe it's because drv_mask was not rigth */\n\tif (st0 & WDCS_BSY)\n\t\tdrv_mask &= ~0x01;\n\tif (st1 & WDCS_BSY)\n\t\tdrv_mask &= ~0x02;\nend:\n\tWDCDEBUG_PRINT((\"%s:%d: wdcwait_reset() end, st0=0x%x, st1=0x%x\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    st0, st1), DEBUG_PROBE);\n\n\treturn drv_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_ctlr",
            "WDCTL_4BIT"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_error"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_ctlr",
            "WDCTL_IDS"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_ctlr",
            "WDCTL_RST | WDCTL_IDS"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"%s:%d: before reset, st0=0x%x, st1=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t\t    chp->channel, st0, st1)",
            "DEBUG_PROBE"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_status"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | 0x10"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_READ_REG",
          "args": [
            "chp",
            "wdr_status"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nstatic int   __wdcwait_reset;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nint\nwdcprobe(chp)\n\tstruct channel_softc *chp;\n{\n\tu_int8_t st0, st1, sc, sn, cl, ch;\n\tu_int8_t ret_value = 0x03;\n\tu_int8_t drive;\n\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\t/*\n\t * Sanity check to see if the wdc channel responds at all.\n\t */\n\tif (chp->wdc == NULL ||\n\t    (chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\t\tdelay(10);\n\t\tst0 = CHP_READ_REG(chp, wdr_status);\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n\t\tdelay(10);\n\t\tst1 = CHP_READ_REG(chp, wdr_status);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d: before reset, st0=0x%x, st1=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t\t    chp->channel, st0, st1), DEBUG_PROBE);\n\n\t\tif (st0 == 0xff)\n\t\t\tret_value &= ~0x01;\n\t\tif (st1 == 0xff)\n\t\t\tret_value &= ~0x02;\n\t\tif (ret_value == 0) \n\t\t\treturn 0;\n\t}\n\n\t/* assert SRST, wait for reset to complete */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM);\n\tdelay(10);\n\tCHP_WRITE_REG(chp,wdr_ctlr, WDCTL_RST | WDCTL_IDS); \n\tDELAY(1000);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n\tdelay(1000);\n\t(void) CHP_READ_REG(chp, wdr_error);\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n\tdelay(10);\n\n\tret_value = __wdcwait_reset(chp, ret_value);\n\tWDCDEBUG_PRINT((\"%s:%d: after reset, ret_value=0x%d\\n\",\n\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\", chp->channel,\n\t    ret_value), DEBUG_PROBE);\n\n\t/* if reset failed, there's nothing here */\n\tif (ret_value == 0)\n\t\treturn 0;\n\n\t/*\n\t * Test presence of drives. First test register signatures looking for\n\t * ATAPI devices. If it's not an ATAPI and reset said there may be\n\t * something here assume it's ATA or OLD. Ghost will be killed later in\n\t * attach routine.\n\t */\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tif ((ret_value & (0x01 << drive)) == 0)\n\t\t\tcontinue;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\t\tdelay(10);\n\t\t/* Save registers contents */\n\t\tsc = CHP_READ_REG(chp, wdr_seccnt);\n\t\tsn = CHP_READ_REG(chp, wdr_sector);\n\t\tcl = CHP_READ_REG(chp, wdr_cyl_lo);\n\t\tch = CHP_READ_REG(chp, wdr_cyl_hi);\n\n\t\tWDCDEBUG_PRINT((\"%s:%d:%d: after reset, sc=0x%x sn=0x%x \"\n\t\t    \"cl=0x%x ch=0x%x\\n\",\n\t\t    chp->wdc ? chp->wdc->sc_dev.dv_xname : \"wdcprobe\",\n\t    \t    chp->channel, drive, sc, sn, cl, ch), DEBUG_PROBE);\n\t\t/*\n\t\t * This is a simplification of the test in the ATAPI\n\t\t * spec since not all drives seem to set the other regs\n\t\t * correctly.\n\t\t */\n\t\tif (cl == 0x14 && ch == 0xeb) {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATAPI;\n\t\t} else {\n\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_ATA;\n\t\t\tif (chp->wdc == NULL ||\n\t\t\t    (chp->wdc->cap & WDC_CAPABILITY_PREATA) != 0)\n\t\t\t\tchp->ch_drive[drive].drive_flags |= DRIVE_OLD;\n\t\t}\n\t}\n\treturn (ret_value);\t\n}"
  },
  {
    "function_name": "wdc_select_drive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "321-343",
    "snippet": "int\nwdc_select_drive(chp, drive, howlong)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint howlong;\n{\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\t\n\tdelay(1);\n\n\tif (wdcwait(chp, WDCS_DRQ, 0, howlong)) {\n\t\tWDCDEBUG_PRINT((\"wdc_select_drive %s:%d:%d waiting for %d\"\n\t\t\t\t\"after\\n\",\n\t\t\t\tchp->wdc->sc_dev.dv_xname, chp->channel, drive,\n\t\t\t\thowlong),\n\t\t\t       DEBUG_SDRIVE);\n\t\t\n\t\t\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_SDRIVE 0x40"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_select_drive %s:%d:%d waiting for %d\"\n\t\t\t\t\"after\\n\",\n\t\t\t\tchp->wdc->sc_dev.dv_xname, chp->channel, drive,\n\t\t\t\thowlong)",
            "DEBUG_SDRIVE"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdcwait",
          "args": [
            "chp",
            "WDCS_DRQ",
            "0",
            "howlong"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "wdcwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "879-950",
          "snippet": "int\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_STATUSX 0x20",
            "#define DEBUG_STATUS 0x04",
            "#define WDCNDELAY_DEBUG\t50",
            "#define WDCDELAY  100 /* 100 microseconds */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_STATUSX 0x20\n#define DEBUG_STATUS 0x04\n#define WDCNDELAY_DEBUG\t50\n#define WDCDELAY  100 /* 100 microseconds */\n\nint\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (drive << 4)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_SDRIVE 0x40\n\nint\nwdc_select_drive(chp, drive, howlong)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint howlong;\n{\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\t\n\tdelay(1);\n\n\tif (wdcwait(chp, WDCS_DRQ, 0, howlong)) {\n\t\tWDCDEBUG_PRINT((\"wdc_select_drive %s:%d:%d waiting for %d\"\n\t\t\t\t\"after\\n\",\n\t\t\t\tchp->wdc->sc_dev.dv_xname, chp->channel, drive,\n\t\t\t\thowlong),\n\t\t\t       DEBUG_SDRIVE);\n\t\t\n\t\t\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wdc_enable_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "314-319",
    "snippet": "void\nwdc_enable_intr(chp)\n\tstruct channel_softc *chp;\n{\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_ctlr",
            "WDCTL_4BIT"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_enable_intr(chp)\n\tstruct channel_softc *chp;\n{\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_4BIT);\n}"
  },
  {
    "function_name": "wdc_disable_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "307-312",
    "snippet": "void\nwdc_disable_intr(chp)\n\tstruct channel_softc *chp;\n{\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_ctlr",
            "WDCTL_IDS"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_disable_intr(chp)\n\tstruct channel_softc *chp;\n{\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n}"
  },
  {
    "function_name": "atapi_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "295-305",
    "snippet": "int\natapi_print(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct ata_atapi_attach *aa_link = aux;\n\tif (pnp)\n\t\tprintf(\"atapibus at %s\", pnp);\n\tprintf(\" channel %d\", aa_link->aa_channel);\n\treturn (UNCONF);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" channel %d\"",
            "aa_link->aa_channel"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\natapi_print(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct ata_atapi_attach *aa_link = aux;\n\tif (pnp)\n\t\tprintf(\"atapibus at %s\", pnp);\n\tprintf(\" channel %d\", aa_link->aa_channel);\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "wdprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "282-293",
    "snippet": "int\nwdprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct ata_atapi_attach *aa_link = aux;\n\tif (pnp)\n\t\tprintf(\"drive at %s\", pnp);\n\tprintf(\" channel %d drive %d\", aa_link->aa_channel,\n\t    aa_link->aa_drv_data->drive);\n\treturn (UNCONF);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int   wdprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" channel %d drive %d\"",
            "aa_link->aa_channel",
            "aa_link->aa_drv_data->drive"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint   wdprint;\n\nint\nwdprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct ata_atapi_attach *aa_link = aux;\n\tif (pnp)\n\t\tprintf(\"drive at %s\", pnp);\n\tprintf(\" channel %d drive %d\", aa_link->aa_channel,\n\t    aa_link->aa_drv_data->drive);\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "wdc_default_read_raw_multi_4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "260-279",
    "snippet": "void\nwdc_default_read_raw_multi_4(chp, data, nbytes)\n\tstruct channel_softc *chp;\n\tvoid *data;\n\tunsigned int nbytes;\n{\n\tif (data == NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nbytes; i += 4) {\n\t\t\tbus_space_read_4(chp->cmd_iot, chp->cmd_ioh, 0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbus_space_read_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0, \n\t    data, nbytes);\n\treturn;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wdc_default_read_raw_multi_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_raw_multi_4",
          "args": [
            "chp->cmd_iot",
            "chp->cmd_ioh",
            "0",
            "data",
            "nbytes"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "chp->cmd_iot",
            "chp->cmd_ioh",
            "0"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wdc_default_read_raw_multi_4;\n\nvoid\nwdc_default_read_raw_multi_4(chp, data, nbytes)\n\tstruct channel_softc *chp;\n\tvoid *data;\n\tunsigned int nbytes;\n{\n\tif (data == NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nbytes; i += 4) {\n\t\t\tbus_space_read_4(chp->cmd_iot, chp->cmd_ioh, 0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbus_space_read_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0, \n\t    data, nbytes);\n\treturn;\n}"
  },
  {
    "function_name": "wdc_default_write_raw_multi_4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "238-257",
    "snippet": "void\nwdc_default_write_raw_multi_4(chp, data, nbytes)\n\tstruct channel_softc *chp;\n\tvoid *data;\n\tunsigned int nbytes;\n{\n\tif (data == NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nbytes; i += 4) {\n\t\t\tbus_space_write_4(chp->cmd_iot, chp->cmd_ioh, 0, 0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbus_space_write_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0, \n\t    data, nbytes);\n\treturn;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wdc_default_write_raw_multi_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_4",
          "args": [
            "chp->cmd_iot",
            "chp->cmd_ioh",
            "0",
            "data",
            "nbytes"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "chp->cmd_iot",
            "chp->cmd_ioh",
            "0",
            "0"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wdc_default_write_raw_multi_4;\n\nvoid\nwdc_default_write_raw_multi_4(chp, data, nbytes)\n\tstruct channel_softc *chp;\n\tvoid *data;\n\tunsigned int nbytes;\n{\n\tif (data == NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nbytes; i += 4) {\n\t\t\tbus_space_write_4(chp->cmd_iot, chp->cmd_ioh, 0, 0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbus_space_write_raw_multi_4(chp->cmd_iot, chp->cmd_ioh, 0, \n\t    data, nbytes);\n\treturn;\n}"
  },
  {
    "function_name": "wdc_default_write_raw_multi_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "216-235",
    "snippet": "void\nwdc_default_write_raw_multi_2(chp, data, nbytes)\n\tstruct channel_softc *chp;\n\tvoid *data;\n\tunsigned int nbytes;\n{\n\tif (data == NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nbytes; i += 2) {\n\t\t\tbus_space_write_2(chp->cmd_iot, chp->cmd_ioh, 0, 0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbus_space_write_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0, \n\t    data, nbytes);\n\treturn;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wdc_default_write_raw_multi_2"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "chp->cmd_iot",
            "chp->cmd_ioh",
            "0",
            "data",
            "nbytes"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "chp->cmd_iot",
            "chp->cmd_ioh",
            "0",
            "0"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wdc_default_write_raw_multi_2;\n\nvoid\nwdc_default_write_raw_multi_2(chp, data, nbytes)\n\tstruct channel_softc *chp;\n\tvoid *data;\n\tunsigned int nbytes;\n{\n\tif (data == NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nbytes; i += 2) {\n\t\t\tbus_space_write_2(chp->cmd_iot, chp->cmd_ioh, 0, 0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbus_space_write_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0, \n\t    data, nbytes);\n\treturn;\n}"
  },
  {
    "function_name": "wdc_default_read_raw_multi_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "194-213",
    "snippet": "void\nwdc_default_read_raw_multi_2(chp, data, nbytes)\n\tstruct channel_softc *chp;\n\tvoid *data;\n\tunsigned int nbytes;\n{\n\tif (data == NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nbytes; i += 2) {\n\t\t\tbus_space_read_2(chp->cmd_iot, chp->cmd_ioh, 0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbus_space_read_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0, \n\t    data, nbytes);\n\treturn;\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wdc_default_read_raw_multi_2"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_raw_multi_2",
          "args": [
            "chp->cmd_iot",
            "chp->cmd_ioh",
            "0",
            "data",
            "nbytes"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "chp->cmd_iot",
            "chp->cmd_ioh",
            "0"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wdc_default_read_raw_multi_2;\n\nvoid\nwdc_default_read_raw_multi_2(chp, data, nbytes)\n\tstruct channel_softc *chp;\n\tvoid *data;\n\tunsigned int nbytes;\n{\n\tif (data == NULL) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nbytes; i += 2) {\n\t\t\tbus_space_read_2(chp->cmd_iot, chp->cmd_ioh, 0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbus_space_read_raw_multi_2(chp->cmd_iot, chp->cmd_ioh, 0, \n\t    data, nbytes);\n\treturn;\n}"
  },
  {
    "function_name": "wdc_default_write_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "173-191",
    "snippet": "void\nwdc_default_write_reg(chp, reg, val)\n\tstruct channel_softc *chp;\n\tenum wdc_regs reg;\n\tu_int8_t val;\n{\n#ifdef DIAGNOSTIC\t\n\tif (reg & _WDC_RDONLY) {\n\t\tprintf (\"wdc_default_write_reg: writing to a read-only register %d\\n\", reg);\n\t}\n#endif\n\n\tif (reg & _WDC_AUX) \n\t\tbus_space_write_1(chp->ctl_iot, chp->ctl_ioh,\n\t\t    reg & _WDC_REGMASK, val);\n\telse\n\t\tbus_space_write_1(chp->cmd_iot, chp->cmd_ioh,\n\t\t    reg & _WDC_REGMASK, val);\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wdc_default_write_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "chp->cmd_iot",
            "chp->cmd_ioh",
            "reg & _WDC_REGMASK",
            "val"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "chp->ctl_iot",
            "chp->ctl_ioh",
            "reg & _WDC_REGMASK",
            "val"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wdc_default_write_reg: writing to a read-only register %d\\n\"",
            "reg"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid wdc_default_write_reg;\n\nvoid\nwdc_default_write_reg(chp, reg, val)\n\tstruct channel_softc *chp;\n\tenum wdc_regs reg;\n\tu_int8_t val;\n{\n#ifdef DIAGNOSTIC\t\n\tif (reg & _WDC_RDONLY) {\n\t\tprintf (\"wdc_default_write_reg: writing to a read-only register %d\\n\", reg);\n\t}\n#endif\n\n\tif (reg & _WDC_AUX) \n\t\tbus_space_write_1(chp->ctl_iot, chp->ctl_ioh,\n\t\t    reg & _WDC_REGMASK, val);\n\telse\n\t\tbus_space_write_1(chp->cmd_iot, chp->cmd_ioh,\n\t\t    reg & _WDC_REGMASK, val);\n}"
  },
  {
    "function_name": "wdc_default_read_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
    "lines": "154-171",
    "snippet": "u_int8_t\nwdc_default_read_reg(chp, reg)\n\tstruct channel_softc *chp;\n\tenum wdc_regs reg;\n{\n#ifdef DIAGNOSTIC\t\n\tif (reg & _WDC_WRONLY) {\n\t\tprintf (\"wdc_default_read_reg: reading from a write-only register %d\\n\", reg);\n\t}\n#endif\n\n\tif (reg & _WDC_AUX) \n\t\treturn (bus_space_read_1(chp->ctl_iot, chp->ctl_ioh,\n\t\t    reg & _WDC_REGMASK));\n\telse\n\t\treturn (bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,\n\t\t    reg & _WDC_REGMASK));\n}",
    "includes": [
      "#include \"atapiscsi.h\"",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atareg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t wdc_default_read_reg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "chp->cmd_iot",
            "chp->cmd_ioh",
            "reg & _WDC_REGMASK"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "chp->ctl_iot",
            "chp->ctl_ioh",
            "reg & _WDC_REGMASK"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wdc_default_read_reg: reading from a write-only register %d\\n\"",
            "reg"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t wdc_default_read_reg;\n\nu_int8_t\nwdc_default_read_reg(chp, reg)\n\tstruct channel_softc *chp;\n\tenum wdc_regs reg;\n{\n#ifdef DIAGNOSTIC\t\n\tif (reg & _WDC_WRONLY) {\n\t\tprintf (\"wdc_default_read_reg: reading from a write-only register %d\\n\", reg);\n\t}\n#endif\n\n\tif (reg & _WDC_AUX) \n\t\treturn (bus_space_read_1(chp->ctl_iot, chp->ctl_ioh,\n\t\t    reg & _WDC_REGMASK));\n\telse\n\t\treturn (bus_space_read_1(chp->cmd_iot, chp->cmd_ioh,\n\t\t    reg & _WDC_REGMASK));\n}"
  }
]