[
  {
    "function_name": "ugenpoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "1135-1189",
    "snippet": "int\nugenpoll(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\tstruct ugen_softc *sc;\n\tstruct ugen_endpoint *sce;\n\tint revents = 0;\n\tint s;\n\n\tUSB_GET_SC(ugen, UGENUNIT(dev), sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\t/* XXX always IN */\n\tsce = &sc->sc_endpoints[UGENENDPOINT(dev)][IN];\n\tif (sce == NULL)\n\t\treturn (EINVAL);\n#ifdef DIAGNOSTIC\n\tif (!sce->edesc) {\n\t\tprintf(\"ugenpoll: no edesc\\n\");\n\t\treturn (EIO);\n\t}\n\tif (!sce->pipeh) {\n\t\tprintf(\"ugenpoll: no pipe\\n\");\n\t\treturn (EIO);\n\t}\n#endif\n\ts = splusb();\n\tswitch (sce->edesc->bmAttributes & UE_XFERTYPE) {\n\tcase UE_INTERRUPT:\n\t\tif (events & (POLLIN | POLLRDNORM)) {\n\t\t\tif (sce->q.c_cc > 0)\n\t\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\t\telse\n\t\t\t\tselrecord(p, &sce->rsel);\n\t\t}\n\t\tbreak;\n\tcase UE_BULK:\n\t\t/* \n\t\t * We have no easy way of determining if a read will\n\t\t * yield any data or a write will happen.\n\t\t * Pretend they will.\n\t\t */\n\t\trevents |= events & \n\t\t\t   (POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (revents);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define IN  1"
    ],
    "globals_used": [
      "ugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));",
      "ugen_set_interface __P((struct ugen_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selrecord",
          "args": [
            "p",
            "&sce->rsel"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ugenpoll: no pipe\\n\""
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UGENENDPOINT",
          "args": [
            "dev"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "ugen",
            "UGENUNIT(dev)",
            "sc"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENUNIT",
          "args": [
            "dev"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n\nugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));\nugen_set_interface __P((struct ugen_softc *, int, int));\n\nint\nugenpoll(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\tstruct ugen_softc *sc;\n\tstruct ugen_endpoint *sce;\n\tint revents = 0;\n\tint s;\n\n\tUSB_GET_SC(ugen, UGENUNIT(dev), sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\t/* XXX always IN */\n\tsce = &sc->sc_endpoints[UGENENDPOINT(dev)][IN];\n\tif (sce == NULL)\n\t\treturn (EINVAL);\n#ifdef DIAGNOSTIC\n\tif (!sce->edesc) {\n\t\tprintf(\"ugenpoll: no edesc\\n\");\n\t\treturn (EIO);\n\t}\n\tif (!sce->pipeh) {\n\t\tprintf(\"ugenpoll: no pipe\\n\");\n\t\treturn (EIO);\n\t}\n#endif\n\ts = splusb();\n\tswitch (sce->edesc->bmAttributes & UE_XFERTYPE) {\n\tcase UE_INTERRUPT:\n\t\tif (events & (POLLIN | POLLRDNORM)) {\n\t\t\tif (sce->q.c_cc > 0)\n\t\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\t\telse\n\t\t\t\tselrecord(p, &sce->rsel);\n\t\t}\n\t\tbreak;\n\tcase UE_BULK:\n\t\t/* \n\t\t * We have no easy way of determining if a read will\n\t\t * yield any data or a write will happen.\n\t\t * Pretend they will.\n\t\t */\n\t\trevents |= events & \n\t\t\t   (POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (revents);\n}"
  },
  {
    "function_name": "ugenioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "1114-1133",
    "snippet": "int\nugenioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr; \n\tint flag;\n\tstruct proc *p;\n{\n\tint endpt = UGENENDPOINT(dev);\n\tstruct ugen_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(ugen, UGENUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = ugen_do_ioctl(sc, endpt, cmd, addr, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));",
      "ugen_set_interface __P((struct ugen_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugen_do_ioctl",
          "args": [
            "sc",
            "endpt",
            "cmd",
            "addr",
            "flag",
            "p"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "ugen_do_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
          "lines": "842-1112",
          "snippet": "Static int\nugen_do_ioctl(sc, endpt, cmd, addr, flag, p)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tu_long cmd;\n\tcaddr_t addr; \n\tint flag;\n\tstruct proc *p;\n{\n\tstruct ugen_endpoint *sce;\n\tusbd_status err;\n\tusbd_interface_handle iface;\n\tstruct usb_config_desc *cd;\n\tusb_config_descriptor_t *cdesc;\n\tstruct usb_interface_desc *id;\n\tusb_interface_descriptor_t *idesc;\n\tstruct usb_endpoint_desc *ed;\n\tusb_endpoint_descriptor_t *edesc;\n\tstruct usb_alt_interface *ai;\n\tstruct usb_string_desc *si;\n\tu_int8_t conf, alt;\n\n\tDPRINTFN(5, (\"ugenioctl: cmd=%08lx\\n\", cmd));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\treturn (0);\n\tcase USB_SET_SHORT_XFER:\n\t\t/* This flag only affects read */\n\t\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\t\treturn (EINVAL);\n\t\tsce = &sc->sc_endpoints[endpt][IN];\n\t\tif (sce == NULL)\n\t\t\treturn (EINVAL);\n#ifdef DIAGNOSTIC\n\t\tif (sce->pipeh == NULL) {\n\t\t\tprintf(\"ugenioctl: USB_SET_SHORT_XFER, no pipe\\n\");\n\t\t\treturn (EIO);\n\t\t}\n#endif\n\t\tif (*(int *)addr)\n\t\t\tsce->state |= UGEN_SHORT_OK;\n\t\telse\n\t\t\tsce->state &= ~UGEN_SHORT_OK;\n\t\treturn (0);\n\tcase USB_SET_TIMEOUT:\n\t\tsce = &sc->sc_endpoints[endpt][IN];\n\t\tif (sce == NULL)\n\t\t\treturn (EINVAL);\n#ifdef DIAGNOSTIC\n\t\tif (sce->pipeh == NULL) {\n\t\t\tprintf(\"ugenioctl: USB_SET_TIMEOUT, no pipe\\n\");\n\t\t\treturn (EIO);\n\t\t}\n#endif\n\t\tsce->timeout = *(int *)addr;\n\t\treturn (0);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (endpt != USB_CONTROL_ENDPOINT)\n\t\treturn (EINVAL);\n\n\tswitch (cmd) {\n#ifdef UGEN_DEBUG\n\tcase USB_SETDEBUG:\n\t\tugendebug = *(int *)addr;\n\t\tbreak;\n#endif\n\tcase USB_GET_CONFIG:\n\t\terr = usbd_get_config(sc->sc_udev, &conf);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\t*(int *)addr = conf;\n\t\tbreak;\n\tcase USB_SET_CONFIG:\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\terr = ugen_set_config(sc, *(int *)addr);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\tcase USB_GET_ALTINTERFACE:\n\t\tai = (struct usb_alt_interface *)addr;\n\t\terr = usbd_device2interface_handle(sc->sc_udev, \n\t\t\t  ai->interface_index, &iface);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tidesc = usbd_get_interface_descriptor(iface);\n\t\tif (idesc == NULL)\n\t\t\treturn (EIO);\n\t\tai->alt_no = idesc->bAlternateSetting;\n\t\tbreak;\n\tcase USB_SET_ALTINTERFACE:\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\tai = (struct usb_alt_interface *)addr;\n\t\terr = usbd_device2interface_handle(sc->sc_udev, \n\t\t\t  ai->interface_index, &iface);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\terr = ugen_set_interface(sc, ai->interface_index, ai->alt_no);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase USB_GET_NO_ALT:\n\t\tai = (struct usb_alt_interface *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, ai->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tidesc = usbd_find_idesc(cdesc, ai->interface_index, 0);\n\t\tif (idesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tai->alt_no = usbd_get_no_alts(cdesc, idesc->bInterfaceNumber);\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_DEVICE_DESC:\n\t\t*(usb_device_descriptor_t *)addr =\n\t\t\t*usbd_get_device_descriptor(sc->sc_udev);\n\t\tbreak;\n\tcase USB_GET_CONFIG_DESC:\n\t\tcd = (struct usb_config_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, cd->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tcd->desc = *cdesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_INTERFACE_DESC:\n\t\tid = (struct usb_interface_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, id->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (id->config_index == USB_CURRENT_CONFIG_INDEX &&\n\t\t    id->alt_index == USB_CURRENT_ALT_INDEX)\n\t\t\talt = ugen_get_alt_index(sc, id->interface_index);\n\t\telse\n\t\t\talt = id->alt_index;\n\t\tidesc = usbd_find_idesc(cdesc, id->interface_index, alt);\n\t\tif (idesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tid->desc = *idesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_ENDPOINT_DESC:\n\t\ted = (struct usb_endpoint_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, ed->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (ed->config_index == USB_CURRENT_CONFIG_INDEX &&\n\t\t    ed->alt_index == USB_CURRENT_ALT_INDEX)\n\t\t\talt = ugen_get_alt_index(sc, ed->interface_index);\n\t\telse\n\t\t\talt = ed->alt_index;\n\t\tedesc = usbd_find_edesc(cdesc, ed->interface_index, \n\t\t\t\t\talt, ed->endpoint_index);\n\t\tif (edesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\ted->desc = *edesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_FULL_DESC:\n\t{\n\t\tint len;\n\t\tstruct iovec iov;\n\t\tstruct uio uio;\n\t\tstruct usb_full_desc *fd = (struct usb_full_desc *)addr;\n\t\tint error;\n\n\t\tcdesc = ugen_get_cdesc(sc, fd->config_index, &len);\n\t\tif (len > fd->size)\n\t\t\tlen = fd->size;\n\t\tiov.iov_base = (caddr_t)fd->data;\n\t\tiov.iov_len = len;\n\t\tuio.uio_iov = &iov;\n\t\tuio.uio_iovcnt = 1;\n\t\tuio.uio_resid = len;\n\t\tuio.uio_offset = 0;\n\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\tuio.uio_rw = UIO_READ;\n\t\tuio.uio_procp = p;\n\t\terror = uiomove((void *)cdesc, len, &uio);\n\t\tfree(cdesc, M_TEMP);\n\t\treturn (error);\n\t}\n\tcase USB_GET_STRING_DESC:\n\t\tsi = (struct usb_string_desc *)addr;\n\t\terr = usbd_get_string_desc(sc->sc_udev, si->string_index, \n\t\t\t  si->language_id, &si->desc);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase USB_DO_REQUEST:\n\t{\n\t\tstruct usb_ctl_request *ur = (void *)addr;\n\t\tint len = UGETW(ur->request.wLength);\n\t\tstruct iovec iov;\n\t\tstruct uio uio;\n\t\tvoid *ptr = 0;\n\t\tusbd_status err;\n\t\tint error = 0;\n\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\t/* Avoid requests that would damage the bus integrity. */\n\t\tif ((ur->request.bmRequestType == UT_WRITE_DEVICE &&\n\t\t     ur->request.bRequest == UR_SET_ADDRESS) ||\n\t\t    (ur->request.bmRequestType == UT_WRITE_DEVICE &&\n\t\t     ur->request.bRequest == UR_SET_CONFIG) ||\n\t\t    (ur->request.bmRequestType == UT_WRITE_INTERFACE &&\n\t\t     ur->request.bRequest == UR_SET_INTERFACE))\n\t\t\treturn (EINVAL);\n\n\t\tif (len < 0 || len > 32767)\n\t\t\treturn (EINVAL);\n\t\tif (len != 0) {\n\t\t\tiov.iov_base = (caddr_t)ur->data;\n\t\t\tiov.iov_len = len;\n\t\t\tuio.uio_iov = &iov;\n\t\t\tuio.uio_iovcnt = 1;\n\t\t\tuio.uio_resid = len;\n\t\t\tuio.uio_offset = 0;\n\t\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\t\tuio.uio_rw =\n\t\t\t\tur->request.bmRequestType & UT_READ ? \n\t\t\t\tUIO_READ : UIO_WRITE;\n\t\t\tuio.uio_procp = p;\n\t\t\tptr = malloc(len, M_TEMP, M_WAITOK);\n\t\t\tif (uio.uio_rw == UIO_WRITE) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\terr = usbd_do_request_flags(sc->sc_udev, &ur->request, \n\t\t\t  ptr, ur->flags, &ur->actlen);\n\t\tif (err) {\n\t\t\terror = EIO;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 0) {\n\t\t\tif (uio.uio_rw == UIO_READ) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\tret:\n\t\tif (ptr)\n\t\t\tfree(ptr, M_TEMP);\n\t\treturn (error);\n\t}\n\tcase USB_GET_DEVICEINFO:\n\t\tusbd_fill_deviceinfo(sc->sc_udev,\n\t\t\t\t     (struct usb_device_info *)addr);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/filio.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define IN  1",
            "#define UGEN_SHORT_OK\t0x04\t/* short xfers are OK */"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));",
            "Static int",
            "ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));",
            "Static int",
            "ugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));",
            "Static int",
            "Static usb_config_descriptor_t",
            "Static usbd_status",
            "ugen_set_interface __P((struct ugen_softc *, int, int));",
            "Static int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n#define UGEN_SHORT_OK\t0x04\t/* short xfers are OK */\n\nStatic void;\nStatic int;\nugen_do_read __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nugen_do_write __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));\nStatic int;\nStatic usb_config_descriptor_t;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic int\nugen_do_ioctl(sc, endpt, cmd, addr, flag, p)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tu_long cmd;\n\tcaddr_t addr; \n\tint flag;\n\tstruct proc *p;\n{\n\tstruct ugen_endpoint *sce;\n\tusbd_status err;\n\tusbd_interface_handle iface;\n\tstruct usb_config_desc *cd;\n\tusb_config_descriptor_t *cdesc;\n\tstruct usb_interface_desc *id;\n\tusb_interface_descriptor_t *idesc;\n\tstruct usb_endpoint_desc *ed;\n\tusb_endpoint_descriptor_t *edesc;\n\tstruct usb_alt_interface *ai;\n\tstruct usb_string_desc *si;\n\tu_int8_t conf, alt;\n\n\tDPRINTFN(5, (\"ugenioctl: cmd=%08lx\\n\", cmd));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\treturn (0);\n\tcase USB_SET_SHORT_XFER:\n\t\t/* This flag only affects read */\n\t\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\t\treturn (EINVAL);\n\t\tsce = &sc->sc_endpoints[endpt][IN];\n\t\tif (sce == NULL)\n\t\t\treturn (EINVAL);\n#ifdef DIAGNOSTIC\n\t\tif (sce->pipeh == NULL) {\n\t\t\tprintf(\"ugenioctl: USB_SET_SHORT_XFER, no pipe\\n\");\n\t\t\treturn (EIO);\n\t\t}\n#endif\n\t\tif (*(int *)addr)\n\t\t\tsce->state |= UGEN_SHORT_OK;\n\t\telse\n\t\t\tsce->state &= ~UGEN_SHORT_OK;\n\t\treturn (0);\n\tcase USB_SET_TIMEOUT:\n\t\tsce = &sc->sc_endpoints[endpt][IN];\n\t\tif (sce == NULL)\n\t\t\treturn (EINVAL);\n#ifdef DIAGNOSTIC\n\t\tif (sce->pipeh == NULL) {\n\t\t\tprintf(\"ugenioctl: USB_SET_TIMEOUT, no pipe\\n\");\n\t\t\treturn (EIO);\n\t\t}\n#endif\n\t\tsce->timeout = *(int *)addr;\n\t\treturn (0);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (endpt != USB_CONTROL_ENDPOINT)\n\t\treturn (EINVAL);\n\n\tswitch (cmd) {\n#ifdef UGEN_DEBUG\n\tcase USB_SETDEBUG:\n\t\tugendebug = *(int *)addr;\n\t\tbreak;\n#endif\n\tcase USB_GET_CONFIG:\n\t\terr = usbd_get_config(sc->sc_udev, &conf);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\t*(int *)addr = conf;\n\t\tbreak;\n\tcase USB_SET_CONFIG:\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\terr = ugen_set_config(sc, *(int *)addr);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\tcase USB_GET_ALTINTERFACE:\n\t\tai = (struct usb_alt_interface *)addr;\n\t\terr = usbd_device2interface_handle(sc->sc_udev, \n\t\t\t  ai->interface_index, &iface);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tidesc = usbd_get_interface_descriptor(iface);\n\t\tif (idesc == NULL)\n\t\t\treturn (EIO);\n\t\tai->alt_no = idesc->bAlternateSetting;\n\t\tbreak;\n\tcase USB_SET_ALTINTERFACE:\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\tai = (struct usb_alt_interface *)addr;\n\t\terr = usbd_device2interface_handle(sc->sc_udev, \n\t\t\t  ai->interface_index, &iface);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\terr = ugen_set_interface(sc, ai->interface_index, ai->alt_no);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase USB_GET_NO_ALT:\n\t\tai = (struct usb_alt_interface *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, ai->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tidesc = usbd_find_idesc(cdesc, ai->interface_index, 0);\n\t\tif (idesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tai->alt_no = usbd_get_no_alts(cdesc, idesc->bInterfaceNumber);\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_DEVICE_DESC:\n\t\t*(usb_device_descriptor_t *)addr =\n\t\t\t*usbd_get_device_descriptor(sc->sc_udev);\n\t\tbreak;\n\tcase USB_GET_CONFIG_DESC:\n\t\tcd = (struct usb_config_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, cd->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tcd->desc = *cdesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_INTERFACE_DESC:\n\t\tid = (struct usb_interface_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, id->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (id->config_index == USB_CURRENT_CONFIG_INDEX &&\n\t\t    id->alt_index == USB_CURRENT_ALT_INDEX)\n\t\t\talt = ugen_get_alt_index(sc, id->interface_index);\n\t\telse\n\t\t\talt = id->alt_index;\n\t\tidesc = usbd_find_idesc(cdesc, id->interface_index, alt);\n\t\tif (idesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tid->desc = *idesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_ENDPOINT_DESC:\n\t\ted = (struct usb_endpoint_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, ed->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (ed->config_index == USB_CURRENT_CONFIG_INDEX &&\n\t\t    ed->alt_index == USB_CURRENT_ALT_INDEX)\n\t\t\talt = ugen_get_alt_index(sc, ed->interface_index);\n\t\telse\n\t\t\talt = ed->alt_index;\n\t\tedesc = usbd_find_edesc(cdesc, ed->interface_index, \n\t\t\t\t\talt, ed->endpoint_index);\n\t\tif (edesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\ted->desc = *edesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_FULL_DESC:\n\t{\n\t\tint len;\n\t\tstruct iovec iov;\n\t\tstruct uio uio;\n\t\tstruct usb_full_desc *fd = (struct usb_full_desc *)addr;\n\t\tint error;\n\n\t\tcdesc = ugen_get_cdesc(sc, fd->config_index, &len);\n\t\tif (len > fd->size)\n\t\t\tlen = fd->size;\n\t\tiov.iov_base = (caddr_t)fd->data;\n\t\tiov.iov_len = len;\n\t\tuio.uio_iov = &iov;\n\t\tuio.uio_iovcnt = 1;\n\t\tuio.uio_resid = len;\n\t\tuio.uio_offset = 0;\n\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\tuio.uio_rw = UIO_READ;\n\t\tuio.uio_procp = p;\n\t\terror = uiomove((void *)cdesc, len, &uio);\n\t\tfree(cdesc, M_TEMP);\n\t\treturn (error);\n\t}\n\tcase USB_GET_STRING_DESC:\n\t\tsi = (struct usb_string_desc *)addr;\n\t\terr = usbd_get_string_desc(sc->sc_udev, si->string_index, \n\t\t\t  si->language_id, &si->desc);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase USB_DO_REQUEST:\n\t{\n\t\tstruct usb_ctl_request *ur = (void *)addr;\n\t\tint len = UGETW(ur->request.wLength);\n\t\tstruct iovec iov;\n\t\tstruct uio uio;\n\t\tvoid *ptr = 0;\n\t\tusbd_status err;\n\t\tint error = 0;\n\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\t/* Avoid requests that would damage the bus integrity. */\n\t\tif ((ur->request.bmRequestType == UT_WRITE_DEVICE &&\n\t\t     ur->request.bRequest == UR_SET_ADDRESS) ||\n\t\t    (ur->request.bmRequestType == UT_WRITE_DEVICE &&\n\t\t     ur->request.bRequest == UR_SET_CONFIG) ||\n\t\t    (ur->request.bmRequestType == UT_WRITE_INTERFACE &&\n\t\t     ur->request.bRequest == UR_SET_INTERFACE))\n\t\t\treturn (EINVAL);\n\n\t\tif (len < 0 || len > 32767)\n\t\t\treturn (EINVAL);\n\t\tif (len != 0) {\n\t\t\tiov.iov_base = (caddr_t)ur->data;\n\t\t\tiov.iov_len = len;\n\t\t\tuio.uio_iov = &iov;\n\t\t\tuio.uio_iovcnt = 1;\n\t\t\tuio.uio_resid = len;\n\t\t\tuio.uio_offset = 0;\n\t\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\t\tuio.uio_rw =\n\t\t\t\tur->request.bmRequestType & UT_READ ? \n\t\t\t\tUIO_READ : UIO_WRITE;\n\t\t\tuio.uio_procp = p;\n\t\t\tptr = malloc(len, M_TEMP, M_WAITOK);\n\t\t\tif (uio.uio_rw == UIO_WRITE) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\terr = usbd_do_request_flags(sc->sc_udev, &ur->request, \n\t\t\t  ptr, ur->flags, &ur->actlen);\n\t\tif (err) {\n\t\t\terror = EIO;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 0) {\n\t\t\tif (uio.uio_rw == UIO_READ) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\tret:\n\t\tif (ptr)\n\t\t\tfree(ptr, M_TEMP);\n\t\treturn (error);\n\t}\n\tcase USB_GET_DEVICEINFO:\n\t\tusbd_fill_deviceinfo(sc->sc_udev,\n\t\t\t\t     (struct usb_device_info *)addr);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "ugen",
            "UGENUNIT(dev)",
            "sc"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENUNIT",
          "args": [
            "dev"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENENDPOINT",
          "args": [
            "dev"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));\nugen_set_interface __P((struct ugen_softc *, int, int));\n\nint\nugenioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr; \n\tint flag;\n\tstruct proc *p;\n{\n\tint endpt = UGENENDPOINT(dev);\n\tstruct ugen_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(ugen, UGENUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = ugen_do_ioctl(sc, endpt, cmd, addr, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}"
  },
  {
    "function_name": "ugen_do_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "842-1112",
    "snippet": "Static int\nugen_do_ioctl(sc, endpt, cmd, addr, flag, p)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tu_long cmd;\n\tcaddr_t addr; \n\tint flag;\n\tstruct proc *p;\n{\n\tstruct ugen_endpoint *sce;\n\tusbd_status err;\n\tusbd_interface_handle iface;\n\tstruct usb_config_desc *cd;\n\tusb_config_descriptor_t *cdesc;\n\tstruct usb_interface_desc *id;\n\tusb_interface_descriptor_t *idesc;\n\tstruct usb_endpoint_desc *ed;\n\tusb_endpoint_descriptor_t *edesc;\n\tstruct usb_alt_interface *ai;\n\tstruct usb_string_desc *si;\n\tu_int8_t conf, alt;\n\n\tDPRINTFN(5, (\"ugenioctl: cmd=%08lx\\n\", cmd));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\treturn (0);\n\tcase USB_SET_SHORT_XFER:\n\t\t/* This flag only affects read */\n\t\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\t\treturn (EINVAL);\n\t\tsce = &sc->sc_endpoints[endpt][IN];\n\t\tif (sce == NULL)\n\t\t\treturn (EINVAL);\n#ifdef DIAGNOSTIC\n\t\tif (sce->pipeh == NULL) {\n\t\t\tprintf(\"ugenioctl: USB_SET_SHORT_XFER, no pipe\\n\");\n\t\t\treturn (EIO);\n\t\t}\n#endif\n\t\tif (*(int *)addr)\n\t\t\tsce->state |= UGEN_SHORT_OK;\n\t\telse\n\t\t\tsce->state &= ~UGEN_SHORT_OK;\n\t\treturn (0);\n\tcase USB_SET_TIMEOUT:\n\t\tsce = &sc->sc_endpoints[endpt][IN];\n\t\tif (sce == NULL)\n\t\t\treturn (EINVAL);\n#ifdef DIAGNOSTIC\n\t\tif (sce->pipeh == NULL) {\n\t\t\tprintf(\"ugenioctl: USB_SET_TIMEOUT, no pipe\\n\");\n\t\t\treturn (EIO);\n\t\t}\n#endif\n\t\tsce->timeout = *(int *)addr;\n\t\treturn (0);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (endpt != USB_CONTROL_ENDPOINT)\n\t\treturn (EINVAL);\n\n\tswitch (cmd) {\n#ifdef UGEN_DEBUG\n\tcase USB_SETDEBUG:\n\t\tugendebug = *(int *)addr;\n\t\tbreak;\n#endif\n\tcase USB_GET_CONFIG:\n\t\terr = usbd_get_config(sc->sc_udev, &conf);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\t*(int *)addr = conf;\n\t\tbreak;\n\tcase USB_SET_CONFIG:\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\terr = ugen_set_config(sc, *(int *)addr);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\tcase USB_GET_ALTINTERFACE:\n\t\tai = (struct usb_alt_interface *)addr;\n\t\terr = usbd_device2interface_handle(sc->sc_udev, \n\t\t\t  ai->interface_index, &iface);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tidesc = usbd_get_interface_descriptor(iface);\n\t\tif (idesc == NULL)\n\t\t\treturn (EIO);\n\t\tai->alt_no = idesc->bAlternateSetting;\n\t\tbreak;\n\tcase USB_SET_ALTINTERFACE:\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\tai = (struct usb_alt_interface *)addr;\n\t\terr = usbd_device2interface_handle(sc->sc_udev, \n\t\t\t  ai->interface_index, &iface);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\terr = ugen_set_interface(sc, ai->interface_index, ai->alt_no);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase USB_GET_NO_ALT:\n\t\tai = (struct usb_alt_interface *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, ai->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tidesc = usbd_find_idesc(cdesc, ai->interface_index, 0);\n\t\tif (idesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tai->alt_no = usbd_get_no_alts(cdesc, idesc->bInterfaceNumber);\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_DEVICE_DESC:\n\t\t*(usb_device_descriptor_t *)addr =\n\t\t\t*usbd_get_device_descriptor(sc->sc_udev);\n\t\tbreak;\n\tcase USB_GET_CONFIG_DESC:\n\t\tcd = (struct usb_config_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, cd->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tcd->desc = *cdesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_INTERFACE_DESC:\n\t\tid = (struct usb_interface_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, id->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (id->config_index == USB_CURRENT_CONFIG_INDEX &&\n\t\t    id->alt_index == USB_CURRENT_ALT_INDEX)\n\t\t\talt = ugen_get_alt_index(sc, id->interface_index);\n\t\telse\n\t\t\talt = id->alt_index;\n\t\tidesc = usbd_find_idesc(cdesc, id->interface_index, alt);\n\t\tif (idesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tid->desc = *idesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_ENDPOINT_DESC:\n\t\ted = (struct usb_endpoint_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, ed->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (ed->config_index == USB_CURRENT_CONFIG_INDEX &&\n\t\t    ed->alt_index == USB_CURRENT_ALT_INDEX)\n\t\t\talt = ugen_get_alt_index(sc, ed->interface_index);\n\t\telse\n\t\t\talt = ed->alt_index;\n\t\tedesc = usbd_find_edesc(cdesc, ed->interface_index, \n\t\t\t\t\talt, ed->endpoint_index);\n\t\tif (edesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\ted->desc = *edesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_FULL_DESC:\n\t{\n\t\tint len;\n\t\tstruct iovec iov;\n\t\tstruct uio uio;\n\t\tstruct usb_full_desc *fd = (struct usb_full_desc *)addr;\n\t\tint error;\n\n\t\tcdesc = ugen_get_cdesc(sc, fd->config_index, &len);\n\t\tif (len > fd->size)\n\t\t\tlen = fd->size;\n\t\tiov.iov_base = (caddr_t)fd->data;\n\t\tiov.iov_len = len;\n\t\tuio.uio_iov = &iov;\n\t\tuio.uio_iovcnt = 1;\n\t\tuio.uio_resid = len;\n\t\tuio.uio_offset = 0;\n\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\tuio.uio_rw = UIO_READ;\n\t\tuio.uio_procp = p;\n\t\terror = uiomove((void *)cdesc, len, &uio);\n\t\tfree(cdesc, M_TEMP);\n\t\treturn (error);\n\t}\n\tcase USB_GET_STRING_DESC:\n\t\tsi = (struct usb_string_desc *)addr;\n\t\terr = usbd_get_string_desc(sc->sc_udev, si->string_index, \n\t\t\t  si->language_id, &si->desc);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase USB_DO_REQUEST:\n\t{\n\t\tstruct usb_ctl_request *ur = (void *)addr;\n\t\tint len = UGETW(ur->request.wLength);\n\t\tstruct iovec iov;\n\t\tstruct uio uio;\n\t\tvoid *ptr = 0;\n\t\tusbd_status err;\n\t\tint error = 0;\n\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\t/* Avoid requests that would damage the bus integrity. */\n\t\tif ((ur->request.bmRequestType == UT_WRITE_DEVICE &&\n\t\t     ur->request.bRequest == UR_SET_ADDRESS) ||\n\t\t    (ur->request.bmRequestType == UT_WRITE_DEVICE &&\n\t\t     ur->request.bRequest == UR_SET_CONFIG) ||\n\t\t    (ur->request.bmRequestType == UT_WRITE_INTERFACE &&\n\t\t     ur->request.bRequest == UR_SET_INTERFACE))\n\t\t\treturn (EINVAL);\n\n\t\tif (len < 0 || len > 32767)\n\t\t\treturn (EINVAL);\n\t\tif (len != 0) {\n\t\t\tiov.iov_base = (caddr_t)ur->data;\n\t\t\tiov.iov_len = len;\n\t\t\tuio.uio_iov = &iov;\n\t\t\tuio.uio_iovcnt = 1;\n\t\t\tuio.uio_resid = len;\n\t\t\tuio.uio_offset = 0;\n\t\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\t\tuio.uio_rw =\n\t\t\t\tur->request.bmRequestType & UT_READ ? \n\t\t\t\tUIO_READ : UIO_WRITE;\n\t\t\tuio.uio_procp = p;\n\t\t\tptr = malloc(len, M_TEMP, M_WAITOK);\n\t\t\tif (uio.uio_rw == UIO_WRITE) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\terr = usbd_do_request_flags(sc->sc_udev, &ur->request, \n\t\t\t  ptr, ur->flags, &ur->actlen);\n\t\tif (err) {\n\t\t\terror = EIO;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 0) {\n\t\t\tif (uio.uio_rw == UIO_READ) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\tret:\n\t\tif (ptr)\n\t\t\tfree(ptr, M_TEMP);\n\t\treturn (error);\n\t}\n\tcase USB_GET_DEVICEINFO:\n\t\tusbd_fill_deviceinfo(sc->sc_udev,\n\t\t\t\t     (struct usb_device_info *)addr);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define IN  1",
      "#define UGEN_SHORT_OK\t0x04\t/* short xfers are OK */"
    ],
    "globals_used": [
      "Static void",
      "Static int",
      "ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));",
      "Static int",
      "ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));",
      "Static int",
      "ugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));",
      "Static int",
      "Static usb_config_descriptor_t",
      "Static usbd_status",
      "ugen_set_interface __P((struct ugen_softc *, int, int));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_fill_deviceinfo",
          "args": [
            "sc->sc_udev",
            "(struct usb_device_info *)addr"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_fill_deviceinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1171-1231",
          "snippet": "void\nusbd_fill_deviceinfo(dev, di)\n\tusbd_device_handle dev;\n\tstruct usb_device_info *di;\n{\n\tstruct usbd_port *p;\n\tint i, err, s;\n\n\tdi->bus = USBDEVUNIT(dev->bus->bdev);\n\tdi->addr = dev->address;\n\tdi->cookie = dev->cookie;\n\tusbd_devinfo_vp(dev, di->vendor, di->product);\n\tusbd_printBCD(di->release, UGETW(dev->ddesc.bcdDevice));\n\tdi->vendorNo = UGETW(dev->ddesc.idVendor);\n\tdi->productNo = UGETW(dev->ddesc.idProduct);\n\tdi->releaseNo = UGETW(dev->ddesc.bcdDevice);\n\tdi->class = dev->ddesc.bDeviceClass;\n\tdi->subclass = dev->ddesc.bDeviceSubClass;\n\tdi->protocol = dev->ddesc.bDeviceProtocol;\n\tdi->config = dev->config;\n\tdi->power = dev->self_powered ? 0 : dev->power;\n\tdi->lowspeed = dev->lowspeed;\n\n\tif (dev->subdevs != NULL) {\n\t\tfor (i = 0; dev->subdevs[i] &&\n\t\t\t     i < USB_MAX_DEVNAMES; i++) {\n\t\t\tstrncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),\n\t\t\t\tUSB_MAX_DEVNAMELEN);\n\t\t\tdi->devnames[i][USB_MAX_DEVNAMELEN-1] = '\\0';\n                }\n        } else {\n                i = 0;\n        }\n        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)\n                di->devnames[i][0] = 0;                 /* empty */\n\n\tif (dev->hub) {\n\t\tfor (i = 0; \n\t\t     i < sizeof(di->ports) / sizeof(di->ports[0]) &&\n\t\t\t     i < dev->hub->hubdesc.bNbrPorts;\n\t\t     i++) {\n\t\t\tp = &dev->hub->ports[i];\n\t\t\tif (p->device)\n\t\t\t\terr = p->device->address;\n\t\t\telse {\n\t\t\t\ts = UGETW(p->status.wPortStatus);\n\t\t\t\tif (s & UPS_PORT_ENABLED)\n\t\t\t\t\terr = USB_PORT_ENABLED;\n\t\t\t\telse if (s & UPS_SUSPEND)\n\t\t\t\t\terr = USB_PORT_SUSPENDED;\n\t\t\t\telse if (s & UPS_PORT_POWER)\n\t\t\t\t\terr = USB_PORT_POWERED;\n\t\t\t\telse\n\t\t\t\t\terr = USB_PORT_DISABLED;\n\t\t\t}\n\t\t\tdi->ports[i] = err;\n\t\t}\n\t\tdi->nports = dev->hub->hubdesc.bNbrPorts;\n\t} else\n\t\tdi->nports = 0;\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "usbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nusbd_probe_and_attach \n\t__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_fill_deviceinfo(dev, di)\n\tusbd_device_handle dev;\n\tstruct usb_device_info *di;\n{\n\tstruct usbd_port *p;\n\tint i, err, s;\n\n\tdi->bus = USBDEVUNIT(dev->bus->bdev);\n\tdi->addr = dev->address;\n\tdi->cookie = dev->cookie;\n\tusbd_devinfo_vp(dev, di->vendor, di->product);\n\tusbd_printBCD(di->release, UGETW(dev->ddesc.bcdDevice));\n\tdi->vendorNo = UGETW(dev->ddesc.idVendor);\n\tdi->productNo = UGETW(dev->ddesc.idProduct);\n\tdi->releaseNo = UGETW(dev->ddesc.bcdDevice);\n\tdi->class = dev->ddesc.bDeviceClass;\n\tdi->subclass = dev->ddesc.bDeviceSubClass;\n\tdi->protocol = dev->ddesc.bDeviceProtocol;\n\tdi->config = dev->config;\n\tdi->power = dev->self_powered ? 0 : dev->power;\n\tdi->lowspeed = dev->lowspeed;\n\n\tif (dev->subdevs != NULL) {\n\t\tfor (i = 0; dev->subdevs[i] &&\n\t\t\t     i < USB_MAX_DEVNAMES; i++) {\n\t\t\tstrncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),\n\t\t\t\tUSB_MAX_DEVNAMELEN);\n\t\t\tdi->devnames[i][USB_MAX_DEVNAMELEN-1] = '\\0';\n                }\n        } else {\n                i = 0;\n        }\n        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)\n                di->devnames[i][0] = 0;                 /* empty */\n\n\tif (dev->hub) {\n\t\tfor (i = 0; \n\t\t     i < sizeof(di->ports) / sizeof(di->ports[0]) &&\n\t\t\t     i < dev->hub->hubdesc.bNbrPorts;\n\t\t     i++) {\n\t\t\tp = &dev->hub->ports[i];\n\t\t\tif (p->device)\n\t\t\t\terr = p->device->address;\n\t\t\telse {\n\t\t\t\ts = UGETW(p->status.wPortStatus);\n\t\t\t\tif (s & UPS_PORT_ENABLED)\n\t\t\t\t\terr = USB_PORT_ENABLED;\n\t\t\t\telse if (s & UPS_SUSPEND)\n\t\t\t\t\terr = USB_PORT_SUSPENDED;\n\t\t\t\telse if (s & UPS_PORT_POWER)\n\t\t\t\t\terr = USB_PORT_POWERED;\n\t\t\t\telse\n\t\t\t\t\terr = USB_PORT_DISABLED;\n\t\t\t}\n\t\t\tdi->ports[i] = err;\n\t\t}\n\t\tdi->nports = dev->hub->hubdesc.bNbrPorts;\n\t} else\n\t\tdi->nports = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr",
            "M_TEMP"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "ptr",
            "len",
            "&uio"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_do_request_flags",
          "args": [
            "sc->sc_udev",
            "&ur->request",
            "ptr",
            "ur->flags",
            "&ur->actlen"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "952-1033",
          "snippet": "usbd_status\nusbd_do_request_flags(dev, req, data, flags, actlen)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n\tu_int16_t flags;\n\tint *actlen;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n#ifdef DIAGNOSTIC\n#if defined(__i386__) && defined(__FreeBSD__)\n\tKASSERT(intr_nesting_level == 0,\n\t       \t(\"usbd_do_request: in interrupt context\"));\n#endif\n\tif (dev->bus->intr_context) {\n\t\tprintf(\"usbd_do_request: not in process context\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t\t\t\t   data, UGETW(req->wLength), flags, 0);\n\terr = usbd_sync_transfer(xfer);\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tif (actlen != NULL)\n\t\t*actlen = xfer->actlen;\n\tif (err == USBD_STALLED) {\n\t\t/* \n\t\t * The control endpoint has stalled.  Control endpoints\n\t\t * should not halt, but some may do so anyway so clear\n\t\t * any halt condition.\n\t\t */\n\t\tusb_device_request_t treq;\n\t\tusb_status_t status;\n\t\tu_int16_t s;\n\t\tusbd_status nerr;\n\n\t\ttreq.bmRequestType = UT_READ_ENDPOINT;\n\t\ttreq.bRequest = UR_GET_STATUS;\n\t\tUSETW(treq.wValue, 0);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, sizeof(usb_status_t));\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status,sizeof(usb_status_t),\n\t\t\t\t\t   0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t\ts = UGETW(status.wStatus);\n\t\tDPRINTF((\"usbd_do_request: status = 0x%04x\\n\", s));\n\t\tif (!(s & UES_HALT))\n\t\t\tgoto bad;\n\t\ttreq.bmRequestType = UT_WRITE_ENDPOINT;\n\t\ttreq.bRequest = UR_CLEAR_FEATURE;\n\t\tUSETW(treq.wValue, UF_ENDPOINT_HALT);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, 0);\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status, 0, 0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t}\n\n bad:\n\tusbd_free_xfer(xfer);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "u_int8_t index;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nu_int8_t index;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nu_int8_t address;\n\nusbd_status\nusbd_do_request_flags(dev, req, data, flags, actlen)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n\tu_int16_t flags;\n\tint *actlen;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n#ifdef DIAGNOSTIC\n#if defined(__i386__) && defined(__FreeBSD__)\n\tKASSERT(intr_nesting_level == 0,\n\t       \t(\"usbd_do_request: in interrupt context\"));\n#endif\n\tif (dev->bus->intr_context) {\n\t\tprintf(\"usbd_do_request: not in process context\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t\t\t\t   data, UGETW(req->wLength), flags, 0);\n\terr = usbd_sync_transfer(xfer);\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tif (actlen != NULL)\n\t\t*actlen = xfer->actlen;\n\tif (err == USBD_STALLED) {\n\t\t/* \n\t\t * The control endpoint has stalled.  Control endpoints\n\t\t * should not halt, but some may do so anyway so clear\n\t\t * any halt condition.\n\t\t */\n\t\tusb_device_request_t treq;\n\t\tusb_status_t status;\n\t\tu_int16_t s;\n\t\tusbd_status nerr;\n\n\t\ttreq.bmRequestType = UT_READ_ENDPOINT;\n\t\ttreq.bRequest = UR_GET_STATUS;\n\t\tUSETW(treq.wValue, 0);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, sizeof(usb_status_t));\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status,sizeof(usb_status_t),\n\t\t\t\t\t   0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t\ts = UGETW(status.wStatus);\n\t\tDPRINTF((\"usbd_do_request: status = 0x%04x\\n\", s));\n\t\tif (!(s & UES_HALT))\n\t\t\tgoto bad;\n\t\ttreq.bmRequestType = UT_WRITE_ENDPOINT;\n\t\ttreq.bRequest = UR_CLEAR_FEATURE;\n\t\tUSETW(treq.wValue, UF_ENDPOINT_HALT);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, 0);\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status, 0, 0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t}\n\n bad:\n\tusbd_free_xfer(xfer);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "ptr",
            "len",
            "&uio"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len",
            "M_TEMP",
            "M_WAITOK"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "ur->request.wLength"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_string_desc",
          "args": [
            "sc->sc_udev",
            "si->string_index",
            "si->language_id",
            "&si->desc"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_string_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "151-171",
          "snippet": "usbd_status\nusbd_get_string_desc(dev, sindex, langid, sdesc)\n\tusbd_device_handle dev;\n\tint sindex;\n\tint langid;\n\tusb_string_descriptor_t *sdesc;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, UDESC_STRING, sindex);\n\tUSETW(req.wIndex, langid);\n\tUSETW(req.wLength, 1);\t/* only size byte first */\n\terr = usbd_do_request(dev, &req, sdesc);\n\tif (err)\n\t\treturn (err);\n\tUSETW(req.wLength, sdesc->bLength);\t/* the whole string */\n\treturn (usbd_do_request(dev, &req, sdesc));\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static usbd_status",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_get_string_desc(dev, sindex, langid, sdesc)\n\tusbd_device_handle dev;\n\tint sindex;\n\tint langid;\n\tusb_string_descriptor_t *sdesc;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_DESCRIPTOR;\n\tUSETW2(req.wValue, UDESC_STRING, sindex);\n\tUSETW(req.wIndex, langid);\n\tUSETW(req.wLength, 1);\t/* only size byte first */\n\terr = usbd_do_request(dev, &req, sdesc);\n\tif (err)\n\t\treturn (err);\n\tUSETW(req.wLength, sdesc->bLength);\t/* the whole string */\n\treturn (usbd_do_request(dev, &req, sdesc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(void *)cdesc",
            "len",
            "&uio"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugen_get_cdesc",
          "args": [
            "sc",
            "fd->config_index",
            "&len"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "ugen_get_cdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
          "lines": "792-826",
          "snippet": "Static usb_config_descriptor_t *\nugen_get_cdesc(sc, index, lenp)\n\tstruct ugen_softc *sc;\n\tint index;\n\tint *lenp;\n{\n\tusb_config_descriptor_t *cdesc, *tdesc, cdescr;\n\tint len;\n\tusbd_status err;\n\n\tif (index == USB_CURRENT_CONFIG_INDEX) {\n\t\ttdesc = usbd_get_config_descriptor(sc->sc_udev);\n\t\tlen = UGETW(tdesc->wTotalLength);\n\t\tif (lenp)\n\t\t\t*lenp = len;\n\t\tcdesc = malloc(len, M_TEMP, M_WAITOK);\n\t\tmemcpy(cdesc, tdesc, len);\n\t\tDPRINTFN(5,(\"ugen_get_cdesc: current, len=%d\\n\", len));\n\t} else {\n\t\terr = usbd_get_config_desc(sc->sc_udev, index, &cdescr);\n\t\tif (err)\n\t\t\treturn (0);\n\t\tlen = UGETW(cdescr.wTotalLength);\n\t\tDPRINTFN(5,(\"ugen_get_cdesc: index=%d, len=%d\\n\", index, len));\n\t\tif (lenp)\n\t\t\t*lenp = len;\n\t\tcdesc = malloc(len, M_TEMP, M_WAITOK);\n\t\terr = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,len);\n\t\tif (err) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (cdesc);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/filio.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static int",
            "Static int",
            "Static int",
            "Static int",
            "Static usb_config_descriptor_t",
            "Static usbd_status",
            "ugen_set_interface __P((struct ugen_softc *, int, int));",
            "Static int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic usb_config_descriptor_t;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic usb_config_descriptor_t *\nugen_get_cdesc(sc, index, lenp)\n\tstruct ugen_softc *sc;\n\tint index;\n\tint *lenp;\n{\n\tusb_config_descriptor_t *cdesc, *tdesc, cdescr;\n\tint len;\n\tusbd_status err;\n\n\tif (index == USB_CURRENT_CONFIG_INDEX) {\n\t\ttdesc = usbd_get_config_descriptor(sc->sc_udev);\n\t\tlen = UGETW(tdesc->wTotalLength);\n\t\tif (lenp)\n\t\t\t*lenp = len;\n\t\tcdesc = malloc(len, M_TEMP, M_WAITOK);\n\t\tmemcpy(cdesc, tdesc, len);\n\t\tDPRINTFN(5,(\"ugen_get_cdesc: current, len=%d\\n\", len));\n\t} else {\n\t\terr = usbd_get_config_desc(sc->sc_udev, index, &cdescr);\n\t\tif (err)\n\t\t\treturn (0);\n\t\tlen = UGETW(cdescr.wTotalLength);\n\t\tDPRINTFN(5,(\"ugen_get_cdesc: index=%d, len=%d\\n\", index, len));\n\t\tif (lenp)\n\t\t\t*lenp = len;\n\t\tcdesc = malloc(len, M_TEMP, M_WAITOK);\n\t\terr = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,len);\n\t\tif (err) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (cdesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_find_edesc",
          "args": [
            "cdesc",
            "ed->interface_index",
            "alt",
            "ed->endpoint_index"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugen_get_alt_index",
          "args": [
            "sc",
            "ed->interface_index"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "ugen_get_alt_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
          "lines": "828-840",
          "snippet": "Static int\nugen_get_alt_index(sc, ifaceidx)\n\tstruct ugen_softc *sc;\n\tint ifaceidx;\n{\n\tusbd_interface_handle iface;\n\tusbd_status err;\n\n\terr = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);\n\tif (err)\n\t\t\treturn (-1);\n\treturn (usbd_get_interface_altindex(iface));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/filio.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "Static int",
            "Static int",
            "Static int",
            "Static int",
            "Static usbd_status",
            "ugen_set_interface __P((struct ugen_softc *, int, int));",
            "Static int",
            "ugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\nugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));\n\nStatic int\nugen_get_alt_index(sc, ifaceidx)\n\tstruct ugen_softc *sc;\n\tint ifaceidx;\n{\n\tusbd_interface_handle iface;\n\tusbd_status err;\n\n\terr = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);\n\tif (err)\n\t\t\treturn (-1);\n\treturn (usbd_get_interface_altindex(iface));\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_find_idesc",
          "args": [
            "cdesc",
            "id->interface_index",
            "alt"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_device_descriptor",
          "args": [
            "sc->sc_udev"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_no_alts",
          "args": [
            "cdesc",
            "idesc->bInterfaceNumber"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_no_alts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "717-735",
          "snippet": "int\nusbd_get_no_alts(cdesc, ifaceno)\n\tusb_config_descriptor_t *cdesc;\n\tint ifaceno;\n{\n\tchar *p = (char *)cdesc;\n\tchar *end = p + UGETW(cdesc->wTotalLength);\n\tusb_interface_descriptor_t *d;\n\tint n;\n\n\tfor (n = 0; p < end; p += d->bLength) {\n\t\td = (usb_interface_descriptor_t *)p;\n\t\tif (p + d->bLength <= end && \n\t\t    d->bDescriptorType == UDESC_INTERFACE &&\n\t\t    d->bInterfaceNumber == ifaceno)\n\t\t\tn++;\n\t}\n\treturn (n);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_get_no_alts(cdesc, ifaceno)\n\tusb_config_descriptor_t *cdesc;\n\tint ifaceno;\n{\n\tchar *p = (char *)cdesc;\n\tchar *end = p + UGETW(cdesc->wTotalLength);\n\tusb_interface_descriptor_t *d;\n\tint n;\n\n\tfor (n = 0; p < end; p += d->bLength) {\n\t\td = (usb_interface_descriptor_t *)p;\n\t\tif (p + d->bLength <= end && \n\t\t    d->bDescriptorType == UDESC_INTERFACE &&\n\t\t    d->bInterfaceNumber == ifaceno)\n\t\t\tn++;\n\t}\n\treturn (n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_find_idesc",
          "args": [
            "cdesc",
            "ai->interface_index",
            "0"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugen_set_interface",
          "args": [
            "sc",
            "ai->interface_index",
            "ai->alt_no"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ugen_set_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
          "lines": "735-789",
          "snippet": "Static usbd_status\nugen_set_interface(sc, ifaceidx, altno)\n\tstruct ugen_softc *sc;\n\tint ifaceidx, altno;\n{\n\tusbd_interface_handle iface;\n\tusb_endpoint_descriptor_t *ed;\n\tusbd_status err;\n\tstruct ugen_endpoint *sce;\n\tu_int8_t niface, nendpt, endptno, endpt;\n\tint dir;\n\n\tDPRINTFN(15, (\"ugen_set_interface %d %d\\n\", ifaceidx, altno));\n\n\terr = usbd_interface_count(sc->sc_udev, &niface);\n\tif (err)\n\t\treturn (err);\n\tif (ifaceidx < 0 || ifaceidx >= niface)\n\t\treturn (USBD_INVAL);\n\t\n\terr = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);\n\tif (err)\n\t\treturn (err);\n\terr = usbd_endpoint_count(iface, &nendpt);\n\tif (err)\n\t\treturn (err);\n\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\tendpt = ed->bEndpointAddress;\n\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\tsce->sc = 0;\n\t\tsce->edesc = 0;\n\t\tsce->iface = 0;\n\t}\n\n\t/* change setting */\n\terr = usbd_set_interface(iface, altno);\n\tif (err)\n\t\treturn (err);\n\n\terr = usbd_endpoint_count(iface, &nendpt);\n\tif (err)\n\t\treturn (err);\n\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\tendpt = ed->bEndpointAddress;\n\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\tsce->sc = sc;\n\t\tsce->edesc = ed;\n\t\tsce->iface = iface;\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/filio.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define IN  1",
            "#define OUT 0"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static int",
            "Static int",
            "Static int",
            "Static usbd_status",
            "ugen_set_interface __P((struct ugen_softc *, int, int));",
            "Static int",
            "ugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n#define OUT 0\n\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\nugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));\n\nStatic usbd_status\nugen_set_interface(sc, ifaceidx, altno)\n\tstruct ugen_softc *sc;\n\tint ifaceidx, altno;\n{\n\tusbd_interface_handle iface;\n\tusb_endpoint_descriptor_t *ed;\n\tusbd_status err;\n\tstruct ugen_endpoint *sce;\n\tu_int8_t niface, nendpt, endptno, endpt;\n\tint dir;\n\n\tDPRINTFN(15, (\"ugen_set_interface %d %d\\n\", ifaceidx, altno));\n\n\terr = usbd_interface_count(sc->sc_udev, &niface);\n\tif (err)\n\t\treturn (err);\n\tif (ifaceidx < 0 || ifaceidx >= niface)\n\t\treturn (USBD_INVAL);\n\t\n\terr = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);\n\tif (err)\n\t\treturn (err);\n\terr = usbd_endpoint_count(iface, &nendpt);\n\tif (err)\n\t\treturn (err);\n\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\tendpt = ed->bEndpointAddress;\n\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\tsce->sc = 0;\n\t\tsce->edesc = 0;\n\t\tsce->iface = 0;\n\t}\n\n\t/* change setting */\n\terr = usbd_set_interface(iface, altno);\n\tif (err)\n\t\treturn (err);\n\n\terr = usbd_endpoint_count(iface, &nendpt);\n\tif (err)\n\t\treturn (err);\n\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\tendpt = ed->bEndpointAddress;\n\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\tsce->sc = sc;\n\t\tsce->edesc = ed;\n\t\tsce->iface = iface;\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_device2interface_handle",
          "args": [
            "sc->sc_udev",
            "ai->interface_index",
            "&iface"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_device2interface_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "667-679",
          "snippet": "usbd_status \nusbd_device2interface_handle(dev, ifaceno, iface)\n\tusbd_device_handle dev;\n\tu_int8_t ifaceno;\n\tusbd_interface_handle *iface;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\tif (ifaceno >= dev->cdesc->bNumInterface)\n\t\treturn (USBD_INVAL);\n\t*iface = &dev->ifaces[ifaceno];\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_device2interface_handle(dev, ifaceno, iface)\n\tusbd_device_handle dev;\n\tu_int8_t ifaceno;\n\tusbd_interface_handle *iface;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\tif (ifaceno >= dev->cdesc->bNumInterface)\n\t\treturn (USBD_INVAL);\n\t*iface = &dev->ifaces[ifaceno];\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_get_interface_descriptor",
          "args": [
            "iface"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugen_set_config",
          "args": [
            "sc",
            "*(int *)addr"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "ugen_set_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
          "lines": "218-268",
          "snippet": "Static int\nugen_set_config(sc, configno)\n\tstruct ugen_softc *sc;\n\tint configno;\n{\n\tusbd_device_handle dev = sc->sc_udev;\n\tusbd_interface_handle iface;\n\tusb_endpoint_descriptor_t *ed;\n\tstruct ugen_endpoint *sce;\n\tu_int8_t niface, nendpt;\n\tint ifaceno, endptno, endpt;\n\tusbd_status err;\n\tint dir;\n\n\tDPRINTFN(1,(\"ugen_set_config: %s to configno %d, sc=%p\\n\",\n\t\t    USBDEVNAME(sc->sc_dev), configno, sc));\n\t/* Avoid setting the current value. */\n\tif (usbd_get_config_descriptor(dev)->bConfigurationValue != configno) {\n\t\terr = usbd_set_config_no(dev, configno, 0);\n\t\tif (err)\n\t\t\treturn (err);\n\t}\n\n\terr = usbd_interface_count(dev, &niface);\n\tif (err)\n\t\treturn (err);\n\tmemset(sc->sc_endpoints, 0, sizeof sc->sc_endpoints);\n\tfor (ifaceno = 0; ifaceno < niface; ifaceno++) {\n\t\tDPRINTFN(1,(\"ugen_set_config: ifaceno %d\\n\", ifaceno));\n\t\terr = usbd_device2interface_handle(dev, ifaceno, &iface);\n\t\tif (err)\n\t\t\treturn (err);\n\t\terr = usbd_endpoint_count(iface, &nendpt);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\t\tendpt = ed->bEndpointAddress;\n\t\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\t\tDPRINTFN(1,(\"ugen_set_config: endptno %d, endpt=0x%02x\"\n\t\t\t\t    \"(%d,%d), sce=%p\\n\", \n\t\t\t\t    endptno, endpt, UE_GET_ADDR(endpt),\n\t\t\t\t    UE_GET_DIR(endpt), sce));\n\t\t\tsce->sc = sc;\n\t\t\tsce->edesc = ed;\n\t\t\tsce->iface = iface;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/filio.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define IN  1",
            "#define OUT 0"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static int",
            "Static int",
            "Static int",
            "ugen_set_config __P((struct ugen_softc *sc, int configno));",
            "Static usbd_status",
            "ugen_set_interface __P((struct ugen_softc *, int, int));",
            "Static int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n#define OUT 0\n\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nugen_set_config __P((struct ugen_softc *sc, int configno));\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic int\nugen_set_config(sc, configno)\n\tstruct ugen_softc *sc;\n\tint configno;\n{\n\tusbd_device_handle dev = sc->sc_udev;\n\tusbd_interface_handle iface;\n\tusb_endpoint_descriptor_t *ed;\n\tstruct ugen_endpoint *sce;\n\tu_int8_t niface, nendpt;\n\tint ifaceno, endptno, endpt;\n\tusbd_status err;\n\tint dir;\n\n\tDPRINTFN(1,(\"ugen_set_config: %s to configno %d, sc=%p\\n\",\n\t\t    USBDEVNAME(sc->sc_dev), configno, sc));\n\t/* Avoid setting the current value. */\n\tif (usbd_get_config_descriptor(dev)->bConfigurationValue != configno) {\n\t\terr = usbd_set_config_no(dev, configno, 0);\n\t\tif (err)\n\t\t\treturn (err);\n\t}\n\n\terr = usbd_interface_count(dev, &niface);\n\tif (err)\n\t\treturn (err);\n\tmemset(sc->sc_endpoints, 0, sizeof sc->sc_endpoints);\n\tfor (ifaceno = 0; ifaceno < niface; ifaceno++) {\n\t\tDPRINTFN(1,(\"ugen_set_config: ifaceno %d\\n\", ifaceno));\n\t\terr = usbd_device2interface_handle(dev, ifaceno, &iface);\n\t\tif (err)\n\t\t\treturn (err);\n\t\terr = usbd_endpoint_count(iface, &nendpt);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\t\tendpt = ed->bEndpointAddress;\n\t\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\t\tDPRINTFN(1,(\"ugen_set_config: endptno %d, endpt=0x%02x\"\n\t\t\t\t    \"(%d,%d), sce=%p\\n\", \n\t\t\t\t    endptno, endpt, UE_GET_ADDR(endpt),\n\t\t\t\t    UE_GET_DIR(endpt), sce));\n\t\t\tsce->sc = sc;\n\t\t\tsce->edesc = ed;\n\t\t\tsce->iface = iface;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_get_config",
          "args": [
            "sc->sc_udev",
            "&conf"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "473-486",
          "snippet": "usbd_status \nusbd_get_config(dev, conf)\n\tusbd_device_handle dev;\n\tu_int8_t *conf;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_CONFIG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 1);\n\treturn (usbd_do_request(dev, &req, conf));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status \nusbd_get_config(dev, conf)\n\tusbd_device_handle dev;\n\tu_int8_t *conf;\n{\n\tusb_device_request_t req;\n\n\treq.bmRequestType = UT_READ_DEVICE;\n\treq.bRequest = UR_GET_CONFIG;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 1);\n\treturn (usbd_do_request(dev, &req, conf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ugenioctl: USB_SET_TIMEOUT, no pipe\\n\""
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenioctl: cmd=%08lx\\n\", cmd)"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n#define UGEN_SHORT_OK\t0x04\t/* short xfers are OK */\n\nStatic void;\nStatic int;\nugen_do_read __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nugen_do_write __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));\nStatic int;\nStatic usb_config_descriptor_t;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic int\nugen_do_ioctl(sc, endpt, cmd, addr, flag, p)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tu_long cmd;\n\tcaddr_t addr; \n\tint flag;\n\tstruct proc *p;\n{\n\tstruct ugen_endpoint *sce;\n\tusbd_status err;\n\tusbd_interface_handle iface;\n\tstruct usb_config_desc *cd;\n\tusb_config_descriptor_t *cdesc;\n\tstruct usb_interface_desc *id;\n\tusb_interface_descriptor_t *idesc;\n\tstruct usb_endpoint_desc *ed;\n\tusb_endpoint_descriptor_t *edesc;\n\tstruct usb_alt_interface *ai;\n\tstruct usb_string_desc *si;\n\tu_int8_t conf, alt;\n\n\tDPRINTFN(5, (\"ugenioctl: cmd=%08lx\\n\", cmd));\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tswitch (cmd) {\n\tcase FIONBIO:\n\t\t/* All handled in the upper FS layer. */\n\t\treturn (0);\n\tcase USB_SET_SHORT_XFER:\n\t\t/* This flag only affects read */\n\t\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\t\treturn (EINVAL);\n\t\tsce = &sc->sc_endpoints[endpt][IN];\n\t\tif (sce == NULL)\n\t\t\treturn (EINVAL);\n#ifdef DIAGNOSTIC\n\t\tif (sce->pipeh == NULL) {\n\t\t\tprintf(\"ugenioctl: USB_SET_SHORT_XFER, no pipe\\n\");\n\t\t\treturn (EIO);\n\t\t}\n#endif\n\t\tif (*(int *)addr)\n\t\t\tsce->state |= UGEN_SHORT_OK;\n\t\telse\n\t\t\tsce->state &= ~UGEN_SHORT_OK;\n\t\treturn (0);\n\tcase USB_SET_TIMEOUT:\n\t\tsce = &sc->sc_endpoints[endpt][IN];\n\t\tif (sce == NULL)\n\t\t\treturn (EINVAL);\n#ifdef DIAGNOSTIC\n\t\tif (sce->pipeh == NULL) {\n\t\t\tprintf(\"ugenioctl: USB_SET_TIMEOUT, no pipe\\n\");\n\t\t\treturn (EIO);\n\t\t}\n#endif\n\t\tsce->timeout = *(int *)addr;\n\t\treturn (0);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (endpt != USB_CONTROL_ENDPOINT)\n\t\treturn (EINVAL);\n\n\tswitch (cmd) {\n#ifdef UGEN_DEBUG\n\tcase USB_SETDEBUG:\n\t\tugendebug = *(int *)addr;\n\t\tbreak;\n#endif\n\tcase USB_GET_CONFIG:\n\t\terr = usbd_get_config(sc->sc_udev, &conf);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\t*(int *)addr = conf;\n\t\tbreak;\n\tcase USB_SET_CONFIG:\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\terr = ugen_set_config(sc, *(int *)addr);\n\t\tif (err)\n\t\t\treturn (EIO);\n\t\tbreak;\n\tcase USB_GET_ALTINTERFACE:\n\t\tai = (struct usb_alt_interface *)addr;\n\t\terr = usbd_device2interface_handle(sc->sc_udev, \n\t\t\t  ai->interface_index, &iface);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tidesc = usbd_get_interface_descriptor(iface);\n\t\tif (idesc == NULL)\n\t\t\treturn (EIO);\n\t\tai->alt_no = idesc->bAlternateSetting;\n\t\tbreak;\n\tcase USB_SET_ALTINTERFACE:\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\tai = (struct usb_alt_interface *)addr;\n\t\terr = usbd_device2interface_handle(sc->sc_udev, \n\t\t\t  ai->interface_index, &iface);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\terr = ugen_set_interface(sc, ai->interface_index, ai->alt_no);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase USB_GET_NO_ALT:\n\t\tai = (struct usb_alt_interface *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, ai->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tidesc = usbd_find_idesc(cdesc, ai->interface_index, 0);\n\t\tif (idesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tai->alt_no = usbd_get_no_alts(cdesc, idesc->bInterfaceNumber);\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_DEVICE_DESC:\n\t\t*(usb_device_descriptor_t *)addr =\n\t\t\t*usbd_get_device_descriptor(sc->sc_udev);\n\t\tbreak;\n\tcase USB_GET_CONFIG_DESC:\n\t\tcd = (struct usb_config_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, cd->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tcd->desc = *cdesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_INTERFACE_DESC:\n\t\tid = (struct usb_interface_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, id->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (id->config_index == USB_CURRENT_CONFIG_INDEX &&\n\t\t    id->alt_index == USB_CURRENT_ALT_INDEX)\n\t\t\talt = ugen_get_alt_index(sc, id->interface_index);\n\t\telse\n\t\t\talt = id->alt_index;\n\t\tidesc = usbd_find_idesc(cdesc, id->interface_index, alt);\n\t\tif (idesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\tid->desc = *idesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_ENDPOINT_DESC:\n\t\ted = (struct usb_endpoint_desc *)addr;\n\t\tcdesc = ugen_get_cdesc(sc, ed->config_index, 0);\n\t\tif (cdesc == NULL)\n\t\t\treturn (EINVAL);\n\t\tif (ed->config_index == USB_CURRENT_CONFIG_INDEX &&\n\t\t    ed->alt_index == USB_CURRENT_ALT_INDEX)\n\t\t\talt = ugen_get_alt_index(sc, ed->interface_index);\n\t\telse\n\t\t\talt = ed->alt_index;\n\t\tedesc = usbd_find_edesc(cdesc, ed->interface_index, \n\t\t\t\t\talt, ed->endpoint_index);\n\t\tif (edesc == NULL) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (EINVAL);\n\t\t}\n\t\ted->desc = *edesc;\n\t\tfree(cdesc, M_TEMP);\n\t\tbreak;\n\tcase USB_GET_FULL_DESC:\n\t{\n\t\tint len;\n\t\tstruct iovec iov;\n\t\tstruct uio uio;\n\t\tstruct usb_full_desc *fd = (struct usb_full_desc *)addr;\n\t\tint error;\n\n\t\tcdesc = ugen_get_cdesc(sc, fd->config_index, &len);\n\t\tif (len > fd->size)\n\t\t\tlen = fd->size;\n\t\tiov.iov_base = (caddr_t)fd->data;\n\t\tiov.iov_len = len;\n\t\tuio.uio_iov = &iov;\n\t\tuio.uio_iovcnt = 1;\n\t\tuio.uio_resid = len;\n\t\tuio.uio_offset = 0;\n\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\tuio.uio_rw = UIO_READ;\n\t\tuio.uio_procp = p;\n\t\terror = uiomove((void *)cdesc, len, &uio);\n\t\tfree(cdesc, M_TEMP);\n\t\treturn (error);\n\t}\n\tcase USB_GET_STRING_DESC:\n\t\tsi = (struct usb_string_desc *)addr;\n\t\terr = usbd_get_string_desc(sc->sc_udev, si->string_index, \n\t\t\t  si->language_id, &si->desc);\n\t\tif (err)\n\t\t\treturn (EINVAL);\n\t\tbreak;\n\tcase USB_DO_REQUEST:\n\t{\n\t\tstruct usb_ctl_request *ur = (void *)addr;\n\t\tint len = UGETW(ur->request.wLength);\n\t\tstruct iovec iov;\n\t\tstruct uio uio;\n\t\tvoid *ptr = 0;\n\t\tusbd_status err;\n\t\tint error = 0;\n\n\t\tif (!(flag & FWRITE))\n\t\t\treturn (EPERM);\n\t\t/* Avoid requests that would damage the bus integrity. */\n\t\tif ((ur->request.bmRequestType == UT_WRITE_DEVICE &&\n\t\t     ur->request.bRequest == UR_SET_ADDRESS) ||\n\t\t    (ur->request.bmRequestType == UT_WRITE_DEVICE &&\n\t\t     ur->request.bRequest == UR_SET_CONFIG) ||\n\t\t    (ur->request.bmRequestType == UT_WRITE_INTERFACE &&\n\t\t     ur->request.bRequest == UR_SET_INTERFACE))\n\t\t\treturn (EINVAL);\n\n\t\tif (len < 0 || len > 32767)\n\t\t\treturn (EINVAL);\n\t\tif (len != 0) {\n\t\t\tiov.iov_base = (caddr_t)ur->data;\n\t\t\tiov.iov_len = len;\n\t\t\tuio.uio_iov = &iov;\n\t\t\tuio.uio_iovcnt = 1;\n\t\t\tuio.uio_resid = len;\n\t\t\tuio.uio_offset = 0;\n\t\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\t\tuio.uio_rw =\n\t\t\t\tur->request.bmRequestType & UT_READ ? \n\t\t\t\tUIO_READ : UIO_WRITE;\n\t\t\tuio.uio_procp = p;\n\t\t\tptr = malloc(len, M_TEMP, M_WAITOK);\n\t\t\tif (uio.uio_rw == UIO_WRITE) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\t\terr = usbd_do_request_flags(sc->sc_udev, &ur->request, \n\t\t\t  ptr, ur->flags, &ur->actlen);\n\t\tif (err) {\n\t\t\terror = EIO;\n\t\t\tgoto ret;\n\t\t}\n\t\tif (len != 0) {\n\t\t\tif (uio.uio_rw == UIO_READ) {\n\t\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto ret;\n\t\t\t}\n\t\t}\n\tret:\n\t\tif (ptr)\n\t\t\tfree(ptr, M_TEMP);\n\t\treturn (error);\n\t}\n\tcase USB_GET_DEVICEINFO:\n\t\tusbd_fill_deviceinfo(sc->sc_udev,\n\t\t\t\t     (struct usb_device_info *)addr);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "ugen_get_alt_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "828-840",
    "snippet": "Static int\nugen_get_alt_index(sc, ifaceidx)\n\tstruct ugen_softc *sc;\n\tint ifaceidx;\n{\n\tusbd_interface_handle iface;\n\tusbd_status err;\n\n\terr = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);\n\tif (err)\n\t\t\treturn (-1);\n\treturn (usbd_get_interface_altindex(iface));\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static int",
      "Static int",
      "Static int",
      "Static int",
      "Static usbd_status",
      "ugen_set_interface __P((struct ugen_softc *, int, int));",
      "Static int",
      "ugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_get_interface_altindex",
          "args": [
            "iface"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_interface_altindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "737-742",
          "snippet": "int\nusbd_get_interface_altindex(iface)\n\tusbd_interface_handle iface;\n{\n\treturn (iface->altindex);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nint\nusbd_get_interface_altindex(iface)\n\tusbd_interface_handle iface;\n{\n\treturn (iface->altindex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_device2interface_handle",
          "args": [
            "sc->sc_udev",
            "ifaceidx",
            "&iface"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_device2interface_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "667-679",
          "snippet": "usbd_status \nusbd_device2interface_handle(dev, ifaceno, iface)\n\tusbd_device_handle dev;\n\tu_int8_t ifaceno;\n\tusbd_interface_handle *iface;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\tif (ifaceno >= dev->cdesc->bNumInterface)\n\t\treturn (USBD_INVAL);\n\t*iface = &dev->ifaces[ifaceno];\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_device2interface_handle(dev, ifaceno, iface)\n\tusbd_device_handle dev;\n\tu_int8_t ifaceno;\n\tusbd_interface_handle *iface;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\tif (ifaceno >= dev->cdesc->bNumInterface)\n\t\treturn (USBD_INVAL);\n\t*iface = &dev->ifaces[ifaceno];\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\nugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));\n\nStatic int\nugen_get_alt_index(sc, ifaceidx)\n\tstruct ugen_softc *sc;\n\tint ifaceidx;\n{\n\tusbd_interface_handle iface;\n\tusbd_status err;\n\n\terr = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);\n\tif (err)\n\t\t\treturn (-1);\n\treturn (usbd_get_interface_altindex(iface));\n}"
  },
  {
    "function_name": "ugen_get_cdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "792-826",
    "snippet": "Static usb_config_descriptor_t *\nugen_get_cdesc(sc, index, lenp)\n\tstruct ugen_softc *sc;\n\tint index;\n\tint *lenp;\n{\n\tusb_config_descriptor_t *cdesc, *tdesc, cdescr;\n\tint len;\n\tusbd_status err;\n\n\tif (index == USB_CURRENT_CONFIG_INDEX) {\n\t\ttdesc = usbd_get_config_descriptor(sc->sc_udev);\n\t\tlen = UGETW(tdesc->wTotalLength);\n\t\tif (lenp)\n\t\t\t*lenp = len;\n\t\tcdesc = malloc(len, M_TEMP, M_WAITOK);\n\t\tmemcpy(cdesc, tdesc, len);\n\t\tDPRINTFN(5,(\"ugen_get_cdesc: current, len=%d\\n\", len));\n\t} else {\n\t\terr = usbd_get_config_desc(sc->sc_udev, index, &cdescr);\n\t\tif (err)\n\t\t\treturn (0);\n\t\tlen = UGETW(cdescr.wTotalLength);\n\t\tDPRINTFN(5,(\"ugen_get_cdesc: index=%d, len=%d\\n\", index, len));\n\t\tif (lenp)\n\t\t\t*lenp = len;\n\t\tcdesc = malloc(len, M_TEMP, M_WAITOK);\n\t\terr = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,len);\n\t\tif (err) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (cdesc);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "Static int",
      "Static int",
      "Static int",
      "Static int",
      "Static usb_config_descriptor_t",
      "Static usbd_status",
      "ugen_set_interface __P((struct ugen_softc *, int, int));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cdesc",
            "M_TEMP"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_get_config_desc_full",
          "args": [
            "sc->sc_udev",
            "index",
            "cdesc",
            "len"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_config_desc_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "110-119",
          "snippet": "usbd_status\nusbd_get_config_desc_full(dev, conf, d, size)\n\tusbd_device_handle dev;\n\tint conf;\n\tvoid *d;\n\tint size;\n{\n\tDPRINTFN(3,(\"usbd_get_config_desc_full: conf=%d\\n\", conf));\n\treturn (usbd_get_desc(dev, UDESC_CONFIG, conf, size, d));\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_get_config_desc_full(dev, conf, d, size)\n\tusbd_device_handle dev;\n\tint conf;\n\tvoid *d;\n\tint size;\n{\n\tDPRINTFN(3,(\"usbd_get_config_desc_full: conf=%d\\n\", conf));\n\treturn (usbd_get_desc(dev, UDESC_CONFIG, conf, size, d));\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len",
            "M_TEMP",
            "M_WAITOK"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugen_get_cdesc: index=%d, len=%d\\n\", index, len)"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "cdescr.wTotalLength"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugen_get_cdesc: current, len=%d\\n\", len)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cdesc",
            "tdesc",
            "len"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "tdesc->wTotalLength"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_config_descriptor",
          "args": [
            "sc->sc_udev"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic usb_config_descriptor_t;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic usb_config_descriptor_t *\nugen_get_cdesc(sc, index, lenp)\n\tstruct ugen_softc *sc;\n\tint index;\n\tint *lenp;\n{\n\tusb_config_descriptor_t *cdesc, *tdesc, cdescr;\n\tint len;\n\tusbd_status err;\n\n\tif (index == USB_CURRENT_CONFIG_INDEX) {\n\t\ttdesc = usbd_get_config_descriptor(sc->sc_udev);\n\t\tlen = UGETW(tdesc->wTotalLength);\n\t\tif (lenp)\n\t\t\t*lenp = len;\n\t\tcdesc = malloc(len, M_TEMP, M_WAITOK);\n\t\tmemcpy(cdesc, tdesc, len);\n\t\tDPRINTFN(5,(\"ugen_get_cdesc: current, len=%d\\n\", len));\n\t} else {\n\t\terr = usbd_get_config_desc(sc->sc_udev, index, &cdescr);\n\t\tif (err)\n\t\t\treturn (0);\n\t\tlen = UGETW(cdescr.wTotalLength);\n\t\tDPRINTFN(5,(\"ugen_get_cdesc: index=%d, len=%d\\n\", index, len));\n\t\tif (lenp)\n\t\t\t*lenp = len;\n\t\tcdesc = malloc(len, M_TEMP, M_WAITOK);\n\t\terr = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,len);\n\t\tif (err) {\n\t\t\tfree(cdesc, M_TEMP);\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (cdesc);\n}"
  },
  {
    "function_name": "ugen_set_interface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "735-789",
    "snippet": "Static usbd_status\nugen_set_interface(sc, ifaceidx, altno)\n\tstruct ugen_softc *sc;\n\tint ifaceidx, altno;\n{\n\tusbd_interface_handle iface;\n\tusb_endpoint_descriptor_t *ed;\n\tusbd_status err;\n\tstruct ugen_endpoint *sce;\n\tu_int8_t niface, nendpt, endptno, endpt;\n\tint dir;\n\n\tDPRINTFN(15, (\"ugen_set_interface %d %d\\n\", ifaceidx, altno));\n\n\terr = usbd_interface_count(sc->sc_udev, &niface);\n\tif (err)\n\t\treturn (err);\n\tif (ifaceidx < 0 || ifaceidx >= niface)\n\t\treturn (USBD_INVAL);\n\t\n\terr = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);\n\tif (err)\n\t\treturn (err);\n\terr = usbd_endpoint_count(iface, &nendpt);\n\tif (err)\n\t\treturn (err);\n\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\tendpt = ed->bEndpointAddress;\n\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\tsce->sc = 0;\n\t\tsce->edesc = 0;\n\t\tsce->iface = 0;\n\t}\n\n\t/* change setting */\n\terr = usbd_set_interface(iface, altno);\n\tif (err)\n\t\treturn (err);\n\n\terr = usbd_endpoint_count(iface, &nendpt);\n\tif (err)\n\t\treturn (err);\n\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\tendpt = ed->bEndpointAddress;\n\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\tsce->sc = sc;\n\t\tsce->edesc = ed;\n\t\tsce->iface = iface;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define IN  1",
      "#define OUT 0"
    ],
    "globals_used": [
      "Static void",
      "Static int",
      "Static int",
      "Static int",
      "Static int",
      "Static usbd_status",
      "ugen_set_interface __P((struct ugen_softc *, int, int));",
      "Static int",
      "ugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UE_GET_ADDR",
          "args": [
            "endpt"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_DIR",
          "args": [
            "endpt"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_interface2endpoint_descriptor",
          "args": [
            "iface",
            "endptno"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_endpoint_count",
          "args": [
            "iface",
            "&nendpt"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_endpoint_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "638-645",
          "snippet": "usbd_status \nusbd_endpoint_count(iface, count)\n\tusbd_interface_handle iface;\n\tu_int8_t *count;\n{\n\t*count = iface->idesc->bNumEndpoints;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_endpoint_count(iface, count)\n\tusbd_interface_handle iface;\n\tu_int8_t *count;\n{\n\t*count = iface->idesc->bNumEndpoints;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_set_interface",
          "args": [
            "iface",
            "altno"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_interface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "689-715",
          "snippet": "usbd_status\nusbd_set_interface(iface, altidx)\n\tusbd_interface_handle iface;\n\tint altidx;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tif (LIST_FIRST(&iface->pipes) != 0)\n\t\treturn (USBD_IN_USE);\n\n\tif (iface->endpoints)\n\t\tfree(iface->endpoints, M_USB);\n\tiface->endpoints = 0;\n\tiface->idesc = 0;\n\n\terr = usbd_fill_iface_data(iface->device, iface->index, altidx);\n\tif (err)\n\t\treturn (err);\n\n\treq.bmRequestType = UT_WRITE_INTERFACE;\n\treq.bRequest = UR_SET_INTERFACE;\n\tUSETW(req.wValue, iface->idesc->bAlternateSetting);\n\tUSETW(req.wIndex, iface->idesc->bInterfaceNumber);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(iface->device, &req, 0));\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "u_int8_t index;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nu_int8_t index;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status\nusbd_set_interface(iface, altidx)\n\tusbd_interface_handle iface;\n\tint altidx;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tif (LIST_FIRST(&iface->pipes) != 0)\n\t\treturn (USBD_IN_USE);\n\n\tif (iface->endpoints)\n\t\tfree(iface->endpoints, M_USB);\n\tiface->endpoints = 0;\n\tiface->idesc = 0;\n\n\terr = usbd_fill_iface_data(iface->device, iface->index, altidx);\n\tif (err)\n\t\treturn (err);\n\n\treq.bmRequestType = UT_WRITE_INTERFACE;\n\treq.bRequest = UR_SET_INTERFACE;\n\tUSETW(req.wValue, iface->idesc->bAlternateSetting);\n\tUSETW(req.wIndex, iface->idesc->bInterfaceNumber);\n\tUSETW(req.wLength, 0);\n\treturn (usbd_do_request(iface->device, &req, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "UE_GET_ADDR",
          "args": [
            "endpt"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_DIR",
          "args": [
            "endpt"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_interface2endpoint_descriptor",
          "args": [
            "iface",
            "endptno"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_device2interface_handle",
          "args": [
            "sc->sc_udev",
            "ifaceidx",
            "&iface"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_device2interface_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "667-679",
          "snippet": "usbd_status \nusbd_device2interface_handle(dev, ifaceno, iface)\n\tusbd_device_handle dev;\n\tu_int8_t ifaceno;\n\tusbd_interface_handle *iface;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\tif (ifaceno >= dev->cdesc->bNumInterface)\n\t\treturn (USBD_INVAL);\n\t*iface = &dev->ifaces[ifaceno];\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_device2interface_handle(dev, ifaceno, iface)\n\tusbd_device_handle dev;\n\tu_int8_t ifaceno;\n\tusbd_interface_handle *iface;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\tif (ifaceno >= dev->cdesc->bNumInterface)\n\t\treturn (USBD_INVAL);\n\t*iface = &dev->ifaces[ifaceno];\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_interface_count",
          "args": [
            "sc->sc_udev",
            "&niface"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_interface_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "647-656",
          "snippet": "usbd_status \nusbd_interface_count(dev, count)\n\tusbd_device_handle dev;\n\tu_int8_t *count;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\t*count = dev->cdesc->bNumInterface;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_interface_count(dev, count)\n\tusbd_device_handle dev;\n\tu_int8_t *count;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\t*count = dev->cdesc->bNumInterface;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "15",
            "(\"ugen_set_interface %d %d\\n\", ifaceidx, altno)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n#define OUT 0\n\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\nugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));\n\nStatic usbd_status\nugen_set_interface(sc, ifaceidx, altno)\n\tstruct ugen_softc *sc;\n\tint ifaceidx, altno;\n{\n\tusbd_interface_handle iface;\n\tusb_endpoint_descriptor_t *ed;\n\tusbd_status err;\n\tstruct ugen_endpoint *sce;\n\tu_int8_t niface, nendpt, endptno, endpt;\n\tint dir;\n\n\tDPRINTFN(15, (\"ugen_set_interface %d %d\\n\", ifaceidx, altno));\n\n\terr = usbd_interface_count(sc->sc_udev, &niface);\n\tif (err)\n\t\treturn (err);\n\tif (ifaceidx < 0 || ifaceidx >= niface)\n\t\treturn (USBD_INVAL);\n\t\n\terr = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);\n\tif (err)\n\t\treturn (err);\n\terr = usbd_endpoint_count(iface, &nendpt);\n\tif (err)\n\t\treturn (err);\n\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\tendpt = ed->bEndpointAddress;\n\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\tsce->sc = 0;\n\t\tsce->edesc = 0;\n\t\tsce->iface = 0;\n\t}\n\n\t/* change setting */\n\terr = usbd_set_interface(iface, altno);\n\tif (err)\n\t\treturn (err);\n\n\terr = usbd_endpoint_count(iface, &nendpt);\n\tif (err)\n\t\treturn (err);\n\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\tendpt = ed->bEndpointAddress;\n\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\tsce->sc = sc;\n\t\tsce->edesc = ed;\n\t\tsce->iface = iface;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "ugenintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "697-733",
    "snippet": "Static void\nugenintr(xfer, addr, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle addr;\n\tusbd_status status;\n{\n\tstruct ugen_endpoint *sce = addr;\n\t/*struct ugen_softc *sc = sce->sc;*/\n\tu_int32_t count;\n\tu_char *ibuf;\n\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tDPRINTF((\"ugenintr: status=%d\\n\", status));\n\t\tusbd_clear_endpoint_stall_async(sce->pipeh);\n\t\treturn;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);\n\tibuf = sce->ibuf;\n\n\tDPRINTFN(5, (\"ugenintr: xfer=%p status=%d count=%d\\n\", \n\t\t     xfer, status, count));\n\tDPRINTFN(5, (\"          data = %02x %02x %02x\\n\",\n\t\t     ibuf[0], ibuf[1], ibuf[2]));\n\n\t(void)b_to_q(ibuf, count, &sce->q);\n\t\t\n\tif (sce->state & UGEN_ASLP) {\n\t\tsce->state &= ~UGEN_ASLP;\n\t\tDPRINTFN(5, (\"ugen_intr: waking %p\\n\", sce));\n\t\twakeup(sce);\n\t}\n\tselwakeup(&sce->rsel);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tUGEN_ASLP\t0x02\t/* waiting for data */"
    ],
    "globals_used": [
      "Static void",
      "ugenintr __P((usbd_xfer_handle xfer, usbd_private_handle addr, \n\t\t\t  usbd_status status));",
      "Static int",
      "Static int",
      "Static int",
      "Static int",
      "Static usbd_status",
      "ugen_set_interface __P((struct ugen_softc *, int, int));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&sce->rsel"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "sce"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugen_intr: waking %p\\n\", sce)"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_to_q",
          "args": [
            "ibuf",
            "count",
            "&sce->q"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"          data = %02x %02x %02x\\n\",\n\t\t     ibuf[0], ibuf[1], ibuf[2])"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenintr: xfer=%p status=%d count=%d\\n\", \n\t\t     xfer, status, count)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "NULL",
            "&count",
            "NULL"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall_async",
          "args": [
            "sce->pipeh"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ugenintr: status=%d\\n\", status)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tUGEN_ASLP\t0x02\t/* waiting for data */\n\nStatic void;\nugenintr __P((usbd_xfer_handle xfer, usbd_private_handle addr, \n\t\t\t  usbd_status status));\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic void\nugenintr(xfer, addr, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle addr;\n\tusbd_status status;\n{\n\tstruct ugen_endpoint *sce = addr;\n\t/*struct ugen_softc *sc = sce->sc;*/\n\tu_int32_t count;\n\tu_char *ibuf;\n\n\tif (status == USBD_CANCELLED)\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tDPRINTF((\"ugenintr: status=%d\\n\", status));\n\t\tusbd_clear_endpoint_stall_async(sce->pipeh);\n\t\treturn;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);\n\tibuf = sce->ibuf;\n\n\tDPRINTFN(5, (\"ugenintr: xfer=%p status=%d count=%d\\n\", \n\t\t     xfer, status, count));\n\tDPRINTFN(5, (\"          data = %02x %02x %02x\\n\",\n\t\t     ibuf[0], ibuf[1], ibuf[2]));\n\n\t(void)b_to_q(ibuf, count, &sce->q);\n\t\t\n\tif (sce->state & UGEN_ASLP) {\n\t\tsce->state &= ~UGEN_ASLP;\n\t\tDPRINTFN(5, (\"ugen_intr: waking %p\\n\", sce));\n\t\twakeup(sce);\n\t}\n\tselwakeup(&sce->rsel);\n}"
  },
  {
    "function_name": "ugen_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "624-641",
    "snippet": "int\nugen_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct ugen_softc *sc = (struct ugen_softc *)self;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ugen_set_interface __P((struct ugen_softc *, int, int));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nugen_set_interface __P((struct ugen_softc *, int, int));\n\nint\nugen_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct ugen_softc *sc = (struct ugen_softc *)self;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "ugenwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "604-621",
    "snippet": "int\nugenwrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint endpt = UGENENDPOINT(dev);\n\tstruct ugen_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(ugen, UGENUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = ugen_do_write(sc, endpt, uio, flag);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));",
      "ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));",
      "ugen_set_interface __P((struct ugen_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugen_do_write",
          "args": [
            "sc",
            "endpt",
            "uio",
            "flag"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "ugen_do_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
          "lines": "541-602",
          "snippet": "Static int\nugen_do_write(sc, endpt, uio, flag)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ugen_endpoint *sce = &sc->sc_endpoints[endpt][OUT];\n\tu_int32_t n;\n\tint error = 0;\n\tchar buf[UGEN_BBSIZE];\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tDPRINTFN(5, (\"%s: ugenwrite: %d\\n\", USBDEVNAME(sc->sc_dev), endpt));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\treturn (ENODEV);\n\n#ifdef DIAGNOSTIC\n\tif (sce->edesc == NULL) {\n\t\tprintf(\"ugenwrite: no edesc\\n\");\n\t\treturn (EIO);\n\t}\n\tif (sce->pipeh == NULL) {\n\t\tprintf(\"ugenwrite: no pipe\\n\");\n\t\treturn (EIO);\n\t}\n#endif\n\n\tswitch (sce->edesc->bmAttributes & UE_XFERTYPE) {\n\tcase UE_BULK:\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\treturn (EIO);\n\t\twhile ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {\n\t\t\terror = uiomove(buf, n, uio);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tDPRINTFN(1, (\"ugenwrite: transfer %d bytes\\n\", n));\n\t\t\terr = usbd_bulk_transfer(xfer, sce->pipeh, 0, \n\t\t\t\t  sce->timeout, buf, &n,\"ugenwb\");\n\t\t\tif (err) {\n\t\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\t\terror = EINTR;\n\t\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\t\terror = ETIMEDOUT;\n\t\t\t\telse\n\t\t\t\t\terror = EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tusbd_free_xfer(xfer);\n\t\tbreak;\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n\treturn (error);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/filio.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define OUT 0",
            "#define\tUGEN_BBSIZE\t1024"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));",
            "Static int",
            "ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));",
            "Static int",
            "Static int",
            "Static usbd_status",
            "ugen_set_interface __P((struct ugen_softc *, int, int));",
            "Static int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define OUT 0\n#define\tUGEN_BBSIZE\t1024\n\nStatic void;\nStatic int;\nugen_do_read __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nugen_do_write __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nStatic int;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic int\nugen_do_write(sc, endpt, uio, flag)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ugen_endpoint *sce = &sc->sc_endpoints[endpt][OUT];\n\tu_int32_t n;\n\tint error = 0;\n\tchar buf[UGEN_BBSIZE];\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tDPRINTFN(5, (\"%s: ugenwrite: %d\\n\", USBDEVNAME(sc->sc_dev), endpt));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\treturn (ENODEV);\n\n#ifdef DIAGNOSTIC\n\tif (sce->edesc == NULL) {\n\t\tprintf(\"ugenwrite: no edesc\\n\");\n\t\treturn (EIO);\n\t}\n\tif (sce->pipeh == NULL) {\n\t\tprintf(\"ugenwrite: no pipe\\n\");\n\t\treturn (EIO);\n\t}\n#endif\n\n\tswitch (sce->edesc->bmAttributes & UE_XFERTYPE) {\n\tcase UE_BULK:\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\treturn (EIO);\n\t\twhile ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {\n\t\t\terror = uiomove(buf, n, uio);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tDPRINTFN(1, (\"ugenwrite: transfer %d bytes\\n\", n));\n\t\t\terr = usbd_bulk_transfer(xfer, sce->pipeh, 0, \n\t\t\t\t  sce->timeout, buf, &n,\"ugenwb\");\n\t\t\tif (err) {\n\t\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\t\terror = EINTR;\n\t\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\t\terror = ETIMEDOUT;\n\t\t\t\telse\n\t\t\t\t\terror = EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tusbd_free_xfer(xfer);\n\t\tbreak;\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "ugen",
            "UGENUNIT(dev)",
            "sc"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENUNIT",
          "args": [
            "dev"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENENDPOINT",
          "args": [
            "dev"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nugen_do_read __P((struct ugen_softc *, int, struct uio *, int));\nugen_do_write __P((struct ugen_softc *, int, struct uio *, int));\nugen_set_interface __P((struct ugen_softc *, int, int));\n\nint\nugenwrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint endpt = UGENENDPOINT(dev);\n\tstruct ugen_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(ugen, UGENUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = ugen_do_write(sc, endpt, uio, flag);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}"
  },
  {
    "function_name": "ugen_do_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "541-602",
    "snippet": "Static int\nugen_do_write(sc, endpt, uio, flag)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ugen_endpoint *sce = &sc->sc_endpoints[endpt][OUT];\n\tu_int32_t n;\n\tint error = 0;\n\tchar buf[UGEN_BBSIZE];\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tDPRINTFN(5, (\"%s: ugenwrite: %d\\n\", USBDEVNAME(sc->sc_dev), endpt));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\treturn (ENODEV);\n\n#ifdef DIAGNOSTIC\n\tif (sce->edesc == NULL) {\n\t\tprintf(\"ugenwrite: no edesc\\n\");\n\t\treturn (EIO);\n\t}\n\tif (sce->pipeh == NULL) {\n\t\tprintf(\"ugenwrite: no pipe\\n\");\n\t\treturn (EIO);\n\t}\n#endif\n\n\tswitch (sce->edesc->bmAttributes & UE_XFERTYPE) {\n\tcase UE_BULK:\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\treturn (EIO);\n\t\twhile ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {\n\t\t\terror = uiomove(buf, n, uio);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tDPRINTFN(1, (\"ugenwrite: transfer %d bytes\\n\", n));\n\t\t\terr = usbd_bulk_transfer(xfer, sce->pipeh, 0, \n\t\t\t\t  sce->timeout, buf, &n,\"ugenwb\");\n\t\t\tif (err) {\n\t\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\t\terror = EINTR;\n\t\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\t\terror = ETIMEDOUT;\n\t\t\t\telse\n\t\t\t\t\terror = EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tusbd_free_xfer(xfer);\n\t\tbreak;\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define OUT 0",
      "#define\tUGEN_BBSIZE\t1024"
    ],
    "globals_used": [
      "Static void",
      "Static int",
      "ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));",
      "Static int",
      "ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));",
      "Static int",
      "Static int",
      "Static usbd_status",
      "ugen_set_interface __P((struct ugen_softc *, int, int));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "xfer"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_bulk_transfer",
          "args": [
            "xfer",
            "sce->pipeh",
            "0",
            "sce->timeout",
            "buf",
            "&n",
            "\"ugenwb\""
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_bulk_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "499-535",
          "snippet": "usbd_status\nusbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid *buf;\n\tu_int32_t *size;\n\tchar *lbl;\n{\n\tusbd_status err;\n\tint s, error;\n\n\tusbd_setup_xfer(xfer, pipe, 0, buf, *size,\n\t\t\tflags, timeout, usbd_bulk_transfer_cb);\n\tDPRINTFN(1, (\"usbd_bulk_transfer: start transfer %d bytes\\n\", *size));\n\ts = splusb();\t\t/* don't want callback until tsleep() */\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn (err);\n\t}\n\terror = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);\n\tsplx(s);\n\tif (error) {\n\t\tDPRINTF((\"usbd_bulk_transfer: tsleep=%d\\n\", error));\n\t\tusbd_abort_pipe(pipe);\n\t\treturn (USBD_INTERRUPTED);\n\t}\n\tusbd_get_xfer_status(xfer, NULL, NULL, size, &err);\n\tDPRINTFN(1,(\"usbd_bulk_transfer: transferred %d\\n\", *size));\n\tif (err) {\n\t\tDPRINTF((\"usbd_bulk_transfer: error=%d\\n\", err));\n\t\tusbd_clear_endpoint_stall(pipe);\n\t}\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid *buf;\n\tu_int32_t *size;\n\tchar *lbl;\n{\n\tusbd_status err;\n\tint s, error;\n\n\tusbd_setup_xfer(xfer, pipe, 0, buf, *size,\n\t\t\tflags, timeout, usbd_bulk_transfer_cb);\n\tDPRINTFN(1, (\"usbd_bulk_transfer: start transfer %d bytes\\n\", *size));\n\ts = splusb();\t\t/* don't want callback until tsleep() */\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn (err);\n\t}\n\terror = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);\n\tsplx(s);\n\tif (error) {\n\t\tDPRINTF((\"usbd_bulk_transfer: tsleep=%d\\n\", error));\n\t\tusbd_abort_pipe(pipe);\n\t\treturn (USBD_INTERRUPTED);\n\t}\n\tusbd_get_xfer_status(xfer, NULL, NULL, size, &err);\n\tDPRINTFN(1,(\"usbd_bulk_transfer: transferred %d\\n\", *size));\n\tif (err) {\n\t\tDPRINTF((\"usbd_bulk_transfer: error=%d\\n\", err));\n\t\tusbd_clear_endpoint_stall(pipe);\n\t}\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ugenwrite: transfer %d bytes\\n\", n)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "buf",
            "n",
            "uio"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "UGEN_BBSIZE",
            "uio->uio_resid"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->sc_udev"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ugenwrite: no pipe\\n\""
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: ugenwrite: %d\\n\", USBDEVNAME(sc->sc_dev), endpt)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define OUT 0\n#define\tUGEN_BBSIZE\t1024\n\nStatic void;\nStatic int;\nugen_do_read __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nugen_do_write __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nStatic int;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic int\nugen_do_write(sc, endpt, uio, flag)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ugen_endpoint *sce = &sc->sc_endpoints[endpt][OUT];\n\tu_int32_t n;\n\tint error = 0;\n\tchar buf[UGEN_BBSIZE];\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tDPRINTFN(5, (\"%s: ugenwrite: %d\\n\", USBDEVNAME(sc->sc_dev), endpt));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\treturn (ENODEV);\n\n#ifdef DIAGNOSTIC\n\tif (sce->edesc == NULL) {\n\t\tprintf(\"ugenwrite: no edesc\\n\");\n\t\treturn (EIO);\n\t}\n\tif (sce->pipeh == NULL) {\n\t\tprintf(\"ugenwrite: no pipe\\n\");\n\t\treturn (EIO);\n\t}\n#endif\n\n\tswitch (sce->edesc->bmAttributes & UE_XFERTYPE) {\n\tcase UE_BULK:\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\treturn (EIO);\n\t\twhile ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {\n\t\t\terror = uiomove(buf, n, uio);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tDPRINTFN(1, (\"ugenwrite: transfer %d bytes\\n\", n));\n\t\t\terr = usbd_bulk_transfer(xfer, sce->pipeh, 0, \n\t\t\t\t  sce->timeout, buf, &n,\"ugenwb\");\n\t\t\tif (err) {\n\t\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\t\terror = EINTR;\n\t\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\t\terror = ETIMEDOUT;\n\t\t\t\telse\n\t\t\t\t\terror = EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tusbd_free_xfer(xfer);\n\t\tbreak;\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n\treturn (error);\n}"
  },
  {
    "function_name": "ugenread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "522-539",
    "snippet": "int\nugenread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint endpt = UGENENDPOINT(dev);\n\tstruct ugen_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(ugen, UGENUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = ugen_do_read(sc, endpt, uio, flag);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));",
      "ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));",
      "ugen_set_interface __P((struct ugen_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ugen_do_read",
          "args": [
            "sc",
            "endpt",
            "uio",
            "flag"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "ugen_do_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
          "lines": "413-520",
          "snippet": "Static int\nugen_do_read(sc, endpt, uio, flag)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ugen_endpoint *sce = &sc->sc_endpoints[endpt][IN];\n\tu_int32_t n, tn;\n\tchar buf[UGEN_BBSIZE];\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\tint s;\n\tint error = 0;\n\tu_char buffer[UGEN_CHUNK];\n\n#ifdef __NetBSD__\n\tDPRINTFN(5, (\"ugenread: %d:%d\\n\", sc->sc_dev.dv_unit, endpt));\n#endif\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\treturn (ENODEV);\n\n#ifdef DIAGNOSTIC\n\tif (sce->edesc == NULL) {\n\t\tprintf(\"ugenread: no edesc\\n\");\n\t\treturn (EIO);\n\t}\n\tif (sce->pipeh == NULL) {\n\t\tprintf(\"ugenread: no pipe\\n\");\n\t\treturn (EIO);\n\t}\n#endif\n\n\tswitch (sce->edesc->bmAttributes & UE_XFERTYPE) {\n\tcase UE_INTERRUPT:\n\t\t/* Block until activity occured. */\n\t\ts = splusb();\n\t\twhile (sce->q.c_cc == 0) {\n\t\t\tif (flag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\tsce->state |= UGEN_ASLP;\n\t\t\tDPRINTFN(5, (\"ugenread: sleep on %p\\n\", sc));\n\t\t\terror = tsleep(sce, PZERO | PCATCH, \"ugenri\", 0);\n\t\t\tDPRINTFN(5, (\"ugenread: woke, error=%d\\n\", error));\n\t\t\tif (sc->sc_dying)\n\t\t\t\terror = EIO;\n\t\t\tif (error) {\n\t\t\t\tsce->state &= ~UGEN_ASLP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsplx(s);\n\n\t\t/* Transfer as many chunks as possible. */\n\t\twhile (sce->q.c_cc > 0 && uio->uio_resid > 0 && !error) {\n\t\t\tn = min(sce->q.c_cc, uio->uio_resid);\n\t\t\tif (n > sizeof(buffer))\n\t\t\t\tn = sizeof(buffer);\n\n\t\t\t/* Remove a small chunk from the input queue. */\n\t\t\tq_to_b(&sce->q, buffer, n);\n\t\t\tDPRINTFN(5, (\"ugenread: got %d chars\\n\", n));\n\n\t\t\t/* Copy the data to the user process. */\n\t\t\terror = uiomove(buffer, n, uio);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UE_BULK:\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\treturn (ENOMEM);\n\t\twhile ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {\n\t\t\tDPRINTFN(1, (\"ugenread: start transfer %d bytes\\n\",n));\n\t\t\ttn = n;\n\t\t\terr = usbd_bulk_transfer(\n\t\t\t\t  xfer, sce->pipeh,\n\t\t\t\t  sce->state & UGEN_SHORT_OK ? \n\t\t\t\t      USBD_SHORT_XFER_OK : 0, \n\t\t\t\t  sce->timeout, buf, &tn, \"ugenrb\");\n\t\t\tif (err) {\n\t\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\t\terror = EINTR;\n\t\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\t\terror = ETIMEDOUT;\n\t\t\t\telse\n\t\t\t\t\terror = EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTFN(1, (\"ugenread: got %d bytes\\n\", tn));\n\t\t\terror = uiomove(buf, tn, uio);\n\t\t\tif (error || tn < n)\n\t\t\t\tbreak;\n\t\t}\n\t\tusbd_free_xfer(xfer);\n\t\tbreak;\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n\treturn (error);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/poll.h>",
            "#include <sys/vnode.h>",
            "#include <sys/proc.h>",
            "#include <sys/select.h>",
            "#include <sys/file.h>",
            "#include <sys/tty.h>",
            "#include <sys/conf.h>",
            "#include <sys/filio.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define IN  1",
            "#define\tUGEN_BBSIZE\t1024",
            "#define\tUGEN_CHUNK\t128\t/* chunk size for read */",
            "#define UGEN_SHORT_OK\t0x04\t/* short xfers are OK */",
            "#define\tUGEN_ASLP\t0x02\t/* waiting for data */"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));",
            "Static int",
            "ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));",
            "Static int",
            "Static int",
            "Static usbd_status",
            "ugen_set_interface __P((struct ugen_softc *, int, int));",
            "Static int"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n#define\tUGEN_BBSIZE\t1024\n#define\tUGEN_CHUNK\t128\t/* chunk size for read */\n#define UGEN_SHORT_OK\t0x04\t/* short xfers are OK */\n#define\tUGEN_ASLP\t0x02\t/* waiting for data */\n\nStatic void;\nStatic int;\nugen_do_read __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nugen_do_write __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nStatic int;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic int\nugen_do_read(sc, endpt, uio, flag)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ugen_endpoint *sce = &sc->sc_endpoints[endpt][IN];\n\tu_int32_t n, tn;\n\tchar buf[UGEN_BBSIZE];\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\tint s;\n\tint error = 0;\n\tu_char buffer[UGEN_CHUNK];\n\n#ifdef __NetBSD__\n\tDPRINTFN(5, (\"ugenread: %d:%d\\n\", sc->sc_dev.dv_unit, endpt));\n#endif\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\treturn (ENODEV);\n\n#ifdef DIAGNOSTIC\n\tif (sce->edesc == NULL) {\n\t\tprintf(\"ugenread: no edesc\\n\");\n\t\treturn (EIO);\n\t}\n\tif (sce->pipeh == NULL) {\n\t\tprintf(\"ugenread: no pipe\\n\");\n\t\treturn (EIO);\n\t}\n#endif\n\n\tswitch (sce->edesc->bmAttributes & UE_XFERTYPE) {\n\tcase UE_INTERRUPT:\n\t\t/* Block until activity occured. */\n\t\ts = splusb();\n\t\twhile (sce->q.c_cc == 0) {\n\t\t\tif (flag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\tsce->state |= UGEN_ASLP;\n\t\t\tDPRINTFN(5, (\"ugenread: sleep on %p\\n\", sc));\n\t\t\terror = tsleep(sce, PZERO | PCATCH, \"ugenri\", 0);\n\t\t\tDPRINTFN(5, (\"ugenread: woke, error=%d\\n\", error));\n\t\t\tif (sc->sc_dying)\n\t\t\t\terror = EIO;\n\t\t\tif (error) {\n\t\t\t\tsce->state &= ~UGEN_ASLP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsplx(s);\n\n\t\t/* Transfer as many chunks as possible. */\n\t\twhile (sce->q.c_cc > 0 && uio->uio_resid > 0 && !error) {\n\t\t\tn = min(sce->q.c_cc, uio->uio_resid);\n\t\t\tif (n > sizeof(buffer))\n\t\t\t\tn = sizeof(buffer);\n\n\t\t\t/* Remove a small chunk from the input queue. */\n\t\t\tq_to_b(&sce->q, buffer, n);\n\t\t\tDPRINTFN(5, (\"ugenread: got %d chars\\n\", n));\n\n\t\t\t/* Copy the data to the user process. */\n\t\t\terror = uiomove(buffer, n, uio);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UE_BULK:\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\treturn (ENOMEM);\n\t\twhile ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {\n\t\t\tDPRINTFN(1, (\"ugenread: start transfer %d bytes\\n\",n));\n\t\t\ttn = n;\n\t\t\terr = usbd_bulk_transfer(\n\t\t\t\t  xfer, sce->pipeh,\n\t\t\t\t  sce->state & UGEN_SHORT_OK ? \n\t\t\t\t      USBD_SHORT_XFER_OK : 0, \n\t\t\t\t  sce->timeout, buf, &tn, \"ugenrb\");\n\t\t\tif (err) {\n\t\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\t\terror = EINTR;\n\t\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\t\terror = ETIMEDOUT;\n\t\t\t\telse\n\t\t\t\t\terror = EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTFN(1, (\"ugenread: got %d bytes\\n\", tn));\n\t\t\terror = uiomove(buf, tn, uio);\n\t\t\tif (error || tn < n)\n\t\t\t\tbreak;\n\t\t}\n\t\tusbd_free_xfer(xfer);\n\t\tbreak;\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "ugen",
            "UGENUNIT(dev)",
            "sc"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENUNIT",
          "args": [
            "dev"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENENDPOINT",
          "args": [
            "dev"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nugen_do_read __P((struct ugen_softc *, int, struct uio *, int));\nugen_do_write __P((struct ugen_softc *, int, struct uio *, int));\nugen_set_interface __P((struct ugen_softc *, int, int));\n\nint\nugenread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tint endpt = UGENENDPOINT(dev);\n\tstruct ugen_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(ugen, UGENUNIT(dev), sc);\n\n\tsc->sc_refcnt++;\n\terror = ugen_do_read(sc, endpt, uio, flag);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}"
  },
  {
    "function_name": "ugen_do_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "413-520",
    "snippet": "Static int\nugen_do_read(sc, endpt, uio, flag)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ugen_endpoint *sce = &sc->sc_endpoints[endpt][IN];\n\tu_int32_t n, tn;\n\tchar buf[UGEN_BBSIZE];\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\tint s;\n\tint error = 0;\n\tu_char buffer[UGEN_CHUNK];\n\n#ifdef __NetBSD__\n\tDPRINTFN(5, (\"ugenread: %d:%d\\n\", sc->sc_dev.dv_unit, endpt));\n#endif\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\treturn (ENODEV);\n\n#ifdef DIAGNOSTIC\n\tif (sce->edesc == NULL) {\n\t\tprintf(\"ugenread: no edesc\\n\");\n\t\treturn (EIO);\n\t}\n\tif (sce->pipeh == NULL) {\n\t\tprintf(\"ugenread: no pipe\\n\");\n\t\treturn (EIO);\n\t}\n#endif\n\n\tswitch (sce->edesc->bmAttributes & UE_XFERTYPE) {\n\tcase UE_INTERRUPT:\n\t\t/* Block until activity occured. */\n\t\ts = splusb();\n\t\twhile (sce->q.c_cc == 0) {\n\t\t\tif (flag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\tsce->state |= UGEN_ASLP;\n\t\t\tDPRINTFN(5, (\"ugenread: sleep on %p\\n\", sc));\n\t\t\terror = tsleep(sce, PZERO | PCATCH, \"ugenri\", 0);\n\t\t\tDPRINTFN(5, (\"ugenread: woke, error=%d\\n\", error));\n\t\t\tif (sc->sc_dying)\n\t\t\t\terror = EIO;\n\t\t\tif (error) {\n\t\t\t\tsce->state &= ~UGEN_ASLP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsplx(s);\n\n\t\t/* Transfer as many chunks as possible. */\n\t\twhile (sce->q.c_cc > 0 && uio->uio_resid > 0 && !error) {\n\t\t\tn = min(sce->q.c_cc, uio->uio_resid);\n\t\t\tif (n > sizeof(buffer))\n\t\t\t\tn = sizeof(buffer);\n\n\t\t\t/* Remove a small chunk from the input queue. */\n\t\t\tq_to_b(&sce->q, buffer, n);\n\t\t\tDPRINTFN(5, (\"ugenread: got %d chars\\n\", n));\n\n\t\t\t/* Copy the data to the user process. */\n\t\t\terror = uiomove(buffer, n, uio);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UE_BULK:\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\treturn (ENOMEM);\n\t\twhile ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {\n\t\t\tDPRINTFN(1, (\"ugenread: start transfer %d bytes\\n\",n));\n\t\t\ttn = n;\n\t\t\terr = usbd_bulk_transfer(\n\t\t\t\t  xfer, sce->pipeh,\n\t\t\t\t  sce->state & UGEN_SHORT_OK ? \n\t\t\t\t      USBD_SHORT_XFER_OK : 0, \n\t\t\t\t  sce->timeout, buf, &tn, \"ugenrb\");\n\t\t\tif (err) {\n\t\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\t\terror = EINTR;\n\t\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\t\terror = ETIMEDOUT;\n\t\t\t\telse\n\t\t\t\t\terror = EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTFN(1, (\"ugenread: got %d bytes\\n\", tn));\n\t\t\terror = uiomove(buf, tn, uio);\n\t\t\tif (error || tn < n)\n\t\t\t\tbreak;\n\t\t}\n\t\tusbd_free_xfer(xfer);\n\t\tbreak;\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define IN  1",
      "#define\tUGEN_BBSIZE\t1024",
      "#define\tUGEN_CHUNK\t128\t/* chunk size for read */",
      "#define UGEN_SHORT_OK\t0x04\t/* short xfers are OK */",
      "#define\tUGEN_ASLP\t0x02\t/* waiting for data */"
    ],
    "globals_used": [
      "Static void",
      "Static int",
      "ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));",
      "Static int",
      "ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));",
      "Static int",
      "Static int",
      "Static usbd_status",
      "ugen_set_interface __P((struct ugen_softc *, int, int));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "xfer"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "buf",
            "tn",
            "uio"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ugenread: got %d bytes\\n\", tn)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_bulk_transfer",
          "args": [
            "xfer",
            "sce->pipeh",
            "sce->state & UGEN_SHORT_OK ? \n\t\t\t\t      USBD_SHORT_XFER_OK : 0",
            "sce->timeout",
            "buf",
            "&tn",
            "\"ugenrb\""
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_bulk_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "499-535",
          "snippet": "usbd_status\nusbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid *buf;\n\tu_int32_t *size;\n\tchar *lbl;\n{\n\tusbd_status err;\n\tint s, error;\n\n\tusbd_setup_xfer(xfer, pipe, 0, buf, *size,\n\t\t\tflags, timeout, usbd_bulk_transfer_cb);\n\tDPRINTFN(1, (\"usbd_bulk_transfer: start transfer %d bytes\\n\", *size));\n\ts = splusb();\t\t/* don't want callback until tsleep() */\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn (err);\n\t}\n\terror = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);\n\tsplx(s);\n\tif (error) {\n\t\tDPRINTF((\"usbd_bulk_transfer: tsleep=%d\\n\", error));\n\t\tusbd_abort_pipe(pipe);\n\t\treturn (USBD_INTERRUPTED);\n\t}\n\tusbd_get_xfer_status(xfer, NULL, NULL, size, &err);\n\tDPRINTFN(1,(\"usbd_bulk_transfer: transferred %d\\n\", *size));\n\tif (err) {\n\t\tDPRINTF((\"usbd_bulk_transfer: error=%d\\n\", err));\n\t\tusbd_clear_endpoint_stall(pipe);\n\t}\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid *buf;\n\tu_int32_t *size;\n\tchar *lbl;\n{\n\tusbd_status err;\n\tint s, error;\n\n\tusbd_setup_xfer(xfer, pipe, 0, buf, *size,\n\t\t\tflags, timeout, usbd_bulk_transfer_cb);\n\tDPRINTFN(1, (\"usbd_bulk_transfer: start transfer %d bytes\\n\", *size));\n\ts = splusb();\t\t/* don't want callback until tsleep() */\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn (err);\n\t}\n\terror = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);\n\tsplx(s);\n\tif (error) {\n\t\tDPRINTF((\"usbd_bulk_transfer: tsleep=%d\\n\", error));\n\t\tusbd_abort_pipe(pipe);\n\t\treturn (USBD_INTERRUPTED);\n\t}\n\tusbd_get_xfer_status(xfer, NULL, NULL, size, &err);\n\tDPRINTFN(1,(\"usbd_bulk_transfer: transferred %d\\n\", *size));\n\tif (err) {\n\t\tDPRINTF((\"usbd_bulk_transfer: error=%d\\n\", err));\n\t\tusbd_clear_endpoint_stall(pipe);\n\t}\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ugenread: start transfer %d bytes\\n\",n)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "UGEN_BBSIZE",
            "uio->uio_resid"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->sc_udev"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "buffer",
            "n",
            "uio"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenread: got %d chars\\n\", n)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "q_to_b",
          "args": [
            "&sce->q",
            "buffer",
            "n"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenread: woke, error=%d\\n\", error)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "sce",
            "PZERO | PCATCH",
            "\"ugenri\"",
            "0"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenread: sleep on %p\\n\", sc)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ugenread: no pipe\\n\""
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenread: %d:%d\\n\", sc->sc_dev.dv_unit, endpt)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n#define\tUGEN_BBSIZE\t1024\n#define\tUGEN_CHUNK\t128\t/* chunk size for read */\n#define UGEN_SHORT_OK\t0x04\t/* short xfers are OK */\n#define\tUGEN_ASLP\t0x02\t/* waiting for data */\n\nStatic void;\nStatic int;\nugen_do_read __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nugen_do_write __P((struct ugen_softc *, int, struct uio *, int));\nStatic int;\nStatic int;\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic int\nugen_do_read(sc, endpt, uio, flag)\n\tstruct ugen_softc *sc;\n\tint endpt;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct ugen_endpoint *sce = &sc->sc_endpoints[endpt][IN];\n\tu_int32_t n, tn;\n\tchar buf[UGEN_BBSIZE];\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\tint s;\n\tint error = 0;\n\tu_char buffer[UGEN_CHUNK];\n\n#ifdef __NetBSD__\n\tDPRINTFN(5, (\"ugenread: %d:%d\\n\", sc->sc_dev.dv_unit, endpt));\n#endif\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (endpt == USB_CONTROL_ENDPOINT)\n\t\treturn (ENODEV);\n\n#ifdef DIAGNOSTIC\n\tif (sce->edesc == NULL) {\n\t\tprintf(\"ugenread: no edesc\\n\");\n\t\treturn (EIO);\n\t}\n\tif (sce->pipeh == NULL) {\n\t\tprintf(\"ugenread: no pipe\\n\");\n\t\treturn (EIO);\n\t}\n#endif\n\n\tswitch (sce->edesc->bmAttributes & UE_XFERTYPE) {\n\tcase UE_INTERRUPT:\n\t\t/* Block until activity occured. */\n\t\ts = splusb();\n\t\twhile (sce->q.c_cc == 0) {\n\t\t\tif (flag & IO_NDELAY) {\n\t\t\t\tsplx(s);\n\t\t\t\treturn (EWOULDBLOCK);\n\t\t\t}\n\t\t\tsce->state |= UGEN_ASLP;\n\t\t\tDPRINTFN(5, (\"ugenread: sleep on %p\\n\", sc));\n\t\t\terror = tsleep(sce, PZERO | PCATCH, \"ugenri\", 0);\n\t\t\tDPRINTFN(5, (\"ugenread: woke, error=%d\\n\", error));\n\t\t\tif (sc->sc_dying)\n\t\t\t\terror = EIO;\n\t\t\tif (error) {\n\t\t\t\tsce->state &= ~UGEN_ASLP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsplx(s);\n\n\t\t/* Transfer as many chunks as possible. */\n\t\twhile (sce->q.c_cc > 0 && uio->uio_resid > 0 && !error) {\n\t\t\tn = min(sce->q.c_cc, uio->uio_resid);\n\t\t\tif (n > sizeof(buffer))\n\t\t\t\tn = sizeof(buffer);\n\n\t\t\t/* Remove a small chunk from the input queue. */\n\t\t\tq_to_b(&sce->q, buffer, n);\n\t\t\tDPRINTFN(5, (\"ugenread: got %d chars\\n\", n));\n\n\t\t\t/* Copy the data to the user process. */\n\t\t\terror = uiomove(buffer, n, uio);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UE_BULK:\n\t\txfer = usbd_alloc_xfer(sc->sc_udev);\n\t\tif (xfer == 0)\n\t\t\treturn (ENOMEM);\n\t\twhile ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {\n\t\t\tDPRINTFN(1, (\"ugenread: start transfer %d bytes\\n\",n));\n\t\t\ttn = n;\n\t\t\terr = usbd_bulk_transfer(\n\t\t\t\t  xfer, sce->pipeh,\n\t\t\t\t  sce->state & UGEN_SHORT_OK ? \n\t\t\t\t      USBD_SHORT_XFER_OK : 0, \n\t\t\t\t  sce->timeout, buf, &tn, \"ugenrb\");\n\t\t\tif (err) {\n\t\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\t\terror = EINTR;\n\t\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\t\terror = ETIMEDOUT;\n\t\t\t\telse\n\t\t\t\t\terror = EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDPRINTFN(1, (\"ugenread: got %d bytes\\n\", tn));\n\t\t\terror = uiomove(buf, tn, uio);\n\t\t\tif (error || tn < n)\n\t\t\t\tbreak;\n\t\t}\n\t\tusbd_free_xfer(xfer);\n\t\tbreak;\n\tdefault:\n\t\treturn (ENXIO);\n\t}\n\treturn (error);\n}"
  },
  {
    "function_name": "ugenclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "358-411",
    "snippet": "int\nugenclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tint endpt = UGENENDPOINT(dev);\n\tstruct ugen_softc *sc;\n\tstruct ugen_endpoint *sce;\n\tint dir;\n\n\tUSB_GET_SC(ugen, UGENUNIT(dev), sc);\n\n\tDPRINTFN(5, (\"ugenclose: flag=%d, mode=%d, unit=%d, endpt=%d\\n\",\n\t\t     flag, mode, UGENUNIT(dev), endpt));\n\n#ifdef DIAGNOSTIC\n\tif (!sc->sc_is_open[endpt]) {\n\t\tprintf(\"ugenclose: not open\\n\");\n\t\treturn (EINVAL);\n\t}\n#endif\n\n\tif (endpt == USB_CONTROL_ENDPOINT) {\n\t\tDPRINTFN(5, (\"ugenclose: close control\\n\"));\n\t\tsc->sc_is_open[endpt] = 0;\n\t\treturn (0);\n\t}\n\n\tfor (dir = OUT; dir <= IN; dir++) {\n\t\tif (!(flag & (dir == OUT ? FWRITE : FREAD)))\n\t\t\tcontinue;\n\t\tsce = &sc->sc_endpoints[endpt][dir];\n\t\tif (sce == NULL || sce->pipeh == NULL)\n\t\t\tcontinue;\n\t\tDPRINTFN(5, (\"ugenclose: endpt=%d dir=%d sce=%p\\n\", \n\t\t\t     endpt, dir, sce));\n\t\t\n\t\tusbd_abort_pipe(sce->pipeh);\n\t\tusbd_close_pipe(sce->pipeh);\n\t\tsce->pipeh = NULL;\n\t\t\n\t\tif (sce->ibuf != NULL) {\n\t\t\tfree(sce->ibuf, M_USBDEV);\n\t\t\tsce->ibuf = NULL;\n\t\t\tclfree(&sce->q);\n\n\t\t}\n\t}\n\tsc->sc_is_open[endpt] = 0;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define IN  1",
      "#define OUT 0"
    ],
    "globals_used": [
      "ugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));",
      "ugen_set_interface __P((struct ugen_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clfree",
          "args": [
            "&sce->q"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sce->ibuf",
            "M_USBDEV"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "sce->pipeh"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_abort_pipe",
          "args": [
            "sce->pipeh"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_abort_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "560-577",
          "snippet": "usbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenclose: endpt=%d dir=%d sce=%p\\n\", \n\t\t\t     endpt, dir, sce)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenclose: close control\\n\")"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ugenclose: not open\\n\""
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenclose: flag=%d, mode=%d, unit=%d, endpt=%d\\n\",\n\t\t     flag, mode, UGENUNIT(dev), endpt)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENUNIT",
          "args": [
            "dev"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "ugen",
            "UGENUNIT(dev)",
            "sc"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENUNIT",
          "args": [
            "dev"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENENDPOINT",
          "args": [
            "dev"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n#define OUT 0\n\nugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));\nugen_set_interface __P((struct ugen_softc *, int, int));\n\nint\nugenclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tint endpt = UGENENDPOINT(dev);\n\tstruct ugen_softc *sc;\n\tstruct ugen_endpoint *sce;\n\tint dir;\n\n\tUSB_GET_SC(ugen, UGENUNIT(dev), sc);\n\n\tDPRINTFN(5, (\"ugenclose: flag=%d, mode=%d, unit=%d, endpt=%d\\n\",\n\t\t     flag, mode, UGENUNIT(dev), endpt));\n\n#ifdef DIAGNOSTIC\n\tif (!sc->sc_is_open[endpt]) {\n\t\tprintf(\"ugenclose: not open\\n\");\n\t\treturn (EINVAL);\n\t}\n#endif\n\n\tif (endpt == USB_CONTROL_ENDPOINT) {\n\t\tDPRINTFN(5, (\"ugenclose: close control\\n\"));\n\t\tsc->sc_is_open[endpt] = 0;\n\t\treturn (0);\n\t}\n\n\tfor (dir = OUT; dir <= IN; dir++) {\n\t\tif (!(flag & (dir == OUT ? FWRITE : FREAD)))\n\t\t\tcontinue;\n\t\tsce = &sc->sc_endpoints[endpt][dir];\n\t\tif (sce == NULL || sce->pipeh == NULL)\n\t\t\tcontinue;\n\t\tDPRINTFN(5, (\"ugenclose: endpt=%d dir=%d sce=%p\\n\", \n\t\t\t     endpt, dir, sce));\n\t\t\n\t\tusbd_abort_pipe(sce->pipeh);\n\t\tusbd_close_pipe(sce->pipeh);\n\t\tsce->pipeh = NULL;\n\t\t\n\t\tif (sce->ibuf != NULL) {\n\t\t\tfree(sce->ibuf, M_USBDEV);\n\t\t\tsce->ibuf = NULL;\n\t\t\tclfree(&sce->q);\n\n\t\t}\n\t}\n\tsc->sc_is_open[endpt] = 0;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "ugenopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "270-356",
    "snippet": "int\nugenopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct ugen_softc *sc;\n\tint unit = UGENUNIT(dev);\n\tint endpt = UGENENDPOINT(dev);\n\tusb_endpoint_descriptor_t *edesc;\n\tstruct ugen_endpoint *sce;\n\tint dir, isize;\n\tusbd_status err;\n\n\tUSB_GET_SC_OPEN(ugen, unit, sc);\n\n \tDPRINTFN(5, (\"ugenopen: flag=%d, mode=%d, unit=%d endpt=%d\\n\", \n\t\t     flag, mode, unit, endpt));\n\n\tif (sc == NULL || sc->sc_dying)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_is_open[endpt])\n\t\treturn (EBUSY);\n\n\tif (endpt == USB_CONTROL_ENDPOINT) {\n\t\tsc->sc_is_open[USB_CONTROL_ENDPOINT] = 1;\n\t\treturn (0);\n\t}\n\n\t/* Make sure there are pipes for all directions. */\n\tfor (dir = OUT; dir <= IN; dir++) {\n\t\tif (flag & (dir == OUT ? FWRITE : FREAD)) {\n\t\t\tsce = &sc->sc_endpoints[endpt][dir];\n\t\t\tif (sce == 0 || sce->edesc == 0)\n\t\t\t\treturn (ENXIO);\n\t\t}\n\t}\n\n\t/* Actually open the pipes. */\n\t/* XXX Should back out properly if it fails. */\n\tfor (dir = OUT; dir <= IN; dir++) {\n\t\tif (!(flag & (dir == OUT ? FWRITE : FREAD)))\n\t\t\tcontinue;\n\t\tsce = &sc->sc_endpoints[endpt][dir];\n\t\tsce->state = 0;\n\t\tsce->timeout = USBD_NO_TIMEOUT;\n\t\tDPRINTFN(5, (\"ugenopen: sc=%p, endpt=%d, dir=%d, sce=%p\\n\", \n\t\t\t     sc, endpt, dir, sce));\n\t\tedesc = sce->edesc;\n\t\tswitch (edesc->bmAttributes & UE_XFERTYPE) {\n\t\tcase UE_INTERRUPT:\n\t\t\tisize = UGETW(edesc->wMaxPacketSize);\n\t\t\tif (isize == 0)\t/* shouldn't happen */\n\t\t\t\treturn (EINVAL);\n\t\t\tsce->ibuf = malloc(isize, M_USBDEV, M_WAITOK);\n\t\t\tDPRINTFN(5, (\"ugenopen: intr endpt=%d,isize=%d\\n\", \n\t\t\t\t     endpt, isize));\n                        if (clalloc(&sce->q, UGEN_IBSIZE, 0) == -1)\n                                return (ENOMEM);\n\t\t\terr = usbd_open_pipe_intr(sce->iface, \n\t\t\t\t  edesc->bEndpointAddress, \n\t\t\t\t  USBD_SHORT_XFER_OK, &sce->pipeh, sce, \n\t\t\t\t  sce->ibuf, isize, ugenintr, \n\t\t\t\t  USBD_DEFAULT_INTERVAL);\n\t\t\tif (err) {\n\t\t\t\tfree(sce->ibuf, M_USBDEV);\n\t\t\t\tclfree(&sce->q);\n\t\t\t\treturn (EIO);\n\t\t\t}\n\t\t\tDPRINTFN(5, (\"ugenopen: interrupt open done\\n\"));\n\t\t\tbreak;\n\t\tcase UE_BULK:\n\t\t\terr = usbd_open_pipe(sce->iface, \n\t\t\t\t  edesc->bEndpointAddress, 0, &sce->pipeh);\n\t\t\tif (err)\n\t\t\t\treturn (EIO);\n\t\t\tbreak;\n\t\tcase UE_CONTROL:\n\t\tcase UE_ISOCHRONOUS:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\tsc->sc_is_open[endpt] = 1;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define IN  1",
      "#define OUT 0",
      "#define\tUGEN_IBSIZE\t1020\t/* buffer size */"
    ],
    "globals_used": [
      "ugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));",
      "Static usbd_status",
      "ugen_set_interface __P((struct ugen_softc *, int, int));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_open_pipe",
          "args": [
            "sce->iface",
            "edesc->bEndpointAddress",
            "0",
            "&sce->pipeh"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_open_pipe_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "177-222",
          "snippet": "usbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenopen: interrupt open done\\n\")"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clfree",
          "args": [
            "&sce->q"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sce->ibuf",
            "M_USBDEV"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clalloc",
          "args": [
            "&sce->q",
            "UGEN_IBSIZE",
            "0"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenopen: intr endpt=%d,isize=%d\\n\", \n\t\t\t\t     endpt, isize)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "isize",
            "M_USBDEV",
            "M_WAITOK"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "edesc->wMaxPacketSize"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenopen: sc=%p, endpt=%d, dir=%d, sce=%p\\n\", \n\t\t\t     sc, endpt, dir, sce)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"ugenopen: flag=%d, mode=%d, unit=%d endpt=%d\\n\", \n\t\t     flag, mode, unit, endpt)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC_OPEN",
          "args": [
            "ugen",
            "unit",
            "sc"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENENDPOINT",
          "args": [
            "dev"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGENUNIT",
          "args": [
            "dev"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n#define OUT 0\n#define\tUGEN_IBSIZE\t1020\t/* buffer size */\n\nugen_do_ioctl __P((struct ugen_softc *, int, u_long, \n\t\t\t      caddr_t, int, struct proc *));\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\n\nint\nugenopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct ugen_softc *sc;\n\tint unit = UGENUNIT(dev);\n\tint endpt = UGENENDPOINT(dev);\n\tusb_endpoint_descriptor_t *edesc;\n\tstruct ugen_endpoint *sce;\n\tint dir, isize;\n\tusbd_status err;\n\n\tUSB_GET_SC_OPEN(ugen, unit, sc);\n\n \tDPRINTFN(5, (\"ugenopen: flag=%d, mode=%d, unit=%d endpt=%d\\n\", \n\t\t     flag, mode, unit, endpt));\n\n\tif (sc == NULL || sc->sc_dying)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_is_open[endpt])\n\t\treturn (EBUSY);\n\n\tif (endpt == USB_CONTROL_ENDPOINT) {\n\t\tsc->sc_is_open[USB_CONTROL_ENDPOINT] = 1;\n\t\treturn (0);\n\t}\n\n\t/* Make sure there are pipes for all directions. */\n\tfor (dir = OUT; dir <= IN; dir++) {\n\t\tif (flag & (dir == OUT ? FWRITE : FREAD)) {\n\t\t\tsce = &sc->sc_endpoints[endpt][dir];\n\t\t\tif (sce == 0 || sce->edesc == 0)\n\t\t\t\treturn (ENXIO);\n\t\t}\n\t}\n\n\t/* Actually open the pipes. */\n\t/* XXX Should back out properly if it fails. */\n\tfor (dir = OUT; dir <= IN; dir++) {\n\t\tif (!(flag & (dir == OUT ? FWRITE : FREAD)))\n\t\t\tcontinue;\n\t\tsce = &sc->sc_endpoints[endpt][dir];\n\t\tsce->state = 0;\n\t\tsce->timeout = USBD_NO_TIMEOUT;\n\t\tDPRINTFN(5, (\"ugenopen: sc=%p, endpt=%d, dir=%d, sce=%p\\n\", \n\t\t\t     sc, endpt, dir, sce));\n\t\tedesc = sce->edesc;\n\t\tswitch (edesc->bmAttributes & UE_XFERTYPE) {\n\t\tcase UE_INTERRUPT:\n\t\t\tisize = UGETW(edesc->wMaxPacketSize);\n\t\t\tif (isize == 0)\t/* shouldn't happen */\n\t\t\t\treturn (EINVAL);\n\t\t\tsce->ibuf = malloc(isize, M_USBDEV, M_WAITOK);\n\t\t\tDPRINTFN(5, (\"ugenopen: intr endpt=%d,isize=%d\\n\", \n\t\t\t\t     endpt, isize));\n                        if (clalloc(&sce->q, UGEN_IBSIZE, 0) == -1)\n                                return (ENOMEM);\n\t\t\terr = usbd_open_pipe_intr(sce->iface, \n\t\t\t\t  edesc->bEndpointAddress, \n\t\t\t\t  USBD_SHORT_XFER_OK, &sce->pipeh, sce, \n\t\t\t\t  sce->ibuf, isize, ugenintr, \n\t\t\t\t  USBD_DEFAULT_INTERVAL);\n\t\t\tif (err) {\n\t\t\t\tfree(sce->ibuf, M_USBDEV);\n\t\t\t\tclfree(&sce->q);\n\t\t\t\treturn (EIO);\n\t\t\t}\n\t\t\tDPRINTFN(5, (\"ugenopen: interrupt open done\\n\"));\n\t\t\tbreak;\n\t\tcase UE_BULK:\n\t\t\terr = usbd_open_pipe(sce->iface, \n\t\t\t\t  edesc->bEndpointAddress, 0, &sce->pipeh);\n\t\t\tif (err)\n\t\t\t\treturn (EIO);\n\t\t\tbreak;\n\t\tcase UE_CONTROL:\n\t\tcase UE_ISOCHRONOUS:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\tsc->sc_is_open[endpt] = 1;\n\treturn (0);\n}"
  },
  {
    "function_name": "ugen_set_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ugen.c",
    "lines": "218-268",
    "snippet": "Static int\nugen_set_config(sc, configno)\n\tstruct ugen_softc *sc;\n\tint configno;\n{\n\tusbd_device_handle dev = sc->sc_udev;\n\tusbd_interface_handle iface;\n\tusb_endpoint_descriptor_t *ed;\n\tstruct ugen_endpoint *sce;\n\tu_int8_t niface, nendpt;\n\tint ifaceno, endptno, endpt;\n\tusbd_status err;\n\tint dir;\n\n\tDPRINTFN(1,(\"ugen_set_config: %s to configno %d, sc=%p\\n\",\n\t\t    USBDEVNAME(sc->sc_dev), configno, sc));\n\t/* Avoid setting the current value. */\n\tif (usbd_get_config_descriptor(dev)->bConfigurationValue != configno) {\n\t\terr = usbd_set_config_no(dev, configno, 0);\n\t\tif (err)\n\t\t\treturn (err);\n\t}\n\n\terr = usbd_interface_count(dev, &niface);\n\tif (err)\n\t\treturn (err);\n\tmemset(sc->sc_endpoints, 0, sizeof sc->sc_endpoints);\n\tfor (ifaceno = 0; ifaceno < niface; ifaceno++) {\n\t\tDPRINTFN(1,(\"ugen_set_config: ifaceno %d\\n\", ifaceno));\n\t\terr = usbd_device2interface_handle(dev, ifaceno, &iface);\n\t\tif (err)\n\t\t\treturn (err);\n\t\terr = usbd_endpoint_count(iface, &nendpt);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\t\tendpt = ed->bEndpointAddress;\n\t\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\t\tDPRINTFN(1,(\"ugen_set_config: endptno %d, endpt=0x%02x\"\n\t\t\t\t    \"(%d,%d), sce=%p\\n\", \n\t\t\t\t    endptno, endpt, UE_GET_ADDR(endpt),\n\t\t\t\t    UE_GET_DIR(endpt), sce));\n\t\t\tsce->sc = sc;\n\t\t\tsce->edesc = ed;\n\t\t\tsce->iface = iface;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/tty.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define IN  1",
      "#define OUT 0"
    ],
    "globals_used": [
      "Static void",
      "Static int",
      "Static int",
      "Static int",
      "Static int",
      "ugen_set_config __P((struct ugen_softc *sc, int configno));",
      "Static usbd_status",
      "ugen_set_interface __P((struct ugen_softc *, int, int));",
      "Static int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ugen_set_config: endptno %d, endpt=0x%02x\"\n\t\t\t\t    \"(%d,%d), sce=%p\\n\", \n\t\t\t\t    endptno, endpt, UE_GET_ADDR(endpt),\n\t\t\t\t    UE_GET_DIR(endpt), sce)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_DIR",
          "args": [
            "endpt"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_ADDR",
          "args": [
            "endpt"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_ADDR",
          "args": [
            "endpt"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UE_GET_DIR",
          "args": [
            "endpt"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_interface2endpoint_descriptor",
          "args": [
            "iface",
            "endptno"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_endpoint_count",
          "args": [
            "iface",
            "&nendpt"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_endpoint_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "638-645",
          "snippet": "usbd_status \nusbd_endpoint_count(iface, count)\n\tusbd_interface_handle iface;\n\tu_int8_t *count;\n{\n\t*count = iface->idesc->bNumEndpoints;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_endpoint_count(iface, count)\n\tusbd_interface_handle iface;\n\tu_int8_t *count;\n{\n\t*count = iface->idesc->bNumEndpoints;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_device2interface_handle",
          "args": [
            "dev",
            "ifaceno",
            "&iface"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_device2interface_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "667-679",
          "snippet": "usbd_status \nusbd_device2interface_handle(dev, ifaceno, iface)\n\tusbd_device_handle dev;\n\tu_int8_t ifaceno;\n\tusbd_interface_handle *iface;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\tif (ifaceno >= dev->cdesc->bNumInterface)\n\t\treturn (USBD_INVAL);\n\t*iface = &dev->ifaces[ifaceno];\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\n\nusbd_status \nusbd_device2interface_handle(dev, ifaceno, iface)\n\tusbd_device_handle dev;\n\tu_int8_t ifaceno;\n\tusbd_interface_handle *iface;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\tif (ifaceno >= dev->cdesc->bNumInterface)\n\t\treturn (USBD_INVAL);\n\t*iface = &dev->ifaces[ifaceno];\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ugen_set_config: ifaceno %d\\n\", ifaceno)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sc->sc_endpoints",
            "0",
            "sizeof sc->sc_endpoints"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_interface_count",
          "args": [
            "dev",
            "&niface"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_interface_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "647-656",
          "snippet": "usbd_status \nusbd_interface_count(dev, count)\n\tusbd_device_handle dev;\n\tu_int8_t *count;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\t*count = dev->cdesc->bNumInterface;\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_interface_count(dev, count)\n\tusbd_device_handle dev;\n\tu_int8_t *count;\n{\n\tif (dev->cdesc == NULL)\n\t\treturn (USBD_NOT_CONFIGURED);\n\t*count = dev->cdesc->bNumInterface;\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_set_config_no",
          "args": [
            "dev",
            "configno",
            "0"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_config_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "532-552",
          "snippet": "usbd_status\nusbd_set_config_no(dev, no, msg)\n\tusbd_device_handle dev;\n\tint no;\n\tint msg;\n{\n\tint index;\n\tusb_config_descriptor_t cd;\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"usbd_set_config_no: %d\\n\", no));\n\t/* Figure out what config index to use. */\n\tfor (index = 0; index < dev->ddesc.bNumConfigurations; index++) {\n\t\terr = usbd_get_config_desc(dev, index, &cd);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tif (cd.bConfigurationValue == no)\n\t\t\treturn (usbd_set_config_index(dev, index, msg));\n\t}\n\treturn (USBD_INVAL);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static usbd_status",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;",
            "usb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;\nusb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;\n\nusbd_status\nusbd_set_config_no(dev, no, msg)\n\tusbd_device_handle dev;\n\tint no;\n\tint msg;\n{\n\tint index;\n\tusb_config_descriptor_t cd;\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"usbd_set_config_no: %d\\n\", no));\n\t/* Figure out what config index to use. */\n\tfor (index = 0; index < dev->ddesc.bNumConfigurations; index++) {\n\t\terr = usbd_get_config_desc(dev, index, &cd);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tif (cd.bConfigurationValue == no)\n\t\t\treturn (usbd_set_config_index(dev, index, msg));\n\t}\n\treturn (USBD_INVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_get_config_descriptor",
          "args": [
            "dev"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ugen_set_config: %s to configno %d, sc=%p\\n\",\n\t\t    USBDEVNAME(sc->sc_dev), configno, sc)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/tty.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IN  1\n#define OUT 0\n\nStatic void;\nStatic int;\nStatic int;\nStatic int;\nStatic int;\nugen_set_config __P((struct ugen_softc *sc, int configno));\nStatic usbd_status;\nugen_set_interface __P((struct ugen_softc *, int, int));\nStatic int;\n\nStatic int\nugen_set_config(sc, configno)\n\tstruct ugen_softc *sc;\n\tint configno;\n{\n\tusbd_device_handle dev = sc->sc_udev;\n\tusbd_interface_handle iface;\n\tusb_endpoint_descriptor_t *ed;\n\tstruct ugen_endpoint *sce;\n\tu_int8_t niface, nendpt;\n\tint ifaceno, endptno, endpt;\n\tusbd_status err;\n\tint dir;\n\n\tDPRINTFN(1,(\"ugen_set_config: %s to configno %d, sc=%p\\n\",\n\t\t    USBDEVNAME(sc->sc_dev), configno, sc));\n\t/* Avoid setting the current value. */\n\tif (usbd_get_config_descriptor(dev)->bConfigurationValue != configno) {\n\t\terr = usbd_set_config_no(dev, configno, 0);\n\t\tif (err)\n\t\t\treturn (err);\n\t}\n\n\terr = usbd_interface_count(dev, &niface);\n\tif (err)\n\t\treturn (err);\n\tmemset(sc->sc_endpoints, 0, sizeof sc->sc_endpoints);\n\tfor (ifaceno = 0; ifaceno < niface; ifaceno++) {\n\t\tDPRINTFN(1,(\"ugen_set_config: ifaceno %d\\n\", ifaceno));\n\t\terr = usbd_device2interface_handle(dev, ifaceno, &iface);\n\t\tif (err)\n\t\t\treturn (err);\n\t\terr = usbd_endpoint_count(iface, &nendpt);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tfor (endptno = 0; endptno < nendpt; endptno++) {\n\t\t\ted = usbd_interface2endpoint_descriptor(iface,endptno);\n\t\t\tendpt = ed->bEndpointAddress;\n\t\t\tdir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;\n\t\t\tsce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];\n\t\t\tDPRINTFN(1,(\"ugen_set_config: endptno %d, endpt=0x%02x\"\n\t\t\t\t    \"(%d,%d), sce=%p\\n\", \n\t\t\t\t    endptno, endpt, UE_GET_ADDR(endpt),\n\t\t\t\t    UE_GET_DIR(endpt), sce));\n\t\t\tsce->sc = sc;\n\t\t\tsce->edesc = ed;\n\t\t\tsce->iface = iface;\n\t\t}\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  }
]