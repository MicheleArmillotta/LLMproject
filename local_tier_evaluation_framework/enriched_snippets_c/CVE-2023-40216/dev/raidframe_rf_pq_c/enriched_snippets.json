[
  {
    "function_name": "rf_InvertQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "885-924",
    "snippet": "static void \nrf_InvertQ(\n    unsigned long *qbuf,\n    unsigned long *abuf,\n    unsigned length,\n    unsigned coeff)\n{\n\tunsigned long a, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[3 + coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n\t/* 13 5 bit quants in a 64 bit word */\n\tlength /= 8;\n\twhile (length) {\n\t\ta = *qbuf++;\n\t\ta1 = EXTRACT(a, 0);\n\t\ta2 = EXTRACT(a, 1);\n\t\ta1 = r ^ q[a1];\n\t\ta2 = r ^ q[a2];\n\t\tnew = INSERT(a2, 1) | a1;\n#define M(i,j) \\\n      a1 = EXTRACT(a,i); \\\n      a2 = EXTRACT(a,j); \\\n      a1 = r ^ q[a1]; \\\n      a2 = r ^ q[a2]; \\\n      new = new | INSERT(a1,i) | INSERT(a2,j)\n\n\t\tM(2, 3);\n\t\tM(4, 5);\n\t\tM(5, 6);\n#if RF_LONGSHIFT > 2\n\t\tM(7, 8);\n\t\tM(9, 10);\n\t\tM(11, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\t*abuf++ = new;\n\t\tlength--;\n\t}\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "M",
          "args": [
            "11",
            "12"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "rf_MapRegionIDParityLogging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "780-798",
          "snippet": "RF_RegionId_t \nrf_MapRegionIDParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_SectorNum_t address)\n{\n\tRF_RegionId_t regionID;\n\n/*  regionID = address / (raidPtr->regionParityRange * raidPtr->Layout.numDataCol); */\n\tregionID = address / raidPtr->regionParityRange;\n\tif (regionID == rf_numParityRegions) {\n\t\t/* last region may be larger than other regions */\n\t\tregionID--;\n\t}\n\tRF_ASSERT(address >= raidPtr->regionInfo[regionID].parityStartAddr);\n\tRF_ASSERT(address < raidPtr->regionInfo[regionID].parityStartAddr + \n\t\t  raidPtr->regionInfo[regionID].numSectorsParity);\n\tRF_ASSERT(regionID < rf_numParityRegions);\n\treturn (regionID);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nRF_RegionId_t \nrf_MapRegionIDParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_SectorNum_t address)\n{\n\tRF_RegionId_t regionID;\n\n/*  regionID = address / (raidPtr->regionParityRange * raidPtr->Layout.numDataCol); */\n\tregionID = address / raidPtr->regionParityRange;\n\tif (regionID == rf_numParityRegions) {\n\t\t/* last region may be larger than other regions */\n\t\tregionID--;\n\t}\n\tRF_ASSERT(address >= raidPtr->regionInfo[regionID].parityStartAddr);\n\tRF_ASSERT(address < raidPtr->regionInfo[regionID].parityStartAddr + \n\t\t  raidPtr->regionInfo[regionID].numSectorsParity);\n\tRF_ASSERT(regionID < rf_numParityRegions);\n\treturn (regionID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "1"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "1"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "0"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_InvertQ(\n    unsigned long *qbuf,\n    unsigned long *abuf,\n    unsigned length,\n    unsigned coeff)\n{\n\tunsigned long a, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[3 + coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n\t/* 13 5 bit quants in a 64 bit word */\n\tlength /= 8;\n\twhile (length) {\n\t\ta = *qbuf++;\n\t\ta1 = EXTRACT(a, 0);\n\t\ta2 = EXTRACT(a, 1);\n\t\ta1 = r ^ q[a1];\n\t\ta2 = r ^ q[a2];\n\t\tnew = INSERT(a2, 1) | a1;\n#define M(i,j) \\\n      a1 = EXTRACT(a,i); \\\n      a2 = EXTRACT(a,j); \\\n      a1 = r ^ q[a1]; \\\n      a2 = r ^ q[a2]; \\\n      new = new | INSERT(a1,i) | INSERT(a2,j)\n\n\t\tM(2, 3);\n\t\tM(4, 5);\n\t\tM(5, 6);\n#if RF_LONGSHIFT > 2\n\t\tM(7, 8);\n\t\tM(9, 10);\n\t\tM(11, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\t*abuf++ = new;\n\t\tlength--;\n\t}\n}"
  },
  {
    "function_name": "rf_PQ_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "820-864",
    "snippet": "void \nrf_PQ_recover(pbuf, qbuf, abuf, bbuf, length, coeff_a, coeff_b)\n\tunsigned long *pbuf;\n\tunsigned long *qbuf;\n\tunsigned long *abuf;\n\tunsigned long *bbuf;\n\tunsigned length;\n\tunsigned coeff_a;\n\tunsigned coeff_b;\n{\n\tunsigned long p, q, a, a0, a1;\n\tint     col = (29 * coeff_a) + coeff_b;\n\tunsigned char *q0 = &(rf_qinv[col][0]);\n\n\tlength /= 8;\n\twhile (length) {\n\t\tp = *pbuf++;\n\t\tq = *qbuf++;\n\t\ta0 = EXTRACT(p, 0);\n\t\ta1 = EXTRACT(q, 0);\n\t\ta = q0[a0 << 5 | a1];\n#define MF(i) \\\n      a0 = EXTRACT(p,i); \\\n      a1 = EXTRACT(q,i); \\\n      a  = a | INSERT(q0[a0<<5 | a1],i)\n\n\t\tMF(1);\n\t\tMF(2);\n\t\tMF(3);\n\t\tMF(4);\n\t\tMF(5);\n\t\tMF(6);\n#if 0\n\t\tMF(7);\n\t\tMF(8);\n\t\tMF(9);\n\t\tMF(10);\n\t\tMF(11);\n\t\tMF(12);\n#endif\t\t\t\t/* 0 */\n\t\t*abuf++ = a;\n\t\t*bbuf++ = a ^ p;\n\t\tlength--;\n\t}\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "12"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "11"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "10"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "9"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "8"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "7"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "6"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "5"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "4"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "3"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "2"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MF",
          "args": [
            "1"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "q",
            "0"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "p",
            "0"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_PQ_recover(pbuf, qbuf, abuf, bbuf, length, coeff_a, coeff_b)\n\tunsigned long *pbuf;\n\tunsigned long *qbuf;\n\tunsigned long *abuf;\n\tunsigned long *bbuf;\n\tunsigned length;\n\tunsigned coeff_a;\n\tunsigned coeff_b;\n{\n\tunsigned long p, q, a, a0, a1;\n\tint     col = (29 * coeff_a) + coeff_b;\n\tunsigned char *q0 = &(rf_qinv[col][0]);\n\n\tlength /= 8;\n\twhile (length) {\n\t\tp = *pbuf++;\n\t\tq = *qbuf++;\n\t\ta0 = EXTRACT(p, 0);\n\t\ta1 = EXTRACT(q, 0);\n\t\ta = q0[a0 << 5 | a1];\n#define MF(i) \\\n      a0 = EXTRACT(p,i); \\\n      a1 = EXTRACT(q,i); \\\n      a  = a | INSERT(q0[a0<<5 | a1],i)\n\n\t\tMF(1);\n\t\tMF(2);\n\t\tMF(3);\n\t\tMF(4);\n\t\tMF(5);\n\t\tMF(6);\n#if 0\n\t\tMF(7);\n\t\tMF(8);\n\t\tMF(9);\n\t\tMF(10);\n\t\tMF(11);\n\t\tMF(12);\n#endif\t\t\t\t/* 0 */\n\t\t*abuf++ = a;\n\t\t*bbuf++ = a ^ p;\n\t\tlength--;\n\t}\n}"
  },
  {
    "function_name": "QDelta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "737-807",
    "snippet": "static void \nQDelta(\n    char *dest,\n    char *obuf,\n    char *nbuf,\n    unsigned length,\n    unsigned char coeff)\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned int r = rf_rn[coeff + 1];\n\n\tr = a1 = a2 = new = d = a = 0; /* XXX for now... */\n\tq = NULL; /* XXX for now */\n\n#ifdef _KERNEL\n\t/* PQ in kernel currently not supported because the encoding/decoding\n\t * table is not present */\n\tbzero(dest, length);\n#else\t\t\t\t/* _KERNEL */\n\t/* this code probably doesn't work and should be rewritten  -wvcii */\n\t/* 13 5 bit quants in a 64 bit word */\n\tlength /= 8;\n\twhile (length) {\n\t\ta = *obuf++;\t/* XXX need to reorg to avoid cache conflicts */\n\t\ta ^= *nbuf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n#endif\t\t\t\t/* _KERNEL */\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "12"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "11"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "12"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "11"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "10"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "9"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "10"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "9"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "8"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "7"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "8"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "7"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "6"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "5"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "6"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "5"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "5"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "4"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "5"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "4"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "3"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "2"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "3"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "2"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "1"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "1"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "0"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "dest",
            "length"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nQDelta(\n    char *dest,\n    char *obuf,\n    char *nbuf,\n    unsigned length,\n    unsigned char coeff)\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned int r = rf_rn[coeff + 1];\n\n\tr = a1 = a2 = new = d = a = 0; /* XXX for now... */\n\tq = NULL; /* XXX for now */\n\n#ifdef _KERNEL\n\t/* PQ in kernel currently not supported because the encoding/decoding\n\t * table is not present */\n\tbzero(dest, length);\n#else\t\t\t\t/* _KERNEL */\n\t/* this code probably doesn't work and should be rewritten  -wvcii */\n\t/* 13 5 bit quants in a 64 bit word */\n\tlength /= 8;\n\twhile (length) {\n\t\ta = *obuf++;\t/* XXX need to reorg to avoid cache conflicts */\n\t\ta ^= *nbuf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n#endif\t\t\t\t/* _KERNEL */\n}"
  },
  {
    "function_name": "rf_IncQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "666-725",
    "snippet": "void \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "12"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "11"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "12"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "11"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "10"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "9"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "10"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "9"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "8"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "7"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "8"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "7"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "6"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "5"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "6"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "5"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "5"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "4"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "5"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "4"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "3"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a1",
            "2"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "3"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "2"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSERT",
          "args": [
            "a2",
            "1"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "1"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "a",
            "0"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}"
  },
  {
    "function_name": "rf_PQ_DegradedWriteQFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "608-650",
    "snippet": "void \nrf_PQ_DegradedWriteQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *qbuf = node->results[0];\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\tint     fail_start, j;\n\n\told = (RF_PhysDiskAddr_t *) node->params[np - 2].p;\n\tfail_start = old->startSector % secPerSU;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 2) / 2;\n\tRF_ASSERT(2 * d + 2 == np);\n\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\tj = old->startSector % secPerSU;\n\t\tRF_ASSERT(j >= fail_start);\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, j - fail_start);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_IncQ",
          "args": [
            "(unsigned long *) qpbuf",
            "(unsigned long *) obuf",
            "rf_RaidAddressToByte(raidPtr, old->numSector)",
            "coeff"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "rf_IncQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "666-725",
          "snippet": "void \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "old->numSector"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "j - fail_start"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "j >= fail_start"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "old->raidAddress"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "2 * d + 2 == np"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_PQ_DegradedWriteQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *qbuf = node->results[0];\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\tint     fail_start, j;\n\n\told = (RF_PhysDiskAddr_t *) node->params[np - 2].p;\n\tfail_start = old->startSector % secPerSU;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 2) / 2;\n\tRF_ASSERT(2 * d + 2 == np);\n\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\tj = old->startSector % secPerSU;\n\t\tRF_ASSERT(j >= fail_start);\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, j - fail_start);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\n}"
  },
  {
    "function_name": "rf_RecoveryPQFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "587-594",
    "snippet": "int \nrf_RecoveryPQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tprintf(\"raid%d: Recovery from PQ not implemented.\\n\",raidPtr->raidid);\n\treturn (1);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Recovery from PQ not implemented.\\n\"",
            "raidPtr->raidid"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_RecoveryPQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tprintf(\"raid%d: Recovery from PQ not implemented.\\n\",raidPtr->raidid);\n\treturn (1);\n}"
  },
  {
    "function_name": "rf_RecoveryQFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "547-585",
    "snippet": "int \nrf_RecoveryQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tint     i;\n\tRF_PhysDiskAddr_t *pda;\n\tRF_RaidAddr_t suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tunsigned long coeff;\n\n\tRF_ETIMER_START(timer);\n\t/* start by copying Q into the buffer */\n\tbcopy(node->params[node->numParams - 3].p, node->results[0],\n\t    rf_RaidAddressToByte(raidPtr, failedPDA->numSector));\n\tfor (i = 0; i < node->numParams - 4; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != node->results[0]);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), pda->raidAddress);\n\t\t/* compute the data unit offset within the column */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\trf_IncQ((unsigned long *) destbuf, (unsigned long *) srcbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);\n\t}\n\t/* Do the nasty inversion now */\n\tcoeff = (rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), failedPDA->startSector) % raidPtr->Layout.numDataCol);\n\trf_InvertQ(node->results[0], node->results[0], rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_InvertQ",
          "args": [
            "node->results[0]",
            "node->results[0]",
            "rf_RaidAddressToByte(raidPtr, pda->numSector)",
            "coeff"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "rf_InvertQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "885-924",
          "snippet": "static void \nrf_InvertQ(\n    unsigned long *qbuf,\n    unsigned long *abuf,\n    unsigned length,\n    unsigned coeff)\n{\n\tunsigned long a, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[3 + coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n\t/* 13 5 bit quants in a 64 bit word */\n\tlength /= 8;\n\twhile (length) {\n\t\ta = *qbuf++;\n\t\ta1 = EXTRACT(a, 0);\n\t\ta2 = EXTRACT(a, 1);\n\t\ta1 = r ^ q[a1];\n\t\ta2 = r ^ q[a2];\n\t\tnew = INSERT(a2, 1) | a1;\n#define M(i,j) \\\n      a1 = EXTRACT(a,i); \\\n      a2 = EXTRACT(a,j); \\\n      a1 = r ^ q[a1]; \\\n      a2 = r ^ q[a2]; \\\n      new = new | INSERT(a1,i) | INSERT(a2,j)\n\n\t\tM(2, 3);\n\t\tM(4, 5);\n\t\tM(5, 6);\n#if RF_LONGSHIFT > 2\n\t\tM(7, 8);\n\t\tM(9, 10);\n\t\tM(11, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\t*abuf++ = new;\n\t\tlength--;\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_InvertQ(\n    unsigned long *qbuf,\n    unsigned long *abuf,\n    unsigned length,\n    unsigned coeff)\n{\n\tunsigned long a, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[3 + coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n\t/* 13 5 bit quants in a 64 bit word */\n\tlength /= 8;\n\twhile (length) {\n\t\ta = *qbuf++;\n\t\ta1 = EXTRACT(a, 0);\n\t\ta2 = EXTRACT(a, 1);\n\t\ta1 = r ^ q[a1];\n\t\ta2 = r ^ q[a2];\n\t\tnew = INSERT(a2, 1) | a1;\n#define M(i,j) \\\n      a1 = EXTRACT(a,i); \\\n      a2 = EXTRACT(a,j); \\\n      a1 = r ^ q[a1]; \\\n      a2 = r ^ q[a2]; \\\n      new = new | INSERT(a1,i) | INSERT(a2,j)\n\n\t\tM(2, 3);\n\t\tM(4, 5);\n\t\tM(5, 6);\n#if RF_LONGSHIFT > 2\n\t\tM(7, 8);\n\t\tM(9, 10);\n\t\tM(11, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\t*abuf++ = new;\n\t\tlength--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "pda->numSector"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "failedPDA->startSector"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_IncQ",
          "args": [
            "(unsigned long *) destbuf",
            "(unsigned long *) srcbuf",
            "rf_RaidAddressToByte(raidPtr, pda->numSector)",
            "coeff"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "rf_IncQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "666-725",
          "snippet": "void \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "pda->numSector"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "pda->raidAddress"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "suoffset - failedSUOffset"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda->startSector"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->params[i + 1].p != node->results[0]"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "node->params[node->numParams - 3].p",
            "node->results[0]",
            "rf_RaidAddressToByte(raidPtr, failedPDA->numSector)"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "failedPDA->numSector"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "failedPDA->startSector"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_RecoveryQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tint     i;\n\tRF_PhysDiskAddr_t *pda;\n\tRF_RaidAddr_t suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tunsigned long coeff;\n\n\tRF_ETIMER_START(timer);\n\t/* start by copying Q into the buffer */\n\tbcopy(node->params[node->numParams - 3].p, node->results[0],\n\t    rf_RaidAddressToByte(raidPtr, failedPDA->numSector));\n\tfor (i = 0; i < node->numParams - 4; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != node->results[0]);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), pda->raidAddress);\n\t\t/* compute the data unit offset within the column */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\trf_IncQ((unsigned long *) destbuf, (unsigned long *) srcbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);\n\t}\n\t/* Do the nasty inversion now */\n\tcoeff = (rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), failedPDA->startSector) % raidPtr->Layout.numDataCol);\n\trf_InvertQ(node->results[0], node->results[0], rf_RaidAddressToByte(raidPtr, pda->numSector), coeff);\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_Degraded_100_PQFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "504-513",
    "snippet": "void \nrf_Degraded_100_PQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\n\tRF_ASSERT(np >= 2);\n\tDegrQSubr(node);\n\trf_RecoveryXorFunc(node);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RecoveryXorFunc",
          "args": [
            "node"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RecoveryXorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "545-574",
          "snippet": "int \nrf_RecoveryXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tint     i, retcode = 0;\n\tRF_PhysDiskAddr_t *pda;\n\tint     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 2; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\t\t\tretcode = rf_bxor(srcbuf, destbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_RecoveryXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tint     i, retcode = 0;\n\tRF_PhysDiskAddr_t *pda;\n\tint     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 2; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\t\t\tretcode = rf_bxor(srcbuf, destbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DegrQSubr",
          "args": [
            "node"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "DegrQSubr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "405-449",
          "snippet": "static void \nDegrQSubr(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *qbuf = node->results[1];\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\tunsigned fail_start;\n\tint     j;\n\n\told = (RF_PhysDiskAddr_t *) node->params[np - 2].p;\n\tfail_start = old->startSector % secPerSU;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 2) / 2;\n\tRF_ASSERT(2 * d + 2 == np);\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* the input buffers may not all be aligned with the start of\n\t\t * the stripe. so shift by their sector offset within the\n\t\t * stripe unit */\n\t\tj = old->startSector % secPerSU;\n\t\tRF_ASSERT(j >= fail_start);\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, j - fail_start);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nDegrQSubr(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *qbuf = node->results[1];\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\tunsigned fail_start;\n\tint     j;\n\n\told = (RF_PhysDiskAddr_t *) node->params[np - 2].p;\n\tfail_start = old->startSector % secPerSU;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 2) / 2;\n\tRF_ASSERT(2 * d + 2 == np);\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* the input buffers may not all be aligned with the start of\n\t\t * the stripe. so shift by their sector offset within the\n\t\t * stripe unit */\n\t\tj = old->startSector % secPerSU;\n\t\tRF_ASSERT(j >= fail_start);\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, j - fail_start);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "np >= 2"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_Degraded_100_PQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\n\tRF_ASSERT(np >= 2);\n\tDegrQSubr(node);\n\trf_RecoveryXorFunc(node);\n}"
  },
  {
    "function_name": "rf_RegularQFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "475-484",
    "snippet": "int \nrf_RegularQFunc(node)\n\tRF_DagNode_t *node;\n{\n\t/* Almost ... adjust Qsubr args */\n\tRegularQSubr(node, node->results[0]);\n\trf_GenericWakeupFunc(node, 0);\t/* call wake func explicitly since no\n\t\t\t\t\t * I/O in this node */\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RegularQSubr",
          "args": [
            "node",
            "node->results[0]"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "RegularQSubr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "361-398",
          "snippet": "static void \nRegularQSubr(node, qbuf)\n\tRF_DagNode_t *node;\n\tchar   *qbuf;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 1) / 2;\n\tRF_ASSERT(2 * d + 1 == np);\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* the input buffers may not all be aligned with the start of\n\t\t * the stripe. so shift by their sector offset within the\n\t\t * stripe unit */\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, old->startSector % secPerSU);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nRegularQSubr(node, qbuf)\n\tRF_DagNode_t *node;\n\tchar   *qbuf;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 1) / 2;\n\tRF_ASSERT(2 * d + 1 == np);\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* the input buffers may not all be aligned with the start of\n\t\t * the stripe. so shift by their sector offset within the\n\t\t * stripe unit */\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, old->startSector % secPerSU);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_RegularQFunc(node)\n\tRF_DagNode_t *node;\n{\n\t/* Almost ... adjust Qsubr args */\n\tRegularQSubr(node, node->results[0]);\n\trf_GenericWakeupFunc(node, 0);\t/* call wake func explicitly since no\n\t\t\t\t\t * I/O in this node */\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_RegularPQFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "467-473",
    "snippet": "int \nrf_RegularPQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRegularQSubr(node, node->results[1]);\n\treturn (rf_RegularXorFunc(node));\t/* does the wakeup */\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RegularXorFunc",
          "args": [
            "node"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RegularXorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "485-510",
          "snippet": "int \nrf_RegularXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tint     i, retcode;\n\n\tretcode = 0;\n\tif (node->dagHdr->status == rf_enable) {\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,\n\t\t\t\t    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_RegularXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tint     i, retcode;\n\n\tretcode = 0;\n\tif (node->dagHdr->status == rf_enable) {\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,\n\t\t\t\t    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RegularQSubr",
          "args": [
            "node",
            "node->results[1]"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "RegularQSubr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "361-398",
          "snippet": "static void \nRegularQSubr(node, qbuf)\n\tRF_DagNode_t *node;\n\tchar   *qbuf;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 1) / 2;\n\tRF_ASSERT(2 * d + 1 == np);\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* the input buffers may not all be aligned with the start of\n\t\t * the stripe. so shift by their sector offset within the\n\t\t * stripe unit */\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, old->startSector % secPerSU);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nRegularQSubr(node, qbuf)\n\tRF_DagNode_t *node;\n\tchar   *qbuf;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 1) / 2;\n\tRF_ASSERT(2 * d + 1 == np);\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* the input buffers may not all be aligned with the start of\n\t\t * the stripe. so shift by their sector offset within the\n\t\t * stripe unit */\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, old->startSector % secPerSU);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_RegularPQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRegularQSubr(node, node->results[1]);\n\treturn (rf_RegularXorFunc(node));\t/* does the wakeup */\n}"
  },
  {
    "function_name": "DegrQSubr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "405-449",
    "snippet": "static void \nDegrQSubr(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *qbuf = node->results[1];\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\tunsigned fail_start;\n\tint     j;\n\n\told = (RF_PhysDiskAddr_t *) node->params[np - 2].p;\n\tfail_start = old->startSector % secPerSU;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 2) / 2;\n\tRF_ASSERT(2 * d + 2 == np);\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* the input buffers may not all be aligned with the start of\n\t\t * the stripe. so shift by their sector offset within the\n\t\t * stripe unit */\n\t\tj = old->startSector % secPerSU;\n\t\tRF_ASSERT(j >= fail_start);\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, j - fail_start);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_IncQ",
          "args": [
            "(unsigned long *) qpbuf",
            "(unsigned long *) obuf",
            "rf_RaidAddressToByte(raidPtr, old->numSector)",
            "coeff"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "rf_IncQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "666-725",
          "snippet": "void \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "old->numSector"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "j - fail_start"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "j >= fail_start"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "old->raidAddress"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "2 * d + 2 == np"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nDegrQSubr(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *qbuf = node->results[1];\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\tunsigned fail_start;\n\tint     j;\n\n\told = (RF_PhysDiskAddr_t *) node->params[np - 2].p;\n\tfail_start = old->startSector % secPerSU;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 2) / 2;\n\tRF_ASSERT(2 * d + 2 == np);\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* the input buffers may not all be aligned with the start of\n\t\t * the stripe. so shift by their sector offset within the\n\t\t * stripe unit */\n\t\tj = old->startSector % secPerSU;\n\t\tRF_ASSERT(j >= fail_start);\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, j - fail_start);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}"
  },
  {
    "function_name": "RegularQSubr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "361-398",
    "snippet": "static void \nRegularQSubr(node, qbuf)\n\tRF_DagNode_t *node;\n\tchar   *qbuf;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 1) / 2;\n\tRF_ASSERT(2 * d + 1 == np);\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* the input buffers may not all be aligned with the start of\n\t\t * the stripe. so shift by their sector offset within the\n\t\t * stripe unit */\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, old->startSector % secPerSU);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_IncQ",
          "args": [
            "(unsigned long *) qpbuf",
            "(unsigned long *) obuf",
            "rf_RaidAddressToByte(raidPtr, old->numSector)",
            "coeff"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "rf_IncQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "666-725",
          "snippet": "void \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "old->numSector"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "old->startSector % secPerSU"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "old->raidAddress"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "2 * d + 1 == np"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nRegularQSubr(node, qbuf)\n\tRF_DagNode_t *node;\n\tchar   *qbuf;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *obuf, *qpbuf;\n\tRF_PhysDiskAddr_t *old;\n\tunsigned long coeff;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 1) / 2;\n\tRF_ASSERT(2 * d + 1 == np);\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), old->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* the input buffers may not all be aligned with the start of\n\t\t * the stripe. so shift by their sector offset within the\n\t\t * stripe unit */\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, old->startSector % secPerSU);\n\t\trf_IncQ((unsigned long *) qpbuf, (unsigned long *) obuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}"
  },
  {
    "function_name": "rf_SimpleONQFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "311-353",
    "snippet": "int \nrf_SimpleONQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *qbuf;\n\tchar   *obuf, *nbuf;\n\tRF_PhysDiskAddr_t *old, *new;\n\tunsigned long coeff;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 3) / 4;\n\tRF_ASSERT(4 * d + 3 == np);\n\tqbuf = (char *) node->params[2 * d + 1].p;\t/* q buffer */\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tnew = (RF_PhysDiskAddr_t *) node->params[2 * (d + 1 + i)].p;\n\t\tnbuf = (char *) node->params[2 * (d + 1 + i) + 1].p;\n\t\tRF_ASSERT(new->numSector == old->numSector);\n\t\tRF_ASSERT(new->raidAddress == old->raidAddress);\n\t\t/* the stripe unit within the stripe tells us the coefficient\n\t\t * to use for the multiply. */\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), new->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\tQDelta(qbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\t/* call wake func explicitly since no\n\t\t\t\t\t * I/O in this node */\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDelta",
          "args": [
            "qbuf",
            "obuf",
            "nbuf",
            "rf_RaidAddressToByte(raidPtr, old->numSector)",
            "coeff"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "QDelta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "737-807",
          "snippet": "static void \nQDelta(\n    char *dest,\n    char *obuf,\n    char *nbuf,\n    unsigned length,\n    unsigned char coeff)\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned int r = rf_rn[coeff + 1];\n\n\tr = a1 = a2 = new = d = a = 0; /* XXX for now... */\n\tq = NULL; /* XXX for now */\n\n#ifdef _KERNEL\n\t/* PQ in kernel currently not supported because the encoding/decoding\n\t * table is not present */\n\tbzero(dest, length);\n#else\t\t\t\t/* _KERNEL */\n\t/* this code probably doesn't work and should be rewritten  -wvcii */\n\t/* 13 5 bit quants in a 64 bit word */\n\tlength /= 8;\n\twhile (length) {\n\t\ta = *obuf++;\t/* XXX need to reorg to avoid cache conflicts */\n\t\ta ^= *nbuf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n#endif\t\t\t\t/* _KERNEL */\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nQDelta(\n    char *dest,\n    char *obuf,\n    char *nbuf,\n    unsigned length,\n    unsigned char coeff)\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned int r = rf_rn[coeff + 1];\n\n\tr = a1 = a2 = new = d = a = 0; /* XXX for now... */\n\tq = NULL; /* XXX for now */\n\n#ifdef _KERNEL\n\t/* PQ in kernel currently not supported because the encoding/decoding\n\t * table is not present */\n\tbzero(dest, length);\n#else\t\t\t\t/* _KERNEL */\n\t/* this code probably doesn't work and should be rewritten  -wvcii */\n\t/* 13 5 bit quants in a 64 bit word */\n\tlength /= 8;\n\twhile (length) {\n\t\ta = *obuf++;\t/* XXX need to reorg to avoid cache conflicts */\n\t\ta ^= *nbuf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n#endif\t\t\t\t/* _KERNEL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "old->numSector"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "new->raidAddress"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "new->raidAddress == old->raidAddress"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "new->numSector == old->numSector"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "4 * d + 3 == np"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_SimpleONQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *qbuf;\n\tchar   *obuf, *nbuf;\n\tRF_PhysDiskAddr_t *old, *new;\n\tunsigned long coeff;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 3) / 4;\n\tRF_ASSERT(4 * d + 3 == np);\n\tqbuf = (char *) node->params[2 * d + 1].p;\t/* q buffer */\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tnew = (RF_PhysDiskAddr_t *) node->params[2 * (d + 1 + i)].p;\n\t\tnbuf = (char *) node->params[2 * (d + 1 + i) + 1].p;\n\t\tRF_ASSERT(new->numSector == old->numSector);\n\t\tRF_ASSERT(new->raidAddress == old->raidAddress);\n\t\t/* the stripe unit within the stripe tells us the coefficient\n\t\t * to use for the multiply. */\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), new->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\tQDelta(qbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\t/* call wake func explicitly since no\n\t\t\t\t\t * I/O in this node */\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_RegularONQFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "246-290",
    "snippet": "int \nrf_RegularONQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *qbuf, *qpbuf;\n\tchar   *obuf, *nbuf;\n\tRF_PhysDiskAddr_t *old, *new;\n\tunsigned long coeff;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 3) / 4;\n\tRF_ASSERT(4 * d + 3 == np);\n\tqbuf = (char *) node->params[2 * d + 1].p;\t/* q buffer */\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tnew = (RF_PhysDiskAddr_t *) node->params[2 * (d + 1 + i)].p;\n\t\tnbuf = (char *) node->params[2 * (d + 1 + i) + 1].p;\n\t\tRF_ASSERT(new->numSector == old->numSector);\n\t\tRF_ASSERT(new->raidAddress == old->raidAddress);\n\t\t/* the stripe unit within the stripe tells us the coefficient\n\t\t * to use for the multiply. */\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), new->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, old->startSector % secPerSU);\n\t\tQDelta(qpbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\t/* call wake func explicitly since no\n\t\t\t\t\t * I/O in this node */\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QDelta",
          "args": [
            "qpbuf",
            "obuf",
            "nbuf",
            "rf_RaidAddressToByte(raidPtr, old->numSector)",
            "coeff"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "QDelta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "737-807",
          "snippet": "static void \nQDelta(\n    char *dest,\n    char *obuf,\n    char *nbuf,\n    unsigned length,\n    unsigned char coeff)\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned int r = rf_rn[coeff + 1];\n\n\tr = a1 = a2 = new = d = a = 0; /* XXX for now... */\n\tq = NULL; /* XXX for now */\n\n#ifdef _KERNEL\n\t/* PQ in kernel currently not supported because the encoding/decoding\n\t * table is not present */\n\tbzero(dest, length);\n#else\t\t\t\t/* _KERNEL */\n\t/* this code probably doesn't work and should be rewritten  -wvcii */\n\t/* 13 5 bit quants in a 64 bit word */\n\tlength /= 8;\n\twhile (length) {\n\t\ta = *obuf++;\t/* XXX need to reorg to avoid cache conflicts */\n\t\ta ^= *nbuf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n#endif\t\t\t\t/* _KERNEL */\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nQDelta(\n    char *dest,\n    char *obuf,\n    char *nbuf,\n    unsigned length,\n    unsigned char coeff)\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned int r = rf_rn[coeff + 1];\n\n\tr = a1 = a2 = new = d = a = 0; /* XXX for now... */\n\tq = NULL; /* XXX for now */\n\n#ifdef _KERNEL\n\t/* PQ in kernel currently not supported because the encoding/decoding\n\t * table is not present */\n\tbzero(dest, length);\n#else\t\t\t\t/* _KERNEL */\n\t/* this code probably doesn't work and should be rewritten  -wvcii */\n\t/* 13 5 bit quants in a 64 bit word */\n\tlength /= 8;\n\twhile (length) {\n\t\ta = *obuf++;\t/* XXX need to reorg to avoid cache conflicts */\n\t\ta ^= *nbuf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n#endif\t\t\t\t/* _KERNEL */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "old->numSector"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "old->startSector % secPerSU"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "new->raidAddress"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "new->raidAddress == old->raidAddress"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "new->numSector == old->numSector"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "4 * d + 3 == np"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_RegularONQFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tint     d;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 1].p;\n\tint     i;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tchar   *qbuf, *qpbuf;\n\tchar   *obuf, *nbuf;\n\tRF_PhysDiskAddr_t *old, *new;\n\tunsigned long coeff;\n\tunsigned secPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\n\tRF_ETIMER_START(timer);\n\n\td = (np - 3) / 4;\n\tRF_ASSERT(4 * d + 3 == np);\n\tqbuf = (char *) node->params[2 * d + 1].p;\t/* q buffer */\n\tfor (i = 0; i < d; i++) {\n\t\told = (RF_PhysDiskAddr_t *) node->params[2 * i].p;\n\t\tobuf = (char *) node->params[2 * i + 1].p;\n\t\tnew = (RF_PhysDiskAddr_t *) node->params[2 * (d + 1 + i)].p;\n\t\tnbuf = (char *) node->params[2 * (d + 1 + i) + 1].p;\n\t\tRF_ASSERT(new->numSector == old->numSector);\n\t\tRF_ASSERT(new->raidAddress == old->raidAddress);\n\t\t/* the stripe unit within the stripe tells us the coefficient\n\t\t * to use for the multiply. */\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), new->raidAddress);\n\t\t/* compute the data unit offset within the column, then add\n\t\t * one */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\tqpbuf = qbuf + rf_RaidAddressToByte(raidPtr, old->startSector % secPerSU);\n\t\tQDelta(qpbuf, obuf, nbuf, rf_RaidAddressToByte(raidPtr, old->numSector), coeff);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\t/* call wake func explicitly since no\n\t\t\t\t\t * I/O in this node */\n\treturn (0);\n}"
  },
  {
    "function_name": "PQOneTwo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "228-237",
    "snippet": "static void \nPQOneTwo(raidPtr, nSucc, nAnte, asmap)\n\tRF_Raid_t *raidPtr;\n\tint    *nSucc;\n\tint    *nAnte;\n\tRF_AccessStripeMap_t *asmap;\n{\n\t*nSucc = 1;\n\t*nAnte = 2;\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nPQOneTwo(raidPtr, nSucc, nAnte, asmap)\n\tRF_Raid_t *raidPtr;\n\tint    *nSucc;\n\tint    *nAnte;\n\tRF_AccessStripeMap_t *asmap;\n{\n\t*nSucc = 1;\n\t*nAnte = 2;\n}"
  },
  {
    "function_name": "PQOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "218-226",
    "snippet": "static void \nPQOne(raidPtr, nSucc, nAnte, asmap)\n\tRF_Raid_t *raidPtr;\n\tint    *nSucc;\n\tint    *nAnte;\n\tRF_AccessStripeMap_t *asmap;\n{\n\t*nSucc = *nAnte = 1;\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nPQOne(raidPtr, nSucc, nAnte, asmap)\n\tRF_Raid_t *raidPtr;\n\tint    *nSucc;\n\tint    *nAnte;\n\tRF_AccessStripeMap_t *asmap;\n{\n\t*nSucc = *nAnte = 1;\n}"
  },
  {
    "function_name": "rf_PQDagSelect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "96-213",
    "snippet": "void \nrf_PQDagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmap,\n    RF_VoidFuncPtr * createFunc)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tunsigned ndfail = asmap->numDataFailed;\n\tunsigned npfail = asmap->numParityFailed;\n\tunsigned ntfail = npfail + ndfail;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\tif (ntfail > 2) {\n\t\tRF_ERRORMSG(\"more than two disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t /* *infoFunc = */ *createFunc = NULL;\n\t\treturn;\n\t}\n\t/* ok, we can do this I/O */\n\tif (type == RF_IO_TYPE_READ) {\n\t\tswitch (ndfail) {\n\t\tcase 0:\n\t\t\t/* fault free read */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;\t/* same as raid 5 */\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* lost a single data unit */\n\t\t\t/* two cases: (1) parity is not lost. do a normal raid\n\t\t\t * 5 reconstruct read. (2) parity is lost. do a\n\t\t\t * reconstruct read using \"q\". */\n\t\t\tif (ntfail == 2) {\t/* also lost redundancy */\n\t\t\t\tif (asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY)\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_110_CreateReadDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_101_CreateReadDAG;\n\t\t\t} else {\n\t\t\t\t/* P and Q are ok. But is there a failure in\n\t\t\t\t * some unaccessed data unit? */\n\t\t\t\tif (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateReadDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_100_CreateReadDAG;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* lost two data units */\n\t\t\t/* *infoFunc = PQOneTwo; */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateReadDAG;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\t/* a write */\n\tswitch (ntfail) {\n\tcase 0:\t\t/* fault free */\n\t\tif (rf_suppressLocksAndLargeWrites ||\n\t\t    (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||\n\t\t\t(asmap->parityInfo->next != NULL) || (asmap->qInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {\n\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQCreateSmallWriteDAG;\n\t\t} else {\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQCreateLargeWriteDAG;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\t\t/* single disk fault */\n\t\tif (npfail == 1) {\n\t\t\tRF_ASSERT((asmap->failedPDAs[0]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));\n\t\t\tif (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {\t/* q died, treat like\n\t\t\t\t\t\t\t\t\t\t * normal mode raid5\n\t\t\t\t\t\t\t\t\t\t * write. */\n\t\t\t\tif (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))\n\t\t\t\t    || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_001_CreateSmallWriteDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_001_CreateLargeWriteDAG;\n\t\t\t} else {/* parity died, small write only updating Q */\n\t\t\t\tif (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))\n\t\t\t\t    || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_010_CreateSmallWriteDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_010_CreateLargeWriteDAG;\n\t\t\t}\n\t\t} else {\t/* data missing. Do a P reconstruct write if\n\t\t\t\t * only a single data unit is lost in the\n\t\t\t\t * stripe, otherwise a PQ reconstruct write. */\n\t\t\tif (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateWriteDAG;\n\t\t\telse\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_100_CreateWriteDAG;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\t\t/* two disk faults */\n\t\tswitch (npfail) {\n\t\tcase 2:\t/* both p and q dead */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_011_CreateWriteDAG;\n\t\t\tbreak;\n\t\tcase 1:\t/* either p or q and dead data */\n\t\t\tRF_ASSERT(asmap->failedPDAs[0]->type == RF_PDA_TYPE_DATA);\n\t\t\tRF_ASSERT((asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));\n\t\t\tif (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q)\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_101_CreateWriteDAG;\n\t\t\telse\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_110_CreateWriteDAG;\n\t\t\tbreak;\n\t\tcase 0:\t/* double data loss */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateWriteDAG;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\t\t/* more than 2 disk faults */\n\t\t*createFunc = NULL;\n\t\tRF_PANIC();\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "(asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "asmap->failedPDAs[0]->type == RF_PDA_TYPE_DATA"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_NumFailedDataUnitsInStripe",
          "args": [
            "raidPtr",
            "asmap"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "rf_NumFailedDataUnitsInStripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "660-689",
          "snippet": "int \nrf_NumFailedDataUnitsInStripe(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t trow, tcol, row, i;\n\tRF_SectorNum_t diskOffset;\n\tRF_RaidAddr_t sosAddr;\n\tint     numFailures;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\tnumFailures = 0;\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\tfor (i = 0; i < layoutPtr->numDataCol; i++) {\n\t\t(layoutPtr->map->MapSector) (raidPtr, sosAddr + i * layoutPtr->sectorsPerStripeUnit,\n\t\t    &trow, &tcol, &diskOffset, 0);\n\t\tif (RF_DEAD_DISK(raidPtr->Disks[trow][tcol].status))\n\t\t\tnumFailures++;\n\t}\n\n\treturn numFailures;\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
            "RF_RaidAddr_t raidAddress;",
            "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_RaidAddr_t raidAddress;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nint \nrf_NumFailedDataUnitsInStripe(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t trow, tcol, row, i;\n\tRF_SectorNum_t diskOffset;\n\tRF_RaidAddr_t sosAddr;\n\tint     numFailures;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\tnumFailures = 0;\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\tfor (i = 0; i < layoutPtr->numDataCol; i++) {\n\t\t(layoutPtr->map->MapSector) (raidPtr, sosAddr + i * layoutPtr->sectorsPerStripeUnit,\n\t\t    &trow, &tcol, &diskOffset, 0);\n\t\tif (RF_DEAD_DISK(raidPtr->Disks[trow][tcol].status))\n\t\t\tnumFailures++;\n\t}\n\n\treturn numFailures;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "(asmap->failedPDAs[0]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckStripeForFailures",
          "args": [
            "raidPtr",
            "asmap"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckStripeForFailures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "608-655",
          "snippet": "int \nrf_CheckStripeForFailures(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t trow, tcol, prow, pcol, *diskids, row, i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t stripeOffset;\n\tint     numFailures;\n\tRF_RaidAddr_t sosAddr;\n\tRF_SectorNum_t diskOffset, poffset;\n\tRF_RowCol_t testrow;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &testrow);\n\t(layoutPtr->map->MapParity) (raidPtr, asmap->raidAddress, &prow, &pcol, &poffset, 0);\t/* get pcol */\n\n\t/* this need not be true if we've redirected the access to a spare in\n\t * another row RF_ASSERT(row == testrow); */\n\tstripeOffset = 0;\n\tfor (i = 0; i < layoutPtr->numDataCol + layoutPtr->numParityCol; i++) {\n\t\tif (diskids[i] != pcol) {\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[testrow][diskids[i]].status)) {\n\t\t\t\tif (raidPtr->status[testrow] != rf_rs_reconstructing)\n\t\t\t\t\treturn (1);\n\t\t\t\tRF_ASSERT(raidPtr->reconControl[testrow]->fcol == diskids[i]);\n\t\t\t\tlayoutPtr->map->MapSector(raidPtr,\n\t\t\t\t    sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit,\n\t\t\t\t    &trow, &tcol, &diskOffset, 0);\n\t\t\t\tRF_ASSERT((trow == testrow) && (tcol == diskids[i]));\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[testrow]->reconMap, diskOffset))\n\t\t\t\t\treturn (1);\n\t\t\t\tasmap->flags |= RF_ASM_REDIR_LARGE_WRITE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tstripeOffset++;\n\t\t}\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
            "RF_RaidAddr_t raidAddress;",
            "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_RaidAddr_t raidAddress;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nint \nrf_CheckStripeForFailures(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t trow, tcol, prow, pcol, *diskids, row, i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t stripeOffset;\n\tint     numFailures;\n\tRF_RaidAddr_t sosAddr;\n\tRF_SectorNum_t diskOffset, poffset;\n\tRF_RowCol_t testrow;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &testrow);\n\t(layoutPtr->map->MapParity) (raidPtr, asmap->raidAddress, &prow, &pcol, &poffset, 0);\t/* get pcol */\n\n\t/* this need not be true if we've redirected the access to a spare in\n\t * another row RF_ASSERT(row == testrow); */\n\tstripeOffset = 0;\n\tfor (i = 0; i < layoutPtr->numDataCol + layoutPtr->numParityCol; i++) {\n\t\tif (diskids[i] != pcol) {\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[testrow][diskids[i]].status)) {\n\t\t\t\tif (raidPtr->status[testrow] != rf_rs_reconstructing)\n\t\t\t\t\treturn (1);\n\t\t\t\tRF_ASSERT(raidPtr->reconControl[testrow]->fcol == diskids[i]);\n\t\t\t\tlayoutPtr->map->MapSector(raidPtr,\n\t\t\t\t    sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit,\n\t\t\t\t    &trow, &tcol, &diskOffset, 0);\n\t\t\t\tRF_ASSERT((trow == testrow) && (tcol == diskids[i]));\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[testrow]->reconMap, diskOffset))\n\t\t\t\t\treturn (1);\n\t\t\t\tasmap->flags |= RF_ASM_REDIR_LARGE_WRITE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tstripeOffset++;\n\t\t}\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"more than two disks failed in a single group!  Aborting I/O operation.\\n\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_IO_IS_R_OR_W(type)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_IO_IS_R_OR_W",
          "args": [
            "type"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_PQDagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmap,\n    RF_VoidFuncPtr * createFunc)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tunsigned ndfail = asmap->numDataFailed;\n\tunsigned npfail = asmap->numParityFailed;\n\tunsigned ntfail = npfail + ndfail;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\tif (ntfail > 2) {\n\t\tRF_ERRORMSG(\"more than two disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t /* *infoFunc = */ *createFunc = NULL;\n\t\treturn;\n\t}\n\t/* ok, we can do this I/O */\n\tif (type == RF_IO_TYPE_READ) {\n\t\tswitch (ndfail) {\n\t\tcase 0:\n\t\t\t/* fault free read */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;\t/* same as raid 5 */\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* lost a single data unit */\n\t\t\t/* two cases: (1) parity is not lost. do a normal raid\n\t\t\t * 5 reconstruct read. (2) parity is lost. do a\n\t\t\t * reconstruct read using \"q\". */\n\t\t\tif (ntfail == 2) {\t/* also lost redundancy */\n\t\t\t\tif (asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY)\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_110_CreateReadDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_101_CreateReadDAG;\n\t\t\t} else {\n\t\t\t\t/* P and Q are ok. But is there a failure in\n\t\t\t\t * some unaccessed data unit? */\n\t\t\t\tif (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateReadDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_100_CreateReadDAG;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* lost two data units */\n\t\t\t/* *infoFunc = PQOneTwo; */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateReadDAG;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\t/* a write */\n\tswitch (ntfail) {\n\tcase 0:\t\t/* fault free */\n\t\tif (rf_suppressLocksAndLargeWrites ||\n\t\t    (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||\n\t\t\t(asmap->parityInfo->next != NULL) || (asmap->qInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {\n\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQCreateSmallWriteDAG;\n\t\t} else {\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQCreateLargeWriteDAG;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\t\t/* single disk fault */\n\t\tif (npfail == 1) {\n\t\t\tRF_ASSERT((asmap->failedPDAs[0]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));\n\t\t\tif (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {\t/* q died, treat like\n\t\t\t\t\t\t\t\t\t\t * normal mode raid5\n\t\t\t\t\t\t\t\t\t\t * write. */\n\t\t\t\tif (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))\n\t\t\t\t    || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_001_CreateSmallWriteDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_001_CreateLargeWriteDAG;\n\t\t\t} else {/* parity died, small write only updating Q */\n\t\t\t\tif (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))\n\t\t\t\t    || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_010_CreateSmallWriteDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_010_CreateLargeWriteDAG;\n\t\t\t}\n\t\t} else {\t/* data missing. Do a P reconstruct write if\n\t\t\t\t * only a single data unit is lost in the\n\t\t\t\t * stripe, otherwise a PQ reconstruct write. */\n\t\t\tif (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateWriteDAG;\n\t\t\telse\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_100_CreateWriteDAG;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\t\t/* two disk faults */\n\t\tswitch (npfail) {\n\t\tcase 2:\t/* both p and q dead */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_011_CreateWriteDAG;\n\t\t\tbreak;\n\t\tcase 1:\t/* either p or q and dead data */\n\t\t\tRF_ASSERT(asmap->failedPDAs[0]->type == RF_PDA_TYPE_DATA);\n\t\t\tRF_ASSERT((asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));\n\t\t\tif (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q)\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_101_CreateWriteDAG;\n\t\t\telse\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_110_CreateWriteDAG;\n\t\t\tbreak;\n\t\tcase 0:\t/* double data loss */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_PQ_200_CreateWriteDAG;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\t\t/* more than 2 disk faults */\n\t\t*createFunc = NULL;\n\t\tRF_PANIC();\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "rf_RegularPFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "77-82",
    "snippet": "int \nrf_RegularPFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (rf_RegularXorFunc(node));\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RegularXorFunc",
          "args": [
            "node"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RegularXorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "485-510",
          "snippet": "int \nrf_RegularXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tint     i, retcode;\n\n\tretcode = 0;\n\tif (node->dagHdr->status == rf_enable) {\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,\n\t\t\t\t    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_RegularXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tint     i, retcode;\n\n\tretcode = 0;\n\tif (node->dagHdr->status == rf_enable) {\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,\n\t\t\t\t    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_RegularPFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (rf_RegularXorFunc(node));\n}"
  },
  {
    "function_name": "rf_RecoveryPFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "70-75",
    "snippet": "int \nrf_RecoveryPFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (rf_RecoveryXorFunc(node));\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RecoveryXorFunc",
          "args": [
            "node"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RecoveryXorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "545-574",
          "snippet": "int \nrf_RecoveryXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tint     i, retcode = 0;\n\tRF_PhysDiskAddr_t *pda;\n\tint     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 2; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\t\t\tretcode = rf_bxor(srcbuf, destbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_RecoveryXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tint     i, retcode = 0;\n\tRF_PhysDiskAddr_t *pda;\n\tint     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 2; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\t\t\tretcode = rf_bxor(srcbuf, destbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_RecoveryPFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (rf_RecoveryXorFunc(node));\n}"
  },
  {
    "function_name": "rf_SimpleONPFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "63-68",
    "snippet": "int \nrf_SimpleONPFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (rf_SimpleXorFunc(node));\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_SimpleXorFunc",
          "args": [
            "node"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "rf_SimpleXorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "512-537",
          "snippet": "int \nrf_SimpleXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tint     i, retcode = 0;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_bxor((char *) node->params[i + 1].p, (char *) node->results[0],\n\t\t\t\t    rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[i].p)->numSector),\n\t\t\t\t    (struct buf *) node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_SimpleXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tint     i, retcode = 0;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_bxor((char *) node->params[i + 1].p, (char *) node->results[0],\n\t\t\t\t    rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[i].p)->numSector),\n\t\t\t\t    (struct buf *) node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_SimpleONPFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (rf_SimpleXorFunc(node));\n}"
  },
  {
    "function_name": "rf_RegularONPFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
    "lines": "53-58",
    "snippet": "int \nrf_RegularONPFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (rf_RegularXorFunc(node));\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_pqdeg.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RegularXorFunc",
          "args": [
            "node"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RegularXorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "485-510",
          "snippet": "int \nrf_RegularXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tint     i, retcode;\n\n\tretcode = 0;\n\tif (node->dagHdr->status == rf_enable) {\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,\n\t\t\t\t    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_RegularXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tint     i, retcode;\n\n\tretcode = 0;\n\tif (node->dagHdr->status == rf_enable) {\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,\n\t\t\t\t    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_RegularONPFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (rf_RegularXorFunc(node));\n}"
  }
]