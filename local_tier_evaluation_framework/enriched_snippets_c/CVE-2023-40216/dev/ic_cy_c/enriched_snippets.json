[
  {
    "function_name": "cy_speed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "1443-1461",
    "snippet": "int\ncy_speed(speed_t speed, int *cor, int *bpr)\n{\n    int c, co, br;\n\n    if(speed < 50 || speed > 150000)\n      return -1;\n\n    for(c = 0, co = 8; co <= 2048; co <<= 2, c++) {\n\tbr = (CY_CLOCK + (co * speed) / 2) / (co * speed);\n\tif(br < 0x100) {\n\t    *bpr = br;\n\t    *cor = c;\n\t    return 0;\n\t}\n    }\n\n    return -1;\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_speed(speed_t speed, int *cor, int *bpr)\n{\n    int c, co, br;\n\n    if(speed < 50 || speed > 150000)\n      return -1;\n\n    for(c = 0, co = 8; co <= 2048; co <<= 2, c++) {\n\tbr = (CY_CLOCK + (co * speed) / 2) / (co * speed);\n\tif(br < 0x100) {\n\t    *bpr = br;\n\t    *cor = c;\n\t    return 0;\n\t}\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "cd1400_channel_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "1414-1433",
    "snippet": "void\ncd1400_channel_cmd(cy, cmd)\n     struct cy_port *cy;\n     int cmd;\n{\n    u_int waitcnt = 5 * 8 * 1024; /* approx 5 ms */\n\n#ifdef CY_DEBUG\n    printf(\"c1400_channel_cmd cy 0x%x command 0x%x\\n\", cy, cmd);\n#endif\n\n    /* wait until cd1400 is ready to process a new command */\n    while(cd_read_reg(cy, CD1400_CCR) != 0 && waitcnt-- > 0)\n      ;\n\n    if(waitcnt == 0)\n      log(LOG_ERR, \"cy: channel command timeout\\n\");\n\n    cd_write_reg(cy, CD1400_CCR, cmd);\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_CCR",
            "cmd"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"cy: channel command timeout\\n\""
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "pdq_read_error_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/pdq.c",
          "lines": "324-340",
          "snippet": "static pdq_boolean_t\npdq_read_error_log(\n    pdq_t *pdq,\n    pdq_response_error_log_get_t *log_entry)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_uint32_t *ptr = (pdq_uint32_t *) log_entry;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_ERROR_LOG_START);\n\n    while (pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ) == PDQ_TRUE) {\n\t*ptr++ = PDQ_CSR_READ(csrs, csr_host_data);\n\tif ((pdq_uint8_t *) ptr - (pdq_uint8_t *) log_entry == sizeof(*log_entry))\n\t    break;\n    }\n    return (ptr == (pdq_uint32_t *) log_entry) ? PDQ_FALSE : PDQ_TRUE;\n}",
          "includes": [
            "#include \"pdqreg.h\"",
            "#include \"pdqvar.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pdqreg.h\"\n#include \"pdqvar.h\"\n\nstatic pdq_boolean_t\npdq_read_error_log(\n    pdq_t *pdq,\n    pdq_response_error_log_get_t *log_entry)\n{\n    const pdq_csrs_t * const csrs = &pdq->pdq_csrs;\n    pdq_uint32_t *ptr = (pdq_uint32_t *) log_entry;\n\n    pdq_do_port_control(csrs, PDQ_PCTL_ERROR_LOG_START);\n\n    while (pdq_do_port_control(csrs, PDQ_PCTL_FW_REV_READ) == PDQ_TRUE) {\n\t*ptr++ = PDQ_CSR_READ(csrs, csr_host_data);\n\tif ((pdq_uint8_t *) ptr - (pdq_uint8_t *) log_entry == sizeof(*log_entry))\n\t    break;\n    }\n    return (ptr == (pdq_uint32_t *) log_entry) ? PDQ_FALSE : PDQ_TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_CCR"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"c1400_channel_cmd cy 0x%x command 0x%x\\n\"",
            "cy",
            "cmd"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nvoid\ncd1400_channel_cmd(cy, cmd)\n     struct cy_port *cy;\n     int cmd;\n{\n    u_int waitcnt = 5 * 8 * 1024; /* approx 5 ms */\n\n#ifdef CY_DEBUG\n    printf(\"c1400_channel_cmd cy 0x%x command 0x%x\\n\", cy, cmd);\n#endif\n\n    /* wait until cd1400 is ready to process a new command */\n    while(cd_read_reg(cy, CD1400_CCR) != 0 && waitcnt-- > 0)\n      ;\n\n    if(waitcnt == 0)\n      log(LOG_ERR, \"cy: channel command timeout\\n\");\n\n    cd_write_reg(cy, CD1400_CCR, cmd);\n}"
  },
  {
    "function_name": "cy_enable_transmitter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "1399-1409",
    "snippet": "void\ncy_enable_transmitter(cy)\n     struct cy_port *cy;\n{\n    int s;\n    s = splhigh();\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n    cd_write_reg(cy, CD1400_SRER, cd_read_reg(cy, CD1400_SRER)\n\t\t | CD1400_SRER_TXRDY);\n    splx(s);\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_SRER",
            "cd_read_reg(cy, CD1400_SRER)\n\t\t | CD1400_SRER_TXRDY"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_SRER"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_CAR",
            "cy->cy_port_num & CD1400_CAR_CHAN"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nvoid\ncy_enable_transmitter(cy)\n     struct cy_port *cy;\n{\n    int s;\n    s = splhigh();\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n    cd_write_reg(cy, CD1400_SRER, cd_read_reg(cy, CD1400_SRER)\n\t\t | CD1400_SRER_TXRDY);\n    splx(s);\n}"
  },
  {
    "function_name": "cyintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "1152-1394",
    "snippet": "int\ncyintr(arg)\n     void *arg;\n{\n    struct cy_softc *sc = arg;\n    struct cy_port *cy;\n    int card = sc->sc_dev.dv_unit;\n    int cy_chip, stat;\n    int int_serviced = 0;\n\n/*\n * Check interrupt status of each CD1400 chip on this card\n * (multiple cards cannot share the same interrupt)\n */\n    for(cy_chip = 0; cy_chip < cy_nr_cd1400s[card]; cy_chip++) {\n\n\tstat = cd_read_reg_sc(sc, cy_chip, CD1400_SVRR);\n\tif(stat == 0)\n\t  continue;\n\n\tif(ISSET(stat, CD1400_SVRR_RXRDY)) {\n\t    u_char save_car, save_rir, serv_type;\n\t    u_char line_stat, recv_data, n_chars;\n\t    u_char *buf_p;\n\n\t    save_rir = cd_read_reg_sc(sc, cy_chip, CD1400_RIR);\n\t    save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);\n\t    /* enter rx service */\n\t    cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_rir);\n\n\t    serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_RIVR);\n\t    cy = &sc->sc_ports[serv_type >> 3];\n\n#ifdef CY_DEBUG1\n\t    cy->cy_rx_int_count++;\n#endif\n\n\t    if(cy->cy_tty == NULL ||\n\t       !ISSET(cy->cy_tty->t_state, TS_ISOPEN))\n\t      goto end_rx_serv;\n\n\t    buf_p = cy->cy_ibuf_wr_ptr;\n\n\t    if(ISSET(serv_type, CD1400_RIVR_EXCEPTION)) {\n\t\tline_stat = cd_read_reg(cy, CD1400_RDSR);\n\t\trecv_data = cd_read_reg(cy, CD1400_RDSR);\n\n#ifdef CY_DEBUG\n\t\tprintf(\"cy%d port %d recv exception, \"\n\t\t       \"line_stat 0x%x, char 0x%x\\n\",\n\t\t       card, cy->cy_port_num, line_stat, recv_data);\n#endif\n\t\tif(ISSET(line_stat, CD1400_RDSR_OE))\n\t\t  cy->cy_fifo_overruns++;\n\n\t\t*buf_p++ = line_stat;\n\t\t*buf_p++ = recv_data;\n\t\tif(buf_p == cy->cy_ibuf_end)\n\t\t  buf_p = cy->cy_ibuf;\n\n\t\tif(buf_p == cy->cy_ibuf_rd_ptr) {\n\t\t    if(buf_p == cy->cy_ibuf)\n\t\t      buf_p = cy->cy_ibuf_end;\n\t\t    buf_p -= 2;\n\t\t    cy->cy_ibuf_overruns++;\n\t\t}\n\t\tcy_events = 1;\n\t    } else { /* no exception, received data OK */\n\t\tn_chars = cd_read_reg(cy, CD1400_RDCR);\n#ifdef CY_DEBUG\n\t\tprintf(\"cy%d port %d receive ok %d chars\\n\",\n\t\t       card, cy->cy_port_num, n_chars);\n#endif\n\t\twhile(n_chars--) {\n\t\t    *buf_p++ = 0; /* status: OK */\n\t\t    *buf_p++ =\n\t\t      cd_read_reg(cy, CD1400_RDSR); /* data byte */\n\t\t    if(buf_p == cy->cy_ibuf_end)\n\t\t      buf_p = cy->cy_ibuf;\n\t\t    if(buf_p == cy->cy_ibuf_rd_ptr) {\n\t\t\tif(buf_p == cy->cy_ibuf)\n\t\t\t  buf_p = cy->cy_ibuf_end;\n\t\t\tbuf_p -= 2;\n\t\t\tcy->cy_ibuf_overruns++;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tcy_events = 1;\n\t    }\n\n\t    cy->cy_ibuf_wr_ptr = buf_p;\n\n#ifndef CY_HW_RTS\n\t    /* RTS handshaking for incoming data */\n\t    if(ISSET(cy->cy_tty->t_cflag, CRTSCTS)) {\n\t\tint bf;\n\n\t\tbf = buf_p - cy->cy_ibuf_rd_ptr;\n\t\tif(bf < 0)\n\t\t  bf += IBUF_SIZE;\n\n\t\tif(bf > (IBUF_SIZE/2))  /* turn RTS off */\n\t\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\t    }\n#endif /* CY_HW_RTS */\n\nend_rx_serv:\n\t    /* terminate service context */\n\t    cd_write_reg(cy, CD1400_RIR, save_rir & 0x3f);\n\t    cd_write_reg(cy, CD1400_CAR, save_car);\n\t    int_serviced = 1;\n\t} /* if(rx_service...) */\n\n\tif(ISSET(stat, CD1400_SVRR_MDMCH)) {\n\t    u_char save_car, save_mir, serv_type, modem_stat;\n\n\t    save_mir = cd_read_reg_sc(sc, cy_chip, CD1400_MIR);\n\t    save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);\n\t    /* enter modem service */\n\t    cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_mir);\n\n\t    serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_MIVR);\n\t    cy = &sc->sc_ports[serv_type >> 3];\n\n#ifdef CY_DEBUG1\n\t    cy->cy_modem_int_count++;\n#endif\n\n\t    modem_stat = cd_read_reg(cy, CD1400_MSVR2);\n\n#ifdef CY_DEBUG\n\t    printf(\"cy%d port %d modem line change, new stat 0x%x\\n\",\n\t\t   card, cy->cy_port_num, modem_stat);\n#endif\n\t    if(ISSET((cy->cy_carrier_stat ^ modem_stat), CD1400_MSVR2_CD)) {\n\t\tSET(cy->cy_flags, CYF_CARRIER_CHANGED);\n\t\tcy_events = 1;\n\t    }\n\n\t    cy->cy_carrier_stat = modem_stat;\n\n\t  /* terminate service context */\n\t    cd_write_reg(cy, CD1400_MIR, save_mir & 0x3f);\n\t    cd_write_reg(cy, CD1400_CAR, save_car);\n\t    int_serviced = 1;\n\t} /* if(modem_service...) */\n\n\tif(ISSET(stat, CD1400_SVRR_TXRDY)) {\n\t    u_char save_car, save_tir, serv_type, count, ch;\n\t    struct tty *tp;\n\n\t    save_tir = cd_read_reg_sc(sc, cy_chip, CD1400_TIR);\n\t    save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);\n\t    /* enter tx service */\n\t    cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_tir);\n\n\t    serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_TIVR);\n\t    cy = &sc->sc_ports[serv_type >> 3];\n\n#ifdef CY_DEBUG1\n\t    cy->cy_tx_int_count++;\n#endif\n#ifdef CY_DEBUG\n\t    printf(\"cy%d port %d tx service\\n\", card, cy->cy_port_num);\n#endif\n\n\t    /* stop transmitting if no tty or CYF_STOP set */\n\t    tp = cy->cy_tty;\n\t    if(tp == NULL || ISSET(cy->cy_flags, CYF_STOP))\n\t      goto txdone;\n\n\t    count = 0;\n\t    if(ISSET(cy->cy_flags, CYF_SEND_NUL)) {\n\t\tcd_write_reg(cy, CD1400_TDR, 0);\n\t\tcd_write_reg(cy, CD1400_TDR, 0);\n\t\tcount += 2;\n\t\tCLR(cy->cy_flags, CYF_SEND_NUL);\n\t    }\n\n\t    if(tp->t_outq.c_cc > 0) {\n\t\tSET(tp->t_state, TS_BUSY);\n\t\twhile(tp->t_outq.c_cc > 0 && count < CD1400_TX_FIFO_SIZE) {\n\t\t    ch = getc(&tp->t_outq);\n\t\t    /* remember to double NUL characters because\n\t\t       embedded transmit commands are enabled */\n\t\t    if(ch == 0) {\n\t\t\tif(count >= CD1400_TX_FIFO_SIZE-2) {\n\t\t\t    SET(cy->cy_flags, CYF_SEND_NUL);\n\t\t\t    break;\n\t\t\t}\n\n\t\t\tcd_write_reg(cy, CD1400_TDR, ch);\n\t\t\tcount++;\n\t\t    }\n\n\t\t    cd_write_reg(cy, CD1400_TDR, ch);\n\t\t    count++;\n\t\t}\n\t    } else {\n\t\t/* no data to send -- check if we should start/stop a break */\n\t\t/* XXX does this cause too much delay before breaks? */\n\t\tif(ISSET(cy->cy_flags, CYF_START_BREAK)) {\n\t\t    cd_write_reg(cy, CD1400_TDR, 0);\n\t\t    cd_write_reg(cy, CD1400_TDR, 0x81);\n\t\t    CLR(cy->cy_flags, CYF_START_BREAK);\n\t\t}\n\t\tif(ISSET(cy->cy_flags, CYF_END_BREAK)) {\n\t\t    cd_write_reg(cy, CD1400_TDR, 0);\n\t\t    cd_write_reg(cy, CD1400_TDR, 0x83);\n\t\t    CLR(cy->cy_flags, CYF_END_BREAK);\n\t\t}\n\t    }\n\n\t    if(tp->t_outq.c_cc == 0) {\ntxdone:\n\t\t/*\n\t\t * No data to send or requested to stop.\n\t\t * Disable transmit interrupt\n\t\t */\n\t\tcd_write_reg(cy, CD1400_SRER,\n\t\t\t     cd_read_reg(cy, CD1400_SRER)\n\t\t\t     & ~CD1400_SRER_TXRDY);\n\t\tCLR(cy->cy_flags, CYF_STOP);\n\t\tCLR(tp->t_state, TS_BUSY);\n\t    }\n\n\t    if(tp->t_outq.c_cc <= tp->t_lowat) {\n\t\tSET(cy->cy_flags, CYF_START);\n\t\tcy_events = 1;\n\t    }\n\n\t    /* terminate service context */\n\t    cd_write_reg(cy, CD1400_TIR, save_tir & 0x3f);\n\t    cd_write_reg(cy, CD1400_CAR, save_car);\n\t    int_serviced = 1;\n\t} /* if(tx_service...) */\n    } /* for(...all CD1400s on a card) */\n\n    /* ensure an edge for next interrupt */\n    bus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t    CY_CLEAR_INTR<<sc->sc_bustype, 0);\n    return int_serviced;\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "CY_CLEAR_INTR<<sc->sc_bustype",
            "0"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_CAR",
            "save_car"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TIR",
            "save_tir & 0x3f"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "cy->cy_flags",
            "CYF_START"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "tp->t_state",
            "TS_BUSY"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "cy->cy_flags",
            "CYF_STOP"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_SRER",
            "cd_read_reg(cy, CD1400_SRER)\n\t\t\t     & ~CD1400_SRER_TXRDY"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_SRER"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "cy->cy_flags",
            "CYF_END_BREAK"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TDR",
            "0x83"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TDR",
            "0"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_flags",
            "CYF_END_BREAK"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "cy->cy_flags",
            "CYF_START_BREAK"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TDR",
            "0x81"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TDR",
            "0"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_flags",
            "CYF_START_BREAK"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TDR",
            "ch"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TDR",
            "ch"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "cy->cy_flags",
            "CYF_SEND_NUL"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getc",
          "args": [
            "&tp->t_outq"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "comcngetc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/com.c",
          "lines": "1764-1779",
          "snippet": "int\ncomcngetc(dev)\n\tdev_t dev;\n{\n\tint s = splhigh();\n\tbus_space_tag_t iot = comconsiot;\n\tbus_space_handle_t ioh = comconsioh;\n\tu_char stat, c;\n\n\twhile (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))\n\t\t;\n\tc = bus_space_read_1(iot, ioh, com_data);\n\tstat = bus_space_read_1(iot, ioh, com_iir);\n\tsplx(s);\n\treturn c;\n}",
          "includes": [
            "#include <dev/cons.h>",
            "#include <machine/remote-sl.h>",
            "#include <dev/isa/isavar.h>\t/* XXX */",
            "#include \"com.h\"",
            "#include <dev/ic/hayespreg.h>",
            "#include <dev/ic/ns16550reg.h>",
            "#include <dev/ic/comvar.h>",
            "#include <dev/ic/comreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <ddb/db_var.h>",
            "#include <sys/vnode.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/select.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bus_space_tag_t comconsiot;",
            "bus_space_handle_t comconsioh;",
            "bus_space_tag_t iot;",
            "bus_space_handle_t ioh;",
            "struct tty *\ncomtty(dev)\n\tdev_t dev;",
            "bus_space_tag_t iot = sc->sc_iot;",
            "bus_space_handle_t ioh = sc->sc_ioh;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cons.h>\n#include <machine/remote-sl.h>\n#include <dev/isa/isavar.h>\t/* XXX */\n#include \"com.h\"\n#include <dev/ic/hayespreg.h>\n#include <dev/ic/ns16550reg.h>\n#include <dev/ic/comvar.h>\n#include <dev/ic/comreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <ddb/db_var.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/select.h>\n#include <sys/ioctl.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nbus_space_tag_t comconsiot;\nbus_space_handle_t comconsioh;\nbus_space_tag_t iot;\nbus_space_handle_t ioh;\nstruct tty *\ncomtty(dev)\n\tdev_t dev;\nbus_space_tag_t iot = sc->sc_iot;\nbus_space_handle_t ioh = sc->sc_ioh;\n\nint\ncomcngetc(dev)\n\tdev_t dev;\n{\n\tint s = splhigh();\n\tbus_space_tag_t iot = comconsiot;\n\tbus_space_handle_t ioh = comconsioh;\n\tu_char stat, c;\n\n\twhile (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))\n\t\t;\n\tc = bus_space_read_1(iot, ioh, com_data);\n\tstat = bus_space_read_1(iot, ioh, com_iir);\n\tsplx(s);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_state",
            "TS_BUSY"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "cy->cy_flags",
            "CYF_SEND_NUL"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TDR",
            "0"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TDR",
            "0"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_flags",
            "CYF_SEND_NUL"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_flags",
            "CYF_STOP"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy%d port %d tx service\\n\"",
            "card",
            "cy->cy_port_num"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd_read_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_TIVR"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_CAR",
            "save_tir"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_CAR"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_TIR"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "stat",
            "CD1400_SVRR_TXRDY"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_CAR",
            "save_car"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MIR",
            "save_mir & 0x3f"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "cy->cy_flags",
            "CYF_CARRIER_CHANGED"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "(cy->cy_carrier_stat ^ modem_stat)",
            "CD1400_MSVR2_CD"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_MSVR2"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_MIVR"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_CAR",
            "save_mir"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_CAR"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_MIR"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "stat",
            "CD1400_SVRR_MDMCH"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_CAR",
            "save_car"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_RIR",
            "save_rir & 0x3f"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR1",
            "0"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_tty->t_cflag",
            "CRTSCTS"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_RDSR"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_RDCR"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "line_stat",
            "CD1400_RDSR_OE"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_RDSR"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_RDSR"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "serv_type",
            "CD1400_RIVR_EXCEPTION"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_tty->t_state",
            "TS_ISOPEN"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_RIVR"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_CAR",
            "save_rir"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_CAR"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_RIR"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "stat",
            "CD1400_SVRR_RXRDY"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_SVRR"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncyintr(arg)\n     void *arg;\n{\n    struct cy_softc *sc = arg;\n    struct cy_port *cy;\n    int card = sc->sc_dev.dv_unit;\n    int cy_chip, stat;\n    int int_serviced = 0;\n\n/*\n * Check interrupt status of each CD1400 chip on this card\n * (multiple cards cannot share the same interrupt)\n */\n    for(cy_chip = 0; cy_chip < cy_nr_cd1400s[card]; cy_chip++) {\n\n\tstat = cd_read_reg_sc(sc, cy_chip, CD1400_SVRR);\n\tif(stat == 0)\n\t  continue;\n\n\tif(ISSET(stat, CD1400_SVRR_RXRDY)) {\n\t    u_char save_car, save_rir, serv_type;\n\t    u_char line_stat, recv_data, n_chars;\n\t    u_char *buf_p;\n\n\t    save_rir = cd_read_reg_sc(sc, cy_chip, CD1400_RIR);\n\t    save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);\n\t    /* enter rx service */\n\t    cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_rir);\n\n\t    serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_RIVR);\n\t    cy = &sc->sc_ports[serv_type >> 3];\n\n#ifdef CY_DEBUG1\n\t    cy->cy_rx_int_count++;\n#endif\n\n\t    if(cy->cy_tty == NULL ||\n\t       !ISSET(cy->cy_tty->t_state, TS_ISOPEN))\n\t      goto end_rx_serv;\n\n\t    buf_p = cy->cy_ibuf_wr_ptr;\n\n\t    if(ISSET(serv_type, CD1400_RIVR_EXCEPTION)) {\n\t\tline_stat = cd_read_reg(cy, CD1400_RDSR);\n\t\trecv_data = cd_read_reg(cy, CD1400_RDSR);\n\n#ifdef CY_DEBUG\n\t\tprintf(\"cy%d port %d recv exception, \"\n\t\t       \"line_stat 0x%x, char 0x%x\\n\",\n\t\t       card, cy->cy_port_num, line_stat, recv_data);\n#endif\n\t\tif(ISSET(line_stat, CD1400_RDSR_OE))\n\t\t  cy->cy_fifo_overruns++;\n\n\t\t*buf_p++ = line_stat;\n\t\t*buf_p++ = recv_data;\n\t\tif(buf_p == cy->cy_ibuf_end)\n\t\t  buf_p = cy->cy_ibuf;\n\n\t\tif(buf_p == cy->cy_ibuf_rd_ptr) {\n\t\t    if(buf_p == cy->cy_ibuf)\n\t\t      buf_p = cy->cy_ibuf_end;\n\t\t    buf_p -= 2;\n\t\t    cy->cy_ibuf_overruns++;\n\t\t}\n\t\tcy_events = 1;\n\t    } else { /* no exception, received data OK */\n\t\tn_chars = cd_read_reg(cy, CD1400_RDCR);\n#ifdef CY_DEBUG\n\t\tprintf(\"cy%d port %d receive ok %d chars\\n\",\n\t\t       card, cy->cy_port_num, n_chars);\n#endif\n\t\twhile(n_chars--) {\n\t\t    *buf_p++ = 0; /* status: OK */\n\t\t    *buf_p++ =\n\t\t      cd_read_reg(cy, CD1400_RDSR); /* data byte */\n\t\t    if(buf_p == cy->cy_ibuf_end)\n\t\t      buf_p = cy->cy_ibuf;\n\t\t    if(buf_p == cy->cy_ibuf_rd_ptr) {\n\t\t\tif(buf_p == cy->cy_ibuf)\n\t\t\t  buf_p = cy->cy_ibuf_end;\n\t\t\tbuf_p -= 2;\n\t\t\tcy->cy_ibuf_overruns++;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tcy_events = 1;\n\t    }\n\n\t    cy->cy_ibuf_wr_ptr = buf_p;\n\n#ifndef CY_HW_RTS\n\t    /* RTS handshaking for incoming data */\n\t    if(ISSET(cy->cy_tty->t_cflag, CRTSCTS)) {\n\t\tint bf;\n\n\t\tbf = buf_p - cy->cy_ibuf_rd_ptr;\n\t\tif(bf < 0)\n\t\t  bf += IBUF_SIZE;\n\n\t\tif(bf > (IBUF_SIZE/2))  /* turn RTS off */\n\t\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\t    }\n#endif /* CY_HW_RTS */\n\nend_rx_serv:\n\t    /* terminate service context */\n\t    cd_write_reg(cy, CD1400_RIR, save_rir & 0x3f);\n\t    cd_write_reg(cy, CD1400_CAR, save_car);\n\t    int_serviced = 1;\n\t} /* if(rx_service...) */\n\n\tif(ISSET(stat, CD1400_SVRR_MDMCH)) {\n\t    u_char save_car, save_mir, serv_type, modem_stat;\n\n\t    save_mir = cd_read_reg_sc(sc, cy_chip, CD1400_MIR);\n\t    save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);\n\t    /* enter modem service */\n\t    cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_mir);\n\n\t    serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_MIVR);\n\t    cy = &sc->sc_ports[serv_type >> 3];\n\n#ifdef CY_DEBUG1\n\t    cy->cy_modem_int_count++;\n#endif\n\n\t    modem_stat = cd_read_reg(cy, CD1400_MSVR2);\n\n#ifdef CY_DEBUG\n\t    printf(\"cy%d port %d modem line change, new stat 0x%x\\n\",\n\t\t   card, cy->cy_port_num, modem_stat);\n#endif\n\t    if(ISSET((cy->cy_carrier_stat ^ modem_stat), CD1400_MSVR2_CD)) {\n\t\tSET(cy->cy_flags, CYF_CARRIER_CHANGED);\n\t\tcy_events = 1;\n\t    }\n\n\t    cy->cy_carrier_stat = modem_stat;\n\n\t  /* terminate service context */\n\t    cd_write_reg(cy, CD1400_MIR, save_mir & 0x3f);\n\t    cd_write_reg(cy, CD1400_CAR, save_car);\n\t    int_serviced = 1;\n\t} /* if(modem_service...) */\n\n\tif(ISSET(stat, CD1400_SVRR_TXRDY)) {\n\t    u_char save_car, save_tir, serv_type, count, ch;\n\t    struct tty *tp;\n\n\t    save_tir = cd_read_reg_sc(sc, cy_chip, CD1400_TIR);\n\t    save_car = cd_read_reg_sc(sc, cy_chip, CD1400_CAR);\n\t    /* enter tx service */\n\t    cd_write_reg_sc(sc, cy_chip, CD1400_CAR, save_tir);\n\n\t    serv_type = cd_read_reg_sc(sc, cy_chip, CD1400_TIVR);\n\t    cy = &sc->sc_ports[serv_type >> 3];\n\n#ifdef CY_DEBUG1\n\t    cy->cy_tx_int_count++;\n#endif\n#ifdef CY_DEBUG\n\t    printf(\"cy%d port %d tx service\\n\", card, cy->cy_port_num);\n#endif\n\n\t    /* stop transmitting if no tty or CYF_STOP set */\n\t    tp = cy->cy_tty;\n\t    if(tp == NULL || ISSET(cy->cy_flags, CYF_STOP))\n\t      goto txdone;\n\n\t    count = 0;\n\t    if(ISSET(cy->cy_flags, CYF_SEND_NUL)) {\n\t\tcd_write_reg(cy, CD1400_TDR, 0);\n\t\tcd_write_reg(cy, CD1400_TDR, 0);\n\t\tcount += 2;\n\t\tCLR(cy->cy_flags, CYF_SEND_NUL);\n\t    }\n\n\t    if(tp->t_outq.c_cc > 0) {\n\t\tSET(tp->t_state, TS_BUSY);\n\t\twhile(tp->t_outq.c_cc > 0 && count < CD1400_TX_FIFO_SIZE) {\n\t\t    ch = getc(&tp->t_outq);\n\t\t    /* remember to double NUL characters because\n\t\t       embedded transmit commands are enabled */\n\t\t    if(ch == 0) {\n\t\t\tif(count >= CD1400_TX_FIFO_SIZE-2) {\n\t\t\t    SET(cy->cy_flags, CYF_SEND_NUL);\n\t\t\t    break;\n\t\t\t}\n\n\t\t\tcd_write_reg(cy, CD1400_TDR, ch);\n\t\t\tcount++;\n\t\t    }\n\n\t\t    cd_write_reg(cy, CD1400_TDR, ch);\n\t\t    count++;\n\t\t}\n\t    } else {\n\t\t/* no data to send -- check if we should start/stop a break */\n\t\t/* XXX does this cause too much delay before breaks? */\n\t\tif(ISSET(cy->cy_flags, CYF_START_BREAK)) {\n\t\t    cd_write_reg(cy, CD1400_TDR, 0);\n\t\t    cd_write_reg(cy, CD1400_TDR, 0x81);\n\t\t    CLR(cy->cy_flags, CYF_START_BREAK);\n\t\t}\n\t\tif(ISSET(cy->cy_flags, CYF_END_BREAK)) {\n\t\t    cd_write_reg(cy, CD1400_TDR, 0);\n\t\t    cd_write_reg(cy, CD1400_TDR, 0x83);\n\t\t    CLR(cy->cy_flags, CYF_END_BREAK);\n\t\t}\n\t    }\n\n\t    if(tp->t_outq.c_cc == 0) {\ntxdone:\n\t\t/*\n\t\t * No data to send or requested to stop.\n\t\t * Disable transmit interrupt\n\t\t */\n\t\tcd_write_reg(cy, CD1400_SRER,\n\t\t\t     cd_read_reg(cy, CD1400_SRER)\n\t\t\t     & ~CD1400_SRER_TXRDY);\n\t\tCLR(cy->cy_flags, CYF_STOP);\n\t\tCLR(tp->t_state, TS_BUSY);\n\t    }\n\n\t    if(tp->t_outq.c_cc <= tp->t_lowat) {\n\t\tSET(cy->cy_flags, CYF_START);\n\t\tcy_events = 1;\n\t    }\n\n\t    /* terminate service context */\n\t    cd_write_reg(cy, CD1400_TIR, save_tir & 0x3f);\n\t    cd_write_reg(cy, CD1400_CAR, save_car);\n\t    int_serviced = 1;\n\t} /* if(tx_service...) */\n    } /* for(...all CD1400s on a card) */\n\n    /* ensure an edge for next interrupt */\n    bus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t    CY_CLEAR_INTR<<sc->sc_bustype, 0);\n    return int_serviced;\n}"
  },
  {
    "function_name": "cy_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "984-1147",
    "snippet": "void\ncy_poll(arg)\n     void *arg;\n{\n    int card, port;\n    struct cy_softc *sc;\n    struct cy_port *cy;\n    struct tty *tp;\n    static int counter = 0;\n#ifdef CY_DEBUG1\n    int did_something;\n#endif\n\n    int s;\n\n    s = splhigh();\n\n    if(cy_events == 0 && ++counter < 200) {\n        splx(s);\n\tgoto out;\n    }\n\n    cy_events = 0;\n    splx(s);\n\n    for(card = 0; card < cy_cd.cd_ndevs; card++) {\n\tsc = cy_cd.cd_devs[card];\n\tif(sc == NULL)\n\t  continue;\n\n#ifdef CY_DEBUG1\n\tsc->sc_poll_count1++;\n\tdid_something = 0;\n#endif\n\n\tfor(port = 0; port < sc->sc_nports; port++) {\n\t    cy = &sc->sc_ports[port];\n\t    if((tp = cy->cy_tty) == NULL || cy->cy_ibuf == NULL ||\n\t       !ISSET(tp->t_state, TS_ISOPEN | TS_WOPEN))\n\t    continue;\n\n\t    /*\n\t     * handle received data\n\t     */\n\t    while(cy->cy_ibuf_rd_ptr != cy->cy_ibuf_wr_ptr) {\n\t        u_char line_stat;\n\t\tint chr;\n\n\t\tline_stat = cy->cy_ibuf_rd_ptr[0];\n\t\tchr = cy->cy_ibuf_rd_ptr[1];\n\n\t\tif(line_stat & (CD1400_RDSR_BREAK|CD1400_RDSR_FE))\n\t\t  chr |= TTY_FE;\n\t\tif(line_stat & CD1400_RDSR_PE)\n\t\t  chr |= TTY_PE;\n\n\t\t/*\n\t\t * on an overrun error the data is treated as good\n\t\t * just as it should be.\n\t\t */\n\n#ifdef CY_DEBUG\n\t\tprintf(\"cy%d port %d ttyinput 0x%x\\n\",\n\t\t       card, port, chr);\n#endif\n\n\t\t(*linesw[tp->t_line].l_rint)(chr, tp);\n\n                s = splhigh(); /* really necessary? */\n\t\tif((cy->cy_ibuf_rd_ptr += 2) == cy->cy_ibuf_end)\n\t\t  cy->cy_ibuf_rd_ptr = cy->cy_ibuf;\n\t\tsplx(s);\n\n#ifdef CY_DEBUG1\n\t\tdid_something = 1;\n#endif\n\t    }\n\n#ifndef CY_HW_RTS\n\t    /* If we don't have any received data in ibuf and\n\t     * CRTSCTS is on and RTS is turned off, it is time\n\t     * to turn RTS back on\n\t     */\n\t    if(ISSET(tp->t_cflag, CRTSCTS)) {\n\t      /* we can't use cy_modem_control() here as it doesn't\n\t\t change RTS if RTSCTS is on */\n\t      cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN);\n\t      \n\t      if((cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS) == 0) {\n\t\tcd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#ifdef CY_DEBUG1\n\t\tdid_something = 1;\n#endif\n\t      }\n\t    }\n#endif /* CY_HW_RTS */\n\n\t    /*\n\t     * handle carrier changes\n\t     */\n\t    s = splhigh();\n\t    if(ISSET(cy->cy_flags, CYF_CARRIER_CHANGED)) {\n\t\tint carrier;\n\n\t\tCLR(cy->cy_flags, CYF_CARRIER_CHANGED);\n\t\tsplx(s);\n\n\t\tcarrier = ((cy->cy_carrier_stat & CD1400_MSVR2_CD) != 0);\n\n#ifdef CY_DEBUG\n\t\tprintf(\"cy_poll: carrier change \"\n\t\t       \"(card %d, port %d, carrier %d)\\n\",\n\t\t       card, port, carrier);\n#endif\n\t\tif(CY_DIALIN(tp->t_dev) &&\n\t\t   !(*linesw[tp->t_line].l_modem)(tp, carrier))\n\t\t  cy_modem_control(cy, TIOCM_DTR, DMBIC);\n\n#ifdef CY_DEBUG1\n\t\tdid_something = 1;\n#endif\n\t    } else {\n\t\tsplx(s);\n\t    }\n\n\t    s = splhigh();\n\t    if(ISSET(cy->cy_flags, CYF_START)) {\n\t\tCLR(cy->cy_flags, CYF_START);\n              splx(s);\n\n\t\t(*linesw[tp->t_line].l_start)(tp);\n\n#ifdef CY_DEBUG1\n\t\tdid_something = 1;\n#endif\n\t    } else {\n                splx(s);\n\t    }\n\n\t    /* could move this to even upper level... */\n\t    if(cy->cy_fifo_overruns) {\n\t\tcy->cy_fifo_overruns = 0;\n\t\t/* doesn't report overrun count,\n\t\t   but shouldn't really matter */\n\t\tlog(LOG_WARNING, \"cy%d port %d fifo overrun\\n\",\n\t\t    card, port);\n\t    }\n\t    if(cy->cy_ibuf_overruns) {\n\t\tcy->cy_ibuf_overruns = 0;\n\t\tlog(LOG_WARNING, \"cy%d port %d ibuf overrun\\n\",\n\t\t    card, port);\n\t    }\n\t} /* for(port...) */\n#ifdef CY_DEBUG1\n\tif(did_something && counter >= 200)\n\t  sc->sc_poll_count2++;\n#endif\n    } /* for(card...) */\n\n    counter = 0;\n\nout:\n    timeout(cy_poll, NULL, 1);\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "cy_poll",
            "NULL",
            "1"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"cy%d port %d ibuf overrun\\n\"",
            "card",
            "port"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "cy->cy_flags",
            "CYF_START"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_flags",
            "CYF_START"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cy_modem_control",
          "args": [
            "cy",
            "TIOCM_DTR",
            "DMBIC"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "cy_modem_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "885-978",
          "snippet": "int\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "carrier"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_DIALIN",
          "args": [
            "tp->t_dev"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy_poll: carrier change \"\n\t\t       \"(card %d, port %d, carrier %d)\\n\"",
            "card",
            "port",
            "carrier"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "cy->cy_flags",
            "CYF_CARRIER_CHANGED"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_flags",
            "CYF_CARRIER_CHANGED"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR1",
            "CD1400_MSVR1_RTS"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_MSVR1"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_CAR",
            "port & CD1400_CAR_CHAN"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_cflag",
            "CRTSCTS"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chr",
            "tp"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_ISOPEN | TS_WOPEN"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splhigh",
          "args": [],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nvoid\ncy_poll(arg)\n     void *arg;\n{\n    int card, port;\n    struct cy_softc *sc;\n    struct cy_port *cy;\n    struct tty *tp;\n    static int counter = 0;\n#ifdef CY_DEBUG1\n    int did_something;\n#endif\n\n    int s;\n\n    s = splhigh();\n\n    if(cy_events == 0 && ++counter < 200) {\n        splx(s);\n\tgoto out;\n    }\n\n    cy_events = 0;\n    splx(s);\n\n    for(card = 0; card < cy_cd.cd_ndevs; card++) {\n\tsc = cy_cd.cd_devs[card];\n\tif(sc == NULL)\n\t  continue;\n\n#ifdef CY_DEBUG1\n\tsc->sc_poll_count1++;\n\tdid_something = 0;\n#endif\n\n\tfor(port = 0; port < sc->sc_nports; port++) {\n\t    cy = &sc->sc_ports[port];\n\t    if((tp = cy->cy_tty) == NULL || cy->cy_ibuf == NULL ||\n\t       !ISSET(tp->t_state, TS_ISOPEN | TS_WOPEN))\n\t    continue;\n\n\t    /*\n\t     * handle received data\n\t     */\n\t    while(cy->cy_ibuf_rd_ptr != cy->cy_ibuf_wr_ptr) {\n\t        u_char line_stat;\n\t\tint chr;\n\n\t\tline_stat = cy->cy_ibuf_rd_ptr[0];\n\t\tchr = cy->cy_ibuf_rd_ptr[1];\n\n\t\tif(line_stat & (CD1400_RDSR_BREAK|CD1400_RDSR_FE))\n\t\t  chr |= TTY_FE;\n\t\tif(line_stat & CD1400_RDSR_PE)\n\t\t  chr |= TTY_PE;\n\n\t\t/*\n\t\t * on an overrun error the data is treated as good\n\t\t * just as it should be.\n\t\t */\n\n#ifdef CY_DEBUG\n\t\tprintf(\"cy%d port %d ttyinput 0x%x\\n\",\n\t\t       card, port, chr);\n#endif\n\n\t\t(*linesw[tp->t_line].l_rint)(chr, tp);\n\n                s = splhigh(); /* really necessary? */\n\t\tif((cy->cy_ibuf_rd_ptr += 2) == cy->cy_ibuf_end)\n\t\t  cy->cy_ibuf_rd_ptr = cy->cy_ibuf;\n\t\tsplx(s);\n\n#ifdef CY_DEBUG1\n\t\tdid_something = 1;\n#endif\n\t    }\n\n#ifndef CY_HW_RTS\n\t    /* If we don't have any received data in ibuf and\n\t     * CRTSCTS is on and RTS is turned off, it is time\n\t     * to turn RTS back on\n\t     */\n\t    if(ISSET(tp->t_cflag, CRTSCTS)) {\n\t      /* we can't use cy_modem_control() here as it doesn't\n\t\t change RTS if RTSCTS is on */\n\t      cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN);\n\t      \n\t      if((cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS) == 0) {\n\t\tcd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#ifdef CY_DEBUG1\n\t\tdid_something = 1;\n#endif\n\t      }\n\t    }\n#endif /* CY_HW_RTS */\n\n\t    /*\n\t     * handle carrier changes\n\t     */\n\t    s = splhigh();\n\t    if(ISSET(cy->cy_flags, CYF_CARRIER_CHANGED)) {\n\t\tint carrier;\n\n\t\tCLR(cy->cy_flags, CYF_CARRIER_CHANGED);\n\t\tsplx(s);\n\n\t\tcarrier = ((cy->cy_carrier_stat & CD1400_MSVR2_CD) != 0);\n\n#ifdef CY_DEBUG\n\t\tprintf(\"cy_poll: carrier change \"\n\t\t       \"(card %d, port %d, carrier %d)\\n\",\n\t\t       card, port, carrier);\n#endif\n\t\tif(CY_DIALIN(tp->t_dev) &&\n\t\t   !(*linesw[tp->t_line].l_modem)(tp, carrier))\n\t\t  cy_modem_control(cy, TIOCM_DTR, DMBIC);\n\n#ifdef CY_DEBUG1\n\t\tdid_something = 1;\n#endif\n\t    } else {\n\t\tsplx(s);\n\t    }\n\n\t    s = splhigh();\n\t    if(ISSET(cy->cy_flags, CYF_START)) {\n\t\tCLR(cy->cy_flags, CYF_START);\n              splx(s);\n\n\t\t(*linesw[tp->t_line].l_start)(tp);\n\n#ifdef CY_DEBUG1\n\t\tdid_something = 1;\n#endif\n\t    } else {\n                splx(s);\n\t    }\n\n\t    /* could move this to even upper level... */\n\t    if(cy->cy_fifo_overruns) {\n\t\tcy->cy_fifo_overruns = 0;\n\t\t/* doesn't report overrun count,\n\t\t   but shouldn't really matter */\n\t\tlog(LOG_WARNING, \"cy%d port %d fifo overrun\\n\",\n\t\t    card, port);\n\t    }\n\t    if(cy->cy_ibuf_overruns) {\n\t\tcy->cy_ibuf_overruns = 0;\n\t\tlog(LOG_WARNING, \"cy%d port %d ibuf overrun\\n\",\n\t\t    card, port);\n\t    }\n\t} /* for(port...) */\n#ifdef CY_DEBUG1\n\tif(did_something && counter >= 200)\n\t  sc->sc_poll_count2++;\n#endif\n    } /* for(card...) */\n\n    counter = 0;\n\nout:\n    timeout(cy_poll, NULL, 1);\n}"
  },
  {
    "function_name": "cy_modem_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "885-978",
    "snippet": "int\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR2",
            "0"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR1",
            "0"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_tty->t_cflag",
            "CRTSCTS"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR1",
            "0"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR2",
            "0"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_tty->t_cflag",
            "CRTSCTS"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR2",
            "CD1400_MSVR2_DTR"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR1",
            "CD1400_MSVR1_RTS"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_tty->t_cflag",
            "CRTSCTS"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR1",
            "CD1400_MSVR1_RTS"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR2",
            "CD1400_MSVR2_DTR"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_tty->t_cflag",
            "CRTSCTS"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR2",
            "((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0)"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR1",
            "((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0)"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_tty->t_cflag",
            "CRTSCTS"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR1",
            "((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MSVR2",
            "((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0)"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_tty->t_cflag",
            "CRTSCTS"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_MSVR1"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_MSVR1"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_MSVR2"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_CAR",
            "cy->cy_port_num & CD1400_CAR_CHAN"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}"
  },
  {
    "function_name": "cyparam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "737-875",
    "snippet": "int\ncyparam(tp, t)\n     struct tty *tp;\n     struct termios *t;\n{\n    int card = CY_CARD(tp->t_dev);\n    int port = CY_PORT(tp->t_dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    int ibpr, obpr, i_clk_opt, o_clk_opt;\n    int s, opt;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d port %d param tty 0x%x termios 0x%x\\n\",\n\t   card, port, tp, t);\n    printf(\"ispeed %d ospeed %d\\n\", t->c_ispeed, t->c_ospeed);\n#endif\n\n    if(t->c_ospeed != 0 && cy_speed(t->c_ospeed, &o_clk_opt, &obpr) < 0)\n      return EINVAL;\n\n    if(t->c_ispeed != 0 && cy_speed(t->c_ispeed, &i_clk_opt, &ibpr) < 0)\n      return EINVAL;\n\n    s = spltty();\n\n    /* hang up the line is ospeed is zero, else turn DTR on */\n    cy_modem_control(cy, TIOCM_DTR, (t->c_ospeed == 0 ? DMBIC : DMBIS));\n\n    /* channel was selected by the above call to cy_modem_control() */\n    /* cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN); */\n\n    /* set transmit speed */\n    if(t->c_ospeed != 0) {\n\tcd_write_reg(cy, CD1400_TCOR, o_clk_opt);\n\tcd_write_reg(cy, CD1400_TBPR, obpr);\n    }\n    /* set receive speed */\n    if(t->c_ispeed != 0) {\n\tcd_write_reg(cy, CD1400_RCOR, i_clk_opt);\n\tcd_write_reg(cy, CD1400_RBPR, ibpr);\n    }\n\n    opt = CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN\n      | (ISSET(t->c_cflag, CREAD) ? CD1400_CCR_RCVEN : CD1400_CCR_RCVDIS);\n\n    if(opt != cy->cy_channel_control) {\n\tcy->cy_channel_control = opt;\n\tcd1400_channel_cmd(cy, opt);\n    }\n\n    /* compute COR1 contents */\n    opt = 0;\n    if(ISSET(t->c_cflag, PARENB)) {\n\tif(ISSET(t->c_cflag, PARODD))\n\t  opt |= CD1400_COR1_PARODD;\n\topt |= CD1400_COR1_PARNORMAL;\n    }\n\n    if(!ISSET(t->c_iflag, INPCK))\n      opt |= CD1400_COR1_NOINPCK; /* no parity checking */\n\n    if(ISSET(t->c_cflag, CSTOPB))\n      opt |= CD1400_COR1_STOP2;\n\n    switch(t->c_cflag & CSIZE) {\n      case CS5:\n        opt |= CD1400_COR1_CS5;\n        break;\n\n      case CS6:\n        opt |= CD1400_COR1_CS6;\n\tbreak;\n\n      case CS7:\n        opt |= CD1400_COR1_CS7;\n\tbreak;\n\n      default:\n        opt |= CD1400_COR1_CS8;\n\tbreak;\n    }\n\n    cd_write_reg(cy, CD1400_COR1, opt);\n\n#ifdef CY_DEBUG\n    printf(\"cor1 = 0x%x...\", opt);\n#endif\n\n/*\n * use the CD1400 automatic CTS flow control if CRTSCTS is set\n *\n * CD1400_COR2_ETC is used because breaks are generated with\n * embedded transmit commands\n */\n    cd_write_reg(cy, CD1400_COR2,\n\t\t CD1400_COR2_ETC |\n\t\t (ISSET(t->c_cflag, CRTSCTS) ? CD1400_COR2_CCTS_OFLOW : 0));\n\n    cd_write_reg(cy, CD1400_COR3, RX_FIFO_THRESHOLD);\n\n    cd1400_channel_cmd(cy,\n\t\t       CD1400_CCR_CMDCORCHG |\n\t\t       CD1400_CCR_COR1 | CD1400_CCR_COR2 | CD1400_CCR_COR3);\n\n    cd_write_reg(cy, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);\n    cd_write_reg(cy, CD1400_COR5, 0);\n\n  /*\n   * set modem change option registers to generate interrupts\n   * on carrier detect changes.\n   *\n   * if hardware RTS handshaking is used (CY_HW_RTS, DTR and RTS lines\n   * exchanged), also set the handshaking threshold.\n   */\n#ifdef CY_HW_RTS\n    cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd |\n\t\t (ISSET(t->c_cflag, CRTSCTS) ? RX_DTR_THRESHOLD : 0));\n#else\n    cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd);\n#endif /* CY_HW_RTS */\n\n    cd_write_reg(cy, CD1400_MCOR2, CD1400_MCOR2_CDod);\n\n    /*\n     * set receive timeout to approx. 2ms\n     * could use more complex logic here...\n     * (but is it actually needed or even useful?)\n     */\n    cd_write_reg(cy, CD1400_RTPR, 2);\n\n    /*\n     * should do anything else here?\n     * XXX check MDMBUF handshaking like in com.c?\n     */\n\n    splx(s);\n    return 0;\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_RTPR",
            "2"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MCOR2",
            "CD1400_MCOR2_CDod"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MCOR1",
            "CD1400_MCOR1_CDzd"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_MCOR1",
            "CD1400_MCOR1_CDzd |\n\t\t (ISSET(t->c_cflag, CRTSCTS) ? RX_DTR_THRESHOLD : 0)"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "t->c_cflag",
            "CRTSCTS"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_COR5",
            "0"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_COR4",
            "CD1400_COR4_PFO_EXCEPTION"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd1400_channel_cmd",
          "args": [
            "cy",
            "CD1400_CCR_CMDCORCHG |\n\t\t       CD1400_CCR_COR1 | CD1400_CCR_COR2 | CD1400_CCR_COR3"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "cd1400_channel_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "1414-1433",
          "snippet": "void\ncd1400_channel_cmd(cy, cmd)\n     struct cy_port *cy;\n     int cmd;\n{\n    u_int waitcnt = 5 * 8 * 1024; /* approx 5 ms */\n\n#ifdef CY_DEBUG\n    printf(\"c1400_channel_cmd cy 0x%x command 0x%x\\n\", cy, cmd);\n#endif\n\n    /* wait until cd1400 is ready to process a new command */\n    while(cd_read_reg(cy, CD1400_CCR) != 0 && waitcnt-- > 0)\n      ;\n\n    if(waitcnt == 0)\n      log(LOG_ERR, \"cy: channel command timeout\\n\");\n\n    cd_write_reg(cy, CD1400_CCR, cmd);\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nvoid\ncd1400_channel_cmd(cy, cmd)\n     struct cy_port *cy;\n     int cmd;\n{\n    u_int waitcnt = 5 * 8 * 1024; /* approx 5 ms */\n\n#ifdef CY_DEBUG\n    printf(\"c1400_channel_cmd cy 0x%x command 0x%x\\n\", cy, cmd);\n#endif\n\n    /* wait until cd1400 is ready to process a new command */\n    while(cd_read_reg(cy, CD1400_CCR) != 0 && waitcnt-- > 0)\n      ;\n\n    if(waitcnt == 0)\n      log(LOG_ERR, \"cy: channel command timeout\\n\");\n\n    cd_write_reg(cy, CD1400_CCR, cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_COR3",
            "RX_FIFO_THRESHOLD"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_COR2",
            "CD1400_COR2_ETC |\n\t\t (ISSET(t->c_cflag, CRTSCTS) ? CD1400_COR2_CCTS_OFLOW : 0)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "t->c_cflag",
            "CRTSCTS"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cor1 = 0x%x...\"",
            "opt"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_COR1",
            "opt"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "t->c_cflag",
            "CSTOPB"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "t->c_iflag",
            "INPCK"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "t->c_cflag",
            "PARODD"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "t->c_cflag",
            "PARENB"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "t->c_cflag",
            "CREAD"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_RBPR",
            "ibpr"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_RCOR",
            "i_clk_opt"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TBPR",
            "obpr"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_TCOR",
            "o_clk_opt"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cy_modem_control",
          "args": [
            "cy",
            "TIOCM_DTR",
            "(t->c_ospeed == 0 ? DMBIC : DMBIS)"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "cy_modem_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "885-978",
          "snippet": "int\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cy_speed",
          "args": [
            "t->c_ispeed",
            "&i_clk_opt",
            "&ibpr"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "cy_speed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "1443-1461",
          "snippet": "int\ncy_speed(speed_t speed, int *cor, int *bpr)\n{\n    int c, co, br;\n\n    if(speed < 50 || speed > 150000)\n      return -1;\n\n    for(c = 0, co = 8; co <= 2048; co <<= 2, c++) {\n\tbr = (CY_CLOCK + (co * speed) / 2) / (co * speed);\n\tif(br < 0x100) {\n\t    *bpr = br;\n\t    *cor = c;\n\t    return 0;\n\t}\n    }\n\n    return -1;\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_speed(speed_t speed, int *cor, int *bpr)\n{\n    int c, co, br;\n\n    if(speed < 50 || speed > 150000)\n      return -1;\n\n    for(c = 0, co = 8; co <= 2048; co <<= 2, c++) {\n\tbr = (CY_CLOCK + (co * speed) / 2) / (co * speed);\n\tif(br < 0x100) {\n\t    *bpr = br;\n\t    *cor = c;\n\t    return 0;\n\t}\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CY_PORT",
          "args": [
            "tp->t_dev"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CARD",
          "args": [
            "tp->t_dev"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncyparam(tp, t)\n     struct tty *tp;\n     struct termios *t;\n{\n    int card = CY_CARD(tp->t_dev);\n    int port = CY_PORT(tp->t_dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    int ibpr, obpr, i_clk_opt, o_clk_opt;\n    int s, opt;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d port %d param tty 0x%x termios 0x%x\\n\",\n\t   card, port, tp, t);\n    printf(\"ispeed %d ospeed %d\\n\", t->c_ispeed, t->c_ospeed);\n#endif\n\n    if(t->c_ospeed != 0 && cy_speed(t->c_ospeed, &o_clk_opt, &obpr) < 0)\n      return EINVAL;\n\n    if(t->c_ispeed != 0 && cy_speed(t->c_ispeed, &i_clk_opt, &ibpr) < 0)\n      return EINVAL;\n\n    s = spltty();\n\n    /* hang up the line is ospeed is zero, else turn DTR on */\n    cy_modem_control(cy, TIOCM_DTR, (t->c_ospeed == 0 ? DMBIC : DMBIS));\n\n    /* channel was selected by the above call to cy_modem_control() */\n    /* cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN); */\n\n    /* set transmit speed */\n    if(t->c_ospeed != 0) {\n\tcd_write_reg(cy, CD1400_TCOR, o_clk_opt);\n\tcd_write_reg(cy, CD1400_TBPR, obpr);\n    }\n    /* set receive speed */\n    if(t->c_ispeed != 0) {\n\tcd_write_reg(cy, CD1400_RCOR, i_clk_opt);\n\tcd_write_reg(cy, CD1400_RBPR, ibpr);\n    }\n\n    opt = CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN\n      | (ISSET(t->c_cflag, CREAD) ? CD1400_CCR_RCVEN : CD1400_CCR_RCVDIS);\n\n    if(opt != cy->cy_channel_control) {\n\tcy->cy_channel_control = opt;\n\tcd1400_channel_cmd(cy, opt);\n    }\n\n    /* compute COR1 contents */\n    opt = 0;\n    if(ISSET(t->c_cflag, PARENB)) {\n\tif(ISSET(t->c_cflag, PARODD))\n\t  opt |= CD1400_COR1_PARODD;\n\topt |= CD1400_COR1_PARNORMAL;\n    }\n\n    if(!ISSET(t->c_iflag, INPCK))\n      opt |= CD1400_COR1_NOINPCK; /* no parity checking */\n\n    if(ISSET(t->c_cflag, CSTOPB))\n      opt |= CD1400_COR1_STOP2;\n\n    switch(t->c_cflag & CSIZE) {\n      case CS5:\n        opt |= CD1400_COR1_CS5;\n        break;\n\n      case CS6:\n        opt |= CD1400_COR1_CS6;\n\tbreak;\n\n      case CS7:\n        opt |= CD1400_COR1_CS7;\n\tbreak;\n\n      default:\n        opt |= CD1400_COR1_CS8;\n\tbreak;\n    }\n\n    cd_write_reg(cy, CD1400_COR1, opt);\n\n#ifdef CY_DEBUG\n    printf(\"cor1 = 0x%x...\", opt);\n#endif\n\n/*\n * use the CD1400 automatic CTS flow control if CRTSCTS is set\n *\n * CD1400_COR2_ETC is used because breaks are generated with\n * embedded transmit commands\n */\n    cd_write_reg(cy, CD1400_COR2,\n\t\t CD1400_COR2_ETC |\n\t\t (ISSET(t->c_cflag, CRTSCTS) ? CD1400_COR2_CCTS_OFLOW : 0));\n\n    cd_write_reg(cy, CD1400_COR3, RX_FIFO_THRESHOLD);\n\n    cd1400_channel_cmd(cy,\n\t\t       CD1400_CCR_CMDCORCHG |\n\t\t       CD1400_CCR_COR1 | CD1400_CCR_COR2 | CD1400_CCR_COR3);\n\n    cd_write_reg(cy, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);\n    cd_write_reg(cy, CD1400_COR5, 0);\n\n  /*\n   * set modem change option registers to generate interrupts\n   * on carrier detect changes.\n   *\n   * if hardware RTS handshaking is used (CY_HW_RTS, DTR and RTS lines\n   * exchanged), also set the handshaking threshold.\n   */\n#ifdef CY_HW_RTS\n    cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd |\n\t\t (ISSET(t->c_cflag, CRTSCTS) ? RX_DTR_THRESHOLD : 0));\n#else\n    cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd);\n#endif /* CY_HW_RTS */\n\n    cd_write_reg(cy, CD1400_MCOR2, CD1400_MCOR2_CDod);\n\n    /*\n     * set receive timeout to approx. 2ms\n     * could use more complex logic here...\n     * (but is it actually needed or even useful?)\n     */\n    cd_write_reg(cy, CD1400_RTPR, 2);\n\n    /*\n     * should do anything else here?\n     * XXX check MDMBUF handshaking like in com.c?\n     */\n\n    splx(s);\n    return 0;\n}"
  },
  {
    "function_name": "cystop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "701-731",
    "snippet": "int\ncystop(tp, flag)\n     struct tty *tp;\n     int flag;\n{\n    int card = CY_CARD(tp->t_dev);\n    int port = CY_PORT(tp->t_dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    int s;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d port %d stop tty 0x%x flag 0x%x\\n\",\n\t   card, port, tp, flag);\n#endif\n\n    s = spltty();\n\n    if(ISSET(tp->t_state, TS_BUSY)) {\n\tif(!ISSET(tp->t_state, TS_TTSTOP))\n\t  SET(tp->t_state, TS_FLUSH);\n\n\t/*\n\t * the transmit interrupt routine will disable transmit when it\n\t * notices that CYF_STOP has been set.\n\t */\n\tSET(cy->cy_flags, CYF_STOP);\n    }\n    splx(s);\n    return(0);\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "cy->cy_flags",
            "CYF_STOP"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_state",
            "TS_FLUSH"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_TTSTOP"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_BUSY"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy%d port %d stop tty 0x%x flag 0x%x\\n\"",
            "card",
            "port",
            "tp",
            "flag"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CY_PORT",
          "args": [
            "tp->t_dev"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CARD",
          "args": [
            "tp->t_dev"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncystop(tp, flag)\n     struct tty *tp;\n     int flag;\n{\n    int card = CY_CARD(tp->t_dev);\n    int port = CY_PORT(tp->t_dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    int s;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d port %d stop tty 0x%x flag 0x%x\\n\",\n\t   card, port, tp, flag);\n#endif\n\n    s = spltty();\n\n    if(ISSET(tp->t_state, TS_BUSY)) {\n\tif(!ISSET(tp->t_state, TS_TTSTOP))\n\t  SET(tp->t_state, TS_FLUSH);\n\n\t/*\n\t * the transmit interrupt routine will disable transmit when it\n\t * notices that CYF_STOP has been set.\n\t */\n\tSET(cy->cy_flags, CYF_STOP);\n    }\n    splx(s);\n    return(0);\n}"
  },
  {
    "function_name": "cystart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "656-696",
    "snippet": "void\ncystart(tp)\n     struct tty *tp;\n{\n    int card = CY_CARD(tp->t_dev);\n    int port = CY_PORT(tp->t_dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    int s;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d port %d start, tty 0x%x\\n\", card, port, tp);\n#endif\n\n\n    s = spltty();\n\n#ifdef CY_DEBUG1\n    cy->cy_start_count++;\n#endif\n\n  if(!ISSET(tp->t_state, TS_TTSTOP | TS_TIMEOUT | TS_BUSY)) {\n      if(tp->t_outq.c_cc <= tp->t_lowat) {\n\t  if(ISSET(tp->t_state, TS_ASLEEP)) {\n\t      CLR(tp->t_state, TS_ASLEEP);\n\t      wakeup(&tp->t_outq);\n\t  }\n\n\t  selwakeup(&tp->t_wsel);\n\n\t  if(tp->t_outq.c_cc == 0)\n\t    goto out;\n      }\n\n      SET(tp->t_state, TS_BUSY);\n      cy_enable_transmitter(cy);\n  }\nout:\n\n    splx(s);\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cy_enable_transmitter",
          "args": [
            "cy"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "cy_enable_transmitter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "1399-1409",
          "snippet": "void\ncy_enable_transmitter(cy)\n     struct cy_port *cy;\n{\n    int s;\n    s = splhigh();\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n    cd_write_reg(cy, CD1400_SRER, cd_read_reg(cy, CD1400_SRER)\n\t\t | CD1400_SRER_TXRDY);\n    splx(s);\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nvoid\ncy_enable_transmitter(cy)\n     struct cy_port *cy;\n{\n    int s;\n    s = splhigh();\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n    cd_write_reg(cy, CD1400_SRER, cd_read_reg(cy, CD1400_SRER)\n\t\t | CD1400_SRER_TXRDY);\n    splx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_state",
            "TS_BUSY"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&tp->t_wsel"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&tp->t_outq"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "tp->t_state",
            "TS_ASLEEP"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_ASLEEP"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_TTSTOP | TS_TIMEOUT | TS_BUSY"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy%d port %d start, tty 0x%x\\n\"",
            "card",
            "port",
            "tp"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CY_PORT",
          "args": [
            "tp->t_dev"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CARD",
          "args": [
            "tp->t_dev"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nvoid\ncystart(tp)\n     struct tty *tp;\n{\n    int card = CY_CARD(tp->t_dev);\n    int port = CY_PORT(tp->t_dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    int s;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d port %d start, tty 0x%x\\n\", card, port, tp);\n#endif\n\n\n    s = spltty();\n\n#ifdef CY_DEBUG1\n    cy->cy_start_count++;\n#endif\n\n  if(!ISSET(tp->t_state, TS_TTSTOP | TS_TIMEOUT | TS_BUSY)) {\n      if(tp->t_outq.c_cc <= tp->t_lowat) {\n\t  if(ISSET(tp->t_state, TS_ASLEEP)) {\n\t      CLR(tp->t_state, TS_ASLEEP);\n\t      wakeup(&tp->t_outq);\n\t  }\n\n\t  selwakeup(&tp->t_wsel);\n\n\t  if(tp->t_outq.c_cc == 0)\n\t    goto out;\n      }\n\n      SET(tp->t_state, TS_BUSY);\n      cy_enable_transmitter(cy);\n  }\nout:\n\n    splx(s);\n}"
  },
  {
    "function_name": "cyioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "566-651",
    "snippet": "int\ncyioctl(dev, cmd, data, flag, p)\n     dev_t dev;\n     u_long cmd;\n     caddr_t data;\n     int flag;\n     struct proc *p;\n{\n    int card = CY_CARD(dev);\n    int port = CY_PORT(dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    struct tty *tp = cy->cy_tty;\n    int error;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d port %d ioctl cmd 0x%x data 0x%x flag 0x%x\\n\",\n\t   card, port, cmd, data, flag);\n#endif\n\n    error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);\n    if(error >= 0)\n      return error;\n\n    error = ttioctl(tp, cmd, data, flag, p);\n    if(error >= 0)\n      return error;\n\n/* XXX should not allow dropping DTR when dialin? */\n\n    switch(cmd) {\n      case TIOCSBRK: /* start break */\n        SET(cy->cy_flags, CYF_START_BREAK);\n\tcy_enable_transmitter(cy);\n        break;\n\n      case TIOCCBRK: /* stop break */\n\tSET(cy->cy_flags, CYF_END_BREAK);\n\tcy_enable_transmitter(cy);\n\tbreak;\n\n      case TIOCSDTR: /* DTR on */\n\tcy_modem_control(cy, TIOCM_DTR, DMBIS);\n\tbreak;\n\n      case TIOCCDTR: /* DTR off */\n\tcy_modem_control(cy, TIOCM_DTR, DMBIC);\n\tbreak;\n\n      case TIOCMSET: /* set new modem control line values */\n\tcy_modem_control(cy, *((int *)data), DMSET);\n\tbreak;\n\n      case TIOCMBIS: /* turn modem control bits on */\n\tcy_modem_control(cy, *((int *)data), DMBIS);\n\tbreak;\n\n      case TIOCMBIC: /* turn modem control bits off */\n\tcy_modem_control(cy, *((int *)data), DMBIC);\n\tbreak;\n\n      case TIOCMGET: /* get modem control/status line state */\n\t*((int *)data) = cy_modem_control(cy, 0, DMGET);\n\tbreak;\n\n      case TIOCGFLAGS:\n\t*((int *)data) = cy->cy_openflags |\n\t  (CY_DIALOUT(dev) ? TIOCFLAG_SOFTCAR : 0);\n\tbreak;\n\n      case TIOCSFLAGS:\n\terror = suser(p->p_ucred, &p->p_acflag);\n\tif(error != 0)\n\t  return EPERM;\n\n\tcy->cy_openflags = *((int *)data) &\n\t  (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL |\n\t   TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF);\n\tbreak;\n\n      default:\n\treturn ENOTTY;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_DIALOUT",
          "args": [
            "dev"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cy_modem_control",
          "args": [
            "cy",
            "0",
            "DMGET"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "cy_modem_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "885-978",
          "snippet": "int\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cy_enable_transmitter",
          "args": [
            "cy"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "cy_enable_transmitter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "1399-1409",
          "snippet": "void\ncy_enable_transmitter(cy)\n     struct cy_port *cy;\n{\n    int s;\n    s = splhigh();\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n    cd_write_reg(cy, CD1400_SRER, cd_read_reg(cy, CD1400_SRER)\n\t\t | CD1400_SRER_TXRDY);\n    splx(s);\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nvoid\ncy_enable_transmitter(cy)\n     struct cy_port *cy;\n{\n    int s;\n    s = splhigh();\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n    cd_write_reg(cy, CD1400_SRER, cd_read_reg(cy, CD1400_SRER)\n\t\t | CD1400_SRER_TXRDY);\n    splx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "cy->cy_flags",
            "CYF_END_BREAK"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "cy->cy_flags",
            "CYF_START_BREAK"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttioctl",
          "args": [
            "tp",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy%d port %d ioctl cmd 0x%x data 0x%x flag 0x%x\\n\"",
            "card",
            "port",
            "cmd",
            "data",
            "flag"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CY_PORT",
          "args": [
            "dev"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CARD",
          "args": [
            "dev"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncyioctl(dev, cmd, data, flag, p)\n     dev_t dev;\n     u_long cmd;\n     caddr_t data;\n     int flag;\n     struct proc *p;\n{\n    int card = CY_CARD(dev);\n    int port = CY_PORT(dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    struct tty *tp = cy->cy_tty;\n    int error;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d port %d ioctl cmd 0x%x data 0x%x flag 0x%x\\n\",\n\t   card, port, cmd, data, flag);\n#endif\n\n    error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);\n    if(error >= 0)\n      return error;\n\n    error = ttioctl(tp, cmd, data, flag, p);\n    if(error >= 0)\n      return error;\n\n/* XXX should not allow dropping DTR when dialin? */\n\n    switch(cmd) {\n      case TIOCSBRK: /* start break */\n        SET(cy->cy_flags, CYF_START_BREAK);\n\tcy_enable_transmitter(cy);\n        break;\n\n      case TIOCCBRK: /* stop break */\n\tSET(cy->cy_flags, CYF_END_BREAK);\n\tcy_enable_transmitter(cy);\n\tbreak;\n\n      case TIOCSDTR: /* DTR on */\n\tcy_modem_control(cy, TIOCM_DTR, DMBIS);\n\tbreak;\n\n      case TIOCCDTR: /* DTR off */\n\tcy_modem_control(cy, TIOCM_DTR, DMBIC);\n\tbreak;\n\n      case TIOCMSET: /* set new modem control line values */\n\tcy_modem_control(cy, *((int *)data), DMSET);\n\tbreak;\n\n      case TIOCMBIS: /* turn modem control bits on */\n\tcy_modem_control(cy, *((int *)data), DMBIS);\n\tbreak;\n\n      case TIOCMBIC: /* turn modem control bits off */\n\tcy_modem_control(cy, *((int *)data), DMBIC);\n\tbreak;\n\n      case TIOCMGET: /* get modem control/status line state */\n\t*((int *)data) = cy_modem_control(cy, 0, DMGET);\n\tbreak;\n\n      case TIOCGFLAGS:\n\t*((int *)data) = cy->cy_openflags |\n\t  (CY_DIALOUT(dev) ? TIOCFLAG_SOFTCAR : 0);\n\tbreak;\n\n      case TIOCSFLAGS:\n\terror = suser(p->p_ucred, &p->p_acflag);\n\tif(error != 0)\n\t  return EPERM;\n\n\tcy->cy_openflags = *((int *)data) &\n\t  (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL |\n\t   TIOCFLAG_CRTSCTS | TIOCFLAG_MDMBUF);\n\tbreak;\n\n      default:\n\treturn ENOTTY;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "cywrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "522-540",
    "snippet": "int\ncywrite(dev, uio, flag)\n     dev_t dev;\n     struct uio *uio;\n     int flag;\n{\n    int card = CY_CARD(dev);\n    int port = CY_PORT(dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    struct tty *tp = cy->cy_tty;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d write port %d uio 0x%x flag 0x%x\\n\",\n\t   card, port, uio, flag);\n#endif\n\n    return ((*linesw[tp->t_line].l_write)(tp, uio, flag));\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "uio",
            "flag"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy%d write port %d uio 0x%x flag 0x%x\\n\"",
            "card",
            "port",
            "uio",
            "flag"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CY_PORT",
          "args": [
            "dev"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CARD",
          "args": [
            "dev"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncywrite(dev, uio, flag)\n     dev_t dev;\n     struct uio *uio;\n     int flag;\n{\n    int card = CY_CARD(dev);\n    int port = CY_PORT(dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    struct tty *tp = cy->cy_tty;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d write port %d uio 0x%x flag 0x%x\\n\",\n\t   card, port, uio, flag);\n#endif\n\n    return ((*linesw[tp->t_line].l_write)(tp, uio, flag));\n}"
  },
  {
    "function_name": "cyread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "499-517",
    "snippet": "int\ncyread(dev, uio, flag)\n     dev_t dev;\n     struct uio *uio;\n     int flag;\n{\n    int card = CY_CARD(dev);\n    int port = CY_PORT(dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    struct tty *tp = cy->cy_tty;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d read port %d uio 0x%x flag 0x%x\\n\",\n\t   card, port, uio, flag);\n#endif\n\n    return ((*linesw[tp->t_line].l_read)(tp, uio, flag));\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "uio",
            "flag"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy%d read port %d uio 0x%x flag 0x%x\\n\"",
            "card",
            "port",
            "uio",
            "flag"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CY_PORT",
          "args": [
            "dev"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CARD",
          "args": [
            "dev"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncyread(dev, uio, flag)\n     dev_t dev;\n     struct uio *uio;\n     int flag;\n{\n    int card = CY_CARD(dev);\n    int port = CY_PORT(dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    struct tty *tp = cy->cy_tty;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d read port %d uio 0x%x flag 0x%x\\n\",\n\t   card, port, uio, flag);\n#endif\n\n    return ((*linesw[tp->t_line].l_read)(tp, uio, flag));\n}"
  },
  {
    "function_name": "cyclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "456-494",
    "snippet": "int\ncyclose(dev, flag, mode, p)\n     dev_t dev;\n     int flag, mode;\n     struct proc *p;\n{\n    int card = CY_CARD(dev);\n    int port = CY_PORT(dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    struct tty *tp = cy->cy_tty;\n    int s;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d close port %d, flag 0x%x, mode 0x%x\\n\",\n\t card, port, flag, mode);\n#endif\n\n    (*linesw[tp->t_line].l_close)(tp, flag);\n    s = spltty();\n\n    if(ISSET(tp->t_cflag, HUPCL) &&\n       !ISSET(cy->cy_openflags, TIOCFLAG_SOFTCAR)) {\n\t/* drop DTR and RTS\n\t   (should we wait for output buffer to become empty first?) */\n\tcy_modem_control(cy, 0, DMSET);\n    }\n\n/*\n * XXX should we disable modem change and\n * receive interrupts here or somewhere ?\n */\n    CLR(tp->t_state, TS_BUSY | TS_FLUSH);\n\n    splx(s);\n    ttyclose(tp);\n\n    return 0;\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ttyclose",
          "args": [
            "tp"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "tp->t_state",
            "TS_BUSY | TS_FLUSH"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cy_modem_control",
          "args": [
            "cy",
            "0",
            "DMSET"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "cy_modem_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "885-978",
          "snippet": "int\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_openflags",
            "TIOCFLAG_SOFTCAR"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_cflag",
            "HUPCL"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "flag"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy%d close port %d, flag 0x%x, mode 0x%x\\n\"",
            "card",
            "port",
            "flag",
            "mode"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CY_PORT",
          "args": [
            "dev"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CARD",
          "args": [
            "dev"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncyclose(dev, flag, mode, p)\n     dev_t dev;\n     int flag, mode;\n     struct proc *p;\n{\n    int card = CY_CARD(dev);\n    int port = CY_PORT(dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    struct tty *tp = cy->cy_tty;\n    int s;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d close port %d, flag 0x%x, mode 0x%x\\n\",\n\t card, port, flag, mode);\n#endif\n\n    (*linesw[tp->t_line].l_close)(tp, flag);\n    s = spltty();\n\n    if(ISSET(tp->t_cflag, HUPCL) &&\n       !ISSET(cy->cy_openflags, TIOCFLAG_SOFTCAR)) {\n\t/* drop DTR and RTS\n\t   (should we wait for output buffer to become empty first?) */\n\tcy_modem_control(cy, 0, DMSET);\n    }\n\n/*\n * XXX should we disable modem change and\n * receive interrupts here or somewhere ?\n */\n    CLR(tp->t_state, TS_BUSY | TS_FLUSH);\n\n    splx(s);\n    ttyclose(tp);\n\n    return 0;\n}"
  },
  {
    "function_name": "cyopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "315-451",
    "snippet": "int\ncyopen(dev, flag, mode, p)\n     dev_t dev;\n     int flag, mode;\n     struct proc *p;\n{\n    int card = CY_CARD(dev);\n    int port = CY_PORT(dev);\n    struct cy_softc *sc;\n    struct cy_port *cy;\n    struct tty *tp;\n    int s, error;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d open port %d flag 0x%x mode 0x%x\\n\",\n\t   card, port, flag, mode);\n#endif\n\n    if(card >= cy_cd.cd_ndevs ||\n       (sc = cy_cd.cd_devs[card]) == NULL)\n      return ENXIO;\n\n    cy = &sc->sc_ports[port];\n\n    s = spltty();\n    if(cy->cy_tty == NULL) {\n\tif((cy->cy_tty = ttymalloc()) == NULL) {\n\t    splx(s);\n\t    printf(\"cy%d port %d open: can't allocate tty\\n\", card, port);\n\t    return ENOMEM;\n\t}\n    }\n    splx(s);\n\n    tp = cy->cy_tty;\n    tty_attach(tp);\n    tp = cy->cy_tty;\n    tp->t_oproc = cystart;\n    tp->t_param = cyparam;\n    tp->t_dev = dev;\n\n    if(!ISSET(tp->t_state, TS_ISOPEN)) {\n\tSET(tp->t_state, TS_WOPEN);\n\tttychars(tp);\n\ttp->t_iflag = TTYDEF_IFLAG;\n\ttp->t_oflag = TTYDEF_OFLAG;\n\ttp->t_cflag = TTYDEF_CFLAG;\n\tif(ISSET(cy->cy_openflags, TIOCFLAG_CLOCAL))\n\t  SET(tp->t_cflag, CLOCAL);\n\tif(ISSET(cy->cy_openflags, TIOCFLAG_CRTSCTS))\n\t  SET(tp->t_cflag, CRTSCTS);\n\tif(ISSET(cy->cy_openflags, TIOCFLAG_MDMBUF))\n\t  SET(tp->t_cflag, MDMBUF);\n\ttp->t_lflag = TTYDEF_LFLAG;\n\ttp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;\n\n\ts = spltty();\n\n\t/*\n\t * Allocate input ring buffer if we don't already have one\n\t */\n\tif(cy->cy_ibuf == NULL) {\n\t    cy->cy_ibuf = malloc(IBUF_SIZE, M_DEVBUF, M_NOWAIT);\n\t    if(cy->cy_ibuf == NULL) {\n\t\tprintf(\"cy%d: (port %d) can't allocate input buffer\\n\",\n\t\t       card, port);\n\t\tsplx(s);\n\t\treturn ENOMEM;\n\t    }\n\t    cy->cy_ibuf_end = cy->cy_ibuf + IBUF_SIZE;\n\t}\n\n\t/* mark the ring buffer as empty */\n\tcy->cy_ibuf_rd_ptr = cy->cy_ibuf_wr_ptr = cy->cy_ibuf;\n\n\t/* select CD1400 channel */\n\tcd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN);\n\t/* reset the channel */\n\tcd1400_channel_cmd(cy, CD1400_CCR_CMDRESET);\n\t/* encode unit (port) number in LIVR */\n\t/* there is just enough space for 5 bits (32 ports) */\n\tcd_write_reg(cy, CD1400_LIVR, port << 3);\n\n\tcy->cy_channel_control = 0;\n\n\t/* hmm... need spltty() here? */\n\tif(cy_open == 0)\n\t  {\n\t    cy_open = 1;\n\t    timeout(cy_poll, NULL, 1);\n\t  }\n\n\t/* this sets parameters and raises DTR */\n\tcyparam(tp, &tp->t_termios);\n\n\tttsetwater(tp);\n\n\t/* raise RTS too */\n\tcy_modem_control(cy, TIOCM_RTS, DMBIS);\n\n\tcy->cy_carrier_stat =\n\t  cd_read_reg(cy, CD1400_MSVR2);\n\n\t/* enable receiver and modem change interrupts */\n\tcd_write_reg(cy, CD1400_SRER, CD1400_SRER_MDMCH | CD1400_SRER_RXDATA);\n\n\tif(CY_DIALOUT(dev) ||\n\t   ISSET(cy->cy_openflags, TIOCFLAG_SOFTCAR) ||\n\t   ISSET(tp->t_cflag, MDMBUF) ||\n\t   ISSET(cy->cy_carrier_stat, CD1400_MSVR2_CD))\n\t  SET(tp->t_state, TS_CARR_ON);\n\telse\n\t  CLR(tp->t_state, TS_CARR_ON);\n    } else if(ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0) {\n\treturn EBUSY;\n    } else {\n\ts = spltty();\n    }\n\n    /* wait for carrier if necessary */\n    if(!ISSET(flag, O_NONBLOCK)) {\n\twhile(!ISSET(tp->t_cflag, CLOCAL) &&\n\t    !ISSET(tp->t_state, TS_CARR_ON)) {\n\t    SET(tp->t_state, TS_WOPEN);\n\t    error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH, \"cydcd\", 0);\n\t    if(error != 0) {\n\t\tsplx(s);\n\t\tCLR(tp->t_state, TS_WOPEN);\n\t\treturn error;\n\t    }\n\t}\n    }\n\n    splx(s);\n\n    return (*linesw[tp->t_line].l_open)(dev, tp);\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "dev",
            "tp"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "tp->t_state",
            "TS_WOPEN"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttysleep",
          "args": [
            "tp",
            "&tp->t_rawq",
            "TTIPRI | PCATCH",
            "\"cydcd\"",
            "0"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_state",
            "TS_WOPEN"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_CARR_ON"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_cflag",
            "CLOCAL"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "flag",
            "O_NONBLOCK"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_XCLUDE"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLR",
          "args": [
            "tp->t_state",
            "TS_CARR_ON"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_state",
            "TS_CARR_ON"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_carrier_stat",
            "CD1400_MSVR2_CD"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_cflag",
            "MDMBUF"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_openflags",
            "TIOCFLAG_SOFTCAR"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_DIALOUT",
          "args": [
            "dev"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_SRER",
            "CD1400_SRER_MDMCH | CD1400_SRER_RXDATA"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_read_reg",
          "args": [
            "cy",
            "CD1400_MSVR2"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cy_modem_control",
          "args": [
            "cy",
            "TIOCM_RTS",
            "DMBIS"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "cy_modem_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "885-978",
          "snippet": "int\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_modem_control(cy, bits, howto)\n     struct cy_port *cy;\n     int bits;\n     int howto;\n{\n    int s, msvr;\n\n    s = spltty();\n\n    /* select channel */\n    cd_write_reg(cy, CD1400_CAR, cy->cy_port_num & CD1400_CAR_CHAN);\n\n/* does not manipulate RTS if it is used for flow control */\n    switch(howto) {\n      case DMGET:\n        splx(s);\n\tbits = 0;\n\tif(cy->cy_channel_control & CD1400_CCR_RCVEN)\n\t  bits |= TIOCM_LE;\n\tmsvr = cd_read_reg(cy, CD1400_MSVR2);\n#ifdef CY_HW_RTS\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_DTR;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_RTS;\n#else\n\tif(cd_read_reg(cy, CD1400_MSVR1) & CD1400_MSVR1_RTS)\n\t  bits |= TIOCM_RTS;\n\tif(msvr & CD1400_MSVR2_DTR)\n\t  bits |= TIOCM_DTR;\n#endif /* CY_HW_RTS */\n\tif(msvr & CD1400_MSVR2_CTS)\n\t  bits |= TIOCM_CTS;\n\tif(msvr & CD1400_MSVR2_CD)\n\t  bits |= TIOCM_CD;\n\tif(msvr & CD1400_MSVR2_DSR) /* not connected on some Cyclom cards? */\n\t  bits |= TIOCM_DSR;\n\tif(msvr & CD1400_MSVR2_RI) /* not connected on Cyclom-8Y cards? */\n\t  bits |= TIOCM_RI;\n\tsplx(s);\n\treturn bits;\n\n      case DMSET: /* replace old values with new ones */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR2,\n\t\t       ((bits & TIOCM_RTS) ? CD1400_MSVR2_DTR : 0));\n\tcd_write_reg(cy, CD1400_MSVR1,\n\t\t     ((bits & TIOCM_DTR) ? CD1400_MSVR1_RTS : 0));\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS))\n\t  cd_write_reg(cy, CD1400_MSVR1,\n\t\t  ((bits & TIOCM_RTS) ? CD1400_MSVR1_RTS : 0));\n\tcd_write_reg(cy, CD1400_MSVR2,\n\t\t((bits & TIOCM_DTR) ? CD1400_MSVR2_DTR : 0));\n#endif /* CY_HW_RTS */\n        break;\n\n      case DMBIS: /* set bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS) != 0)\n\t  cd_write_reg(cy, CD1400_MSVR1, CD1400_MSVR1_RTS);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, CD1400_MSVR2_DTR);\n#endif /* CY_HW_RTS */\n\tbreak;\n\n      case DMBIC: /* clear bits */\n#ifdef CY_HW_RTS\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n#else\n\tif(!ISSET(cy->cy_tty->t_cflag, CRTSCTS) &&\n\t   (bits & TIOCM_RTS))\n\t  cd_write_reg(cy, CD1400_MSVR1, 0);\n\tif(bits & TIOCM_DTR)\n\t  cd_write_reg(cy, CD1400_MSVR2, 0);\n#endif /* CY_HW_RTS */\n\tbreak;\n    }\n    splx(s);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttsetwater",
          "args": [
            "tp"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cyparam",
          "args": [
            "tp",
            "&tp->t_termios"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "cyparam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "737-875",
          "snippet": "int\ncyparam(tp, t)\n     struct tty *tp;\n     struct termios *t;\n{\n    int card = CY_CARD(tp->t_dev);\n    int port = CY_PORT(tp->t_dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    int ibpr, obpr, i_clk_opt, o_clk_opt;\n    int s, opt;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d port %d param tty 0x%x termios 0x%x\\n\",\n\t   card, port, tp, t);\n    printf(\"ispeed %d ospeed %d\\n\", t->c_ispeed, t->c_ospeed);\n#endif\n\n    if(t->c_ospeed != 0 && cy_speed(t->c_ospeed, &o_clk_opt, &obpr) < 0)\n      return EINVAL;\n\n    if(t->c_ispeed != 0 && cy_speed(t->c_ispeed, &i_clk_opt, &ibpr) < 0)\n      return EINVAL;\n\n    s = spltty();\n\n    /* hang up the line is ospeed is zero, else turn DTR on */\n    cy_modem_control(cy, TIOCM_DTR, (t->c_ospeed == 0 ? DMBIC : DMBIS));\n\n    /* channel was selected by the above call to cy_modem_control() */\n    /* cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN); */\n\n    /* set transmit speed */\n    if(t->c_ospeed != 0) {\n\tcd_write_reg(cy, CD1400_TCOR, o_clk_opt);\n\tcd_write_reg(cy, CD1400_TBPR, obpr);\n    }\n    /* set receive speed */\n    if(t->c_ispeed != 0) {\n\tcd_write_reg(cy, CD1400_RCOR, i_clk_opt);\n\tcd_write_reg(cy, CD1400_RBPR, ibpr);\n    }\n\n    opt = CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN\n      | (ISSET(t->c_cflag, CREAD) ? CD1400_CCR_RCVEN : CD1400_CCR_RCVDIS);\n\n    if(opt != cy->cy_channel_control) {\n\tcy->cy_channel_control = opt;\n\tcd1400_channel_cmd(cy, opt);\n    }\n\n    /* compute COR1 contents */\n    opt = 0;\n    if(ISSET(t->c_cflag, PARENB)) {\n\tif(ISSET(t->c_cflag, PARODD))\n\t  opt |= CD1400_COR1_PARODD;\n\topt |= CD1400_COR1_PARNORMAL;\n    }\n\n    if(!ISSET(t->c_iflag, INPCK))\n      opt |= CD1400_COR1_NOINPCK; /* no parity checking */\n\n    if(ISSET(t->c_cflag, CSTOPB))\n      opt |= CD1400_COR1_STOP2;\n\n    switch(t->c_cflag & CSIZE) {\n      case CS5:\n        opt |= CD1400_COR1_CS5;\n        break;\n\n      case CS6:\n        opt |= CD1400_COR1_CS6;\n\tbreak;\n\n      case CS7:\n        opt |= CD1400_COR1_CS7;\n\tbreak;\n\n      default:\n        opt |= CD1400_COR1_CS8;\n\tbreak;\n    }\n\n    cd_write_reg(cy, CD1400_COR1, opt);\n\n#ifdef CY_DEBUG\n    printf(\"cor1 = 0x%x...\", opt);\n#endif\n\n/*\n * use the CD1400 automatic CTS flow control if CRTSCTS is set\n *\n * CD1400_COR2_ETC is used because breaks are generated with\n * embedded transmit commands\n */\n    cd_write_reg(cy, CD1400_COR2,\n\t\t CD1400_COR2_ETC |\n\t\t (ISSET(t->c_cflag, CRTSCTS) ? CD1400_COR2_CCTS_OFLOW : 0));\n\n    cd_write_reg(cy, CD1400_COR3, RX_FIFO_THRESHOLD);\n\n    cd1400_channel_cmd(cy,\n\t\t       CD1400_CCR_CMDCORCHG |\n\t\t       CD1400_CCR_COR1 | CD1400_CCR_COR2 | CD1400_CCR_COR3);\n\n    cd_write_reg(cy, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);\n    cd_write_reg(cy, CD1400_COR5, 0);\n\n  /*\n   * set modem change option registers to generate interrupts\n   * on carrier detect changes.\n   *\n   * if hardware RTS handshaking is used (CY_HW_RTS, DTR and RTS lines\n   * exchanged), also set the handshaking threshold.\n   */\n#ifdef CY_HW_RTS\n    cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd |\n\t\t (ISSET(t->c_cflag, CRTSCTS) ? RX_DTR_THRESHOLD : 0));\n#else\n    cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd);\n#endif /* CY_HW_RTS */\n\n    cd_write_reg(cy, CD1400_MCOR2, CD1400_MCOR2_CDod);\n\n    /*\n     * set receive timeout to approx. 2ms\n     * could use more complex logic here...\n     * (but is it actually needed or even useful?)\n     */\n    cd_write_reg(cy, CD1400_RTPR, 2);\n\n    /*\n     * should do anything else here?\n     * XXX check MDMBUF handshaking like in com.c?\n     */\n\n    splx(s);\n    return 0;\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncyparam(tp, t)\n     struct tty *tp;\n     struct termios *t;\n{\n    int card = CY_CARD(tp->t_dev);\n    int port = CY_PORT(tp->t_dev);\n    struct cy_softc *sc = cy_cd.cd_devs[card];\n    struct cy_port *cy = &sc->sc_ports[port];\n    int ibpr, obpr, i_clk_opt, o_clk_opt;\n    int s, opt;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d port %d param tty 0x%x termios 0x%x\\n\",\n\t   card, port, tp, t);\n    printf(\"ispeed %d ospeed %d\\n\", t->c_ispeed, t->c_ospeed);\n#endif\n\n    if(t->c_ospeed != 0 && cy_speed(t->c_ospeed, &o_clk_opt, &obpr) < 0)\n      return EINVAL;\n\n    if(t->c_ispeed != 0 && cy_speed(t->c_ispeed, &i_clk_opt, &ibpr) < 0)\n      return EINVAL;\n\n    s = spltty();\n\n    /* hang up the line is ospeed is zero, else turn DTR on */\n    cy_modem_control(cy, TIOCM_DTR, (t->c_ospeed == 0 ? DMBIC : DMBIS));\n\n    /* channel was selected by the above call to cy_modem_control() */\n    /* cd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN); */\n\n    /* set transmit speed */\n    if(t->c_ospeed != 0) {\n\tcd_write_reg(cy, CD1400_TCOR, o_clk_opt);\n\tcd_write_reg(cy, CD1400_TBPR, obpr);\n    }\n    /* set receive speed */\n    if(t->c_ispeed != 0) {\n\tcd_write_reg(cy, CD1400_RCOR, i_clk_opt);\n\tcd_write_reg(cy, CD1400_RBPR, ibpr);\n    }\n\n    opt = CD1400_CCR_CMDCHANCTL | CD1400_CCR_XMTEN\n      | (ISSET(t->c_cflag, CREAD) ? CD1400_CCR_RCVEN : CD1400_CCR_RCVDIS);\n\n    if(opt != cy->cy_channel_control) {\n\tcy->cy_channel_control = opt;\n\tcd1400_channel_cmd(cy, opt);\n    }\n\n    /* compute COR1 contents */\n    opt = 0;\n    if(ISSET(t->c_cflag, PARENB)) {\n\tif(ISSET(t->c_cflag, PARODD))\n\t  opt |= CD1400_COR1_PARODD;\n\topt |= CD1400_COR1_PARNORMAL;\n    }\n\n    if(!ISSET(t->c_iflag, INPCK))\n      opt |= CD1400_COR1_NOINPCK; /* no parity checking */\n\n    if(ISSET(t->c_cflag, CSTOPB))\n      opt |= CD1400_COR1_STOP2;\n\n    switch(t->c_cflag & CSIZE) {\n      case CS5:\n        opt |= CD1400_COR1_CS5;\n        break;\n\n      case CS6:\n        opt |= CD1400_COR1_CS6;\n\tbreak;\n\n      case CS7:\n        opt |= CD1400_COR1_CS7;\n\tbreak;\n\n      default:\n        opt |= CD1400_COR1_CS8;\n\tbreak;\n    }\n\n    cd_write_reg(cy, CD1400_COR1, opt);\n\n#ifdef CY_DEBUG\n    printf(\"cor1 = 0x%x...\", opt);\n#endif\n\n/*\n * use the CD1400 automatic CTS flow control if CRTSCTS is set\n *\n * CD1400_COR2_ETC is used because breaks are generated with\n * embedded transmit commands\n */\n    cd_write_reg(cy, CD1400_COR2,\n\t\t CD1400_COR2_ETC |\n\t\t (ISSET(t->c_cflag, CRTSCTS) ? CD1400_COR2_CCTS_OFLOW : 0));\n\n    cd_write_reg(cy, CD1400_COR3, RX_FIFO_THRESHOLD);\n\n    cd1400_channel_cmd(cy,\n\t\t       CD1400_CCR_CMDCORCHG |\n\t\t       CD1400_CCR_COR1 | CD1400_CCR_COR2 | CD1400_CCR_COR3);\n\n    cd_write_reg(cy, CD1400_COR4, CD1400_COR4_PFO_EXCEPTION);\n    cd_write_reg(cy, CD1400_COR5, 0);\n\n  /*\n   * set modem change option registers to generate interrupts\n   * on carrier detect changes.\n   *\n   * if hardware RTS handshaking is used (CY_HW_RTS, DTR and RTS lines\n   * exchanged), also set the handshaking threshold.\n   */\n#ifdef CY_HW_RTS\n    cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd |\n\t\t (ISSET(t->c_cflag, CRTSCTS) ? RX_DTR_THRESHOLD : 0));\n#else\n    cd_write_reg(cy, CD1400_MCOR1, CD1400_MCOR1_CDzd);\n#endif /* CY_HW_RTS */\n\n    cd_write_reg(cy, CD1400_MCOR2, CD1400_MCOR2_CDod);\n\n    /*\n     * set receive timeout to approx. 2ms\n     * could use more complex logic here...\n     * (but is it actually needed or even useful?)\n     */\n    cd_write_reg(cy, CD1400_RTPR, 2);\n\n    /*\n     * should do anything else here?\n     * XXX check MDMBUF handshaking like in com.c?\n     */\n\n    splx(s);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "cy_poll",
            "NULL",
            "1"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_LIVR",
            "port << 3"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd1400_channel_cmd",
          "args": [
            "cy",
            "CD1400_CCR_CMDRESET"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "cd1400_channel_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
          "lines": "1414-1433",
          "snippet": "void\ncd1400_channel_cmd(cy, cmd)\n     struct cy_port *cy;\n     int cmd;\n{\n    u_int waitcnt = 5 * 8 * 1024; /* approx 5 ms */\n\n#ifdef CY_DEBUG\n    printf(\"c1400_channel_cmd cy 0x%x command 0x%x\\n\", cy, cmd);\n#endif\n\n    /* wait until cd1400 is ready to process a new command */\n    while(cd_read_reg(cy, CD1400_CCR) != 0 && waitcnt-- > 0)\n      ;\n\n    if(waitcnt == 0)\n      log(LOG_ERR, \"cy: channel command timeout\\n\");\n\n    cd_write_reg(cy, CD1400_CCR, cmd);\n}",
          "includes": [
            "#include <dev/ic/cyreg.h>",
            "#include <dev/ic/cd1400reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/systm.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/select.h>",
            "#include <sys/user.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/tty.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>",
            "#include \"cy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nvoid\ncd1400_channel_cmd(cy, cmd)\n     struct cy_port *cy;\n     int cmd;\n{\n    u_int waitcnt = 5 * 8 * 1024; /* approx 5 ms */\n\n#ifdef CY_DEBUG\n    printf(\"c1400_channel_cmd cy 0x%x command 0x%x\\n\", cy, cmd);\n#endif\n\n    /* wait until cd1400 is ready to process a new command */\n    while(cd_read_reg(cy, CD1400_CCR) != 0 && waitcnt-- > 0)\n      ;\n\n    if(waitcnt == 0)\n      log(LOG_ERR, \"cy: channel command timeout\\n\");\n\n    cd_write_reg(cy, CD1400_CCR, cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd_write_reg",
          "args": [
            "cy",
            "CD1400_CAR",
            "port & CD1400_CAR_CHAN"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cy%d: (port %d) can't allocate input buffer\\n\"",
            "card",
            "port"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "IBUF_SIZE",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_cflag",
            "MDMBUF"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_openflags",
            "TIOCFLAG_MDMBUF"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_cflag",
            "CRTSCTS"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_openflags",
            "TIOCFLAG_CRTSCTS"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_cflag",
            "CLOCAL"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "cy->cy_openflags",
            "TIOCFLAG_CLOCAL"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttychars",
          "args": [
            "tp"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_state",
            "TS_WOPEN"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_ISOPEN"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tty_attach",
          "args": [
            "tp"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "zstty_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530tty.c",
          "lines": "210-303",
          "snippet": "void \nzstty_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid   *aux;\n\n{\n\tstruct zsc_softc *zsc = (void *) parent;\n\tstruct zstty_softc *zst = (void *) self;\n\tstruct zsc_attach_args *args = aux;\n\tstruct zs_chanstate *cs;\n\tstruct cfdata *cf;\n\tstruct tty *tp;\n\tint channel, tty_unit;\n\tdev_t dev;\n\n\tcf = zst->zst_dev.dv_cfdata;\n\ttty_unit = zst->zst_dev.dv_unit;\n\tchannel = args->channel;\n\tcs = &zsc->zsc_cs[channel];\n\tcs->cs_private = zst;\n\tcs->cs_ops = &zsops_tty;\n\n\tzst->zst_cs = cs;\n\tzst->zst_swflags = cf->cf_flags;\t/* softcar, etc. */\n\tzst->zst_hwflags = args->hwflags;\n\tdev = makedev(ZSTTY_MAJOR, tty_unit);\n\n\tif (zst->zst_swflags)\n\t\tprintf(\" flags 0x%x\", zst->zst_swflags);\n\n\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)\n\t\tprintf(\" (console)\");\n\telse {\n#ifdef KGDB\n\t\t/*\n\t\t * Allow kgdb to \"take over\" this port.  If this port is\n\t\t * NOT the kgdb port, zs_check_kgdb() will return zero.\n\t\t * If it IS the kgdb port, it will print \"kgdb,...\\n\"\n\t\t * and then return non-zero.\n\t\t */\n\t\tif (zs_check_kgdb(cs, dev)) {\n\t\t\t/*\n\t\t\t * This is the kgdb port (exclusive use)\n\t\t\t * so skip the normal attach code.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n#endif\n\t}\n\tprintf(\"\\n\");\n\n\ttp = ttymalloc();\n\ttp->t_dev = dev;\n\ttp->t_oproc = zsstart;\n\ttp->t_param = zsparam;\n\ttp->t_hwiflow = zshwiflow;\n\ttty_attach(tp);\n\n\tzst->zst_tty = tp;\n\tzst->zst_rbhiwat =  zstty_rbuf_size;\t/* impossible value */\n\tzst->zst_ringmask = zstty_rbuf_size - 1;\n\tzst->zst_rbuf = malloc(zstty_rbuf_size * sizeof(zst->zst_rbuf[0]),\n\t\t\t      M_DEVBUF, M_WAITOK);\n\n\t/*\n\t * Hardware init\n\t */\n\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE) {\n\t\t/* This unit is the console. */\n\t\tzst->zst_swflags |= TIOCFLAG_SOFTCAR;\n\t\t/* Call _param so interrupts get enabled. */\n\t\tcs->cs_defspeed = zs_getspeed(cs);\n\t\ttp->t_ispeed = cs->cs_defspeed;\n\t\ttp->t_ospeed = cs->cs_defspeed;\n\t\ttp->t_cflag = ZSTTY_DEF_CFLAG;\n\t\t(void) zsparam(tp, &tp->t_termios);\n\t} else {\n\t\t/* Not the console; may need reset. */\n\t\tint reset, s;\n\t\treset = (channel == 0) ?\n\t\t\tZSWR9_A_RESET : ZSWR9_B_RESET;\n\t\ts = splzs();\n\t\tzs_write_reg(cs, 9, reset);\n\t\tsplx(s);\n\t}\n\n\t/*\n\t * Initialize state of modem control lines (DTR).\n\t * If softcar is set, turn on DTR now and leave it.\n\t * otherwise, turn off DTR now, and raise in open.\n\t * (Keeps modem from answering too early.)\n\t */\n\tzs_modem(zst, (zst->zst_swflags & TIOCFLAG_SOFTCAR) ? 1 : 0);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tZSTTY_DEF_CFLAG\tTTYDEF_CFLAG"
          ],
          "globals_used": [
            "int zstty_rbuf_size = ZSTTY_RING_SIZE;",
            "static int\tzstty_match(struct device *, void *, void *);",
            "static void\tzstty_attach(struct device *, struct device *, void *);",
            "struct zsops zsops_tty;",
            "static void\tzsstart",
            "static int\tzsparam",
            "static void\tzs_modem",
            "static int\tzshwiflow",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "__P((register struct zs_chanstate *));",
            "struct tty *\nzstty(dev)\n\tdev_t dev;",
            "struct zsops zsops_tty = {\n\tzstty_rxint,\t/* receive char available */\n\tzstty_stint,\t/* external/status */\n\tzstty_txint,\t/* xmit buffer empty */\n\tzstty_softint,\t/* process software interrupt */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tZSTTY_DEF_CFLAG\tTTYDEF_CFLAG\n\nint zstty_rbuf_size = ZSTTY_RING_SIZE;\nstatic int\tzstty_match(struct device *, void *, void *);\nstatic void\tzstty_attach(struct device *, struct device *, void *);\nstruct zsops zsops_tty;\nstatic void\tzsstart;\nstatic int\tzsparam;\nstatic void\tzs_modem;\nstatic int\tzshwiflow;\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\n__P((register struct zs_chanstate *));\nstruct tty *\nzstty(dev)\n\tdev_t dev;\nstruct zsops zsops_tty = {\n\tzstty_rxint,\t/* receive char available */\n\tzstty_stint,\t/* external/status */\n\tzstty_txint,\t/* xmit buffer empty */\n\tzstty_softint,\t/* process software interrupt */\n};\n\nvoid \nzstty_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid   *aux;\n\n{\n\tstruct zsc_softc *zsc = (void *) parent;\n\tstruct zstty_softc *zst = (void *) self;\n\tstruct zsc_attach_args *args = aux;\n\tstruct zs_chanstate *cs;\n\tstruct cfdata *cf;\n\tstruct tty *tp;\n\tint channel, tty_unit;\n\tdev_t dev;\n\n\tcf = zst->zst_dev.dv_cfdata;\n\ttty_unit = zst->zst_dev.dv_unit;\n\tchannel = args->channel;\n\tcs = &zsc->zsc_cs[channel];\n\tcs->cs_private = zst;\n\tcs->cs_ops = &zsops_tty;\n\n\tzst->zst_cs = cs;\n\tzst->zst_swflags = cf->cf_flags;\t/* softcar, etc. */\n\tzst->zst_hwflags = args->hwflags;\n\tdev = makedev(ZSTTY_MAJOR, tty_unit);\n\n\tif (zst->zst_swflags)\n\t\tprintf(\" flags 0x%x\", zst->zst_swflags);\n\n\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE)\n\t\tprintf(\" (console)\");\n\telse {\n#ifdef KGDB\n\t\t/*\n\t\t * Allow kgdb to \"take over\" this port.  If this port is\n\t\t * NOT the kgdb port, zs_check_kgdb() will return zero.\n\t\t * If it IS the kgdb port, it will print \"kgdb,...\\n\"\n\t\t * and then return non-zero.\n\t\t */\n\t\tif (zs_check_kgdb(cs, dev)) {\n\t\t\t/*\n\t\t\t * This is the kgdb port (exclusive use)\n\t\t\t * so skip the normal attach code.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n#endif\n\t}\n\tprintf(\"\\n\");\n\n\ttp = ttymalloc();\n\ttp->t_dev = dev;\n\ttp->t_oproc = zsstart;\n\ttp->t_param = zsparam;\n\ttp->t_hwiflow = zshwiflow;\n\ttty_attach(tp);\n\n\tzst->zst_tty = tp;\n\tzst->zst_rbhiwat =  zstty_rbuf_size;\t/* impossible value */\n\tzst->zst_ringmask = zstty_rbuf_size - 1;\n\tzst->zst_rbuf = malloc(zstty_rbuf_size * sizeof(zst->zst_rbuf[0]),\n\t\t\t      M_DEVBUF, M_WAITOK);\n\n\t/*\n\t * Hardware init\n\t */\n\tif (zst->zst_hwflags & ZS_HWFLAG_CONSOLE) {\n\t\t/* This unit is the console. */\n\t\tzst->zst_swflags |= TIOCFLAG_SOFTCAR;\n\t\t/* Call _param so interrupts get enabled. */\n\t\tcs->cs_defspeed = zs_getspeed(cs);\n\t\ttp->t_ispeed = cs->cs_defspeed;\n\t\ttp->t_ospeed = cs->cs_defspeed;\n\t\ttp->t_cflag = ZSTTY_DEF_CFLAG;\n\t\t(void) zsparam(tp, &tp->t_termios);\n\t} else {\n\t\t/* Not the console; may need reset. */\n\t\tint reset, s;\n\t\treset = (channel == 0) ?\n\t\t\tZSWR9_A_RESET : ZSWR9_B_RESET;\n\t\ts = splzs();\n\t\tzs_write_reg(cs, 9, reset);\n\t\tsplx(s);\n\t}\n\n\t/*\n\t * Initialize state of modem control lines (DTR).\n\t * If softcar is set, turn on DTR now and leave it.\n\t * otherwise, turn off DTR now, and raise in open.\n\t * (Keeps modem from answering too early.)\n\t */\n\tzs_modem(zst, (zst->zst_swflags & TIOCFLAG_SOFTCAR) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttymalloc",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_PORT",
          "args": [
            "dev"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CY_CARD",
          "args": [
            "dev"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncyopen(dev, flag, mode, p)\n     dev_t dev;\n     int flag, mode;\n     struct proc *p;\n{\n    int card = CY_CARD(dev);\n    int port = CY_PORT(dev);\n    struct cy_softc *sc;\n    struct cy_port *cy;\n    struct tty *tp;\n    int s, error;\n\n#ifdef CY_DEBUG\n    printf(\"cy%d open port %d flag 0x%x mode 0x%x\\n\",\n\t   card, port, flag, mode);\n#endif\n\n    if(card >= cy_cd.cd_ndevs ||\n       (sc = cy_cd.cd_devs[card]) == NULL)\n      return ENXIO;\n\n    cy = &sc->sc_ports[port];\n\n    s = spltty();\n    if(cy->cy_tty == NULL) {\n\tif((cy->cy_tty = ttymalloc()) == NULL) {\n\t    splx(s);\n\t    printf(\"cy%d port %d open: can't allocate tty\\n\", card, port);\n\t    return ENOMEM;\n\t}\n    }\n    splx(s);\n\n    tp = cy->cy_tty;\n    tty_attach(tp);\n    tp = cy->cy_tty;\n    tp->t_oproc = cystart;\n    tp->t_param = cyparam;\n    tp->t_dev = dev;\n\n    if(!ISSET(tp->t_state, TS_ISOPEN)) {\n\tSET(tp->t_state, TS_WOPEN);\n\tttychars(tp);\n\ttp->t_iflag = TTYDEF_IFLAG;\n\ttp->t_oflag = TTYDEF_OFLAG;\n\ttp->t_cflag = TTYDEF_CFLAG;\n\tif(ISSET(cy->cy_openflags, TIOCFLAG_CLOCAL))\n\t  SET(tp->t_cflag, CLOCAL);\n\tif(ISSET(cy->cy_openflags, TIOCFLAG_CRTSCTS))\n\t  SET(tp->t_cflag, CRTSCTS);\n\tif(ISSET(cy->cy_openflags, TIOCFLAG_MDMBUF))\n\t  SET(tp->t_cflag, MDMBUF);\n\ttp->t_lflag = TTYDEF_LFLAG;\n\ttp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;\n\n\ts = spltty();\n\n\t/*\n\t * Allocate input ring buffer if we don't already have one\n\t */\n\tif(cy->cy_ibuf == NULL) {\n\t    cy->cy_ibuf = malloc(IBUF_SIZE, M_DEVBUF, M_NOWAIT);\n\t    if(cy->cy_ibuf == NULL) {\n\t\tprintf(\"cy%d: (port %d) can't allocate input buffer\\n\",\n\t\t       card, port);\n\t\tsplx(s);\n\t\treturn ENOMEM;\n\t    }\n\t    cy->cy_ibuf_end = cy->cy_ibuf + IBUF_SIZE;\n\t}\n\n\t/* mark the ring buffer as empty */\n\tcy->cy_ibuf_rd_ptr = cy->cy_ibuf_wr_ptr = cy->cy_ibuf;\n\n\t/* select CD1400 channel */\n\tcd_write_reg(cy, CD1400_CAR, port & CD1400_CAR_CHAN);\n\t/* reset the channel */\n\tcd1400_channel_cmd(cy, CD1400_CCR_CMDRESET);\n\t/* encode unit (port) number in LIVR */\n\t/* there is just enough space for 5 bits (32 ports) */\n\tcd_write_reg(cy, CD1400_LIVR, port << 3);\n\n\tcy->cy_channel_control = 0;\n\n\t/* hmm... need spltty() here? */\n\tif(cy_open == 0)\n\t  {\n\t    cy_open = 1;\n\t    timeout(cy_poll, NULL, 1);\n\t  }\n\n\t/* this sets parameters and raises DTR */\n\tcyparam(tp, &tp->t_termios);\n\n\tttsetwater(tp);\n\n\t/* raise RTS too */\n\tcy_modem_control(cy, TIOCM_RTS, DMBIS);\n\n\tcy->cy_carrier_stat =\n\t  cd_read_reg(cy, CD1400_MSVR2);\n\n\t/* enable receiver and modem change interrupts */\n\tcd_write_reg(cy, CD1400_SRER, CD1400_SRER_MDMCH | CD1400_SRER_RXDATA);\n\n\tif(CY_DIALOUT(dev) ||\n\t   ISSET(cy->cy_openflags, TIOCFLAG_SOFTCAR) ||\n\t   ISSET(tp->t_cflag, MDMBUF) ||\n\t   ISSET(cy->cy_carrier_stat, CD1400_MSVR2_CD))\n\t  SET(tp->t_state, TS_CARR_ON);\n\telse\n\t  CLR(tp->t_state, TS_CARR_ON);\n    } else if(ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0) {\n\treturn EBUSY;\n    } else {\n\ts = spltty();\n    }\n\n    /* wait for carrier if necessary */\n    if(!ISSET(flag, O_NONBLOCK)) {\n\twhile(!ISSET(tp->t_cflag, CLOCAL) &&\n\t    !ISSET(tp->t_state, TS_CARR_ON)) {\n\t    SET(tp->t_state, TS_WOPEN);\n\t    error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH, \"cydcd\", 0);\n\t    if(error != 0) {\n\t\tsplx(s);\n\t\tCLR(tp->t_state, TS_WOPEN);\n\t\treturn error;\n\t    }\n\t}\n    }\n\n    splx(s);\n\n    return (*linesw[tp->t_line].l_open)(dev, tp);\n}"
  },
  {
    "function_name": "cyattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "199-300",
    "snippet": "void\ncyattach(parent, self, aux)\n     struct device *parent, *self;\n     void *aux;\n{\n  struct cy_softc *sc = (void *)self;\n  int card, port, cy_chip, num_chips, cdu, chip_offs;\n\n  card = sc->sc_dev.dv_unit;\n  num_chips = cy_nr_cd1400s[card];\n  if(num_chips == 0)\n    return;\n\n  sc->sc_bustype = cy_bus_types[card];\n  sc->sc_memh = cy_card_memh[card];\n  switch(sc->sc_bustype) {\n#if NCY_ISA > 0\n    case CY_BUSTYPE_ISA:\n      sc->sc_memt = ((struct isa_attach_args *)(aux))->ia_memt;\n      break;\n#endif\n#if NCY_PCI > 0\n    case CY_BUSTYPE_PCI:\n      sc->sc_memt = ((struct pci_attach_args *)aux)->pa_memt;\n      break;\n#endif\n  }\n\n  bzero(sc->sc_ports, sizeof(sc->sc_ports));\n  sc->sc_nports = num_chips * CD1400_NO_OF_CHANNELS;\n\n  port = 0;\n  for(cy_chip = 0, chip_offs = 0;\n      cy_chip < num_chips; cy_chip++,\n      chip_offs += (CY_CD1400_MEMSPACING<<sc->sc_bustype)) {\n\n    if(cy_chip == 4)\n      chip_offs -= (CY32_ADDR_FIX<<sc->sc_bustype);\n\n#ifdef CY_DEBUG\n    printf(\"attach CD1400 #%d offset 0x%x\\n\", cy_chip, chip_offs);\n#endif\n    sc->sc_cd1400_offs[cy_chip] = chip_offs;\n\n    /* configure port 0 as serial port (should already be after reset) */\n    cd_write_reg_sc(sc, cy_chip, CD1400_GCR, 0);\n\n    /* set up a receive timeout period (1ms) */\n    cd_write_reg_sc(sc, cy_chip, CD1400_PPR,\n\t\t    (CY_CLOCK / CD1400_PPR_PRESCALER / 1000) + 1);\n\n    for(cdu = 0; cdu < CD1400_NO_OF_CHANNELS; cdu++) {\n      sc->sc_ports[port].cy_port_num = port;\n      sc->sc_ports[port].cy_memt = sc->sc_memt;\n      sc->sc_ports[port].cy_memh = sc->sc_memh;\n      sc->sc_ports[port].cy_chip_offs = chip_offs;\n      sc->sc_ports[port].cy_bustype = sc->sc_bustype;\n\n      /* should we initialize anything else here? */\n      port++;\n    } /* for(each port on one CD1400...) */\n\n  } /* for(each CD1400 on a card... ) */\n\n  printf(\" (%d ports)\\n\", port);\n\n  /* ensure an edge for the next interrupt */\n  bus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t  CY_CLEAR_INTR<<sc->sc_bustype, 0);\n\n  switch(sc->sc_bustype) {\n#if NCY_ISA > 0\n    case CY_BUSTYPE_ISA:\n      {\n\tstruct isa_attach_args *ia = aux;\n\n\tsc->sc_ih =\n\t  isa_intr_establish(ia->ia_ic, ia->ia_irq,\n\t    IST_EDGE, IPL_TTY, cyintr, sc, sc->sc_dev.dv_xname);\n      }\n      break;\n#endif /* NCY_ISA > 0 */\n#if NCY_PCI > 0\n    case CY_BUSTYPE_PCI:\n      {\n\tpci_intr_handle_t intrhandle;\n\tstruct pci_attach_args *pa = aux;\n\n\tif(pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t\tpa->pa_intrline, &intrhandle) != 0)\n\t  panic(\"cy: couldn't map PCI interrupt\");\n\n\tsc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle,\n\t  IPL_TTY, cyintr, sc, sc->sc_dev.dv_xname);\n      }\n      break;\n#endif /* NCY_PCI > 0 */\n  }\n\n  if(sc->sc_ih == NULL)\n    panic(\"cy: couldn't establish interrupt\");\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"cy: couldn't establish interrupt\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pa->pa_pc",
            "intrhandle",
            "IPL_TTY",
            "cyintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"cy: couldn't map PCI interrupt\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pa->pa_pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&intrhandle"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_TTY",
            "cyintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "CY_CLEAR_INTR<<sc->sc_bustype",
            "0"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" (%d ports)\\n\"",
            "port"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd_write_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_PPR",
            "(CY_CLOCK / CD1400_PPR_PRESCALER / 1000) + 1"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd_write_reg_sc",
          "args": [
            "sc",
            "cy_chip",
            "CD1400_GCR",
            "0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->sc_ports",
            "sizeof(sc->sc_ports)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nvoid\ncyattach(parent, self, aux)\n     struct device *parent, *self;\n     void *aux;\n{\n  struct cy_softc *sc = (void *)self;\n  int card, port, cy_chip, num_chips, cdu, chip_offs;\n\n  card = sc->sc_dev.dv_unit;\n  num_chips = cy_nr_cd1400s[card];\n  if(num_chips == 0)\n    return;\n\n  sc->sc_bustype = cy_bus_types[card];\n  sc->sc_memh = cy_card_memh[card];\n  switch(sc->sc_bustype) {\n#if NCY_ISA > 0\n    case CY_BUSTYPE_ISA:\n      sc->sc_memt = ((struct isa_attach_args *)(aux))->ia_memt;\n      break;\n#endif\n#if NCY_PCI > 0\n    case CY_BUSTYPE_PCI:\n      sc->sc_memt = ((struct pci_attach_args *)aux)->pa_memt;\n      break;\n#endif\n  }\n\n  bzero(sc->sc_ports, sizeof(sc->sc_ports));\n  sc->sc_nports = num_chips * CD1400_NO_OF_CHANNELS;\n\n  port = 0;\n  for(cy_chip = 0, chip_offs = 0;\n      cy_chip < num_chips; cy_chip++,\n      chip_offs += (CY_CD1400_MEMSPACING<<sc->sc_bustype)) {\n\n    if(cy_chip == 4)\n      chip_offs -= (CY32_ADDR_FIX<<sc->sc_bustype);\n\n#ifdef CY_DEBUG\n    printf(\"attach CD1400 #%d offset 0x%x\\n\", cy_chip, chip_offs);\n#endif\n    sc->sc_cd1400_offs[cy_chip] = chip_offs;\n\n    /* configure port 0 as serial port (should already be after reset) */\n    cd_write_reg_sc(sc, cy_chip, CD1400_GCR, 0);\n\n    /* set up a receive timeout period (1ms) */\n    cd_write_reg_sc(sc, cy_chip, CD1400_PPR,\n\t\t    (CY_CLOCK / CD1400_PPR_PRESCALER / 1000) + 1);\n\n    for(cdu = 0; cdu < CD1400_NO_OF_CHANNELS; cdu++) {\n      sc->sc_ports[port].cy_port_num = port;\n      sc->sc_ports[port].cy_memt = sc->sc_memt;\n      sc->sc_ports[port].cy_memh = sc->sc_memh;\n      sc->sc_ports[port].cy_chip_offs = chip_offs;\n      sc->sc_ports[port].cy_bustype = sc->sc_bustype;\n\n      /* should we initialize anything else here? */\n      port++;\n    } /* for(each port on one CD1400...) */\n\n  } /* for(each CD1400 on a card... ) */\n\n  printf(\" (%d ports)\\n\", port);\n\n  /* ensure an edge for the next interrupt */\n  bus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t  CY_CLEAR_INTR<<sc->sc_bustype, 0);\n\n  switch(sc->sc_bustype) {\n#if NCY_ISA > 0\n    case CY_BUSTYPE_ISA:\n      {\n\tstruct isa_attach_args *ia = aux;\n\n\tsc->sc_ih =\n\t  isa_intr_establish(ia->ia_ic, ia->ia_irq,\n\t    IST_EDGE, IPL_TTY, cyintr, sc, sc->sc_dev.dv_xname);\n      }\n      break;\n#endif /* NCY_ISA > 0 */\n#if NCY_PCI > 0\n    case CY_BUSTYPE_PCI:\n      {\n\tpci_intr_handle_t intrhandle;\n\tstruct pci_attach_args *pa = aux;\n\n\tif(pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t\tpa->pa_intrline, &intrhandle) != 0)\n\t  panic(\"cy: couldn't map PCI interrupt\");\n\n\tsc->sc_ih = pci_intr_establish(pa->pa_pc, intrhandle,\n\t  IPL_TTY, cyintr, sc, sc->sc_dev.dv_xname);\n      }\n      break;\n#endif /* NCY_PCI > 0 */\n  }\n\n  if(sc->sc_ih == NULL)\n    panic(\"cy: couldn't establish interrupt\");\n}"
  },
  {
    "function_name": "cy_probe_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/cy.c",
    "lines": "94-194",
    "snippet": "int\ncy_probe_common(card, memt, memh, bustype)\n     int card, bustype;\n     bus_space_tag_t memt;\n     bus_space_handle_t memh;\n{\n  int cy_chip, chip_offs;\n  u_char firmware_ver;\n\n  /* Cyclom card hardware reset */\n  bus_space_write_1(memt, memh, CY16_RESET<<bustype, 0);\n  DELAY(500); /* wait for reset to complete */\n  bus_space_write_1(memt, memh, CY_CLEAR_INTR<<bustype, 0);\n\n#ifdef CY_DEBUG\n  printf(\"cy: card reset done\\n\");\n#endif\n\n  cy_nr_cd1400s[card] = 0;\n\n  for(cy_chip = 0, chip_offs = 0;\n      cy_chip < CY_MAX_CD1400s;\n      cy_chip++, chip_offs += (CY_CD1400_MEMSPACING<<bustype)) {\n    int i;\n\n    /* the last 4 cd1400s are 'interleaved'\n       with the first 4 on 32-port boards */\n    if(cy_chip == 4)\n      chip_offs -= (CY32_ADDR_FIX<<bustype);\n\n#ifdef CY_DEBUG\n    printf(\"cy%d probe chip %d offset 0x%lx ... \",\n\t   card, cy_chip, chip_offs);\n#endif\n\n    /* wait until the chip is ready for command */\n    DELAY(1000);\n    if(bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_CCR<<1) << bustype)) != 0) {\n#ifdef CY_DEBUG\n      printf(\"not ready for command\\n\");\n#endif\n      break;\n    }\n\n    /* clear the firmware version reg. */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_GFRCR<<1) << bustype), 0);\n\n    /*\n     * On Cyclom-16 references to non-existent chip 4\n     * actually access chip 0 (address line 9 not decoded).\n     * Here we check if the clearing of chip 4 GFRCR actually\n     * cleared chip 0 GFRCR. In that case we have a 16 port card.\n     */\n    if(cy_chip == 4 &&\n       bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_GFRCR<<1) << bustype)) ==0)\n      break;\n\n    /* reset the chip */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_CCR<<1) << bustype),\n\t\t    CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);\n\n    /* wait for the chip to initialize itself */\n    for(i = 0; i < 200; i++) {\n      DELAY(50);\n      firmware_ver =\n\tbus_space_read_1(memt, memh, chip_offs +\n\t\t       ((CD1400_GFRCR<<1) << bustype));\n      if((firmware_ver & 0xf0) == 0x40) /* found a CD1400 */\n\tbreak;\n    }\n#ifdef CY_DEBUG\n    printf(\"firmware version 0x%x\\n\", firmware_ver);\n#endif      \n\n    if((firmware_ver & 0xf0) != 0x40)\n      break;\n\n    /* firmware version OK, CD1400 found */\n    cy_nr_cd1400s[card]++;\n  }\n\n  if(cy_nr_cd1400s[card] == 0) {\n#ifdef CY_DEBUG\n    printf(\"no CD1400s found\\n\");\n#endif\n    return 0;\n  }\n\n#ifdef CY_DEBUG\n  printf(\"found %d CD1400s\\n\", cy_nr_cd1400s[card]);\n#endif\n\n  cy_card_memh[card] = memh;\n  cy_bus_types[card] = bustype;\n\n  return 1;\n}",
    "includes": [
      "#include <dev/ic/cyreg.h>",
      "#include <dev/ic/cd1400reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/systm.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/user.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/tty.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>",
      "#include \"cy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"found %d CD1400s\\n\"",
            "cy_nr_cd1400s[card]"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "memh",
            "chip_offs +\n\t\t       ((CD1400_GFRCR<<1) << bustype)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "memt",
            "memh",
            "chip_offs +\n\t\t    ((CD1400_CCR<<1) << bustype)",
            "CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "memh",
            "chip_offs +\n\t\t      ((CD1400_GFRCR<<1) << bustype)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "memt",
            "memh",
            "chip_offs +\n\t\t    ((CD1400_GFRCR<<1) << bustype)",
            "0"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "memh",
            "chip_offs +\n\t\t      ((CD1400_CCR<<1) << bustype)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "memt",
            "memh",
            "CY_CLEAR_INTR<<bustype",
            "0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "500"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "memt",
            "memh",
            "CY16_RESET<<bustype",
            "0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/cyreg.h>\n#include <dev/ic/cd1400reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/isa/isareg.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/systm.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/user.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/tty.h>\n#include <sys/fcntl.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#include \"cy.h\"\n\nint\ncy_probe_common(card, memt, memh, bustype)\n     int card, bustype;\n     bus_space_tag_t memt;\n     bus_space_handle_t memh;\n{\n  int cy_chip, chip_offs;\n  u_char firmware_ver;\n\n  /* Cyclom card hardware reset */\n  bus_space_write_1(memt, memh, CY16_RESET<<bustype, 0);\n  DELAY(500); /* wait for reset to complete */\n  bus_space_write_1(memt, memh, CY_CLEAR_INTR<<bustype, 0);\n\n#ifdef CY_DEBUG\n  printf(\"cy: card reset done\\n\");\n#endif\n\n  cy_nr_cd1400s[card] = 0;\n\n  for(cy_chip = 0, chip_offs = 0;\n      cy_chip < CY_MAX_CD1400s;\n      cy_chip++, chip_offs += (CY_CD1400_MEMSPACING<<bustype)) {\n    int i;\n\n    /* the last 4 cd1400s are 'interleaved'\n       with the first 4 on 32-port boards */\n    if(cy_chip == 4)\n      chip_offs -= (CY32_ADDR_FIX<<bustype);\n\n#ifdef CY_DEBUG\n    printf(\"cy%d probe chip %d offset 0x%lx ... \",\n\t   card, cy_chip, chip_offs);\n#endif\n\n    /* wait until the chip is ready for command */\n    DELAY(1000);\n    if(bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_CCR<<1) << bustype)) != 0) {\n#ifdef CY_DEBUG\n      printf(\"not ready for command\\n\");\n#endif\n      break;\n    }\n\n    /* clear the firmware version reg. */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_GFRCR<<1) << bustype), 0);\n\n    /*\n     * On Cyclom-16 references to non-existent chip 4\n     * actually access chip 0 (address line 9 not decoded).\n     * Here we check if the clearing of chip 4 GFRCR actually\n     * cleared chip 0 GFRCR. In that case we have a 16 port card.\n     */\n    if(cy_chip == 4 &&\n       bus_space_read_1(memt, memh, chip_offs +\n\t\t      ((CD1400_GFRCR<<1) << bustype)) ==0)\n      break;\n\n    /* reset the chip */\n    bus_space_write_1(memt, memh, chip_offs +\n\t\t    ((CD1400_CCR<<1) << bustype),\n\t\t    CD1400_CCR_CMDRESET | CD1400_CCR_FULLRESET);\n\n    /* wait for the chip to initialize itself */\n    for(i = 0; i < 200; i++) {\n      DELAY(50);\n      firmware_ver =\n\tbus_space_read_1(memt, memh, chip_offs +\n\t\t       ((CD1400_GFRCR<<1) << bustype));\n      if((firmware_ver & 0xf0) == 0x40) /* found a CD1400 */\n\tbreak;\n    }\n#ifdef CY_DEBUG\n    printf(\"firmware version 0x%x\\n\", firmware_ver);\n#endif      \n\n    if((firmware_ver & 0xf0) != 0x40)\n      break;\n\n    /* firmware version OK, CD1400 found */\n    cy_nr_cd1400s[card]++;\n  }\n\n  if(cy_nr_cd1400s[card] == 0) {\n#ifdef CY_DEBUG\n    printf(\"no CD1400s found\\n\");\n#endif\n    return 0;\n  }\n\n#ifdef CY_DEBUG\n  printf(\"found %d CD1400s\\n\", cy_nr_cd1400s[card]);\n#endif\n\n  cy_card_memh[card] = memh;\n  cy_bus_types[card] = bustype;\n\n  return 1;\n}"
  }
]