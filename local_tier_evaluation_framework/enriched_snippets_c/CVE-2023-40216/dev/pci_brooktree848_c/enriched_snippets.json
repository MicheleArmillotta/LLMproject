[
  {
    "function_name": "bktr_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8573-8593",
    "snippet": "int\nbktr_mmap( dev_t dev, vm_offset_t offset, int nprot )\n{\n\tint\t\tunit;\n\tbktr_ptr_t\tbktr;\n\n\tunit = UNIT(minor(dev));\n\n\tif (unit >= NBKTR || FUNCTION(minor(dev)) > 0)\n\t\treturn( -1 );\n\n\tbktr = bktr_cd.cd_devs[unit];\n\n\tif (offset < 0)\n\t\treturn( -1 );\n\n\tif (offset >= bktr->alloc_pages * PAGE_SIZE)\n\t\treturn( -1 );\n\n\treturn( i386_btop(vtophys(bktr->bigbuf) + offset) );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define bktr_mmap       bktrmmap",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define NBKTR bktrcd.cd_ndevs"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i386_btop",
          "args": [
            "vtophys(bktr->bigbuf) + offset"
          ],
          "line": 8592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->bigbuf"
          ],
          "line": 8592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 8581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 8579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define bktr_mmap       bktrmmap\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define NBKTR bktrcd.cd_ndevs\n\nint\nbktr_mmap( dev_t dev, vm_offset_t offset, int nprot )\n{\n\tint\t\tunit;\n\tbktr_ptr_t\tbktr;\n\n\tunit = UNIT(minor(dev));\n\n\tif (unit >= NBKTR || FUNCTION(minor(dev)) > 0)\n\t\treturn( -1 );\n\n\tbktr = bktr_cd.cd_devs[unit];\n\n\tif (offset < 0)\n\t\treturn( -1 );\n\n\tif (offset >= bktr->alloc_pages * PAGE_SIZE)\n\t\treturn( -1 );\n\n\treturn( i386_btop(vtophys(bktr->bigbuf) + offset) );\n}"
  },
  {
    "function_name": "bktr_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8545-8568",
    "snippet": "int\nbktr_ioctl( dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = bktr_cd.cd_devs[unit];\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_ioctl( bktr, unit, cmd, arg, pr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_ioctl( bktr, unit, cmd, arg, pr ) );\n\t}\n\n\treturn( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_ioctl      bktrioctl",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuner_ioctl",
          "args": [
            "bktr",
            "unit",
            "cmd",
            "arg",
            "pr"
          ],
          "line": 8564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "video_ioctl",
          "args": [
            "bktr",
            "unit",
            "cmd",
            "arg",
            "pr"
          ],
          "line": 8562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 8560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 8551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_ioctl      bktrioctl\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define NBKTR bktrcd.cd_ndevs\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n\nint\nbktr_ioctl( dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = bktr_cd.cd_devs[unit];\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_ioctl( bktr, unit, cmd, arg, pr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_ioctl( bktr, unit, cmd, arg, pr ) );\n\t}\n\n\treturn( ENXIO );\n}"
  },
  {
    "function_name": "bktr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8536-8540",
    "snippet": "int\nbktr_write( dev_t dev, struct uio *uio, int ioflag )\n{\n\treturn( EINVAL ); /* XXX or ENXIO ? */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define bktr_write      bktrwrite"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define bktr_write      bktrwrite\n\nint\nbktr_write( dev_t dev, struct uio *uio, int ioflag )\n{\n\treturn( EINVAL ); /* XXX or ENXIO ? */\n}"
  },
  {
    "function_name": "bktr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8510-8530",
    "snippet": "int\nbktr_read( dev_t dev, struct uio *uio, int ioflag )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\t\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = bktr_cd.cd_devs[unit];\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_read( bktr, unit, dev, uio ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_read( bktr, dev, uio ) );\n\t}\n\n        return( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_read       bktrread",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbi_read",
          "args": [
            "bktr",
            "dev",
            "uio"
          ],
          "line": 8526
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2142-2177",
          "snippet": "static int\nvbi_read(bktr_ptr_t bktr, dev_t dev, struct uio *uio)\n{\n\tint             readsize, readsize2;\n\tint             status;\n\n\tif(bktr->vbisize == 0)\n\t\tstatus = tsleep(VBI_SLEEP, BKTRPRI, \"vbi\", 0);\n\n\treadsize = (int)uio->uio_iov->iov_len;\n\n\t/* We cannot read more bytes than there are in the circular buffer */\n\tif (readsize > bktr->vbisize) readsize = bktr->vbisize;\n\n\t/* Check if we can read this number of bytes without having to wrap around the circular buffer */\n\tif((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {\n\t\t/* We need to wrap around */\n\n                readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);\n                status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);\n        } else {\n\t\t/* We do not need to wrap around */\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);\n        }\n\n\t/* Update the number of bytes left to read */\n        bktr->vbisize -= readsize;\n\n\t/* Update vbistart */\n        bktr->vbistart += readsize;\n\tbktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */\n\n        return( status );\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VBI_SLEEP   ((caddr_t)bktr + 1)",
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define BKTRPRI (PZERO+8)|PCATCH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_SLEEP   ((caddr_t)bktr + 1)\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define BKTRPRI (PZERO+8)|PCATCH\n\nstatic int\nvbi_read(bktr_ptr_t bktr, dev_t dev, struct uio *uio)\n{\n\tint             readsize, readsize2;\n\tint             status;\n\n\tif(bktr->vbisize == 0)\n\t\tstatus = tsleep(VBI_SLEEP, BKTRPRI, \"vbi\", 0);\n\n\treadsize = (int)uio->uio_iov->iov_len;\n\n\t/* We cannot read more bytes than there are in the circular buffer */\n\tif (readsize > bktr->vbisize) readsize = bktr->vbisize;\n\n\t/* Check if we can read this number of bytes without having to wrap around the circular buffer */\n\tif((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {\n\t\t/* We need to wrap around */\n\n                readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);\n                status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);\n        } else {\n\t\t/* We do not need to wrap around */\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);\n        }\n\n\t/* Update the number of bytes left to read */\n        bktr->vbisize -= readsize;\n\n\t/* Update vbistart */\n        bktr->vbistart += readsize;\n\tbktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */\n\n        return( status );\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_read",
          "args": [
            "bktr",
            "unit",
            "dev",
            "uio"
          ],
          "line": 8524
        },
        "resolved": true,
        "details": {
          "function_name": "video_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2085-2133",
          "snippet": "static int\nvideo_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)\n{\n        bt848_ptr_t     bt848;\n        int             status;\n        int             count;\n\n\n        bt848 = bktr->base;\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tif (bktr->flags & METEOR_CAP_MASK)\n\t\treturn( EIO );\t/* already capturing */\n\n        bt848->cap_ctl = bktr->bktr_cap_ctl;\n\n\n\tcount = bktr->rows * bktr->cols * \n\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp;\n\n\tif ((int) uio->uio_iov->iov_len < count)\n\t\treturn( EINVAL );\n\n\tbktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);\n\n\t/* capture one frame */\n\tstart_capture(bktr, METEOR_SINGLE);\n\t/* wait for capture to complete */\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n                          BT848_INT_RISCI      |\n                          BT848_INT_VSYNC      |\n                          BT848_INT_FMTCHG;\n\n\n\tstatus = tsleep(BKTR_SLEEP, BKTRPRI, \"captur\", 0);\n\tif (!status)\t\t/* successful capture */\n\t\tstatus = uiomove((caddr_t)bktr->bigbuf, count, uio);\n\telse\n\t\tprintf (\"bktr%d: read: tsleep error %d\\n\", unit, status);\n\n\tbktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);\n\n\treturn( status );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ALL_INTS_CLEARED\t0xffffffff",
            "#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN",
            "#define BKTR_SLEEP  ((caddr_t)bktr    )",
            "#define BKTRPRI (PZERO+8)|PCATCH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALL_INTS_CLEARED\t0xffffffff\n#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n#define BKTRPRI (PZERO+8)|PCATCH\n\nstatic int\nvideo_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)\n{\n        bt848_ptr_t     bt848;\n        int             status;\n        int             count;\n\n\n        bt848 = bktr->base;\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tif (bktr->flags & METEOR_CAP_MASK)\n\t\treturn( EIO );\t/* already capturing */\n\n        bt848->cap_ctl = bktr->bktr_cap_ctl;\n\n\n\tcount = bktr->rows * bktr->cols * \n\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp;\n\n\tif ((int) uio->uio_iov->iov_len < count)\n\t\treturn( EINVAL );\n\n\tbktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);\n\n\t/* capture one frame */\n\tstart_capture(bktr, METEOR_SINGLE);\n\t/* wait for capture to complete */\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n                          BT848_INT_RISCI      |\n                          BT848_INT_VSYNC      |\n                          BT848_INT_FMTCHG;\n\n\n\tstatus = tsleep(BKTR_SLEEP, BKTRPRI, \"captur\", 0);\n\tif (!status)\t\t/* successful capture */\n\t\tstatus = uiomove((caddr_t)bktr->bigbuf, count, uio);\n\telse\n\t\tprintf (\"bktr%d: read: tsleep error %d\\n\", unit, status);\n\n\tbktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);\n\n\treturn( status );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 8522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 8516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define bktr_read       bktrread\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define NBKTR bktrcd.cd_ndevs\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n\nint\nbktr_read( dev_t dev, struct uio *uio, int ioflag )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\t\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = bktr_cd.cd_devs[unit];\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_read( bktr, unit, dev, uio ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_read( bktr, dev, uio ) );\n\t}\n\n        return( ENXIO );\n}"
  },
  {
    "function_name": "bktr_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8483-8505",
    "snippet": "int\nbktr_close( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR)\t\t\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = bktr_cd.cd_devs[unit];\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_close( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_close( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_close( bktr ) );\n\t}\n\n\treturn( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_close      bktrclose",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbi_close",
          "args": [
            "bktr"
          ],
          "line": 8501
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2073-2080",
          "snippet": "static int\nvbi_close( bktr_ptr_t bktr )\n{\n\n\tbktr->vbiflags &= ~VBI_OPEN;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nvbi_close( bktr_ptr_t bktr )\n{\n\n\tbktr->vbiflags &= ~VBI_OPEN;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuner_close",
          "args": [
            "bktr"
          ],
          "line": 8499
        },
        "resolved": true,
        "details": {
          "function_name": "tuner_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2059-2071",
          "snippet": "static int\ntuner_close( bktr_ptr_t bktr )\n{\n\tbktr->tflags &= ~TUNER_OPEN;\n\n\t/* mute the audio by switching the mux */\n\tset_audio( bktr, AUDIO_MUTE );\n\n\t/* disable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en = bktr->base->gpio_out_en & ~bktr->card.gpio_mux_bits;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_close( bktr_ptr_t bktr )\n{\n\tbktr->tflags &= ~TUNER_OPEN;\n\n\t/* mute the audio by switching the mux */\n\tset_audio( bktr, AUDIO_MUTE );\n\n\t/* disable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en = bktr->base->gpio_out_en & ~bktr->card.gpio_mux_bits;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_close",
          "args": [
            "bktr"
          ],
          "line": 8497
        },
        "resolved": true,
        "details": {
          "function_name": "video_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2029-2052",
          "snippet": "static int\nvideo_close( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t\tbt848;\n\n\tbktr->flags &= ~(METEOR_OPEN     |\n\t\t\t METEOR_SINGLE   |\n\t\t\t METEOR_CAP_MASK |\n\t\t\t METEOR_WANT_MASK);\n\n\tbt848 = bktr->base;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->cap_ctl = CAPTURE_OFF;\n\n\tbktr->dma_prog_loaded = FALSE;\n\tbt848->tdec = 0;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */\n\tbt848->sreset = 0xf;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define CAPTURE_OFF\t\t0",
            "#define ALL_INTS_CLEARED\t0xffffffff",
            "#define ALL_INTS_DISABLED\t0",
            "#define FIFO_RISC_DISABLED\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CAPTURE_OFF\t\t0\n#define ALL_INTS_CLEARED\t0xffffffff\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n\nstatic int\nvideo_close( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t\tbt848;\n\n\tbktr->flags &= ~(METEOR_OPEN     |\n\t\t\t METEOR_SINGLE   |\n\t\t\t METEOR_CAP_MASK |\n\t\t\t METEOR_WANT_MASK);\n\n\tbt848 = bktr->base;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->cap_ctl = CAPTURE_OFF;\n\n\tbktr->dma_prog_loaded = FALSE;\n\tbt848->tdec = 0;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */\n\tbt848->sreset = 0xf;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 8495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 8489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_close      bktrclose\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define NBKTR bktrcd.cd_ndevs\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n\nint\nbktr_close( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR)\t\t\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = bktr_cd.cd_devs[unit];\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_close( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_close( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_close( bktr ) );\n\t}\n\n\treturn( ENXIO );\n}"
  },
  {
    "function_name": "bktr_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8448-8477",
    "snippet": "int\nbktr_open( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR || unit > bktr_cd.cd_ndevs)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tif (bktr_cd.cd_devs == NULL)\n\t\treturn( ENXIO );\n\n\tbktr = bktr_cd.cd_devs[unit];\n\tif (bktr == NULL)\n\t\treturn ( ENXIO );\n\tif (!(bktr->flags & METEOR_INITALIZED)) /* device not found */\n\t\treturn( ENXIO );\t\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_open( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_open( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_open( bktr ) );\n\t}\n\n\treturn( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_open       bktropen",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbi_open",
          "args": [
            "bktr"
          ],
          "line": 8473
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1971-1989",
          "snippet": "static int\nvbi_open( bktr_ptr_t bktr )\n{\n\tif (bktr->vbiflags & VBI_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->vbiflags |= VBI_OPEN;\n\n\t/* reset the VBI circular buffer pointers and clear the buffers */\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbi_sequence_number = 0;\n\n\tbzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);\n\tbzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n\nstatic int\nvbi_open( bktr_ptr_t bktr )\n{\n\tif (bktr->vbiflags & VBI_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->vbiflags |= VBI_OPEN;\n\n\t/* reset the VBI circular buffer pointers and clear the buffers */\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbi_sequence_number = 0;\n\n\tbzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);\n\tbzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuner_open",
          "args": [
            "bktr"
          ],
          "line": 8471
        },
        "resolved": true,
        "details": {
          "function_name": "tuner_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1994-2021",
          "snippet": "static int\ntuner_open( bktr_ptr_t bktr )\n{\n\tif ( !(bktr->tflags & TUNER_INITALIZED) )\t/* device not found */\n\t\treturn( ENXIO );\t\n\n\tif ( bktr->tflags & TUNER_OPEN )\t\t/* already open */\n\t\treturn( 0 );\n\n\tbktr->tflags |= TUNER_OPEN;\n        bktr->tuner.radio_mode = 0;\n\n\t/* enable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en |= bktr->card.gpio_mux_bits;\n\n\t/* unmute the audio stream */\n\tset_audio( bktr, AUDIO_UNMUTE );\n\n\t/* enable stereo if appropriate on TDA audio chip */\n\tif ( bktr->card.dbx )\n\t\tinit_BTSC( bktr );\n\n\t/* reset the MSP34xx stereo audio chip */\n\tif ( bktr->card.msp3400c )\n\t\tmsp_reset( bktr );\n\t\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_open( bktr_ptr_t bktr )\n{\n\tif ( !(bktr->tflags & TUNER_INITALIZED) )\t/* device not found */\n\t\treturn( ENXIO );\t\n\n\tif ( bktr->tflags & TUNER_OPEN )\t\t/* already open */\n\t\treturn( 0 );\n\n\tbktr->tflags |= TUNER_OPEN;\n        bktr->tuner.radio_mode = 0;\n\n\t/* enable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en |= bktr->card.gpio_mux_bits;\n\n\t/* unmute the audio stream */\n\tset_audio( bktr, AUDIO_UNMUTE );\n\n\t/* enable stereo if appropriate on TDA audio chip */\n\tif ( bktr->card.dbx )\n\t\tinit_BTSC( bktr );\n\n\t/* reset the MSP34xx stereo audio chip */\n\tif ( bktr->card.msp3400c )\n\t\tmsp_reset( bktr );\n\t\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_open",
          "args": [
            "bktr"
          ],
          "line": 8469
        },
        "resolved": true,
        "details": {
          "function_name": "video_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1861-1969",
          "snippet": "static int\nvideo_open( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t bt848;\n\tint frame_rate, video_format=0;\n\n\tif (bktr->flags & METEOR_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->flags |= METEOR_OPEN;\n\n\tbt848 = bktr->base;\n\n#ifdef BT848_DUMP\n\tdump_bt848( bt848 );\n#endif\n\n        bktr->clr_on_start = FALSE;\n\n\tbt848->dstatus = 0x00;\t\t\t/* clear device status reg. */\n\n\tbt848->adc = SYNC_LEVEL;\n\n#if BROOKTREE_SYSTEM_DEFAULT == BROOKTREE_PAL\n\tvideo_format = 0;\n#else\n\tvideo_format = 1;\n#endif\n\n\tif (bt848_format == 0 ) \n\t  video_format = 0;\n\n\tif (bt848_format == 1 ) \n\t  video_format = 1;\n\n\tif (video_format == 1 ) {\n\t  bt848->iform = BT848_IFORM_F_NTSCM;\n\t  bktr->format_params = BT848_IFORM_F_NTSCM;\n\n\t} else {\n\t  bt848->iform = BT848_IFORM_F_PALBDGHI;\n\t  bktr->format_params = BT848_IFORM_F_PALBDGHI;\n\n\t}\n\n\tbt848->iform |= format_params[bktr->format_params].iform_xtsel;\n\n\t/* work around for new Hauppauge 878 cards */\n\tif ((bktr->card.card_id == CARD_HAUPPAUGE) &&\n\t    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbt848->iform |= BT848_IFORM_M_MUX3;\n\telse\n\t\tbt848->iform |= BT848_IFORM_M_MUX1;\n\n\tbt848->adelay = format_params[bktr->format_params].adelay;\n\tbt848->bdelay = format_params[bktr->format_params].bdelay;\n\tframe_rate    = format_params[bktr->format_params].frame_rate;\n\n\t/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */\n\tif (bktr->xtal_pll_mode == BT848_USE_PLL) {\n\t\tbt848->tgctrl=0;\n\t\tbt848->pll_f_lo=0xf9;\n\t\tbt848->pll_f_hi=0xdc;\n\t\tbt848->pll_f_xci=0x8e;\n\t}\n\n\tbktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;\n\n\tbktr->max_clip_node = 0;\n\n\tbt848->color_ctl_gamma       = 1;\n\tbt848->color_ctl_rgb_ded     = 1;\n\tbt848->color_ctl_color_bars  = 0;\n\tbt848->color_ctl_ext_frmrate = 0;\n\tbt848->color_ctl_swap        = 0;\n\n\tbt848->e_hscale_lo = 170;\n\tbt848->o_hscale_lo = 170;\n\n\tbt848->e_delay_lo = 0x72;\n\tbt848->o_delay_lo = 0x72;\n\tbt848->e_scloop = 0;\n\tbt848->o_scloop = 0;\n\n\tbt848->vbi_pack_size = 0;\n\tbt848->vbi_pack_del = 0;\n\n\tbktr->fifo_errors = 0;\n\tbktr->dma_errors = 0;\n\tbktr->frames_captured = 0;\n\tbktr->even_fields_captured = 0;\n\tbktr->odd_fields_captured = 0;\n\tbktr->proc = (struct proc *)0;\n\tset_fps(bktr, frame_rate);\n\tbktr->video.addr = 0;\n\tbktr->video.width = 0;\n\tbktr->video.banksize = 0;\n\tbktr->video.ramsize = 0;\n\tbktr->pixfmt_compat = TRUE;\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\n\tbktr->capture_area_enabled = FALSE;\n\n\tbt848->int_mask = BT848_INT_MYSTERYBIT;\t/* if you take this out triton\n                                                   based motherboards will \n\t\t\t\t\t\t   operate unreliably */\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define\tCARD_HAUPPAUGE\t\t2",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define\tCARD_HAUPPAUGE\t\t2\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic int\nvideo_open( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t bt848;\n\tint frame_rate, video_format=0;\n\n\tif (bktr->flags & METEOR_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->flags |= METEOR_OPEN;\n\n\tbt848 = bktr->base;\n\n#ifdef BT848_DUMP\n\tdump_bt848( bt848 );\n#endif\n\n        bktr->clr_on_start = FALSE;\n\n\tbt848->dstatus = 0x00;\t\t\t/* clear device status reg. */\n\n\tbt848->adc = SYNC_LEVEL;\n\n#if BROOKTREE_SYSTEM_DEFAULT == BROOKTREE_PAL\n\tvideo_format = 0;\n#else\n\tvideo_format = 1;\n#endif\n\n\tif (bt848_format == 0 ) \n\t  video_format = 0;\n\n\tif (bt848_format == 1 ) \n\t  video_format = 1;\n\n\tif (video_format == 1 ) {\n\t  bt848->iform = BT848_IFORM_F_NTSCM;\n\t  bktr->format_params = BT848_IFORM_F_NTSCM;\n\n\t} else {\n\t  bt848->iform = BT848_IFORM_F_PALBDGHI;\n\t  bktr->format_params = BT848_IFORM_F_PALBDGHI;\n\n\t}\n\n\tbt848->iform |= format_params[bktr->format_params].iform_xtsel;\n\n\t/* work around for new Hauppauge 878 cards */\n\tif ((bktr->card.card_id == CARD_HAUPPAUGE) &&\n\t    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbt848->iform |= BT848_IFORM_M_MUX3;\n\telse\n\t\tbt848->iform |= BT848_IFORM_M_MUX1;\n\n\tbt848->adelay = format_params[bktr->format_params].adelay;\n\tbt848->bdelay = format_params[bktr->format_params].bdelay;\n\tframe_rate    = format_params[bktr->format_params].frame_rate;\n\n\t/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */\n\tif (bktr->xtal_pll_mode == BT848_USE_PLL) {\n\t\tbt848->tgctrl=0;\n\t\tbt848->pll_f_lo=0xf9;\n\t\tbt848->pll_f_hi=0xdc;\n\t\tbt848->pll_f_xci=0x8e;\n\t}\n\n\tbktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;\n\n\tbktr->max_clip_node = 0;\n\n\tbt848->color_ctl_gamma       = 1;\n\tbt848->color_ctl_rgb_ded     = 1;\n\tbt848->color_ctl_color_bars  = 0;\n\tbt848->color_ctl_ext_frmrate = 0;\n\tbt848->color_ctl_swap        = 0;\n\n\tbt848->e_hscale_lo = 170;\n\tbt848->o_hscale_lo = 170;\n\n\tbt848->e_delay_lo = 0x72;\n\tbt848->o_delay_lo = 0x72;\n\tbt848->e_scloop = 0;\n\tbt848->o_scloop = 0;\n\n\tbt848->vbi_pack_size = 0;\n\tbt848->vbi_pack_del = 0;\n\n\tbktr->fifo_errors = 0;\n\tbktr->dma_errors = 0;\n\tbktr->frames_captured = 0;\n\tbktr->even_fields_captured = 0;\n\tbktr->odd_fields_captured = 0;\n\tbktr->proc = (struct proc *)0;\n\tset_fps(bktr, frame_rate);\n\tbktr->video.addr = 0;\n\tbktr->video.width = 0;\n\tbktr->video.banksize = 0;\n\tbktr->video.ramsize = 0;\n\tbktr->pixfmt_compat = TRUE;\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\n\tbktr->capture_area_enabled = FALSE;\n\n\tbt848->int_mask = BT848_INT_MYSTERYBIT;\t/* if you take this out triton\n                                                   based motherboards will \n\t\t\t\t\t\t   operate unreliably */\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 8467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 8454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_open       bktropen\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define NBKTR bktrcd.cd_ndevs\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n\nint\nbktr_open( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR || unit > bktr_cd.cd_ndevs)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tif (bktr_cd.cd_devs == NULL)\n\t\treturn( ENXIO );\n\n\tbktr = bktr_cd.cd_devs[unit];\n\tif (bktr == NULL)\n\t\treturn ( ENXIO );\n\tif (!(bktr->flags & METEOR_INITALIZED)) /* device not found */\n\t\treturn( ENXIO );\t\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_open( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_open( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_open( bktr ) );\n\t}\n\n\treturn( ENXIO );\n}"
  },
  {
    "function_name": "free_bktr_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8412-8427",
    "snippet": "static void\nfree_bktr_mem(bktr, dmap, kva)\n        bktr_ptr_t bktr;\n        bus_dmamap_t dmap;\n        vm_offset_t kva;\n{\n        bus_dma_tag_t dmat = bktr->dmat;\n\n#ifdef __NetBSD__ \n        bus_dmamem_unmap(dmat, (caddr_t)kva, dmap->dm_mapsize);\n#else\n        bus_dmamem_unmap(dmat, (caddr_t)kva, bktr->dm_mapsize);\n#endif\n        bus_dmamem_free(dmat, dmap->dm_segs, 1);\n        bus_dmamap_destroy(dmat, dmap);\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "dmat",
            "dmap"
          ],
          "line": 8426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "dmat",
            "dmap->dm_segs",
            "1"
          ],
          "line": 8425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "dmat",
            "(caddr_t)kva",
            "bktr->dm_mapsize"
          ],
          "line": 8423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "dmat",
            "(caddr_t)kva",
            "dmap->dm_mapsize"
          ],
          "line": 8421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic void\nfree_bktr_mem(bktr, dmap, kva)\n        bktr_ptr_t bktr;\n        bus_dmamap_t dmap;\n        vm_offset_t kva;\n{\n        bus_dma_tag_t dmat = bktr->dmat;\n\n#ifdef __NetBSD__ \n        bus_dmamem_unmap(dmat, (caddr_t)kva, dmap->dm_mapsize);\n#else\n        bus_dmamem_unmap(dmat, (caddr_t)kva, bktr->dm_mapsize);\n#endif\n        bus_dmamem_free(dmat, dmap->dm_segs, 1);\n        bus_dmamap_destroy(dmat, dmap);\n}"
  },
  {
    "function_name": "get_bktr_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8355-8410",
    "snippet": "static vm_offset_t\nget_bktr_mem(bktr, dmapp, size)\n        bktr_ptr_t bktr;\n        bus_dmamap_t *dmapp;\n        unsigned int size;\n{\n        bus_dma_tag_t dmat = bktr->dmat;\n        bus_dma_segment_t seg;\n        bus_size_t align;\n        int rseg;\n        caddr_t kva;\n\n        /*\n         * Allocate a DMA area\n         */\n        align = 1 << 24;\n        if (bus_dmamem_alloc(dmat, size, align, 0, &seg, 1,\n                             &rseg, BUS_DMA_NOWAIT)) {\n                align = PAGE_SIZE;\n                if (bus_dmamem_alloc(dmat, size, align, 0, &seg, 1,\n                                     &rseg, BUS_DMA_NOWAIT)) {\n                        printf(\"bktr%d: Unable to dmamem_alloc of %d bytes\\n\",\n                                bktr->bktr_dev.dv_unit, size);\n                        return 0;\n                }\n        }\n        if (bus_dmamem_map(dmat, &seg, rseg, size,\n                           &kva, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {\n                printf(\"bktr%d: Unable to dmamem_map of %d bytes\\n\",\n                        bktr->bktr_dev.dv_unit, size);\n                bus_dmamem_free(dmat, &seg, rseg);\n                return 0;\n        }\n#ifdef __OpenBSD__\n        bktr->dm_mapsize = size;\n#endif\n        /*\n         * Create and locd the DMA map for the DMA area\n         */\n        if (bus_dmamap_create(dmat, size, 1, size, 0, BUS_DMA_NOWAIT, dmapp)) {\n                printf(\"bktr%d: Unable to dmamap_create of %d bytes\\n\",\n                        bktr->bktr_dev.dv_unit, size);\n                bus_dmamem_unmap(dmat, kva, size);\n                bus_dmamem_free(dmat, &seg, rseg);\n                return 0;\n        }\n        if (bus_dmamap_load(dmat, *dmapp, kva, size, NULL, BUS_DMA_NOWAIT)) {\n                printf(\"bktr%d: Unable to dmamap_load of %d bytes\\n\",\n                        bktr->bktr_dev.dv_unit, size);\n                bus_dmamem_unmap(dmat, kva, size);\n                bus_dmamem_free(dmat, &seg, rseg);\n                bus_dmamap_destroy(dmat, *dmapp);\n                return 0;\n        }\n        return (vm_offset_t)kva;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "dmat",
            "*dmapp"
          ],
          "line": 8406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "dmat",
            "&seg",
            "rseg"
          ],
          "line": 8405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "dmat",
            "kva",
            "size"
          ],
          "line": 8404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bktr%d: Unable to dmamap_load of %d bytes\\n\"",
            "bktr->bktr_dev.dv_unit",
            "size"
          ],
          "line": 8402
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "dmat",
            "*dmapp",
            "kva",
            "size",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 8401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "dmat",
            "&seg",
            "rseg"
          ],
          "line": 8398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "dmat",
            "kva",
            "size"
          ],
          "line": 8397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "dmat",
            "size",
            "1",
            "size",
            "0",
            "BUS_DMA_NOWAIT",
            "dmapp"
          ],
          "line": 8394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "dmat",
            "&seg",
            "rseg"
          ],
          "line": 8385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "dmat",
            "&seg",
            "rseg",
            "size",
            "&kva",
            "BUS_DMA_NOWAIT|BUS_DMA_COHERENT"
          ],
          "line": 8381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "dmat",
            "size",
            "align",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 8374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "dmat",
            "size",
            "align",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 8371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic vm_offset_t\nget_bktr_mem(bktr, dmapp, size)\n        bktr_ptr_t bktr;\n        bus_dmamap_t *dmapp;\n        unsigned int size;\n{\n        bus_dma_tag_t dmat = bktr->dmat;\n        bus_dma_segment_t seg;\n        bus_size_t align;\n        int rseg;\n        caddr_t kva;\n\n        /*\n         * Allocate a DMA area\n         */\n        align = 1 << 24;\n        if (bus_dmamem_alloc(dmat, size, align, 0, &seg, 1,\n                             &rseg, BUS_DMA_NOWAIT)) {\n                align = PAGE_SIZE;\n                if (bus_dmamem_alloc(dmat, size, align, 0, &seg, 1,\n                                     &rseg, BUS_DMA_NOWAIT)) {\n                        printf(\"bktr%d: Unable to dmamem_alloc of %d bytes\\n\",\n                                bktr->bktr_dev.dv_unit, size);\n                        return 0;\n                }\n        }\n        if (bus_dmamem_map(dmat, &seg, rseg, size,\n                           &kva, BUS_DMA_NOWAIT|BUS_DMA_COHERENT)) {\n                printf(\"bktr%d: Unable to dmamem_map of %d bytes\\n\",\n                        bktr->bktr_dev.dv_unit, size);\n                bus_dmamem_free(dmat, &seg, rseg);\n                return 0;\n        }\n#ifdef __OpenBSD__\n        bktr->dm_mapsize = size;\n#endif\n        /*\n         * Create and locd the DMA map for the DMA area\n         */\n        if (bus_dmamap_create(dmat, size, 1, size, 0, BUS_DMA_NOWAIT, dmapp)) {\n                printf(\"bktr%d: Unable to dmamap_create of %d bytes\\n\",\n                        bktr->bktr_dev.dv_unit, size);\n                bus_dmamem_unmap(dmat, kva, size);\n                bus_dmamem_free(dmat, &seg, rseg);\n                return 0;\n        }\n        if (bus_dmamap_load(dmat, *dmapp, kva, size, NULL, BUS_DMA_NOWAIT)) {\n                printf(\"bktr%d: Unable to dmamap_load of %d bytes\\n\",\n                        bktr->bktr_dev.dv_unit, size);\n                bus_dmamem_unmap(dmat, kva, size);\n                bus_dmamem_free(dmat, &seg, rseg);\n                bus_dmamap_destroy(dmat, *dmapp);\n                return 0;\n        }\n        return (vm_offset_t)kva;\n}"
  },
  {
    "function_name": "bktr_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8134-8134",
    "snippet": "static\tint\t\tbktr_intr(void *arg) { return common_bktr_intr(arg); }",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_bktr_intr",
          "args": [
            "arg"
          ],
          "line": 8134
        },
        "resolved": true,
        "details": {
          "function_name": "common_bktr_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1608-1853",
          "snippet": "static int \ncommon_bktr_intr( void *arg )\n{ \n\tbktr_ptr_t\t\tbktr;\n\tbt848_ptr_t\t\tbt848;\n\tu_long\t\t\tbktr_status;\n\tu_char\t\t\tdstatus;\n\tu_long                  field;\n\tu_long                  w_field;\n\tu_long                  req_field;\n\n\tbktr = (bktr_ptr_t) arg;\n\tbt848 = bktr->base;\n\n\t/*\n\t * check to see if any interrupts are unmasked on this device.  If\n\t * none are, then we likely got here by way of being on a PCI shared\n\t * interrupt dispatch list.\n\t */\n\tif (bt848->int_mask == ALL_INTS_DISABLED)\n\t  \treturn 0;\t/* bail out now, before we do something we\n\t\t\t\t   shouldn't */\n\n\tif (!(bktr->flags & METEOR_OPEN)) {\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\t\t/* return; ?? */\n\t}\n\n\t/* record and clear the INTerrupt status bits */\n\tbktr_status = bt848->int_stat;\n\tbt848->int_stat = bktr_status & ~I2C_BITS;\t/* don't touch i2c */\n\n\t/* record and clear the device status register */\n\tdstatus = bt848->dstatus;\n\tbt848->dstatus = 0x00;\n\n#if defined( STATUS_SUM )\n\t/* add any new device status or INTerrupt status bits */\n\tstatus_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));\n\tstatus_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);\n#endif /* STATUS_SUM */\n\t/* printf( \" STATUS %x %x %x \\n\",\n\t\tdstatus, bktr_status, bt848->risc_count );\n\t*/\n\n\n\t/* if risc was disabled re-start process again */\n\tif ( !(bktr_status & BT848_INT_RISC_EN) ||\n\t     ((bktr_status &(BT848_INT_FBUS   |\n\t\t\t      BT848_INT_FTRGT  |\n\t\t\t      BT848_INT_FDSR   |\n\t\t\t      BT848_INT_PPERR  |\n\t\t\t      BT848_INT_RIPERR |\n\t\t\t      BT848_INT_PABORT |\n\t\t\t      BT848_INT_OCERR  |\n\t\t\t      BT848_INT_SCERR) ) != 0) ||\n\t     ((bt848->tdec == 0) && (bktr_status & TDEC_BITS)) ) {\n\n\t\tu_short\ttdec_save = bt848->tdec;\n\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t/*  Reset temporal decimation ctr  */\n\t\tbt848->tdec = 0;\n\t\tbt848->tdec = tdec_save;\n\t\t\n\t\t/*  Reset to no-fields captured state  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\n\t\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n\t\t\t\t  BT848_INT_RISCI      |\n\t\t\t\t  BT848_INT_VSYNC      |\n\t\t\t\t  BT848_INT_FMTCHG;\n\n\t\tbt848->cap_ctl = bktr->bktr_cap_ctl;\n\t\treturn 1;\n\t}\n\n\t/* If this is not a RISC program interrupt, return */\n\tif (!(bktr_status & BT848_INT_RISCI))\n\t\treturn 0;\n\n/**\n\tprintf( \"intr status %x %x %x\\n\",\n\t\tbktr_status, dstatus, bt848->risc_count );\n */\n\t\n\n\t/*\n\t * Disable future interrupts if a capture mode is not selected.\n\t * This can happen when we are in the process of closing or \n\t * changing capture modes, otherwise it shouldn't happen.\n\t */\n\tif (!(bktr->flags & METEOR_CAP_MASK))\n\t\tbt848->cap_ctl = CAPTURE_OFF;\n\n\t/*\n\t *  Register the completed field\n\t *    (For dual-field mode, require fields from the same frame)\n\t */\n\tfield = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;\n\tswitch ( bktr->flags & METEOR_WANT_MASK ) {\n\t\tcase METEOR_WANT_ODD  : w_field = ODD_F         ;  break;\n\t\tcase METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;\n\t\tdefault               : w_field = (ODD_F|EVEN_F);  break;\n\t}\n\tswitch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {\n\t\tcase METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;\n\t\tcase METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;\n\t\tdefault                      : req_field = (ODD_F|EVEN_F);  \n\t\t\t                       break;\n\t}\n\n\tif (( field == EVEN_F ) && ( w_field == EVEN_F ))\n\t\tbktr->flags &= ~METEOR_WANT_EVEN;\n\telse if (( field == ODD_F ) && ( req_field == ODD_F ) &&\n\t\t ( w_field == ODD_F ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == (ODD_F|EVEN_F) ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == ODD_F )) {\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\t\tbktr->flags |=  METEOR_WANT_EVEN;\n\t}\n\telse {\n\t\t/*  We're out of sync.  Start over.  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If we have a complete frame.\n\t */\n\tif (!(bktr->flags & METEOR_WANT_MASK)) {\n\t\tbktr->frames_captured++;\n\t\t/*\n\t\t * post the completion time. \n\t\t */\n\t\tif (bktr->flags & METEOR_WANT_TS) {\n\t\t\tstruct timeval *ts;\n\t\t\t\n\t\t\tif ((u_int) bktr->alloc_pages * PAGE_SIZE\n\t\t\t   <= (bktr->frame_size + sizeof(struct timeval))) {\n\t\t\t\tts =(struct timeval *)bktr->bigbuf +\n\t\t\t\t  bktr->frame_size;\n\t\t\t\t/* doesn't work in synch mode except\n\t\t\t\t *  for first frame */\n\t\t\t\t/* XXX */\n\t\t\t\tmicrotime(ts);\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Process the VBI data if it is being captured\n\t\t */\n\t\tif (bktr->vbiflags & VBI_CAPTURE) {\n                \tvbidecode(bktr);\n                \twakeup(VBI_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * Wake up the user in single capture mode.\n\t\t */\n\t\tif (bktr->flags & METEOR_SINGLE) {\n\n\t\t\t/* stop dma */\n\t\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t\t/* disable risc, leave fifo running */\n\t\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\t\twakeup(BKTR_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * If the user requested to be notified via signal,\n\t\t * let them know the frame is complete.\n\t\t */\n\n\t\tif (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))\n\t\t\tpsignal( bktr->proc,\n\t\t\t\t bktr->signal&(~METEOR_SIG_MODE_MASK) );\n\n\t\t/*\n\t\t * Reset the want flags if in continuous or\n\t\t * synchronous capture mode.\n\t\t */\n/*\n* XXX NOTE (Luigi):\n* currently we only support 3 capture modes: odd only, even only,\n* odd+even interlaced (odd field first). A fourth mode (non interlaced,\n* either even OR odd) could provide 60 (50 for PAL) pictures per\n* second, but it would require this routine to toggle the desired frame\n* each time, and one more different DMA program for the Bt848.\n* As a consequence, this fourth mode is currently unsupported.\n*/\n\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)",
            "#define I2C_BITS\t\t(BT848_INT_RACK | BT848_INT_I2CDONE)",
            "#define CAPTURE_OFF\t\t0",
            "#define ALL_INTS_DISABLED\t0",
            "#define FIFO_RISC_DISABLED\t0",
            "#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN",
            "#define STATUS_SUM",
            "#define VBI_SLEEP   ((caddr_t)bktr + 1)",
            "#define BKTR_SLEEP  ((caddr_t)bktr    )",
            "#define EVEN_F 0x02",
            "#define ODD_F  0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)\n#define I2C_BITS\t\t(BT848_INT_RACK | BT848_INT_I2CDONE)\n#define CAPTURE_OFF\t\t0\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN\n#define STATUS_SUM\n#define VBI_SLEEP   ((caddr_t)bktr + 1)\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n#define EVEN_F 0x02\n#define ODD_F  0x01\n\nstatic int \ncommon_bktr_intr( void *arg )\n{ \n\tbktr_ptr_t\t\tbktr;\n\tbt848_ptr_t\t\tbt848;\n\tu_long\t\t\tbktr_status;\n\tu_char\t\t\tdstatus;\n\tu_long                  field;\n\tu_long                  w_field;\n\tu_long                  req_field;\n\n\tbktr = (bktr_ptr_t) arg;\n\tbt848 = bktr->base;\n\n\t/*\n\t * check to see if any interrupts are unmasked on this device.  If\n\t * none are, then we likely got here by way of being on a PCI shared\n\t * interrupt dispatch list.\n\t */\n\tif (bt848->int_mask == ALL_INTS_DISABLED)\n\t  \treturn 0;\t/* bail out now, before we do something we\n\t\t\t\t   shouldn't */\n\n\tif (!(bktr->flags & METEOR_OPEN)) {\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\t\t/* return; ?? */\n\t}\n\n\t/* record and clear the INTerrupt status bits */\n\tbktr_status = bt848->int_stat;\n\tbt848->int_stat = bktr_status & ~I2C_BITS;\t/* don't touch i2c */\n\n\t/* record and clear the device status register */\n\tdstatus = bt848->dstatus;\n\tbt848->dstatus = 0x00;\n\n#if defined( STATUS_SUM )\n\t/* add any new device status or INTerrupt status bits */\n\tstatus_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));\n\tstatus_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);\n#endif /* STATUS_SUM */\n\t/* printf( \" STATUS %x %x %x \\n\",\n\t\tdstatus, bktr_status, bt848->risc_count );\n\t*/\n\n\n\t/* if risc was disabled re-start process again */\n\tif ( !(bktr_status & BT848_INT_RISC_EN) ||\n\t     ((bktr_status &(BT848_INT_FBUS   |\n\t\t\t      BT848_INT_FTRGT  |\n\t\t\t      BT848_INT_FDSR   |\n\t\t\t      BT848_INT_PPERR  |\n\t\t\t      BT848_INT_RIPERR |\n\t\t\t      BT848_INT_PABORT |\n\t\t\t      BT848_INT_OCERR  |\n\t\t\t      BT848_INT_SCERR) ) != 0) ||\n\t     ((bt848->tdec == 0) && (bktr_status & TDEC_BITS)) ) {\n\n\t\tu_short\ttdec_save = bt848->tdec;\n\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t/*  Reset temporal decimation ctr  */\n\t\tbt848->tdec = 0;\n\t\tbt848->tdec = tdec_save;\n\t\t\n\t\t/*  Reset to no-fields captured state  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\n\t\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n\t\t\t\t  BT848_INT_RISCI      |\n\t\t\t\t  BT848_INT_VSYNC      |\n\t\t\t\t  BT848_INT_FMTCHG;\n\n\t\tbt848->cap_ctl = bktr->bktr_cap_ctl;\n\t\treturn 1;\n\t}\n\n\t/* If this is not a RISC program interrupt, return */\n\tif (!(bktr_status & BT848_INT_RISCI))\n\t\treturn 0;\n\n/**\n\tprintf( \"intr status %x %x %x\\n\",\n\t\tbktr_status, dstatus, bt848->risc_count );\n */\n\t\n\n\t/*\n\t * Disable future interrupts if a capture mode is not selected.\n\t * This can happen when we are in the process of closing or \n\t * changing capture modes, otherwise it shouldn't happen.\n\t */\n\tif (!(bktr->flags & METEOR_CAP_MASK))\n\t\tbt848->cap_ctl = CAPTURE_OFF;\n\n\t/*\n\t *  Register the completed field\n\t *    (For dual-field mode, require fields from the same frame)\n\t */\n\tfield = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;\n\tswitch ( bktr->flags & METEOR_WANT_MASK ) {\n\t\tcase METEOR_WANT_ODD  : w_field = ODD_F         ;  break;\n\t\tcase METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;\n\t\tdefault               : w_field = (ODD_F|EVEN_F);  break;\n\t}\n\tswitch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {\n\t\tcase METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;\n\t\tcase METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;\n\t\tdefault                      : req_field = (ODD_F|EVEN_F);  \n\t\t\t                       break;\n\t}\n\n\tif (( field == EVEN_F ) && ( w_field == EVEN_F ))\n\t\tbktr->flags &= ~METEOR_WANT_EVEN;\n\telse if (( field == ODD_F ) && ( req_field == ODD_F ) &&\n\t\t ( w_field == ODD_F ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == (ODD_F|EVEN_F) ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == ODD_F )) {\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\t\tbktr->flags |=  METEOR_WANT_EVEN;\n\t}\n\telse {\n\t\t/*  We're out of sync.  Start over.  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If we have a complete frame.\n\t */\n\tif (!(bktr->flags & METEOR_WANT_MASK)) {\n\t\tbktr->frames_captured++;\n\t\t/*\n\t\t * post the completion time. \n\t\t */\n\t\tif (bktr->flags & METEOR_WANT_TS) {\n\t\t\tstruct timeval *ts;\n\t\t\t\n\t\t\tif ((u_int) bktr->alloc_pages * PAGE_SIZE\n\t\t\t   <= (bktr->frame_size + sizeof(struct timeval))) {\n\t\t\t\tts =(struct timeval *)bktr->bigbuf +\n\t\t\t\t  bktr->frame_size;\n\t\t\t\t/* doesn't work in synch mode except\n\t\t\t\t *  for first frame */\n\t\t\t\t/* XXX */\n\t\t\t\tmicrotime(ts);\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Process the VBI data if it is being captured\n\t\t */\n\t\tif (bktr->vbiflags & VBI_CAPTURE) {\n                \tvbidecode(bktr);\n                \twakeup(VBI_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * Wake up the user in single capture mode.\n\t\t */\n\t\tif (bktr->flags & METEOR_SINGLE) {\n\n\t\t\t/* stop dma */\n\t\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t\t/* disable risc, leave fifo running */\n\t\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\t\twakeup(BKTR_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * If the user requested to be notified via signal,\n\t\t * let them know the frame is complete.\n\t\t */\n\n\t\tif (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))\n\t\t\tpsignal( bktr->proc,\n\t\t\t\t bktr->signal&(~METEOR_SIG_MODE_MASK) );\n\n\t\t/*\n\t\t * Reset the want flags if in continuous or\n\t\t * synchronous capture mode.\n\t\t */\n/*\n* XXX NOTE (Luigi):\n* currently we only support 3 capture modes: odd only, even only,\n* odd+even interlaced (odd field first). A fourth mode (non interlaced,\n* either even OR odd) could provide 60 (50 for PAL) pictures per\n* second, but it would require this routine to toggle the desired frame\n* each time, and one more different DMA program for the Bt848.\n* As a consequence, this fourth mode is currently unsupported.\n*/\n\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic\tint\t\tbktr_intr(void *arg) { return common_bktr_intr(arg); }"
  },
  {
    "function_name": "bktr_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8099-8122",
    "snippet": "int\nbktr_mmap( dev_t dev, vm_offset_t offset, int nprot )\n{\n\tint\t\tunit;\n\tbktr_ptr_t\tbktr;\n\n\tunit = UNIT(minor(dev));\n\n\tif (unit >= NBKTR || FUNCTION(minor(dev)) > 0)\n\t\treturn( -1 );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (nprot & PROT_EXEC)\n\t\treturn( -1 );\n\n\tif (offset < 0)\n\t\treturn( -1 );\n\n\tif (offset >= bktr->alloc_pages * PAGE_SIZE)\n\t\treturn( -1 );\n\n\treturn( i386_btop(vtophys(bktr->bigbuf) + offset) );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define bktr_mmap       bktrmmap",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i386_btop",
          "args": [
            "vtophys(bktr->bigbuf) + offset"
          ],
          "line": 8121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->bigbuf"
          ],
          "line": 8121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 8107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 8105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define bktr_mmap       bktrmmap\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n\nint\nbktr_mmap( dev_t dev, vm_offset_t offset, int nprot )\n{\n\tint\t\tunit;\n\tbktr_ptr_t\tbktr;\n\n\tunit = UNIT(minor(dev));\n\n\tif (unit >= NBKTR || FUNCTION(minor(dev)) > 0)\n\t\treturn( -1 );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (nprot & PROT_EXEC)\n\t\treturn( -1 );\n\n\tif (offset < 0)\n\t\treturn( -1 );\n\n\tif (offset >= bktr->alloc_pages * PAGE_SIZE)\n\t\treturn( -1 );\n\n\treturn( i386_btop(vtophys(bktr->bigbuf) + offset) );\n}"
  },
  {
    "function_name": "bktr_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8071-8094",
    "snippet": "int\nbktr_ioctl( dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_ioctl( bktr, unit, cmd, arg, pr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_ioctl( bktr, unit, cmd, arg, pr ) );\n\t}\n\n\treturn( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_ioctl      bktrioctl",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuner_ioctl",
          "args": [
            "bktr",
            "unit",
            "cmd",
            "arg",
            "pr"
          ],
          "line": 8090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "video_ioctl",
          "args": [
            "bktr",
            "unit",
            "cmd",
            "arg",
            "pr"
          ],
          "line": 8088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 8086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 8077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_ioctl      bktrioctl\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n\nint\nbktr_ioctl( dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_ioctl( bktr, unit, cmd, arg, pr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_ioctl( bktr, unit, cmd, arg, pr ) );\n\t}\n\n\treturn( ENXIO );\n}"
  },
  {
    "function_name": "bktr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8062-8066",
    "snippet": "int\nbktr_write( dev_t dev, struct uio *uio, int ioflag )\n{\n\treturn( EINVAL ); /* XXX or ENXIO ? */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define bktr_write      bktrwrite"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define bktr_write      bktrwrite\n\nint\nbktr_write( dev_t dev, struct uio *uio, int ioflag )\n{\n\treturn( EINVAL ); /* XXX or ENXIO ? */\n}"
  },
  {
    "function_name": "bktr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8036-8056",
    "snippet": "int\nbktr_read( dev_t dev, struct uio *uio, int ioflag )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\t\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[unit]);\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_read( bktr, unit, dev, uio ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_read( bktr, dev, uio ) );\n\t}\n\n        return( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_read       bktrread",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbi_read",
          "args": [
            "bktr",
            "dev",
            "uio"
          ],
          "line": 8052
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2142-2177",
          "snippet": "static int\nvbi_read(bktr_ptr_t bktr, dev_t dev, struct uio *uio)\n{\n\tint             readsize, readsize2;\n\tint             status;\n\n\tif(bktr->vbisize == 0)\n\t\tstatus = tsleep(VBI_SLEEP, BKTRPRI, \"vbi\", 0);\n\n\treadsize = (int)uio->uio_iov->iov_len;\n\n\t/* We cannot read more bytes than there are in the circular buffer */\n\tif (readsize > bktr->vbisize) readsize = bktr->vbisize;\n\n\t/* Check if we can read this number of bytes without having to wrap around the circular buffer */\n\tif((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {\n\t\t/* We need to wrap around */\n\n                readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);\n                status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);\n        } else {\n\t\t/* We do not need to wrap around */\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);\n        }\n\n\t/* Update the number of bytes left to read */\n        bktr->vbisize -= readsize;\n\n\t/* Update vbistart */\n        bktr->vbistart += readsize;\n\tbktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */\n\n        return( status );\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VBI_SLEEP   ((caddr_t)bktr + 1)",
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define BKTRPRI (PZERO+8)|PCATCH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_SLEEP   ((caddr_t)bktr + 1)\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define BKTRPRI (PZERO+8)|PCATCH\n\nstatic int\nvbi_read(bktr_ptr_t bktr, dev_t dev, struct uio *uio)\n{\n\tint             readsize, readsize2;\n\tint             status;\n\n\tif(bktr->vbisize == 0)\n\t\tstatus = tsleep(VBI_SLEEP, BKTRPRI, \"vbi\", 0);\n\n\treadsize = (int)uio->uio_iov->iov_len;\n\n\t/* We cannot read more bytes than there are in the circular buffer */\n\tif (readsize > bktr->vbisize) readsize = bktr->vbisize;\n\n\t/* Check if we can read this number of bytes without having to wrap around the circular buffer */\n\tif((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {\n\t\t/* We need to wrap around */\n\n                readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);\n                status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);\n        } else {\n\t\t/* We do not need to wrap around */\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);\n        }\n\n\t/* Update the number of bytes left to read */\n        bktr->vbisize -= readsize;\n\n\t/* Update vbistart */\n        bktr->vbistart += readsize;\n\tbktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */\n\n        return( status );\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_read",
          "args": [
            "bktr",
            "unit",
            "dev",
            "uio"
          ],
          "line": 8050
        },
        "resolved": true,
        "details": {
          "function_name": "video_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2085-2133",
          "snippet": "static int\nvideo_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)\n{\n        bt848_ptr_t     bt848;\n        int             status;\n        int             count;\n\n\n        bt848 = bktr->base;\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tif (bktr->flags & METEOR_CAP_MASK)\n\t\treturn( EIO );\t/* already capturing */\n\n        bt848->cap_ctl = bktr->bktr_cap_ctl;\n\n\n\tcount = bktr->rows * bktr->cols * \n\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp;\n\n\tif ((int) uio->uio_iov->iov_len < count)\n\t\treturn( EINVAL );\n\n\tbktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);\n\n\t/* capture one frame */\n\tstart_capture(bktr, METEOR_SINGLE);\n\t/* wait for capture to complete */\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n                          BT848_INT_RISCI      |\n                          BT848_INT_VSYNC      |\n                          BT848_INT_FMTCHG;\n\n\n\tstatus = tsleep(BKTR_SLEEP, BKTRPRI, \"captur\", 0);\n\tif (!status)\t\t/* successful capture */\n\t\tstatus = uiomove((caddr_t)bktr->bigbuf, count, uio);\n\telse\n\t\tprintf (\"bktr%d: read: tsleep error %d\\n\", unit, status);\n\n\tbktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);\n\n\treturn( status );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ALL_INTS_CLEARED\t0xffffffff",
            "#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN",
            "#define BKTR_SLEEP  ((caddr_t)bktr    )",
            "#define BKTRPRI (PZERO+8)|PCATCH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALL_INTS_CLEARED\t0xffffffff\n#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n#define BKTRPRI (PZERO+8)|PCATCH\n\nstatic int\nvideo_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)\n{\n        bt848_ptr_t     bt848;\n        int             status;\n        int             count;\n\n\n        bt848 = bktr->base;\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tif (bktr->flags & METEOR_CAP_MASK)\n\t\treturn( EIO );\t/* already capturing */\n\n        bt848->cap_ctl = bktr->bktr_cap_ctl;\n\n\n\tcount = bktr->rows * bktr->cols * \n\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp;\n\n\tif ((int) uio->uio_iov->iov_len < count)\n\t\treturn( EINVAL );\n\n\tbktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);\n\n\t/* capture one frame */\n\tstart_capture(bktr, METEOR_SINGLE);\n\t/* wait for capture to complete */\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n                          BT848_INT_RISCI      |\n                          BT848_INT_VSYNC      |\n                          BT848_INT_FMTCHG;\n\n\n\tstatus = tsleep(BKTR_SLEEP, BKTRPRI, \"captur\", 0);\n\tif (!status)\t\t/* successful capture */\n\t\tstatus = uiomove((caddr_t)bktr->bigbuf, count, uio);\n\telse\n\t\tprintf (\"bktr%d: read: tsleep error %d\\n\", unit, status);\n\n\tbktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);\n\n\treturn( status );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 8048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 8042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define bktr_read       bktrread\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n\nint\nbktr_read( dev_t dev, struct uio *uio, int ioflag )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\t\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[unit]);\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_read( bktr, unit, dev, uio ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_read( bktr, dev, uio ) );\n\t}\n\n        return( ENXIO );\n}"
  },
  {
    "function_name": "bktr_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "8009-8031",
    "snippet": "int\nbktr_close( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR)\t\t\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_close( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_close( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_close( bktr ) );\n\t}\n\n\treturn( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_close      bktrclose",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbi_close",
          "args": [
            "bktr"
          ],
          "line": 8027
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2073-2080",
          "snippet": "static int\nvbi_close( bktr_ptr_t bktr )\n{\n\n\tbktr->vbiflags &= ~VBI_OPEN;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nvbi_close( bktr_ptr_t bktr )\n{\n\n\tbktr->vbiflags &= ~VBI_OPEN;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuner_close",
          "args": [
            "bktr"
          ],
          "line": 8025
        },
        "resolved": true,
        "details": {
          "function_name": "tuner_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2059-2071",
          "snippet": "static int\ntuner_close( bktr_ptr_t bktr )\n{\n\tbktr->tflags &= ~TUNER_OPEN;\n\n\t/* mute the audio by switching the mux */\n\tset_audio( bktr, AUDIO_MUTE );\n\n\t/* disable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en = bktr->base->gpio_out_en & ~bktr->card.gpio_mux_bits;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_close( bktr_ptr_t bktr )\n{\n\tbktr->tflags &= ~TUNER_OPEN;\n\n\t/* mute the audio by switching the mux */\n\tset_audio( bktr, AUDIO_MUTE );\n\n\t/* disable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en = bktr->base->gpio_out_en & ~bktr->card.gpio_mux_bits;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_close",
          "args": [
            "bktr"
          ],
          "line": 8023
        },
        "resolved": true,
        "details": {
          "function_name": "video_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2029-2052",
          "snippet": "static int\nvideo_close( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t\tbt848;\n\n\tbktr->flags &= ~(METEOR_OPEN     |\n\t\t\t METEOR_SINGLE   |\n\t\t\t METEOR_CAP_MASK |\n\t\t\t METEOR_WANT_MASK);\n\n\tbt848 = bktr->base;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->cap_ctl = CAPTURE_OFF;\n\n\tbktr->dma_prog_loaded = FALSE;\n\tbt848->tdec = 0;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */\n\tbt848->sreset = 0xf;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define CAPTURE_OFF\t\t0",
            "#define ALL_INTS_CLEARED\t0xffffffff",
            "#define ALL_INTS_DISABLED\t0",
            "#define FIFO_RISC_DISABLED\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CAPTURE_OFF\t\t0\n#define ALL_INTS_CLEARED\t0xffffffff\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n\nstatic int\nvideo_close( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t\tbt848;\n\n\tbktr->flags &= ~(METEOR_OPEN     |\n\t\t\t METEOR_SINGLE   |\n\t\t\t METEOR_CAP_MASK |\n\t\t\t METEOR_WANT_MASK);\n\n\tbt848 = bktr->base;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->cap_ctl = CAPTURE_OFF;\n\n\tbktr->dma_prog_loaded = FALSE;\n\tbt848->tdec = 0;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */\n\tbt848->sreset = 0xf;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 8021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 8015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 8015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_close      bktrclose\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n\nint\nbktr_close( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR)\t\t\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_close( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_close( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_close( bktr ) );\n\t}\n\n\treturn( ENXIO );\n}"
  },
  {
    "function_name": "bktr_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7978-8003",
    "snippet": "int\nbktr_open( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR)\t\t\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (!(bktr->flags & METEOR_INITALIZED)) /* device not found */\n\t\treturn( ENXIO );\t\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_open( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_open( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_open( bktr ) );\n\t}\n\n\treturn( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_open       bktropen",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbi_open",
          "args": [
            "bktr"
          ],
          "line": 7999
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1971-1989",
          "snippet": "static int\nvbi_open( bktr_ptr_t bktr )\n{\n\tif (bktr->vbiflags & VBI_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->vbiflags |= VBI_OPEN;\n\n\t/* reset the VBI circular buffer pointers and clear the buffers */\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbi_sequence_number = 0;\n\n\tbzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);\n\tbzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n\nstatic int\nvbi_open( bktr_ptr_t bktr )\n{\n\tif (bktr->vbiflags & VBI_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->vbiflags |= VBI_OPEN;\n\n\t/* reset the VBI circular buffer pointers and clear the buffers */\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbi_sequence_number = 0;\n\n\tbzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);\n\tbzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuner_open",
          "args": [
            "bktr"
          ],
          "line": 7997
        },
        "resolved": true,
        "details": {
          "function_name": "tuner_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1994-2021",
          "snippet": "static int\ntuner_open( bktr_ptr_t bktr )\n{\n\tif ( !(bktr->tflags & TUNER_INITALIZED) )\t/* device not found */\n\t\treturn( ENXIO );\t\n\n\tif ( bktr->tflags & TUNER_OPEN )\t\t/* already open */\n\t\treturn( 0 );\n\n\tbktr->tflags |= TUNER_OPEN;\n        bktr->tuner.radio_mode = 0;\n\n\t/* enable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en |= bktr->card.gpio_mux_bits;\n\n\t/* unmute the audio stream */\n\tset_audio( bktr, AUDIO_UNMUTE );\n\n\t/* enable stereo if appropriate on TDA audio chip */\n\tif ( bktr->card.dbx )\n\t\tinit_BTSC( bktr );\n\n\t/* reset the MSP34xx stereo audio chip */\n\tif ( bktr->card.msp3400c )\n\t\tmsp_reset( bktr );\n\t\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_open( bktr_ptr_t bktr )\n{\n\tif ( !(bktr->tflags & TUNER_INITALIZED) )\t/* device not found */\n\t\treturn( ENXIO );\t\n\n\tif ( bktr->tflags & TUNER_OPEN )\t\t/* already open */\n\t\treturn( 0 );\n\n\tbktr->tflags |= TUNER_OPEN;\n        bktr->tuner.radio_mode = 0;\n\n\t/* enable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en |= bktr->card.gpio_mux_bits;\n\n\t/* unmute the audio stream */\n\tset_audio( bktr, AUDIO_UNMUTE );\n\n\t/* enable stereo if appropriate on TDA audio chip */\n\tif ( bktr->card.dbx )\n\t\tinit_BTSC( bktr );\n\n\t/* reset the MSP34xx stereo audio chip */\n\tif ( bktr->card.msp3400c )\n\t\tmsp_reset( bktr );\n\t\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_open",
          "args": [
            "bktr"
          ],
          "line": 7995
        },
        "resolved": true,
        "details": {
          "function_name": "video_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1861-1969",
          "snippet": "static int\nvideo_open( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t bt848;\n\tint frame_rate, video_format=0;\n\n\tif (bktr->flags & METEOR_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->flags |= METEOR_OPEN;\n\n\tbt848 = bktr->base;\n\n#ifdef BT848_DUMP\n\tdump_bt848( bt848 );\n#endif\n\n        bktr->clr_on_start = FALSE;\n\n\tbt848->dstatus = 0x00;\t\t\t/* clear device status reg. */\n\n\tbt848->adc = SYNC_LEVEL;\n\n#if BROOKTREE_SYSTEM_DEFAULT == BROOKTREE_PAL\n\tvideo_format = 0;\n#else\n\tvideo_format = 1;\n#endif\n\n\tif (bt848_format == 0 ) \n\t  video_format = 0;\n\n\tif (bt848_format == 1 ) \n\t  video_format = 1;\n\n\tif (video_format == 1 ) {\n\t  bt848->iform = BT848_IFORM_F_NTSCM;\n\t  bktr->format_params = BT848_IFORM_F_NTSCM;\n\n\t} else {\n\t  bt848->iform = BT848_IFORM_F_PALBDGHI;\n\t  bktr->format_params = BT848_IFORM_F_PALBDGHI;\n\n\t}\n\n\tbt848->iform |= format_params[bktr->format_params].iform_xtsel;\n\n\t/* work around for new Hauppauge 878 cards */\n\tif ((bktr->card.card_id == CARD_HAUPPAUGE) &&\n\t    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbt848->iform |= BT848_IFORM_M_MUX3;\n\telse\n\t\tbt848->iform |= BT848_IFORM_M_MUX1;\n\n\tbt848->adelay = format_params[bktr->format_params].adelay;\n\tbt848->bdelay = format_params[bktr->format_params].bdelay;\n\tframe_rate    = format_params[bktr->format_params].frame_rate;\n\n\t/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */\n\tif (bktr->xtal_pll_mode == BT848_USE_PLL) {\n\t\tbt848->tgctrl=0;\n\t\tbt848->pll_f_lo=0xf9;\n\t\tbt848->pll_f_hi=0xdc;\n\t\tbt848->pll_f_xci=0x8e;\n\t}\n\n\tbktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;\n\n\tbktr->max_clip_node = 0;\n\n\tbt848->color_ctl_gamma       = 1;\n\tbt848->color_ctl_rgb_ded     = 1;\n\tbt848->color_ctl_color_bars  = 0;\n\tbt848->color_ctl_ext_frmrate = 0;\n\tbt848->color_ctl_swap        = 0;\n\n\tbt848->e_hscale_lo = 170;\n\tbt848->o_hscale_lo = 170;\n\n\tbt848->e_delay_lo = 0x72;\n\tbt848->o_delay_lo = 0x72;\n\tbt848->e_scloop = 0;\n\tbt848->o_scloop = 0;\n\n\tbt848->vbi_pack_size = 0;\n\tbt848->vbi_pack_del = 0;\n\n\tbktr->fifo_errors = 0;\n\tbktr->dma_errors = 0;\n\tbktr->frames_captured = 0;\n\tbktr->even_fields_captured = 0;\n\tbktr->odd_fields_captured = 0;\n\tbktr->proc = (struct proc *)0;\n\tset_fps(bktr, frame_rate);\n\tbktr->video.addr = 0;\n\tbktr->video.width = 0;\n\tbktr->video.banksize = 0;\n\tbktr->video.ramsize = 0;\n\tbktr->pixfmt_compat = TRUE;\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\n\tbktr->capture_area_enabled = FALSE;\n\n\tbt848->int_mask = BT848_INT_MYSTERYBIT;\t/* if you take this out triton\n                                                   based motherboards will \n\t\t\t\t\t\t   operate unreliably */\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define\tCARD_HAUPPAUGE\t\t2",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define\tCARD_HAUPPAUGE\t\t2\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic int\nvideo_open( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t bt848;\n\tint frame_rate, video_format=0;\n\n\tif (bktr->flags & METEOR_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->flags |= METEOR_OPEN;\n\n\tbt848 = bktr->base;\n\n#ifdef BT848_DUMP\n\tdump_bt848( bt848 );\n#endif\n\n        bktr->clr_on_start = FALSE;\n\n\tbt848->dstatus = 0x00;\t\t\t/* clear device status reg. */\n\n\tbt848->adc = SYNC_LEVEL;\n\n#if BROOKTREE_SYSTEM_DEFAULT == BROOKTREE_PAL\n\tvideo_format = 0;\n#else\n\tvideo_format = 1;\n#endif\n\n\tif (bt848_format == 0 ) \n\t  video_format = 0;\n\n\tif (bt848_format == 1 ) \n\t  video_format = 1;\n\n\tif (video_format == 1 ) {\n\t  bt848->iform = BT848_IFORM_F_NTSCM;\n\t  bktr->format_params = BT848_IFORM_F_NTSCM;\n\n\t} else {\n\t  bt848->iform = BT848_IFORM_F_PALBDGHI;\n\t  bktr->format_params = BT848_IFORM_F_PALBDGHI;\n\n\t}\n\n\tbt848->iform |= format_params[bktr->format_params].iform_xtsel;\n\n\t/* work around for new Hauppauge 878 cards */\n\tif ((bktr->card.card_id == CARD_HAUPPAUGE) &&\n\t    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbt848->iform |= BT848_IFORM_M_MUX3;\n\telse\n\t\tbt848->iform |= BT848_IFORM_M_MUX1;\n\n\tbt848->adelay = format_params[bktr->format_params].adelay;\n\tbt848->bdelay = format_params[bktr->format_params].bdelay;\n\tframe_rate    = format_params[bktr->format_params].frame_rate;\n\n\t/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */\n\tif (bktr->xtal_pll_mode == BT848_USE_PLL) {\n\t\tbt848->tgctrl=0;\n\t\tbt848->pll_f_lo=0xf9;\n\t\tbt848->pll_f_hi=0xdc;\n\t\tbt848->pll_f_xci=0x8e;\n\t}\n\n\tbktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;\n\n\tbktr->max_clip_node = 0;\n\n\tbt848->color_ctl_gamma       = 1;\n\tbt848->color_ctl_rgb_ded     = 1;\n\tbt848->color_ctl_color_bars  = 0;\n\tbt848->color_ctl_ext_frmrate = 0;\n\tbt848->color_ctl_swap        = 0;\n\n\tbt848->e_hscale_lo = 170;\n\tbt848->o_hscale_lo = 170;\n\n\tbt848->e_delay_lo = 0x72;\n\tbt848->o_delay_lo = 0x72;\n\tbt848->e_scloop = 0;\n\tbt848->o_scloop = 0;\n\n\tbt848->vbi_pack_size = 0;\n\tbt848->vbi_pack_del = 0;\n\n\tbktr->fifo_errors = 0;\n\tbktr->dma_errors = 0;\n\tbktr->frames_captured = 0;\n\tbktr->even_fields_captured = 0;\n\tbktr->odd_fields_captured = 0;\n\tbktr->proc = (struct proc *)0;\n\tset_fps(bktr, frame_rate);\n\tbktr->video.addr = 0;\n\tbktr->video.width = 0;\n\tbktr->video.banksize = 0;\n\tbktr->video.ramsize = 0;\n\tbktr->pixfmt_compat = TRUE;\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\n\tbktr->capture_area_enabled = FALSE;\n\n\tbt848->int_mask = BT848_INT_MYSTERYBIT;\t/* if you take this out triton\n                                                   based motherboards will \n\t\t\t\t\t\t   operate unreliably */\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_open       bktropen\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n\nint\nbktr_open( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR)\t\t\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (!(bktr->flags & METEOR_INITALIZED)) /* device not found */\n\t\treturn( ENXIO );\t\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_open( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_open( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_open( bktr ) );\n\t}\n\n\treturn( ENXIO );\n}"
  },
  {
    "function_name": "get_bktr_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7942-7957",
    "snippet": "static vm_offset_t\nget_bktr_mem( int unit, unsigned size )\n{\n\tvm_offset_t\taddr = 0;\n\n\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff, 1<<24);\n\tif (addr == 0)\n\t\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff,\n\t\t\t\t\t\t\t\tPAGE_SIZE);\n\tif (addr == 0) {\n\t\tprintf(\"bktr%d: Unable to allocate %d bytes of memory.\\n\",\n\t\t\tunit, size);\n\t}\n\n\treturn( addr );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bktr%d: Unable to allocate %d bytes of memory.\\n\"",
            "unit",
            "size"
          ],
          "line": 7952
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_page_alloc_contig",
          "args": [
            "size",
            "0x100000",
            "0xffffffff",
            "PAGE_SIZE"
          ],
          "line": 7949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_page_alloc_contig",
          "args": [
            "size",
            "0x100000",
            "0xffffffff",
            "1<<24"
          ],
          "line": 7947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic vm_offset_t\nget_bktr_mem( int unit, unsigned size )\n{\n\tvm_offset_t\taddr = 0;\n\n\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff, 1<<24);\n\tif (addr == 0)\n\t\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff,\n\t\t\t\t\t\t\t\tPAGE_SIZE);\n\tif (addr == 0) {\n\t\tprintf(\"bktr%d: Unable to allocate %d bytes of memory.\\n\",\n\t\t\tunit, size);\n\t}\n\n\treturn( addr );\n}"
  },
  {
    "function_name": "bktr_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7880-7936",
    "snippet": "static\tvoid\nbktr_attach( struct device * const parent, struct device * const self,\n\t\tvoid *const aux  )\n{\n\tbktr_ptr_t\tbktr;\n\tbt848_ptr_t\tbt848;\n\tvm_offset_t\tbuf;\n\tu_long\t\tlatency;\n\tu_long\t\tfun;\n\tunsigned int\trev;\n\n\tstruct isa_attach_args * const ia = (struct isa_attach_args *)aux;\n\tpci_devaddr_t *tag = (pci_devaddr_t *) ia->ia_aux;\n\tint unit  = bktr->bktr_dev.dv_unit;\n\n\tbktr = (bktr_reg_t *) self;\n\tbktr->base = (bt848_ptr_t) bktr_res.pci_vaddr;\n\tisa_establish(&bktr->bktr_id, &bktr->bktr_dev);\n\tbktr->bktr_ih.ih_fun = bktr_intr_returning_1;\n\tbktr->bktr_ih.ih_arg = (void *)bktr;\n\tintr_establish(ia->ia_irq, &bktr->bktr_ih, DV_DULL);\n\t\n/*\n * PCI latency timer.  32 is a good value for 4 bus mastering slots, if\n * you have more than four, then 16 would probably be a better value.\n */\n#ifndef BROOKTREE_DEF_LATENCY_VALUE\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#endif\n\tlatency = pci_conf_read(tag, PCI_LATENCY_TIMER);\n\tlatency = (latency >> 8) & 0xff;\n\tif ( bootverbose ) {\n\t\tif (latency)\n\t\t\tprintf(\"brooktree%d: PCI bus latency is\", unit);\n\t\telse\n\t\t\tprintf(\"brooktree%d: PCI bus latency was 0 changing to\",\n\t\t\t\tunit);\n\t}\n\tif ( !latency ) {\n\t\tlatency = BROOKTREE_DEF_LATENCY_VALUE;\n\t\tpci_conf_write(tag, PCI_LATENCY_TIMER,\tlatency<<8);\n\t}\n\tif ( bootverbose ) {\n\t\tprintf(\" %d.\\n\", (int) latency);\n\t}\n\n\tfun = pci_conf_read(tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(tag, PCI_COMMAND_STATUS_REG, fun | 2);\n\n\t/* read the pci id and determine the card type */\n\tfun = pci_conf_read(tag, PCI_ID_REG);\n        rev = pci_conf_read(tag, PCIR_REVID) & 0x000000ff;\n\n\t/* call the common attach code */\n\tcommon_bktr_attach( bktr, unit, fun, rev );\n\t \n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define PCI_COMMAND_STATUS_REG PCI_COMMAND",
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))",
      "#define PCIR_REVID     PCI_CLASS_REG"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_bktr_attach",
          "args": [
            "bktr",
            "unit",
            "fun",
            "rev"
          ],
          "line": 7934
        },
        "resolved": true,
        "details": {
          "function_name": "common_bktr_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1447-1558",
          "snippet": "static void \ncommon_bktr_attach( bktr_ptr_t bktr, int unit, u_long pci_id, u_int rev )\n{\n\tbt848_ptr_t\tbt848;\n\tvm_offset_t\tbuf;\n\n\tbt848 = bktr->base;\n\n/***************************************/\n/* *** OS Specific memory routines *** */\n/***************************************/\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n        /* allocate space for dma program */\n        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);\n        bktr->odd_dma_prog = get_bktr_mem(bktr, &bktr->dm_oprog, DMA_PROG_ALLOC)\n;\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(bktr, &bktr->dm_vbibuffer, VBI_BUFFER_SIZE);\n\n        /* allocate space for pixel buffer */\n        if ( BROOKTREE_ALLOC )\n                buf = get_bktr_mem(bktr, &bktr->dm_mem, BROOKTREE_ALLOC);\n        else\n                buf = 0;\n#endif\n\n#if defined(__FreeBSD__) || defined(__bsdi__)\n\t/* allocate space for dma program */\n\tbktr->dma_prog     = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\tbktr->odd_dma_prog = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(unit, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(unit, VBI_BUFFER_SIZE);\n\n\t/* allocate space for pixel buffer */\n\tif ( BROOKTREE_ALLOC )\n\t\tbuf = get_bktr_mem(unit, BROOKTREE_ALLOC);\n\telse\n\t\tbuf = 0;\n#endif\n\n\tif ( bootverbose ) {\n\t\tprintf(\"bktr%d: buffer size %d, addr 0x%x\\n\",\n\t\t\tunit, BROOKTREE_ALLOC, vtophys(buf));\n\t}\n\n\tif ( buf != 0 ) {\n\t\tbktr->bigbuf = buf;\n\t\tbktr->alloc_pages = BROOKTREE_ALLOC_PAGES;\n\t\tbzero((caddr_t) bktr->bigbuf, BROOKTREE_ALLOC);\n\t} else {\n\t\tbktr->alloc_pages = 0;\n\t}\n\t\t\n\n\tbktr->flags = METEOR_INITALIZED | METEOR_AUTOMODE |\n\t\t      METEOR_DEV0 | METEOR_RGB16;\n\tbktr->dma_prog_loaded = FALSE;\n\tbktr->cols = 640;\n\tbktr->rows = 480;\n\tbktr->frames = 1;\t\t/* one frame */\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\tbktr->pixfmt_compat = TRUE;\n\n\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbiflags = 0;\n\n \n\t/* using the pci device id and revision id */\n\t/* and determine the card type            */\n\tswitch (pci_id) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) bktr->id = BROOKTREE_848A;\n\t\telse             bktr->id = BROOKTREE_848;\n\t\tbreak;\n        case BROOKTREE_849_PCI_ID:\n\t\tbktr->id = BROOKTREE_849A;\n\t\tbreak;\n        case BROOKTREE_878_PCI_ID:\n\t\tbktr->id = BROOKTREE_878;\n\t\tbreak;\n        case BROOKTREE_879_PCI_ID:\n\t\tbktr->id = BROOKTREE_879;\n\t\tbreak;\n\t};\n\n\tbktr->clr_on_start = FALSE;\n\n\t/* defaults for the tuner section of the card */\n\tbktr->tflags = TUNER_INITALIZED;\n\tbktr->tuner.frequency = 0;\n\tbktr->tuner.channel = 0;\n\tbktr->tuner.chnlset = DEFAULT_CHNLSET;\n\tbktr->audio_mux_select = 0;\n\tbktr->audio_mute_state = FALSE;\n\tbktr->bt848_card = -1;\n\tbktr->bt848_tuner = -1;\n\tbktr->reverse_mute = -1;\n\n\tprobeCard( bktr, TRUE );\n\n\t/* If there is an MSP Audio device, reset it and display the model */\n\tif (bktr->card.msp3400c)msp_reset(bktr);\n\tif (bktr->card.msp3400c)msp_read_id(bktr);\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CHNLSET\tCHNLSET_WEUROPE",
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)",
            "#define BROOKTREE_ALLOC\t\t(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)",
            "#define BROOKTREE_ALLOC_PAGES\t217*4",
            "#define DMA_PROG_ALLOC\t\t(8 * PAGE_SIZE)",
            "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define DEFAULT_CHNLSET\tCHNLSET_WEUROPE\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n#define BROOKTREE_ALLOC\t\t(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)\n#define BROOKTREE_ALLOC_PAGES\t217*4\n#define DMA_PROG_ALLOC\t\t(8 * PAGE_SIZE)\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n\nstatic void \ncommon_bktr_attach( bktr_ptr_t bktr, int unit, u_long pci_id, u_int rev )\n{\n\tbt848_ptr_t\tbt848;\n\tvm_offset_t\tbuf;\n\n\tbt848 = bktr->base;\n\n/***************************************/\n/* *** OS Specific memory routines *** */\n/***************************************/\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n        /* allocate space for dma program */\n        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);\n        bktr->odd_dma_prog = get_bktr_mem(bktr, &bktr->dm_oprog, DMA_PROG_ALLOC)\n;\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(bktr, &bktr->dm_vbibuffer, VBI_BUFFER_SIZE);\n\n        /* allocate space for pixel buffer */\n        if ( BROOKTREE_ALLOC )\n                buf = get_bktr_mem(bktr, &bktr->dm_mem, BROOKTREE_ALLOC);\n        else\n                buf = 0;\n#endif\n\n#if defined(__FreeBSD__) || defined(__bsdi__)\n\t/* allocate space for dma program */\n\tbktr->dma_prog     = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\tbktr->odd_dma_prog = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(unit, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(unit, VBI_BUFFER_SIZE);\n\n\t/* allocate space for pixel buffer */\n\tif ( BROOKTREE_ALLOC )\n\t\tbuf = get_bktr_mem(unit, BROOKTREE_ALLOC);\n\telse\n\t\tbuf = 0;\n#endif\n\n\tif ( bootverbose ) {\n\t\tprintf(\"bktr%d: buffer size %d, addr 0x%x\\n\",\n\t\t\tunit, BROOKTREE_ALLOC, vtophys(buf));\n\t}\n\n\tif ( buf != 0 ) {\n\t\tbktr->bigbuf = buf;\n\t\tbktr->alloc_pages = BROOKTREE_ALLOC_PAGES;\n\t\tbzero((caddr_t) bktr->bigbuf, BROOKTREE_ALLOC);\n\t} else {\n\t\tbktr->alloc_pages = 0;\n\t}\n\t\t\n\n\tbktr->flags = METEOR_INITALIZED | METEOR_AUTOMODE |\n\t\t      METEOR_DEV0 | METEOR_RGB16;\n\tbktr->dma_prog_loaded = FALSE;\n\tbktr->cols = 640;\n\tbktr->rows = 480;\n\tbktr->frames = 1;\t\t/* one frame */\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\tbktr->pixfmt_compat = TRUE;\n\n\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbiflags = 0;\n\n \n\t/* using the pci device id and revision id */\n\t/* and determine the card type            */\n\tswitch (pci_id) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) bktr->id = BROOKTREE_848A;\n\t\telse             bktr->id = BROOKTREE_848;\n\t\tbreak;\n        case BROOKTREE_849_PCI_ID:\n\t\tbktr->id = BROOKTREE_849A;\n\t\tbreak;\n        case BROOKTREE_878_PCI_ID:\n\t\tbktr->id = BROOKTREE_878;\n\t\tbreak;\n        case BROOKTREE_879_PCI_ID:\n\t\tbktr->id = BROOKTREE_879;\n\t\tbreak;\n\t};\n\n\tbktr->clr_on_start = FALSE;\n\n\t/* defaults for the tuner section of the card */\n\tbktr->tflags = TUNER_INITALIZED;\n\tbktr->tuner.frequency = 0;\n\tbktr->tuner.channel = 0;\n\tbktr->tuner.chnlset = DEFAULT_CHNLSET;\n\tbktr->audio_mux_select = 0;\n\tbktr->audio_mute_state = FALSE;\n\tbktr->bt848_card = -1;\n\tbktr->bt848_tuner = -1;\n\tbktr->reverse_mute = -1;\n\n\tprobeCard( bktr, TRUE );\n\n\t/* If there is an MSP Audio device, reset it and display the model */\n\tif (bktr->card.msp3400c)msp_reset(bktr);\n\tif (bktr->card.msp3400c)msp_read_id(bktr);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCIR_REVID"
          ],
          "line": 7931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_ID_REG"
          ],
          "line": 7930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "tag",
            "PCI_COMMAND_STATUS_REG",
            "fun | 2"
          ],
          "line": 7927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 7926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %d.\\n\"",
            "(int) latency"
          ],
          "line": 7923
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "tag",
            "PCI_LATENCY_TIMER",
            "latency<<8"
          ],
          "line": 7920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_LATENCY_TIMER"
          ],
          "line": 7909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intr_establish",
          "args": [
            "ia->ia_irq",
            "&bktr->bktr_ih",
            "DV_DULL"
          ],
          "line": 7900
        },
        "resolved": true,
        "details": {
          "function_name": "tc_intr_establish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/tc.c",
          "lines": "276-287",
          "snippet": "void\ntc_intr_establish(dev, cookie, level, handler, arg)\n\tstruct device *dev;\n\tvoid *cookie, *arg;\n\ttc_intrlevel_t level;\n\tint (*handler) __P((void *));\n{\n\tstruct tc_softc *sc = (struct tc_softc *)dev;\n\n\t(*sc->sc_intr_establish)(sc->sc_dv.dv_parent, cookie, level,\n\t    handler, arg);\n}",
          "includes": [
            "#include <dev/tc/tcdevs_data.h>",
            "#include <machine/autoconf.h>\t/* for the proto of badaddr() */",
            "#include <dev/tc/tcdevs.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <dev/tc/tcreg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/tcdevs_data.h>\n#include <machine/autoconf.h>\t/* for the proto of badaddr() */\n#include <dev/tc/tcdevs.h>\n#include <dev/tc/tcvar.h>\n#include <dev/tc/tcreg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ntc_intr_establish(dev, cookie, level, handler, arg)\n\tstruct device *dev;\n\tvoid *cookie, *arg;\n\ttc_intrlevel_t level;\n\tint (*handler) __P((void *));\n{\n\tstruct tc_softc *sc = (struct tc_softc *)dev;\n\n\t(*sc->sc_intr_establish)(sc->sc_dv.dv_parent, cookie, level,\n\t    handler, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_establish",
          "args": [
            "&bktr->bktr_id",
            "&bktr->bktr_dev"
          ],
          "line": 7897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define PCI_COMMAND_STATUS_REG PCI_COMMAND\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n#define PCIR_REVID     PCI_CLASS_REG\n\nstatic\tvoid\nbktr_attach( struct device * const parent, struct device * const self,\n\t\tvoid *const aux  )\n{\n\tbktr_ptr_t\tbktr;\n\tbt848_ptr_t\tbt848;\n\tvm_offset_t\tbuf;\n\tu_long\t\tlatency;\n\tu_long\t\tfun;\n\tunsigned int\trev;\n\n\tstruct isa_attach_args * const ia = (struct isa_attach_args *)aux;\n\tpci_devaddr_t *tag = (pci_devaddr_t *) ia->ia_aux;\n\tint unit  = bktr->bktr_dev.dv_unit;\n\n\tbktr = (bktr_reg_t *) self;\n\tbktr->base = (bt848_ptr_t) bktr_res.pci_vaddr;\n\tisa_establish(&bktr->bktr_id, &bktr->bktr_dev);\n\tbktr->bktr_ih.ih_fun = bktr_intr_returning_1;\n\tbktr->bktr_ih.ih_arg = (void *)bktr;\n\tintr_establish(ia->ia_irq, &bktr->bktr_ih, DV_DULL);\n\t\n/*\n * PCI latency timer.  32 is a good value for 4 bus mastering slots, if\n * you have more than four, then 16 would probably be a better value.\n */\n#ifndef BROOKTREE_DEF_LATENCY_VALUE\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#endif\n\tlatency = pci_conf_read(tag, PCI_LATENCY_TIMER);\n\tlatency = (latency >> 8) & 0xff;\n\tif ( bootverbose ) {\n\t\tif (latency)\n\t\t\tprintf(\"brooktree%d: PCI bus latency is\", unit);\n\t\telse\n\t\t\tprintf(\"brooktree%d: PCI bus latency was 0 changing to\",\n\t\t\t\tunit);\n\t}\n\tif ( !latency ) {\n\t\tlatency = BROOKTREE_DEF_LATENCY_VALUE;\n\t\tpci_conf_write(tag, PCI_LATENCY_TIMER,\tlatency<<8);\n\t}\n\tif ( bootverbose ) {\n\t\tprintf(\" %d.\\n\", (int) latency);\n\t}\n\n\tfun = pci_conf_read(tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(tag, PCI_COMMAND_STATUS_REG, fun | 2);\n\n\t/* read the pci id and determine the card type */\n\tfun = pci_conf_read(tag, PCI_ID_REG);\n        rev = pci_conf_read(tag, PCIR_REVID) & 0x000000ff;\n\n\t/* call the common attach code */\n\tcommon_bktr_attach( bktr, unit, fun, rev );\n\t \n}"
  },
  {
    "function_name": "bktr_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7841-7861",
    "snippet": "static int\nbktr_probe(struct device *parent, struct cfdata *cf, void *aux)\n{\n    pci_devaddr_t *pa;\n    pci_devres_t res;\n    struct isa_attach_args *ia = aux;\n\n    if (ia->ia_bustype != BUS_PCI)\n\treturn (0);\n\n    if ((pa = pci_scan(bktr_pci_match)) == NULL)\n\treturn (0);\n\n    pci_getres(pa, &bktr_res, 1, ia);\n    if (ia->ia_maddr == 0) {\n\tprintf(\"bktr%d: no mem attached\\n\", cf->cf_unit);\n\treturn (0);\n    }\n    ia->ia_aux = pa;\n    return 1;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bktr%d: no mem attached\\n\"",
            "cf->cf_unit"
          ],
          "line": 7856
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_getres",
          "args": [
            "pa",
            "&bktr_res",
            "1",
            "ia"
          ],
          "line": 7854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_scan",
          "args": [
            "bktr_pci_match"
          ],
          "line": 7851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nbktr_probe(struct device *parent, struct cfdata *cf, void *aux)\n{\n    pci_devaddr_t *pa;\n    pci_devres_t res;\n    struct isa_attach_args *ia = aux;\n\n    if (ia->ia_bustype != BUS_PCI)\n\treturn (0);\n\n    if ((pa = pci_scan(bktr_pci_match)) == NULL)\n\treturn (0);\n\n    pci_getres(pa, &bktr_res, 1, ia);\n    if (ia->ia_maddr == 0) {\n\tprintf(\"bktr%d: no mem attached\\n\", cf->cf_unit);\n\treturn (0);\n    }\n    ia->ia_aux = pa;\n    return 1;\n}"
  },
  {
    "function_name": "bktr_pci_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7820-7837",
    "snippet": "static int\nbktr_pci_match(pci_devaddr_t *pa)\n{\n\tunsigned id;\n\n\tid = pci_inl(pa, PCI_VENDOR_ID);\n\n\tswitch (id) {\n\t   BROOKTREE_848_PCI_ID:\n\t   BROOKTREE_849_PCI_ID:\n\t   BROOKTREE_878_PCI_ID:\n\t   BROOKTREE_879_PCI_ID:\n\t     return 1;\n\t}\n\taprint_debug(\"bktr_pci_match got %x\\n\", id);\n\treturn 0;\n\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aprint_debug",
          "args": [
            "\"bktr_pci_match got %x\\n\"",
            "id"
          ],
          "line": 7834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_inl",
          "args": [
            "pa",
            "PCI_VENDOR_ID"
          ],
          "line": 7825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nbktr_pci_match(pci_devaddr_t *pa)\n{\n\tunsigned id;\n\n\tid = pci_inl(pa, PCI_VENDOR_ID);\n\n\tswitch (id) {\n\t   BROOKTREE_848_PCI_ID:\n\t   BROOKTREE_849_PCI_ID:\n\t   BROOKTREE_878_PCI_ID:\n\t   BROOKTREE_879_PCI_ID:\n\t     return 1;\n\t}\n\taprint_debug(\"bktr_pci_match got %x\\n\", id);\n\treturn 0;\n\n}"
  },
  {
    "function_name": "bktr_intr_returning_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7816-7816",
    "snippet": "static int bktr_intr_returning_1(void *arg) { common_bktr_intr(arg); return (1);}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_bktr_intr",
          "args": [
            "arg"
          ],
          "line": 7816
        },
        "resolved": true,
        "details": {
          "function_name": "common_bktr_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1608-1853",
          "snippet": "static int \ncommon_bktr_intr( void *arg )\n{ \n\tbktr_ptr_t\t\tbktr;\n\tbt848_ptr_t\t\tbt848;\n\tu_long\t\t\tbktr_status;\n\tu_char\t\t\tdstatus;\n\tu_long                  field;\n\tu_long                  w_field;\n\tu_long                  req_field;\n\n\tbktr = (bktr_ptr_t) arg;\n\tbt848 = bktr->base;\n\n\t/*\n\t * check to see if any interrupts are unmasked on this device.  If\n\t * none are, then we likely got here by way of being on a PCI shared\n\t * interrupt dispatch list.\n\t */\n\tif (bt848->int_mask == ALL_INTS_DISABLED)\n\t  \treturn 0;\t/* bail out now, before we do something we\n\t\t\t\t   shouldn't */\n\n\tif (!(bktr->flags & METEOR_OPEN)) {\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\t\t/* return; ?? */\n\t}\n\n\t/* record and clear the INTerrupt status bits */\n\tbktr_status = bt848->int_stat;\n\tbt848->int_stat = bktr_status & ~I2C_BITS;\t/* don't touch i2c */\n\n\t/* record and clear the device status register */\n\tdstatus = bt848->dstatus;\n\tbt848->dstatus = 0x00;\n\n#if defined( STATUS_SUM )\n\t/* add any new device status or INTerrupt status bits */\n\tstatus_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));\n\tstatus_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);\n#endif /* STATUS_SUM */\n\t/* printf( \" STATUS %x %x %x \\n\",\n\t\tdstatus, bktr_status, bt848->risc_count );\n\t*/\n\n\n\t/* if risc was disabled re-start process again */\n\tif ( !(bktr_status & BT848_INT_RISC_EN) ||\n\t     ((bktr_status &(BT848_INT_FBUS   |\n\t\t\t      BT848_INT_FTRGT  |\n\t\t\t      BT848_INT_FDSR   |\n\t\t\t      BT848_INT_PPERR  |\n\t\t\t      BT848_INT_RIPERR |\n\t\t\t      BT848_INT_PABORT |\n\t\t\t      BT848_INT_OCERR  |\n\t\t\t      BT848_INT_SCERR) ) != 0) ||\n\t     ((bt848->tdec == 0) && (bktr_status & TDEC_BITS)) ) {\n\n\t\tu_short\ttdec_save = bt848->tdec;\n\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t/*  Reset temporal decimation ctr  */\n\t\tbt848->tdec = 0;\n\t\tbt848->tdec = tdec_save;\n\t\t\n\t\t/*  Reset to no-fields captured state  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\n\t\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n\t\t\t\t  BT848_INT_RISCI      |\n\t\t\t\t  BT848_INT_VSYNC      |\n\t\t\t\t  BT848_INT_FMTCHG;\n\n\t\tbt848->cap_ctl = bktr->bktr_cap_ctl;\n\t\treturn 1;\n\t}\n\n\t/* If this is not a RISC program interrupt, return */\n\tif (!(bktr_status & BT848_INT_RISCI))\n\t\treturn 0;\n\n/**\n\tprintf( \"intr status %x %x %x\\n\",\n\t\tbktr_status, dstatus, bt848->risc_count );\n */\n\t\n\n\t/*\n\t * Disable future interrupts if a capture mode is not selected.\n\t * This can happen when we are in the process of closing or \n\t * changing capture modes, otherwise it shouldn't happen.\n\t */\n\tif (!(bktr->flags & METEOR_CAP_MASK))\n\t\tbt848->cap_ctl = CAPTURE_OFF;\n\n\t/*\n\t *  Register the completed field\n\t *    (For dual-field mode, require fields from the same frame)\n\t */\n\tfield = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;\n\tswitch ( bktr->flags & METEOR_WANT_MASK ) {\n\t\tcase METEOR_WANT_ODD  : w_field = ODD_F         ;  break;\n\t\tcase METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;\n\t\tdefault               : w_field = (ODD_F|EVEN_F);  break;\n\t}\n\tswitch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {\n\t\tcase METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;\n\t\tcase METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;\n\t\tdefault                      : req_field = (ODD_F|EVEN_F);  \n\t\t\t                       break;\n\t}\n\n\tif (( field == EVEN_F ) && ( w_field == EVEN_F ))\n\t\tbktr->flags &= ~METEOR_WANT_EVEN;\n\telse if (( field == ODD_F ) && ( req_field == ODD_F ) &&\n\t\t ( w_field == ODD_F ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == (ODD_F|EVEN_F) ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == ODD_F )) {\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\t\tbktr->flags |=  METEOR_WANT_EVEN;\n\t}\n\telse {\n\t\t/*  We're out of sync.  Start over.  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If we have a complete frame.\n\t */\n\tif (!(bktr->flags & METEOR_WANT_MASK)) {\n\t\tbktr->frames_captured++;\n\t\t/*\n\t\t * post the completion time. \n\t\t */\n\t\tif (bktr->flags & METEOR_WANT_TS) {\n\t\t\tstruct timeval *ts;\n\t\t\t\n\t\t\tif ((u_int) bktr->alloc_pages * PAGE_SIZE\n\t\t\t   <= (bktr->frame_size + sizeof(struct timeval))) {\n\t\t\t\tts =(struct timeval *)bktr->bigbuf +\n\t\t\t\t  bktr->frame_size;\n\t\t\t\t/* doesn't work in synch mode except\n\t\t\t\t *  for first frame */\n\t\t\t\t/* XXX */\n\t\t\t\tmicrotime(ts);\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Process the VBI data if it is being captured\n\t\t */\n\t\tif (bktr->vbiflags & VBI_CAPTURE) {\n                \tvbidecode(bktr);\n                \twakeup(VBI_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * Wake up the user in single capture mode.\n\t\t */\n\t\tif (bktr->flags & METEOR_SINGLE) {\n\n\t\t\t/* stop dma */\n\t\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t\t/* disable risc, leave fifo running */\n\t\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\t\twakeup(BKTR_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * If the user requested to be notified via signal,\n\t\t * let them know the frame is complete.\n\t\t */\n\n\t\tif (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))\n\t\t\tpsignal( bktr->proc,\n\t\t\t\t bktr->signal&(~METEOR_SIG_MODE_MASK) );\n\n\t\t/*\n\t\t * Reset the want flags if in continuous or\n\t\t * synchronous capture mode.\n\t\t */\n/*\n* XXX NOTE (Luigi):\n* currently we only support 3 capture modes: odd only, even only,\n* odd+even interlaced (odd field first). A fourth mode (non interlaced,\n* either even OR odd) could provide 60 (50 for PAL) pictures per\n* second, but it would require this routine to toggle the desired frame\n* each time, and one more different DMA program for the Bt848.\n* As a consequence, this fourth mode is currently unsupported.\n*/\n\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)",
            "#define I2C_BITS\t\t(BT848_INT_RACK | BT848_INT_I2CDONE)",
            "#define CAPTURE_OFF\t\t0",
            "#define ALL_INTS_DISABLED\t0",
            "#define FIFO_RISC_DISABLED\t0",
            "#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN",
            "#define STATUS_SUM",
            "#define VBI_SLEEP   ((caddr_t)bktr + 1)",
            "#define BKTR_SLEEP  ((caddr_t)bktr    )",
            "#define EVEN_F 0x02",
            "#define ODD_F  0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)\n#define I2C_BITS\t\t(BT848_INT_RACK | BT848_INT_I2CDONE)\n#define CAPTURE_OFF\t\t0\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN\n#define STATUS_SUM\n#define VBI_SLEEP   ((caddr_t)bktr + 1)\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n#define EVEN_F 0x02\n#define ODD_F  0x01\n\nstatic int \ncommon_bktr_intr( void *arg )\n{ \n\tbktr_ptr_t\t\tbktr;\n\tbt848_ptr_t\t\tbt848;\n\tu_long\t\t\tbktr_status;\n\tu_char\t\t\tdstatus;\n\tu_long                  field;\n\tu_long                  w_field;\n\tu_long                  req_field;\n\n\tbktr = (bktr_ptr_t) arg;\n\tbt848 = bktr->base;\n\n\t/*\n\t * check to see if any interrupts are unmasked on this device.  If\n\t * none are, then we likely got here by way of being on a PCI shared\n\t * interrupt dispatch list.\n\t */\n\tif (bt848->int_mask == ALL_INTS_DISABLED)\n\t  \treturn 0;\t/* bail out now, before we do something we\n\t\t\t\t   shouldn't */\n\n\tif (!(bktr->flags & METEOR_OPEN)) {\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\t\t/* return; ?? */\n\t}\n\n\t/* record and clear the INTerrupt status bits */\n\tbktr_status = bt848->int_stat;\n\tbt848->int_stat = bktr_status & ~I2C_BITS;\t/* don't touch i2c */\n\n\t/* record and clear the device status register */\n\tdstatus = bt848->dstatus;\n\tbt848->dstatus = 0x00;\n\n#if defined( STATUS_SUM )\n\t/* add any new device status or INTerrupt status bits */\n\tstatus_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));\n\tstatus_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);\n#endif /* STATUS_SUM */\n\t/* printf( \" STATUS %x %x %x \\n\",\n\t\tdstatus, bktr_status, bt848->risc_count );\n\t*/\n\n\n\t/* if risc was disabled re-start process again */\n\tif ( !(bktr_status & BT848_INT_RISC_EN) ||\n\t     ((bktr_status &(BT848_INT_FBUS   |\n\t\t\t      BT848_INT_FTRGT  |\n\t\t\t      BT848_INT_FDSR   |\n\t\t\t      BT848_INT_PPERR  |\n\t\t\t      BT848_INT_RIPERR |\n\t\t\t      BT848_INT_PABORT |\n\t\t\t      BT848_INT_OCERR  |\n\t\t\t      BT848_INT_SCERR) ) != 0) ||\n\t     ((bt848->tdec == 0) && (bktr_status & TDEC_BITS)) ) {\n\n\t\tu_short\ttdec_save = bt848->tdec;\n\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t/*  Reset temporal decimation ctr  */\n\t\tbt848->tdec = 0;\n\t\tbt848->tdec = tdec_save;\n\t\t\n\t\t/*  Reset to no-fields captured state  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\n\t\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n\t\t\t\t  BT848_INT_RISCI      |\n\t\t\t\t  BT848_INT_VSYNC      |\n\t\t\t\t  BT848_INT_FMTCHG;\n\n\t\tbt848->cap_ctl = bktr->bktr_cap_ctl;\n\t\treturn 1;\n\t}\n\n\t/* If this is not a RISC program interrupt, return */\n\tif (!(bktr_status & BT848_INT_RISCI))\n\t\treturn 0;\n\n/**\n\tprintf( \"intr status %x %x %x\\n\",\n\t\tbktr_status, dstatus, bt848->risc_count );\n */\n\t\n\n\t/*\n\t * Disable future interrupts if a capture mode is not selected.\n\t * This can happen when we are in the process of closing or \n\t * changing capture modes, otherwise it shouldn't happen.\n\t */\n\tif (!(bktr->flags & METEOR_CAP_MASK))\n\t\tbt848->cap_ctl = CAPTURE_OFF;\n\n\t/*\n\t *  Register the completed field\n\t *    (For dual-field mode, require fields from the same frame)\n\t */\n\tfield = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;\n\tswitch ( bktr->flags & METEOR_WANT_MASK ) {\n\t\tcase METEOR_WANT_ODD  : w_field = ODD_F         ;  break;\n\t\tcase METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;\n\t\tdefault               : w_field = (ODD_F|EVEN_F);  break;\n\t}\n\tswitch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {\n\t\tcase METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;\n\t\tcase METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;\n\t\tdefault                      : req_field = (ODD_F|EVEN_F);  \n\t\t\t                       break;\n\t}\n\n\tif (( field == EVEN_F ) && ( w_field == EVEN_F ))\n\t\tbktr->flags &= ~METEOR_WANT_EVEN;\n\telse if (( field == ODD_F ) && ( req_field == ODD_F ) &&\n\t\t ( w_field == ODD_F ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == (ODD_F|EVEN_F) ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == ODD_F )) {\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\t\tbktr->flags |=  METEOR_WANT_EVEN;\n\t}\n\telse {\n\t\t/*  We're out of sync.  Start over.  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If we have a complete frame.\n\t */\n\tif (!(bktr->flags & METEOR_WANT_MASK)) {\n\t\tbktr->frames_captured++;\n\t\t/*\n\t\t * post the completion time. \n\t\t */\n\t\tif (bktr->flags & METEOR_WANT_TS) {\n\t\t\tstruct timeval *ts;\n\t\t\t\n\t\t\tif ((u_int) bktr->alloc_pages * PAGE_SIZE\n\t\t\t   <= (bktr->frame_size + sizeof(struct timeval))) {\n\t\t\t\tts =(struct timeval *)bktr->bigbuf +\n\t\t\t\t  bktr->frame_size;\n\t\t\t\t/* doesn't work in synch mode except\n\t\t\t\t *  for first frame */\n\t\t\t\t/* XXX */\n\t\t\t\tmicrotime(ts);\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Process the VBI data if it is being captured\n\t\t */\n\t\tif (bktr->vbiflags & VBI_CAPTURE) {\n                \tvbidecode(bktr);\n                \twakeup(VBI_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * Wake up the user in single capture mode.\n\t\t */\n\t\tif (bktr->flags & METEOR_SINGLE) {\n\n\t\t\t/* stop dma */\n\t\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t\t/* disable risc, leave fifo running */\n\t\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\t\twakeup(BKTR_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * If the user requested to be notified via signal,\n\t\t * let them know the frame is complete.\n\t\t */\n\n\t\tif (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))\n\t\t\tpsignal( bktr->proc,\n\t\t\t\t bktr->signal&(~METEOR_SIG_MODE_MASK) );\n\n\t\t/*\n\t\t * Reset the want flags if in continuous or\n\t\t * synchronous capture mode.\n\t\t */\n/*\n* XXX NOTE (Luigi):\n* currently we only support 3 capture modes: odd only, even only,\n* odd+even interlaced (odd field first). A fourth mode (non interlaced,\n* either even OR odd) could provide 60 (50 for PAL) pictures per\n* second, but it would require this routine to toggle the desired frame\n* each time, and one more different DMA program for the Bt848.\n* As a consequence, this fourth mode is currently unsupported.\n*/\n\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int bktr_intr_returning_1(void *arg) { common_bktr_intr(arg); return (1);}"
  },
  {
    "function_name": "bktr_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7773-7796",
    "snippet": "int bktr_mmap( dev_t dev, vm_offset_t offset, int nprot )\n\n{\n\tint\t\tunit;\n\tbktr_ptr_t\tbktr;\n\n\tunit = UNIT(minor(dev));\n\n\tif (unit >= NBKTR || FUNCTION(minor(dev)) > 0)\n\t\treturn( -1 );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (nprot & PROT_EXEC)\n\t\treturn( -1 );\n\n\tif (offset < 0)\n\t\treturn( -1 );\n\n\tif (offset >= bktr->alloc_pages * PAGE_SIZE)\n\t\treturn( -1 );\n\n\treturn( i386_btop(vtophys(bktr->bigbuf) + offset) );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define bktr_mmap       bktrmmap",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i386_btop",
          "args": [
            "vtophys(bktr->bigbuf) + offset"
          ],
          "line": 7795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->bigbuf"
          ],
          "line": 7795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define bktr_mmap       bktrmmap\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n\nint bktr_mmap( dev_t dev, vm_offset_t offset, int nprot )\n\n{\n\tint\t\tunit;\n\tbktr_ptr_t\tbktr;\n\n\tunit = UNIT(minor(dev));\n\n\tif (unit >= NBKTR || FUNCTION(minor(dev)) > 0)\n\t\treturn( -1 );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (nprot & PROT_EXEC)\n\t\treturn( -1 );\n\n\tif (offset < 0)\n\t\treturn( -1 );\n\n\tif (offset >= bktr->alloc_pages * PAGE_SIZE)\n\t\treturn( -1 );\n\n\treturn( i386_btop(vtophys(bktr->bigbuf) + offset) );\n}"
  },
  {
    "function_name": "bktr_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7743-7766",
    "snippet": "int\nbktr_ioctl( dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_ioctl( bktr, unit, cmd, arg, pr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_ioctl( bktr, unit, cmd, arg, pr ) );\n\t}\n\n\treturn( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_ioctl      bktrioctl",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuner_ioctl",
          "args": [
            "bktr",
            "unit",
            "cmd",
            "arg",
            "pr"
          ],
          "line": 7762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "video_ioctl",
          "args": [
            "bktr",
            "unit",
            "cmd",
            "arg",
            "pr"
          ],
          "line": 7760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_ioctl      bktrioctl\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n\nint\nbktr_ioctl( dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_ioctl( bktr, unit, cmd, arg, pr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_ioctl( bktr, unit, cmd, arg, pr ) );\n\t}\n\n\treturn( ENXIO );\n}"
  },
  {
    "function_name": "bktr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7734-7738",
    "snippet": "int\nbktr_write( dev_t dev, struct uio *uio, int ioflag )\n{\n\treturn( EINVAL ); /* XXX or ENXIO ? */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define bktr_write      bktrwrite"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define bktr_write      bktrwrite\n\nint\nbktr_write( dev_t dev, struct uio *uio, int ioflag )\n{\n\treturn( EINVAL ); /* XXX or ENXIO ? */\n}"
  },
  {
    "function_name": "bktr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7709-7728",
    "snippet": "int\nbktr_read( dev_t dev, struct uio *uio, int ioflag )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\t\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[unit]);\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_read( bktr, unit, dev, uio ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_read( bktr, dev, uio ) );\n\t}\n        return( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_read       bktrread",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbi_read",
          "args": [
            "bktr",
            "dev",
            "uio"
          ],
          "line": 7725
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2142-2177",
          "snippet": "static int\nvbi_read(bktr_ptr_t bktr, dev_t dev, struct uio *uio)\n{\n\tint             readsize, readsize2;\n\tint             status;\n\n\tif(bktr->vbisize == 0)\n\t\tstatus = tsleep(VBI_SLEEP, BKTRPRI, \"vbi\", 0);\n\n\treadsize = (int)uio->uio_iov->iov_len;\n\n\t/* We cannot read more bytes than there are in the circular buffer */\n\tif (readsize > bktr->vbisize) readsize = bktr->vbisize;\n\n\t/* Check if we can read this number of bytes without having to wrap around the circular buffer */\n\tif((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {\n\t\t/* We need to wrap around */\n\n                readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);\n                status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);\n        } else {\n\t\t/* We do not need to wrap around */\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);\n        }\n\n\t/* Update the number of bytes left to read */\n        bktr->vbisize -= readsize;\n\n\t/* Update vbistart */\n        bktr->vbistart += readsize;\n\tbktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */\n\n        return( status );\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VBI_SLEEP   ((caddr_t)bktr + 1)",
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define BKTRPRI (PZERO+8)|PCATCH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_SLEEP   ((caddr_t)bktr + 1)\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define BKTRPRI (PZERO+8)|PCATCH\n\nstatic int\nvbi_read(bktr_ptr_t bktr, dev_t dev, struct uio *uio)\n{\n\tint             readsize, readsize2;\n\tint             status;\n\n\tif(bktr->vbisize == 0)\n\t\tstatus = tsleep(VBI_SLEEP, BKTRPRI, \"vbi\", 0);\n\n\treadsize = (int)uio->uio_iov->iov_len;\n\n\t/* We cannot read more bytes than there are in the circular buffer */\n\tif (readsize > bktr->vbisize) readsize = bktr->vbisize;\n\n\t/* Check if we can read this number of bytes without having to wrap around the circular buffer */\n\tif((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {\n\t\t/* We need to wrap around */\n\n                readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);\n                status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);\n        } else {\n\t\t/* We do not need to wrap around */\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);\n        }\n\n\t/* Update the number of bytes left to read */\n        bktr->vbisize -= readsize;\n\n\t/* Update vbistart */\n        bktr->vbistart += readsize;\n\tbktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */\n\n        return( status );\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_read",
          "args": [
            "bktr",
            "unit",
            "dev",
            "uio"
          ],
          "line": 7723
        },
        "resolved": true,
        "details": {
          "function_name": "video_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2085-2133",
          "snippet": "static int\nvideo_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)\n{\n        bt848_ptr_t     bt848;\n        int             status;\n        int             count;\n\n\n        bt848 = bktr->base;\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tif (bktr->flags & METEOR_CAP_MASK)\n\t\treturn( EIO );\t/* already capturing */\n\n        bt848->cap_ctl = bktr->bktr_cap_ctl;\n\n\n\tcount = bktr->rows * bktr->cols * \n\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp;\n\n\tif ((int) uio->uio_iov->iov_len < count)\n\t\treturn( EINVAL );\n\n\tbktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);\n\n\t/* capture one frame */\n\tstart_capture(bktr, METEOR_SINGLE);\n\t/* wait for capture to complete */\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n                          BT848_INT_RISCI      |\n                          BT848_INT_VSYNC      |\n                          BT848_INT_FMTCHG;\n\n\n\tstatus = tsleep(BKTR_SLEEP, BKTRPRI, \"captur\", 0);\n\tif (!status)\t\t/* successful capture */\n\t\tstatus = uiomove((caddr_t)bktr->bigbuf, count, uio);\n\telse\n\t\tprintf (\"bktr%d: read: tsleep error %d\\n\", unit, status);\n\n\tbktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);\n\n\treturn( status );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ALL_INTS_CLEARED\t0xffffffff",
            "#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN",
            "#define BKTR_SLEEP  ((caddr_t)bktr    )",
            "#define BKTRPRI (PZERO+8)|PCATCH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALL_INTS_CLEARED\t0xffffffff\n#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n#define BKTRPRI (PZERO+8)|PCATCH\n\nstatic int\nvideo_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)\n{\n        bt848_ptr_t     bt848;\n        int             status;\n        int             count;\n\n\n        bt848 = bktr->base;\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tif (bktr->flags & METEOR_CAP_MASK)\n\t\treturn( EIO );\t/* already capturing */\n\n        bt848->cap_ctl = bktr->bktr_cap_ctl;\n\n\n\tcount = bktr->rows * bktr->cols * \n\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp;\n\n\tif ((int) uio->uio_iov->iov_len < count)\n\t\treturn( EINVAL );\n\n\tbktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);\n\n\t/* capture one frame */\n\tstart_capture(bktr, METEOR_SINGLE);\n\t/* wait for capture to complete */\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n                          BT848_INT_RISCI      |\n                          BT848_INT_VSYNC      |\n                          BT848_INT_FMTCHG;\n\n\n\tstatus = tsleep(BKTR_SLEEP, BKTRPRI, \"captur\", 0);\n\tif (!status)\t\t/* successful capture */\n\t\tstatus = uiomove((caddr_t)bktr->bigbuf, count, uio);\n\telse\n\t\tprintf (\"bktr%d: read: tsleep error %d\\n\", unit, status);\n\n\tbktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);\n\n\treturn( status );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define bktr_read       bktrread\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n\nint\nbktr_read( dev_t dev, struct uio *uio, int ioflag )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\t\n\tunit = UNIT(minor(dev));\n\tif (unit >= NBKTR)\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[unit]);\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_read( bktr, unit, dev, uio ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_read( bktr, dev, uio ) );\n\t}\n        return( ENXIO );\n}"
  },
  {
    "function_name": "bktr_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7682-7704",
    "snippet": "int\nbktr_close( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR)\t\t\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_close( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_close( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_close( bktr ) );\n\t}\n\n\treturn( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_close      bktrclose",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbi_close",
          "args": [
            "bktr"
          ],
          "line": 7700
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2073-2080",
          "snippet": "static int\nvbi_close( bktr_ptr_t bktr )\n{\n\n\tbktr->vbiflags &= ~VBI_OPEN;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nvbi_close( bktr_ptr_t bktr )\n{\n\n\tbktr->vbiflags &= ~VBI_OPEN;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuner_close",
          "args": [
            "bktr"
          ],
          "line": 7698
        },
        "resolved": true,
        "details": {
          "function_name": "tuner_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2059-2071",
          "snippet": "static int\ntuner_close( bktr_ptr_t bktr )\n{\n\tbktr->tflags &= ~TUNER_OPEN;\n\n\t/* mute the audio by switching the mux */\n\tset_audio( bktr, AUDIO_MUTE );\n\n\t/* disable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en = bktr->base->gpio_out_en & ~bktr->card.gpio_mux_bits;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_close( bktr_ptr_t bktr )\n{\n\tbktr->tflags &= ~TUNER_OPEN;\n\n\t/* mute the audio by switching the mux */\n\tset_audio( bktr, AUDIO_MUTE );\n\n\t/* disable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en = bktr->base->gpio_out_en & ~bktr->card.gpio_mux_bits;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_close",
          "args": [
            "bktr"
          ],
          "line": 7696
        },
        "resolved": true,
        "details": {
          "function_name": "video_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2029-2052",
          "snippet": "static int\nvideo_close( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t\tbt848;\n\n\tbktr->flags &= ~(METEOR_OPEN     |\n\t\t\t METEOR_SINGLE   |\n\t\t\t METEOR_CAP_MASK |\n\t\t\t METEOR_WANT_MASK);\n\n\tbt848 = bktr->base;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->cap_ctl = CAPTURE_OFF;\n\n\tbktr->dma_prog_loaded = FALSE;\n\tbt848->tdec = 0;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */\n\tbt848->sreset = 0xf;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define CAPTURE_OFF\t\t0",
            "#define ALL_INTS_CLEARED\t0xffffffff",
            "#define ALL_INTS_DISABLED\t0",
            "#define FIFO_RISC_DISABLED\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CAPTURE_OFF\t\t0\n#define ALL_INTS_CLEARED\t0xffffffff\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n\nstatic int\nvideo_close( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t\tbt848;\n\n\tbktr->flags &= ~(METEOR_OPEN     |\n\t\t\t METEOR_SINGLE   |\n\t\t\t METEOR_CAP_MASK |\n\t\t\t METEOR_WANT_MASK);\n\n\tbt848 = bktr->base;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->cap_ctl = CAPTURE_OFF;\n\n\tbktr->dma_prog_loaded = FALSE;\n\tbt848->tdec = 0;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */\n\tbt848->sreset = 0xf;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_close      bktrclose\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n\nint\nbktr_close( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR)\t\t\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_close( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_close( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_close( bktr ) );\n\t}\n\n\treturn( ENXIO );\n}"
  },
  {
    "function_name": "bktr_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7622-7676",
    "snippet": "int\nbktr_open( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR)\t\t\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (!(bktr->flags & METEOR_INITALIZED)) /* device not found */\n\t\treturn( ENXIO );\t\n\n\n\tif (bt848_card != -1) {\n\t  if ((bt848_card >> 8   == unit ) &&\n\t     ( (bt848_card & 0xff) < Bt848_MAX_CARD )) {\n\t    if ( bktr->bt848_card != (bt848_card & 0xff) ) {\n\t      bktr->bt848_card = (bt848_card & 0xff);\n\t      probeCard(bktr, FALSE);\n\t    }\n\t  }\n\t}\n\n\tif (bt848_tuner != -1) {\n\t  if ((bt848_tuner >> 8   == unit ) &&\n\t     ( (bt848_tuner & 0xff) < Bt848_MAX_TUNER )) {\n\t    if ( bktr->bt848_tuner != (bt848_tuner & 0xff) ) {\n\t      bktr->bt848_tuner = (bt848_tuner & 0xff);\n\t      probeCard(bktr, FALSE);\n\t    }\n\t  }\n\t}\n\n\tif (bt848_reverse_mute != -1) {\n\t  if (((bt848_reverse_mute >> 8)   == unit ) &&\n\t      ((bt848_reverse_mute & 0xff) < Bt848_MAX_TUNER) ) {\n\t    bktr->reverse_mute = bt848_reverse_mute & 0xff;\n\t    bt848_reverse_mute = -1;\n\t  }\n\t}\n\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_open( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_open( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_open( bktr ) );\n\t}\n\treturn( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_open       bktropen",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define Bt848_MAX_CARD\t\t13",
      "#define Bt848_MAX_TUNER         14"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbi_open",
          "args": [
            "bktr"
          ],
          "line": 7673
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1971-1989",
          "snippet": "static int\nvbi_open( bktr_ptr_t bktr )\n{\n\tif (bktr->vbiflags & VBI_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->vbiflags |= VBI_OPEN;\n\n\t/* reset the VBI circular buffer pointers and clear the buffers */\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbi_sequence_number = 0;\n\n\tbzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);\n\tbzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n\nstatic int\nvbi_open( bktr_ptr_t bktr )\n{\n\tif (bktr->vbiflags & VBI_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->vbiflags |= VBI_OPEN;\n\n\t/* reset the VBI circular buffer pointers and clear the buffers */\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbi_sequence_number = 0;\n\n\tbzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);\n\tbzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuner_open",
          "args": [
            "bktr"
          ],
          "line": 7671
        },
        "resolved": true,
        "details": {
          "function_name": "tuner_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1994-2021",
          "snippet": "static int\ntuner_open( bktr_ptr_t bktr )\n{\n\tif ( !(bktr->tflags & TUNER_INITALIZED) )\t/* device not found */\n\t\treturn( ENXIO );\t\n\n\tif ( bktr->tflags & TUNER_OPEN )\t\t/* already open */\n\t\treturn( 0 );\n\n\tbktr->tflags |= TUNER_OPEN;\n        bktr->tuner.radio_mode = 0;\n\n\t/* enable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en |= bktr->card.gpio_mux_bits;\n\n\t/* unmute the audio stream */\n\tset_audio( bktr, AUDIO_UNMUTE );\n\n\t/* enable stereo if appropriate on TDA audio chip */\n\tif ( bktr->card.dbx )\n\t\tinit_BTSC( bktr );\n\n\t/* reset the MSP34xx stereo audio chip */\n\tif ( bktr->card.msp3400c )\n\t\tmsp_reset( bktr );\n\t\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_open( bktr_ptr_t bktr )\n{\n\tif ( !(bktr->tflags & TUNER_INITALIZED) )\t/* device not found */\n\t\treturn( ENXIO );\t\n\n\tif ( bktr->tflags & TUNER_OPEN )\t\t/* already open */\n\t\treturn( 0 );\n\n\tbktr->tflags |= TUNER_OPEN;\n        bktr->tuner.radio_mode = 0;\n\n\t/* enable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en |= bktr->card.gpio_mux_bits;\n\n\t/* unmute the audio stream */\n\tset_audio( bktr, AUDIO_UNMUTE );\n\n\t/* enable stereo if appropriate on TDA audio chip */\n\tif ( bktr->card.dbx )\n\t\tinit_BTSC( bktr );\n\n\t/* reset the MSP34xx stereo audio chip */\n\tif ( bktr->card.msp3400c )\n\t\tmsp_reset( bktr );\n\t\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_open",
          "args": [
            "bktr"
          ],
          "line": 7669
        },
        "resolved": true,
        "details": {
          "function_name": "video_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1861-1969",
          "snippet": "static int\nvideo_open( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t bt848;\n\tint frame_rate, video_format=0;\n\n\tif (bktr->flags & METEOR_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->flags |= METEOR_OPEN;\n\n\tbt848 = bktr->base;\n\n#ifdef BT848_DUMP\n\tdump_bt848( bt848 );\n#endif\n\n        bktr->clr_on_start = FALSE;\n\n\tbt848->dstatus = 0x00;\t\t\t/* clear device status reg. */\n\n\tbt848->adc = SYNC_LEVEL;\n\n#if BROOKTREE_SYSTEM_DEFAULT == BROOKTREE_PAL\n\tvideo_format = 0;\n#else\n\tvideo_format = 1;\n#endif\n\n\tif (bt848_format == 0 ) \n\t  video_format = 0;\n\n\tif (bt848_format == 1 ) \n\t  video_format = 1;\n\n\tif (video_format == 1 ) {\n\t  bt848->iform = BT848_IFORM_F_NTSCM;\n\t  bktr->format_params = BT848_IFORM_F_NTSCM;\n\n\t} else {\n\t  bt848->iform = BT848_IFORM_F_PALBDGHI;\n\t  bktr->format_params = BT848_IFORM_F_PALBDGHI;\n\n\t}\n\n\tbt848->iform |= format_params[bktr->format_params].iform_xtsel;\n\n\t/* work around for new Hauppauge 878 cards */\n\tif ((bktr->card.card_id == CARD_HAUPPAUGE) &&\n\t    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbt848->iform |= BT848_IFORM_M_MUX3;\n\telse\n\t\tbt848->iform |= BT848_IFORM_M_MUX1;\n\n\tbt848->adelay = format_params[bktr->format_params].adelay;\n\tbt848->bdelay = format_params[bktr->format_params].bdelay;\n\tframe_rate    = format_params[bktr->format_params].frame_rate;\n\n\t/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */\n\tif (bktr->xtal_pll_mode == BT848_USE_PLL) {\n\t\tbt848->tgctrl=0;\n\t\tbt848->pll_f_lo=0xf9;\n\t\tbt848->pll_f_hi=0xdc;\n\t\tbt848->pll_f_xci=0x8e;\n\t}\n\n\tbktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;\n\n\tbktr->max_clip_node = 0;\n\n\tbt848->color_ctl_gamma       = 1;\n\tbt848->color_ctl_rgb_ded     = 1;\n\tbt848->color_ctl_color_bars  = 0;\n\tbt848->color_ctl_ext_frmrate = 0;\n\tbt848->color_ctl_swap        = 0;\n\n\tbt848->e_hscale_lo = 170;\n\tbt848->o_hscale_lo = 170;\n\n\tbt848->e_delay_lo = 0x72;\n\tbt848->o_delay_lo = 0x72;\n\tbt848->e_scloop = 0;\n\tbt848->o_scloop = 0;\n\n\tbt848->vbi_pack_size = 0;\n\tbt848->vbi_pack_del = 0;\n\n\tbktr->fifo_errors = 0;\n\tbktr->dma_errors = 0;\n\tbktr->frames_captured = 0;\n\tbktr->even_fields_captured = 0;\n\tbktr->odd_fields_captured = 0;\n\tbktr->proc = (struct proc *)0;\n\tset_fps(bktr, frame_rate);\n\tbktr->video.addr = 0;\n\tbktr->video.width = 0;\n\tbktr->video.banksize = 0;\n\tbktr->video.ramsize = 0;\n\tbktr->pixfmt_compat = TRUE;\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\n\tbktr->capture_area_enabled = FALSE;\n\n\tbt848->int_mask = BT848_INT_MYSTERYBIT;\t/* if you take this out triton\n                                                   based motherboards will \n\t\t\t\t\t\t   operate unreliably */\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define\tCARD_HAUPPAUGE\t\t2",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define\tCARD_HAUPPAUGE\t\t2\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic int\nvideo_open( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t bt848;\n\tint frame_rate, video_format=0;\n\n\tif (bktr->flags & METEOR_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->flags |= METEOR_OPEN;\n\n\tbt848 = bktr->base;\n\n#ifdef BT848_DUMP\n\tdump_bt848( bt848 );\n#endif\n\n        bktr->clr_on_start = FALSE;\n\n\tbt848->dstatus = 0x00;\t\t\t/* clear device status reg. */\n\n\tbt848->adc = SYNC_LEVEL;\n\n#if BROOKTREE_SYSTEM_DEFAULT == BROOKTREE_PAL\n\tvideo_format = 0;\n#else\n\tvideo_format = 1;\n#endif\n\n\tif (bt848_format == 0 ) \n\t  video_format = 0;\n\n\tif (bt848_format == 1 ) \n\t  video_format = 1;\n\n\tif (video_format == 1 ) {\n\t  bt848->iform = BT848_IFORM_F_NTSCM;\n\t  bktr->format_params = BT848_IFORM_F_NTSCM;\n\n\t} else {\n\t  bt848->iform = BT848_IFORM_F_PALBDGHI;\n\t  bktr->format_params = BT848_IFORM_F_PALBDGHI;\n\n\t}\n\n\tbt848->iform |= format_params[bktr->format_params].iform_xtsel;\n\n\t/* work around for new Hauppauge 878 cards */\n\tif ((bktr->card.card_id == CARD_HAUPPAUGE) &&\n\t    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbt848->iform |= BT848_IFORM_M_MUX3;\n\telse\n\t\tbt848->iform |= BT848_IFORM_M_MUX1;\n\n\tbt848->adelay = format_params[bktr->format_params].adelay;\n\tbt848->bdelay = format_params[bktr->format_params].bdelay;\n\tframe_rate    = format_params[bktr->format_params].frame_rate;\n\n\t/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */\n\tif (bktr->xtal_pll_mode == BT848_USE_PLL) {\n\t\tbt848->tgctrl=0;\n\t\tbt848->pll_f_lo=0xf9;\n\t\tbt848->pll_f_hi=0xdc;\n\t\tbt848->pll_f_xci=0x8e;\n\t}\n\n\tbktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;\n\n\tbktr->max_clip_node = 0;\n\n\tbt848->color_ctl_gamma       = 1;\n\tbt848->color_ctl_rgb_ded     = 1;\n\tbt848->color_ctl_color_bars  = 0;\n\tbt848->color_ctl_ext_frmrate = 0;\n\tbt848->color_ctl_swap        = 0;\n\n\tbt848->e_hscale_lo = 170;\n\tbt848->o_hscale_lo = 170;\n\n\tbt848->e_delay_lo = 0x72;\n\tbt848->o_delay_lo = 0x72;\n\tbt848->e_scloop = 0;\n\tbt848->o_scloop = 0;\n\n\tbt848->vbi_pack_size = 0;\n\tbt848->vbi_pack_del = 0;\n\n\tbktr->fifo_errors = 0;\n\tbktr->dma_errors = 0;\n\tbktr->frames_captured = 0;\n\tbktr->even_fields_captured = 0;\n\tbktr->odd_fields_captured = 0;\n\tbktr->proc = (struct proc *)0;\n\tset_fps(bktr, frame_rate);\n\tbktr->video.addr = 0;\n\tbktr->video.width = 0;\n\tbktr->video.banksize = 0;\n\tbktr->video.ramsize = 0;\n\tbktr->pixfmt_compat = TRUE;\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\n\tbktr->capture_area_enabled = FALSE;\n\n\tbt848->int_mask = BT848_INT_MYSTERYBIT;\t/* if you take this out triton\n                                                   based motherboards will \n\t\t\t\t\t\t   operate unreliably */\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probeCard",
          "args": [
            "bktr",
            "FALSE"
          ],
          "line": 7653
        },
        "resolved": true,
        "details": {
          "function_name": "probeCard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5356-5885",
          "snippet": "static void\nprobeCard( bktr_ptr_t bktr, int verbose )\n{\n\tint\t\tcard, i,j, card_found;\n\tint\t\tstatus;\n\tbt848_ptr_t\tbt848;\n\tu_char \t\tprobe_signature[128], *probe_temp;\n        int   \t\tany_i2c_devices;\n\tu_char \t\teeprom[256];\n\tu_char \t\ttuner_code = 0;\n\tint \t\ttuner_i2c_address = -1;\n\tint \t\teeprom_i2c_address = -1;\n\n\tbt848 = bktr->base;\n\n\t/* Select all GPIO bits as inputs */\n\tbt848->gpio_out_en = 0;\n\tif (bootverbose)\n\t    printf(\"bktr: GPIO is 0x%08x\\n\", bt848->gpio_data);\n\n#ifdef HAUPPAUGE_MSP_RESET\n\t/* Reset the MSP34xx audio chip. This resolves bootup card\n\t * detection problems with old Bt848 based Hauppauge cards with\n\t * MSP34xx stereo audio chips. This must be user enabled because\n\t * at this point the probe function does not know the card type. */\n        bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n#endif\n\n\t/* Check for the presence of i2c devices */\n        any_i2c_devices = check_for_i2c_devices( bktr );\n\n\n\t/* Check for a user specified override on the card selection */\n#if defined( OVERRIDE_CARD )\n\tbktr->card = cards[ (card = OVERRIDE_CARD) ];\n\tgoto checkEEPROM;\n#endif\n\tif (bktr->bt848_card != -1 ) {\n\t  bktr->card = cards[ (card = bktr->bt848_card) ];\n\t  goto checkEEPROM;\n\t}\n\n\n\t/* No override, so try and determine the make of the card */\n\n        /* On BT878/879 cards, read the sub-system vendor id */\n\t/* This identifies the manufacturer of the card and the model */\n\t/* In theory this can be read from PCI registers but this does not */\n\t/* appear to work on the FlyVideo 98. Hauppauge also warned that */\n\t/* the PCI registers are sometimes not loaded correctly. */\n\t/* Therefore, I will read the sub-system vendor ID from the EEPROM */\n\t/* (just like the Bt878 does during power up initialisation) */\n\n        if (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) {\n\n\t    /* Try and locate the EEPROM */\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\n                unsigned int subsystem_vendor_id; /* vendors PCI-SIG ID */\n                unsigned int subsystem_id;        /* board model number */\n\t\tunsigned int byte_252, byte_253, byte_254, byte_255;\n\n\t\tbktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\n\t        readEEProm(bktr, 0, 256, (u_char *) &eeprom );\n                byte_252 = (unsigned int)eeprom[252];\n                byte_253 = (unsigned int)eeprom[253];\n                byte_254 = (unsigned int)eeprom[254];\n                byte_255 = (unsigned int)eeprom[255];\n                \n                subsystem_id        = (byte_252 << 8) | byte_253;\n                subsystem_vendor_id = (byte_254 << 8) | byte_255;\n\n\t        if ( bootverbose ) \n\t            printf(\"subsystem 0x%04x 0x%04x\\n\",subsystem_vendor_id,\n\t\t                                  subsystem_id);\n\n                if (subsystem_vendor_id == VENDOR_AVER_MEDIA) {\n                    bktr->card = cards[ (card = CARD_AVER_MEDIA) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_HAUPPAUGE) {\n                    bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_FLYVIDEO) {\n                    bktr->card = cards[ (card = CARD_FLYVIDEO) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_STB) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                /* Vendor is unknown. We will use the standard probe code */\n\t\t/* which may not give best results */\n                printf(\"Warning - card vendor 0x%04x (model 0x%04x) unknown. This may cause poor performance\\n\",subsystem_vendor_id,subsystem_id);\n            }\n\t    else\n\t    {\n                printf(\"Warning - card has no configuration EEPROM. Cannot determine card make. This may cause poor performance\\n\");\n\t    }\n\t} /* end of bt878/bt879 card detection code */\n\n\t/* If we get to this point, we must have a Bt848/848A/849A card */\n\t/* or a Bt878/879 with an unknown subsystem vendor id */\n        /* Try and determine the make of card by clever i2c probing */\n\n   \t/* Check for i2c devices. If none, move on */\n\tif (!any_i2c_devices) {\n\t\tbktr->card = cards[ (card = CARD_INTEL) ];\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t\tgoto checkTuner;\n\t}\n\n\n        /* Look for Hauppauge, STB and Osprey cards by the presence */\n\t/* of an EEPROM */\n        /* Note: Bt878 based cards also use EEPROMs so we can only do this */\n        /* test on BT848/848A and 849A based cards. */\n\tif ((bktr->id==BROOKTREE_848)  ||\n\t    (bktr->id==BROOKTREE_848A) ||\n\t    (bktr->id==BROOKTREE_849A)) {\n\n            /* At i2c address 0xa0, look for Hauppauge and Osprey cards */\n            if ( (status = i2cRead( bktr, PFC8582_RADDR )) != ABSENT ) {\n\n\t\t    /* Read the eeprom contents */\n\t\t    bktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t            readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\t\t    /* For Hauppauge, check the EEPROM begins with 0x84 */\n\t\t    if (eeprom[0] == 0x84) {\n                            bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\n\t\t    /* For Osprey, check the EEPROM begins with \"MMAC\" */\n\t\t    if (  (eeprom[0] == 'M') &&(eeprom[1] == 'M')\n\t\t\t&&(eeprom[2] == 'A') &&(eeprom[3] == 'C')) {\n                            bktr->card = cards[ (card = CARD_OSPREY) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\t\t    printf(\"Warning: Unknown card type. EEPROM data not recognised\\n\");\n\t\t    printf(\"%x %x %x %x\\n\",eeprom[0],eeprom[1],eeprom[2],eeprom[3]);\n            }\n\n            /* look for an STB card */\n            if ( (status = i2cRead( bktr, X24C01_RADDR )) != ABSENT ) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = X24C01_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(128 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n            }\n\n\t}\n\n\tsignCard( bktr, 1, 128, (u_char *)  &probe_signature );\n\n\tif (bootverbose) {\n\t  printf(\"card signature \\n\");\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    printf(\" %02x \", probe_signature[j]);\n\t  }\n\t  printf(\"\\n\\n\");\n\t}\n\tfor (i = 0;\n\t     i < (sizeof bt848_card_signature)/ sizeof (struct bt848_card_sig);\n\t     i++ ) {\n\n\t  card_found = 1;\n\t  probe_temp = (u_char *) &bt848_card_signature[i].signature;\n\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    if ((probe_temp[j] & 0xf) != (probe_signature[j] & 0xf)) {\n\t      card_found = 0;\n\t      break;\n\t    }\n\n\t  }\n\t  if (card_found) {\n\t    bktr->card = cards[ card = bt848_card_signature[i].card];\n\t    bktr->card.tuner = &tuners[ bt848_card_signature[i].tuner];\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t    } else {\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t    }\n\t    goto checkDBX;\n\t  }\n\t}\n\n\t/* We do not know the card type. Default to Miro */\n\tbktr->card = cards[ (card = CARD_MIRO) ];\n\n\ncheckEEPROM:\n\t/* look for a configuration eeprom */\n\teeprom_i2c_address = locate_eeprom_address( bktr );\n\tif (eeprom_i2c_address != -1) {\n\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t} else {\n\t    bktr->card.eepromAddr = 0;\n\t    bktr->card.eepromSize = 0;\n\t}\n\n\ncheckTuner:\n\n\t/* look for a tuner */\n\ttuner_i2c_address = locate_tuner_address( bktr );\n\tif ( tuner_i2c_address == -1 ) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n#if defined( OVERRIDE_TUNER )\n\tbktr->card.tuner = &tuners[ OVERRIDE_TUNER ];\n\tgoto checkDBX;\n#endif\n\tif (bktr->bt848_tuner != -1 ) {\n\t  bktr->card.tuner = &tuners[ bktr->bt848_tuner & 0xff ];\n\t  goto checkDBX;\n\t}\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n\t/* differentiate type of tuner */\n\n\tswitch (card) {\n\tcase CARD_MIRO:\n\t    switch (((bt848->gpio_data >> 10)-1)&7) {\n\t    case 0: bktr->card.tuner = &tuners[ TEMIC_PAL ]; break;\n\t    case 1: bktr->card.tuner = &tuners[ PHILIPS_PAL ]; break;\n\t    case 2: bktr->card.tuner = &tuners[ PHILIPS_NTSC ]; break;\n\t    case 3: bktr->card.tuner = &tuners[ PHILIPS_SECAM ]; break;\n\t    case 4: bktr->card.tuner = &tuners[ NO_TUNER ]; break;\n\t    case 5: bktr->card.tuner = &tuners[ PHILIPS_PALI ]; break;\n\t    case 6: bktr->card.tuner = &tuners[ TEMIC_NTSC ]; break;\n\t    case 7: bktr->card.tuner = &tuners[ TEMIC_PALI ]; break;\n\t    }\n\t    goto checkDBX;\n\t    break;\n\n\tcase CARD_HAUPPAUGE:\n\t    /* Hauppauge kindly supplied the following Tuner Table */\n\t    /* FIXME: I think the tuners the driver selects for types */\n\t    /* 0x08 and 0x15 may be incorrect but no one has complained. */\n\t    /*\n   \t    \tID Tuner Model          Format         \tWe select Format\n\t   \t 0 NONE               \n\t\t 1 EXTERNAL             \n\t\t 2 OTHER                \n\t\t 3 Philips FI1216       BG \n\t\t 4 Philips FI1216MF     BGLL' \n\t\t 5 Philips FI1236       MN \t\tPHILIPS_NTSC\n\t\t 6 Philips FI1246       I \n\t\t 7 Philips FI1256       DK \n\t\t 8 Philips FI1216 MK2   BG \t\tPHILIPS_PALI\n\t\t 9 Philips FI1216MF MK2 BGLL' \n\t\t a Philips FI1236 MK2   MN \t\tPHILIPS_NTSC\n\t\t b Philips FI1246 MK2   I \t\tPHILIPS_PALI\n\t\t c Philips FI1256 MK2   DK \n\t\t d Temic 4032FY5        NTSC\t\tTEMIC_NTSC\n\t\t e Temic 4002FH5        BG\t\tTEMIC_PAL\n\t\t f Temic 4062FY5        I \t\tTEMIC_PALI\n\t\t10 Philips FR1216 MK2   BG \n\t\t11 Philips FR1216MF MK2 BGLL' \n\t\t12 Philips FR1236 MK2   MN \t\tPHILIPS_FR1236_NTSC\n\t\t13 Philips FR1246 MK2   I \n\t\t14 Philips FR1256 MK2   DK \n\t\t15 Philips FM1216       BG \t\tPHILIPS_FR1216_PAL\n\t\t16 Philips FM1216MF     BGLL' \n\t\t17 Philips FM1236       MN \t\tPHILIPS_FR1236_NTSC\n\t\t18 Philips FM1246       I \n\t\t19 Philips FM1256       DK \n\t\t1a Temic 4036FY5        MN - FI1236 MK2 clone\n\t\t1b Samsung TCPN9082D    MN \n\t\t1c Samsung TCPM9092P    Pal BG/I/DK \n\t\t1d Temic 4006FH5        BG \t\tPHILIPS_PALI clone\n\t\t1e Samsung TCPN9085D    MN/Radio \n\t\t1f Samsung TCPB9085P    Pal BG/I/DK / Radio \n\t\t20 Samsung TCPL9091P    Pal BG & Secam L/L' \n\t\t21 Temic 4039FY5        NTSC Radio\n\n\t    */\n\n\t    readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\n\t    /* Determine the model number from the eeprom */\n\t    {\n\t\tu_int model;\n\t\tu_int revision;\n\t\tmodel    = (eeprom[12] << 8  | eeprom[11]);\n\t\trevision = (eeprom[15] << 16 | eeprom[14] << 8 | eeprom[13]);\n\t\tif (verbose)\n\t\t    printf(\"Hauppauge Model %d %c%c%c%c\\n\",\n\t\t\tmodel,\n\t\t\t((revision >> 18) & 0x3f) + 32,\n\t\t\t((revision >> 12) & 0x3f) + 32,\n\t\t\t((revision >>  6) & 0x3f) + 32,\n\t\t\t((revision >>  0) & 0x3f) + 32 );\n\t    }\n\n\t    /* Determine the tuner type from the eeprom */\n\t    tuner_code = eeprom[9];\n\t    switch (tuner_code) {\n\n\t       case 0x5:\n               case 0x0a:\n\t       case 0x1a:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_NTSC  ];\n\t\t goto checkDBX;\n\n               case 0x12:\n\t       case 0x17:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1236_NTSC  ];\n\t\t goto checkDBX;\n\n\t       case 0x8:\n\t       case 0xb:\n\t       case 0x1d:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_PALI ];\n\t\t goto checkDBX;\n\n\t       case 0xd:\n\t\t bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n\t\t goto checkDBX;\n\n               case 0xe:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PAL];\n\t\t goto checkDBX;\n\n\t       case 0xf:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PALI ];\n\t\t goto checkDBX;\n\n               case 0x15:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1216_PAL];\n\t\t goto checkDBX;\n\n\t       default :\n\t\t printf(\"Warning - Unknown Hauppauge Tuner 0x%x\\n\",tuner_code);\n\t    }\n\t    break;\n\n\t} /* end switch(card) */\n\n        /* At this point, a goto checkDBX has not occured */\n        /* We have not been able to select a Tuner */\n        /* Some cards make use of the tuner address to */\n        /* identify the make/model of tuner */\n\n        /* At address 0xc0/0xc1 we often find a TEMIC NTSC */\n        if ( i2cRead( bktr, 0xc1 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n            goto checkDBX;\n        }\n  \n        /* At address 0xc6/0xc7 we often find a PHILIPS NTSC Tuner */\n        if ( i2cRead( bktr, 0xc7 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ PHILIPS_NTSC ];\n            goto checkDBX;\n        }\n\n        /* Address 0xc2/0xc3 is default (or common address) for several */\n\t/* tuners and we cannot tell which is which. */\n\t/* And for all other tuner i2c addresses, select the default */\n\tbktr->card.tuner = &tuners[ DEFAULT_TUNER ];\n\n\ncheckDBX:\n#if defined( OVERRIDE_DBX )\n\tbktr->card.dbx = OVERRIDE_DBX;\n\tgoto checkMSP;\n#endif\n   /* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSP;\n\t}\n\n\t/* probe for BTSC (dbx) chip */\n\tif ( i2cRead( bktr, TDA9850_RADDR ) != ABSENT )\n\t\tbktr->card.dbx = 1;\n\ncheckMSP:\n\t/* If this is a Hauppauge Bt878 card, we need to enable the\n\t * MSP 34xx audio chip. \n\t * If this is a Hauppauge Bt848 card, reset the MSP device.\n\t * The MSP reset line is wired to GPIO pin 5. On Bt878 cards a pulldown\n\t * resistor holds the device in reset until we set GPIO pin 5.\n         */\n\n\t/* Optionally skip the MSP reset. This is handy if you initialise the\n\t * MSP audio in another operating system (eg Windows) first and then\n\t * do a soft reboot.\n\t */\n\n#ifndef BKTR_NO_MSP_RESET\n\tif (card == CARD_HAUPPAUGE) {\n            bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n        }\n#endif\n\n#if defined( OVERRIDE_MSP )\n\tbktr->card.msp3400c = OVERRIDE_MSP;\n\tgoto checkMSPEnd;\n#endif\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSPEnd;\n\t}\n\n\tif ( i2cRead( bktr, MSP3400C_RADDR ) != ABSENT )\n\t\tbktr->card.msp3400c = 1;\n\ncheckMSPEnd:\n\n/* Start of Check Remote */\n        /* Check for the Hauppauge IR Remote Control */\n        /* If there is an external unit, the internal will be ignored */\n\n        bktr->remote_control = 0; /* initial value */\n\n        if (any_i2c_devices) {\n            if (i2cRead( bktr, HAUP_REMOTE_EXT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_EXT_RADDR;\n                }\n            else if (i2cRead( bktr, HAUP_REMOTE_INT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_INT_RADDR;\n                }\n\n        }\n        /* If a remote control is found, poll it 5 times to turn off the LED */\n        if (bktr->remote_control) {\n                int i;\n                for (i=0; i<5; i++)\n                        i2cRead( bktr, bktr->remote_control_addr );\n        }\n/* End of Check Remote */\n\n#if defined( BKTR_USE_PLL )\n\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\tgoto checkPLLEnd;\n#endif\n\t/* Default is to use XTALS and not PLL mode */\n\tbktr->xtal_pll_mode = BT848_USE_XTALS;\n\n\t/* Enable PLL mode for PAL/SECAM users on Hauppauge 878 cards */\n\tif ((card == CARD_HAUPPAUGE) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\n\t/* Enable PLL mode for OSPREY users */\n\tif (card == CARD_OSPREY)\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\t/* Enable PLL mode for PAL/SECAM users on FlyVideo 878 cards */\n\tif ((card == CARD_FLYVIDEO) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n#if defined( BKTR_USE_PLL )\ncheckPLLEnd:\n#endif\n\n\n\tbktr->card.tuner_pllAddr = tuner_i2c_address;\n\n\tif ( verbose ) {\n\t\tprintf( \"%s\", bktr->card.name );\n\t\tif ( bktr->card.tuner )\n\t\t\tprintf( \", %s tuner\", bktr->card.tuner->name );\n\t\tif ( bktr->card.dbx )\n\t\t\tprintf( \", dbx stereo\" );\n\t\tif ( bktr->card.msp3400c )\n\t\t\tprintf( \", msp3400c stereo\" );\n                if ( bktr->remote_control )\n                        printf( \", remote control\" );\n\t\tprintf( \".\\n\" );\n\t}\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VENDOR_STB        0x10B4",
            "#define VENDOR_FLYVIDEO   0x1851",
            "#define VENDOR_HAUPPAUGE  0x0070",
            "#define VENDOR_AVER_MEDIA 0x1431",
            "#define ABSENT\t\t(-1)",
            "#define CARD_FLYVIDEO\t\t10",
            "#define\tCARD_OSPREY\t\t7",
            "#define\tCARD_AVER_MEDIA\t\t6",
            "#define\tCARD_INTEL\t\t4",
            "#define\tCARD_STB\t\t3",
            "#define\tCARD_HAUPPAUGE\t\t2",
            "#define\tCARD_MIRO\t\t1",
            "#define\tCARD_UNKNOWN\t\t0",
            "#define DEFAULT_TUNER\tPHILIPS_NTSC",
            "#define DEFAULT_TUNER\tPHILIPS_PALI",
            "#define PHILIPS_FR1216_PAL\t10",
            "#define PHILIPS_FR1236_NTSC     9",
            "#define PHILIPS_PALI\t\t8",
            "#define TEMIC_PALI\t\t7",
            "#define PHILIPS_SECAM\t\t6",
            "#define PHILIPS_PAL\t\t5",
            "#define PHILIPS_NTSC\t\t4",
            "#define TEMIC_PAL\t\t2",
            "#define TEMIC_NTSC\t\t1",
            "#define NO_TUNER\t\t0",
            "#define PFC8582_RADDR\t\t0xa1",
            "#define PFC8582_WADDR\t\t0xa0",
            "#define X24C01_RADDR\t\t0xaf",
            "#define X24C01_WADDR\t\t0xae",
            "#define MSP3400C_RADDR\t\t0x81",
            "#define TDA9850_RADDR\t\t0xb7",
            "#define HAUP_REMOTE_EXT_RADDR   0x35",
            "#define HAUP_REMOTE_INT_RADDR   0x31",
            "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VENDOR_STB        0x10B4\n#define VENDOR_FLYVIDEO   0x1851\n#define VENDOR_HAUPPAUGE  0x0070\n#define VENDOR_AVER_MEDIA 0x1431\n#define ABSENT\t\t(-1)\n#define CARD_FLYVIDEO\t\t10\n#define\tCARD_OSPREY\t\t7\n#define\tCARD_AVER_MEDIA\t\t6\n#define\tCARD_INTEL\t\t4\n#define\tCARD_STB\t\t3\n#define\tCARD_HAUPPAUGE\t\t2\n#define\tCARD_MIRO\t\t1\n#define\tCARD_UNKNOWN\t\t0\n#define DEFAULT_TUNER\tPHILIPS_NTSC\n#define DEFAULT_TUNER\tPHILIPS_PALI\n#define PHILIPS_FR1216_PAL\t10\n#define PHILIPS_FR1236_NTSC     9\n#define PHILIPS_PALI\t\t8\n#define TEMIC_PALI\t\t7\n#define PHILIPS_SECAM\t\t6\n#define PHILIPS_PAL\t\t5\n#define PHILIPS_NTSC\t\t4\n#define TEMIC_PAL\t\t2\n#define TEMIC_NTSC\t\t1\n#define NO_TUNER\t\t0\n#define PFC8582_RADDR\t\t0xa1\n#define PFC8582_WADDR\t\t0xa0\n#define X24C01_RADDR\t\t0xaf\n#define X24C01_WADDR\t\t0xae\n#define MSP3400C_RADDR\t\t0x81\n#define TDA9850_RADDR\t\t0xb7\n#define HAUP_REMOTE_EXT_RADDR   0x35\n#define HAUP_REMOTE_INT_RADDR   0x31\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n\nstatic void\nprobeCard( bktr_ptr_t bktr, int verbose )\n{\n\tint\t\tcard, i,j, card_found;\n\tint\t\tstatus;\n\tbt848_ptr_t\tbt848;\n\tu_char \t\tprobe_signature[128], *probe_temp;\n        int   \t\tany_i2c_devices;\n\tu_char \t\teeprom[256];\n\tu_char \t\ttuner_code = 0;\n\tint \t\ttuner_i2c_address = -1;\n\tint \t\teeprom_i2c_address = -1;\n\n\tbt848 = bktr->base;\n\n\t/* Select all GPIO bits as inputs */\n\tbt848->gpio_out_en = 0;\n\tif (bootverbose)\n\t    printf(\"bktr: GPIO is 0x%08x\\n\", bt848->gpio_data);\n\n#ifdef HAUPPAUGE_MSP_RESET\n\t/* Reset the MSP34xx audio chip. This resolves bootup card\n\t * detection problems with old Bt848 based Hauppauge cards with\n\t * MSP34xx stereo audio chips. This must be user enabled because\n\t * at this point the probe function does not know the card type. */\n        bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n#endif\n\n\t/* Check for the presence of i2c devices */\n        any_i2c_devices = check_for_i2c_devices( bktr );\n\n\n\t/* Check for a user specified override on the card selection */\n#if defined( OVERRIDE_CARD )\n\tbktr->card = cards[ (card = OVERRIDE_CARD) ];\n\tgoto checkEEPROM;\n#endif\n\tif (bktr->bt848_card != -1 ) {\n\t  bktr->card = cards[ (card = bktr->bt848_card) ];\n\t  goto checkEEPROM;\n\t}\n\n\n\t/* No override, so try and determine the make of the card */\n\n        /* On BT878/879 cards, read the sub-system vendor id */\n\t/* This identifies the manufacturer of the card and the model */\n\t/* In theory this can be read from PCI registers but this does not */\n\t/* appear to work on the FlyVideo 98. Hauppauge also warned that */\n\t/* the PCI registers are sometimes not loaded correctly. */\n\t/* Therefore, I will read the sub-system vendor ID from the EEPROM */\n\t/* (just like the Bt878 does during power up initialisation) */\n\n        if (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) {\n\n\t    /* Try and locate the EEPROM */\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\n                unsigned int subsystem_vendor_id; /* vendors PCI-SIG ID */\n                unsigned int subsystem_id;        /* board model number */\n\t\tunsigned int byte_252, byte_253, byte_254, byte_255;\n\n\t\tbktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\n\t        readEEProm(bktr, 0, 256, (u_char *) &eeprom );\n                byte_252 = (unsigned int)eeprom[252];\n                byte_253 = (unsigned int)eeprom[253];\n                byte_254 = (unsigned int)eeprom[254];\n                byte_255 = (unsigned int)eeprom[255];\n                \n                subsystem_id        = (byte_252 << 8) | byte_253;\n                subsystem_vendor_id = (byte_254 << 8) | byte_255;\n\n\t        if ( bootverbose ) \n\t            printf(\"subsystem 0x%04x 0x%04x\\n\",subsystem_vendor_id,\n\t\t                                  subsystem_id);\n\n                if (subsystem_vendor_id == VENDOR_AVER_MEDIA) {\n                    bktr->card = cards[ (card = CARD_AVER_MEDIA) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_HAUPPAUGE) {\n                    bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_FLYVIDEO) {\n                    bktr->card = cards[ (card = CARD_FLYVIDEO) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_STB) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                /* Vendor is unknown. We will use the standard probe code */\n\t\t/* which may not give best results */\n                printf(\"Warning - card vendor 0x%04x (model 0x%04x) unknown. This may cause poor performance\\n\",subsystem_vendor_id,subsystem_id);\n            }\n\t    else\n\t    {\n                printf(\"Warning - card has no configuration EEPROM. Cannot determine card make. This may cause poor performance\\n\");\n\t    }\n\t} /* end of bt878/bt879 card detection code */\n\n\t/* If we get to this point, we must have a Bt848/848A/849A card */\n\t/* or a Bt878/879 with an unknown subsystem vendor id */\n        /* Try and determine the make of card by clever i2c probing */\n\n   \t/* Check for i2c devices. If none, move on */\n\tif (!any_i2c_devices) {\n\t\tbktr->card = cards[ (card = CARD_INTEL) ];\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t\tgoto checkTuner;\n\t}\n\n\n        /* Look for Hauppauge, STB and Osprey cards by the presence */\n\t/* of an EEPROM */\n        /* Note: Bt878 based cards also use EEPROMs so we can only do this */\n        /* test on BT848/848A and 849A based cards. */\n\tif ((bktr->id==BROOKTREE_848)  ||\n\t    (bktr->id==BROOKTREE_848A) ||\n\t    (bktr->id==BROOKTREE_849A)) {\n\n            /* At i2c address 0xa0, look for Hauppauge and Osprey cards */\n            if ( (status = i2cRead( bktr, PFC8582_RADDR )) != ABSENT ) {\n\n\t\t    /* Read the eeprom contents */\n\t\t    bktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t            readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\t\t    /* For Hauppauge, check the EEPROM begins with 0x84 */\n\t\t    if (eeprom[0] == 0x84) {\n                            bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\n\t\t    /* For Osprey, check the EEPROM begins with \"MMAC\" */\n\t\t    if (  (eeprom[0] == 'M') &&(eeprom[1] == 'M')\n\t\t\t&&(eeprom[2] == 'A') &&(eeprom[3] == 'C')) {\n                            bktr->card = cards[ (card = CARD_OSPREY) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\t\t    printf(\"Warning: Unknown card type. EEPROM data not recognised\\n\");\n\t\t    printf(\"%x %x %x %x\\n\",eeprom[0],eeprom[1],eeprom[2],eeprom[3]);\n            }\n\n            /* look for an STB card */\n            if ( (status = i2cRead( bktr, X24C01_RADDR )) != ABSENT ) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = X24C01_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(128 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n            }\n\n\t}\n\n\tsignCard( bktr, 1, 128, (u_char *)  &probe_signature );\n\n\tif (bootverbose) {\n\t  printf(\"card signature \\n\");\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    printf(\" %02x \", probe_signature[j]);\n\t  }\n\t  printf(\"\\n\\n\");\n\t}\n\tfor (i = 0;\n\t     i < (sizeof bt848_card_signature)/ sizeof (struct bt848_card_sig);\n\t     i++ ) {\n\n\t  card_found = 1;\n\t  probe_temp = (u_char *) &bt848_card_signature[i].signature;\n\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    if ((probe_temp[j] & 0xf) != (probe_signature[j] & 0xf)) {\n\t      card_found = 0;\n\t      break;\n\t    }\n\n\t  }\n\t  if (card_found) {\n\t    bktr->card = cards[ card = bt848_card_signature[i].card];\n\t    bktr->card.tuner = &tuners[ bt848_card_signature[i].tuner];\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t    } else {\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t    }\n\t    goto checkDBX;\n\t  }\n\t}\n\n\t/* We do not know the card type. Default to Miro */\n\tbktr->card = cards[ (card = CARD_MIRO) ];\n\n\ncheckEEPROM:\n\t/* look for a configuration eeprom */\n\teeprom_i2c_address = locate_eeprom_address( bktr );\n\tif (eeprom_i2c_address != -1) {\n\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t} else {\n\t    bktr->card.eepromAddr = 0;\n\t    bktr->card.eepromSize = 0;\n\t}\n\n\ncheckTuner:\n\n\t/* look for a tuner */\n\ttuner_i2c_address = locate_tuner_address( bktr );\n\tif ( tuner_i2c_address == -1 ) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n#if defined( OVERRIDE_TUNER )\n\tbktr->card.tuner = &tuners[ OVERRIDE_TUNER ];\n\tgoto checkDBX;\n#endif\n\tif (bktr->bt848_tuner != -1 ) {\n\t  bktr->card.tuner = &tuners[ bktr->bt848_tuner & 0xff ];\n\t  goto checkDBX;\n\t}\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n\t/* differentiate type of tuner */\n\n\tswitch (card) {\n\tcase CARD_MIRO:\n\t    switch (((bt848->gpio_data >> 10)-1)&7) {\n\t    case 0: bktr->card.tuner = &tuners[ TEMIC_PAL ]; break;\n\t    case 1: bktr->card.tuner = &tuners[ PHILIPS_PAL ]; break;\n\t    case 2: bktr->card.tuner = &tuners[ PHILIPS_NTSC ]; break;\n\t    case 3: bktr->card.tuner = &tuners[ PHILIPS_SECAM ]; break;\n\t    case 4: bktr->card.tuner = &tuners[ NO_TUNER ]; break;\n\t    case 5: bktr->card.tuner = &tuners[ PHILIPS_PALI ]; break;\n\t    case 6: bktr->card.tuner = &tuners[ TEMIC_NTSC ]; break;\n\t    case 7: bktr->card.tuner = &tuners[ TEMIC_PALI ]; break;\n\t    }\n\t    goto checkDBX;\n\t    break;\n\n\tcase CARD_HAUPPAUGE:\n\t    /* Hauppauge kindly supplied the following Tuner Table */\n\t    /* FIXME: I think the tuners the driver selects for types */\n\t    /* 0x08 and 0x15 may be incorrect but no one has complained. */\n\t    /*\n   \t    \tID Tuner Model          Format         \tWe select Format\n\t   \t 0 NONE               \n\t\t 1 EXTERNAL             \n\t\t 2 OTHER                \n\t\t 3 Philips FI1216       BG \n\t\t 4 Philips FI1216MF     BGLL' \n\t\t 5 Philips FI1236       MN \t\tPHILIPS_NTSC\n\t\t 6 Philips FI1246       I \n\t\t 7 Philips FI1256       DK \n\t\t 8 Philips FI1216 MK2   BG \t\tPHILIPS_PALI\n\t\t 9 Philips FI1216MF MK2 BGLL' \n\t\t a Philips FI1236 MK2   MN \t\tPHILIPS_NTSC\n\t\t b Philips FI1246 MK2   I \t\tPHILIPS_PALI\n\t\t c Philips FI1256 MK2   DK \n\t\t d Temic 4032FY5        NTSC\t\tTEMIC_NTSC\n\t\t e Temic 4002FH5        BG\t\tTEMIC_PAL\n\t\t f Temic 4062FY5        I \t\tTEMIC_PALI\n\t\t10 Philips FR1216 MK2   BG \n\t\t11 Philips FR1216MF MK2 BGLL' \n\t\t12 Philips FR1236 MK2   MN \t\tPHILIPS_FR1236_NTSC\n\t\t13 Philips FR1246 MK2   I \n\t\t14 Philips FR1256 MK2   DK \n\t\t15 Philips FM1216       BG \t\tPHILIPS_FR1216_PAL\n\t\t16 Philips FM1216MF     BGLL' \n\t\t17 Philips FM1236       MN \t\tPHILIPS_FR1236_NTSC\n\t\t18 Philips FM1246       I \n\t\t19 Philips FM1256       DK \n\t\t1a Temic 4036FY5        MN - FI1236 MK2 clone\n\t\t1b Samsung TCPN9082D    MN \n\t\t1c Samsung TCPM9092P    Pal BG/I/DK \n\t\t1d Temic 4006FH5        BG \t\tPHILIPS_PALI clone\n\t\t1e Samsung TCPN9085D    MN/Radio \n\t\t1f Samsung TCPB9085P    Pal BG/I/DK / Radio \n\t\t20 Samsung TCPL9091P    Pal BG & Secam L/L' \n\t\t21 Temic 4039FY5        NTSC Radio\n\n\t    */\n\n\t    readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\n\t    /* Determine the model number from the eeprom */\n\t    {\n\t\tu_int model;\n\t\tu_int revision;\n\t\tmodel    = (eeprom[12] << 8  | eeprom[11]);\n\t\trevision = (eeprom[15] << 16 | eeprom[14] << 8 | eeprom[13]);\n\t\tif (verbose)\n\t\t    printf(\"Hauppauge Model %d %c%c%c%c\\n\",\n\t\t\tmodel,\n\t\t\t((revision >> 18) & 0x3f) + 32,\n\t\t\t((revision >> 12) & 0x3f) + 32,\n\t\t\t((revision >>  6) & 0x3f) + 32,\n\t\t\t((revision >>  0) & 0x3f) + 32 );\n\t    }\n\n\t    /* Determine the tuner type from the eeprom */\n\t    tuner_code = eeprom[9];\n\t    switch (tuner_code) {\n\n\t       case 0x5:\n               case 0x0a:\n\t       case 0x1a:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_NTSC  ];\n\t\t goto checkDBX;\n\n               case 0x12:\n\t       case 0x17:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1236_NTSC  ];\n\t\t goto checkDBX;\n\n\t       case 0x8:\n\t       case 0xb:\n\t       case 0x1d:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_PALI ];\n\t\t goto checkDBX;\n\n\t       case 0xd:\n\t\t bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n\t\t goto checkDBX;\n\n               case 0xe:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PAL];\n\t\t goto checkDBX;\n\n\t       case 0xf:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PALI ];\n\t\t goto checkDBX;\n\n               case 0x15:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1216_PAL];\n\t\t goto checkDBX;\n\n\t       default :\n\t\t printf(\"Warning - Unknown Hauppauge Tuner 0x%x\\n\",tuner_code);\n\t    }\n\t    break;\n\n\t} /* end switch(card) */\n\n        /* At this point, a goto checkDBX has not occured */\n        /* We have not been able to select a Tuner */\n        /* Some cards make use of the tuner address to */\n        /* identify the make/model of tuner */\n\n        /* At address 0xc0/0xc1 we often find a TEMIC NTSC */\n        if ( i2cRead( bktr, 0xc1 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n            goto checkDBX;\n        }\n  \n        /* At address 0xc6/0xc7 we often find a PHILIPS NTSC Tuner */\n        if ( i2cRead( bktr, 0xc7 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ PHILIPS_NTSC ];\n            goto checkDBX;\n        }\n\n        /* Address 0xc2/0xc3 is default (or common address) for several */\n\t/* tuners and we cannot tell which is which. */\n\t/* And for all other tuner i2c addresses, select the default */\n\tbktr->card.tuner = &tuners[ DEFAULT_TUNER ];\n\n\ncheckDBX:\n#if defined( OVERRIDE_DBX )\n\tbktr->card.dbx = OVERRIDE_DBX;\n\tgoto checkMSP;\n#endif\n   /* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSP;\n\t}\n\n\t/* probe for BTSC (dbx) chip */\n\tif ( i2cRead( bktr, TDA9850_RADDR ) != ABSENT )\n\t\tbktr->card.dbx = 1;\n\ncheckMSP:\n\t/* If this is a Hauppauge Bt878 card, we need to enable the\n\t * MSP 34xx audio chip. \n\t * If this is a Hauppauge Bt848 card, reset the MSP device.\n\t * The MSP reset line is wired to GPIO pin 5. On Bt878 cards a pulldown\n\t * resistor holds the device in reset until we set GPIO pin 5.\n         */\n\n\t/* Optionally skip the MSP reset. This is handy if you initialise the\n\t * MSP audio in another operating system (eg Windows) first and then\n\t * do a soft reboot.\n\t */\n\n#ifndef BKTR_NO_MSP_RESET\n\tif (card == CARD_HAUPPAUGE) {\n            bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n        }\n#endif\n\n#if defined( OVERRIDE_MSP )\n\tbktr->card.msp3400c = OVERRIDE_MSP;\n\tgoto checkMSPEnd;\n#endif\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSPEnd;\n\t}\n\n\tif ( i2cRead( bktr, MSP3400C_RADDR ) != ABSENT )\n\t\tbktr->card.msp3400c = 1;\n\ncheckMSPEnd:\n\n/* Start of Check Remote */\n        /* Check for the Hauppauge IR Remote Control */\n        /* If there is an external unit, the internal will be ignored */\n\n        bktr->remote_control = 0; /* initial value */\n\n        if (any_i2c_devices) {\n            if (i2cRead( bktr, HAUP_REMOTE_EXT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_EXT_RADDR;\n                }\n            else if (i2cRead( bktr, HAUP_REMOTE_INT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_INT_RADDR;\n                }\n\n        }\n        /* If a remote control is found, poll it 5 times to turn off the LED */\n        if (bktr->remote_control) {\n                int i;\n                for (i=0; i<5; i++)\n                        i2cRead( bktr, bktr->remote_control_addr );\n        }\n/* End of Check Remote */\n\n#if defined( BKTR_USE_PLL )\n\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\tgoto checkPLLEnd;\n#endif\n\t/* Default is to use XTALS and not PLL mode */\n\tbktr->xtal_pll_mode = BT848_USE_XTALS;\n\n\t/* Enable PLL mode for PAL/SECAM users on Hauppauge 878 cards */\n\tif ((card == CARD_HAUPPAUGE) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\n\t/* Enable PLL mode for OSPREY users */\n\tif (card == CARD_OSPREY)\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\t/* Enable PLL mode for PAL/SECAM users on FlyVideo 878 cards */\n\tif ((card == CARD_FLYVIDEO) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n#if defined( BKTR_USE_PLL )\ncheckPLLEnd:\n#endif\n\n\n\tbktr->card.tuner_pllAddr = tuner_i2c_address;\n\n\tif ( verbose ) {\n\t\tprintf( \"%s\", bktr->card.name );\n\t\tif ( bktr->card.tuner )\n\t\t\tprintf( \", %s tuner\", bktr->card.tuner->name );\n\t\tif ( bktr->card.dbx )\n\t\t\tprintf( \", dbx stereo\" );\n\t\tif ( bktr->card.msp3400c )\n\t\t\tprintf( \", msp3400c stereo\" );\n                if ( bktr->remote_control )\n                        printf( \", remote control\" );\n\t\tprintf( \".\\n\" );\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_open       bktropen\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define Bt848_MAX_CARD\t\t13\n#define Bt848_MAX_TUNER         14\n\nint\nbktr_open( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT( minor(dev) );\n\tif (unit >= NBKTR)\t\t\t/* unit out of range */\n\t\treturn( ENXIO );\n\n\tbktr = &(brooktree[ unit ]);\n\n\tif (!(bktr->flags & METEOR_INITALIZED)) /* device not found */\n\t\treturn( ENXIO );\t\n\n\n\tif (bt848_card != -1) {\n\t  if ((bt848_card >> 8   == unit ) &&\n\t     ( (bt848_card & 0xff) < Bt848_MAX_CARD )) {\n\t    if ( bktr->bt848_card != (bt848_card & 0xff) ) {\n\t      bktr->bt848_card = (bt848_card & 0xff);\n\t      probeCard(bktr, FALSE);\n\t    }\n\t  }\n\t}\n\n\tif (bt848_tuner != -1) {\n\t  if ((bt848_tuner >> 8   == unit ) &&\n\t     ( (bt848_tuner & 0xff) < Bt848_MAX_TUNER )) {\n\t    if ( bktr->bt848_tuner != (bt848_tuner & 0xff) ) {\n\t      bktr->bt848_tuner = (bt848_tuner & 0xff);\n\t      probeCard(bktr, FALSE);\n\t    }\n\t  }\n\t}\n\n\tif (bt848_reverse_mute != -1) {\n\t  if (((bt848_reverse_mute >> 8)   == unit ) &&\n\t      ((bt848_reverse_mute & 0xff) < Bt848_MAX_TUNER) ) {\n\t    bktr->reverse_mute = bt848_reverse_mute & 0xff;\n\t    bt848_reverse_mute = -1;\n\t  }\n\t}\n\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_open( bktr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_open( bktr ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_open( bktr ) );\n\t}\n\treturn( ENXIO );\n}"
  },
  {
    "function_name": "get_bktr_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7586-7601",
    "snippet": "static vm_offset_t\nget_bktr_mem( int unit, unsigned size )\n{\n\tvm_offset_t\taddr = 0;\n\n\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff, 1<<24);\n\tif (addr == 0)\n\t\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff,\n\t\t\t\t\t\t\t\tPAGE_SIZE);\n\tif (addr == 0) {\n\t\tprintf(\"bktr%d: Unable to allocate %d bytes of memory.\\n\",\n\t\t\tunit, size);\n\t}\n\n\treturn( addr );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bktr%d: Unable to allocate %d bytes of memory.\\n\"",
            "unit",
            "size"
          ],
          "line": 7596
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_page_alloc_contig",
          "args": [
            "size",
            "0x100000",
            "0xffffffff",
            "PAGE_SIZE"
          ],
          "line": 7593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_page_alloc_contig",
          "args": [
            "size",
            "0x100000",
            "0xffffffff",
            "1<<24"
          ],
          "line": 7591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic vm_offset_t\nget_bktr_mem( int unit, unsigned size )\n{\n\tvm_offset_t\taddr = 0;\n\n\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff, 1<<24);\n\tif (addr == 0)\n\t\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff,\n\t\t\t\t\t\t\t\tPAGE_SIZE);\n\tif (addr == 0) {\n\t\tprintf(\"bktr%d: Unable to allocate %d bytes of memory.\\n\",\n\t\t\tunit, size);\n\t}\n\n\treturn( addr );\n}"
  },
  {
    "function_name": "bktr_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7456-7580",
    "snippet": "static\tvoid\nbktr_attach( pcici_t tag, int unit )\n{\n\tbktr_ptr_t\tbktr;\n\tbt848_ptr_t\tbt848;\n\tu_long\t\tlatency;\n\tu_long\t\tfun;\n\tunsigned int\trev;\n#ifdef BROOKTREE_IRQ\n\tu_long\t\told_irq, new_irq;\n#endif \n\n\tbktr = &brooktree[unit];\n\n\tif (unit >= NBKTR) {\n\t\tprintf(\"brooktree%d: attach: only %d units configured.\\n\",\n\t\t        unit, NBKTR);\n\t\tprintf(\"brooktree%d: attach: invalid unit number.\\n\", unit);\n\t\treturn;\n\t}\n\n\t/* Enable Memory Mapping */\n\tfun = pci_conf_read(tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(tag, PCI_COMMAND_STATUS_REG, fun | 2);\n\n\t/* Enable Bus Mastering */\n\tfun = pci_conf_read(tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(tag, PCI_COMMAND_STATUS_REG, fun | 4);\n\n\tbktr->tag = tag;\n\n\n\t/*\n\t * Map control/status registers\n\t */\n\tpci_map_mem( tag, PCI_MAP_REG_START, (vm_offset_t *) &bktr->base,\n\t\t     &bktr->phys_base );\n\n\t/*\n\t * Disable the brooktree device\n\t */\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n#ifdef BROOKTREE_IRQ\t\t/* from the configuration file */\n\told_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tpci_conf_write(tag, PCI_INTERRUPT_REG, BROOKTREE_IRQ);\n\tnew_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tprintf(\"bktr%d: attach: irq changed from %d to %d\\n\",\n\t\tunit, (old_irq & 0xff), (new_irq & 0xff));\n#endif \n\n\t/*\n\t * setup the interrupt handling routine\n\t */\n\tpci_map_int(tag, bktr_intr, (void*) bktr, &net_imask);\n\n\n\t/* Update the Device Control Register */\n\t/* on Bt878 and Bt879 cards */\n\tfun = pci_conf_read(tag, 0x40);\n        fun = fun | 1;\t/* Enable writes to the sub-system vendor ID */\n\n#if defined( BKTR_430_FX_MODE )\n\tif (bootverbose) printf(\"Using 430 FX chipset compatibilty mode\\n\");\n        fun = fun | 2;\t/* Enable Intel 430 FX compatibility mode */\n#endif\n\n#if defined( BKTR_SIS_VIA_MODE )\n\tif (bootverbose) printf(\"Using SiS/VIA chipset compatibilty mode\\n\");\n        fun = fun | 4;\t/* Enable SiS/VIA compatibility mode (usefull for\n                           OPTi chipset motherboards too */\n#endif\n\tpci_conf_write(tag, 0x40, fun);\n\n\n\t/* XXX call bt848_i2c dependent attach() routine */\n#if (NSMBUS > 0)\n\tif (bt848_i2c_attach(unit, bktr->base, &bktr->i2c_sc))\n\t\tprintf(\"bktr%d: i2c_attach: can't attach\\n\", unit);\n#endif\n\n\n/*\n * PCI latency timer.  32 is a good value for 4 bus mastering slots, if\n * you have more than four, then 16 would probably be a better value.\n */\n#ifndef BROOKTREE_DEF_LATENCY_VALUE\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#endif\n\tlatency = pci_conf_read(tag, PCI_LATENCY_TIMER);\n\tlatency = (latency >> 8) & 0xff;\n\tif ( bootverbose ) {\n\t\tif (latency)\n\t\t\tprintf(\"brooktree%d: PCI bus latency is\", unit);\n\t\telse\n\t\t\tprintf(\"brooktree%d: PCI bus latency was 0 changing to\",\n\t\t\t\tunit);\n\t}\n\tif ( !latency ) {\n\t\tlatency = BROOKTREE_DEF_LATENCY_VALUE;\n\t\tpci_conf_write(tag, PCI_LATENCY_TIMER,\tlatency<<8);\n\t}\n\tif ( bootverbose ) {\n\t\tprintf(\" %d.\\n\", (int) latency);\n\t}\n\n\n\t/* read the pci device id and revision id */\n\tfun = pci_conf_read(tag, PCI_ID_REG);\n        rev = pci_conf_read(tag, PCIR_REVID) & 0x000000ff;\n\n\t/* call the common attach code */\n\tcommon_bktr_attach( bktr, unit, fun, rev );\n \n#ifdef DEVFS\n\t/* XXX This just throw away the token, which should probably be fixed when\n\t   DEVFS is finally made really operational. */\n\tdevfs_add_devswf(&bktr_cdevsw, unit,    DV_CHR, 0, 0, 0444, \"bktr%d\",  unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+16, DV_CHR, 0, 0, 0444, \"tuner%d\", unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+32, DV_CHR, 0, 0, 0444, \"vbi%d\", unit);\n#endif /* DEVFS */\n\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define NBKTR bktrcd.cd_ndevs",
      "#define PCI_COMMAND_STATUS_REG PCI_COMMAND",
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define ALL_INTS_DISABLED\t0",
      "#define FIFO_RISC_DISABLED\t0",
      "#define NSMBUS 0",
      "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))",
      "#define NSMBUS 0",
      "#define PCIR_REVID     PCI_CLASS_REG",
      "#define NSMBUS 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devfs_add_devswf",
          "args": [
            "&bktr_cdevsw",
            "unit+32",
            "DV_CHR",
            "0",
            "0",
            "0444",
            "\"vbi%d\"",
            "unit"
          ],
          "line": 7577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devfs_add_devswf",
          "args": [
            "&bktr_cdevsw",
            "unit+16",
            "DV_CHR",
            "0",
            "0",
            "0444",
            "\"tuner%d\"",
            "unit"
          ],
          "line": 7576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devfs_add_devswf",
          "args": [
            "&bktr_cdevsw",
            "unit",
            "DV_CHR",
            "0",
            "0",
            "0444",
            "\"bktr%d\"",
            "unit"
          ],
          "line": 7575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "common_bktr_attach",
          "args": [
            "bktr",
            "unit",
            "fun",
            "rev"
          ],
          "line": 7570
        },
        "resolved": true,
        "details": {
          "function_name": "common_bktr_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1447-1558",
          "snippet": "static void \ncommon_bktr_attach( bktr_ptr_t bktr, int unit, u_long pci_id, u_int rev )\n{\n\tbt848_ptr_t\tbt848;\n\tvm_offset_t\tbuf;\n\n\tbt848 = bktr->base;\n\n/***************************************/\n/* *** OS Specific memory routines *** */\n/***************************************/\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n        /* allocate space for dma program */\n        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);\n        bktr->odd_dma_prog = get_bktr_mem(bktr, &bktr->dm_oprog, DMA_PROG_ALLOC)\n;\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(bktr, &bktr->dm_vbibuffer, VBI_BUFFER_SIZE);\n\n        /* allocate space for pixel buffer */\n        if ( BROOKTREE_ALLOC )\n                buf = get_bktr_mem(bktr, &bktr->dm_mem, BROOKTREE_ALLOC);\n        else\n                buf = 0;\n#endif\n\n#if defined(__FreeBSD__) || defined(__bsdi__)\n\t/* allocate space for dma program */\n\tbktr->dma_prog     = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\tbktr->odd_dma_prog = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(unit, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(unit, VBI_BUFFER_SIZE);\n\n\t/* allocate space for pixel buffer */\n\tif ( BROOKTREE_ALLOC )\n\t\tbuf = get_bktr_mem(unit, BROOKTREE_ALLOC);\n\telse\n\t\tbuf = 0;\n#endif\n\n\tif ( bootverbose ) {\n\t\tprintf(\"bktr%d: buffer size %d, addr 0x%x\\n\",\n\t\t\tunit, BROOKTREE_ALLOC, vtophys(buf));\n\t}\n\n\tif ( buf != 0 ) {\n\t\tbktr->bigbuf = buf;\n\t\tbktr->alloc_pages = BROOKTREE_ALLOC_PAGES;\n\t\tbzero((caddr_t) bktr->bigbuf, BROOKTREE_ALLOC);\n\t} else {\n\t\tbktr->alloc_pages = 0;\n\t}\n\t\t\n\n\tbktr->flags = METEOR_INITALIZED | METEOR_AUTOMODE |\n\t\t      METEOR_DEV0 | METEOR_RGB16;\n\tbktr->dma_prog_loaded = FALSE;\n\tbktr->cols = 640;\n\tbktr->rows = 480;\n\tbktr->frames = 1;\t\t/* one frame */\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\tbktr->pixfmt_compat = TRUE;\n\n\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbiflags = 0;\n\n \n\t/* using the pci device id and revision id */\n\t/* and determine the card type            */\n\tswitch (pci_id) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) bktr->id = BROOKTREE_848A;\n\t\telse             bktr->id = BROOKTREE_848;\n\t\tbreak;\n        case BROOKTREE_849_PCI_ID:\n\t\tbktr->id = BROOKTREE_849A;\n\t\tbreak;\n        case BROOKTREE_878_PCI_ID:\n\t\tbktr->id = BROOKTREE_878;\n\t\tbreak;\n        case BROOKTREE_879_PCI_ID:\n\t\tbktr->id = BROOKTREE_879;\n\t\tbreak;\n\t};\n\n\tbktr->clr_on_start = FALSE;\n\n\t/* defaults for the tuner section of the card */\n\tbktr->tflags = TUNER_INITALIZED;\n\tbktr->tuner.frequency = 0;\n\tbktr->tuner.channel = 0;\n\tbktr->tuner.chnlset = DEFAULT_CHNLSET;\n\tbktr->audio_mux_select = 0;\n\tbktr->audio_mute_state = FALSE;\n\tbktr->bt848_card = -1;\n\tbktr->bt848_tuner = -1;\n\tbktr->reverse_mute = -1;\n\n\tprobeCard( bktr, TRUE );\n\n\t/* If there is an MSP Audio device, reset it and display the model */\n\tif (bktr->card.msp3400c)msp_reset(bktr);\n\tif (bktr->card.msp3400c)msp_read_id(bktr);\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CHNLSET\tCHNLSET_WEUROPE",
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)",
            "#define BROOKTREE_ALLOC\t\t(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)",
            "#define BROOKTREE_ALLOC_PAGES\t217*4",
            "#define DMA_PROG_ALLOC\t\t(8 * PAGE_SIZE)",
            "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define DEFAULT_CHNLSET\tCHNLSET_WEUROPE\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n#define BROOKTREE_ALLOC\t\t(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)\n#define BROOKTREE_ALLOC_PAGES\t217*4\n#define DMA_PROG_ALLOC\t\t(8 * PAGE_SIZE)\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n\nstatic void \ncommon_bktr_attach( bktr_ptr_t bktr, int unit, u_long pci_id, u_int rev )\n{\n\tbt848_ptr_t\tbt848;\n\tvm_offset_t\tbuf;\n\n\tbt848 = bktr->base;\n\n/***************************************/\n/* *** OS Specific memory routines *** */\n/***************************************/\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n        /* allocate space for dma program */\n        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);\n        bktr->odd_dma_prog = get_bktr_mem(bktr, &bktr->dm_oprog, DMA_PROG_ALLOC)\n;\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(bktr, &bktr->dm_vbibuffer, VBI_BUFFER_SIZE);\n\n        /* allocate space for pixel buffer */\n        if ( BROOKTREE_ALLOC )\n                buf = get_bktr_mem(bktr, &bktr->dm_mem, BROOKTREE_ALLOC);\n        else\n                buf = 0;\n#endif\n\n#if defined(__FreeBSD__) || defined(__bsdi__)\n\t/* allocate space for dma program */\n\tbktr->dma_prog     = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\tbktr->odd_dma_prog = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(unit, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(unit, VBI_BUFFER_SIZE);\n\n\t/* allocate space for pixel buffer */\n\tif ( BROOKTREE_ALLOC )\n\t\tbuf = get_bktr_mem(unit, BROOKTREE_ALLOC);\n\telse\n\t\tbuf = 0;\n#endif\n\n\tif ( bootverbose ) {\n\t\tprintf(\"bktr%d: buffer size %d, addr 0x%x\\n\",\n\t\t\tunit, BROOKTREE_ALLOC, vtophys(buf));\n\t}\n\n\tif ( buf != 0 ) {\n\t\tbktr->bigbuf = buf;\n\t\tbktr->alloc_pages = BROOKTREE_ALLOC_PAGES;\n\t\tbzero((caddr_t) bktr->bigbuf, BROOKTREE_ALLOC);\n\t} else {\n\t\tbktr->alloc_pages = 0;\n\t}\n\t\t\n\n\tbktr->flags = METEOR_INITALIZED | METEOR_AUTOMODE |\n\t\t      METEOR_DEV0 | METEOR_RGB16;\n\tbktr->dma_prog_loaded = FALSE;\n\tbktr->cols = 640;\n\tbktr->rows = 480;\n\tbktr->frames = 1;\t\t/* one frame */\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\tbktr->pixfmt_compat = TRUE;\n\n\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbiflags = 0;\n\n \n\t/* using the pci device id and revision id */\n\t/* and determine the card type            */\n\tswitch (pci_id) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) bktr->id = BROOKTREE_848A;\n\t\telse             bktr->id = BROOKTREE_848;\n\t\tbreak;\n        case BROOKTREE_849_PCI_ID:\n\t\tbktr->id = BROOKTREE_849A;\n\t\tbreak;\n        case BROOKTREE_878_PCI_ID:\n\t\tbktr->id = BROOKTREE_878;\n\t\tbreak;\n        case BROOKTREE_879_PCI_ID:\n\t\tbktr->id = BROOKTREE_879;\n\t\tbreak;\n\t};\n\n\tbktr->clr_on_start = FALSE;\n\n\t/* defaults for the tuner section of the card */\n\tbktr->tflags = TUNER_INITALIZED;\n\tbktr->tuner.frequency = 0;\n\tbktr->tuner.channel = 0;\n\tbktr->tuner.chnlset = DEFAULT_CHNLSET;\n\tbktr->audio_mux_select = 0;\n\tbktr->audio_mute_state = FALSE;\n\tbktr->bt848_card = -1;\n\tbktr->bt848_tuner = -1;\n\tbktr->reverse_mute = -1;\n\n\tprobeCard( bktr, TRUE );\n\n\t/* If there is an MSP Audio device, reset it and display the model */\n\tif (bktr->card.msp3400c)msp_reset(bktr);\n\tif (bktr->card.msp3400c)msp_read_id(bktr);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCIR_REVID"
          ],
          "line": 7567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_ID_REG"
          ],
          "line": 7566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %d.\\n\"",
            "(int) latency"
          ],
          "line": 7561
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "tag",
            "PCI_LATENCY_TIMER",
            "latency<<8"
          ],
          "line": 7558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_LATENCY_TIMER"
          ],
          "line": 7547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt848_i2c_attach",
          "args": [
            "unit",
            "bktr->base",
            "&bktr->i2c_sc"
          ],
          "line": 7535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "tag",
            "0x40",
            "fun"
          ],
          "line": 7530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "0x40"
          ],
          "line": 7517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_map_int",
          "args": [
            "tag",
            "bktr_intr",
            "(void*) bktr",
            "&net_imask"
          ],
          "line": 7512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_INTERRUPT_REG"
          ],
          "line": 7504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "tag",
            "PCI_INTERRUPT_REG",
            "BROOKTREE_IRQ"
          ],
          "line": 7503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_INTERRUPT_REG"
          ],
          "line": 7502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_map_mem",
          "args": [
            "tag",
            "PCI_MAP_REG_START",
            "(vm_offset_t *) &bktr->base",
            "&bktr->phys_base"
          ],
          "line": 7491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "tag",
            "PCI_COMMAND_STATUS_REG",
            "fun | 4"
          ],
          "line": 7483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 7482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "tag",
            "PCI_COMMAND_STATUS_REG",
            "fun | 2"
          ],
          "line": 7479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 7478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define NBKTR bktrcd.cd_ndevs\n#define PCI_COMMAND_STATUS_REG PCI_COMMAND\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n#define NSMBUS 0\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n#define NSMBUS 0\n#define PCIR_REVID     PCI_CLASS_REG\n#define NSMBUS 0\n\nstatic\tvoid\nbktr_attach( pcici_t tag, int unit )\n{\n\tbktr_ptr_t\tbktr;\n\tbt848_ptr_t\tbt848;\n\tu_long\t\tlatency;\n\tu_long\t\tfun;\n\tunsigned int\trev;\n#ifdef BROOKTREE_IRQ\n\tu_long\t\told_irq, new_irq;\n#endif \n\n\tbktr = &brooktree[unit];\n\n\tif (unit >= NBKTR) {\n\t\tprintf(\"brooktree%d: attach: only %d units configured.\\n\",\n\t\t        unit, NBKTR);\n\t\tprintf(\"brooktree%d: attach: invalid unit number.\\n\", unit);\n\t\treturn;\n\t}\n\n\t/* Enable Memory Mapping */\n\tfun = pci_conf_read(tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(tag, PCI_COMMAND_STATUS_REG, fun | 2);\n\n\t/* Enable Bus Mastering */\n\tfun = pci_conf_read(tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(tag, PCI_COMMAND_STATUS_REG, fun | 4);\n\n\tbktr->tag = tag;\n\n\n\t/*\n\t * Map control/status registers\n\t */\n\tpci_map_mem( tag, PCI_MAP_REG_START, (vm_offset_t *) &bktr->base,\n\t\t     &bktr->phys_base );\n\n\t/*\n\t * Disable the brooktree device\n\t */\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n#ifdef BROOKTREE_IRQ\t\t/* from the configuration file */\n\told_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tpci_conf_write(tag, PCI_INTERRUPT_REG, BROOKTREE_IRQ);\n\tnew_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tprintf(\"bktr%d: attach: irq changed from %d to %d\\n\",\n\t\tunit, (old_irq & 0xff), (new_irq & 0xff));\n#endif \n\n\t/*\n\t * setup the interrupt handling routine\n\t */\n\tpci_map_int(tag, bktr_intr, (void*) bktr, &net_imask);\n\n\n\t/* Update the Device Control Register */\n\t/* on Bt878 and Bt879 cards */\n\tfun = pci_conf_read(tag, 0x40);\n        fun = fun | 1;\t/* Enable writes to the sub-system vendor ID */\n\n#if defined( BKTR_430_FX_MODE )\n\tif (bootverbose) printf(\"Using 430 FX chipset compatibilty mode\\n\");\n        fun = fun | 2;\t/* Enable Intel 430 FX compatibility mode */\n#endif\n\n#if defined( BKTR_SIS_VIA_MODE )\n\tif (bootverbose) printf(\"Using SiS/VIA chipset compatibilty mode\\n\");\n        fun = fun | 4;\t/* Enable SiS/VIA compatibility mode (usefull for\n                           OPTi chipset motherboards too */\n#endif\n\tpci_conf_write(tag, 0x40, fun);\n\n\n\t/* XXX call bt848_i2c dependent attach() routine */\n#if (NSMBUS > 0)\n\tif (bt848_i2c_attach(unit, bktr->base, &bktr->i2c_sc))\n\t\tprintf(\"bktr%d: i2c_attach: can't attach\\n\", unit);\n#endif\n\n\n/*\n * PCI latency timer.  32 is a good value for 4 bus mastering slots, if\n * you have more than four, then 16 would probably be a better value.\n */\n#ifndef BROOKTREE_DEF_LATENCY_VALUE\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#endif\n\tlatency = pci_conf_read(tag, PCI_LATENCY_TIMER);\n\tlatency = (latency >> 8) & 0xff;\n\tif ( bootverbose ) {\n\t\tif (latency)\n\t\t\tprintf(\"brooktree%d: PCI bus latency is\", unit);\n\t\telse\n\t\t\tprintf(\"brooktree%d: PCI bus latency was 0 changing to\",\n\t\t\t\tunit);\n\t}\n\tif ( !latency ) {\n\t\tlatency = BROOKTREE_DEF_LATENCY_VALUE;\n\t\tpci_conf_write(tag, PCI_LATENCY_TIMER,\tlatency<<8);\n\t}\n\tif ( bootverbose ) {\n\t\tprintf(\" %d.\\n\", (int) latency);\n\t}\n\n\n\t/* read the pci device id and revision id */\n\tfun = pci_conf_read(tag, PCI_ID_REG);\n        rev = pci_conf_read(tag, PCIR_REVID) & 0x000000ff;\n\n\t/* call the common attach code */\n\tcommon_bktr_attach( bktr, unit, fun, rev );\n \n#ifdef DEVFS\n\t/* XXX This just throw away the token, which should probably be fixed when\n\t   DEVFS is finally made really operational. */\n\tdevfs_add_devswf(&bktr_cdevsw, unit,    DV_CHR, 0, 0, 0444, \"bktr%d\",  unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+16, DV_CHR, 0, 0, 0444, \"tuner%d\", unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+32, DV_CHR, 0, 0, 0444, \"vbi%d\", unit);\n#endif /* DEVFS */\n\n}"
  },
  {
    "function_name": "bktr_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7433-7451",
    "snippet": "static const char*\nbktr_probe( pcici_t tag, pcidi_t type )\n{\n        unsigned int rev = pci_conf_read( tag, PCIR_REVID) & 0x000000ff;\n\t \n\tswitch (type) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) return(\"BrookTree 848A\");\n\t\telse             return(\"BrookTree 848\"); \n        case BROOKTREE_849_PCI_ID:\n                return(\"BrookTree 849A\");\n        case BROOKTREE_878_PCI_ID:\n                return(\"BrookTree 878\");\n        case BROOKTREE_879_PCI_ID:\n                return(\"BrookTree 879\");\n\t};\n\n\treturn ((char *)0);\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define PCIR_REVID     PCI_CLASS_REG"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCIR_REVID"
          ],
          "line": 7436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define PCIR_REVID     PCI_CLASS_REG\n\nstatic const char*\nbktr_probe( pcici_t tag, pcidi_t type )\n{\n        unsigned int rev = pci_conf_read( tag, PCIR_REVID) & 0x000000ff;\n\t \n\tswitch (type) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) return(\"BrookTree 848A\");\n\t\telse             return(\"BrookTree 848\"); \n        case BROOKTREE_849_PCI_ID:\n                return(\"BrookTree 849A\");\n        case BROOKTREE_878_PCI_ID:\n                return(\"BrookTree 878\");\n        case BROOKTREE_879_PCI_ID:\n                return(\"BrookTree 879\");\n\t};\n\n\treturn ((char *)0);\n}"
  },
  {
    "function_name": "bktr_drvinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7416-7426",
    "snippet": "static void\nbktr_drvinit( void *unused )\n{\n\tdev_t dev;\n\n\tif ( ! bktr_devsw_installed ) {\n\t\tdev = makedev(CDEV_MAJOR, 0);\n\t\tcdevsw_add(&dev,&bktr_cdevsw, NULL);\n\t\tbktr_devsw_installed = 1;\n\t}\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define CDEV_MAJOR 92",
      "#define CDEV_MAJOR 92"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cdevsw_add",
          "args": [
            "&dev",
            "&bktr_cdevsw",
            "NULL"
          ],
          "line": 7423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makedev",
          "args": [
            "CDEV_MAJOR",
            "0"
          ],
          "line": 7422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CDEV_MAJOR 92\n#define CDEV_MAJOR 92\n\nstatic void\nbktr_drvinit( void *unused )\n{\n\tdev_t dev;\n\n\tif ( ! bktr_devsw_installed ) {\n\t\tdev = makedev(CDEV_MAJOR, 0);\n\t\tcdevsw_add(&dev,&bktr_cdevsw, NULL);\n\t\tbktr_devsw_installed = 1;\n\t}\n}"
  },
  {
    "function_name": "bktr_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7385-7385",
    "snippet": "static void\t\tbktr_intr(void *arg) { common_bktr_intr(arg); }",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_bktr_intr",
          "args": [
            "arg"
          ],
          "line": 7385
        },
        "resolved": true,
        "details": {
          "function_name": "common_bktr_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1608-1853",
          "snippet": "static int \ncommon_bktr_intr( void *arg )\n{ \n\tbktr_ptr_t\t\tbktr;\n\tbt848_ptr_t\t\tbt848;\n\tu_long\t\t\tbktr_status;\n\tu_char\t\t\tdstatus;\n\tu_long                  field;\n\tu_long                  w_field;\n\tu_long                  req_field;\n\n\tbktr = (bktr_ptr_t) arg;\n\tbt848 = bktr->base;\n\n\t/*\n\t * check to see if any interrupts are unmasked on this device.  If\n\t * none are, then we likely got here by way of being on a PCI shared\n\t * interrupt dispatch list.\n\t */\n\tif (bt848->int_mask == ALL_INTS_DISABLED)\n\t  \treturn 0;\t/* bail out now, before we do something we\n\t\t\t\t   shouldn't */\n\n\tif (!(bktr->flags & METEOR_OPEN)) {\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\t\t/* return; ?? */\n\t}\n\n\t/* record and clear the INTerrupt status bits */\n\tbktr_status = bt848->int_stat;\n\tbt848->int_stat = bktr_status & ~I2C_BITS;\t/* don't touch i2c */\n\n\t/* record and clear the device status register */\n\tdstatus = bt848->dstatus;\n\tbt848->dstatus = 0x00;\n\n#if defined( STATUS_SUM )\n\t/* add any new device status or INTerrupt status bits */\n\tstatus_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));\n\tstatus_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);\n#endif /* STATUS_SUM */\n\t/* printf( \" STATUS %x %x %x \\n\",\n\t\tdstatus, bktr_status, bt848->risc_count );\n\t*/\n\n\n\t/* if risc was disabled re-start process again */\n\tif ( !(bktr_status & BT848_INT_RISC_EN) ||\n\t     ((bktr_status &(BT848_INT_FBUS   |\n\t\t\t      BT848_INT_FTRGT  |\n\t\t\t      BT848_INT_FDSR   |\n\t\t\t      BT848_INT_PPERR  |\n\t\t\t      BT848_INT_RIPERR |\n\t\t\t      BT848_INT_PABORT |\n\t\t\t      BT848_INT_OCERR  |\n\t\t\t      BT848_INT_SCERR) ) != 0) ||\n\t     ((bt848->tdec == 0) && (bktr_status & TDEC_BITS)) ) {\n\n\t\tu_short\ttdec_save = bt848->tdec;\n\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t/*  Reset temporal decimation ctr  */\n\t\tbt848->tdec = 0;\n\t\tbt848->tdec = tdec_save;\n\t\t\n\t\t/*  Reset to no-fields captured state  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\n\t\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n\t\t\t\t  BT848_INT_RISCI      |\n\t\t\t\t  BT848_INT_VSYNC      |\n\t\t\t\t  BT848_INT_FMTCHG;\n\n\t\tbt848->cap_ctl = bktr->bktr_cap_ctl;\n\t\treturn 1;\n\t}\n\n\t/* If this is not a RISC program interrupt, return */\n\tif (!(bktr_status & BT848_INT_RISCI))\n\t\treturn 0;\n\n/**\n\tprintf( \"intr status %x %x %x\\n\",\n\t\tbktr_status, dstatus, bt848->risc_count );\n */\n\t\n\n\t/*\n\t * Disable future interrupts if a capture mode is not selected.\n\t * This can happen when we are in the process of closing or \n\t * changing capture modes, otherwise it shouldn't happen.\n\t */\n\tif (!(bktr->flags & METEOR_CAP_MASK))\n\t\tbt848->cap_ctl = CAPTURE_OFF;\n\n\t/*\n\t *  Register the completed field\n\t *    (For dual-field mode, require fields from the same frame)\n\t */\n\tfield = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;\n\tswitch ( bktr->flags & METEOR_WANT_MASK ) {\n\t\tcase METEOR_WANT_ODD  : w_field = ODD_F         ;  break;\n\t\tcase METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;\n\t\tdefault               : w_field = (ODD_F|EVEN_F);  break;\n\t}\n\tswitch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {\n\t\tcase METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;\n\t\tcase METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;\n\t\tdefault                      : req_field = (ODD_F|EVEN_F);  \n\t\t\t                       break;\n\t}\n\n\tif (( field == EVEN_F ) && ( w_field == EVEN_F ))\n\t\tbktr->flags &= ~METEOR_WANT_EVEN;\n\telse if (( field == ODD_F ) && ( req_field == ODD_F ) &&\n\t\t ( w_field == ODD_F ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == (ODD_F|EVEN_F) ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == ODD_F )) {\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\t\tbktr->flags |=  METEOR_WANT_EVEN;\n\t}\n\telse {\n\t\t/*  We're out of sync.  Start over.  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If we have a complete frame.\n\t */\n\tif (!(bktr->flags & METEOR_WANT_MASK)) {\n\t\tbktr->frames_captured++;\n\t\t/*\n\t\t * post the completion time. \n\t\t */\n\t\tif (bktr->flags & METEOR_WANT_TS) {\n\t\t\tstruct timeval *ts;\n\t\t\t\n\t\t\tif ((u_int) bktr->alloc_pages * PAGE_SIZE\n\t\t\t   <= (bktr->frame_size + sizeof(struct timeval))) {\n\t\t\t\tts =(struct timeval *)bktr->bigbuf +\n\t\t\t\t  bktr->frame_size;\n\t\t\t\t/* doesn't work in synch mode except\n\t\t\t\t *  for first frame */\n\t\t\t\t/* XXX */\n\t\t\t\tmicrotime(ts);\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Process the VBI data if it is being captured\n\t\t */\n\t\tif (bktr->vbiflags & VBI_CAPTURE) {\n                \tvbidecode(bktr);\n                \twakeup(VBI_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * Wake up the user in single capture mode.\n\t\t */\n\t\tif (bktr->flags & METEOR_SINGLE) {\n\n\t\t\t/* stop dma */\n\t\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t\t/* disable risc, leave fifo running */\n\t\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\t\twakeup(BKTR_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * If the user requested to be notified via signal,\n\t\t * let them know the frame is complete.\n\t\t */\n\n\t\tif (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))\n\t\t\tpsignal( bktr->proc,\n\t\t\t\t bktr->signal&(~METEOR_SIG_MODE_MASK) );\n\n\t\t/*\n\t\t * Reset the want flags if in continuous or\n\t\t * synchronous capture mode.\n\t\t */\n/*\n* XXX NOTE (Luigi):\n* currently we only support 3 capture modes: odd only, even only,\n* odd+even interlaced (odd field first). A fourth mode (non interlaced,\n* either even OR odd) could provide 60 (50 for PAL) pictures per\n* second, but it would require this routine to toggle the desired frame\n* each time, and one more different DMA program for the Bt848.\n* As a consequence, this fourth mode is currently unsupported.\n*/\n\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)",
            "#define I2C_BITS\t\t(BT848_INT_RACK | BT848_INT_I2CDONE)",
            "#define CAPTURE_OFF\t\t0",
            "#define ALL_INTS_DISABLED\t0",
            "#define FIFO_RISC_DISABLED\t0",
            "#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN",
            "#define STATUS_SUM",
            "#define VBI_SLEEP   ((caddr_t)bktr + 1)",
            "#define BKTR_SLEEP  ((caddr_t)bktr    )",
            "#define EVEN_F 0x02",
            "#define ODD_F  0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)\n#define I2C_BITS\t\t(BT848_INT_RACK | BT848_INT_I2CDONE)\n#define CAPTURE_OFF\t\t0\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN\n#define STATUS_SUM\n#define VBI_SLEEP   ((caddr_t)bktr + 1)\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n#define EVEN_F 0x02\n#define ODD_F  0x01\n\nstatic int \ncommon_bktr_intr( void *arg )\n{ \n\tbktr_ptr_t\t\tbktr;\n\tbt848_ptr_t\t\tbt848;\n\tu_long\t\t\tbktr_status;\n\tu_char\t\t\tdstatus;\n\tu_long                  field;\n\tu_long                  w_field;\n\tu_long                  req_field;\n\n\tbktr = (bktr_ptr_t) arg;\n\tbt848 = bktr->base;\n\n\t/*\n\t * check to see if any interrupts are unmasked on this device.  If\n\t * none are, then we likely got here by way of being on a PCI shared\n\t * interrupt dispatch list.\n\t */\n\tif (bt848->int_mask == ALL_INTS_DISABLED)\n\t  \treturn 0;\t/* bail out now, before we do something we\n\t\t\t\t   shouldn't */\n\n\tif (!(bktr->flags & METEOR_OPEN)) {\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\t\t/* return; ?? */\n\t}\n\n\t/* record and clear the INTerrupt status bits */\n\tbktr_status = bt848->int_stat;\n\tbt848->int_stat = bktr_status & ~I2C_BITS;\t/* don't touch i2c */\n\n\t/* record and clear the device status register */\n\tdstatus = bt848->dstatus;\n\tbt848->dstatus = 0x00;\n\n#if defined( STATUS_SUM )\n\t/* add any new device status or INTerrupt status bits */\n\tstatus_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));\n\tstatus_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);\n#endif /* STATUS_SUM */\n\t/* printf( \" STATUS %x %x %x \\n\",\n\t\tdstatus, bktr_status, bt848->risc_count );\n\t*/\n\n\n\t/* if risc was disabled re-start process again */\n\tif ( !(bktr_status & BT848_INT_RISC_EN) ||\n\t     ((bktr_status &(BT848_INT_FBUS   |\n\t\t\t      BT848_INT_FTRGT  |\n\t\t\t      BT848_INT_FDSR   |\n\t\t\t      BT848_INT_PPERR  |\n\t\t\t      BT848_INT_RIPERR |\n\t\t\t      BT848_INT_PABORT |\n\t\t\t      BT848_INT_OCERR  |\n\t\t\t      BT848_INT_SCERR) ) != 0) ||\n\t     ((bt848->tdec == 0) && (bktr_status & TDEC_BITS)) ) {\n\n\t\tu_short\ttdec_save = bt848->tdec;\n\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t/*  Reset temporal decimation ctr  */\n\t\tbt848->tdec = 0;\n\t\tbt848->tdec = tdec_save;\n\t\t\n\t\t/*  Reset to no-fields captured state  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\n\t\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n\t\t\t\t  BT848_INT_RISCI      |\n\t\t\t\t  BT848_INT_VSYNC      |\n\t\t\t\t  BT848_INT_FMTCHG;\n\n\t\tbt848->cap_ctl = bktr->bktr_cap_ctl;\n\t\treturn 1;\n\t}\n\n\t/* If this is not a RISC program interrupt, return */\n\tif (!(bktr_status & BT848_INT_RISCI))\n\t\treturn 0;\n\n/**\n\tprintf( \"intr status %x %x %x\\n\",\n\t\tbktr_status, dstatus, bt848->risc_count );\n */\n\t\n\n\t/*\n\t * Disable future interrupts if a capture mode is not selected.\n\t * This can happen when we are in the process of closing or \n\t * changing capture modes, otherwise it shouldn't happen.\n\t */\n\tif (!(bktr->flags & METEOR_CAP_MASK))\n\t\tbt848->cap_ctl = CAPTURE_OFF;\n\n\t/*\n\t *  Register the completed field\n\t *    (For dual-field mode, require fields from the same frame)\n\t */\n\tfield = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;\n\tswitch ( bktr->flags & METEOR_WANT_MASK ) {\n\t\tcase METEOR_WANT_ODD  : w_field = ODD_F         ;  break;\n\t\tcase METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;\n\t\tdefault               : w_field = (ODD_F|EVEN_F);  break;\n\t}\n\tswitch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {\n\t\tcase METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;\n\t\tcase METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;\n\t\tdefault                      : req_field = (ODD_F|EVEN_F);  \n\t\t\t                       break;\n\t}\n\n\tif (( field == EVEN_F ) && ( w_field == EVEN_F ))\n\t\tbktr->flags &= ~METEOR_WANT_EVEN;\n\telse if (( field == ODD_F ) && ( req_field == ODD_F ) &&\n\t\t ( w_field == ODD_F ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == (ODD_F|EVEN_F) ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == ODD_F )) {\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\t\tbktr->flags |=  METEOR_WANT_EVEN;\n\t}\n\telse {\n\t\t/*  We're out of sync.  Start over.  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If we have a complete frame.\n\t */\n\tif (!(bktr->flags & METEOR_WANT_MASK)) {\n\t\tbktr->frames_captured++;\n\t\t/*\n\t\t * post the completion time. \n\t\t */\n\t\tif (bktr->flags & METEOR_WANT_TS) {\n\t\t\tstruct timeval *ts;\n\t\t\t\n\t\t\tif ((u_int) bktr->alloc_pages * PAGE_SIZE\n\t\t\t   <= (bktr->frame_size + sizeof(struct timeval))) {\n\t\t\t\tts =(struct timeval *)bktr->bigbuf +\n\t\t\t\t  bktr->frame_size;\n\t\t\t\t/* doesn't work in synch mode except\n\t\t\t\t *  for first frame */\n\t\t\t\t/* XXX */\n\t\t\t\tmicrotime(ts);\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Process the VBI data if it is being captured\n\t\t */\n\t\tif (bktr->vbiflags & VBI_CAPTURE) {\n                \tvbidecode(bktr);\n                \twakeup(VBI_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * Wake up the user in single capture mode.\n\t\t */\n\t\tif (bktr->flags & METEOR_SINGLE) {\n\n\t\t\t/* stop dma */\n\t\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t\t/* disable risc, leave fifo running */\n\t\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\t\twakeup(BKTR_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * If the user requested to be notified via signal,\n\t\t * let them know the frame is complete.\n\t\t */\n\n\t\tif (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))\n\t\t\tpsignal( bktr->proc,\n\t\t\t\t bktr->signal&(~METEOR_SIG_MODE_MASK) );\n\n\t\t/*\n\t\t * Reset the want flags if in continuous or\n\t\t * synchronous capture mode.\n\t\t */\n/*\n* XXX NOTE (Luigi):\n* currently we only support 3 capture modes: odd only, even only,\n* odd+even interlaced (odd field first). A fourth mode (non interlaced,\n* either even OR odd) could provide 60 (50 for PAL) pictures per\n* second, but it would require this routine to toggle the desired frame\n* each time, and one more different DMA program for the Bt848.\n* As a consequence, this fourth mode is currently unsupported.\n*/\n\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic void\t\tbktr_intr(void *arg) { common_bktr_intr(arg); }"
  },
  {
    "function_name": "bktr_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7342-7370",
    "snippet": "int\nbktr_mmap( dev_t dev, vm_offset_t offset, int nprot )\n{\n\tint\t\tunit;\n\tbktr_ptr_t\tbktr;\n\n\tunit = UNIT(minor(dev));\n\n\tif (FUNCTION(minor(dev)) > 0)\t/* only allow mmap on /dev/bktr[n] */\n\t\treturn( -1 );\n\n\t/* Get the device data */\n\tbktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);\n\tif (bktr == NULL) {\n\t\t/* the device is no longer valid/functioning */\n\t\treturn (ENXIO);\n\t}\n\n\tif (nprot & PROT_EXEC)\n\t\treturn( -1 );\n\n\tif (offset < 0)\n\t\treturn( -1 );\n\n\tif (offset >= bktr->alloc_pages * PAGE_SIZE)\n\t\treturn( -1 );\n\n\treturn( i386_btop(vtophys(bktr->bigbuf) + offset) );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define bktr_mmap       bktrmmap",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i386_btop",
          "args": [
            "vtophys(bktr->bigbuf) + offset"
          ],
          "line": 7369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->bigbuf"
          ],
          "line": 7369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devclass_get_softc",
          "args": [
            "bktr_devclass",
            "unit"
          ],
          "line": 7354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define bktr_mmap       bktrmmap\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n\nint\nbktr_mmap( dev_t dev, vm_offset_t offset, int nprot )\n{\n\tint\t\tunit;\n\tbktr_ptr_t\tbktr;\n\n\tunit = UNIT(minor(dev));\n\n\tif (FUNCTION(minor(dev)) > 0)\t/* only allow mmap on /dev/bktr[n] */\n\t\treturn( -1 );\n\n\t/* Get the device data */\n\tbktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);\n\tif (bktr == NULL) {\n\t\t/* the device is no longer valid/functioning */\n\t\treturn (ENXIO);\n\t}\n\n\tif (nprot & PROT_EXEC)\n\t\treturn( -1 );\n\n\tif (offset < 0)\n\t\treturn( -1 );\n\n\tif (offset >= bktr->alloc_pages * PAGE_SIZE)\n\t\treturn( -1 );\n\n\treturn( i386_btop(vtophys(bktr->bigbuf) + offset) );\n}"
  },
  {
    "function_name": "bktr_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7310-7336",
    "snippet": "int\nbktr_ioctl( dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT(minor(dev));\n\n\t/* Get the device data */\n\tbktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);\n\tif (bktr == NULL) {\n\t\t/* the device is no longer valid/functioning */\n\t\treturn (ENXIO);\n\t}\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_ioctl( bktr, unit, cmd, arg, pr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_ioctl( bktr, unit, cmd, arg, pr ) );\n\t}\n\n\treturn( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_ioctl      bktrioctl",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuner_ioctl",
          "args": [
            "bktr",
            "unit",
            "cmd",
            "arg",
            "pr"
          ],
          "line": 7332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "video_ioctl",
          "args": [
            "bktr",
            "unit",
            "cmd",
            "arg",
            "pr"
          ],
          "line": 7330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devclass_get_softc",
          "args": [
            "bktr_devclass",
            "unit"
          ],
          "line": 7319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_ioctl      bktrioctl\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n\nint\nbktr_ioctl( dev_t dev, ioctl_cmd_t cmd, caddr_t arg, int flag, struct proc* pr )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\n\tunit = UNIT(minor(dev));\n\n\t/* Get the device data */\n\tbktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);\n\tif (bktr == NULL) {\n\t\t/* the device is no longer valid/functioning */\n\t\treturn (ENXIO);\n\t}\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_ioctl( bktr, unit, cmd, arg, pr ) );\n\tcase TUNER_DEV:\n\t\treturn( tuner_ioctl( bktr, unit, cmd, arg, pr ) );\n\t}\n\n\treturn( ENXIO );\n}"
  },
  {
    "function_name": "bktr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7300-7304",
    "snippet": "int\nbktr_write( dev_t dev, struct uio *uio, int ioflag )\n{\n\treturn( EINVAL ); /* XXX or ENXIO ? */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define bktr_write      bktrwrite"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define bktr_write      bktrwrite\n\nint\nbktr_write( dev_t dev, struct uio *uio, int ioflag )\n{\n\treturn( EINVAL ); /* XXX or ENXIO ? */\n}"
  },
  {
    "function_name": "bktr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7272-7294",
    "snippet": "int\nbktr_read( dev_t dev, struct uio *uio, int ioflag )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\t\n\tunit = UNIT(minor(dev));\n\n\t/* Get the device data */\n\tbktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);\n\tif (bktr == NULL) {\n\t\t/* the device is no longer valid/functioning */\n\t\treturn (ENXIO);\n\t}\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_read( bktr, unit, dev, uio ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_read( bktr, dev, uio ) );\n\t}\n        return( ENXIO );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_read       bktrread",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vbi_read",
          "args": [
            "bktr",
            "dev",
            "uio"
          ],
          "line": 7291
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2142-2177",
          "snippet": "static int\nvbi_read(bktr_ptr_t bktr, dev_t dev, struct uio *uio)\n{\n\tint             readsize, readsize2;\n\tint             status;\n\n\tif(bktr->vbisize == 0)\n\t\tstatus = tsleep(VBI_SLEEP, BKTRPRI, \"vbi\", 0);\n\n\treadsize = (int)uio->uio_iov->iov_len;\n\n\t/* We cannot read more bytes than there are in the circular buffer */\n\tif (readsize > bktr->vbisize) readsize = bktr->vbisize;\n\n\t/* Check if we can read this number of bytes without having to wrap around the circular buffer */\n\tif((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {\n\t\t/* We need to wrap around */\n\n                readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);\n                status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);\n        } else {\n\t\t/* We do not need to wrap around */\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);\n        }\n\n\t/* Update the number of bytes left to read */\n        bktr->vbisize -= readsize;\n\n\t/* Update vbistart */\n        bktr->vbistart += readsize;\n\tbktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */\n\n        return( status );\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VBI_SLEEP   ((caddr_t)bktr + 1)",
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define BKTRPRI (PZERO+8)|PCATCH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_SLEEP   ((caddr_t)bktr + 1)\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define BKTRPRI (PZERO+8)|PCATCH\n\nstatic int\nvbi_read(bktr_ptr_t bktr, dev_t dev, struct uio *uio)\n{\n\tint             readsize, readsize2;\n\tint             status;\n\n\tif(bktr->vbisize == 0)\n\t\tstatus = tsleep(VBI_SLEEP, BKTRPRI, \"vbi\", 0);\n\n\treadsize = (int)uio->uio_iov->iov_len;\n\n\t/* We cannot read more bytes than there are in the circular buffer */\n\tif (readsize > bktr->vbisize) readsize = bktr->vbisize;\n\n\t/* Check if we can read this number of bytes without having to wrap around the circular buffer */\n\tif((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {\n\t\t/* We need to wrap around */\n\n                readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);\n                status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);\n        } else {\n\t\t/* We do not need to wrap around */\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);\n        }\n\n\t/* Update the number of bytes left to read */\n        bktr->vbisize -= readsize;\n\n\t/* Update vbistart */\n        bktr->vbistart += readsize;\n\tbktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */\n\n        return( status );\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_read",
          "args": [
            "bktr",
            "unit",
            "dev",
            "uio"
          ],
          "line": 7289
        },
        "resolved": true,
        "details": {
          "function_name": "video_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2085-2133",
          "snippet": "static int\nvideo_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)\n{\n        bt848_ptr_t     bt848;\n        int             status;\n        int             count;\n\n\n        bt848 = bktr->base;\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tif (bktr->flags & METEOR_CAP_MASK)\n\t\treturn( EIO );\t/* already capturing */\n\n        bt848->cap_ctl = bktr->bktr_cap_ctl;\n\n\n\tcount = bktr->rows * bktr->cols * \n\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp;\n\n\tif ((int) uio->uio_iov->iov_len < count)\n\t\treturn( EINVAL );\n\n\tbktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);\n\n\t/* capture one frame */\n\tstart_capture(bktr, METEOR_SINGLE);\n\t/* wait for capture to complete */\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n                          BT848_INT_RISCI      |\n                          BT848_INT_VSYNC      |\n                          BT848_INT_FMTCHG;\n\n\n\tstatus = tsleep(BKTR_SLEEP, BKTRPRI, \"captur\", 0);\n\tif (!status)\t\t/* successful capture */\n\t\tstatus = uiomove((caddr_t)bktr->bigbuf, count, uio);\n\telse\n\t\tprintf (\"bktr%d: read: tsleep error %d\\n\", unit, status);\n\n\tbktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);\n\n\treturn( status );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ALL_INTS_CLEARED\t0xffffffff",
            "#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN",
            "#define BKTR_SLEEP  ((caddr_t)bktr    )",
            "#define BKTRPRI (PZERO+8)|PCATCH"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALL_INTS_CLEARED\t0xffffffff\n#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n#define BKTRPRI (PZERO+8)|PCATCH\n\nstatic int\nvideo_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)\n{\n        bt848_ptr_t     bt848;\n        int             status;\n        int             count;\n\n\n        bt848 = bktr->base;\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tif (bktr->flags & METEOR_CAP_MASK)\n\t\treturn( EIO );\t/* already capturing */\n\n        bt848->cap_ctl = bktr->bktr_cap_ctl;\n\n\n\tcount = bktr->rows * bktr->cols * \n\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp;\n\n\tif ((int) uio->uio_iov->iov_len < count)\n\t\treturn( EINVAL );\n\n\tbktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);\n\n\t/* capture one frame */\n\tstart_capture(bktr, METEOR_SINGLE);\n\t/* wait for capture to complete */\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n                          BT848_INT_RISCI      |\n                          BT848_INT_VSYNC      |\n                          BT848_INT_FMTCHG;\n\n\n\tstatus = tsleep(BKTR_SLEEP, BKTRPRI, \"captur\", 0);\n\tif (!status)\t\t/* successful capture */\n\t\tstatus = uiomove((caddr_t)bktr->bigbuf, count, uio);\n\telse\n\t\tprintf (\"bktr%d: read: tsleep error %d\\n\", unit, status);\n\n\tbktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);\n\n\treturn( status );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devclass_get_softc",
          "args": [
            "bktr_devclass",
            "unit"
          ],
          "line": 7281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define bktr_read       bktrread\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define VIDEO_DEV\t0x00\n\nint\nbktr_read( dev_t dev, struct uio *uio, int ioflag )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\t\n\tunit = UNIT(minor(dev));\n\n\t/* Get the device data */\n\tbktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);\n\tif (bktr == NULL) {\n\t\t/* the device is no longer valid/functioning */\n\t\treturn (ENXIO);\n\t}\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\treturn( video_read( bktr, unit, dev, uio ) );\n\tcase VBI_DEV:\n\t\treturn( vbi_read( bktr, dev, uio ) );\n\t}\n        return( ENXIO );\n}"
  },
  {
    "function_name": "bktr_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7233-7266",
    "snippet": "int\nbktr_close( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\tint\t\tresult;\n\n\tunit = UNIT( minor(dev) );\n\n\t/* Get the device data */\n\tbktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);\n\tif (bktr == NULL) {\n\t\t/* the device is no longer valid/functioning */\n\t\treturn (ENXIO);\n\t}\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\tresult = video_close( bktr );\n\t\tbreak;\n\tcase TUNER_DEV:\n\t\tresult = tuner_close( bktr );\n\t\tbreak;\n\tcase VBI_DEV:\n\t\tresult = vbi_close( bktr );\n\t\tbreak;\n\tdefault:\n\t\treturn (ENXIO);\n\t\tbreak;\n\t}\n\n\tdevice_unbusy(devclass_get_device(bktr_devclass, unit)); \n\treturn( result );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_close      bktrclose",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_unbusy",
          "args": [
            "devclass_get_device(bktr_devclass, unit)"
          ],
          "line": 7264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devclass_get_device",
          "args": [
            "bktr_devclass",
            "unit"
          ],
          "line": 7264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vbi_close",
          "args": [
            "bktr"
          ],
          "line": 7257
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2073-2080",
          "snippet": "static int\nvbi_close( bktr_ptr_t bktr )\n{\n\n\tbktr->vbiflags &= ~VBI_OPEN;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nvbi_close( bktr_ptr_t bktr )\n{\n\n\tbktr->vbiflags &= ~VBI_OPEN;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuner_close",
          "args": [
            "bktr"
          ],
          "line": 7254
        },
        "resolved": true,
        "details": {
          "function_name": "tuner_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2059-2071",
          "snippet": "static int\ntuner_close( bktr_ptr_t bktr )\n{\n\tbktr->tflags &= ~TUNER_OPEN;\n\n\t/* mute the audio by switching the mux */\n\tset_audio( bktr, AUDIO_MUTE );\n\n\t/* disable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en = bktr->base->gpio_out_en & ~bktr->card.gpio_mux_bits;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_close( bktr_ptr_t bktr )\n{\n\tbktr->tflags &= ~TUNER_OPEN;\n\n\t/* mute the audio by switching the mux */\n\tset_audio( bktr, AUDIO_MUTE );\n\n\t/* disable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en = bktr->base->gpio_out_en & ~bktr->card.gpio_mux_bits;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_close",
          "args": [
            "bktr"
          ],
          "line": 7251
        },
        "resolved": true,
        "details": {
          "function_name": "video_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "2029-2052",
          "snippet": "static int\nvideo_close( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t\tbt848;\n\n\tbktr->flags &= ~(METEOR_OPEN     |\n\t\t\t METEOR_SINGLE   |\n\t\t\t METEOR_CAP_MASK |\n\t\t\t METEOR_WANT_MASK);\n\n\tbt848 = bktr->base;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->cap_ctl = CAPTURE_OFF;\n\n\tbktr->dma_prog_loaded = FALSE;\n\tbt848->tdec = 0;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */\n\tbt848->sreset = 0xf;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define CAPTURE_OFF\t\t0",
            "#define ALL_INTS_CLEARED\t0xffffffff",
            "#define ALL_INTS_DISABLED\t0",
            "#define FIFO_RISC_DISABLED\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CAPTURE_OFF\t\t0\n#define ALL_INTS_CLEARED\t0xffffffff\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n\nstatic int\nvideo_close( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t\tbt848;\n\n\tbktr->flags &= ~(METEOR_OPEN     |\n\t\t\t METEOR_SINGLE   |\n\t\t\t METEOR_CAP_MASK |\n\t\t\t METEOR_WANT_MASK);\n\n\tbt848 = bktr->base;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->cap_ctl = CAPTURE_OFF;\n\n\tbktr->dma_prog_loaded = FALSE;\n\tbt848->tdec = 0;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */\n\tbt848->sreset = 0xf;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devclass_get_softc",
          "args": [
            "bktr_devclass",
            "unit"
          ],
          "line": 7243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_close      bktrclose\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n\nint\nbktr_close( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\tint\t\tresult;\n\n\tunit = UNIT( minor(dev) );\n\n\t/* Get the device data */\n\tbktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);\n\tif (bktr == NULL) {\n\t\t/* the device is no longer valid/functioning */\n\t\treturn (ENXIO);\n\t}\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\tresult = video_close( bktr );\n\t\tbreak;\n\tcase TUNER_DEV:\n\t\tresult = tuner_close( bktr );\n\t\tbreak;\n\tcase VBI_DEV:\n\t\tresult = vbi_close( bktr );\n\t\tbreak;\n\tdefault:\n\t\treturn (ENXIO);\n\t\tbreak;\n\t}\n\n\tdevice_unbusy(devclass_get_device(bktr_devclass, unit)); \n\treturn( result );\n}"
  },
  {
    "function_name": "bktr_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7157-7227",
    "snippet": "int\nbktr_open( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\tint\t\tresult;\n\n\tunit = UNIT( minor(dev) );\n\n\t/* Get the device data */\n\tbktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);\n\tif (bktr == NULL) {\n\t\t/* the device is no longer valid/functioning */\n\t\treturn (ENXIO);\n\t}\n\n\tif (!(bktr->flags & METEOR_INITALIZED)) /* device not found */\n\t\treturn( ENXIO );\t\n\n\t/* Record that the device is now busy */\n\tdevice_busy(devclass_get_device(bktr_devclass, unit)); \n\n\n\tif (bt848_card != -1) {\n\t  if ((bt848_card >> 8   == unit ) &&\n\t     ( (bt848_card & 0xff) < Bt848_MAX_CARD )) {\n\t    if ( bktr->bt848_card != (bt848_card & 0xff) ) {\n\t      bktr->bt848_card = (bt848_card & 0xff);\n\t      probeCard(bktr, FALSE);\n\t    }\n\t  }\n\t}\n\n\tif (bt848_tuner != -1) {\n\t  if ((bt848_tuner >> 8   == unit ) &&\n\t     ( (bt848_tuner & 0xff) < Bt848_MAX_TUNER )) {\n\t    if ( bktr->bt848_tuner != (bt848_tuner & 0xff) ) {\n\t      bktr->bt848_tuner = (bt848_tuner & 0xff);\n\t      probeCard(bktr, FALSE);\n\t    }\n\t  }\n\t}\n\n\tif (bt848_reverse_mute != -1) {\n\t  if (((bt848_reverse_mute >> 8)   == unit ) &&\n\t      ((bt848_reverse_mute & 0xff) < Bt848_MAX_TUNER) ) {\n\t    bktr->reverse_mute = bt848_reverse_mute & 0xff;\n\t    bt848_reverse_mute = -1;\n\t  }\n\t}\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\tresult = video_open( bktr );\n\t\tbreak;\n\tcase TUNER_DEV:\n\t\tresult = tuner_open( bktr );\n\t\tbreak;\n\tcase VBI_DEV:\n\t\tresult = vbi_open( bktr );\n\t\tbreak;\n\tdefault:\n\t\tresult = ENXIO;\n\t\tbreak;\n\t}\n\n\t/* If there was an error opening the device, undo the busy status */\n\tif (result != 0)\n\t\tdevice_unbusy(devclass_get_device(bktr_devclass, unit)); \n\treturn( result );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define bktr_open       bktropen",
      "#define FUNCTION\tdv_subunit",
      "#define UNIT\t\tdv_unit",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define VBI_DEV\t\t0x02",
      "#define TUNER_DEV\t0x01",
      "#define VIDEO_DEV\t0x00",
      "#define Bt848_MAX_CARD\t\t13",
      "#define Bt848_MAX_TUNER         14"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_unbusy",
          "args": [
            "devclass_get_device(bktr_devclass, unit)"
          ],
          "line": 7225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devclass_get_device",
          "args": [
            "bktr_devclass",
            "unit"
          ],
          "line": 7225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vbi_open",
          "args": [
            "bktr"
          ],
          "line": 7216
        },
        "resolved": true,
        "details": {
          "function_name": "vbi_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1971-1989",
          "snippet": "static int\nvbi_open( bktr_ptr_t bktr )\n{\n\tif (bktr->vbiflags & VBI_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->vbiflags |= VBI_OPEN;\n\n\t/* reset the VBI circular buffer pointers and clear the buffers */\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbi_sequence_number = 0;\n\n\tbzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);\n\tbzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n\nstatic int\nvbi_open( bktr_ptr_t bktr )\n{\n\tif (bktr->vbiflags & VBI_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->vbiflags |= VBI_OPEN;\n\n\t/* reset the VBI circular buffer pointers and clear the buffers */\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbi_sequence_number = 0;\n\n\tbzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);\n\tbzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "tuner_open",
          "args": [
            "bktr"
          ],
          "line": 7213
        },
        "resolved": true,
        "details": {
          "function_name": "tuner_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1994-2021",
          "snippet": "static int\ntuner_open( bktr_ptr_t bktr )\n{\n\tif ( !(bktr->tflags & TUNER_INITALIZED) )\t/* device not found */\n\t\treturn( ENXIO );\t\n\n\tif ( bktr->tflags & TUNER_OPEN )\t\t/* already open */\n\t\treturn( 0 );\n\n\tbktr->tflags |= TUNER_OPEN;\n        bktr->tuner.radio_mode = 0;\n\n\t/* enable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en |= bktr->card.gpio_mux_bits;\n\n\t/* unmute the audio stream */\n\tset_audio( bktr, AUDIO_UNMUTE );\n\n\t/* enable stereo if appropriate on TDA audio chip */\n\tif ( bktr->card.dbx )\n\t\tinit_BTSC( bktr );\n\n\t/* reset the MSP34xx stereo audio chip */\n\tif ( bktr->card.msp3400c )\n\t\tmsp_reset( bktr );\n\t\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_open( bktr_ptr_t bktr )\n{\n\tif ( !(bktr->tflags & TUNER_INITALIZED) )\t/* device not found */\n\t\treturn( ENXIO );\t\n\n\tif ( bktr->tflags & TUNER_OPEN )\t\t/* already open */\n\t\treturn( 0 );\n\n\tbktr->tflags |= TUNER_OPEN;\n        bktr->tuner.radio_mode = 0;\n\n\t/* enable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en |= bktr->card.gpio_mux_bits;\n\n\t/* unmute the audio stream */\n\tset_audio( bktr, AUDIO_UNMUTE );\n\n\t/* enable stereo if appropriate on TDA audio chip */\n\tif ( bktr->card.dbx )\n\t\tinit_BTSC( bktr );\n\n\t/* reset the MSP34xx stereo audio chip */\n\tif ( bktr->card.msp3400c )\n\t\tmsp_reset( bktr );\n\t\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "video_open",
          "args": [
            "bktr"
          ],
          "line": 7210
        },
        "resolved": true,
        "details": {
          "function_name": "video_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1861-1969",
          "snippet": "static int\nvideo_open( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t bt848;\n\tint frame_rate, video_format=0;\n\n\tif (bktr->flags & METEOR_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->flags |= METEOR_OPEN;\n\n\tbt848 = bktr->base;\n\n#ifdef BT848_DUMP\n\tdump_bt848( bt848 );\n#endif\n\n        bktr->clr_on_start = FALSE;\n\n\tbt848->dstatus = 0x00;\t\t\t/* clear device status reg. */\n\n\tbt848->adc = SYNC_LEVEL;\n\n#if BROOKTREE_SYSTEM_DEFAULT == BROOKTREE_PAL\n\tvideo_format = 0;\n#else\n\tvideo_format = 1;\n#endif\n\n\tif (bt848_format == 0 ) \n\t  video_format = 0;\n\n\tif (bt848_format == 1 ) \n\t  video_format = 1;\n\n\tif (video_format == 1 ) {\n\t  bt848->iform = BT848_IFORM_F_NTSCM;\n\t  bktr->format_params = BT848_IFORM_F_NTSCM;\n\n\t} else {\n\t  bt848->iform = BT848_IFORM_F_PALBDGHI;\n\t  bktr->format_params = BT848_IFORM_F_PALBDGHI;\n\n\t}\n\n\tbt848->iform |= format_params[bktr->format_params].iform_xtsel;\n\n\t/* work around for new Hauppauge 878 cards */\n\tif ((bktr->card.card_id == CARD_HAUPPAUGE) &&\n\t    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbt848->iform |= BT848_IFORM_M_MUX3;\n\telse\n\t\tbt848->iform |= BT848_IFORM_M_MUX1;\n\n\tbt848->adelay = format_params[bktr->format_params].adelay;\n\tbt848->bdelay = format_params[bktr->format_params].bdelay;\n\tframe_rate    = format_params[bktr->format_params].frame_rate;\n\n\t/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */\n\tif (bktr->xtal_pll_mode == BT848_USE_PLL) {\n\t\tbt848->tgctrl=0;\n\t\tbt848->pll_f_lo=0xf9;\n\t\tbt848->pll_f_hi=0xdc;\n\t\tbt848->pll_f_xci=0x8e;\n\t}\n\n\tbktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;\n\n\tbktr->max_clip_node = 0;\n\n\tbt848->color_ctl_gamma       = 1;\n\tbt848->color_ctl_rgb_ded     = 1;\n\tbt848->color_ctl_color_bars  = 0;\n\tbt848->color_ctl_ext_frmrate = 0;\n\tbt848->color_ctl_swap        = 0;\n\n\tbt848->e_hscale_lo = 170;\n\tbt848->o_hscale_lo = 170;\n\n\tbt848->e_delay_lo = 0x72;\n\tbt848->o_delay_lo = 0x72;\n\tbt848->e_scloop = 0;\n\tbt848->o_scloop = 0;\n\n\tbt848->vbi_pack_size = 0;\n\tbt848->vbi_pack_del = 0;\n\n\tbktr->fifo_errors = 0;\n\tbktr->dma_errors = 0;\n\tbktr->frames_captured = 0;\n\tbktr->even_fields_captured = 0;\n\tbktr->odd_fields_captured = 0;\n\tbktr->proc = (struct proc *)0;\n\tset_fps(bktr, frame_rate);\n\tbktr->video.addr = 0;\n\tbktr->video.width = 0;\n\tbktr->video.banksize = 0;\n\tbktr->video.ramsize = 0;\n\tbktr->pixfmt_compat = TRUE;\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\n\tbktr->capture_area_enabled = FALSE;\n\n\tbt848->int_mask = BT848_INT_MYSTERYBIT;\t/* if you take this out triton\n                                                   based motherboards will \n\t\t\t\t\t\t   operate unreliably */\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define\tCARD_HAUPPAUGE\t\t2",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define\tCARD_HAUPPAUGE\t\t2\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic int\nvideo_open( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t bt848;\n\tint frame_rate, video_format=0;\n\n\tif (bktr->flags & METEOR_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->flags |= METEOR_OPEN;\n\n\tbt848 = bktr->base;\n\n#ifdef BT848_DUMP\n\tdump_bt848( bt848 );\n#endif\n\n        bktr->clr_on_start = FALSE;\n\n\tbt848->dstatus = 0x00;\t\t\t/* clear device status reg. */\n\n\tbt848->adc = SYNC_LEVEL;\n\n#if BROOKTREE_SYSTEM_DEFAULT == BROOKTREE_PAL\n\tvideo_format = 0;\n#else\n\tvideo_format = 1;\n#endif\n\n\tif (bt848_format == 0 ) \n\t  video_format = 0;\n\n\tif (bt848_format == 1 ) \n\t  video_format = 1;\n\n\tif (video_format == 1 ) {\n\t  bt848->iform = BT848_IFORM_F_NTSCM;\n\t  bktr->format_params = BT848_IFORM_F_NTSCM;\n\n\t} else {\n\t  bt848->iform = BT848_IFORM_F_PALBDGHI;\n\t  bktr->format_params = BT848_IFORM_F_PALBDGHI;\n\n\t}\n\n\tbt848->iform |= format_params[bktr->format_params].iform_xtsel;\n\n\t/* work around for new Hauppauge 878 cards */\n\tif ((bktr->card.card_id == CARD_HAUPPAUGE) &&\n\t    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbt848->iform |= BT848_IFORM_M_MUX3;\n\telse\n\t\tbt848->iform |= BT848_IFORM_M_MUX1;\n\n\tbt848->adelay = format_params[bktr->format_params].adelay;\n\tbt848->bdelay = format_params[bktr->format_params].bdelay;\n\tframe_rate    = format_params[bktr->format_params].frame_rate;\n\n\t/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */\n\tif (bktr->xtal_pll_mode == BT848_USE_PLL) {\n\t\tbt848->tgctrl=0;\n\t\tbt848->pll_f_lo=0xf9;\n\t\tbt848->pll_f_hi=0xdc;\n\t\tbt848->pll_f_xci=0x8e;\n\t}\n\n\tbktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;\n\n\tbktr->max_clip_node = 0;\n\n\tbt848->color_ctl_gamma       = 1;\n\tbt848->color_ctl_rgb_ded     = 1;\n\tbt848->color_ctl_color_bars  = 0;\n\tbt848->color_ctl_ext_frmrate = 0;\n\tbt848->color_ctl_swap        = 0;\n\n\tbt848->e_hscale_lo = 170;\n\tbt848->o_hscale_lo = 170;\n\n\tbt848->e_delay_lo = 0x72;\n\tbt848->o_delay_lo = 0x72;\n\tbt848->e_scloop = 0;\n\tbt848->o_scloop = 0;\n\n\tbt848->vbi_pack_size = 0;\n\tbt848->vbi_pack_del = 0;\n\n\tbktr->fifo_errors = 0;\n\tbktr->dma_errors = 0;\n\tbktr->frames_captured = 0;\n\tbktr->even_fields_captured = 0;\n\tbktr->odd_fields_captured = 0;\n\tbktr->proc = (struct proc *)0;\n\tset_fps(bktr, frame_rate);\n\tbktr->video.addr = 0;\n\tbktr->video.width = 0;\n\tbktr->video.banksize = 0;\n\tbktr->video.ramsize = 0;\n\tbktr->pixfmt_compat = TRUE;\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\n\tbktr->capture_area_enabled = FALSE;\n\n\tbt848->int_mask = BT848_INT_MYSTERYBIT;\t/* if you take this out triton\n                                                   based motherboards will \n\t\t\t\t\t\t   operate unreliably */\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUNCTION",
          "args": [
            "minor(dev)"
          ],
          "line": 7208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probeCard",
          "args": [
            "bktr",
            "FALSE"
          ],
          "line": 7195
        },
        "resolved": true,
        "details": {
          "function_name": "probeCard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5356-5885",
          "snippet": "static void\nprobeCard( bktr_ptr_t bktr, int verbose )\n{\n\tint\t\tcard, i,j, card_found;\n\tint\t\tstatus;\n\tbt848_ptr_t\tbt848;\n\tu_char \t\tprobe_signature[128], *probe_temp;\n        int   \t\tany_i2c_devices;\n\tu_char \t\teeprom[256];\n\tu_char \t\ttuner_code = 0;\n\tint \t\ttuner_i2c_address = -1;\n\tint \t\teeprom_i2c_address = -1;\n\n\tbt848 = bktr->base;\n\n\t/* Select all GPIO bits as inputs */\n\tbt848->gpio_out_en = 0;\n\tif (bootverbose)\n\t    printf(\"bktr: GPIO is 0x%08x\\n\", bt848->gpio_data);\n\n#ifdef HAUPPAUGE_MSP_RESET\n\t/* Reset the MSP34xx audio chip. This resolves bootup card\n\t * detection problems with old Bt848 based Hauppauge cards with\n\t * MSP34xx stereo audio chips. This must be user enabled because\n\t * at this point the probe function does not know the card type. */\n        bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n#endif\n\n\t/* Check for the presence of i2c devices */\n        any_i2c_devices = check_for_i2c_devices( bktr );\n\n\n\t/* Check for a user specified override on the card selection */\n#if defined( OVERRIDE_CARD )\n\tbktr->card = cards[ (card = OVERRIDE_CARD) ];\n\tgoto checkEEPROM;\n#endif\n\tif (bktr->bt848_card != -1 ) {\n\t  bktr->card = cards[ (card = bktr->bt848_card) ];\n\t  goto checkEEPROM;\n\t}\n\n\n\t/* No override, so try and determine the make of the card */\n\n        /* On BT878/879 cards, read the sub-system vendor id */\n\t/* This identifies the manufacturer of the card and the model */\n\t/* In theory this can be read from PCI registers but this does not */\n\t/* appear to work on the FlyVideo 98. Hauppauge also warned that */\n\t/* the PCI registers are sometimes not loaded correctly. */\n\t/* Therefore, I will read the sub-system vendor ID from the EEPROM */\n\t/* (just like the Bt878 does during power up initialisation) */\n\n        if (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) {\n\n\t    /* Try and locate the EEPROM */\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\n                unsigned int subsystem_vendor_id; /* vendors PCI-SIG ID */\n                unsigned int subsystem_id;        /* board model number */\n\t\tunsigned int byte_252, byte_253, byte_254, byte_255;\n\n\t\tbktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\n\t        readEEProm(bktr, 0, 256, (u_char *) &eeprom );\n                byte_252 = (unsigned int)eeprom[252];\n                byte_253 = (unsigned int)eeprom[253];\n                byte_254 = (unsigned int)eeprom[254];\n                byte_255 = (unsigned int)eeprom[255];\n                \n                subsystem_id        = (byte_252 << 8) | byte_253;\n                subsystem_vendor_id = (byte_254 << 8) | byte_255;\n\n\t        if ( bootverbose ) \n\t            printf(\"subsystem 0x%04x 0x%04x\\n\",subsystem_vendor_id,\n\t\t                                  subsystem_id);\n\n                if (subsystem_vendor_id == VENDOR_AVER_MEDIA) {\n                    bktr->card = cards[ (card = CARD_AVER_MEDIA) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_HAUPPAUGE) {\n                    bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_FLYVIDEO) {\n                    bktr->card = cards[ (card = CARD_FLYVIDEO) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_STB) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                /* Vendor is unknown. We will use the standard probe code */\n\t\t/* which may not give best results */\n                printf(\"Warning - card vendor 0x%04x (model 0x%04x) unknown. This may cause poor performance\\n\",subsystem_vendor_id,subsystem_id);\n            }\n\t    else\n\t    {\n                printf(\"Warning - card has no configuration EEPROM. Cannot determine card make. This may cause poor performance\\n\");\n\t    }\n\t} /* end of bt878/bt879 card detection code */\n\n\t/* If we get to this point, we must have a Bt848/848A/849A card */\n\t/* or a Bt878/879 with an unknown subsystem vendor id */\n        /* Try and determine the make of card by clever i2c probing */\n\n   \t/* Check for i2c devices. If none, move on */\n\tif (!any_i2c_devices) {\n\t\tbktr->card = cards[ (card = CARD_INTEL) ];\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t\tgoto checkTuner;\n\t}\n\n\n        /* Look for Hauppauge, STB and Osprey cards by the presence */\n\t/* of an EEPROM */\n        /* Note: Bt878 based cards also use EEPROMs so we can only do this */\n        /* test on BT848/848A and 849A based cards. */\n\tif ((bktr->id==BROOKTREE_848)  ||\n\t    (bktr->id==BROOKTREE_848A) ||\n\t    (bktr->id==BROOKTREE_849A)) {\n\n            /* At i2c address 0xa0, look for Hauppauge and Osprey cards */\n            if ( (status = i2cRead( bktr, PFC8582_RADDR )) != ABSENT ) {\n\n\t\t    /* Read the eeprom contents */\n\t\t    bktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t            readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\t\t    /* For Hauppauge, check the EEPROM begins with 0x84 */\n\t\t    if (eeprom[0] == 0x84) {\n                            bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\n\t\t    /* For Osprey, check the EEPROM begins with \"MMAC\" */\n\t\t    if (  (eeprom[0] == 'M') &&(eeprom[1] == 'M')\n\t\t\t&&(eeprom[2] == 'A') &&(eeprom[3] == 'C')) {\n                            bktr->card = cards[ (card = CARD_OSPREY) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\t\t    printf(\"Warning: Unknown card type. EEPROM data not recognised\\n\");\n\t\t    printf(\"%x %x %x %x\\n\",eeprom[0],eeprom[1],eeprom[2],eeprom[3]);\n            }\n\n            /* look for an STB card */\n            if ( (status = i2cRead( bktr, X24C01_RADDR )) != ABSENT ) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = X24C01_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(128 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n            }\n\n\t}\n\n\tsignCard( bktr, 1, 128, (u_char *)  &probe_signature );\n\n\tif (bootverbose) {\n\t  printf(\"card signature \\n\");\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    printf(\" %02x \", probe_signature[j]);\n\t  }\n\t  printf(\"\\n\\n\");\n\t}\n\tfor (i = 0;\n\t     i < (sizeof bt848_card_signature)/ sizeof (struct bt848_card_sig);\n\t     i++ ) {\n\n\t  card_found = 1;\n\t  probe_temp = (u_char *) &bt848_card_signature[i].signature;\n\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    if ((probe_temp[j] & 0xf) != (probe_signature[j] & 0xf)) {\n\t      card_found = 0;\n\t      break;\n\t    }\n\n\t  }\n\t  if (card_found) {\n\t    bktr->card = cards[ card = bt848_card_signature[i].card];\n\t    bktr->card.tuner = &tuners[ bt848_card_signature[i].tuner];\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t    } else {\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t    }\n\t    goto checkDBX;\n\t  }\n\t}\n\n\t/* We do not know the card type. Default to Miro */\n\tbktr->card = cards[ (card = CARD_MIRO) ];\n\n\ncheckEEPROM:\n\t/* look for a configuration eeprom */\n\teeprom_i2c_address = locate_eeprom_address( bktr );\n\tif (eeprom_i2c_address != -1) {\n\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t} else {\n\t    bktr->card.eepromAddr = 0;\n\t    bktr->card.eepromSize = 0;\n\t}\n\n\ncheckTuner:\n\n\t/* look for a tuner */\n\ttuner_i2c_address = locate_tuner_address( bktr );\n\tif ( tuner_i2c_address == -1 ) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n#if defined( OVERRIDE_TUNER )\n\tbktr->card.tuner = &tuners[ OVERRIDE_TUNER ];\n\tgoto checkDBX;\n#endif\n\tif (bktr->bt848_tuner != -1 ) {\n\t  bktr->card.tuner = &tuners[ bktr->bt848_tuner & 0xff ];\n\t  goto checkDBX;\n\t}\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n\t/* differentiate type of tuner */\n\n\tswitch (card) {\n\tcase CARD_MIRO:\n\t    switch (((bt848->gpio_data >> 10)-1)&7) {\n\t    case 0: bktr->card.tuner = &tuners[ TEMIC_PAL ]; break;\n\t    case 1: bktr->card.tuner = &tuners[ PHILIPS_PAL ]; break;\n\t    case 2: bktr->card.tuner = &tuners[ PHILIPS_NTSC ]; break;\n\t    case 3: bktr->card.tuner = &tuners[ PHILIPS_SECAM ]; break;\n\t    case 4: bktr->card.tuner = &tuners[ NO_TUNER ]; break;\n\t    case 5: bktr->card.tuner = &tuners[ PHILIPS_PALI ]; break;\n\t    case 6: bktr->card.tuner = &tuners[ TEMIC_NTSC ]; break;\n\t    case 7: bktr->card.tuner = &tuners[ TEMIC_PALI ]; break;\n\t    }\n\t    goto checkDBX;\n\t    break;\n\n\tcase CARD_HAUPPAUGE:\n\t    /* Hauppauge kindly supplied the following Tuner Table */\n\t    /* FIXME: I think the tuners the driver selects for types */\n\t    /* 0x08 and 0x15 may be incorrect but no one has complained. */\n\t    /*\n   \t    \tID Tuner Model          Format         \tWe select Format\n\t   \t 0 NONE               \n\t\t 1 EXTERNAL             \n\t\t 2 OTHER                \n\t\t 3 Philips FI1216       BG \n\t\t 4 Philips FI1216MF     BGLL' \n\t\t 5 Philips FI1236       MN \t\tPHILIPS_NTSC\n\t\t 6 Philips FI1246       I \n\t\t 7 Philips FI1256       DK \n\t\t 8 Philips FI1216 MK2   BG \t\tPHILIPS_PALI\n\t\t 9 Philips FI1216MF MK2 BGLL' \n\t\t a Philips FI1236 MK2   MN \t\tPHILIPS_NTSC\n\t\t b Philips FI1246 MK2   I \t\tPHILIPS_PALI\n\t\t c Philips FI1256 MK2   DK \n\t\t d Temic 4032FY5        NTSC\t\tTEMIC_NTSC\n\t\t e Temic 4002FH5        BG\t\tTEMIC_PAL\n\t\t f Temic 4062FY5        I \t\tTEMIC_PALI\n\t\t10 Philips FR1216 MK2   BG \n\t\t11 Philips FR1216MF MK2 BGLL' \n\t\t12 Philips FR1236 MK2   MN \t\tPHILIPS_FR1236_NTSC\n\t\t13 Philips FR1246 MK2   I \n\t\t14 Philips FR1256 MK2   DK \n\t\t15 Philips FM1216       BG \t\tPHILIPS_FR1216_PAL\n\t\t16 Philips FM1216MF     BGLL' \n\t\t17 Philips FM1236       MN \t\tPHILIPS_FR1236_NTSC\n\t\t18 Philips FM1246       I \n\t\t19 Philips FM1256       DK \n\t\t1a Temic 4036FY5        MN - FI1236 MK2 clone\n\t\t1b Samsung TCPN9082D    MN \n\t\t1c Samsung TCPM9092P    Pal BG/I/DK \n\t\t1d Temic 4006FH5        BG \t\tPHILIPS_PALI clone\n\t\t1e Samsung TCPN9085D    MN/Radio \n\t\t1f Samsung TCPB9085P    Pal BG/I/DK / Radio \n\t\t20 Samsung TCPL9091P    Pal BG & Secam L/L' \n\t\t21 Temic 4039FY5        NTSC Radio\n\n\t    */\n\n\t    readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\n\t    /* Determine the model number from the eeprom */\n\t    {\n\t\tu_int model;\n\t\tu_int revision;\n\t\tmodel    = (eeprom[12] << 8  | eeprom[11]);\n\t\trevision = (eeprom[15] << 16 | eeprom[14] << 8 | eeprom[13]);\n\t\tif (verbose)\n\t\t    printf(\"Hauppauge Model %d %c%c%c%c\\n\",\n\t\t\tmodel,\n\t\t\t((revision >> 18) & 0x3f) + 32,\n\t\t\t((revision >> 12) & 0x3f) + 32,\n\t\t\t((revision >>  6) & 0x3f) + 32,\n\t\t\t((revision >>  0) & 0x3f) + 32 );\n\t    }\n\n\t    /* Determine the tuner type from the eeprom */\n\t    tuner_code = eeprom[9];\n\t    switch (tuner_code) {\n\n\t       case 0x5:\n               case 0x0a:\n\t       case 0x1a:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_NTSC  ];\n\t\t goto checkDBX;\n\n               case 0x12:\n\t       case 0x17:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1236_NTSC  ];\n\t\t goto checkDBX;\n\n\t       case 0x8:\n\t       case 0xb:\n\t       case 0x1d:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_PALI ];\n\t\t goto checkDBX;\n\n\t       case 0xd:\n\t\t bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n\t\t goto checkDBX;\n\n               case 0xe:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PAL];\n\t\t goto checkDBX;\n\n\t       case 0xf:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PALI ];\n\t\t goto checkDBX;\n\n               case 0x15:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1216_PAL];\n\t\t goto checkDBX;\n\n\t       default :\n\t\t printf(\"Warning - Unknown Hauppauge Tuner 0x%x\\n\",tuner_code);\n\t    }\n\t    break;\n\n\t} /* end switch(card) */\n\n        /* At this point, a goto checkDBX has not occured */\n        /* We have not been able to select a Tuner */\n        /* Some cards make use of the tuner address to */\n        /* identify the make/model of tuner */\n\n        /* At address 0xc0/0xc1 we often find a TEMIC NTSC */\n        if ( i2cRead( bktr, 0xc1 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n            goto checkDBX;\n        }\n  \n        /* At address 0xc6/0xc7 we often find a PHILIPS NTSC Tuner */\n        if ( i2cRead( bktr, 0xc7 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ PHILIPS_NTSC ];\n            goto checkDBX;\n        }\n\n        /* Address 0xc2/0xc3 is default (or common address) for several */\n\t/* tuners and we cannot tell which is which. */\n\t/* And for all other tuner i2c addresses, select the default */\n\tbktr->card.tuner = &tuners[ DEFAULT_TUNER ];\n\n\ncheckDBX:\n#if defined( OVERRIDE_DBX )\n\tbktr->card.dbx = OVERRIDE_DBX;\n\tgoto checkMSP;\n#endif\n   /* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSP;\n\t}\n\n\t/* probe for BTSC (dbx) chip */\n\tif ( i2cRead( bktr, TDA9850_RADDR ) != ABSENT )\n\t\tbktr->card.dbx = 1;\n\ncheckMSP:\n\t/* If this is a Hauppauge Bt878 card, we need to enable the\n\t * MSP 34xx audio chip. \n\t * If this is a Hauppauge Bt848 card, reset the MSP device.\n\t * The MSP reset line is wired to GPIO pin 5. On Bt878 cards a pulldown\n\t * resistor holds the device in reset until we set GPIO pin 5.\n         */\n\n\t/* Optionally skip the MSP reset. This is handy if you initialise the\n\t * MSP audio in another operating system (eg Windows) first and then\n\t * do a soft reboot.\n\t */\n\n#ifndef BKTR_NO_MSP_RESET\n\tif (card == CARD_HAUPPAUGE) {\n            bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n        }\n#endif\n\n#if defined( OVERRIDE_MSP )\n\tbktr->card.msp3400c = OVERRIDE_MSP;\n\tgoto checkMSPEnd;\n#endif\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSPEnd;\n\t}\n\n\tif ( i2cRead( bktr, MSP3400C_RADDR ) != ABSENT )\n\t\tbktr->card.msp3400c = 1;\n\ncheckMSPEnd:\n\n/* Start of Check Remote */\n        /* Check for the Hauppauge IR Remote Control */\n        /* If there is an external unit, the internal will be ignored */\n\n        bktr->remote_control = 0; /* initial value */\n\n        if (any_i2c_devices) {\n            if (i2cRead( bktr, HAUP_REMOTE_EXT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_EXT_RADDR;\n                }\n            else if (i2cRead( bktr, HAUP_REMOTE_INT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_INT_RADDR;\n                }\n\n        }\n        /* If a remote control is found, poll it 5 times to turn off the LED */\n        if (bktr->remote_control) {\n                int i;\n                for (i=0; i<5; i++)\n                        i2cRead( bktr, bktr->remote_control_addr );\n        }\n/* End of Check Remote */\n\n#if defined( BKTR_USE_PLL )\n\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\tgoto checkPLLEnd;\n#endif\n\t/* Default is to use XTALS and not PLL mode */\n\tbktr->xtal_pll_mode = BT848_USE_XTALS;\n\n\t/* Enable PLL mode for PAL/SECAM users on Hauppauge 878 cards */\n\tif ((card == CARD_HAUPPAUGE) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\n\t/* Enable PLL mode for OSPREY users */\n\tif (card == CARD_OSPREY)\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\t/* Enable PLL mode for PAL/SECAM users on FlyVideo 878 cards */\n\tif ((card == CARD_FLYVIDEO) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n#if defined( BKTR_USE_PLL )\ncheckPLLEnd:\n#endif\n\n\n\tbktr->card.tuner_pllAddr = tuner_i2c_address;\n\n\tif ( verbose ) {\n\t\tprintf( \"%s\", bktr->card.name );\n\t\tif ( bktr->card.tuner )\n\t\t\tprintf( \", %s tuner\", bktr->card.tuner->name );\n\t\tif ( bktr->card.dbx )\n\t\t\tprintf( \", dbx stereo\" );\n\t\tif ( bktr->card.msp3400c )\n\t\t\tprintf( \", msp3400c stereo\" );\n                if ( bktr->remote_control )\n                        printf( \", remote control\" );\n\t\tprintf( \".\\n\" );\n\t}\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VENDOR_STB        0x10B4",
            "#define VENDOR_FLYVIDEO   0x1851",
            "#define VENDOR_HAUPPAUGE  0x0070",
            "#define VENDOR_AVER_MEDIA 0x1431",
            "#define ABSENT\t\t(-1)",
            "#define CARD_FLYVIDEO\t\t10",
            "#define\tCARD_OSPREY\t\t7",
            "#define\tCARD_AVER_MEDIA\t\t6",
            "#define\tCARD_INTEL\t\t4",
            "#define\tCARD_STB\t\t3",
            "#define\tCARD_HAUPPAUGE\t\t2",
            "#define\tCARD_MIRO\t\t1",
            "#define\tCARD_UNKNOWN\t\t0",
            "#define DEFAULT_TUNER\tPHILIPS_NTSC",
            "#define DEFAULT_TUNER\tPHILIPS_PALI",
            "#define PHILIPS_FR1216_PAL\t10",
            "#define PHILIPS_FR1236_NTSC     9",
            "#define PHILIPS_PALI\t\t8",
            "#define TEMIC_PALI\t\t7",
            "#define PHILIPS_SECAM\t\t6",
            "#define PHILIPS_PAL\t\t5",
            "#define PHILIPS_NTSC\t\t4",
            "#define TEMIC_PAL\t\t2",
            "#define TEMIC_NTSC\t\t1",
            "#define NO_TUNER\t\t0",
            "#define PFC8582_RADDR\t\t0xa1",
            "#define PFC8582_WADDR\t\t0xa0",
            "#define X24C01_RADDR\t\t0xaf",
            "#define X24C01_WADDR\t\t0xae",
            "#define MSP3400C_RADDR\t\t0x81",
            "#define TDA9850_RADDR\t\t0xb7",
            "#define HAUP_REMOTE_EXT_RADDR   0x35",
            "#define HAUP_REMOTE_INT_RADDR   0x31",
            "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VENDOR_STB        0x10B4\n#define VENDOR_FLYVIDEO   0x1851\n#define VENDOR_HAUPPAUGE  0x0070\n#define VENDOR_AVER_MEDIA 0x1431\n#define ABSENT\t\t(-1)\n#define CARD_FLYVIDEO\t\t10\n#define\tCARD_OSPREY\t\t7\n#define\tCARD_AVER_MEDIA\t\t6\n#define\tCARD_INTEL\t\t4\n#define\tCARD_STB\t\t3\n#define\tCARD_HAUPPAUGE\t\t2\n#define\tCARD_MIRO\t\t1\n#define\tCARD_UNKNOWN\t\t0\n#define DEFAULT_TUNER\tPHILIPS_NTSC\n#define DEFAULT_TUNER\tPHILIPS_PALI\n#define PHILIPS_FR1216_PAL\t10\n#define PHILIPS_FR1236_NTSC     9\n#define PHILIPS_PALI\t\t8\n#define TEMIC_PALI\t\t7\n#define PHILIPS_SECAM\t\t6\n#define PHILIPS_PAL\t\t5\n#define PHILIPS_NTSC\t\t4\n#define TEMIC_PAL\t\t2\n#define TEMIC_NTSC\t\t1\n#define NO_TUNER\t\t0\n#define PFC8582_RADDR\t\t0xa1\n#define PFC8582_WADDR\t\t0xa0\n#define X24C01_RADDR\t\t0xaf\n#define X24C01_WADDR\t\t0xae\n#define MSP3400C_RADDR\t\t0x81\n#define TDA9850_RADDR\t\t0xb7\n#define HAUP_REMOTE_EXT_RADDR   0x35\n#define HAUP_REMOTE_INT_RADDR   0x31\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n\nstatic void\nprobeCard( bktr_ptr_t bktr, int verbose )\n{\n\tint\t\tcard, i,j, card_found;\n\tint\t\tstatus;\n\tbt848_ptr_t\tbt848;\n\tu_char \t\tprobe_signature[128], *probe_temp;\n        int   \t\tany_i2c_devices;\n\tu_char \t\teeprom[256];\n\tu_char \t\ttuner_code = 0;\n\tint \t\ttuner_i2c_address = -1;\n\tint \t\teeprom_i2c_address = -1;\n\n\tbt848 = bktr->base;\n\n\t/* Select all GPIO bits as inputs */\n\tbt848->gpio_out_en = 0;\n\tif (bootverbose)\n\t    printf(\"bktr: GPIO is 0x%08x\\n\", bt848->gpio_data);\n\n#ifdef HAUPPAUGE_MSP_RESET\n\t/* Reset the MSP34xx audio chip. This resolves bootup card\n\t * detection problems with old Bt848 based Hauppauge cards with\n\t * MSP34xx stereo audio chips. This must be user enabled because\n\t * at this point the probe function does not know the card type. */\n        bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n#endif\n\n\t/* Check for the presence of i2c devices */\n        any_i2c_devices = check_for_i2c_devices( bktr );\n\n\n\t/* Check for a user specified override on the card selection */\n#if defined( OVERRIDE_CARD )\n\tbktr->card = cards[ (card = OVERRIDE_CARD) ];\n\tgoto checkEEPROM;\n#endif\n\tif (bktr->bt848_card != -1 ) {\n\t  bktr->card = cards[ (card = bktr->bt848_card) ];\n\t  goto checkEEPROM;\n\t}\n\n\n\t/* No override, so try and determine the make of the card */\n\n        /* On BT878/879 cards, read the sub-system vendor id */\n\t/* This identifies the manufacturer of the card and the model */\n\t/* In theory this can be read from PCI registers but this does not */\n\t/* appear to work on the FlyVideo 98. Hauppauge also warned that */\n\t/* the PCI registers are sometimes not loaded correctly. */\n\t/* Therefore, I will read the sub-system vendor ID from the EEPROM */\n\t/* (just like the Bt878 does during power up initialisation) */\n\n        if (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) {\n\n\t    /* Try and locate the EEPROM */\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\n                unsigned int subsystem_vendor_id; /* vendors PCI-SIG ID */\n                unsigned int subsystem_id;        /* board model number */\n\t\tunsigned int byte_252, byte_253, byte_254, byte_255;\n\n\t\tbktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\n\t        readEEProm(bktr, 0, 256, (u_char *) &eeprom );\n                byte_252 = (unsigned int)eeprom[252];\n                byte_253 = (unsigned int)eeprom[253];\n                byte_254 = (unsigned int)eeprom[254];\n                byte_255 = (unsigned int)eeprom[255];\n                \n                subsystem_id        = (byte_252 << 8) | byte_253;\n                subsystem_vendor_id = (byte_254 << 8) | byte_255;\n\n\t        if ( bootverbose ) \n\t            printf(\"subsystem 0x%04x 0x%04x\\n\",subsystem_vendor_id,\n\t\t                                  subsystem_id);\n\n                if (subsystem_vendor_id == VENDOR_AVER_MEDIA) {\n                    bktr->card = cards[ (card = CARD_AVER_MEDIA) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_HAUPPAUGE) {\n                    bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_FLYVIDEO) {\n                    bktr->card = cards[ (card = CARD_FLYVIDEO) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_STB) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                /* Vendor is unknown. We will use the standard probe code */\n\t\t/* which may not give best results */\n                printf(\"Warning - card vendor 0x%04x (model 0x%04x) unknown. This may cause poor performance\\n\",subsystem_vendor_id,subsystem_id);\n            }\n\t    else\n\t    {\n                printf(\"Warning - card has no configuration EEPROM. Cannot determine card make. This may cause poor performance\\n\");\n\t    }\n\t} /* end of bt878/bt879 card detection code */\n\n\t/* If we get to this point, we must have a Bt848/848A/849A card */\n\t/* or a Bt878/879 with an unknown subsystem vendor id */\n        /* Try and determine the make of card by clever i2c probing */\n\n   \t/* Check for i2c devices. If none, move on */\n\tif (!any_i2c_devices) {\n\t\tbktr->card = cards[ (card = CARD_INTEL) ];\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t\tgoto checkTuner;\n\t}\n\n\n        /* Look for Hauppauge, STB and Osprey cards by the presence */\n\t/* of an EEPROM */\n        /* Note: Bt878 based cards also use EEPROMs so we can only do this */\n        /* test on BT848/848A and 849A based cards. */\n\tif ((bktr->id==BROOKTREE_848)  ||\n\t    (bktr->id==BROOKTREE_848A) ||\n\t    (bktr->id==BROOKTREE_849A)) {\n\n            /* At i2c address 0xa0, look for Hauppauge and Osprey cards */\n            if ( (status = i2cRead( bktr, PFC8582_RADDR )) != ABSENT ) {\n\n\t\t    /* Read the eeprom contents */\n\t\t    bktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t            readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\t\t    /* For Hauppauge, check the EEPROM begins with 0x84 */\n\t\t    if (eeprom[0] == 0x84) {\n                            bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\n\t\t    /* For Osprey, check the EEPROM begins with \"MMAC\" */\n\t\t    if (  (eeprom[0] == 'M') &&(eeprom[1] == 'M')\n\t\t\t&&(eeprom[2] == 'A') &&(eeprom[3] == 'C')) {\n                            bktr->card = cards[ (card = CARD_OSPREY) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\t\t    printf(\"Warning: Unknown card type. EEPROM data not recognised\\n\");\n\t\t    printf(\"%x %x %x %x\\n\",eeprom[0],eeprom[1],eeprom[2],eeprom[3]);\n            }\n\n            /* look for an STB card */\n            if ( (status = i2cRead( bktr, X24C01_RADDR )) != ABSENT ) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = X24C01_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(128 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n            }\n\n\t}\n\n\tsignCard( bktr, 1, 128, (u_char *)  &probe_signature );\n\n\tif (bootverbose) {\n\t  printf(\"card signature \\n\");\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    printf(\" %02x \", probe_signature[j]);\n\t  }\n\t  printf(\"\\n\\n\");\n\t}\n\tfor (i = 0;\n\t     i < (sizeof bt848_card_signature)/ sizeof (struct bt848_card_sig);\n\t     i++ ) {\n\n\t  card_found = 1;\n\t  probe_temp = (u_char *) &bt848_card_signature[i].signature;\n\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    if ((probe_temp[j] & 0xf) != (probe_signature[j] & 0xf)) {\n\t      card_found = 0;\n\t      break;\n\t    }\n\n\t  }\n\t  if (card_found) {\n\t    bktr->card = cards[ card = bt848_card_signature[i].card];\n\t    bktr->card.tuner = &tuners[ bt848_card_signature[i].tuner];\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t    } else {\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t    }\n\t    goto checkDBX;\n\t  }\n\t}\n\n\t/* We do not know the card type. Default to Miro */\n\tbktr->card = cards[ (card = CARD_MIRO) ];\n\n\ncheckEEPROM:\n\t/* look for a configuration eeprom */\n\teeprom_i2c_address = locate_eeprom_address( bktr );\n\tif (eeprom_i2c_address != -1) {\n\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t} else {\n\t    bktr->card.eepromAddr = 0;\n\t    bktr->card.eepromSize = 0;\n\t}\n\n\ncheckTuner:\n\n\t/* look for a tuner */\n\ttuner_i2c_address = locate_tuner_address( bktr );\n\tif ( tuner_i2c_address == -1 ) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n#if defined( OVERRIDE_TUNER )\n\tbktr->card.tuner = &tuners[ OVERRIDE_TUNER ];\n\tgoto checkDBX;\n#endif\n\tif (bktr->bt848_tuner != -1 ) {\n\t  bktr->card.tuner = &tuners[ bktr->bt848_tuner & 0xff ];\n\t  goto checkDBX;\n\t}\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n\t/* differentiate type of tuner */\n\n\tswitch (card) {\n\tcase CARD_MIRO:\n\t    switch (((bt848->gpio_data >> 10)-1)&7) {\n\t    case 0: bktr->card.tuner = &tuners[ TEMIC_PAL ]; break;\n\t    case 1: bktr->card.tuner = &tuners[ PHILIPS_PAL ]; break;\n\t    case 2: bktr->card.tuner = &tuners[ PHILIPS_NTSC ]; break;\n\t    case 3: bktr->card.tuner = &tuners[ PHILIPS_SECAM ]; break;\n\t    case 4: bktr->card.tuner = &tuners[ NO_TUNER ]; break;\n\t    case 5: bktr->card.tuner = &tuners[ PHILIPS_PALI ]; break;\n\t    case 6: bktr->card.tuner = &tuners[ TEMIC_NTSC ]; break;\n\t    case 7: bktr->card.tuner = &tuners[ TEMIC_PALI ]; break;\n\t    }\n\t    goto checkDBX;\n\t    break;\n\n\tcase CARD_HAUPPAUGE:\n\t    /* Hauppauge kindly supplied the following Tuner Table */\n\t    /* FIXME: I think the tuners the driver selects for types */\n\t    /* 0x08 and 0x15 may be incorrect but no one has complained. */\n\t    /*\n   \t    \tID Tuner Model          Format         \tWe select Format\n\t   \t 0 NONE               \n\t\t 1 EXTERNAL             \n\t\t 2 OTHER                \n\t\t 3 Philips FI1216       BG \n\t\t 4 Philips FI1216MF     BGLL' \n\t\t 5 Philips FI1236       MN \t\tPHILIPS_NTSC\n\t\t 6 Philips FI1246       I \n\t\t 7 Philips FI1256       DK \n\t\t 8 Philips FI1216 MK2   BG \t\tPHILIPS_PALI\n\t\t 9 Philips FI1216MF MK2 BGLL' \n\t\t a Philips FI1236 MK2   MN \t\tPHILIPS_NTSC\n\t\t b Philips FI1246 MK2   I \t\tPHILIPS_PALI\n\t\t c Philips FI1256 MK2   DK \n\t\t d Temic 4032FY5        NTSC\t\tTEMIC_NTSC\n\t\t e Temic 4002FH5        BG\t\tTEMIC_PAL\n\t\t f Temic 4062FY5        I \t\tTEMIC_PALI\n\t\t10 Philips FR1216 MK2   BG \n\t\t11 Philips FR1216MF MK2 BGLL' \n\t\t12 Philips FR1236 MK2   MN \t\tPHILIPS_FR1236_NTSC\n\t\t13 Philips FR1246 MK2   I \n\t\t14 Philips FR1256 MK2   DK \n\t\t15 Philips FM1216       BG \t\tPHILIPS_FR1216_PAL\n\t\t16 Philips FM1216MF     BGLL' \n\t\t17 Philips FM1236       MN \t\tPHILIPS_FR1236_NTSC\n\t\t18 Philips FM1246       I \n\t\t19 Philips FM1256       DK \n\t\t1a Temic 4036FY5        MN - FI1236 MK2 clone\n\t\t1b Samsung TCPN9082D    MN \n\t\t1c Samsung TCPM9092P    Pal BG/I/DK \n\t\t1d Temic 4006FH5        BG \t\tPHILIPS_PALI clone\n\t\t1e Samsung TCPN9085D    MN/Radio \n\t\t1f Samsung TCPB9085P    Pal BG/I/DK / Radio \n\t\t20 Samsung TCPL9091P    Pal BG & Secam L/L' \n\t\t21 Temic 4039FY5        NTSC Radio\n\n\t    */\n\n\t    readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\n\t    /* Determine the model number from the eeprom */\n\t    {\n\t\tu_int model;\n\t\tu_int revision;\n\t\tmodel    = (eeprom[12] << 8  | eeprom[11]);\n\t\trevision = (eeprom[15] << 16 | eeprom[14] << 8 | eeprom[13]);\n\t\tif (verbose)\n\t\t    printf(\"Hauppauge Model %d %c%c%c%c\\n\",\n\t\t\tmodel,\n\t\t\t((revision >> 18) & 0x3f) + 32,\n\t\t\t((revision >> 12) & 0x3f) + 32,\n\t\t\t((revision >>  6) & 0x3f) + 32,\n\t\t\t((revision >>  0) & 0x3f) + 32 );\n\t    }\n\n\t    /* Determine the tuner type from the eeprom */\n\t    tuner_code = eeprom[9];\n\t    switch (tuner_code) {\n\n\t       case 0x5:\n               case 0x0a:\n\t       case 0x1a:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_NTSC  ];\n\t\t goto checkDBX;\n\n               case 0x12:\n\t       case 0x17:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1236_NTSC  ];\n\t\t goto checkDBX;\n\n\t       case 0x8:\n\t       case 0xb:\n\t       case 0x1d:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_PALI ];\n\t\t goto checkDBX;\n\n\t       case 0xd:\n\t\t bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n\t\t goto checkDBX;\n\n               case 0xe:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PAL];\n\t\t goto checkDBX;\n\n\t       case 0xf:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PALI ];\n\t\t goto checkDBX;\n\n               case 0x15:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1216_PAL];\n\t\t goto checkDBX;\n\n\t       default :\n\t\t printf(\"Warning - Unknown Hauppauge Tuner 0x%x\\n\",tuner_code);\n\t    }\n\t    break;\n\n\t} /* end switch(card) */\n\n        /* At this point, a goto checkDBX has not occured */\n        /* We have not been able to select a Tuner */\n        /* Some cards make use of the tuner address to */\n        /* identify the make/model of tuner */\n\n        /* At address 0xc0/0xc1 we often find a TEMIC NTSC */\n        if ( i2cRead( bktr, 0xc1 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n            goto checkDBX;\n        }\n  \n        /* At address 0xc6/0xc7 we often find a PHILIPS NTSC Tuner */\n        if ( i2cRead( bktr, 0xc7 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ PHILIPS_NTSC ];\n            goto checkDBX;\n        }\n\n        /* Address 0xc2/0xc3 is default (or common address) for several */\n\t/* tuners and we cannot tell which is which. */\n\t/* And for all other tuner i2c addresses, select the default */\n\tbktr->card.tuner = &tuners[ DEFAULT_TUNER ];\n\n\ncheckDBX:\n#if defined( OVERRIDE_DBX )\n\tbktr->card.dbx = OVERRIDE_DBX;\n\tgoto checkMSP;\n#endif\n   /* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSP;\n\t}\n\n\t/* probe for BTSC (dbx) chip */\n\tif ( i2cRead( bktr, TDA9850_RADDR ) != ABSENT )\n\t\tbktr->card.dbx = 1;\n\ncheckMSP:\n\t/* If this is a Hauppauge Bt878 card, we need to enable the\n\t * MSP 34xx audio chip. \n\t * If this is a Hauppauge Bt848 card, reset the MSP device.\n\t * The MSP reset line is wired to GPIO pin 5. On Bt878 cards a pulldown\n\t * resistor holds the device in reset until we set GPIO pin 5.\n         */\n\n\t/* Optionally skip the MSP reset. This is handy if you initialise the\n\t * MSP audio in another operating system (eg Windows) first and then\n\t * do a soft reboot.\n\t */\n\n#ifndef BKTR_NO_MSP_RESET\n\tif (card == CARD_HAUPPAUGE) {\n            bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n        }\n#endif\n\n#if defined( OVERRIDE_MSP )\n\tbktr->card.msp3400c = OVERRIDE_MSP;\n\tgoto checkMSPEnd;\n#endif\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSPEnd;\n\t}\n\n\tif ( i2cRead( bktr, MSP3400C_RADDR ) != ABSENT )\n\t\tbktr->card.msp3400c = 1;\n\ncheckMSPEnd:\n\n/* Start of Check Remote */\n        /* Check for the Hauppauge IR Remote Control */\n        /* If there is an external unit, the internal will be ignored */\n\n        bktr->remote_control = 0; /* initial value */\n\n        if (any_i2c_devices) {\n            if (i2cRead( bktr, HAUP_REMOTE_EXT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_EXT_RADDR;\n                }\n            else if (i2cRead( bktr, HAUP_REMOTE_INT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_INT_RADDR;\n                }\n\n        }\n        /* If a remote control is found, poll it 5 times to turn off the LED */\n        if (bktr->remote_control) {\n                int i;\n                for (i=0; i<5; i++)\n                        i2cRead( bktr, bktr->remote_control_addr );\n        }\n/* End of Check Remote */\n\n#if defined( BKTR_USE_PLL )\n\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\tgoto checkPLLEnd;\n#endif\n\t/* Default is to use XTALS and not PLL mode */\n\tbktr->xtal_pll_mode = BT848_USE_XTALS;\n\n\t/* Enable PLL mode for PAL/SECAM users on Hauppauge 878 cards */\n\tif ((card == CARD_HAUPPAUGE) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\n\t/* Enable PLL mode for OSPREY users */\n\tif (card == CARD_OSPREY)\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\t/* Enable PLL mode for PAL/SECAM users on FlyVideo 878 cards */\n\tif ((card == CARD_FLYVIDEO) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n#if defined( BKTR_USE_PLL )\ncheckPLLEnd:\n#endif\n\n\n\tbktr->card.tuner_pllAddr = tuner_i2c_address;\n\n\tif ( verbose ) {\n\t\tprintf( \"%s\", bktr->card.name );\n\t\tif ( bktr->card.tuner )\n\t\t\tprintf( \", %s tuner\", bktr->card.tuner->name );\n\t\tif ( bktr->card.dbx )\n\t\t\tprintf( \", dbx stereo\" );\n\t\tif ( bktr->card.msp3400c )\n\t\t\tprintf( \", msp3400c stereo\" );\n                if ( bktr->remote_control )\n                        printf( \", remote control\" );\n\t\tprintf( \".\\n\" );\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_busy",
          "args": [
            "devclass_get_device(bktr_devclass, unit)"
          ],
          "line": 7177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devclass_get_device",
          "args": [
            "bktr_devclass",
            "unit"
          ],
          "line": 7177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devclass_get_softc",
          "args": [
            "bktr_devclass",
            "unit"
          ],
          "line": 7167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UNIT",
          "args": [
            "minor(dev)"
          ],
          "line": 7164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 7164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define bktr_open       bktropen\n#define FUNCTION\tdv_subunit\n#define UNIT\t\tdv_unit\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define VBI_DEV\t\t0x02\n#define TUNER_DEV\t0x01\n#define VIDEO_DEV\t0x00\n#define Bt848_MAX_CARD\t\t13\n#define Bt848_MAX_TUNER         14\n\nint\nbktr_open( dev_t dev, int flags, int fmt, struct proc *p )\n{\n\tbktr_ptr_t\tbktr;\n\tint\t\tunit;\n\tint\t\tresult;\n\n\tunit = UNIT( minor(dev) );\n\n\t/* Get the device data */\n\tbktr = (struct bktr_softc*)devclass_get_softc(bktr_devclass, unit);\n\tif (bktr == NULL) {\n\t\t/* the device is no longer valid/functioning */\n\t\treturn (ENXIO);\n\t}\n\n\tif (!(bktr->flags & METEOR_INITALIZED)) /* device not found */\n\t\treturn( ENXIO );\t\n\n\t/* Record that the device is now busy */\n\tdevice_busy(devclass_get_device(bktr_devclass, unit)); \n\n\n\tif (bt848_card != -1) {\n\t  if ((bt848_card >> 8   == unit ) &&\n\t     ( (bt848_card & 0xff) < Bt848_MAX_CARD )) {\n\t    if ( bktr->bt848_card != (bt848_card & 0xff) ) {\n\t      bktr->bt848_card = (bt848_card & 0xff);\n\t      probeCard(bktr, FALSE);\n\t    }\n\t  }\n\t}\n\n\tif (bt848_tuner != -1) {\n\t  if ((bt848_tuner >> 8   == unit ) &&\n\t     ( (bt848_tuner & 0xff) < Bt848_MAX_TUNER )) {\n\t    if ( bktr->bt848_tuner != (bt848_tuner & 0xff) ) {\n\t      bktr->bt848_tuner = (bt848_tuner & 0xff);\n\t      probeCard(bktr, FALSE);\n\t    }\n\t  }\n\t}\n\n\tif (bt848_reverse_mute != -1) {\n\t  if (((bt848_reverse_mute >> 8)   == unit ) &&\n\t      ((bt848_reverse_mute & 0xff) < Bt848_MAX_TUNER) ) {\n\t    bktr->reverse_mute = bt848_reverse_mute & 0xff;\n\t    bt848_reverse_mute = -1;\n\t  }\n\t}\n\n\tswitch ( FUNCTION( minor(dev) ) ) {\n\tcase VIDEO_DEV:\n\t\tresult = video_open( bktr );\n\t\tbreak;\n\tcase TUNER_DEV:\n\t\tresult = tuner_open( bktr );\n\t\tbreak;\n\tcase VBI_DEV:\n\t\tresult = vbi_open( bktr );\n\t\tbreak;\n\tdefault:\n\t\tresult = ENXIO;\n\t\tbreak;\n\t}\n\n\t/* If there was an error opening the device, undo the busy status */\n\tif (result != 0)\n\t\tdevice_unbusy(devclass_get_device(bktr_devclass, unit)); \n\treturn( result );\n}"
  },
  {
    "function_name": "get_bktr_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7122-7137",
    "snippet": "static vm_offset_t\nget_bktr_mem( int unit, unsigned size )\n{\n\tvm_offset_t\taddr = 0;\n\n\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff, 1<<24);\n\tif (addr == 0)\n\t\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff,\n\t\t\t\t\t\t\t\tPAGE_SIZE);\n\tif (addr == 0) {\n\t\tprintf(\"bktr%d: Unable to allocate %d bytes of memory.\\n\",\n\t\t\tunit, size);\n\t}\n\n\treturn( addr );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bktr%d: Unable to allocate %d bytes of memory.\\n\"",
            "unit",
            "size"
          ],
          "line": 7132
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_page_alloc_contig",
          "args": [
            "size",
            "0x100000",
            "0xffffffff",
            "PAGE_SIZE"
          ],
          "line": 7129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_page_alloc_contig",
          "args": [
            "size",
            "0x100000",
            "0xffffffff",
            "1<<24"
          ],
          "line": 7127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic vm_offset_t\nget_bktr_mem( int unit, unsigned size )\n{\n\tvm_offset_t\taddr = 0;\n\n\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff, 1<<24);\n\tif (addr == 0)\n\t\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff,\n\t\t\t\t\t\t\t\tPAGE_SIZE);\n\tif (addr == 0) {\n\t\tprintf(\"bktr%d: Unable to allocate %d bytes of memory.\\n\",\n\t\t\tunit, size);\n\t}\n\n\treturn( addr );\n}"
  },
  {
    "function_name": "bktr_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7104-7116",
    "snippet": "static int\nbktr_shutdown( device_t dev )\n{\n\tstruct bktr_softc *bktr = device_get_softc(dev);\n\tbt848_ptr_t bt848;\n\n\t/* Disable the brooktree device */\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define ALL_INTS_DISABLED\t0",
      "#define FIFO_RISC_DISABLED\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_get_softc",
          "args": [
            "dev"
          ],
          "line": 7107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n\nstatic int\nbktr_shutdown( device_t dev )\n{\n\tstruct bktr_softc *bktr = device_get_softc(dev);\n\tbt848_ptr_t bt848;\n\n\t/* Disable the brooktree device */\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bktr_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "7078-7099",
    "snippet": "static int\nbktr_detach( device_t dev )\n{\n\tstruct bktr_softc *bktr = device_get_softc(dev);\n\tbt848_ptr_t bt848;\n\n\t/* Disable the brooktree device */\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t/* FIXME - Free memory for RISC programs, grab buffer, vbi buffers */\n\n\t/*\n\t * Deallocate resources.\n\t */\n\tbus_teardown_intr(dev, bktr->res_irq, bktr->res_ih);\n\tbus_release_resource(dev, SYS_RES_IRQ, 0, bktr->res_irq);\n\tbus_release_resource(dev, SYS_RES_MEMORY, PCI_MAP_REG_START, bktr->res_mem);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define ALL_INTS_DISABLED\t0",
      "#define FIFO_RISC_DISABLED\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_release_resource",
          "args": [
            "dev",
            "SYS_RES_MEMORY",
            "PCI_MAP_REG_START",
            "bktr->res_mem"
          ],
          "line": 7096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_release_resource",
          "args": [
            "dev",
            "SYS_RES_IRQ",
            "0",
            "bktr->res_irq"
          ],
          "line": 7095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_teardown_intr",
          "args": [
            "dev",
            "bktr->res_irq",
            "bktr->res_ih"
          ],
          "line": 7094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_softc",
          "args": [
            "dev"
          ],
          "line": 7081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n\nstatic int\nbktr_detach( device_t dev )\n{\n\tstruct bktr_softc *bktr = device_get_softc(dev);\n\tbt848_ptr_t bt848;\n\n\t/* Disable the brooktree device */\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t/* FIXME - Free memory for RISC programs, grab buffer, vbi buffers */\n\n\t/*\n\t * Deallocate resources.\n\t */\n\tbus_teardown_intr(dev, bktr->res_irq, bktr->res_ih);\n\tbus_release_resource(dev, SYS_RES_IRQ, 0, bktr->res_irq);\n\tbus_release_resource(dev, SYS_RES_MEMORY, PCI_MAP_REG_START, bktr->res_mem);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bktr_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6927-7073",
    "snippet": "static int\nbktr_attach( device_t dev )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\tlatency;\n\tu_long\t\tfun;\n\tu_long\t\tval;\n\tunsigned int\trev;\n\tunsigned int\tunit;\n\tint\t\terror = 0;\n\tint\t\trid;\n#ifdef BROOKTREE_IRQ\n\tu_long\t\told_irq, new_irq;\n#endif \n\n        struct bktr_softc *bktr = device_get_softc(dev);\n\n\tunit = device_get_unit(dev);\n\n\t/*\n\t * Enable bus mastering and Memory Mapped device\n\t */\n\tval = pci_read_config(dev, PCIR_COMMAND, 4);\n\tval |= (PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN);\n\tpci_write_config(dev, PCIR_COMMAND, val, 4);\n\n\t/*\n\t * Map control/status registers.\n\t */\n\trid = PCI_MAP_REG_START;\n\tbktr->res_mem = bus_alloc_resource(dev, SYS_RES_MEMORY, &rid,\n                                  0, ~0, 1, RF_ACTIVE);\n\n\tif (!bktr->res_mem) {\n\t\tdevice_printf(dev, \"could not map memory\\n\");\n\t\terror = ENXIO;\n\t\tgoto fail;\n\t}\n\tbktr->base = rman_get_virtual(bktr->res_mem); /* XXX use bus_space */\n\n\t/*\n\t * Disable the brooktree device\n\t */\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\n#ifdef BROOKTREE_IRQ\t\t/* from the configuration file */\n\told_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tpci_conf_write(tag, PCI_INTERRUPT_REG, BROOKTREE_IRQ);\n\tnew_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tprintf(\"bktr%d: attach: irq changed from %d to %d\\n\",\n\t\tunit, (old_irq & 0xff), (new_irq & 0xff));\n#endif \n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\trid = 0;\n\tbktr->res_irq = bus_alloc_resource(dev, SYS_RES_IRQ, &rid, 0, ~0, 1,\n                                 RF_SHAREABLE | RF_ACTIVE);\n\tif (bktr->res_irq == NULL) {\n\t\tdevice_printf(dev, \"could not map interrupt\\n\");\n\t\terror = ENXIO;\n\t\tgoto fail;\n\t}\n\n\terror = bus_setup_intr(dev, bktr->res_irq, INTR_TYPE_NET,\n                               bktr_intr, bktr, &bktr->res_ih);\n\tif (error) {\n\t\tdevice_printf(dev, \"could not setup irq\\n\");\n\t\tgoto fail;\n\n\t}\n\n\n\t/* Update the Device Control Register */\n\t/* on Bt878 and Bt879 cards           */\n\tfun = pci_read_config( dev, 0x40, 2);\n        fun = fun | 1;\t/* Enable writes to the sub-system vendor ID */\n\n#if defined( BKTR_430_FX_MODE )\n\tif (bootverbose) printf(\"Using 430 FX chipset compatibilty mode\\n\");\n        fun = fun | 2;\t/* Enable Intel 430 FX compatibility mode */\n#endif\n\n#if defined( BKTR_SIS_VIA_MODE )\n\tif (bootverbose) printf(\"Using SiS/VIA chipset compatibilty mode\\n\");\n        fun = fun | 4;\t/* Enable SiS/VIA compatibility mode (usefull for\n                           OPTi chipset motherboards too */\n#endif\n\tpci_write_config(dev, 0x40, fun, 2);\n\n\n\t/* XXX call bt848_i2c dependent attach() routine */\n#if (NSMBUS > 0)\n\tif (bt848_i2c_attach(unit, bktr->base, &bktr->i2c_sc))\n\t\tprintf(\"bktr%d: i2c_attach: can't attach\\n\", unit);\n#endif\n\n\n/*\n * PCI latency timer.  32 is a good value for 4 bus mastering slots, if\n * you have more than four, then 16 would probably be a better value.\n */\n#ifndef BROOKTREE_DEF_LATENCY_VALUE\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#endif\n\tlatency = pci_read_config(dev, PCI_LATENCY_TIMER, 4);\n\tlatency = (latency >> 8) & 0xff;\n\tif ( bootverbose ) {\n\t\tif (latency)\n\t\t\tprintf(\"brooktree%d: PCI bus latency is\", unit);\n\t\telse\n\t\t\tprintf(\"brooktree%d: PCI bus latency was 0 changing to\",\n\t\t\t\tunit);\n\t}\n\tif ( !latency ) {\n\t\tlatency = BROOKTREE_DEF_LATENCY_VALUE;\n\t\tpci_write_config(dev, PCI_LATENCY_TIMER, latency<<8, 4);\n\t}\n\tif ( bootverbose ) {\n\t\tprintf(\" %d.\\n\", (int) latency);\n\t}\n\n\t/* read the pci device id and revision id */\n\tfun = pci_get_devid(dev);\n        rev = pci_get_revid(dev);\n\n\t/* call the common attach code */\n\tcommon_bktr_attach( bktr, unit, fun, rev );\n\n#ifdef DEVFS\n\t/* XXX This just throw away the token, which should probably be fixed when\n\t   DEVFS is finally made really operational. */\n\tdevfs_add_devswf(&bktr_cdevsw, unit,    DV_CHR, 0, 0, 0444, \"bktr%d\",  unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+16, DV_CHR, 0, 0, 0444, \"tuner%d\", unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+32, DV_CHR, 0, 0, 0444, \"vbi%d\", unit);\n#endif /* DEVFS */\n\n\treturn 0;\n\nfail:\n\treturn error;\n\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)",
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define BROOKTREE_DEF_LATENCY_VALUE\t10",
      "#define ALL_INTS_DISABLED\t0",
      "#define FIFO_RISC_DISABLED\t0",
      "#define NSMBUS 0",
      "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))",
      "#define NSMBUS 0",
      "#define NSMBUS 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devfs_add_devswf",
          "args": [
            "&bktr_cdevsw",
            "unit+32",
            "DV_CHR",
            "0",
            "0",
            "0444",
            "\"vbi%d\"",
            "unit"
          ],
          "line": 7065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devfs_add_devswf",
          "args": [
            "&bktr_cdevsw",
            "unit+16",
            "DV_CHR",
            "0",
            "0",
            "0444",
            "\"tuner%d\"",
            "unit"
          ],
          "line": 7064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devfs_add_devswf",
          "args": [
            "&bktr_cdevsw",
            "unit",
            "DV_CHR",
            "0",
            "0",
            "0444",
            "\"bktr%d\"",
            "unit"
          ],
          "line": 7063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "common_bktr_attach",
          "args": [
            "bktr",
            "unit",
            "fun",
            "rev"
          ],
          "line": 7058
        },
        "resolved": true,
        "details": {
          "function_name": "common_bktr_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1447-1558",
          "snippet": "static void \ncommon_bktr_attach( bktr_ptr_t bktr, int unit, u_long pci_id, u_int rev )\n{\n\tbt848_ptr_t\tbt848;\n\tvm_offset_t\tbuf;\n\n\tbt848 = bktr->base;\n\n/***************************************/\n/* *** OS Specific memory routines *** */\n/***************************************/\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n        /* allocate space for dma program */\n        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);\n        bktr->odd_dma_prog = get_bktr_mem(bktr, &bktr->dm_oprog, DMA_PROG_ALLOC)\n;\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(bktr, &bktr->dm_vbibuffer, VBI_BUFFER_SIZE);\n\n        /* allocate space for pixel buffer */\n        if ( BROOKTREE_ALLOC )\n                buf = get_bktr_mem(bktr, &bktr->dm_mem, BROOKTREE_ALLOC);\n        else\n                buf = 0;\n#endif\n\n#if defined(__FreeBSD__) || defined(__bsdi__)\n\t/* allocate space for dma program */\n\tbktr->dma_prog     = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\tbktr->odd_dma_prog = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(unit, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(unit, VBI_BUFFER_SIZE);\n\n\t/* allocate space for pixel buffer */\n\tif ( BROOKTREE_ALLOC )\n\t\tbuf = get_bktr_mem(unit, BROOKTREE_ALLOC);\n\telse\n\t\tbuf = 0;\n#endif\n\n\tif ( bootverbose ) {\n\t\tprintf(\"bktr%d: buffer size %d, addr 0x%x\\n\",\n\t\t\tunit, BROOKTREE_ALLOC, vtophys(buf));\n\t}\n\n\tif ( buf != 0 ) {\n\t\tbktr->bigbuf = buf;\n\t\tbktr->alloc_pages = BROOKTREE_ALLOC_PAGES;\n\t\tbzero((caddr_t) bktr->bigbuf, BROOKTREE_ALLOC);\n\t} else {\n\t\tbktr->alloc_pages = 0;\n\t}\n\t\t\n\n\tbktr->flags = METEOR_INITALIZED | METEOR_AUTOMODE |\n\t\t      METEOR_DEV0 | METEOR_RGB16;\n\tbktr->dma_prog_loaded = FALSE;\n\tbktr->cols = 640;\n\tbktr->rows = 480;\n\tbktr->frames = 1;\t\t/* one frame */\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\tbktr->pixfmt_compat = TRUE;\n\n\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbiflags = 0;\n\n \n\t/* using the pci device id and revision id */\n\t/* and determine the card type            */\n\tswitch (pci_id) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) bktr->id = BROOKTREE_848A;\n\t\telse             bktr->id = BROOKTREE_848;\n\t\tbreak;\n        case BROOKTREE_849_PCI_ID:\n\t\tbktr->id = BROOKTREE_849A;\n\t\tbreak;\n        case BROOKTREE_878_PCI_ID:\n\t\tbktr->id = BROOKTREE_878;\n\t\tbreak;\n        case BROOKTREE_879_PCI_ID:\n\t\tbktr->id = BROOKTREE_879;\n\t\tbreak;\n\t};\n\n\tbktr->clr_on_start = FALSE;\n\n\t/* defaults for the tuner section of the card */\n\tbktr->tflags = TUNER_INITALIZED;\n\tbktr->tuner.frequency = 0;\n\tbktr->tuner.channel = 0;\n\tbktr->tuner.chnlset = DEFAULT_CHNLSET;\n\tbktr->audio_mux_select = 0;\n\tbktr->audio_mute_state = FALSE;\n\tbktr->bt848_card = -1;\n\tbktr->bt848_tuner = -1;\n\tbktr->reverse_mute = -1;\n\n\tprobeCard( bktr, TRUE );\n\n\t/* If there is an MSP Audio device, reset it and display the model */\n\tif (bktr->card.msp3400c)msp_reset(bktr);\n\tif (bktr->card.msp3400c)msp_read_id(bktr);\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define DEFAULT_CHNLSET\tCHNLSET_WEUROPE",
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)",
            "#define BROOKTREE_ALLOC\t\t(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)",
            "#define BROOKTREE_ALLOC_PAGES\t217*4",
            "#define DMA_PROG_ALLOC\t\t(8 * PAGE_SIZE)",
            "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define DEFAULT_CHNLSET\tCHNLSET_WEUROPE\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n#define BROOKTREE_ALLOC\t\t(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)\n#define BROOKTREE_ALLOC_PAGES\t217*4\n#define DMA_PROG_ALLOC\t\t(8 * PAGE_SIZE)\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n\nstatic void \ncommon_bktr_attach( bktr_ptr_t bktr, int unit, u_long pci_id, u_int rev )\n{\n\tbt848_ptr_t\tbt848;\n\tvm_offset_t\tbuf;\n\n\tbt848 = bktr->base;\n\n/***************************************/\n/* *** OS Specific memory routines *** */\n/***************************************/\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n        /* allocate space for dma program */\n        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);\n        bktr->odd_dma_prog = get_bktr_mem(bktr, &bktr->dm_oprog, DMA_PROG_ALLOC)\n;\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(bktr, &bktr->dm_vbibuffer, VBI_BUFFER_SIZE);\n\n        /* allocate space for pixel buffer */\n        if ( BROOKTREE_ALLOC )\n                buf = get_bktr_mem(bktr, &bktr->dm_mem, BROOKTREE_ALLOC);\n        else\n                buf = 0;\n#endif\n\n#if defined(__FreeBSD__) || defined(__bsdi__)\n\t/* allocate space for dma program */\n\tbktr->dma_prog     = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\tbktr->odd_dma_prog = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(unit, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(unit, VBI_BUFFER_SIZE);\n\n\t/* allocate space for pixel buffer */\n\tif ( BROOKTREE_ALLOC )\n\t\tbuf = get_bktr_mem(unit, BROOKTREE_ALLOC);\n\telse\n\t\tbuf = 0;\n#endif\n\n\tif ( bootverbose ) {\n\t\tprintf(\"bktr%d: buffer size %d, addr 0x%x\\n\",\n\t\t\tunit, BROOKTREE_ALLOC, vtophys(buf));\n\t}\n\n\tif ( buf != 0 ) {\n\t\tbktr->bigbuf = buf;\n\t\tbktr->alloc_pages = BROOKTREE_ALLOC_PAGES;\n\t\tbzero((caddr_t) bktr->bigbuf, BROOKTREE_ALLOC);\n\t} else {\n\t\tbktr->alloc_pages = 0;\n\t}\n\t\t\n\n\tbktr->flags = METEOR_INITALIZED | METEOR_AUTOMODE |\n\t\t      METEOR_DEV0 | METEOR_RGB16;\n\tbktr->dma_prog_loaded = FALSE;\n\tbktr->cols = 640;\n\tbktr->rows = 480;\n\tbktr->frames = 1;\t\t/* one frame */\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\tbktr->pixfmt_compat = TRUE;\n\n\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbiflags = 0;\n\n \n\t/* using the pci device id and revision id */\n\t/* and determine the card type            */\n\tswitch (pci_id) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) bktr->id = BROOKTREE_848A;\n\t\telse             bktr->id = BROOKTREE_848;\n\t\tbreak;\n        case BROOKTREE_849_PCI_ID:\n\t\tbktr->id = BROOKTREE_849A;\n\t\tbreak;\n        case BROOKTREE_878_PCI_ID:\n\t\tbktr->id = BROOKTREE_878;\n\t\tbreak;\n        case BROOKTREE_879_PCI_ID:\n\t\tbktr->id = BROOKTREE_879;\n\t\tbreak;\n\t};\n\n\tbktr->clr_on_start = FALSE;\n\n\t/* defaults for the tuner section of the card */\n\tbktr->tflags = TUNER_INITALIZED;\n\tbktr->tuner.frequency = 0;\n\tbktr->tuner.channel = 0;\n\tbktr->tuner.chnlset = DEFAULT_CHNLSET;\n\tbktr->audio_mux_select = 0;\n\tbktr->audio_mute_state = FALSE;\n\tbktr->bt848_card = -1;\n\tbktr->bt848_tuner = -1;\n\tbktr->reverse_mute = -1;\n\n\tprobeCard( bktr, TRUE );\n\n\t/* If there is an MSP Audio device, reset it and display the model */\n\tif (bktr->card.msp3400c)msp_reset(bktr);\n\tif (bktr->card.msp3400c)msp_read_id(bktr);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_get_revid",
          "args": [
            "dev"
          ],
          "line": 7055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_devid",
          "args": [
            "dev"
          ],
          "line": 7054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %d.\\n\"",
            "(int) latency"
          ],
          "line": 7050
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_write_config",
          "args": [
            "dev",
            "PCI_LATENCY_TIMER",
            "latency<<8",
            "4"
          ],
          "line": 7047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config",
          "args": [
            "dev",
            "PCI_LATENCY_TIMER",
            "4"
          ],
          "line": 7036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt848_i2c_attach",
          "args": [
            "unit",
            "bktr->base",
            "&bktr->i2c_sc"
          ],
          "line": 7024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_write_config",
          "args": [
            "dev",
            "0x40",
            "fun",
            "2"
          ],
          "line": 7019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config",
          "args": [
            "dev",
            "0x40",
            "2"
          ],
          "line": 7006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_printf",
          "args": [
            "dev",
            "\"could not setup irq\\n\""
          ],
          "line": 6998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_setup_intr",
          "args": [
            "dev",
            "bktr->res_irq",
            "INTR_TYPE_NET",
            "bktr_intr",
            "bktr",
            "&bktr->res_ih"
          ],
          "line": 6995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_printf",
          "args": [
            "dev",
            "\"could not map interrupt\\n\""
          ],
          "line": 6990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_alloc_resource",
          "args": [
            "dev",
            "SYS_RES_IRQ",
            "&rid",
            "0",
            "~0",
            "1",
            "RF_SHAREABLE | RF_ACTIVE"
          ],
          "line": 6987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_INTERRUPT_REG"
          ],
          "line": 6978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "tag",
            "PCI_INTERRUPT_REG",
            "BROOKTREE_IRQ"
          ],
          "line": 6977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "tag",
            "PCI_INTERRUPT_REG"
          ],
          "line": 6976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rman_get_virtual",
          "args": [
            "bktr->res_mem"
          ],
          "line": 6965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_printf",
          "args": [
            "dev",
            "\"could not map memory\\n\""
          ],
          "line": 6961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_alloc_resource",
          "args": [
            "dev",
            "SYS_RES_MEMORY",
            "&rid",
            "0",
            "~0",
            "1",
            "RF_ACTIVE"
          ],
          "line": 6957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_write_config",
          "args": [
            "dev",
            "PCIR_COMMAND",
            "val",
            "4"
          ],
          "line": 6951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config",
          "args": [
            "dev",
            "PCIR_COMMAND",
            "4"
          ],
          "line": 6949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "dev"
          ],
          "line": 6944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_softc",
          "args": [
            "dev"
          ],
          "line": 6942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define brooktree *((bktr_ptr_t *)bktrcd.cd_devs)\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n#define NSMBUS 0\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n#define NSMBUS 0\n#define NSMBUS 0\n\nstatic int\nbktr_attach( device_t dev )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\tlatency;\n\tu_long\t\tfun;\n\tu_long\t\tval;\n\tunsigned int\trev;\n\tunsigned int\tunit;\n\tint\t\terror = 0;\n\tint\t\trid;\n#ifdef BROOKTREE_IRQ\n\tu_long\t\told_irq, new_irq;\n#endif \n\n        struct bktr_softc *bktr = device_get_softc(dev);\n\n\tunit = device_get_unit(dev);\n\n\t/*\n\t * Enable bus mastering and Memory Mapped device\n\t */\n\tval = pci_read_config(dev, PCIR_COMMAND, 4);\n\tval |= (PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN);\n\tpci_write_config(dev, PCIR_COMMAND, val, 4);\n\n\t/*\n\t * Map control/status registers.\n\t */\n\trid = PCI_MAP_REG_START;\n\tbktr->res_mem = bus_alloc_resource(dev, SYS_RES_MEMORY, &rid,\n                                  0, ~0, 1, RF_ACTIVE);\n\n\tif (!bktr->res_mem) {\n\t\tdevice_printf(dev, \"could not map memory\\n\");\n\t\terror = ENXIO;\n\t\tgoto fail;\n\t}\n\tbktr->base = rman_get_virtual(bktr->res_mem); /* XXX use bus_space */\n\n\t/*\n\t * Disable the brooktree device\n\t */\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\n#ifdef BROOKTREE_IRQ\t\t/* from the configuration file */\n\told_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tpci_conf_write(tag, PCI_INTERRUPT_REG, BROOKTREE_IRQ);\n\tnew_irq = pci_conf_read(tag, PCI_INTERRUPT_REG);\n\tprintf(\"bktr%d: attach: irq changed from %d to %d\\n\",\n\t\tunit, (old_irq & 0xff), (new_irq & 0xff));\n#endif \n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\trid = 0;\n\tbktr->res_irq = bus_alloc_resource(dev, SYS_RES_IRQ, &rid, 0, ~0, 1,\n                                 RF_SHAREABLE | RF_ACTIVE);\n\tif (bktr->res_irq == NULL) {\n\t\tdevice_printf(dev, \"could not map interrupt\\n\");\n\t\terror = ENXIO;\n\t\tgoto fail;\n\t}\n\n\terror = bus_setup_intr(dev, bktr->res_irq, INTR_TYPE_NET,\n                               bktr_intr, bktr, &bktr->res_ih);\n\tif (error) {\n\t\tdevice_printf(dev, \"could not setup irq\\n\");\n\t\tgoto fail;\n\n\t}\n\n\n\t/* Update the Device Control Register */\n\t/* on Bt878 and Bt879 cards           */\n\tfun = pci_read_config( dev, 0x40, 2);\n        fun = fun | 1;\t/* Enable writes to the sub-system vendor ID */\n\n#if defined( BKTR_430_FX_MODE )\n\tif (bootverbose) printf(\"Using 430 FX chipset compatibilty mode\\n\");\n        fun = fun | 2;\t/* Enable Intel 430 FX compatibility mode */\n#endif\n\n#if defined( BKTR_SIS_VIA_MODE )\n\tif (bootverbose) printf(\"Using SiS/VIA chipset compatibilty mode\\n\");\n        fun = fun | 4;\t/* Enable SiS/VIA compatibility mode (usefull for\n                           OPTi chipset motherboards too */\n#endif\n\tpci_write_config(dev, 0x40, fun, 2);\n\n\n\t/* XXX call bt848_i2c dependent attach() routine */\n#if (NSMBUS > 0)\n\tif (bt848_i2c_attach(unit, bktr->base, &bktr->i2c_sc))\n\t\tprintf(\"bktr%d: i2c_attach: can't attach\\n\", unit);\n#endif\n\n\n/*\n * PCI latency timer.  32 is a good value for 4 bus mastering slots, if\n * you have more than four, then 16 would probably be a better value.\n */\n#ifndef BROOKTREE_DEF_LATENCY_VALUE\n#define BROOKTREE_DEF_LATENCY_VALUE\t10\n#endif\n\tlatency = pci_read_config(dev, PCI_LATENCY_TIMER, 4);\n\tlatency = (latency >> 8) & 0xff;\n\tif ( bootverbose ) {\n\t\tif (latency)\n\t\t\tprintf(\"brooktree%d: PCI bus latency is\", unit);\n\t\telse\n\t\t\tprintf(\"brooktree%d: PCI bus latency was 0 changing to\",\n\t\t\t\tunit);\n\t}\n\tif ( !latency ) {\n\t\tlatency = BROOKTREE_DEF_LATENCY_VALUE;\n\t\tpci_write_config(dev, PCI_LATENCY_TIMER, latency<<8, 4);\n\t}\n\tif ( bootverbose ) {\n\t\tprintf(\" %d.\\n\", (int) latency);\n\t}\n\n\t/* read the pci device id and revision id */\n\tfun = pci_get_devid(dev);\n        rev = pci_get_revid(dev);\n\n\t/* call the common attach code */\n\tcommon_bktr_attach( bktr, unit, fun, rev );\n\n#ifdef DEVFS\n\t/* XXX This just throw away the token, which should probably be fixed when\n\t   DEVFS is finally made really operational. */\n\tdevfs_add_devswf(&bktr_cdevsw, unit,    DV_CHR, 0, 0, 0444, \"bktr%d\",  unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+16, DV_CHR, 0, 0, 0444, \"tuner%d\", unit);\n\tdevfs_add_devswf(&bktr_cdevsw, unit+32, DV_CHR, 0, 0, 0444, \"vbi%d\", unit);\n#endif /* DEVFS */\n\n\treturn 0;\n\nfail:\n\treturn error;\n\n}"
  },
  {
    "function_name": "bktr_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6894-6921",
    "snippet": "static int\nbktr_probe( device_t dev )\n{\n\tunsigned int type = pci_get_devid(dev);\n        unsigned int rev  = pci_get_revid(dev);\n\tstatic int once;\n\n\tif (!once++)\n\t\tcdevsw_add(&bktr_cdevsw);\n\n\tswitch (type) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) device_set_desc(dev, \"BrookTree 848A\");\n\t\telse             device_set_desc(dev, \"BrookTree 848\");\n                return 0;\n        case BROOKTREE_849_PCI_ID:\n                device_set_desc(dev, \"BrookTree 849A\");\n                return 0;\n        case BROOKTREE_878_PCI_ID:\n                device_set_desc(dev, \"BrookTree 878\");\n                return 0;\n        case BROOKTREE_879_PCI_ID:\n                device_set_desc(dev, \"BrookTree 879\");\n                return 0;\n\t};\n\n        return ENXIO;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_set_desc",
          "args": [
            "dev",
            "\"BrookTree 879\""
          ],
          "line": 6916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_set_desc",
          "args": [
            "dev",
            "\"BrookTree 878\""
          ],
          "line": 6913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_set_desc",
          "args": [
            "dev",
            "\"BrookTree 849A\""
          ],
          "line": 6910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_set_desc",
          "args": [
            "dev",
            "\"BrookTree 848\""
          ],
          "line": 6907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_set_desc",
          "args": [
            "dev",
            "\"BrookTree 848A\""
          ],
          "line": 6906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cdevsw_add",
          "args": [
            "&bktr_cdevsw"
          ],
          "line": 6902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_revid",
          "args": [
            "dev"
          ],
          "line": 6898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_devid",
          "args": [
            "dev"
          ],
          "line": 6897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nbktr_probe( device_t dev )\n{\n\tunsigned int type = pci_get_devid(dev);\n        unsigned int rev  = pci_get_revid(dev);\n\tstatic int once;\n\n\tif (!once++)\n\t\tcdevsw_add(&bktr_cdevsw);\n\n\tswitch (type) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) device_set_desc(dev, \"BrookTree 848A\");\n\t\telse             device_set_desc(dev, \"BrookTree 848\");\n                return 0;\n        case BROOKTREE_849_PCI_ID:\n                device_set_desc(dev, \"BrookTree 849A\");\n                return 0;\n        case BROOKTREE_878_PCI_ID:\n                device_set_desc(dev, \"BrookTree 878\");\n                return 0;\n        case BROOKTREE_879_PCI_ID:\n                device_set_desc(dev, \"BrookTree 879\");\n                return 0;\n\t};\n\n        return ENXIO;\n}"
  },
  {
    "function_name": "bktr_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6838-6838",
    "snippet": "static void\tbktr_intr(void *arg) { common_bktr_intr(arg); }",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "common_bktr_intr",
          "args": [
            "arg"
          ],
          "line": 6838
        },
        "resolved": true,
        "details": {
          "function_name": "common_bktr_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1608-1853",
          "snippet": "static int \ncommon_bktr_intr( void *arg )\n{ \n\tbktr_ptr_t\t\tbktr;\n\tbt848_ptr_t\t\tbt848;\n\tu_long\t\t\tbktr_status;\n\tu_char\t\t\tdstatus;\n\tu_long                  field;\n\tu_long                  w_field;\n\tu_long                  req_field;\n\n\tbktr = (bktr_ptr_t) arg;\n\tbt848 = bktr->base;\n\n\t/*\n\t * check to see if any interrupts are unmasked on this device.  If\n\t * none are, then we likely got here by way of being on a PCI shared\n\t * interrupt dispatch list.\n\t */\n\tif (bt848->int_mask == ALL_INTS_DISABLED)\n\t  \treturn 0;\t/* bail out now, before we do something we\n\t\t\t\t   shouldn't */\n\n\tif (!(bktr->flags & METEOR_OPEN)) {\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\t\t/* return; ?? */\n\t}\n\n\t/* record and clear the INTerrupt status bits */\n\tbktr_status = bt848->int_stat;\n\tbt848->int_stat = bktr_status & ~I2C_BITS;\t/* don't touch i2c */\n\n\t/* record and clear the device status register */\n\tdstatus = bt848->dstatus;\n\tbt848->dstatus = 0x00;\n\n#if defined( STATUS_SUM )\n\t/* add any new device status or INTerrupt status bits */\n\tstatus_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));\n\tstatus_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);\n#endif /* STATUS_SUM */\n\t/* printf( \" STATUS %x %x %x \\n\",\n\t\tdstatus, bktr_status, bt848->risc_count );\n\t*/\n\n\n\t/* if risc was disabled re-start process again */\n\tif ( !(bktr_status & BT848_INT_RISC_EN) ||\n\t     ((bktr_status &(BT848_INT_FBUS   |\n\t\t\t      BT848_INT_FTRGT  |\n\t\t\t      BT848_INT_FDSR   |\n\t\t\t      BT848_INT_PPERR  |\n\t\t\t      BT848_INT_RIPERR |\n\t\t\t      BT848_INT_PABORT |\n\t\t\t      BT848_INT_OCERR  |\n\t\t\t      BT848_INT_SCERR) ) != 0) ||\n\t     ((bt848->tdec == 0) && (bktr_status & TDEC_BITS)) ) {\n\n\t\tu_short\ttdec_save = bt848->tdec;\n\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t/*  Reset temporal decimation ctr  */\n\t\tbt848->tdec = 0;\n\t\tbt848->tdec = tdec_save;\n\t\t\n\t\t/*  Reset to no-fields captured state  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\n\t\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n\t\t\t\t  BT848_INT_RISCI      |\n\t\t\t\t  BT848_INT_VSYNC      |\n\t\t\t\t  BT848_INT_FMTCHG;\n\n\t\tbt848->cap_ctl = bktr->bktr_cap_ctl;\n\t\treturn 1;\n\t}\n\n\t/* If this is not a RISC program interrupt, return */\n\tif (!(bktr_status & BT848_INT_RISCI))\n\t\treturn 0;\n\n/**\n\tprintf( \"intr status %x %x %x\\n\",\n\t\tbktr_status, dstatus, bt848->risc_count );\n */\n\t\n\n\t/*\n\t * Disable future interrupts if a capture mode is not selected.\n\t * This can happen when we are in the process of closing or \n\t * changing capture modes, otherwise it shouldn't happen.\n\t */\n\tif (!(bktr->flags & METEOR_CAP_MASK))\n\t\tbt848->cap_ctl = CAPTURE_OFF;\n\n\t/*\n\t *  Register the completed field\n\t *    (For dual-field mode, require fields from the same frame)\n\t */\n\tfield = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;\n\tswitch ( bktr->flags & METEOR_WANT_MASK ) {\n\t\tcase METEOR_WANT_ODD  : w_field = ODD_F         ;  break;\n\t\tcase METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;\n\t\tdefault               : w_field = (ODD_F|EVEN_F);  break;\n\t}\n\tswitch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {\n\t\tcase METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;\n\t\tcase METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;\n\t\tdefault                      : req_field = (ODD_F|EVEN_F);  \n\t\t\t                       break;\n\t}\n\n\tif (( field == EVEN_F ) && ( w_field == EVEN_F ))\n\t\tbktr->flags &= ~METEOR_WANT_EVEN;\n\telse if (( field == ODD_F ) && ( req_field == ODD_F ) &&\n\t\t ( w_field == ODD_F ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == (ODD_F|EVEN_F) ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == ODD_F )) {\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\t\tbktr->flags |=  METEOR_WANT_EVEN;\n\t}\n\telse {\n\t\t/*  We're out of sync.  Start over.  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If we have a complete frame.\n\t */\n\tif (!(bktr->flags & METEOR_WANT_MASK)) {\n\t\tbktr->frames_captured++;\n\t\t/*\n\t\t * post the completion time. \n\t\t */\n\t\tif (bktr->flags & METEOR_WANT_TS) {\n\t\t\tstruct timeval *ts;\n\t\t\t\n\t\t\tif ((u_int) bktr->alloc_pages * PAGE_SIZE\n\t\t\t   <= (bktr->frame_size + sizeof(struct timeval))) {\n\t\t\t\tts =(struct timeval *)bktr->bigbuf +\n\t\t\t\t  bktr->frame_size;\n\t\t\t\t/* doesn't work in synch mode except\n\t\t\t\t *  for first frame */\n\t\t\t\t/* XXX */\n\t\t\t\tmicrotime(ts);\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Process the VBI data if it is being captured\n\t\t */\n\t\tif (bktr->vbiflags & VBI_CAPTURE) {\n                \tvbidecode(bktr);\n                \twakeup(VBI_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * Wake up the user in single capture mode.\n\t\t */\n\t\tif (bktr->flags & METEOR_SINGLE) {\n\n\t\t\t/* stop dma */\n\t\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t\t/* disable risc, leave fifo running */\n\t\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\t\twakeup(BKTR_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * If the user requested to be notified via signal,\n\t\t * let them know the frame is complete.\n\t\t */\n\n\t\tif (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))\n\t\t\tpsignal( bktr->proc,\n\t\t\t\t bktr->signal&(~METEOR_SIG_MODE_MASK) );\n\n\t\t/*\n\t\t * Reset the want flags if in continuous or\n\t\t * synchronous capture mode.\n\t\t */\n/*\n* XXX NOTE (Luigi):\n* currently we only support 3 capture modes: odd only, even only,\n* odd+even interlaced (odd field first). A fourth mode (non interlaced,\n* either even OR odd) could provide 60 (50 for PAL) pictures per\n* second, but it would require this routine to toggle the desired frame\n* each time, and one more different DMA program for the Bt848.\n* As a consequence, this fourth mode is currently unsupported.\n*/\n\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)",
            "#define I2C_BITS\t\t(BT848_INT_RACK | BT848_INT_I2CDONE)",
            "#define CAPTURE_OFF\t\t0",
            "#define ALL_INTS_DISABLED\t0",
            "#define FIFO_RISC_DISABLED\t0",
            "#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN",
            "#define STATUS_SUM",
            "#define VBI_SLEEP   ((caddr_t)bktr + 1)",
            "#define BKTR_SLEEP  ((caddr_t)bktr    )",
            "#define EVEN_F 0x02",
            "#define ODD_F  0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)\n#define I2C_BITS\t\t(BT848_INT_RACK | BT848_INT_I2CDONE)\n#define CAPTURE_OFF\t\t0\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN\n#define STATUS_SUM\n#define VBI_SLEEP   ((caddr_t)bktr + 1)\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n#define EVEN_F 0x02\n#define ODD_F  0x01\n\nstatic int \ncommon_bktr_intr( void *arg )\n{ \n\tbktr_ptr_t\t\tbktr;\n\tbt848_ptr_t\t\tbt848;\n\tu_long\t\t\tbktr_status;\n\tu_char\t\t\tdstatus;\n\tu_long                  field;\n\tu_long                  w_field;\n\tu_long                  req_field;\n\n\tbktr = (bktr_ptr_t) arg;\n\tbt848 = bktr->base;\n\n\t/*\n\t * check to see if any interrupts are unmasked on this device.  If\n\t * none are, then we likely got here by way of being on a PCI shared\n\t * interrupt dispatch list.\n\t */\n\tif (bt848->int_mask == ALL_INTS_DISABLED)\n\t  \treturn 0;\t/* bail out now, before we do something we\n\t\t\t\t   shouldn't */\n\n\tif (!(bktr->flags & METEOR_OPEN)) {\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\t\t/* return; ?? */\n\t}\n\n\t/* record and clear the INTerrupt status bits */\n\tbktr_status = bt848->int_stat;\n\tbt848->int_stat = bktr_status & ~I2C_BITS;\t/* don't touch i2c */\n\n\t/* record and clear the device status register */\n\tdstatus = bt848->dstatus;\n\tbt848->dstatus = 0x00;\n\n#if defined( STATUS_SUM )\n\t/* add any new device status or INTerrupt status bits */\n\tstatus_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));\n\tstatus_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);\n#endif /* STATUS_SUM */\n\t/* printf( \" STATUS %x %x %x \\n\",\n\t\tdstatus, bktr_status, bt848->risc_count );\n\t*/\n\n\n\t/* if risc was disabled re-start process again */\n\tif ( !(bktr_status & BT848_INT_RISC_EN) ||\n\t     ((bktr_status &(BT848_INT_FBUS   |\n\t\t\t      BT848_INT_FTRGT  |\n\t\t\t      BT848_INT_FDSR   |\n\t\t\t      BT848_INT_PPERR  |\n\t\t\t      BT848_INT_RIPERR |\n\t\t\t      BT848_INT_PABORT |\n\t\t\t      BT848_INT_OCERR  |\n\t\t\t      BT848_INT_SCERR) ) != 0) ||\n\t     ((bt848->tdec == 0) && (bktr_status & TDEC_BITS)) ) {\n\n\t\tu_short\ttdec_save = bt848->tdec;\n\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t/*  Reset temporal decimation ctr  */\n\t\tbt848->tdec = 0;\n\t\tbt848->tdec = tdec_save;\n\t\t\n\t\t/*  Reset to no-fields captured state  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\n\t\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n\t\t\t\t  BT848_INT_RISCI      |\n\t\t\t\t  BT848_INT_VSYNC      |\n\t\t\t\t  BT848_INT_FMTCHG;\n\n\t\tbt848->cap_ctl = bktr->bktr_cap_ctl;\n\t\treturn 1;\n\t}\n\n\t/* If this is not a RISC program interrupt, return */\n\tif (!(bktr_status & BT848_INT_RISCI))\n\t\treturn 0;\n\n/**\n\tprintf( \"intr status %x %x %x\\n\",\n\t\tbktr_status, dstatus, bt848->risc_count );\n */\n\t\n\n\t/*\n\t * Disable future interrupts if a capture mode is not selected.\n\t * This can happen when we are in the process of closing or \n\t * changing capture modes, otherwise it shouldn't happen.\n\t */\n\tif (!(bktr->flags & METEOR_CAP_MASK))\n\t\tbt848->cap_ctl = CAPTURE_OFF;\n\n\t/*\n\t *  Register the completed field\n\t *    (For dual-field mode, require fields from the same frame)\n\t */\n\tfield = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;\n\tswitch ( bktr->flags & METEOR_WANT_MASK ) {\n\t\tcase METEOR_WANT_ODD  : w_field = ODD_F         ;  break;\n\t\tcase METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;\n\t\tdefault               : w_field = (ODD_F|EVEN_F);  break;\n\t}\n\tswitch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {\n\t\tcase METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;\n\t\tcase METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;\n\t\tdefault                      : req_field = (ODD_F|EVEN_F);  \n\t\t\t                       break;\n\t}\n\n\tif (( field == EVEN_F ) && ( w_field == EVEN_F ))\n\t\tbktr->flags &= ~METEOR_WANT_EVEN;\n\telse if (( field == ODD_F ) && ( req_field == ODD_F ) &&\n\t\t ( w_field == ODD_F ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == (ODD_F|EVEN_F) ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == ODD_F )) {\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\t\tbktr->flags |=  METEOR_WANT_EVEN;\n\t}\n\telse {\n\t\t/*  We're out of sync.  Start over.  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If we have a complete frame.\n\t */\n\tif (!(bktr->flags & METEOR_WANT_MASK)) {\n\t\tbktr->frames_captured++;\n\t\t/*\n\t\t * post the completion time. \n\t\t */\n\t\tif (bktr->flags & METEOR_WANT_TS) {\n\t\t\tstruct timeval *ts;\n\t\t\t\n\t\t\tif ((u_int) bktr->alloc_pages * PAGE_SIZE\n\t\t\t   <= (bktr->frame_size + sizeof(struct timeval))) {\n\t\t\t\tts =(struct timeval *)bktr->bigbuf +\n\t\t\t\t  bktr->frame_size;\n\t\t\t\t/* doesn't work in synch mode except\n\t\t\t\t *  for first frame */\n\t\t\t\t/* XXX */\n\t\t\t\tmicrotime(ts);\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Process the VBI data if it is being captured\n\t\t */\n\t\tif (bktr->vbiflags & VBI_CAPTURE) {\n                \tvbidecode(bktr);\n                \twakeup(VBI_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * Wake up the user in single capture mode.\n\t\t */\n\t\tif (bktr->flags & METEOR_SINGLE) {\n\n\t\t\t/* stop dma */\n\t\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t\t/* disable risc, leave fifo running */\n\t\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\t\twakeup(BKTR_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * If the user requested to be notified via signal,\n\t\t * let them know the frame is complete.\n\t\t */\n\n\t\tif (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))\n\t\t\tpsignal( bktr->proc,\n\t\t\t\t bktr->signal&(~METEOR_SIG_MODE_MASK) );\n\n\t\t/*\n\t\t * Reset the want flags if in continuous or\n\t\t * synchronous capture mode.\n\t\t */\n/*\n* XXX NOTE (Luigi):\n* currently we only support 3 capture modes: odd only, even only,\n* odd+even interlaced (odd field first). A fourth mode (non interlaced,\n* either even OR odd) could provide 60 (50 for PAL) pictures per\n* second, but it would require this routine to toggle the desired frame\n* each time, and one more different DMA program for the Bt848.\n* As a consequence, this fourth mode is currently unsupported.\n*/\n\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic void\tbktr_intr(void *arg) { common_bktr_intr(arg); }"
  },
  {
    "function_name": "msp_autodetect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6794-6817",
    "snippet": "static void msp_autodetect( bktr_ptr_t bktr ) {\n\n  if (strncmp(\"3430G\", bktr->msp_version_string, 5) == 0){\n\n    /* For MSP3430G - countries with mono and DBX stereo */\n    msp_write(bktr, 0x10, 0x0030,0x2003);/* Enable Auto format detection */\n    msp_write(bktr, 0x10, 0x0020,0x0020);/* Standard Select Reg. = BTSC-Stereo*/\n    msp_write(bktr, 0x12, 0x000E,0x2403);/* darned if I know */\n    msp_write(bktr, 0x12, 0x0008,0x0320);/* Source select = (St or A) */\n\t\t\t\t\t /*   & Ch. Matrix = St */\n    msp_write(bktr, 0x12, 0x0000,0x7300);/* Set volume to 0db gain */\n\n  } else {\n\n    /* For MSP3410 / 3415 - countries with mono, FM stereo and NICAM */\n    msp_write(bktr, 0x12, 0x0000,0x7300);/* Set volume to 0db gain */\n    msp_write(bktr, 0x10, 0x0020,0x0001);/* Enable Auto format detection */\n    msp_write(bktr, 0x10, 0x0021,0x0001);/* Auto selection of NICAM/MONO mode */\n  }\n\n  /* uncomment the following line to enable the MSP34xx 1Khz Tone Generator */\n  /* turn your speaker volume down low before trying this */\n  /* msp_write(bktr, 0x12, 0x0014, 0x7f40); */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msp_write",
          "args": [
            "bktr",
            "0x10",
            "0x0021",
            "0x0001"
          ],
          "line": 6811
        },
        "resolved": true,
        "details": {
          "function_name": "msp_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5035-5051",
          "snippet": "static void msp_write( bktr_ptr_t bktr, unsigned char dev, unsigned int addr, unsigned int data){\n\tunsigned int msp_w_addr = MSP3400C_WADDR;\n\tunsigned char addr_l, addr_h, data_h, data_l ;\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdata_h = (data >>8) & 0xff;\n\tdata_l = data & 0xff;\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, msp_w_addr);\n\ti2c_write_byte(bktr, dev);\n\ti2c_write_byte(bktr, addr_h);\n\ti2c_write_byte(bktr, addr_l);\n\ti2c_write_byte(bktr, data_h);\n\ti2c_write_byte(bktr, data_l);\n\ti2c_stop(bktr);\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define MSP3400C_WADDR\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define MSP3400C_WADDR\t\t0x80\n\nstatic void msp_write( bktr_ptr_t bktr, unsigned char dev, unsigned int addr, unsigned int data){\n\tunsigned int msp_w_addr = MSP3400C_WADDR;\n\tunsigned char addr_l, addr_h, data_h, data_l ;\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdata_h = (data >>8) & 0xff;\n\tdata_l = data & 0xff;\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, msp_w_addr);\n\ti2c_write_byte(bktr, dev);\n\ti2c_write_byte(bktr, addr_h);\n\ti2c_write_byte(bktr, addr_l);\n\ti2c_write_byte(bktr, data_h);\n\ti2c_write_byte(bktr, data_l);\n\ti2c_stop(bktr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"3430G\"",
            "bktr->msp_version_string",
            "5"
          ],
          "line": 6796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic void msp_autodetect( bktr_ptr_t bktr ) {\n\n  if (strncmp(\"3430G\", bktr->msp_version_string, 5) == 0){\n\n    /* For MSP3430G - countries with mono and DBX stereo */\n    msp_write(bktr, 0x10, 0x0030,0x2003);/* Enable Auto format detection */\n    msp_write(bktr, 0x10, 0x0020,0x0020);/* Standard Select Reg. = BTSC-Stereo*/\n    msp_write(bktr, 0x12, 0x000E,0x2403);/* darned if I know */\n    msp_write(bktr, 0x12, 0x0008,0x0320);/* Source select = (St or A) */\n\t\t\t\t\t /*   & Ch. Matrix = St */\n    msp_write(bktr, 0x12, 0x0000,0x7300);/* Set volume to 0db gain */\n\n  } else {\n\n    /* For MSP3410 / 3415 - countries with mono, FM stereo and NICAM */\n    msp_write(bktr, 0x12, 0x0000,0x7300);/* Set volume to 0db gain */\n    msp_write(bktr, 0x10, 0x0020,0x0001);/* Enable Auto format detection */\n    msp_write(bktr, 0x10, 0x0021,0x0001);/* Auto selection of NICAM/MONO mode */\n  }\n\n  /* uncomment the following line to enable the MSP34xx 1Khz Tone Generator */\n  /* turn your speaker volume down low before trying this */\n  /* msp_write(bktr, 0x12, 0x0014, 0x7f40); */\n}"
  },
  {
    "function_name": "msp_read_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6781-6790",
    "snippet": "static void msp_read_id( bktr_ptr_t bktr ){\n    int rev1=0, rev2=0;\n    rev1 = msp_read(bktr, 0x12, 0x001e);\n    rev2 = msp_read(bktr, 0x12, 0x001f);\n\n    sprintf(bktr->msp_version_string, \"34%02d%c-%c%d\",\n      (rev2>>8)&0xff, (rev1&0xff)+'@', ((rev1>>8)&0xff)+'@', rev2&0x1f);\n\n    printf(\"Detected a MSP%s\\n\",bktr->msp_version_string); \n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Detected a MSP%s\\n\"",
            "bktr->msp_version_string"
          ],
          "line": 6789
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "bktr->msp_version_string",
            "\"34%02d%c-%c%d\"",
            "(rev2>>8)&0xff",
            "(rev1&0xff)+'@'",
            "((rev1>>8)&0xff)+'@'",
            "rev2&0x1f"
          ],
          "line": 6786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msp_read",
          "args": [
            "bktr",
            "0x12",
            "0x001f"
          ],
          "line": 6784
        },
        "resolved": true,
        "details": {
          "function_name": "msp_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5054-5074",
          "snippet": "static unsigned int msp_read(bktr_ptr_t bktr, unsigned char dev, unsigned int addr){\n\tunsigned int data;\n\tunsigned char addr_l, addr_h, data_1, data_2, dev_r ;\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdev_r = dev+1;\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr,MSP3400C_WADDR);\n\ti2c_write_byte(bktr,dev_r);\n\ti2c_write_byte(bktr,addr_h);\n\ti2c_write_byte(bktr,addr_l);\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr,MSP3400C_RADDR);\n\ti2c_read_byte(bktr,&data_1, 0);\n\ti2c_read_byte(bktr,&data_2, 1);\n\ti2c_stop(bktr);\n\tdata = (data_1<<8) | data_2;\n\treturn data;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define MSP3400C_RADDR\t\t0x81",
            "#define MSP3400C_WADDR\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define MSP3400C_RADDR\t\t0x81\n#define MSP3400C_WADDR\t\t0x80\n\nstatic unsigned int msp_read(bktr_ptr_t bktr, unsigned char dev, unsigned int addr){\n\tunsigned int data;\n\tunsigned char addr_l, addr_h, data_1, data_2, dev_r ;\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdev_r = dev+1;\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr,MSP3400C_WADDR);\n\ti2c_write_byte(bktr,dev_r);\n\ti2c_write_byte(bktr,addr_h);\n\ti2c_write_byte(bktr,addr_l);\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr,MSP3400C_RADDR);\n\ti2c_read_byte(bktr,&data_1, 0);\n\ti2c_read_byte(bktr,&data_2, 1);\n\ti2c_stop(bktr);\n\tdata = (data_1<<8) | data_2;\n\treturn data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic void msp_read_id( bktr_ptr_t bktr ){\n    int rev1=0, rev2=0;\n    rev1 = msp_read(bktr, 0x12, 0x001e);\n    rev2 = msp_read(bktr, 0x12, 0x001f);\n\n    sprintf(bktr->msp_version_string, \"34%02d%c-%c%d\",\n      (rev2>>8)&0xff, (rev1&0xff)+'@', ((rev1>>8)&0xff)+'@', rev2&0x1f);\n\n    printf(\"Detected a MSP%s\\n\",bktr->msp_version_string); \n}"
  },
  {
    "function_name": "bctv_gpio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6708-6736",
    "snippet": "static void\nbctv_gpio_write( bktr_ptr_t bktr, int port, int val )\n{\n        bt848_ptr_t bt848 = bktr->base;\n        u_long data, outbits;\n\n        port &= BCTV_GPIO_PORT_MASK;\n        switch (port) {\n        case 1:\n        case 3:\n                data = ((val << BCTV_GPIO_VAL_SHIFT) & BCTV_GPIO_VAL_MASK) |\n                       ((port << BCTV_GPIO_ADDR_SHIFT) & BCTV_GPIO_ADDR_MASK) |\n                       BCTV_GPIO_WE | BCTV_GPIO_OE;\n                outbits = BCTV_GPIO_OUT_WMASK;\n                break;\n        default:\n                return;\n        }\n        bt848->gpio_out_en = 0;\n        bt848->gpio_data = data;\n        bt848->gpio_out_en = outbits;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = data & ~BCTV_GPIO_WE;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = data;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = ~0;\n        bt848->gpio_out_en = 0;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BCTV_BITS       100",
      "#define BCTV_GPIO_OUT_WMASK     0x00ff00",
      "#define BCTV_GPIO_VAL_SHIFT     12",
      "#define BCTV_GPIO_ADDR_SHIFT    8",
      "#define BCTV_GPIO_PORT_MASK     3",
      "#define BCTV_GPIO_VAL_MASK      0x00f000",
      "#define BCTV_GPIO_OE            0x000800",
      "#define BCTV_GPIO_WE            0x000400",
      "#define BCTV_GPIO_ADDR_MASK     0x000300"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BCTV_BITS"
          ],
          "line": 6733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BCTV_BITS"
          ],
          "line": 6731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BCTV_BITS"
          ],
          "line": 6729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BCTV_BITS       100\n#define BCTV_GPIO_OUT_WMASK     0x00ff00\n#define BCTV_GPIO_VAL_SHIFT     12\n#define BCTV_GPIO_ADDR_SHIFT    8\n#define BCTV_GPIO_PORT_MASK     3\n#define BCTV_GPIO_VAL_MASK      0x00f000\n#define BCTV_GPIO_OE            0x000800\n#define BCTV_GPIO_WE            0x000400\n#define BCTV_GPIO_ADDR_MASK     0x000300\n\nstatic void\nbctv_gpio_write( bktr_ptr_t bktr, int port, int val )\n{\n        bt848_ptr_t bt848 = bktr->base;\n        u_long data, outbits;\n\n        port &= BCTV_GPIO_PORT_MASK;\n        switch (port) {\n        case 1:\n        case 3:\n                data = ((val << BCTV_GPIO_VAL_SHIFT) & BCTV_GPIO_VAL_MASK) |\n                       ((port << BCTV_GPIO_ADDR_SHIFT) & BCTV_GPIO_ADDR_MASK) |\n                       BCTV_GPIO_WE | BCTV_GPIO_OE;\n                outbits = BCTV_GPIO_OUT_WMASK;\n                break;\n        default:\n                return;\n        }\n        bt848->gpio_out_en = 0;\n        bt848->gpio_data = data;\n        bt848->gpio_out_en = outbits;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = data & ~BCTV_GPIO_WE;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = data;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = ~0;\n        bt848->gpio_out_en = 0;\n}"
  },
  {
    "function_name": "set_bctv_audio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6657-6690",
    "snippet": "static void\nset_bctv_audio( bktr_ptr_t bktr )\n{\n        int data;\n\n        switch (bktr->audio_mux_select) {\n        case 1:         /* external */\n        case 2:         /* internal */\n                bctv_gpio_write(bktr, BCTV_GPIO_REG1, 0);\n                break;\n        default:        /* tuner */\n                bctv_gpio_write(bktr, BCTV_GPIO_REG1, 1);\n                break;\n        }\n/*      switch (bktr->audio_sap_select) { */\n        switch (BCTV_AUDIO_BOTH) {\n        case BCTV_AUDIO_SUB:\n                data = BCTV_GR0_AUDIO_SUB;\n                break;\n        case BCTV_AUDIO_BOTH:\n                data = BCTV_GR0_AUDIO_BOTH;\n                break;\n        case BCTV_AUDIO_MAIN:\n        default:\n                data = BCTV_GR0_AUDIO_MAIN;\n                break;\n        }\n        if (bktr->audio_mute_state == TRUE)\n                data |= BCTV_GR0_AUDIO_MUTE;\n\n        bctv_gpio_write(bktr, BCTV_GPIO_REG0, data);\n\n        return;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BCTV_GR0_AUDIO_MUTE     4       /* audio mute */",
      "#define BCTV_GR0_AUDIO_BOTH     1       /* main(L) + sub(R) */",
      "#define BCTV_GR0_AUDIO_SUB      3       /* sub program */",
      "#define BCTV_GR0_AUDIO_MAIN     0       /* main program */",
      "#define BCTV_GPIO_REG1          3",
      "#define BCTV_GPIO_REG0          1",
      "#define BCTV_AUDIO_BOTH              0x30    /* main(L) + sub(R) program */",
      "#define BCTV_AUDIO_SUB               0x20    /* sub audio program */",
      "#define BCTV_AUDIO_MAIN              0x10    /* main audio program */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bctv_gpio_write",
          "args": [
            "bktr",
            "BCTV_GPIO_REG0",
            "data"
          ],
          "line": 6687
        },
        "resolved": true,
        "details": {
          "function_name": "bctv_gpio_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6708-6736",
          "snippet": "static void\nbctv_gpio_write( bktr_ptr_t bktr, int port, int val )\n{\n        bt848_ptr_t bt848 = bktr->base;\n        u_long data, outbits;\n\n        port &= BCTV_GPIO_PORT_MASK;\n        switch (port) {\n        case 1:\n        case 3:\n                data = ((val << BCTV_GPIO_VAL_SHIFT) & BCTV_GPIO_VAL_MASK) |\n                       ((port << BCTV_GPIO_ADDR_SHIFT) & BCTV_GPIO_ADDR_MASK) |\n                       BCTV_GPIO_WE | BCTV_GPIO_OE;\n                outbits = BCTV_GPIO_OUT_WMASK;\n                break;\n        default:\n                return;\n        }\n        bt848->gpio_out_en = 0;\n        bt848->gpio_data = data;\n        bt848->gpio_out_en = outbits;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = data & ~BCTV_GPIO_WE;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = data;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = ~0;\n        bt848->gpio_out_en = 0;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BCTV_BITS       100",
            "#define BCTV_GPIO_OUT_WMASK     0x00ff00",
            "#define BCTV_GPIO_VAL_SHIFT     12",
            "#define BCTV_GPIO_ADDR_SHIFT    8",
            "#define BCTV_GPIO_PORT_MASK     3",
            "#define BCTV_GPIO_VAL_MASK      0x00f000",
            "#define BCTV_GPIO_OE            0x000800",
            "#define BCTV_GPIO_WE            0x000400",
            "#define BCTV_GPIO_ADDR_MASK     0x000300"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BCTV_BITS       100\n#define BCTV_GPIO_OUT_WMASK     0x00ff00\n#define BCTV_GPIO_VAL_SHIFT     12\n#define BCTV_GPIO_ADDR_SHIFT    8\n#define BCTV_GPIO_PORT_MASK     3\n#define BCTV_GPIO_VAL_MASK      0x00f000\n#define BCTV_GPIO_OE            0x000800\n#define BCTV_GPIO_WE            0x000400\n#define BCTV_GPIO_ADDR_MASK     0x000300\n\nstatic void\nbctv_gpio_write( bktr_ptr_t bktr, int port, int val )\n{\n        bt848_ptr_t bt848 = bktr->base;\n        u_long data, outbits;\n\n        port &= BCTV_GPIO_PORT_MASK;\n        switch (port) {\n        case 1:\n        case 3:\n                data = ((val << BCTV_GPIO_VAL_SHIFT) & BCTV_GPIO_VAL_MASK) |\n                       ((port << BCTV_GPIO_ADDR_SHIFT) & BCTV_GPIO_ADDR_MASK) |\n                       BCTV_GPIO_WE | BCTV_GPIO_OE;\n                outbits = BCTV_GPIO_OUT_WMASK;\n                break;\n        default:\n                return;\n        }\n        bt848->gpio_out_en = 0;\n        bt848->gpio_data = data;\n        bt848->gpio_out_en = outbits;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = data & ~BCTV_GPIO_WE;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = data;\n        DELAY(BCTV_BITS);\n        bt848->gpio_data = ~0;\n        bt848->gpio_out_en = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BCTV_GR0_AUDIO_MUTE     4       /* audio mute */\n#define BCTV_GR0_AUDIO_BOTH     1       /* main(L) + sub(R) */\n#define BCTV_GR0_AUDIO_SUB      3       /* sub program */\n#define BCTV_GR0_AUDIO_MAIN     0       /* main program */\n#define BCTV_GPIO_REG1          3\n#define BCTV_GPIO_REG0          1\n#define BCTV_AUDIO_BOTH              0x30    /* main(L) + sub(R) program */\n#define BCTV_AUDIO_SUB               0x20    /* sub audio program */\n#define BCTV_AUDIO_MAIN              0x10    /* main audio program */\n\nstatic void\nset_bctv_audio( bktr_ptr_t bktr )\n{\n        int data;\n\n        switch (bktr->audio_mux_select) {\n        case 1:         /* external */\n        case 2:         /* internal */\n                bctv_gpio_write(bktr, BCTV_GPIO_REG1, 0);\n                break;\n        default:        /* tuner */\n                bctv_gpio_write(bktr, BCTV_GPIO_REG1, 1);\n                break;\n        }\n/*      switch (bktr->audio_sap_select) { */\n        switch (BCTV_AUDIO_BOTH) {\n        case BCTV_AUDIO_SUB:\n                data = BCTV_GR0_AUDIO_SUB;\n                break;\n        case BCTV_AUDIO_BOTH:\n                data = BCTV_GR0_AUDIO_BOTH;\n                break;\n        case BCTV_AUDIO_MAIN:\n        default:\n                data = BCTV_GR0_AUDIO_MAIN;\n                break;\n        }\n        if (bktr->audio_mute_state == TRUE)\n                data |= BCTV_GR0_AUDIO_MUTE;\n\n        bctv_gpio_write(bktr, BCTV_GPIO_REG0, data);\n\n        return;\n}"
  },
  {
    "function_name": "set_BTSC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6633-6637",
    "snippet": "static int\nset_BTSC( bktr_ptr_t bktr, int control )\n{\n\treturn( i2cWrite( bktr, TDA9850_WADDR, CON3ADDR, control ) );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define CON3ADDR\t\t0x06",
      "#define TDA9850_WADDR\t\t0xb6"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2cWrite",
          "args": [
            "bktr",
            "TDA9850_WADDR",
            "CON3ADDR",
            "control"
          ],
          "line": 6636
        },
        "resolved": true,
        "details": {
          "function_name": "i2cWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4850-4890",
          "snippet": "static int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CON3ADDR\t\t0x06\n#define TDA9850_WADDR\t\t0xb6\n\nstatic int\nset_BTSC( bktr_ptr_t bktr, int control )\n{\n\treturn( i2cWrite( bktr, TDA9850_WADDR, CON3ADDR, control ) );\n}"
  },
  {
    "function_name": "init_BTSC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6617-6627",
    "snippet": "static void \ninit_BTSC( bktr_ptr_t bktr )\n{\n    i2cWrite(bktr, TDA9850_WADDR, CON1ADDR, 0x08); /* noise threshold st */\n    i2cWrite(bktr, TDA9850_WADDR, CON2ADDR, 0x08); /* noise threshold sap */\n    i2cWrite(bktr, TDA9850_WADDR, CON3ADDR, 0x40); /* stereo mode */\n    i2cWrite(bktr, TDA9850_WADDR, CON4ADDR, 0x07); /* 0 dB input gain? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI1ADDR, 0x10); /* wideband alignment? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI2ADDR, 0x10); /* spectral alignment? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI3ADDR, 0x03);\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define ALI3ADDR\t\t0x0a",
      "#define ALI2ADDR\t\t0x09",
      "#define ALI1ADDR\t\t0x08",
      "#define CON4ADDR\t\t0x07",
      "#define CON3ADDR\t\t0x06",
      "#define CON2ADDR\t\t0x05",
      "#define CON1ADDR\t\t0x04",
      "#define TDA9850_WADDR\t\t0xb6"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2cWrite",
          "args": [
            "bktr",
            "TDA9850_WADDR",
            "ALI3ADDR",
            "0x03"
          ],
          "line": 6626
        },
        "resolved": true,
        "details": {
          "function_name": "i2cWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4850-4890",
          "snippet": "static int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALI3ADDR\t\t0x0a\n#define ALI2ADDR\t\t0x09\n#define ALI1ADDR\t\t0x08\n#define CON4ADDR\t\t0x07\n#define CON3ADDR\t\t0x06\n#define CON2ADDR\t\t0x05\n#define CON1ADDR\t\t0x04\n#define TDA9850_WADDR\t\t0xb6\n\nstatic void \ninit_BTSC( bktr_ptr_t bktr )\n{\n    i2cWrite(bktr, TDA9850_WADDR, CON1ADDR, 0x08); /* noise threshold st */\n    i2cWrite(bktr, TDA9850_WADDR, CON2ADDR, 0x08); /* noise threshold sap */\n    i2cWrite(bktr, TDA9850_WADDR, CON3ADDR, 0x40); /* stereo mode */\n    i2cWrite(bktr, TDA9850_WADDR, CON4ADDR, 0x07); /* 0 dB input gain? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI1ADDR, 0x10); /* wideband alignment? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI2ADDR, 0x10); /* spectral alignment? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI3ADDR, 0x03);\n}"
  },
  {
    "function_name": "temp_mute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6596-6610",
    "snippet": "static void\ntemp_mute( bktr_ptr_t bktr, int flag )\n{\n\tstatic int\tmuteState = FALSE;\n\n\tif ( flag == TRUE ) {\n\t\tmuteState = bktr->audio_mute_state;\n\t\tset_audio( bktr, AUDIO_MUTE );\t\t/* prevent 'click' */\n\t}\n\telse {\n\t\ttsleep( BKTR_SLEEP, PZERO, \"tuning\", hz/8 );\n\t\tif ( muteState == FALSE )\n\t\t\tset_audio( bktr, AUDIO_UNMUTE );\n\t}\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BKTR_SLEEP  ((caddr_t)bktr    )"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_audio",
          "args": [
            "bktr",
            "AUDIO_UNMUTE"
          ],
          "line": 6608
        },
        "resolved": true,
        "details": {
          "function_name": "set_audio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6494-6590",
          "snippet": "static int\nset_audio( bktr_ptr_t bktr, int cmd )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\ttemp;\n\tvolatile u_char\tidx;\n\n#if defined( AUDIOMUX_DISCOVER )\n\tif ( cmd >= 200 )\n\t\tcmd -= 200;\n\telse\n#endif /* AUDIOMUX_DISCOVER */\n\n\t/* check for existance of audio MUXes */\n\tif ( !bktr->card.audiomuxs[ 4 ] )\n\t\treturn( -1 );\n\n\tswitch (cmd) {\n\tcase AUDIO_TUNER:\n#ifdef BKTR_REVERSEMUTE\n\t\tbktr->audio_mux_select = 3;\n#else\n\t\tbktr->audio_mux_select = 0;\n#endif\n\n\t\tif (bktr->reverse_mute ) \n\t\t      bktr->audio_mux_select = 0;\n\t\telse\t\n\t\t    bktr->audio_mux_select = 3;\n\n\t\tbreak;\n\tcase AUDIO_EXTERN:\n\t\tbktr->audio_mux_select = 1;\n\t\tbreak;\n\tcase AUDIO_INTERN:\n\t\tbktr->audio_mux_select = 2;\n\t\tbreak;\n\tcase AUDIO_MUTE:\n\t\tbktr->audio_mute_state = TRUE;\t/* set mute */\n\t\tbreak;\n\tcase AUDIO_UNMUTE:\n\t\tbktr->audio_mute_state = FALSE;\t/* clear mute */\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bktr: audio cmd error %02x\\n\", cmd);\n\t\treturn( -1 );\n\t}\n\n\n\t/* Most cards have a simple audio multiplexer to select the\n\t * audio source. The I/O_GV card has a more advanced multiplexer\n\t * and requires special handling.\n\t */\n        if ( bktr->bt848_card == CARD_IO_GV ) {\n                set_bctv_audio( bktr );\n                return( 0 );\n\t}\n\n\t/* Proceed with the simpler audio multiplexer code for the majority\n\t * of Bt848 cards.\n\t */\n\n\tbt848 =\tbktr->base;\n\n\t/*\n\t * Leave the upper bits of the GPIO port alone in case they control\n\t * something like the dbx or teletext chips.  This doesn't guarantee\n\t * success, but follows the rule of least astonishment.\n\t */\n\n\tif ( bktr->audio_mute_state == TRUE ) {\n#ifdef BKTR_REVERSEMUTE\n\t\tidx = 0;\n#else\n\t\tidx = 3;\n#endif\n\n\t\tif (bktr->reverse_mute )\n\t\t  idx  = 3;\n\t\telse\t\n\t\t  idx  = 0;\n\n\t}\n\telse\n\t\tidx = bktr->audio_mux_select;\n\n\ttemp = bt848->gpio_data & ~bktr->card.gpio_mux_bits;\n\tbt848->gpio_data =\n#if defined( AUDIOMUX_DISCOVER )\n\t\tbt848->gpio_data = temp | (cmd & 0xff);\n\t\tprintf(\"cmd: %d audio mux %x temp %x \\n\", cmd,bktr->card.audiomuxs[ idx ], temp );\n#else\n\t\ttemp | bktr->card.audiomuxs[ idx ];\n#endif /* AUDIOMUX_DISCOVER */\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define CARD_IO_GV\t\t9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CARD_IO_GV\t\t9\n\nstatic int\nset_audio( bktr_ptr_t bktr, int cmd )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\ttemp;\n\tvolatile u_char\tidx;\n\n#if defined( AUDIOMUX_DISCOVER )\n\tif ( cmd >= 200 )\n\t\tcmd -= 200;\n\telse\n#endif /* AUDIOMUX_DISCOVER */\n\n\t/* check for existance of audio MUXes */\n\tif ( !bktr->card.audiomuxs[ 4 ] )\n\t\treturn( -1 );\n\n\tswitch (cmd) {\n\tcase AUDIO_TUNER:\n#ifdef BKTR_REVERSEMUTE\n\t\tbktr->audio_mux_select = 3;\n#else\n\t\tbktr->audio_mux_select = 0;\n#endif\n\n\t\tif (bktr->reverse_mute ) \n\t\t      bktr->audio_mux_select = 0;\n\t\telse\t\n\t\t    bktr->audio_mux_select = 3;\n\n\t\tbreak;\n\tcase AUDIO_EXTERN:\n\t\tbktr->audio_mux_select = 1;\n\t\tbreak;\n\tcase AUDIO_INTERN:\n\t\tbktr->audio_mux_select = 2;\n\t\tbreak;\n\tcase AUDIO_MUTE:\n\t\tbktr->audio_mute_state = TRUE;\t/* set mute */\n\t\tbreak;\n\tcase AUDIO_UNMUTE:\n\t\tbktr->audio_mute_state = FALSE;\t/* clear mute */\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bktr: audio cmd error %02x\\n\", cmd);\n\t\treturn( -1 );\n\t}\n\n\n\t/* Most cards have a simple audio multiplexer to select the\n\t * audio source. The I/O_GV card has a more advanced multiplexer\n\t * and requires special handling.\n\t */\n        if ( bktr->bt848_card == CARD_IO_GV ) {\n                set_bctv_audio( bktr );\n                return( 0 );\n\t}\n\n\t/* Proceed with the simpler audio multiplexer code for the majority\n\t * of Bt848 cards.\n\t */\n\n\tbt848 =\tbktr->base;\n\n\t/*\n\t * Leave the upper bits of the GPIO port alone in case they control\n\t * something like the dbx or teletext chips.  This doesn't guarantee\n\t * success, but follows the rule of least astonishment.\n\t */\n\n\tif ( bktr->audio_mute_state == TRUE ) {\n#ifdef BKTR_REVERSEMUTE\n\t\tidx = 0;\n#else\n\t\tidx = 3;\n#endif\n\n\t\tif (bktr->reverse_mute )\n\t\t  idx  = 3;\n\t\telse\t\n\t\t  idx  = 0;\n\n\t}\n\telse\n\t\tidx = bktr->audio_mux_select;\n\n\ttemp = bt848->gpio_data & ~bktr->card.gpio_mux_bits;\n\tbt848->gpio_data =\n#if defined( AUDIOMUX_DISCOVER )\n\t\tbt848->gpio_data = temp | (cmd & 0xff);\n\t\tprintf(\"cmd: %d audio mux %x temp %x \\n\", cmd,bktr->card.audiomuxs[ idx ], temp );\n#else\n\t\ttemp | bktr->card.audiomuxs[ idx ];\n#endif /* AUDIOMUX_DISCOVER */\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "BKTR_SLEEP",
            "PZERO",
            "\"tuning\"",
            "hz/8"
          ],
          "line": 6606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n\nstatic void\ntemp_mute( bktr_ptr_t bktr, int flag )\n{\n\tstatic int\tmuteState = FALSE;\n\n\tif ( flag == TRUE ) {\n\t\tmuteState = bktr->audio_mute_state;\n\t\tset_audio( bktr, AUDIO_MUTE );\t\t/* prevent 'click' */\n\t}\n\telse {\n\t\ttsleep( BKTR_SLEEP, PZERO, \"tuning\", hz/8 );\n\t\tif ( muteState == FALSE )\n\t\t\tset_audio( bktr, AUDIO_UNMUTE );\n\t}\n}"
  },
  {
    "function_name": "set_audio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6494-6590",
    "snippet": "static int\nset_audio( bktr_ptr_t bktr, int cmd )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\ttemp;\n\tvolatile u_char\tidx;\n\n#if defined( AUDIOMUX_DISCOVER )\n\tif ( cmd >= 200 )\n\t\tcmd -= 200;\n\telse\n#endif /* AUDIOMUX_DISCOVER */\n\n\t/* check for existance of audio MUXes */\n\tif ( !bktr->card.audiomuxs[ 4 ] )\n\t\treturn( -1 );\n\n\tswitch (cmd) {\n\tcase AUDIO_TUNER:\n#ifdef BKTR_REVERSEMUTE\n\t\tbktr->audio_mux_select = 3;\n#else\n\t\tbktr->audio_mux_select = 0;\n#endif\n\n\t\tif (bktr->reverse_mute ) \n\t\t      bktr->audio_mux_select = 0;\n\t\telse\t\n\t\t    bktr->audio_mux_select = 3;\n\n\t\tbreak;\n\tcase AUDIO_EXTERN:\n\t\tbktr->audio_mux_select = 1;\n\t\tbreak;\n\tcase AUDIO_INTERN:\n\t\tbktr->audio_mux_select = 2;\n\t\tbreak;\n\tcase AUDIO_MUTE:\n\t\tbktr->audio_mute_state = TRUE;\t/* set mute */\n\t\tbreak;\n\tcase AUDIO_UNMUTE:\n\t\tbktr->audio_mute_state = FALSE;\t/* clear mute */\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bktr: audio cmd error %02x\\n\", cmd);\n\t\treturn( -1 );\n\t}\n\n\n\t/* Most cards have a simple audio multiplexer to select the\n\t * audio source. The I/O_GV card has a more advanced multiplexer\n\t * and requires special handling.\n\t */\n        if ( bktr->bt848_card == CARD_IO_GV ) {\n                set_bctv_audio( bktr );\n                return( 0 );\n\t}\n\n\t/* Proceed with the simpler audio multiplexer code for the majority\n\t * of Bt848 cards.\n\t */\n\n\tbt848 =\tbktr->base;\n\n\t/*\n\t * Leave the upper bits of the GPIO port alone in case they control\n\t * something like the dbx or teletext chips.  This doesn't guarantee\n\t * success, but follows the rule of least astonishment.\n\t */\n\n\tif ( bktr->audio_mute_state == TRUE ) {\n#ifdef BKTR_REVERSEMUTE\n\t\tidx = 0;\n#else\n\t\tidx = 3;\n#endif\n\n\t\tif (bktr->reverse_mute )\n\t\t  idx  = 3;\n\t\telse\t\n\t\t  idx  = 0;\n\n\t}\n\telse\n\t\tidx = bktr->audio_mux_select;\n\n\ttemp = bt848->gpio_data & ~bktr->card.gpio_mux_bits;\n\tbt848->gpio_data =\n#if defined( AUDIOMUX_DISCOVER )\n\t\tbt848->gpio_data = temp | (cmd & 0xff);\n\t\tprintf(\"cmd: %d audio mux %x temp %x \\n\", cmd,bktr->card.audiomuxs[ idx ], temp );\n#else\n\t\ttemp | bktr->card.audiomuxs[ idx ];\n#endif /* AUDIOMUX_DISCOVER */\n\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define CARD_IO_GV\t\t9"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"cmd: %d audio mux %x temp %x \\n\"",
            "cmd",
            "bktr->card.audiomuxs[ idx ]",
            "temp"
          ],
          "line": 6584
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bctv_audio",
          "args": [
            "bktr"
          ],
          "line": 6548
        },
        "resolved": true,
        "details": {
          "function_name": "set_bctv_audio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6657-6690",
          "snippet": "static void\nset_bctv_audio( bktr_ptr_t bktr )\n{\n        int data;\n\n        switch (bktr->audio_mux_select) {\n        case 1:         /* external */\n        case 2:         /* internal */\n                bctv_gpio_write(bktr, BCTV_GPIO_REG1, 0);\n                break;\n        default:        /* tuner */\n                bctv_gpio_write(bktr, BCTV_GPIO_REG1, 1);\n                break;\n        }\n/*      switch (bktr->audio_sap_select) { */\n        switch (BCTV_AUDIO_BOTH) {\n        case BCTV_AUDIO_SUB:\n                data = BCTV_GR0_AUDIO_SUB;\n                break;\n        case BCTV_AUDIO_BOTH:\n                data = BCTV_GR0_AUDIO_BOTH;\n                break;\n        case BCTV_AUDIO_MAIN:\n        default:\n                data = BCTV_GR0_AUDIO_MAIN;\n                break;\n        }\n        if (bktr->audio_mute_state == TRUE)\n                data |= BCTV_GR0_AUDIO_MUTE;\n\n        bctv_gpio_write(bktr, BCTV_GPIO_REG0, data);\n\n        return;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BCTV_GR0_AUDIO_MUTE     4       /* audio mute */",
            "#define BCTV_GR0_AUDIO_BOTH     1       /* main(L) + sub(R) */",
            "#define BCTV_GR0_AUDIO_SUB      3       /* sub program */",
            "#define BCTV_GR0_AUDIO_MAIN     0       /* main program */",
            "#define BCTV_GPIO_REG1          3",
            "#define BCTV_GPIO_REG0          1",
            "#define BCTV_AUDIO_BOTH              0x30    /* main(L) + sub(R) program */",
            "#define BCTV_AUDIO_SUB               0x20    /* sub audio program */",
            "#define BCTV_AUDIO_MAIN              0x10    /* main audio program */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BCTV_GR0_AUDIO_MUTE     4       /* audio mute */\n#define BCTV_GR0_AUDIO_BOTH     1       /* main(L) + sub(R) */\n#define BCTV_GR0_AUDIO_SUB      3       /* sub program */\n#define BCTV_GR0_AUDIO_MAIN     0       /* main program */\n#define BCTV_GPIO_REG1          3\n#define BCTV_GPIO_REG0          1\n#define BCTV_AUDIO_BOTH              0x30    /* main(L) + sub(R) program */\n#define BCTV_AUDIO_SUB               0x20    /* sub audio program */\n#define BCTV_AUDIO_MAIN              0x10    /* main audio program */\n\nstatic void\nset_bctv_audio( bktr_ptr_t bktr )\n{\n        int data;\n\n        switch (bktr->audio_mux_select) {\n        case 1:         /* external */\n        case 2:         /* internal */\n                bctv_gpio_write(bktr, BCTV_GPIO_REG1, 0);\n                break;\n        default:        /* tuner */\n                bctv_gpio_write(bktr, BCTV_GPIO_REG1, 1);\n                break;\n        }\n/*      switch (bktr->audio_sap_select) { */\n        switch (BCTV_AUDIO_BOTH) {\n        case BCTV_AUDIO_SUB:\n                data = BCTV_GR0_AUDIO_SUB;\n                break;\n        case BCTV_AUDIO_BOTH:\n                data = BCTV_GR0_AUDIO_BOTH;\n                break;\n        case BCTV_AUDIO_MAIN:\n        default:\n                data = BCTV_GR0_AUDIO_MAIN;\n                break;\n        }\n        if (bktr->audio_mute_state == TRUE)\n                data |= BCTV_GR0_AUDIO_MUTE;\n\n        bctv_gpio_write(bktr, BCTV_GPIO_REG0, data);\n\n        return;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CARD_IO_GV\t\t9\n\nstatic int\nset_audio( bktr_ptr_t bktr, int cmd )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\ttemp;\n\tvolatile u_char\tidx;\n\n#if defined( AUDIOMUX_DISCOVER )\n\tif ( cmd >= 200 )\n\t\tcmd -= 200;\n\telse\n#endif /* AUDIOMUX_DISCOVER */\n\n\t/* check for existance of audio MUXes */\n\tif ( !bktr->card.audiomuxs[ 4 ] )\n\t\treturn( -1 );\n\n\tswitch (cmd) {\n\tcase AUDIO_TUNER:\n#ifdef BKTR_REVERSEMUTE\n\t\tbktr->audio_mux_select = 3;\n#else\n\t\tbktr->audio_mux_select = 0;\n#endif\n\n\t\tif (bktr->reverse_mute ) \n\t\t      bktr->audio_mux_select = 0;\n\t\telse\t\n\t\t    bktr->audio_mux_select = 3;\n\n\t\tbreak;\n\tcase AUDIO_EXTERN:\n\t\tbktr->audio_mux_select = 1;\n\t\tbreak;\n\tcase AUDIO_INTERN:\n\t\tbktr->audio_mux_select = 2;\n\t\tbreak;\n\tcase AUDIO_MUTE:\n\t\tbktr->audio_mute_state = TRUE;\t/* set mute */\n\t\tbreak;\n\tcase AUDIO_UNMUTE:\n\t\tbktr->audio_mute_state = FALSE;\t/* clear mute */\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bktr: audio cmd error %02x\\n\", cmd);\n\t\treturn( -1 );\n\t}\n\n\n\t/* Most cards have a simple audio multiplexer to select the\n\t * audio source. The I/O_GV card has a more advanced multiplexer\n\t * and requires special handling.\n\t */\n        if ( bktr->bt848_card == CARD_IO_GV ) {\n                set_bctv_audio( bktr );\n                return( 0 );\n\t}\n\n\t/* Proceed with the simpler audio multiplexer code for the majority\n\t * of Bt848 cards.\n\t */\n\n\tbt848 =\tbktr->base;\n\n\t/*\n\t * Leave the upper bits of the GPIO port alone in case they control\n\t * something like the dbx or teletext chips.  This doesn't guarantee\n\t * success, but follows the rule of least astonishment.\n\t */\n\n\tif ( bktr->audio_mute_state == TRUE ) {\n#ifdef BKTR_REVERSEMUTE\n\t\tidx = 0;\n#else\n\t\tidx = 3;\n#endif\n\n\t\tif (bktr->reverse_mute )\n\t\t  idx  = 3;\n\t\telse\t\n\t\t  idx  = 0;\n\n\t}\n\telse\n\t\tidx = bktr->audio_mux_select;\n\n\ttemp = bt848->gpio_data & ~bktr->card.gpio_mux_bits;\n\tbt848->gpio_data =\n#if defined( AUDIOMUX_DISCOVER )\n\t\tbt848->gpio_data = temp | (cmd & 0xff);\n\t\tprintf(\"cmd: %d audio mux %x temp %x \\n\", cmd,bktr->card.audiomuxs[ idx ], temp );\n#else\n\t\ttemp | bktr->card.audiomuxs[ idx ];\n#endif /* AUDIOMUX_DISCOVER */\n\n\treturn( 0 );\n}"
  },
  {
    "function_name": "tuner_getchnlset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6472-6484",
    "snippet": "static int\ntuner_getchnlset(struct bktr_chnlset *chnlset)\n{\n       if (( chnlset->index < CHNLSET_MIN ) ||\n               ( chnlset->index > CHNLSET_MAX ))\n                       return( EINVAL );\n\n       memcpy(&chnlset->name, &freqTable[chnlset->index].name,\n               BT848_MAX_CHNLSET_NAME_LEN);\n\n       chnlset->max_channel=freqTable[chnlset->index].ptr[0];\n       return( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&chnlset->name",
            "&freqTable[chnlset->index].name",
            "BT848_MAX_CHNLSET_NAME_LEN"
          ],
          "line": 6479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_getchnlset(struct bktr_chnlset *chnlset)\n{\n       if (( chnlset->index < CHNLSET_MIN ) ||\n               ( chnlset->index > CHNLSET_MAX ))\n                       return( EINVAL );\n\n       memcpy(&chnlset->name, &freqTable[chnlset->index].name,\n               BT848_MAX_CHNLSET_NAME_LEN);\n\n       chnlset->max_channel=freqTable[chnlset->index].ptr[0];\n       return( 0 );\n}"
  },
  {
    "function_name": "tv_channel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6452-6467",
    "snippet": "static int\ntv_channel( bktr_ptr_t bktr, int channel )\n{\n\tint frequency;\n\n\t/* calculate the frequency according to tuner type */\n\tif ( (frequency = frequency_lookup( bktr, channel )) < 0 )\n\t\treturn( -1 );\n\n\t/* set the new frequency */\n\tif ( tv_freq( bktr, frequency ) < 0 )\n\t\treturn( -1 );\n\n\t/* OK to update records */\n\treturn( (bktr->tuner.channel = channel) );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tv_freq",
          "args": [
            "bktr",
            "frequency"
          ],
          "line": 6462
        },
        "resolved": true,
        "details": {
          "function_name": "tv_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6295-6376",
          "snippet": "static int\ntv_freq( bktr_ptr_t bktr, int frequency )\n{\n\tconst struct TUNER*\ttuner;\n\tu_char\t\t\taddr;\n\tu_char\t\t\tcontrol;\n\tu_char\t\t\tband;\n\tint\t\t\tN;\n\n\ttuner = bktr->card.tuner;\n\tif ( tuner == NULL )\n\t\treturn( -1 );\n\n\t/*\n\t * select the band based on frequency\n\t * XXX FIXME: get the cross-over points from the tuner struct\n\t */\n\tif ( frequency < (160 * FREQFACTOR) )\n\t  N = 0;\n\telse if ( frequency < (454 * FREQFACTOR) )\n\t  N = 1;\n\telse\n\t  N = 2;\n\n\tif(frequency > RADIO_OFFSET) {\n\t  N=3;\n\t  frequency -= RADIO_OFFSET;\n\t}\n  \n\t/* set the address of the PLL */\n\taddr    = bktr->card.tuner_pllAddr;\n\tcontrol = tuner->pllControl[ N ];\n\tband    = tuner->bandAddrs[ N ];\n\tif(!(band && control))\t\t\t/* Don't try to set un-\t*/\n\t  return(-1);\t\t\t\t/* supported modes.\t*/\n\n         if(N==3) \n\t  band |= bktr->tuner.radio_mode;\n\n\t/*\n\t * N = 16 * { fRF(pc) + fIF(pc) }\n\t * where:\n\t *  pc is picture carrier, fRF & fIF are in mHz\n\t *\n\t * frequency was passed in as mHz * 16\n\t */\n#if defined( TEST_TUNER_AFC )\n\tif ( bktr->tuner.afc )\n\t\tfrequency -= 4;\n#endif\n\n        if(bktr->bt848_tuner == ALPS_TSCH5 && N == 3)   /* for FM frequency */\n                N = frequency;\n        else\n                N = frequency + TBL_IF;\n\n\tif ( frequency > bktr->tuner.frequency ) {\n\t\ti2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t\ti2cWrite( bktr, addr, control, band );\n\t}\n\telse {\n\t\ti2cWrite( bktr, addr, control, band );\n\t\ti2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t}\n\n#if defined( TUNER_AFC )\n\tif ( bktr->tuner.afc == TRUE ) {\n\t\tif ( (N = do_afc( bktr, addr, N )) < 0 ) {\n\t\t    /* AFC failed, restore requested frequency */\n\t\t    N = frequency + TBL_IF;\n\t\t    i2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t\t}\n\t\telse\n\t\t    frequency = N - TBL_IF;\n\t}\n#endif /* TUNER_AFC */\n\n\t/* update frequency */\n\tbktr->tuner.frequency = frequency;\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define TBL_IF\tfreqTable[ bktr->tuner.chnlset ].ptr[ 1 ]",
            "#define FREQFACTOR\t\t16",
            "#define\tALPS_TSCH5\t\t12",
            "#define RADIO_OFFSET\t\t20000",
            "#define TUNER_AFC"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TBL_IF\tfreqTable[ bktr->tuner.chnlset ].ptr[ 1 ]\n#define FREQFACTOR\t\t16\n#define\tALPS_TSCH5\t\t12\n#define RADIO_OFFSET\t\t20000\n#define TUNER_AFC\n\nstatic int\ntv_freq( bktr_ptr_t bktr, int frequency )\n{\n\tconst struct TUNER*\ttuner;\n\tu_char\t\t\taddr;\n\tu_char\t\t\tcontrol;\n\tu_char\t\t\tband;\n\tint\t\t\tN;\n\n\ttuner = bktr->card.tuner;\n\tif ( tuner == NULL )\n\t\treturn( -1 );\n\n\t/*\n\t * select the band based on frequency\n\t * XXX FIXME: get the cross-over points from the tuner struct\n\t */\n\tif ( frequency < (160 * FREQFACTOR) )\n\t  N = 0;\n\telse if ( frequency < (454 * FREQFACTOR) )\n\t  N = 1;\n\telse\n\t  N = 2;\n\n\tif(frequency > RADIO_OFFSET) {\n\t  N=3;\n\t  frequency -= RADIO_OFFSET;\n\t}\n  \n\t/* set the address of the PLL */\n\taddr    = bktr->card.tuner_pllAddr;\n\tcontrol = tuner->pllControl[ N ];\n\tband    = tuner->bandAddrs[ N ];\n\tif(!(band && control))\t\t\t/* Don't try to set un-\t*/\n\t  return(-1);\t\t\t\t/* supported modes.\t*/\n\n         if(N==3) \n\t  band |= bktr->tuner.radio_mode;\n\n\t/*\n\t * N = 16 * { fRF(pc) + fIF(pc) }\n\t * where:\n\t *  pc is picture carrier, fRF & fIF are in mHz\n\t *\n\t * frequency was passed in as mHz * 16\n\t */\n#if defined( TEST_TUNER_AFC )\n\tif ( bktr->tuner.afc )\n\t\tfrequency -= 4;\n#endif\n\n        if(bktr->bt848_tuner == ALPS_TSCH5 && N == 3)   /* for FM frequency */\n                N = frequency;\n        else\n                N = frequency + TBL_IF;\n\n\tif ( frequency > bktr->tuner.frequency ) {\n\t\ti2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t\ti2cWrite( bktr, addr, control, band );\n\t}\n\telse {\n\t\ti2cWrite( bktr, addr, control, band );\n\t\ti2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t}\n\n#if defined( TUNER_AFC )\n\tif ( bktr->tuner.afc == TRUE ) {\n\t\tif ( (N = do_afc( bktr, addr, N )) < 0 ) {\n\t\t    /* AFC failed, restore requested frequency */\n\t\t    N = frequency + TBL_IF;\n\t\t    i2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t\t}\n\t\telse\n\t\t    frequency = N - TBL_IF;\n\t}\n#endif /* TUNER_AFC */\n\n\t/* update frequency */\n\tbktr->tuner.frequency = frequency;\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "frequency_lookup",
          "args": [
            "bktr",
            "channel"
          ],
          "line": 6458
        },
        "resolved": true,
        "details": {
          "function_name": "frequency_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6265-6285",
          "snippet": "static int\nfrequency_lookup( bktr_ptr_t bktr, int channel )\n{\n\tint\tx;\n\n\t/* check for \"> MAX channel\" */\n\tx = 0;\n\tif ( channel > TBL_CHNL )\n\t\treturn( -1 );\n\n\t/* search the table for data */\n\tfor ( x = 3; TBL_CHNL; x += 3 ) {\n\t\tif ( channel >= TBL_CHNL ) {\n\t\t\treturn( TBL_BASE_FREQ +\n\t\t\t\t ((channel - TBL_CHNL) * TBL_OFFSET) );\n\t\t}\n\t}\n\n\t/* not found, must be below the MIN channel */\n\treturn( -1 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define TBL_OFFSET\tfreqTable[ bktr->tuner.chnlset ].ptr[ x + 2 ]",
            "#define TBL_BASE_FREQ\tfreqTable[ bktr->tuner.chnlset ].ptr[ x + 1 ]",
            "#define TBL_CHNL\tfreqTable[ bktr->tuner.chnlset ].ptr[ x ]"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TBL_OFFSET\tfreqTable[ bktr->tuner.chnlset ].ptr[ x + 2 ]\n#define TBL_BASE_FREQ\tfreqTable[ bktr->tuner.chnlset ].ptr[ x + 1 ]\n#define TBL_CHNL\tfreqTable[ bktr->tuner.chnlset ].ptr[ x ]\n\nstatic int\nfrequency_lookup( bktr_ptr_t bktr, int channel )\n{\n\tint\tx;\n\n\t/* check for \"> MAX channel\" */\n\tx = 0;\n\tif ( channel > TBL_CHNL )\n\t\treturn( -1 );\n\n\t/* search the table for data */\n\tfor ( x = 3; TBL_CHNL; x += 3 ) {\n\t\tif ( channel >= TBL_CHNL ) {\n\t\t\treturn( TBL_BASE_FREQ +\n\t\t\t\t ((channel - TBL_CHNL) * TBL_OFFSET) );\n\t\t}\n\t}\n\n\t/* not found, must be below the MIN channel */\n\treturn( -1 );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntv_channel( bktr_ptr_t bktr, int channel )\n{\n\tint frequency;\n\n\t/* calculate the frequency according to tuner type */\n\tif ( (frequency = frequency_lookup( bktr, channel )) < 0 )\n\t\treturn( -1 );\n\n\t/* set the new frequency */\n\tif ( tv_freq( bktr, frequency ) < 0 )\n\t\treturn( -1 );\n\n\t/* OK to update records */\n\treturn( (bktr->tuner.channel = channel) );\n}"
  },
  {
    "function_name": "do_afc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6382-6444",
    "snippet": "static int\ndo_afc( bktr_ptr_t bktr, int addr, int frequency )\n{\n\tint step;\n\tint status;\n\tint origFrequency;\n\n\torigFrequency = frequency;\n\n\t/* wait for first setting to take effect */\n\ttsleep( BKTR_SLEEP, PZERO, \"tuning\", hz/8 );\n\n\tif ( (status = i2cRead( bktr, addr + 1 )) < 0 )\n\t\treturn( -1 );\n\n#if defined( TEST_TUNER_AFC )\n printf( \"\\nOriginal freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\tfor ( step = 0; step < AFC_MAX_STEP; ++step ) {\n\t\tif ( (status = i2cRead( bktr, addr + 1 )) < 0 )\n\t\t\tgoto fubar;\n\t\tif ( !(status & 0x40) ) {\n#if defined( TEST_TUNER_AFC )\n printf( \"no lock!\\n\" );\n#endif\n\t\t\tgoto fubar;\n\t\t}\n\n\t\tswitch( status & AFC_BITS ) {\n\t\tcase AFC_FREQ_CENTERED:\n#if defined( TEST_TUNER_AFC )\n printf( \"Centered, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\treturn( frequency );\n\n\t\tcase AFC_FREQ_MINUS_125:\n\t\tcase AFC_FREQ_MINUS_62:\n#if defined( TEST_TUNER_AFC )\n printf( \"Low, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\t--frequency;\n\t\t\tbreak;\n\n\t\tcase AFC_FREQ_PLUS_62:\n\t\tcase AFC_FREQ_PLUS_125:\n#if defined( TEST_TUNER_AFC )\n printf( \"Hi, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\t++frequency;\n\t\t\tbreak;\n\t\t}\n\n\t\ti2cWrite( bktr, addr,\n\t\t\t  (frequency>>8) & 0x7f, frequency & 0xff );\n\t\tDELAY( AFC_DELAY );\n\t}\n\n fubar:\n\ti2cWrite( bktr, addr,\n\t\t  (origFrequency>>8) & 0x7f, origFrequency & 0xff );\n\n\treturn( -1 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define AFC_MAX_STEP\t\t(5 * FREQFACTOR) /* no more than 5 MHz */",
      "#define AFC_FREQ_PLUS_125\t0x04",
      "#define AFC_FREQ_PLUS_62\t0x03",
      "#define AFC_FREQ_CENTERED\t0x02",
      "#define AFC_FREQ_MINUS_62\t0x01",
      "#define AFC_FREQ_MINUS_125\t0x00",
      "#define AFC_BITS\t\t0x07",
      "#define AFC_DELAY\t\t10000\t/* 10 millisend delay */",
      "#define BKTR_SLEEP  ((caddr_t)bktr    )"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2cWrite",
          "args": [
            "bktr",
            "addr",
            "(origFrequency>>8) & 0x7f",
            "origFrequency & 0xff"
          ],
          "line": 6440
        },
        "resolved": true,
        "details": {
          "function_name": "i2cWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4850-4890",
          "snippet": "static int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "AFC_DELAY"
          ],
          "line": 6436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Hi, freq: %d, status: 0x%02x\\n\"",
            "frequency",
            "status"
          ],
          "line": 6428
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2cRead",
          "args": [
            "bktr",
            "addr + 1"
          ],
          "line": 6401
        },
        "resolved": true,
        "details": {
          "function_name": "i2cRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4896-4930",
          "snippet": "static int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "BKTR_SLEEP",
            "PZERO",
            "\"tuning\"",
            "hz/8"
          ],
          "line": 6392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define AFC_MAX_STEP\t\t(5 * FREQFACTOR) /* no more than 5 MHz */\n#define AFC_FREQ_PLUS_125\t0x04\n#define AFC_FREQ_PLUS_62\t0x03\n#define AFC_FREQ_CENTERED\t0x02\n#define AFC_FREQ_MINUS_62\t0x01\n#define AFC_FREQ_MINUS_125\t0x00\n#define AFC_BITS\t\t0x07\n#define AFC_DELAY\t\t10000\t/* 10 millisend delay */\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n\nstatic int\ndo_afc( bktr_ptr_t bktr, int addr, int frequency )\n{\n\tint step;\n\tint status;\n\tint origFrequency;\n\n\torigFrequency = frequency;\n\n\t/* wait for first setting to take effect */\n\ttsleep( BKTR_SLEEP, PZERO, \"tuning\", hz/8 );\n\n\tif ( (status = i2cRead( bktr, addr + 1 )) < 0 )\n\t\treturn( -1 );\n\n#if defined( TEST_TUNER_AFC )\n printf( \"\\nOriginal freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\tfor ( step = 0; step < AFC_MAX_STEP; ++step ) {\n\t\tif ( (status = i2cRead( bktr, addr + 1 )) < 0 )\n\t\t\tgoto fubar;\n\t\tif ( !(status & 0x40) ) {\n#if defined( TEST_TUNER_AFC )\n printf( \"no lock!\\n\" );\n#endif\n\t\t\tgoto fubar;\n\t\t}\n\n\t\tswitch( status & AFC_BITS ) {\n\t\tcase AFC_FREQ_CENTERED:\n#if defined( TEST_TUNER_AFC )\n printf( \"Centered, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\treturn( frequency );\n\n\t\tcase AFC_FREQ_MINUS_125:\n\t\tcase AFC_FREQ_MINUS_62:\n#if defined( TEST_TUNER_AFC )\n printf( \"Low, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\t--frequency;\n\t\t\tbreak;\n\n\t\tcase AFC_FREQ_PLUS_62:\n\t\tcase AFC_FREQ_PLUS_125:\n#if defined( TEST_TUNER_AFC )\n printf( \"Hi, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\t++frequency;\n\t\t\tbreak;\n\t\t}\n\n\t\ti2cWrite( bktr, addr,\n\t\t\t  (frequency>>8) & 0x7f, frequency & 0xff );\n\t\tDELAY( AFC_DELAY );\n\t}\n\n fubar:\n\ti2cWrite( bktr, addr,\n\t\t  (origFrequency>>8) & 0x7f, origFrequency & 0xff );\n\n\treturn( -1 );\n}"
  },
  {
    "function_name": "tv_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6295-6376",
    "snippet": "static int\ntv_freq( bktr_ptr_t bktr, int frequency )\n{\n\tconst struct TUNER*\ttuner;\n\tu_char\t\t\taddr;\n\tu_char\t\t\tcontrol;\n\tu_char\t\t\tband;\n\tint\t\t\tN;\n\n\ttuner = bktr->card.tuner;\n\tif ( tuner == NULL )\n\t\treturn( -1 );\n\n\t/*\n\t * select the band based on frequency\n\t * XXX FIXME: get the cross-over points from the tuner struct\n\t */\n\tif ( frequency < (160 * FREQFACTOR) )\n\t  N = 0;\n\telse if ( frequency < (454 * FREQFACTOR) )\n\t  N = 1;\n\telse\n\t  N = 2;\n\n\tif(frequency > RADIO_OFFSET) {\n\t  N=3;\n\t  frequency -= RADIO_OFFSET;\n\t}\n  \n\t/* set the address of the PLL */\n\taddr    = bktr->card.tuner_pllAddr;\n\tcontrol = tuner->pllControl[ N ];\n\tband    = tuner->bandAddrs[ N ];\n\tif(!(band && control))\t\t\t/* Don't try to set un-\t*/\n\t  return(-1);\t\t\t\t/* supported modes.\t*/\n\n         if(N==3) \n\t  band |= bktr->tuner.radio_mode;\n\n\t/*\n\t * N = 16 * { fRF(pc) + fIF(pc) }\n\t * where:\n\t *  pc is picture carrier, fRF & fIF are in mHz\n\t *\n\t * frequency was passed in as mHz * 16\n\t */\n#if defined( TEST_TUNER_AFC )\n\tif ( bktr->tuner.afc )\n\t\tfrequency -= 4;\n#endif\n\n        if(bktr->bt848_tuner == ALPS_TSCH5 && N == 3)   /* for FM frequency */\n                N = frequency;\n        else\n                N = frequency + TBL_IF;\n\n\tif ( frequency > bktr->tuner.frequency ) {\n\t\ti2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t\ti2cWrite( bktr, addr, control, band );\n\t}\n\telse {\n\t\ti2cWrite( bktr, addr, control, band );\n\t\ti2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t}\n\n#if defined( TUNER_AFC )\n\tif ( bktr->tuner.afc == TRUE ) {\n\t\tif ( (N = do_afc( bktr, addr, N )) < 0 ) {\n\t\t    /* AFC failed, restore requested frequency */\n\t\t    N = frequency + TBL_IF;\n\t\t    i2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t\t}\n\t\telse\n\t\t    frequency = N - TBL_IF;\n\t}\n#endif /* TUNER_AFC */\n\n\t/* update frequency */\n\tbktr->tuner.frequency = frequency;\n\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define TBL_IF\tfreqTable[ bktr->tuner.chnlset ].ptr[ 1 ]",
      "#define FREQFACTOR\t\t16",
      "#define\tALPS_TSCH5\t\t12",
      "#define RADIO_OFFSET\t\t20000",
      "#define TUNER_AFC"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2cWrite",
          "args": [
            "bktr",
            "addr",
            "(N>>8) & 0x7f",
            "N & 0xff"
          ],
          "line": 6365
        },
        "resolved": true,
        "details": {
          "function_name": "i2cWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4850-4890",
          "snippet": "static int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_afc",
          "args": [
            "bktr",
            "addr",
            "N"
          ],
          "line": 6362
        },
        "resolved": true,
        "details": {
          "function_name": "do_afc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6382-6444",
          "snippet": "static int\ndo_afc( bktr_ptr_t bktr, int addr, int frequency )\n{\n\tint step;\n\tint status;\n\tint origFrequency;\n\n\torigFrequency = frequency;\n\n\t/* wait for first setting to take effect */\n\ttsleep( BKTR_SLEEP, PZERO, \"tuning\", hz/8 );\n\n\tif ( (status = i2cRead( bktr, addr + 1 )) < 0 )\n\t\treturn( -1 );\n\n#if defined( TEST_TUNER_AFC )\n printf( \"\\nOriginal freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\tfor ( step = 0; step < AFC_MAX_STEP; ++step ) {\n\t\tif ( (status = i2cRead( bktr, addr + 1 )) < 0 )\n\t\t\tgoto fubar;\n\t\tif ( !(status & 0x40) ) {\n#if defined( TEST_TUNER_AFC )\n printf( \"no lock!\\n\" );\n#endif\n\t\t\tgoto fubar;\n\t\t}\n\n\t\tswitch( status & AFC_BITS ) {\n\t\tcase AFC_FREQ_CENTERED:\n#if defined( TEST_TUNER_AFC )\n printf( \"Centered, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\treturn( frequency );\n\n\t\tcase AFC_FREQ_MINUS_125:\n\t\tcase AFC_FREQ_MINUS_62:\n#if defined( TEST_TUNER_AFC )\n printf( \"Low, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\t--frequency;\n\t\t\tbreak;\n\n\t\tcase AFC_FREQ_PLUS_62:\n\t\tcase AFC_FREQ_PLUS_125:\n#if defined( TEST_TUNER_AFC )\n printf( \"Hi, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\t++frequency;\n\t\t\tbreak;\n\t\t}\n\n\t\ti2cWrite( bktr, addr,\n\t\t\t  (frequency>>8) & 0x7f, frequency & 0xff );\n\t\tDELAY( AFC_DELAY );\n\t}\n\n fubar:\n\ti2cWrite( bktr, addr,\n\t\t  (origFrequency>>8) & 0x7f, origFrequency & 0xff );\n\n\treturn( -1 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define AFC_MAX_STEP\t\t(5 * FREQFACTOR) /* no more than 5 MHz */",
            "#define AFC_FREQ_PLUS_125\t0x04",
            "#define AFC_FREQ_PLUS_62\t0x03",
            "#define AFC_FREQ_CENTERED\t0x02",
            "#define AFC_FREQ_MINUS_62\t0x01",
            "#define AFC_FREQ_MINUS_125\t0x00",
            "#define AFC_BITS\t\t0x07",
            "#define AFC_DELAY\t\t10000\t/* 10 millisend delay */",
            "#define BKTR_SLEEP  ((caddr_t)bktr    )"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define AFC_MAX_STEP\t\t(5 * FREQFACTOR) /* no more than 5 MHz */\n#define AFC_FREQ_PLUS_125\t0x04\n#define AFC_FREQ_PLUS_62\t0x03\n#define AFC_FREQ_CENTERED\t0x02\n#define AFC_FREQ_MINUS_62\t0x01\n#define AFC_FREQ_MINUS_125\t0x00\n#define AFC_BITS\t\t0x07\n#define AFC_DELAY\t\t10000\t/* 10 millisend delay */\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n\nstatic int\ndo_afc( bktr_ptr_t bktr, int addr, int frequency )\n{\n\tint step;\n\tint status;\n\tint origFrequency;\n\n\torigFrequency = frequency;\n\n\t/* wait for first setting to take effect */\n\ttsleep( BKTR_SLEEP, PZERO, \"tuning\", hz/8 );\n\n\tif ( (status = i2cRead( bktr, addr + 1 )) < 0 )\n\t\treturn( -1 );\n\n#if defined( TEST_TUNER_AFC )\n printf( \"\\nOriginal freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\tfor ( step = 0; step < AFC_MAX_STEP; ++step ) {\n\t\tif ( (status = i2cRead( bktr, addr + 1 )) < 0 )\n\t\t\tgoto fubar;\n\t\tif ( !(status & 0x40) ) {\n#if defined( TEST_TUNER_AFC )\n printf( \"no lock!\\n\" );\n#endif\n\t\t\tgoto fubar;\n\t\t}\n\n\t\tswitch( status & AFC_BITS ) {\n\t\tcase AFC_FREQ_CENTERED:\n#if defined( TEST_TUNER_AFC )\n printf( \"Centered, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\treturn( frequency );\n\n\t\tcase AFC_FREQ_MINUS_125:\n\t\tcase AFC_FREQ_MINUS_62:\n#if defined( TEST_TUNER_AFC )\n printf( \"Low, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\t--frequency;\n\t\t\tbreak;\n\n\t\tcase AFC_FREQ_PLUS_62:\n\t\tcase AFC_FREQ_PLUS_125:\n#if defined( TEST_TUNER_AFC )\n printf( \"Hi, freq: %d, status: 0x%02x\\n\", frequency, status );\n#endif\n\t\t\t++frequency;\n\t\t\tbreak;\n\t\t}\n\n\t\ti2cWrite( bktr, addr,\n\t\t\t  (frequency>>8) & 0x7f, frequency & 0xff );\n\t\tDELAY( AFC_DELAY );\n\t}\n\n fubar:\n\ti2cWrite( bktr, addr,\n\t\t  (origFrequency>>8) & 0x7f, origFrequency & 0xff );\n\n\treturn( -1 );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TBL_IF\tfreqTable[ bktr->tuner.chnlset ].ptr[ 1 ]\n#define FREQFACTOR\t\t16\n#define\tALPS_TSCH5\t\t12\n#define RADIO_OFFSET\t\t20000\n#define TUNER_AFC\n\nstatic int\ntv_freq( bktr_ptr_t bktr, int frequency )\n{\n\tconst struct TUNER*\ttuner;\n\tu_char\t\t\taddr;\n\tu_char\t\t\tcontrol;\n\tu_char\t\t\tband;\n\tint\t\t\tN;\n\n\ttuner = bktr->card.tuner;\n\tif ( tuner == NULL )\n\t\treturn( -1 );\n\n\t/*\n\t * select the band based on frequency\n\t * XXX FIXME: get the cross-over points from the tuner struct\n\t */\n\tif ( frequency < (160 * FREQFACTOR) )\n\t  N = 0;\n\telse if ( frequency < (454 * FREQFACTOR) )\n\t  N = 1;\n\telse\n\t  N = 2;\n\n\tif(frequency > RADIO_OFFSET) {\n\t  N=3;\n\t  frequency -= RADIO_OFFSET;\n\t}\n  \n\t/* set the address of the PLL */\n\taddr    = bktr->card.tuner_pllAddr;\n\tcontrol = tuner->pllControl[ N ];\n\tband    = tuner->bandAddrs[ N ];\n\tif(!(band && control))\t\t\t/* Don't try to set un-\t*/\n\t  return(-1);\t\t\t\t/* supported modes.\t*/\n\n         if(N==3) \n\t  band |= bktr->tuner.radio_mode;\n\n\t/*\n\t * N = 16 * { fRF(pc) + fIF(pc) }\n\t * where:\n\t *  pc is picture carrier, fRF & fIF are in mHz\n\t *\n\t * frequency was passed in as mHz * 16\n\t */\n#if defined( TEST_TUNER_AFC )\n\tif ( bktr->tuner.afc )\n\t\tfrequency -= 4;\n#endif\n\n        if(bktr->bt848_tuner == ALPS_TSCH5 && N == 3)   /* for FM frequency */\n                N = frequency;\n        else\n                N = frequency + TBL_IF;\n\n\tif ( frequency > bktr->tuner.frequency ) {\n\t\ti2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t\ti2cWrite( bktr, addr, control, band );\n\t}\n\telse {\n\t\ti2cWrite( bktr, addr, control, band );\n\t\ti2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t}\n\n#if defined( TUNER_AFC )\n\tif ( bktr->tuner.afc == TRUE ) {\n\t\tif ( (N = do_afc( bktr, addr, N )) < 0 ) {\n\t\t    /* AFC failed, restore requested frequency */\n\t\t    N = frequency + TBL_IF;\n\t\t    i2cWrite( bktr, addr, (N>>8) & 0x7f, N & 0xff );\n\t\t}\n\t\telse\n\t\t    frequency = N - TBL_IF;\n\t}\n#endif /* TUNER_AFC */\n\n\t/* update frequency */\n\tbktr->tuner.frequency = frequency;\n\n\treturn( 0 );\n}"
  },
  {
    "function_name": "frequency_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "6265-6285",
    "snippet": "static int\nfrequency_lookup( bktr_ptr_t bktr, int channel )\n{\n\tint\tx;\n\n\t/* check for \"> MAX channel\" */\n\tx = 0;\n\tif ( channel > TBL_CHNL )\n\t\treturn( -1 );\n\n\t/* search the table for data */\n\tfor ( x = 3; TBL_CHNL; x += 3 ) {\n\t\tif ( channel >= TBL_CHNL ) {\n\t\t\treturn( TBL_BASE_FREQ +\n\t\t\t\t ((channel - TBL_CHNL) * TBL_OFFSET) );\n\t\t}\n\t}\n\n\t/* not found, must be below the MIN channel */\n\treturn( -1 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define TBL_OFFSET\tfreqTable[ bktr->tuner.chnlset ].ptr[ x + 2 ]",
      "#define TBL_BASE_FREQ\tfreqTable[ bktr->tuner.chnlset ].ptr[ x + 1 ]",
      "#define TBL_CHNL\tfreqTable[ bktr->tuner.chnlset ].ptr[ x ]"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TBL_OFFSET\tfreqTable[ bktr->tuner.chnlset ].ptr[ x + 2 ]\n#define TBL_BASE_FREQ\tfreqTable[ bktr->tuner.chnlset ].ptr[ x + 1 ]\n#define TBL_CHNL\tfreqTable[ bktr->tuner.chnlset ].ptr[ x ]\n\nstatic int\nfrequency_lookup( bktr_ptr_t bktr, int channel )\n{\n\tint\tx;\n\n\t/* check for \"> MAX channel\" */\n\tx = 0;\n\tif ( channel > TBL_CHNL )\n\t\treturn( -1 );\n\n\t/* search the table for data */\n\tfor ( x = 3; TBL_CHNL; x += 3 ) {\n\t\tif ( channel >= TBL_CHNL ) {\n\t\t\treturn( TBL_BASE_FREQ +\n\t\t\t\t ((channel - TBL_CHNL) * TBL_OFFSET) );\n\t\t}\n\t}\n\n\t/* not found, must be below the MIN channel */\n\treturn( -1 );\n}"
  },
  {
    "function_name": "probeCard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5356-5885",
    "snippet": "static void\nprobeCard( bktr_ptr_t bktr, int verbose )\n{\n\tint\t\tcard, i,j, card_found;\n\tint\t\tstatus;\n\tbt848_ptr_t\tbt848;\n\tu_char \t\tprobe_signature[128], *probe_temp;\n        int   \t\tany_i2c_devices;\n\tu_char \t\teeprom[256];\n\tu_char \t\ttuner_code = 0;\n\tint \t\ttuner_i2c_address = -1;\n\tint \t\teeprom_i2c_address = -1;\n\n\tbt848 = bktr->base;\n\n\t/* Select all GPIO bits as inputs */\n\tbt848->gpio_out_en = 0;\n\tif (bootverbose)\n\t    printf(\"bktr: GPIO is 0x%08x\\n\", bt848->gpio_data);\n\n#ifdef HAUPPAUGE_MSP_RESET\n\t/* Reset the MSP34xx audio chip. This resolves bootup card\n\t * detection problems with old Bt848 based Hauppauge cards with\n\t * MSP34xx stereo audio chips. This must be user enabled because\n\t * at this point the probe function does not know the card type. */\n        bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n#endif\n\n\t/* Check for the presence of i2c devices */\n        any_i2c_devices = check_for_i2c_devices( bktr );\n\n\n\t/* Check for a user specified override on the card selection */\n#if defined( OVERRIDE_CARD )\n\tbktr->card = cards[ (card = OVERRIDE_CARD) ];\n\tgoto checkEEPROM;\n#endif\n\tif (bktr->bt848_card != -1 ) {\n\t  bktr->card = cards[ (card = bktr->bt848_card) ];\n\t  goto checkEEPROM;\n\t}\n\n\n\t/* No override, so try and determine the make of the card */\n\n        /* On BT878/879 cards, read the sub-system vendor id */\n\t/* This identifies the manufacturer of the card and the model */\n\t/* In theory this can be read from PCI registers but this does not */\n\t/* appear to work on the FlyVideo 98. Hauppauge also warned that */\n\t/* the PCI registers are sometimes not loaded correctly. */\n\t/* Therefore, I will read the sub-system vendor ID from the EEPROM */\n\t/* (just like the Bt878 does during power up initialisation) */\n\n        if (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) {\n\n\t    /* Try and locate the EEPROM */\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\n                unsigned int subsystem_vendor_id; /* vendors PCI-SIG ID */\n                unsigned int subsystem_id;        /* board model number */\n\t\tunsigned int byte_252, byte_253, byte_254, byte_255;\n\n\t\tbktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\n\t        readEEProm(bktr, 0, 256, (u_char *) &eeprom );\n                byte_252 = (unsigned int)eeprom[252];\n                byte_253 = (unsigned int)eeprom[253];\n                byte_254 = (unsigned int)eeprom[254];\n                byte_255 = (unsigned int)eeprom[255];\n                \n                subsystem_id        = (byte_252 << 8) | byte_253;\n                subsystem_vendor_id = (byte_254 << 8) | byte_255;\n\n\t        if ( bootverbose ) \n\t            printf(\"subsystem 0x%04x 0x%04x\\n\",subsystem_vendor_id,\n\t\t                                  subsystem_id);\n\n                if (subsystem_vendor_id == VENDOR_AVER_MEDIA) {\n                    bktr->card = cards[ (card = CARD_AVER_MEDIA) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_HAUPPAUGE) {\n                    bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_FLYVIDEO) {\n                    bktr->card = cards[ (card = CARD_FLYVIDEO) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_STB) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                /* Vendor is unknown. We will use the standard probe code */\n\t\t/* which may not give best results */\n                printf(\"Warning - card vendor 0x%04x (model 0x%04x) unknown. This may cause poor performance\\n\",subsystem_vendor_id,subsystem_id);\n            }\n\t    else\n\t    {\n                printf(\"Warning - card has no configuration EEPROM. Cannot determine card make. This may cause poor performance\\n\");\n\t    }\n\t} /* end of bt878/bt879 card detection code */\n\n\t/* If we get to this point, we must have a Bt848/848A/849A card */\n\t/* or a Bt878/879 with an unknown subsystem vendor id */\n        /* Try and determine the make of card by clever i2c probing */\n\n   \t/* Check for i2c devices. If none, move on */\n\tif (!any_i2c_devices) {\n\t\tbktr->card = cards[ (card = CARD_INTEL) ];\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t\tgoto checkTuner;\n\t}\n\n\n        /* Look for Hauppauge, STB and Osprey cards by the presence */\n\t/* of an EEPROM */\n        /* Note: Bt878 based cards also use EEPROMs so we can only do this */\n        /* test on BT848/848A and 849A based cards. */\n\tif ((bktr->id==BROOKTREE_848)  ||\n\t    (bktr->id==BROOKTREE_848A) ||\n\t    (bktr->id==BROOKTREE_849A)) {\n\n            /* At i2c address 0xa0, look for Hauppauge and Osprey cards */\n            if ( (status = i2cRead( bktr, PFC8582_RADDR )) != ABSENT ) {\n\n\t\t    /* Read the eeprom contents */\n\t\t    bktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t            readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\t\t    /* For Hauppauge, check the EEPROM begins with 0x84 */\n\t\t    if (eeprom[0] == 0x84) {\n                            bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\n\t\t    /* For Osprey, check the EEPROM begins with \"MMAC\" */\n\t\t    if (  (eeprom[0] == 'M') &&(eeprom[1] == 'M')\n\t\t\t&&(eeprom[2] == 'A') &&(eeprom[3] == 'C')) {\n                            bktr->card = cards[ (card = CARD_OSPREY) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\t\t    printf(\"Warning: Unknown card type. EEPROM data not recognised\\n\");\n\t\t    printf(\"%x %x %x %x\\n\",eeprom[0],eeprom[1],eeprom[2],eeprom[3]);\n            }\n\n            /* look for an STB card */\n            if ( (status = i2cRead( bktr, X24C01_RADDR )) != ABSENT ) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = X24C01_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(128 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n            }\n\n\t}\n\n\tsignCard( bktr, 1, 128, (u_char *)  &probe_signature );\n\n\tif (bootverbose) {\n\t  printf(\"card signature \\n\");\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    printf(\" %02x \", probe_signature[j]);\n\t  }\n\t  printf(\"\\n\\n\");\n\t}\n\tfor (i = 0;\n\t     i < (sizeof bt848_card_signature)/ sizeof (struct bt848_card_sig);\n\t     i++ ) {\n\n\t  card_found = 1;\n\t  probe_temp = (u_char *) &bt848_card_signature[i].signature;\n\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    if ((probe_temp[j] & 0xf) != (probe_signature[j] & 0xf)) {\n\t      card_found = 0;\n\t      break;\n\t    }\n\n\t  }\n\t  if (card_found) {\n\t    bktr->card = cards[ card = bt848_card_signature[i].card];\n\t    bktr->card.tuner = &tuners[ bt848_card_signature[i].tuner];\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t    } else {\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t    }\n\t    goto checkDBX;\n\t  }\n\t}\n\n\t/* We do not know the card type. Default to Miro */\n\tbktr->card = cards[ (card = CARD_MIRO) ];\n\n\ncheckEEPROM:\n\t/* look for a configuration eeprom */\n\teeprom_i2c_address = locate_eeprom_address( bktr );\n\tif (eeprom_i2c_address != -1) {\n\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t} else {\n\t    bktr->card.eepromAddr = 0;\n\t    bktr->card.eepromSize = 0;\n\t}\n\n\ncheckTuner:\n\n\t/* look for a tuner */\n\ttuner_i2c_address = locate_tuner_address( bktr );\n\tif ( tuner_i2c_address == -1 ) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n#if defined( OVERRIDE_TUNER )\n\tbktr->card.tuner = &tuners[ OVERRIDE_TUNER ];\n\tgoto checkDBX;\n#endif\n\tif (bktr->bt848_tuner != -1 ) {\n\t  bktr->card.tuner = &tuners[ bktr->bt848_tuner & 0xff ];\n\t  goto checkDBX;\n\t}\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n\t/* differentiate type of tuner */\n\n\tswitch (card) {\n\tcase CARD_MIRO:\n\t    switch (((bt848->gpio_data >> 10)-1)&7) {\n\t    case 0: bktr->card.tuner = &tuners[ TEMIC_PAL ]; break;\n\t    case 1: bktr->card.tuner = &tuners[ PHILIPS_PAL ]; break;\n\t    case 2: bktr->card.tuner = &tuners[ PHILIPS_NTSC ]; break;\n\t    case 3: bktr->card.tuner = &tuners[ PHILIPS_SECAM ]; break;\n\t    case 4: bktr->card.tuner = &tuners[ NO_TUNER ]; break;\n\t    case 5: bktr->card.tuner = &tuners[ PHILIPS_PALI ]; break;\n\t    case 6: bktr->card.tuner = &tuners[ TEMIC_NTSC ]; break;\n\t    case 7: bktr->card.tuner = &tuners[ TEMIC_PALI ]; break;\n\t    }\n\t    goto checkDBX;\n\t    break;\n\n\tcase CARD_HAUPPAUGE:\n\t    /* Hauppauge kindly supplied the following Tuner Table */\n\t    /* FIXME: I think the tuners the driver selects for types */\n\t    /* 0x08 and 0x15 may be incorrect but no one has complained. */\n\t    /*\n   \t    \tID Tuner Model          Format         \tWe select Format\n\t   \t 0 NONE               \n\t\t 1 EXTERNAL             \n\t\t 2 OTHER                \n\t\t 3 Philips FI1216       BG \n\t\t 4 Philips FI1216MF     BGLL' \n\t\t 5 Philips FI1236       MN \t\tPHILIPS_NTSC\n\t\t 6 Philips FI1246       I \n\t\t 7 Philips FI1256       DK \n\t\t 8 Philips FI1216 MK2   BG \t\tPHILIPS_PALI\n\t\t 9 Philips FI1216MF MK2 BGLL' \n\t\t a Philips FI1236 MK2   MN \t\tPHILIPS_NTSC\n\t\t b Philips FI1246 MK2   I \t\tPHILIPS_PALI\n\t\t c Philips FI1256 MK2   DK \n\t\t d Temic 4032FY5        NTSC\t\tTEMIC_NTSC\n\t\t e Temic 4002FH5        BG\t\tTEMIC_PAL\n\t\t f Temic 4062FY5        I \t\tTEMIC_PALI\n\t\t10 Philips FR1216 MK2   BG \n\t\t11 Philips FR1216MF MK2 BGLL' \n\t\t12 Philips FR1236 MK2   MN \t\tPHILIPS_FR1236_NTSC\n\t\t13 Philips FR1246 MK2   I \n\t\t14 Philips FR1256 MK2   DK \n\t\t15 Philips FM1216       BG \t\tPHILIPS_FR1216_PAL\n\t\t16 Philips FM1216MF     BGLL' \n\t\t17 Philips FM1236       MN \t\tPHILIPS_FR1236_NTSC\n\t\t18 Philips FM1246       I \n\t\t19 Philips FM1256       DK \n\t\t1a Temic 4036FY5        MN - FI1236 MK2 clone\n\t\t1b Samsung TCPN9082D    MN \n\t\t1c Samsung TCPM9092P    Pal BG/I/DK \n\t\t1d Temic 4006FH5        BG \t\tPHILIPS_PALI clone\n\t\t1e Samsung TCPN9085D    MN/Radio \n\t\t1f Samsung TCPB9085P    Pal BG/I/DK / Radio \n\t\t20 Samsung TCPL9091P    Pal BG & Secam L/L' \n\t\t21 Temic 4039FY5        NTSC Radio\n\n\t    */\n\n\t    readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\n\t    /* Determine the model number from the eeprom */\n\t    {\n\t\tu_int model;\n\t\tu_int revision;\n\t\tmodel    = (eeprom[12] << 8  | eeprom[11]);\n\t\trevision = (eeprom[15] << 16 | eeprom[14] << 8 | eeprom[13]);\n\t\tif (verbose)\n\t\t    printf(\"Hauppauge Model %d %c%c%c%c\\n\",\n\t\t\tmodel,\n\t\t\t((revision >> 18) & 0x3f) + 32,\n\t\t\t((revision >> 12) & 0x3f) + 32,\n\t\t\t((revision >>  6) & 0x3f) + 32,\n\t\t\t((revision >>  0) & 0x3f) + 32 );\n\t    }\n\n\t    /* Determine the tuner type from the eeprom */\n\t    tuner_code = eeprom[9];\n\t    switch (tuner_code) {\n\n\t       case 0x5:\n               case 0x0a:\n\t       case 0x1a:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_NTSC  ];\n\t\t goto checkDBX;\n\n               case 0x12:\n\t       case 0x17:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1236_NTSC  ];\n\t\t goto checkDBX;\n\n\t       case 0x8:\n\t       case 0xb:\n\t       case 0x1d:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_PALI ];\n\t\t goto checkDBX;\n\n\t       case 0xd:\n\t\t bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n\t\t goto checkDBX;\n\n               case 0xe:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PAL];\n\t\t goto checkDBX;\n\n\t       case 0xf:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PALI ];\n\t\t goto checkDBX;\n\n               case 0x15:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1216_PAL];\n\t\t goto checkDBX;\n\n\t       default :\n\t\t printf(\"Warning - Unknown Hauppauge Tuner 0x%x\\n\",tuner_code);\n\t    }\n\t    break;\n\n\t} /* end switch(card) */\n\n        /* At this point, a goto checkDBX has not occured */\n        /* We have not been able to select a Tuner */\n        /* Some cards make use of the tuner address to */\n        /* identify the make/model of tuner */\n\n        /* At address 0xc0/0xc1 we often find a TEMIC NTSC */\n        if ( i2cRead( bktr, 0xc1 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n            goto checkDBX;\n        }\n  \n        /* At address 0xc6/0xc7 we often find a PHILIPS NTSC Tuner */\n        if ( i2cRead( bktr, 0xc7 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ PHILIPS_NTSC ];\n            goto checkDBX;\n        }\n\n        /* Address 0xc2/0xc3 is default (or common address) for several */\n\t/* tuners and we cannot tell which is which. */\n\t/* And for all other tuner i2c addresses, select the default */\n\tbktr->card.tuner = &tuners[ DEFAULT_TUNER ];\n\n\ncheckDBX:\n#if defined( OVERRIDE_DBX )\n\tbktr->card.dbx = OVERRIDE_DBX;\n\tgoto checkMSP;\n#endif\n   /* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSP;\n\t}\n\n\t/* probe for BTSC (dbx) chip */\n\tif ( i2cRead( bktr, TDA9850_RADDR ) != ABSENT )\n\t\tbktr->card.dbx = 1;\n\ncheckMSP:\n\t/* If this is a Hauppauge Bt878 card, we need to enable the\n\t * MSP 34xx audio chip. \n\t * If this is a Hauppauge Bt848 card, reset the MSP device.\n\t * The MSP reset line is wired to GPIO pin 5. On Bt878 cards a pulldown\n\t * resistor holds the device in reset until we set GPIO pin 5.\n         */\n\n\t/* Optionally skip the MSP reset. This is handy if you initialise the\n\t * MSP audio in another operating system (eg Windows) first and then\n\t * do a soft reboot.\n\t */\n\n#ifndef BKTR_NO_MSP_RESET\n\tif (card == CARD_HAUPPAUGE) {\n            bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n        }\n#endif\n\n#if defined( OVERRIDE_MSP )\n\tbktr->card.msp3400c = OVERRIDE_MSP;\n\tgoto checkMSPEnd;\n#endif\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSPEnd;\n\t}\n\n\tif ( i2cRead( bktr, MSP3400C_RADDR ) != ABSENT )\n\t\tbktr->card.msp3400c = 1;\n\ncheckMSPEnd:\n\n/* Start of Check Remote */\n        /* Check for the Hauppauge IR Remote Control */\n        /* If there is an external unit, the internal will be ignored */\n\n        bktr->remote_control = 0; /* initial value */\n\n        if (any_i2c_devices) {\n            if (i2cRead( bktr, HAUP_REMOTE_EXT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_EXT_RADDR;\n                }\n            else if (i2cRead( bktr, HAUP_REMOTE_INT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_INT_RADDR;\n                }\n\n        }\n        /* If a remote control is found, poll it 5 times to turn off the LED */\n        if (bktr->remote_control) {\n                int i;\n                for (i=0; i<5; i++)\n                        i2cRead( bktr, bktr->remote_control_addr );\n        }\n/* End of Check Remote */\n\n#if defined( BKTR_USE_PLL )\n\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\tgoto checkPLLEnd;\n#endif\n\t/* Default is to use XTALS and not PLL mode */\n\tbktr->xtal_pll_mode = BT848_USE_XTALS;\n\n\t/* Enable PLL mode for PAL/SECAM users on Hauppauge 878 cards */\n\tif ((card == CARD_HAUPPAUGE) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\n\t/* Enable PLL mode for OSPREY users */\n\tif (card == CARD_OSPREY)\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\t/* Enable PLL mode for PAL/SECAM users on FlyVideo 878 cards */\n\tif ((card == CARD_FLYVIDEO) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n#if defined( BKTR_USE_PLL )\ncheckPLLEnd:\n#endif\n\n\n\tbktr->card.tuner_pllAddr = tuner_i2c_address;\n\n\tif ( verbose ) {\n\t\tprintf( \"%s\", bktr->card.name );\n\t\tif ( bktr->card.tuner )\n\t\t\tprintf( \", %s tuner\", bktr->card.tuner->name );\n\t\tif ( bktr->card.dbx )\n\t\t\tprintf( \", dbx stereo\" );\n\t\tif ( bktr->card.msp3400c )\n\t\t\tprintf( \", msp3400c stereo\" );\n                if ( bktr->remote_control )\n                        printf( \", remote control\" );\n\t\tprintf( \".\\n\" );\n\t}\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VENDOR_STB        0x10B4",
      "#define VENDOR_FLYVIDEO   0x1851",
      "#define VENDOR_HAUPPAUGE  0x0070",
      "#define VENDOR_AVER_MEDIA 0x1431",
      "#define ABSENT\t\t(-1)",
      "#define CARD_FLYVIDEO\t\t10",
      "#define\tCARD_OSPREY\t\t7",
      "#define\tCARD_AVER_MEDIA\t\t6",
      "#define\tCARD_INTEL\t\t4",
      "#define\tCARD_STB\t\t3",
      "#define\tCARD_HAUPPAUGE\t\t2",
      "#define\tCARD_MIRO\t\t1",
      "#define\tCARD_UNKNOWN\t\t0",
      "#define DEFAULT_TUNER\tPHILIPS_NTSC",
      "#define DEFAULT_TUNER\tPHILIPS_PALI",
      "#define PHILIPS_FR1216_PAL\t10",
      "#define PHILIPS_FR1236_NTSC     9",
      "#define PHILIPS_PALI\t\t8",
      "#define TEMIC_PALI\t\t7",
      "#define PHILIPS_SECAM\t\t6",
      "#define PHILIPS_PAL\t\t5",
      "#define PHILIPS_NTSC\t\t4",
      "#define TEMIC_PAL\t\t2",
      "#define TEMIC_NTSC\t\t1",
      "#define NO_TUNER\t\t0",
      "#define PFC8582_RADDR\t\t0xa1",
      "#define PFC8582_WADDR\t\t0xa0",
      "#define X24C01_RADDR\t\t0xaf",
      "#define X24C01_WADDR\t\t0xae",
      "#define MSP3400C_RADDR\t\t0x81",
      "#define TDA9850_RADDR\t\t0xb7",
      "#define HAUP_REMOTE_EXT_RADDR   0x35",
      "#define HAUP_REMOTE_INT_RADDR   0x31",
      "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\".\\n\""
          ],
          "line": 5883
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2cRead",
          "args": [
            "bktr",
            "bktr->remote_control_addr"
          ],
          "line": 5840
        },
        "resolved": true,
        "details": {
          "function_name": "i2cRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4896-4930",
          "snippet": "static int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "2500"
          ],
          "line": 5798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "2500"
          ],
          "line": 5796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "2500"
          ],
          "line": 5794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readEEProm",
          "args": [
            "bktr",
            "0",
            "128",
            "(u_char *) &eeprom"
          ],
          "line": 5678
        },
        "resolved": true,
        "details": {
          "function_name": "readEEProm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5204-5233",
          "snippet": "static int\nreadEEProm( bktr_ptr_t bktr, int offset, int count, u_char *data )\n{\n\tint\tx;\n\tint\taddr;\n\tint\tmax;\n\tint\tbyte;\n\n\t/* get the address of the EEProm */\n\taddr = (int)(bktr->card.eepromAddr & 0xff);\n\tif ( addr == 0 )\n\t\treturn( -1 );\n\n\tmax = (int)(bktr->card.eepromSize * EEPROMBLOCKSIZE);\n\tif ( (offset + count) > max )\n\t\treturn( -1 );\n\n\t/* set the start address */\n\tif ( i2cWrite( bktr, addr, offset, -1 ) == -1 )\n\t\treturn( -1 );\n\n\t/* the read cycle */\n\tfor ( x = 0; x < count; ++x ) {\n\t\tif ( (byte = i2cRead( bktr, (addr | 1) )) == -1 )\n\t\t\treturn( -1 );\n\t\tdata[ x ] = byte;\n\t}\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nreadEEProm( bktr_ptr_t bktr, int offset, int count, u_char *data )\n{\n\tint\tx;\n\tint\taddr;\n\tint\tmax;\n\tint\tbyte;\n\n\t/* get the address of the EEProm */\n\taddr = (int)(bktr->card.eepromAddr & 0xff);\n\tif ( addr == 0 )\n\t\treturn( -1 );\n\n\tmax = (int)(bktr->card.eepromSize * EEPROMBLOCKSIZE);\n\tif ( (offset + count) > max )\n\t\treturn( -1 );\n\n\t/* set the start address */\n\tif ( i2cWrite( bktr, addr, offset, -1 ) == -1 )\n\t\treturn( -1 );\n\n\t/* the read cycle */\n\tfor ( x = 0; x < count; ++x ) {\n\t\tif ( (byte = i2cRead( bktr, (addr | 1) )) == -1 )\n\t\t\treturn( -1 );\n\t\tdata[ x ] = byte;\n\t}\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "locate_tuner_address",
          "args": [
            "bktr"
          ],
          "line": 5597
        },
        "resolved": true,
        "details": {
          "function_name": "locate_tuner_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5292-5298",
          "snippet": "static int locate_tuner_address( bktr_ptr_t bktr) {\n  if (i2cRead( bktr, 0xc1) != ABSENT) return 0xc0;\n  if (i2cRead( bktr, 0xc3) != ABSENT) return 0xc2;\n  if (i2cRead( bktr, 0xc5) != ABSENT) return 0xc4;\n  if (i2cRead( bktr, 0xc7) != ABSENT) return 0xc6;\n  return -1; /* no tuner found */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ABSENT\t\t(-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ABSENT\t\t(-1)\n\nstatic int locate_tuner_address( bktr_ptr_t bktr) {\n  if (i2cRead( bktr, 0xc1) != ABSENT) return 0xc0;\n  if (i2cRead( bktr, 0xc3) != ABSENT) return 0xc2;\n  if (i2cRead( bktr, 0xc5) != ABSENT) return 0xc4;\n  if (i2cRead( bktr, 0xc7) != ABSENT) return 0xc6;\n  return -1; /* no tuner found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "256 / EEPROMBLOCKSIZE"
          ],
          "line": 5587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locate_eeprom_address",
          "args": [
            "bktr"
          ],
          "line": 5584
        },
        "resolved": true,
        "details": {
          "function_name": "locate_eeprom_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5304-5309",
          "snippet": "static int locate_eeprom_address( bktr_ptr_t bktr) {\n  if (i2cRead( bktr, 0xa0) != ABSENT) return 0xa0;\n  if (i2cRead( bktr, 0xac) != ABSENT) return 0xac;\n  if (i2cRead( bktr, 0xae) != ABSENT) return 0xae;\n  return -1; /* no eeprom found */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ABSENT\t\t(-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ABSENT\t\t(-1)\n\nstatic int locate_eeprom_address( bktr_ptr_t bktr) {\n  if (i2cRead( bktr, 0xa0) != ABSENT) return 0xa0;\n  if (i2cRead( bktr, 0xac) != ABSENT) return 0xac;\n  if (i2cRead( bktr, 0xae) != ABSENT) return 0xae;\n  return -1; /* no eeprom found */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "256 / EEPROMBLOCKSIZE"
          ],
          "line": 5569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signCard",
          "args": [
            "bktr",
            "1",
            "128",
            "(u_char *)  &probe_signature"
          ],
          "line": 5540
        },
        "resolved": true,
        "details": {
          "function_name": "signCard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5244-5259",
          "snippet": "static int\nsignCard( bktr_ptr_t bktr, int offset, int count, u_char* sig )\n{\n\tint\tx;\n\n\tfor ( x = 0; x < 16; ++x )\n\t\tsig[ x ] = 0;\n\n\tfor ( x = 0; x < count; ++x ) {\n\t\tif ( i2cRead( bktr, (2 * x) + 1 ) != ABSENT ) {\n\t\t\tsig[ x / 8 ] |= (1 << (x % 8) );\n\t\t}\n\t}\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ABSENT\t\t(-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ABSENT\t\t(-1)\n\nstatic int\nsignCard( bktr_ptr_t bktr, int offset, int count, u_char* sig )\n{\n\tint\tx;\n\n\tfor ( x = 0; x < 16; ++x )\n\t\tsig[ x ] = 0;\n\n\tfor ( x = 0; x < count; ++x ) {\n\t\tif ( i2cRead( bktr, (2 * x) + 1 ) != ABSENT ) {\n\t\t\tsig[ x / 8 ] |= (1 << (x % 8) );\n\t\t}\n\t}\n\n\treturn( 0 );\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "128 / EEPROMBLOCKSIZE"
          ],
          "line": 5534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "256 / EEPROMBLOCKSIZE"
          ],
          "line": 5523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "256 / EEPROMBLOCKSIZE"
          ],
          "line": 5514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "256 / EEPROMBLOCKSIZE"
          ],
          "line": 5507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "256 / EEPROMBLOCKSIZE"
          ],
          "line": 5466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "256 / EEPROMBLOCKSIZE"
          ],
          "line": 5459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "256 / EEPROMBLOCKSIZE"
          ],
          "line": 5452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "256 / EEPROMBLOCKSIZE"
          ],
          "line": 5445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "256 / EEPROMBLOCKSIZE"
          ],
          "line": 5427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_i2c_devices",
          "args": [
            "bktr"
          ],
          "line": 5391
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_i2c_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5273-5285",
          "snippet": "static int check_for_i2c_devices( bktr_ptr_t bktr ){\n  int x, temp_read;\n  int i2c_all_0 = 1;\n  int i2c_all_absent = 1;\n  for ( x = 0; x < 128; ++x ) {\n    temp_read = i2cRead( bktr, (2 * x) + 1 );\n    if (temp_read != 0)      i2c_all_0 = 0;\n    if (temp_read != ABSENT) i2c_all_absent = 0;\n  }\n\n  if ((i2c_all_0) || (i2c_all_absent)) return 0;\n  else return 1;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ABSENT\t\t(-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ABSENT\t\t(-1)\n\nstatic int check_for_i2c_devices( bktr_ptr_t bktr ){\n  int x, temp_read;\n  int i2c_all_0 = 1;\n  int i2c_all_absent = 1;\n  for ( x = 0; x < 128; ++x ) {\n    temp_read = i2cRead( bktr, (2 * x) + 1 );\n    if (temp_read != 0)      i2c_all_0 = 0;\n    if (temp_read != ABSENT) i2c_all_absent = 0;\n  }\n\n  if ((i2c_all_0) || (i2c_all_absent)) return 0;\n  else return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "2500"
          ],
          "line": 5387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "2500"
          ],
          "line": 5385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "2500"
          ],
          "line": 5383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VENDOR_STB        0x10B4\n#define VENDOR_FLYVIDEO   0x1851\n#define VENDOR_HAUPPAUGE  0x0070\n#define VENDOR_AVER_MEDIA 0x1431\n#define ABSENT\t\t(-1)\n#define CARD_FLYVIDEO\t\t10\n#define\tCARD_OSPREY\t\t7\n#define\tCARD_AVER_MEDIA\t\t6\n#define\tCARD_INTEL\t\t4\n#define\tCARD_STB\t\t3\n#define\tCARD_HAUPPAUGE\t\t2\n#define\tCARD_MIRO\t\t1\n#define\tCARD_UNKNOWN\t\t0\n#define DEFAULT_TUNER\tPHILIPS_NTSC\n#define DEFAULT_TUNER\tPHILIPS_PALI\n#define PHILIPS_FR1216_PAL\t10\n#define PHILIPS_FR1236_NTSC     9\n#define PHILIPS_PALI\t\t8\n#define TEMIC_PALI\t\t7\n#define PHILIPS_SECAM\t\t6\n#define PHILIPS_PAL\t\t5\n#define PHILIPS_NTSC\t\t4\n#define TEMIC_PAL\t\t2\n#define TEMIC_NTSC\t\t1\n#define NO_TUNER\t\t0\n#define PFC8582_RADDR\t\t0xa1\n#define PFC8582_WADDR\t\t0xa0\n#define X24C01_RADDR\t\t0xaf\n#define X24C01_WADDR\t\t0xae\n#define MSP3400C_RADDR\t\t0x81\n#define TDA9850_RADDR\t\t0xb7\n#define HAUP_REMOTE_EXT_RADDR   0x35\n#define HAUP_REMOTE_INT_RADDR   0x31\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n\nstatic void\nprobeCard( bktr_ptr_t bktr, int verbose )\n{\n\tint\t\tcard, i,j, card_found;\n\tint\t\tstatus;\n\tbt848_ptr_t\tbt848;\n\tu_char \t\tprobe_signature[128], *probe_temp;\n        int   \t\tany_i2c_devices;\n\tu_char \t\teeprom[256];\n\tu_char \t\ttuner_code = 0;\n\tint \t\ttuner_i2c_address = -1;\n\tint \t\teeprom_i2c_address = -1;\n\n\tbt848 = bktr->base;\n\n\t/* Select all GPIO bits as inputs */\n\tbt848->gpio_out_en = 0;\n\tif (bootverbose)\n\t    printf(\"bktr: GPIO is 0x%08x\\n\", bt848->gpio_data);\n\n#ifdef HAUPPAUGE_MSP_RESET\n\t/* Reset the MSP34xx audio chip. This resolves bootup card\n\t * detection problems with old Bt848 based Hauppauge cards with\n\t * MSP34xx stereo audio chips. This must be user enabled because\n\t * at this point the probe function does not know the card type. */\n        bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n#endif\n\n\t/* Check for the presence of i2c devices */\n        any_i2c_devices = check_for_i2c_devices( bktr );\n\n\n\t/* Check for a user specified override on the card selection */\n#if defined( OVERRIDE_CARD )\n\tbktr->card = cards[ (card = OVERRIDE_CARD) ];\n\tgoto checkEEPROM;\n#endif\n\tif (bktr->bt848_card != -1 ) {\n\t  bktr->card = cards[ (card = bktr->bt848_card) ];\n\t  goto checkEEPROM;\n\t}\n\n\n\t/* No override, so try and determine the make of the card */\n\n        /* On BT878/879 cards, read the sub-system vendor id */\n\t/* This identifies the manufacturer of the card and the model */\n\t/* In theory this can be read from PCI registers but this does not */\n\t/* appear to work on the FlyVideo 98. Hauppauge also warned that */\n\t/* the PCI registers are sometimes not loaded correctly. */\n\t/* Therefore, I will read the sub-system vendor ID from the EEPROM */\n\t/* (just like the Bt878 does during power up initialisation) */\n\n        if (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) {\n\n\t    /* Try and locate the EEPROM */\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\n                unsigned int subsystem_vendor_id; /* vendors PCI-SIG ID */\n                unsigned int subsystem_id;        /* board model number */\n\t\tunsigned int byte_252, byte_253, byte_254, byte_255;\n\n\t\tbktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\n\t        readEEProm(bktr, 0, 256, (u_char *) &eeprom );\n                byte_252 = (unsigned int)eeprom[252];\n                byte_253 = (unsigned int)eeprom[253];\n                byte_254 = (unsigned int)eeprom[254];\n                byte_255 = (unsigned int)eeprom[255];\n                \n                subsystem_id        = (byte_252 << 8) | byte_253;\n                subsystem_vendor_id = (byte_254 << 8) | byte_255;\n\n\t        if ( bootverbose ) \n\t            printf(\"subsystem 0x%04x 0x%04x\\n\",subsystem_vendor_id,\n\t\t                                  subsystem_id);\n\n                if (subsystem_vendor_id == VENDOR_AVER_MEDIA) {\n                    bktr->card = cards[ (card = CARD_AVER_MEDIA) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_HAUPPAUGE) {\n                    bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_FLYVIDEO) {\n                    bktr->card = cards[ (card = CARD_FLYVIDEO) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_STB) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                /* Vendor is unknown. We will use the standard probe code */\n\t\t/* which may not give best results */\n                printf(\"Warning - card vendor 0x%04x (model 0x%04x) unknown. This may cause poor performance\\n\",subsystem_vendor_id,subsystem_id);\n            }\n\t    else\n\t    {\n                printf(\"Warning - card has no configuration EEPROM. Cannot determine card make. This may cause poor performance\\n\");\n\t    }\n\t} /* end of bt878/bt879 card detection code */\n\n\t/* If we get to this point, we must have a Bt848/848A/849A card */\n\t/* or a Bt878/879 with an unknown subsystem vendor id */\n        /* Try and determine the make of card by clever i2c probing */\n\n   \t/* Check for i2c devices. If none, move on */\n\tif (!any_i2c_devices) {\n\t\tbktr->card = cards[ (card = CARD_INTEL) ];\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t\tgoto checkTuner;\n\t}\n\n\n        /* Look for Hauppauge, STB and Osprey cards by the presence */\n\t/* of an EEPROM */\n        /* Note: Bt878 based cards also use EEPROMs so we can only do this */\n        /* test on BT848/848A and 849A based cards. */\n\tif ((bktr->id==BROOKTREE_848)  ||\n\t    (bktr->id==BROOKTREE_848A) ||\n\t    (bktr->id==BROOKTREE_849A)) {\n\n            /* At i2c address 0xa0, look for Hauppauge and Osprey cards */\n            if ( (status = i2cRead( bktr, PFC8582_RADDR )) != ABSENT ) {\n\n\t\t    /* Read the eeprom contents */\n\t\t    bktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t            readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\t\t    /* For Hauppauge, check the EEPROM begins with 0x84 */\n\t\t    if (eeprom[0] == 0x84) {\n                            bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\n\t\t    /* For Osprey, check the EEPROM begins with \"MMAC\" */\n\t\t    if (  (eeprom[0] == 'M') &&(eeprom[1] == 'M')\n\t\t\t&&(eeprom[2] == 'A') &&(eeprom[3] == 'C')) {\n                            bktr->card = cards[ (card = CARD_OSPREY) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\t\t    printf(\"Warning: Unknown card type. EEPROM data not recognised\\n\");\n\t\t    printf(\"%x %x %x %x\\n\",eeprom[0],eeprom[1],eeprom[2],eeprom[3]);\n            }\n\n            /* look for an STB card */\n            if ( (status = i2cRead( bktr, X24C01_RADDR )) != ABSENT ) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = X24C01_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(128 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n            }\n\n\t}\n\n\tsignCard( bktr, 1, 128, (u_char *)  &probe_signature );\n\n\tif (bootverbose) {\n\t  printf(\"card signature \\n\");\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    printf(\" %02x \", probe_signature[j]);\n\t  }\n\t  printf(\"\\n\\n\");\n\t}\n\tfor (i = 0;\n\t     i < (sizeof bt848_card_signature)/ sizeof (struct bt848_card_sig);\n\t     i++ ) {\n\n\t  card_found = 1;\n\t  probe_temp = (u_char *) &bt848_card_signature[i].signature;\n\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    if ((probe_temp[j] & 0xf) != (probe_signature[j] & 0xf)) {\n\t      card_found = 0;\n\t      break;\n\t    }\n\n\t  }\n\t  if (card_found) {\n\t    bktr->card = cards[ card = bt848_card_signature[i].card];\n\t    bktr->card.tuner = &tuners[ bt848_card_signature[i].tuner];\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t    } else {\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t    }\n\t    goto checkDBX;\n\t  }\n\t}\n\n\t/* We do not know the card type. Default to Miro */\n\tbktr->card = cards[ (card = CARD_MIRO) ];\n\n\ncheckEEPROM:\n\t/* look for a configuration eeprom */\n\teeprom_i2c_address = locate_eeprom_address( bktr );\n\tif (eeprom_i2c_address != -1) {\n\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t} else {\n\t    bktr->card.eepromAddr = 0;\n\t    bktr->card.eepromSize = 0;\n\t}\n\n\ncheckTuner:\n\n\t/* look for a tuner */\n\ttuner_i2c_address = locate_tuner_address( bktr );\n\tif ( tuner_i2c_address == -1 ) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n#if defined( OVERRIDE_TUNER )\n\tbktr->card.tuner = &tuners[ OVERRIDE_TUNER ];\n\tgoto checkDBX;\n#endif\n\tif (bktr->bt848_tuner != -1 ) {\n\t  bktr->card.tuner = &tuners[ bktr->bt848_tuner & 0xff ];\n\t  goto checkDBX;\n\t}\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n\t/* differentiate type of tuner */\n\n\tswitch (card) {\n\tcase CARD_MIRO:\n\t    switch (((bt848->gpio_data >> 10)-1)&7) {\n\t    case 0: bktr->card.tuner = &tuners[ TEMIC_PAL ]; break;\n\t    case 1: bktr->card.tuner = &tuners[ PHILIPS_PAL ]; break;\n\t    case 2: bktr->card.tuner = &tuners[ PHILIPS_NTSC ]; break;\n\t    case 3: bktr->card.tuner = &tuners[ PHILIPS_SECAM ]; break;\n\t    case 4: bktr->card.tuner = &tuners[ NO_TUNER ]; break;\n\t    case 5: bktr->card.tuner = &tuners[ PHILIPS_PALI ]; break;\n\t    case 6: bktr->card.tuner = &tuners[ TEMIC_NTSC ]; break;\n\t    case 7: bktr->card.tuner = &tuners[ TEMIC_PALI ]; break;\n\t    }\n\t    goto checkDBX;\n\t    break;\n\n\tcase CARD_HAUPPAUGE:\n\t    /* Hauppauge kindly supplied the following Tuner Table */\n\t    /* FIXME: I think the tuners the driver selects for types */\n\t    /* 0x08 and 0x15 may be incorrect but no one has complained. */\n\t    /*\n   \t    \tID Tuner Model          Format         \tWe select Format\n\t   \t 0 NONE               \n\t\t 1 EXTERNAL             \n\t\t 2 OTHER                \n\t\t 3 Philips FI1216       BG \n\t\t 4 Philips FI1216MF     BGLL' \n\t\t 5 Philips FI1236       MN \t\tPHILIPS_NTSC\n\t\t 6 Philips FI1246       I \n\t\t 7 Philips FI1256       DK \n\t\t 8 Philips FI1216 MK2   BG \t\tPHILIPS_PALI\n\t\t 9 Philips FI1216MF MK2 BGLL' \n\t\t a Philips FI1236 MK2   MN \t\tPHILIPS_NTSC\n\t\t b Philips FI1246 MK2   I \t\tPHILIPS_PALI\n\t\t c Philips FI1256 MK2   DK \n\t\t d Temic 4032FY5        NTSC\t\tTEMIC_NTSC\n\t\t e Temic 4002FH5        BG\t\tTEMIC_PAL\n\t\t f Temic 4062FY5        I \t\tTEMIC_PALI\n\t\t10 Philips FR1216 MK2   BG \n\t\t11 Philips FR1216MF MK2 BGLL' \n\t\t12 Philips FR1236 MK2   MN \t\tPHILIPS_FR1236_NTSC\n\t\t13 Philips FR1246 MK2   I \n\t\t14 Philips FR1256 MK2   DK \n\t\t15 Philips FM1216       BG \t\tPHILIPS_FR1216_PAL\n\t\t16 Philips FM1216MF     BGLL' \n\t\t17 Philips FM1236       MN \t\tPHILIPS_FR1236_NTSC\n\t\t18 Philips FM1246       I \n\t\t19 Philips FM1256       DK \n\t\t1a Temic 4036FY5        MN - FI1236 MK2 clone\n\t\t1b Samsung TCPN9082D    MN \n\t\t1c Samsung TCPM9092P    Pal BG/I/DK \n\t\t1d Temic 4006FH5        BG \t\tPHILIPS_PALI clone\n\t\t1e Samsung TCPN9085D    MN/Radio \n\t\t1f Samsung TCPB9085P    Pal BG/I/DK / Radio \n\t\t20 Samsung TCPL9091P    Pal BG & Secam L/L' \n\t\t21 Temic 4039FY5        NTSC Radio\n\n\t    */\n\n\t    readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\n\t    /* Determine the model number from the eeprom */\n\t    {\n\t\tu_int model;\n\t\tu_int revision;\n\t\tmodel    = (eeprom[12] << 8  | eeprom[11]);\n\t\trevision = (eeprom[15] << 16 | eeprom[14] << 8 | eeprom[13]);\n\t\tif (verbose)\n\t\t    printf(\"Hauppauge Model %d %c%c%c%c\\n\",\n\t\t\tmodel,\n\t\t\t((revision >> 18) & 0x3f) + 32,\n\t\t\t((revision >> 12) & 0x3f) + 32,\n\t\t\t((revision >>  6) & 0x3f) + 32,\n\t\t\t((revision >>  0) & 0x3f) + 32 );\n\t    }\n\n\t    /* Determine the tuner type from the eeprom */\n\t    tuner_code = eeprom[9];\n\t    switch (tuner_code) {\n\n\t       case 0x5:\n               case 0x0a:\n\t       case 0x1a:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_NTSC  ];\n\t\t goto checkDBX;\n\n               case 0x12:\n\t       case 0x17:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1236_NTSC  ];\n\t\t goto checkDBX;\n\n\t       case 0x8:\n\t       case 0xb:\n\t       case 0x1d:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_PALI ];\n\t\t goto checkDBX;\n\n\t       case 0xd:\n\t\t bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n\t\t goto checkDBX;\n\n               case 0xe:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PAL];\n\t\t goto checkDBX;\n\n\t       case 0xf:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PALI ];\n\t\t goto checkDBX;\n\n               case 0x15:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1216_PAL];\n\t\t goto checkDBX;\n\n\t       default :\n\t\t printf(\"Warning - Unknown Hauppauge Tuner 0x%x\\n\",tuner_code);\n\t    }\n\t    break;\n\n\t} /* end switch(card) */\n\n        /* At this point, a goto checkDBX has not occured */\n        /* We have not been able to select a Tuner */\n        /* Some cards make use of the tuner address to */\n        /* identify the make/model of tuner */\n\n        /* At address 0xc0/0xc1 we often find a TEMIC NTSC */\n        if ( i2cRead( bktr, 0xc1 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n            goto checkDBX;\n        }\n  \n        /* At address 0xc6/0xc7 we often find a PHILIPS NTSC Tuner */\n        if ( i2cRead( bktr, 0xc7 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ PHILIPS_NTSC ];\n            goto checkDBX;\n        }\n\n        /* Address 0xc2/0xc3 is default (or common address) for several */\n\t/* tuners and we cannot tell which is which. */\n\t/* And for all other tuner i2c addresses, select the default */\n\tbktr->card.tuner = &tuners[ DEFAULT_TUNER ];\n\n\ncheckDBX:\n#if defined( OVERRIDE_DBX )\n\tbktr->card.dbx = OVERRIDE_DBX;\n\tgoto checkMSP;\n#endif\n   /* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSP;\n\t}\n\n\t/* probe for BTSC (dbx) chip */\n\tif ( i2cRead( bktr, TDA9850_RADDR ) != ABSENT )\n\t\tbktr->card.dbx = 1;\n\ncheckMSP:\n\t/* If this is a Hauppauge Bt878 card, we need to enable the\n\t * MSP 34xx audio chip. \n\t * If this is a Hauppauge Bt848 card, reset the MSP device.\n\t * The MSP reset line is wired to GPIO pin 5. On Bt878 cards a pulldown\n\t * resistor holds the device in reset until we set GPIO pin 5.\n         */\n\n\t/* Optionally skip the MSP reset. This is handy if you initialise the\n\t * MSP audio in another operating system (eg Windows) first and then\n\t * do a soft reboot.\n\t */\n\n#ifndef BKTR_NO_MSP_RESET\n\tif (card == CARD_HAUPPAUGE) {\n            bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n        }\n#endif\n\n#if defined( OVERRIDE_MSP )\n\tbktr->card.msp3400c = OVERRIDE_MSP;\n\tgoto checkMSPEnd;\n#endif\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSPEnd;\n\t}\n\n\tif ( i2cRead( bktr, MSP3400C_RADDR ) != ABSENT )\n\t\tbktr->card.msp3400c = 1;\n\ncheckMSPEnd:\n\n/* Start of Check Remote */\n        /* Check for the Hauppauge IR Remote Control */\n        /* If there is an external unit, the internal will be ignored */\n\n        bktr->remote_control = 0; /* initial value */\n\n        if (any_i2c_devices) {\n            if (i2cRead( bktr, HAUP_REMOTE_EXT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_EXT_RADDR;\n                }\n            else if (i2cRead( bktr, HAUP_REMOTE_INT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_INT_RADDR;\n                }\n\n        }\n        /* If a remote control is found, poll it 5 times to turn off the LED */\n        if (bktr->remote_control) {\n                int i;\n                for (i=0; i<5; i++)\n                        i2cRead( bktr, bktr->remote_control_addr );\n        }\n/* End of Check Remote */\n\n#if defined( BKTR_USE_PLL )\n\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\tgoto checkPLLEnd;\n#endif\n\t/* Default is to use XTALS and not PLL mode */\n\tbktr->xtal_pll_mode = BT848_USE_XTALS;\n\n\t/* Enable PLL mode for PAL/SECAM users on Hauppauge 878 cards */\n\tif ((card == CARD_HAUPPAUGE) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\n\t/* Enable PLL mode for OSPREY users */\n\tif (card == CARD_OSPREY)\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\t/* Enable PLL mode for PAL/SECAM users on FlyVideo 878 cards */\n\tif ((card == CARD_FLYVIDEO) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n#if defined( BKTR_USE_PLL )\ncheckPLLEnd:\n#endif\n\n\n\tbktr->card.tuner_pllAddr = tuner_i2c_address;\n\n\tif ( verbose ) {\n\t\tprintf( \"%s\", bktr->card.name );\n\t\tif ( bktr->card.tuner )\n\t\t\tprintf( \", %s tuner\", bktr->card.tuner->name );\n\t\tif ( bktr->card.dbx )\n\t\t\tprintf( \", dbx stereo\" );\n\t\tif ( bktr->card.msp3400c )\n\t\t\tprintf( \", msp3400c stereo\" );\n                if ( bktr->remote_control )\n                        printf( \", remote control\" );\n\t\tprintf( \".\\n\" );\n\t}\n}"
  },
  {
    "function_name": "locate_eeprom_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5304-5309",
    "snippet": "static int locate_eeprom_address( bktr_ptr_t bktr) {\n  if (i2cRead( bktr, 0xa0) != ABSENT) return 0xa0;\n  if (i2cRead( bktr, 0xac) != ABSENT) return 0xac;\n  if (i2cRead( bktr, 0xae) != ABSENT) return 0xae;\n  return -1; /* no eeprom found */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define ABSENT\t\t(-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2cRead",
          "args": [
            "bktr",
            "0xae"
          ],
          "line": 5307
        },
        "resolved": true,
        "details": {
          "function_name": "i2cRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4896-4930",
          "snippet": "static int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ABSENT\t\t(-1)\n\nstatic int locate_eeprom_address( bktr_ptr_t bktr) {\n  if (i2cRead( bktr, 0xa0) != ABSENT) return 0xa0;\n  if (i2cRead( bktr, 0xac) != ABSENT) return 0xac;\n  if (i2cRead( bktr, 0xae) != ABSENT) return 0xae;\n  return -1; /* no eeprom found */\n}"
  },
  {
    "function_name": "locate_tuner_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5292-5298",
    "snippet": "static int locate_tuner_address( bktr_ptr_t bktr) {\n  if (i2cRead( bktr, 0xc1) != ABSENT) return 0xc0;\n  if (i2cRead( bktr, 0xc3) != ABSENT) return 0xc2;\n  if (i2cRead( bktr, 0xc5) != ABSENT) return 0xc4;\n  if (i2cRead( bktr, 0xc7) != ABSENT) return 0xc6;\n  return -1; /* no tuner found */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define ABSENT\t\t(-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2cRead",
          "args": [
            "bktr",
            "0xc7"
          ],
          "line": 5296
        },
        "resolved": true,
        "details": {
          "function_name": "i2cRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4896-4930",
          "snippet": "static int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ABSENT\t\t(-1)\n\nstatic int locate_tuner_address( bktr_ptr_t bktr) {\n  if (i2cRead( bktr, 0xc1) != ABSENT) return 0xc0;\n  if (i2cRead( bktr, 0xc3) != ABSENT) return 0xc2;\n  if (i2cRead( bktr, 0xc5) != ABSENT) return 0xc4;\n  if (i2cRead( bktr, 0xc7) != ABSENT) return 0xc6;\n  return -1; /* no tuner found */\n}"
  },
  {
    "function_name": "check_for_i2c_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5273-5285",
    "snippet": "static int check_for_i2c_devices( bktr_ptr_t bktr ){\n  int x, temp_read;\n  int i2c_all_0 = 1;\n  int i2c_all_absent = 1;\n  for ( x = 0; x < 128; ++x ) {\n    temp_read = i2cRead( bktr, (2 * x) + 1 );\n    if (temp_read != 0)      i2c_all_0 = 0;\n    if (temp_read != ABSENT) i2c_all_absent = 0;\n  }\n\n  if ((i2c_all_0) || (i2c_all_absent)) return 0;\n  else return 1;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define ABSENT\t\t(-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2cRead",
          "args": [
            "bktr",
            "(2 * x) + 1"
          ],
          "line": 5278
        },
        "resolved": true,
        "details": {
          "function_name": "i2cRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4896-4930",
          "snippet": "static int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ABSENT\t\t(-1)\n\nstatic int check_for_i2c_devices( bktr_ptr_t bktr ){\n  int x, temp_read;\n  int i2c_all_0 = 1;\n  int i2c_all_absent = 1;\n  for ( x = 0; x < 128; ++x ) {\n    temp_read = i2cRead( bktr, (2 * x) + 1 );\n    if (temp_read != 0)      i2c_all_0 = 0;\n    if (temp_read != ABSENT) i2c_all_absent = 0;\n  }\n\n  if ((i2c_all_0) || (i2c_all_absent)) return 0;\n  else return 1;\n}"
  },
  {
    "function_name": "signCard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5244-5259",
    "snippet": "static int\nsignCard( bktr_ptr_t bktr, int offset, int count, u_char* sig )\n{\n\tint\tx;\n\n\tfor ( x = 0; x < 16; ++x )\n\t\tsig[ x ] = 0;\n\n\tfor ( x = 0; x < count; ++x ) {\n\t\tif ( i2cRead( bktr, (2 * x) + 1 ) != ABSENT ) {\n\t\t\tsig[ x / 8 ] |= (1 << (x % 8) );\n\t\t}\n\t}\n\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define ABSENT\t\t(-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2cRead",
          "args": [
            "bktr",
            "(2 * x) + 1"
          ],
          "line": 5253
        },
        "resolved": true,
        "details": {
          "function_name": "i2cRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4896-4930",
          "snippet": "static int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ABSENT\t\t(-1)\n\nstatic int\nsignCard( bktr_ptr_t bktr, int offset, int count, u_char* sig )\n{\n\tint\tx;\n\n\tfor ( x = 0; x < 16; ++x )\n\t\tsig[ x ] = 0;\n\n\tfor ( x = 0; x < count; ++x ) {\n\t\tif ( i2cRead( bktr, (2 * x) + 1 ) != ABSENT ) {\n\t\t\tsig[ x / 8 ] |= (1 << (x % 8) );\n\t\t}\n\t}\n\n\treturn( 0 );\n}"
  },
  {
    "function_name": "readEEProm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5204-5233",
    "snippet": "static int\nreadEEProm( bktr_ptr_t bktr, int offset, int count, u_char *data )\n{\n\tint\tx;\n\tint\taddr;\n\tint\tmax;\n\tint\tbyte;\n\n\t/* get the address of the EEProm */\n\taddr = (int)(bktr->card.eepromAddr & 0xff);\n\tif ( addr == 0 )\n\t\treturn( -1 );\n\n\tmax = (int)(bktr->card.eepromSize * EEPROMBLOCKSIZE);\n\tif ( (offset + count) > max )\n\t\treturn( -1 );\n\n\t/* set the start address */\n\tif ( i2cWrite( bktr, addr, offset, -1 ) == -1 )\n\t\treturn( -1 );\n\n\t/* the read cycle */\n\tfor ( x = 0; x < count; ++x ) {\n\t\tif ( (byte = i2cRead( bktr, (addr | 1) )) == -1 )\n\t\t\treturn( -1 );\n\t\tdata[ x ] = byte;\n\t}\n\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2cRead",
          "args": [
            "bktr",
            "(addr | 1)"
          ],
          "line": 5227
        },
        "resolved": true,
        "details": {
          "function_name": "i2cRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4896-4930",
          "snippet": "static int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2cWrite",
          "args": [
            "bktr",
            "addr",
            "offset",
            "-1"
          ],
          "line": 5222
        },
        "resolved": true,
        "details": {
          "function_name": "i2cWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4850-4890",
          "snippet": "static int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
            "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nreadEEProm( bktr_ptr_t bktr, int offset, int count, u_char *data )\n{\n\tint\tx;\n\tint\taddr;\n\tint\tmax;\n\tint\tbyte;\n\n\t/* get the address of the EEProm */\n\taddr = (int)(bktr->card.eepromAddr & 0xff);\n\tif ( addr == 0 )\n\t\treturn( -1 );\n\n\tmax = (int)(bktr->card.eepromSize * EEPROMBLOCKSIZE);\n\tif ( (offset + count) > max )\n\t\treturn( -1 );\n\n\t/* set the start address */\n\tif ( i2cWrite( bktr, addr, offset, -1 ) == -1 )\n\t\treturn( -1 );\n\n\t/* the read cycle */\n\tfor ( x = 0; x < count; ++x ) {\n\t\tif ( (byte = i2cRead( bktr, (addr | 1) )) == -1 )\n\t\t\treturn( -1 );\n\t\tdata[ x ] = byte;\n\t}\n\n\treturn( 0 );\n}"
  },
  {
    "function_name": "writeEEProm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5194-5198",
    "snippet": "static int\nwriteEEProm( bktr_ptr_t bktr, int offset, int count, u_char *data )\n{\n\treturn( -1 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nwriteEEProm( bktr_ptr_t bktr, int offset, int count, u_char *data )\n{\n\treturn( -1 );\n}"
  },
  {
    "function_name": "i2cProbe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5136-5184",
    "snippet": "static int\ni2cProbe( bktr_ptr_t bktr, int addr )\n{\n\tint\t\tx, status;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* the START */\n#if defined( EXTRA_START )\n\tbt848->i2c_data_ctl = 1; DELAY( BITD );\t/* release data */\n\tbt848->i2c_data_ctl = 3; DELAY( BITD );\t/* release clock */\n#endif /* EXTRA_START */\n\tbt848->i2c_data_ctl = 2; DELAY( BITD );\t/* lower data */\n\tbt848->i2c_data_ctl = 0; DELAY( BITD );\t/* lower clock */\n\n\t/* write addr */\n\tfor ( x = 7; x >= 0; --x ) {\n\t\tif ( addr & (1<<x) ) {\n\t\t\tbt848->i2c_data_ctl = 1;\n\t\t\tDELAY( BITD );\t\t/* assert HI data */\n\t\t\tbt848->i2c_data_ctl = 3;\n\t\t\tDELAY( BITD );\t\t/* strobe clock */\n\t\t\tbt848->i2c_data_ctl = 1;\n\t\t\tDELAY( BITD );\t\t/* release clock */\n\t\t}\n\t\telse {\n\t\t\tbt848->i2c_data_ctl = 0;\n\t\t\tDELAY( BITD );\t\t/* assert LO data */\n\t\t\tbt848->i2c_data_ctl = 2;\n\t\t\tDELAY( BITD );\t\t/* strobe clock */\n\t\t\tbt848->i2c_data_ctl = 0;\n\t\t\tDELAY( BITD );\t\t/* release clock */\n\t\t}\n\t}\n\n\t/* look for an ACK */\n\tbt848->i2c_data_ctl = 1; DELAY( BITD );\t/* float data */\n\tbt848->i2c_data_ctl = 3; DELAY( BITD );\t/* strobe clock */\n\tstatus = bt848->i2c_data_ctl & 1;\t/* read the ACK bit */\n\tbt848->i2c_data_ctl = 1; DELAY( BITD );\t/* release clock */\n\n\t/* the STOP */\n\tbt848->i2c_data_ctl = 0; DELAY( BITD );\t/* lower clock & data */\n\tbt848->i2c_data_ctl = 2; DELAY( BITD );\t/* release clock */\n\tbt848->i2c_data_ctl = 3; DELAY( BITD );\t/* release data */\n\n\treturn( status );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define EXTRA_START",
      "#define BITD\t\t40",
      "#define BITD    40"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define EXTRA_START\n#define BITD\t\t40\n#define BITD    40\n\nstatic int\ni2cProbe( bktr_ptr_t bktr, int addr )\n{\n\tint\t\tx, status;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* the START */\n#if defined( EXTRA_START )\n\tbt848->i2c_data_ctl = 1; DELAY( BITD );\t/* release data */\n\tbt848->i2c_data_ctl = 3; DELAY( BITD );\t/* release clock */\n#endif /* EXTRA_START */\n\tbt848->i2c_data_ctl = 2; DELAY( BITD );\t/* lower data */\n\tbt848->i2c_data_ctl = 0; DELAY( BITD );\t/* lower clock */\n\n\t/* write addr */\n\tfor ( x = 7; x >= 0; --x ) {\n\t\tif ( addr & (1<<x) ) {\n\t\t\tbt848->i2c_data_ctl = 1;\n\t\t\tDELAY( BITD );\t\t/* assert HI data */\n\t\t\tbt848->i2c_data_ctl = 3;\n\t\t\tDELAY( BITD );\t\t/* strobe clock */\n\t\t\tbt848->i2c_data_ctl = 1;\n\t\t\tDELAY( BITD );\t\t/* release clock */\n\t\t}\n\t\telse {\n\t\t\tbt848->i2c_data_ctl = 0;\n\t\t\tDELAY( BITD );\t\t/* assert LO data */\n\t\t\tbt848->i2c_data_ctl = 2;\n\t\t\tDELAY( BITD );\t\t/* strobe clock */\n\t\t\tbt848->i2c_data_ctl = 0;\n\t\t\tDELAY( BITD );\t\t/* release clock */\n\t\t}\n\t}\n\n\t/* look for an ACK */\n\tbt848->i2c_data_ctl = 1; DELAY( BITD );\t/* float data */\n\tbt848->i2c_data_ctl = 3; DELAY( BITD );\t/* strobe clock */\n\tstatus = bt848->i2c_data_ctl & 1;\t/* read the ACK bit */\n\tbt848->i2c_data_ctl = 1; DELAY( BITD );\t/* release clock */\n\n\t/* the STOP */\n\tbt848->i2c_data_ctl = 0; DELAY( BITD );\t/* lower clock & data */\n\tbt848->i2c_data_ctl = 2; DELAY( BITD );\t/* release clock */\n\tbt848->i2c_data_ctl = 3; DELAY( BITD );\t/* release data */\n\n\treturn( status );\n}"
  },
  {
    "function_name": "remote_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5103-5114",
    "snippet": "static void remote_read(bktr_ptr_t bktr, struct bktr_remote *remote) {\n\n\t/* XXX errors ignored */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr,bktr->remote_control_addr);\n\ti2c_read_byte(bktr,&(remote->data[0]), 0);\n\ti2c_read_byte(bktr,&(remote->data[1]), 0);\n\ti2c_read_byte(bktr,&(remote->data[2]), 0);\n\ti2c_stop(bktr);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2c_stop",
          "args": [
            "bktr"
          ],
          "line": 5111
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4949-4956",
          "snippet": "static void i2c_stop( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock & data */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release data */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic void i2c_stop( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock & data */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release data */\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2c_read_byte",
          "args": [
            "bktr",
            "&(remote->data[2])",
            "0"
          ],
          "line": 5110
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_read_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4993-5031",
          "snippet": "static int i2c_read_byte( bktr_ptr_t bktr, unsigned char *data, int last ) {\n        int x;\n        int bit;\n        int byte = 0;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* read in the byte */\n        bt848->i2c_data_ctl = 1;\n        DELAY( BITD );                          /* float data */\n        for ( x = 7; x >= 0; --x ) {\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bit = bt848->i2c_data_ctl & 1;  /* read the data bit */\n                if ( bit ) byte |= (1<<x);\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        }\n        /* After reading the byte, send an ACK */\n        /* (unless that was the last byte, for which we send a NAK */\n        if (last) { /* send NAK - same a writing a 1 */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        } else { /* send ACK - same as writing a 0 */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 2;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* release clock */\n        }\n\n        *data=byte;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic int i2c_read_byte( bktr_ptr_t bktr, unsigned char *data, int last ) {\n        int x;\n        int bit;\n        int byte = 0;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* read in the byte */\n        bt848->i2c_data_ctl = 1;\n        DELAY( BITD );                          /* float data */\n        for ( x = 7; x >= 0; --x ) {\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bit = bt848->i2c_data_ctl & 1;  /* read the data bit */\n                if ( bit ) byte |= (1<<x);\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        }\n        /* After reading the byte, send an ACK */\n        /* (unless that was the last byte, for which we send a NAK */\n        if (last) { /* send NAK - same a writing a 1 */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        } else { /* send ACK - same as writing a 0 */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 2;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* release clock */\n        }\n\n        *data=byte;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2c_write_byte",
          "args": [
            "bktr",
            "bktr->remote_control_addr"
          ],
          "line": 5107
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_write_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4958-4991",
          "snippet": "static int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {\n        int x;\n        int status;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* write out the byte */\n        for ( x = 7; x >= 0; --x ) {\n                if ( data & (1<<x) ) {\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* assert HI data */\n                        bt848->i2c_data_ctl = 3;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* release clock */\n                }\n                else {\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* assert LO data */\n                        bt848->i2c_data_ctl = 2;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* release clock */\n                }\n        }\n\n        /* look for an ACK */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* float data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* strobe clock */\n        status = bt848->i2c_data_ctl & 1;       /* read the ACK bit */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release clock */\n\n        return( status );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {\n        int x;\n        int status;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* write out the byte */\n        for ( x = 7; x >= 0; --x ) {\n                if ( data & (1<<x) ) {\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* assert HI data */\n                        bt848->i2c_data_ctl = 3;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* release clock */\n                }\n                else {\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* assert LO data */\n                        bt848->i2c_data_ctl = 2;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* release clock */\n                }\n        }\n\n        /* look for an ACK */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* float data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* strobe clock */\n        status = bt848->i2c_data_ctl & 1;       /* read the ACK bit */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release clock */\n\n        return( status );\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2c_start",
          "args": [
            "bktr"
          ],
          "line": 5106
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4939-4947",
          "snippet": "static void i2c_start( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* lower data */\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic void i2c_start( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* lower data */\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic void remote_read(bktr_ptr_t bktr, struct bktr_remote *remote) {\n\n\t/* XXX errors ignored */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr,bktr->remote_control_addr);\n\ti2c_read_byte(bktr,&(remote->data[0]), 0);\n\ti2c_read_byte(bktr,&(remote->data[1]), 0);\n\ti2c_read_byte(bktr,&(remote->data[2]), 0);\n\ti2c_stop(bktr);\n\n\treturn;\n}"
  },
  {
    "function_name": "msp_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5080-5101",
    "snippet": "static void msp_reset( bktr_ptr_t bktr ) {\n\n#ifndef BKTR_NO_MSP_RESET\n\t/* put into reset mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x80);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n\n\t/* put back to operational mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n#endif\n\treturn;\n\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define MSP3400C_WADDR\t\t0x80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2c_stop",
          "args": [
            "bktr"
          ],
          "line": 5097
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4949-4956",
          "snippet": "static void i2c_stop( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock & data */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release data */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic void i2c_stop( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock & data */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release data */\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2c_write_byte",
          "args": [
            "bktr",
            "0x00"
          ],
          "line": 5096
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_write_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4958-4991",
          "snippet": "static int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {\n        int x;\n        int status;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* write out the byte */\n        for ( x = 7; x >= 0; --x ) {\n                if ( data & (1<<x) ) {\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* assert HI data */\n                        bt848->i2c_data_ctl = 3;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* release clock */\n                }\n                else {\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* assert LO data */\n                        bt848->i2c_data_ctl = 2;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* release clock */\n                }\n        }\n\n        /* look for an ACK */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* float data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* strobe clock */\n        status = bt848->i2c_data_ctl & 1;       /* read the ACK bit */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release clock */\n\n        return( status );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {\n        int x;\n        int status;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* write out the byte */\n        for ( x = 7; x >= 0; --x ) {\n                if ( data & (1<<x) ) {\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* assert HI data */\n                        bt848->i2c_data_ctl = 3;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* release clock */\n                }\n                else {\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* assert LO data */\n                        bt848->i2c_data_ctl = 2;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* release clock */\n                }\n        }\n\n        /* look for an ACK */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* float data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* strobe clock */\n        status = bt848->i2c_data_ctl & 1;       /* read the ACK bit */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release clock */\n\n        return( status );\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2c_start",
          "args": [
            "bktr"
          ],
          "line": 5092
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4939-4947",
          "snippet": "static void i2c_start( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* lower data */\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic void i2c_start( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* lower data */\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define MSP3400C_WADDR\t\t0x80\n\nstatic void msp_reset( bktr_ptr_t bktr ) {\n\n#ifndef BKTR_NO_MSP_RESET\n\t/* put into reset mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x80);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n\n\t/* put back to operational mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n#endif\n\treturn;\n\n}"
  },
  {
    "function_name": "msp_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5054-5074",
    "snippet": "static unsigned int msp_read(bktr_ptr_t bktr, unsigned char dev, unsigned int addr){\n\tunsigned int data;\n\tunsigned char addr_l, addr_h, data_1, data_2, dev_r ;\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdev_r = dev+1;\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr,MSP3400C_WADDR);\n\ti2c_write_byte(bktr,dev_r);\n\ti2c_write_byte(bktr,addr_h);\n\ti2c_write_byte(bktr,addr_l);\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr,MSP3400C_RADDR);\n\ti2c_read_byte(bktr,&data_1, 0);\n\ti2c_read_byte(bktr,&data_2, 1);\n\ti2c_stop(bktr);\n\tdata = (data_1<<8) | data_2;\n\treturn data;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define MSP3400C_RADDR\t\t0x81",
      "#define MSP3400C_WADDR\t\t0x80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2c_stop",
          "args": [
            "bktr"
          ],
          "line": 5071
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4949-4956",
          "snippet": "static void i2c_stop( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock & data */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release data */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic void i2c_stop( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock & data */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release data */\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2c_read_byte",
          "args": [
            "bktr",
            "&data_2",
            "1"
          ],
          "line": 5070
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_read_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4993-5031",
          "snippet": "static int i2c_read_byte( bktr_ptr_t bktr, unsigned char *data, int last ) {\n        int x;\n        int bit;\n        int byte = 0;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* read in the byte */\n        bt848->i2c_data_ctl = 1;\n        DELAY( BITD );                          /* float data */\n        for ( x = 7; x >= 0; --x ) {\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bit = bt848->i2c_data_ctl & 1;  /* read the data bit */\n                if ( bit ) byte |= (1<<x);\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        }\n        /* After reading the byte, send an ACK */\n        /* (unless that was the last byte, for which we send a NAK */\n        if (last) { /* send NAK - same a writing a 1 */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        } else { /* send ACK - same as writing a 0 */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 2;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* release clock */\n        }\n\n        *data=byte;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic int i2c_read_byte( bktr_ptr_t bktr, unsigned char *data, int last ) {\n        int x;\n        int bit;\n        int byte = 0;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* read in the byte */\n        bt848->i2c_data_ctl = 1;\n        DELAY( BITD );                          /* float data */\n        for ( x = 7; x >= 0; --x ) {\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bit = bt848->i2c_data_ctl & 1;  /* read the data bit */\n                if ( bit ) byte |= (1<<x);\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        }\n        /* After reading the byte, send an ACK */\n        /* (unless that was the last byte, for which we send a NAK */\n        if (last) { /* send NAK - same a writing a 1 */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        } else { /* send ACK - same as writing a 0 */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 2;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* release clock */\n        }\n\n        *data=byte;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2c_write_byte",
          "args": [
            "bktr",
            "MSP3400C_RADDR"
          ],
          "line": 5068
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_write_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4958-4991",
          "snippet": "static int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {\n        int x;\n        int status;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* write out the byte */\n        for ( x = 7; x >= 0; --x ) {\n                if ( data & (1<<x) ) {\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* assert HI data */\n                        bt848->i2c_data_ctl = 3;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* release clock */\n                }\n                else {\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* assert LO data */\n                        bt848->i2c_data_ctl = 2;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* release clock */\n                }\n        }\n\n        /* look for an ACK */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* float data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* strobe clock */\n        status = bt848->i2c_data_ctl & 1;       /* read the ACK bit */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release clock */\n\n        return( status );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {\n        int x;\n        int status;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* write out the byte */\n        for ( x = 7; x >= 0; --x ) {\n                if ( data & (1<<x) ) {\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* assert HI data */\n                        bt848->i2c_data_ctl = 3;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* release clock */\n                }\n                else {\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* assert LO data */\n                        bt848->i2c_data_ctl = 2;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* release clock */\n                }\n        }\n\n        /* look for an ACK */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* float data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* strobe clock */\n        status = bt848->i2c_data_ctl & 1;       /* read the ACK bit */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release clock */\n\n        return( status );\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2c_start",
          "args": [
            "bktr"
          ],
          "line": 5067
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4939-4947",
          "snippet": "static void i2c_start( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* lower data */\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic void i2c_start( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* lower data */\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define MSP3400C_RADDR\t\t0x81\n#define MSP3400C_WADDR\t\t0x80\n\nstatic unsigned int msp_read(bktr_ptr_t bktr, unsigned char dev, unsigned int addr){\n\tunsigned int data;\n\tunsigned char addr_l, addr_h, data_1, data_2, dev_r ;\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdev_r = dev+1;\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr,MSP3400C_WADDR);\n\ti2c_write_byte(bktr,dev_r);\n\ti2c_write_byte(bktr,addr_h);\n\ti2c_write_byte(bktr,addr_l);\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr,MSP3400C_RADDR);\n\ti2c_read_byte(bktr,&data_1, 0);\n\ti2c_read_byte(bktr,&data_2, 1);\n\ti2c_stop(bktr);\n\tdata = (data_1<<8) | data_2;\n\treturn data;\n}"
  },
  {
    "function_name": "msp_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "5035-5051",
    "snippet": "static void msp_write( bktr_ptr_t bktr, unsigned char dev, unsigned int addr, unsigned int data){\n\tunsigned int msp_w_addr = MSP3400C_WADDR;\n\tunsigned char addr_l, addr_h, data_h, data_l ;\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdata_h = (data >>8) & 0xff;\n\tdata_l = data & 0xff;\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, msp_w_addr);\n\ti2c_write_byte(bktr, dev);\n\ti2c_write_byte(bktr, addr_h);\n\ti2c_write_byte(bktr, addr_l);\n\ti2c_write_byte(bktr, data_h);\n\ti2c_write_byte(bktr, data_l);\n\ti2c_stop(bktr);\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define MSP3400C_WADDR\t\t0x80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i2c_stop",
          "args": [
            "bktr"
          ],
          "line": 5050
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4949-4956",
          "snippet": "static void i2c_stop( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock & data */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release data */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic void i2c_stop( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock & data */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release data */\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2c_write_byte",
          "args": [
            "bktr",
            "data_l"
          ],
          "line": 5049
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_write_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4958-4991",
          "snippet": "static int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {\n        int x;\n        int status;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* write out the byte */\n        for ( x = 7; x >= 0; --x ) {\n                if ( data & (1<<x) ) {\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* assert HI data */\n                        bt848->i2c_data_ctl = 3;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* release clock */\n                }\n                else {\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* assert LO data */\n                        bt848->i2c_data_ctl = 2;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* release clock */\n                }\n        }\n\n        /* look for an ACK */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* float data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* strobe clock */\n        status = bt848->i2c_data_ctl & 1;       /* read the ACK bit */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release clock */\n\n        return( status );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {\n        int x;\n        int status;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* write out the byte */\n        for ( x = 7; x >= 0; --x ) {\n                if ( data & (1<<x) ) {\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* assert HI data */\n                        bt848->i2c_data_ctl = 3;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* release clock */\n                }\n                else {\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* assert LO data */\n                        bt848->i2c_data_ctl = 2;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* release clock */\n                }\n        }\n\n        /* look for an ACK */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* float data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* strobe clock */\n        status = bt848->i2c_data_ctl & 1;       /* read the ACK bit */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release clock */\n\n        return( status );\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2c_start",
          "args": [
            "bktr"
          ],
          "line": 5043
        },
        "resolved": true,
        "details": {
          "function_name": "i2c_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4939-4947",
          "snippet": "static void i2c_start( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* lower data */\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BITD\t\t40",
            "#define BITD    40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic void i2c_start( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* lower data */\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define MSP3400C_WADDR\t\t0x80\n\nstatic void msp_write( bktr_ptr_t bktr, unsigned char dev, unsigned int addr, unsigned int data){\n\tunsigned int msp_w_addr = MSP3400C_WADDR;\n\tunsigned char addr_l, addr_h, data_h, data_l ;\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdata_h = (data >>8) & 0xff;\n\tdata_l = data & 0xff;\n\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, msp_w_addr);\n\ti2c_write_byte(bktr, dev);\n\ti2c_write_byte(bktr, addr_h);\n\ti2c_write_byte(bktr, addr_l);\n\ti2c_write_byte(bktr, data_h);\n\ti2c_write_byte(bktr, data_l);\n\ti2c_stop(bktr);\n}"
  },
  {
    "function_name": "i2c_read_byte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4993-5031",
    "snippet": "static int i2c_read_byte( bktr_ptr_t bktr, unsigned char *data, int last ) {\n        int x;\n        int bit;\n        int byte = 0;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* read in the byte */\n        bt848->i2c_data_ctl = 1;\n        DELAY( BITD );                          /* float data */\n        for ( x = 7; x >= 0; --x ) {\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bit = bt848->i2c_data_ctl & 1;  /* read the data bit */\n                if ( bit ) byte |= (1<<x);\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        }\n        /* After reading the byte, send an ACK */\n        /* (unless that was the last byte, for which we send a NAK */\n        if (last) { /* send NAK - same a writing a 1 */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        } else { /* send ACK - same as writing a 0 */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 2;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* release clock */\n        }\n\n        *data=byte;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BITD\t\t40",
      "#define BITD    40"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 5002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic int i2c_read_byte( bktr_ptr_t bktr, unsigned char *data, int last ) {\n        int x;\n        int bit;\n        int byte = 0;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* read in the byte */\n        bt848->i2c_data_ctl = 1;\n        DELAY( BITD );                          /* float data */\n        for ( x = 7; x >= 0; --x ) {\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bit = bt848->i2c_data_ctl & 1;  /* read the data bit */\n                if ( bit ) byte |= (1<<x);\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        }\n        /* After reading the byte, send an ACK */\n        /* (unless that was the last byte, for which we send a NAK */\n        if (last) { /* send NAK - same a writing a 1 */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 3;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 1;\n                DELAY( BITD );                  /* release clock */\n        } else { /* send ACK - same as writing a 0 */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* set data bit */\n                bt848->i2c_data_ctl = 2;\n                DELAY( BITD );                  /* strobe clock */\n                bt848->i2c_data_ctl = 0;\n                DELAY( BITD );                  /* release clock */\n        }\n\n        *data=byte;\n\treturn 0;\n}"
  },
  {
    "function_name": "i2c_write_byte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4958-4991",
    "snippet": "static int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {\n        int x;\n        int status;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* write out the byte */\n        for ( x = 7; x >= 0; --x ) {\n                if ( data & (1<<x) ) {\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* assert HI data */\n                        bt848->i2c_data_ctl = 3;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* release clock */\n                }\n                else {\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* assert LO data */\n                        bt848->i2c_data_ctl = 2;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* release clock */\n                }\n        }\n\n        /* look for an ACK */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* float data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* strobe clock */\n        status = bt848->i2c_data_ctl & 1;       /* read the ACK bit */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release clock */\n\n        return( status );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BITD\t\t40",
      "#define BITD    40"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic int i2c_write_byte( bktr_ptr_t bktr, unsigned char data) {\n        int x;\n        int status;\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        /* write out the byte */\n        for ( x = 7; x >= 0; --x ) {\n                if ( data & (1<<x) ) {\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* assert HI data */\n                        bt848->i2c_data_ctl = 3;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 1;\n                        DELAY( BITD );          /* release clock */\n                }\n                else {\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* assert LO data */\n                        bt848->i2c_data_ctl = 2;\n                        DELAY( BITD );          /* strobe clock */\n                        bt848->i2c_data_ctl = 0;\n                        DELAY( BITD );          /* release clock */\n                }\n        }\n\n        /* look for an ACK */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* float data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* strobe clock */\n        status = bt848->i2c_data_ctl & 1;       /* read the ACK bit */\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release clock */\n\n        return( status );\n}"
  },
  {
    "function_name": "i2c_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4949-4956",
    "snippet": "static void i2c_stop( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock & data */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release data */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BITD\t\t40",
      "#define BITD    40"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic void i2c_stop( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock & data */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release data */\n}"
  },
  {
    "function_name": "i2c_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4939-4947",
    "snippet": "static void i2c_start( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* lower data */\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BITD\t\t40",
      "#define BITD    40"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "BITD"
          ],
          "line": 4943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BITD\t\t40\n#define BITD    40\n\nstatic void i2c_start( bktr_ptr_t bktr) {\n        bt848_ptr_t     bt848;\n        bt848 = bktr->base;\n\n        bt848->i2c_data_ctl = 1; DELAY( BITD ); /* release data */\n        bt848->i2c_data_ctl = 3; DELAY( BITD ); /* release clock */\n        bt848->i2c_data_ctl = 2; DELAY( BITD ); /* lower data */\n        bt848->i2c_data_ctl = 0; DELAY( BITD ); /* lower clock */\n}"
  },
  {
    "function_name": "i2cRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4896-4930",
    "snippet": "static int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
      "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tu_long\t\tx;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* write the READ address */\n\t/* The Bt878 and Bt879  differed on the treatment of i2c commands */\n\t   \n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND;\n\t} else {\n\t  bt848->i2c_data_ctl = ((addr & 0xff) << 24) | I2C_COMMAND_878;\n\t}\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* it was a read */\n\treturn( (bt848->i2c_data_ctl >> 8) & 0xff );\n}"
  },
  {
    "function_name": "i2cWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4850-4890",
    "snippet": "static int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
      "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tu_long\t\tx;\n\tu_long\t\tdata;\n\tbt848_ptr_t\tbt848;\n\n\tbt848 = bktr->base;\n\n\t/* clear status bits */\n\tbt848->int_stat = (BT848_INT_RACK | BT848_INT_I2CDONE);\n\n\t/* build the command datum */\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A) {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND;\n\t} else {\n\t  data = ((addr & 0xff) << 24) | ((byte1 & 0xff) << 16) | I2C_COMMAND_878;\n\t}\n\tif ( byte2 != -1 ) {\n\t\tdata |= ((byte2 & 0xff) << 8);\n\t\tdata |= BT848_DATA_CTL_I2CW3B;\n\t}\n\n\t/* write the address and data */\n\tbt848->i2c_data_ctl = data;\n\n\t/* wait for completion */\n\tfor ( x = 0x7fffffff; x; --x ) {\t/* safety valve */\n\t\tif ( bt848->int_stat & BT848_INT_I2CDONE )\n\t\t\tbreak;\n\t}\n\n\t/* check for ACK */\n\tif ( !x || !(bt848->int_stat & BT848_INT_RACK) )\n\t\treturn( -1 );\n\n\t/* return OK */\n\treturn( 0 );\n}"
  },
  {
    "function_name": "remote_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4834-4843",
    "snippet": "static void remote_read(bktr_ptr_t bktr, struct bktr_remote *remote) {\n\tint read;\n\n\t/* XXX errors ignored */\n\tiicbus_start(IICBUS(bktr), bktr->remote_control_addr, 0 /* no timeout? */);\n\tiicbus_read(IICBUS(bktr),  remote->data, 3, &read, IIC_LAST_READ, 0);\n\tiicbus_stop(IICBUS(bktr));\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iicbus_stop",
          "args": [
            "IICBUS(bktr)"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_read",
          "args": [
            "IICBUS(bktr)",
            "remote->data",
            "3",
            "&read",
            "IIC_LAST_READ",
            "0"
          ],
          "line": 4839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_start",
          "args": [
            "IICBUS(bktr)",
            "bktr->remote_control_addr",
            "0/* no timeout? */"
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic void remote_read(bktr_ptr_t bktr, struct bktr_remote *remote) {\n\tint read;\n\n\t/* XXX errors ignored */\n\tiicbus_start(IICBUS(bktr), bktr->remote_control_addr, 0 /* no timeout? */);\n\tiicbus_read(IICBUS(bktr),  remote->data, 3, &read, IIC_LAST_READ, 0);\n\tiicbus_stop(IICBUS(bktr));\n\n\treturn;\n}"
  },
  {
    "function_name": "msp_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4812-4832",
    "snippet": "static void\nmsp_reset( bktr_ptr_t bktr )\n{\n\n#ifndef BKTR_NO_MSP_RESET\n\t/* put into reset mode */\n\tiicbus_start(IICBUS(bktr), MSP3400C_WADDR, 0 /* no timeout? */);\n\tiicbus_write_byte(IICBUS(bktr), 0x00, 0);\n\tiicbus_write_byte(IICBUS(bktr), 0x80, 0);\n\tiicbus_write_byte(IICBUS(bktr), 0x00, 0);\n\tiicbus_stop(IICBUS(bktr));\n\n\t/* put back to operational mode */\n\tiicbus_start(IICBUS(bktr), MSP3400C_WADDR, 0 /* no timeout? */);\n\tiicbus_write_byte(IICBUS(bktr), 0x00, 0);\n\tiicbus_write_byte(IICBUS(bktr), 0x00, 0);\n\tiicbus_write_byte(IICBUS(bktr), 0x00, 0);\n\tiicbus_stop(IICBUS(bktr));\n#endif\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define MSP3400C_WADDR\t\t0x80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iicbus_stop",
          "args": [
            "IICBUS(bktr)"
          ],
          "line": 4829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "0x00",
            "0"
          ],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "0x00",
            "0"
          ],
          "line": 4827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "0x00",
            "0"
          ],
          "line": 4826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_start",
          "args": [
            "IICBUS(bktr)",
            "MSP3400C_WADDR",
            "0/* no timeout? */"
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_stop",
          "args": [
            "IICBUS(bktr)"
          ],
          "line": 4822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "0x00",
            "0"
          ],
          "line": 4821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "0x80",
            "0"
          ],
          "line": 4820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "0x00",
            "0"
          ],
          "line": 4819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_start",
          "args": [
            "IICBUS(bktr)",
            "MSP3400C_WADDR",
            "0/* no timeout? */"
          ],
          "line": 4818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define MSP3400C_WADDR\t\t0x80\n\nstatic void\nmsp_reset( bktr_ptr_t bktr )\n{\n\n#ifndef BKTR_NO_MSP_RESET\n\t/* put into reset mode */\n\tiicbus_start(IICBUS(bktr), MSP3400C_WADDR, 0 /* no timeout? */);\n\tiicbus_write_byte(IICBUS(bktr), 0x00, 0);\n\tiicbus_write_byte(IICBUS(bktr), 0x80, 0);\n\tiicbus_write_byte(IICBUS(bktr), 0x00, 0);\n\tiicbus_stop(IICBUS(bktr));\n\n\t/* put back to operational mode */\n\tiicbus_start(IICBUS(bktr), MSP3400C_WADDR, 0 /* no timeout? */);\n\tiicbus_write_byte(IICBUS(bktr), 0x00, 0);\n\tiicbus_write_byte(IICBUS(bktr), 0x00, 0);\n\tiicbus_write_byte(IICBUS(bktr), 0x00, 0);\n\tiicbus_stop(IICBUS(bktr));\n#endif\n\treturn;\n}"
  },
  {
    "function_name": "msp_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4780-4806",
    "snippet": "static unsigned int\nmsp_read(bktr_ptr_t bktr, unsigned char dev, unsigned int addr)\n{\n\tunsigned int data;\n\tunsigned char addr_l, addr_h, dev_r;\n\tint read;\n\tu_char data_read[2];\n\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdev_r = dev+1;\n\n\t/* XXX errors ignored */\n\tiicbus_start(IICBUS(bktr), MSP3400C_WADDR, 0 /* no timeout? */);\n\n\tiicbus_write_byte(IICBUS(bktr), dev_r, 0);\n\tiicbus_write_byte(IICBUS(bktr), addr_h, 0);\n\tiicbus_write_byte(IICBUS(bktr), addr_l, 0);\n\n\tiicbus_repeated_start(IICBUS(bktr), MSP3400C_RADDR, 0 /* no timeout? */);\n\tiicbus_read(IICBUS(bktr), data_read, 2, &read, IIC_LAST_READ, 0);\n\tiicbus_stop(IICBUS(bktr));\n\n\tdata = (data_read[0]<<8) | data_read[1];\n\n\treturn (data);\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define MSP3400C_RADDR\t\t0x81",
      "#define MSP3400C_WADDR\t\t0x80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iicbus_stop",
          "args": [
            "IICBUS(bktr)"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_read",
          "args": [
            "IICBUS(bktr)",
            "data_read",
            "2",
            "&read",
            "IIC_LAST_READ",
            "0"
          ],
          "line": 4800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_repeated_start",
          "args": [
            "IICBUS(bktr)",
            "MSP3400C_RADDR",
            "0/* no timeout? */"
          ],
          "line": 4799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "addr_l",
            "0"
          ],
          "line": 4797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "addr_h",
            "0"
          ],
          "line": 4796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "dev_r",
            "0"
          ],
          "line": 4795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_start",
          "args": [
            "IICBUS(bktr)",
            "MSP3400C_WADDR",
            "0/* no timeout? */"
          ],
          "line": 4793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define MSP3400C_RADDR\t\t0x81\n#define MSP3400C_WADDR\t\t0x80\n\nstatic unsigned int\nmsp_read(bktr_ptr_t bktr, unsigned char dev, unsigned int addr)\n{\n\tunsigned int data;\n\tunsigned char addr_l, addr_h, dev_r;\n\tint read;\n\tu_char data_read[2];\n\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdev_r = dev+1;\n\n\t/* XXX errors ignored */\n\tiicbus_start(IICBUS(bktr), MSP3400C_WADDR, 0 /* no timeout? */);\n\n\tiicbus_write_byte(IICBUS(bktr), dev_r, 0);\n\tiicbus_write_byte(IICBUS(bktr), addr_h, 0);\n\tiicbus_write_byte(IICBUS(bktr), addr_l, 0);\n\n\tiicbus_repeated_start(IICBUS(bktr), MSP3400C_RADDR, 0 /* no timeout? */);\n\tiicbus_read(IICBUS(bktr), data_read, 2, &read, IIC_LAST_READ, 0);\n\tiicbus_stop(IICBUS(bktr));\n\n\tdata = (data_read[0]<<8) | data_read[1];\n\n\treturn (data);\n}"
  },
  {
    "function_name": "msp_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4756-4777",
    "snippet": "static void\nmsp_write(bktr_ptr_t bktr, unsigned char dev, unsigned int addr, unsigned int data)\n{\n\tunsigned char addr_l, addr_h, data_h, data_l ;\n\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdata_h = (data >>8) & 0xff;\n\tdata_l = data & 0xff;\n\n\tiicbus_start(IICBUS(bktr), MSP3400C_WADDR, 0 /* no timeout? */);\n\n\tiicbus_write_byte(IICBUS(bktr), dev, 0);\n\tiicbus_write_byte(IICBUS(bktr), addr_h, 0);\n\tiicbus_write_byte(IICBUS(bktr), addr_l, 0);\n\tiicbus_write_byte(IICBUS(bktr), data_h, 0);\n\tiicbus_write_byte(IICBUS(bktr), data_l, 0);\n\n\tiicbus_stop(IICBUS(bktr));\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define MSP3400C_WADDR\t\t0x80"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iicbus_stop",
          "args": [
            "IICBUS(bktr)"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "data_l",
            "0"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "data_h",
            "0"
          ],
          "line": 4771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "addr_l",
            "0"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "addr_h",
            "0"
          ],
          "line": 4769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_write_byte",
          "args": [
            "IICBUS(bktr)",
            "dev",
            "0"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iicbus_start",
          "args": [
            "IICBUS(bktr)",
            "MSP3400C_WADDR",
            "0/* no timeout? */"
          ],
          "line": 4766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IICBUS",
          "args": [
            "bktr"
          ],
          "line": 4766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define MSP3400C_WADDR\t\t0x80\n\nstatic void\nmsp_write(bktr_ptr_t bktr, unsigned char dev, unsigned int addr, unsigned int data)\n{\n\tunsigned char addr_l, addr_h, data_h, data_l ;\n\n\taddr_h = (addr >>8) & 0xff;\n\taddr_l = addr & 0xff;\n\tdata_h = (data >>8) & 0xff;\n\tdata_l = data & 0xff;\n\n\tiicbus_start(IICBUS(bktr), MSP3400C_WADDR, 0 /* no timeout? */);\n\n\tiicbus_write_byte(IICBUS(bktr), dev, 0);\n\tiicbus_write_byte(IICBUS(bktr), addr_h, 0);\n\tiicbus_write_byte(IICBUS(bktr), addr_l, 0);\n\tiicbus_write_byte(IICBUS(bktr), data_h, 0);\n\tiicbus_write_byte(IICBUS(bktr), data_l, 0);\n\n\tiicbus_stop(IICBUS(bktr));\n\n\treturn;\n}"
  },
  {
    "function_name": "i2cRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4730-4747",
    "snippet": "static int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tchar result;\n\tchar cmd;\n\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A)\n\t\tcmd = I2C_COMMAND;\n\telse\n\t\tcmd = I2C_COMMAND_878;\n\n\tif (smbus_readb(bktr->i2c_sc.smbus, addr, cmd, &result))\n\t\treturn (-1);\n\n\treturn ((int)((unsigned char)result));\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
      "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smbus_readb",
          "args": [
            "bktr->i2c_sc.smbus",
            "addr",
            "cmd",
            "&result"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cRead( bktr_ptr_t bktr, int addr )\n{\n\tchar result;\n\tchar cmd;\n\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A)\n\t\tcmd = I2C_COMMAND;\n\telse\n\t\tcmd = I2C_COMMAND_878;\n\n\tif (smbus_readb(bktr->i2c_sc.smbus, addr, cmd, &result))\n\t\treturn (-1);\n\n\treturn ((int)((unsigned char)result));\n}"
  },
  {
    "function_name": "i2cWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4704-4728",
    "snippet": "static int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tchar cmd;\n\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A)\n\t\tcmd = I2C_COMMAND;\n\telse\n\t\tcmd = I2C_COMMAND_878;\n\n\tif (byte2 != -1) {\n\t\tif (smbus_writew(bktr->i2c_sc.smbus, addr, cmd,\n\t\t\t(short)(((byte2 & 0xff) << 8) | (byte1 & 0xff))))\n\t\t\treturn (-1);\n\t} else {\n\t\tif (smbus_writeb(bktr->i2c_sc.smbus, addr, cmd,\n\t\t\t(char)(byte1 & 0xff)))\n\t\t\treturn (-1);\n\t}\n\n\t/* return OK */\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)",
      "#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smbus_writeb",
          "args": [
            "bktr->i2c_sc.smbus",
            "addr",
            "cmd",
            "(char)(byte1 & 0xff)"
          ],
          "line": 4721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smbus_writew",
          "args": [
            "bktr->i2c_sc.smbus",
            "addr",
            "cmd",
            "(short)(((byte2 & 0xff) << 8) | (byte1 & 0xff))"
          ],
          "line": 4717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define I2C_COMMAND_878\t\t(I2CBITTIME_878 |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n#define I2C_COMMAND\t\t(I2CBITTIME |\t\t\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSCL |\t\\\n\t\t\t\t BT848_DATA_CTL_I2CSDA)\n\nstatic int\ni2cWrite( bktr_ptr_t bktr, int addr, int byte1, int byte2 )\n{\n\tchar cmd;\n\n\tif (bktr->id == BROOKTREE_848  ||\n\t    bktr->id == BROOKTREE_848A ||\n\t    bktr->id == BROOKTREE_849A)\n\t\tcmd = I2C_COMMAND;\n\telse\n\t\tcmd = I2C_COMMAND_878;\n\n\tif (byte2 != -1) {\n\t\tif (smbus_writew(bktr->i2c_sc.smbus, addr, cmd,\n\t\t\t(short)(((byte2 & 0xff) << 8) | (byte1 & 0xff))))\n\t\t\treturn (-1);\n\t} else {\n\t\tif (smbus_writeb(bktr->i2c_sc.smbus, addr, cmd,\n\t\t\t(char)(byte1 & 0xff)))\n\t\t\treturn (-1);\n\t}\n\n\t/* return OK */\n\treturn( 0 );\n}"
  },
  {
    "function_name": "oformat_meteor_to_bt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4651-4680",
    "snippet": "static int oformat_meteor_to_bt( u_long format )\n{\n\tint    i;\n        struct meteor_pixfmt *pf1, *pf2;\n\n\t/*  Find format in compatibility table  */\n\tfor ( i = 0; i < METEOR_PIXFMT_TABLE_SIZE; i++ )\n\t\tif ( meteor_pixfmt_table[i].meteor_format == format )\n\t\t\tbreak;\n\n\tif ( i >= METEOR_PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\tpf1 = &meteor_pixfmt_table[i].public;\n\n\t/*  Match it with an entry in master pixel format table  */\n\tfor ( i = 0; i < PIXFMT_TABLE_SIZE; i++ ) {\n\t\tpf2 = &pixfmt_table[i].public;\n\n\t\tif (( pf1->type        == pf2->type        ) &&\n\t\t    ( pf1->Bpp         == pf2->Bpp         ) &&\n\t\t    !bcmp( pf1->masks, pf2->masks, sizeof( pf1->masks )) &&\n\t\t    ( pf1->swap_bytes  == pf2->swap_bytes  ) &&\n\t\t    ( pf1->swap_shorts == pf2->swap_shorts )) \n\t\t\tbreak;\n\t}\n\tif ( i >= PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\n\treturn i;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define METEOR_PIXFMT_TABLE_SIZE ( sizeof(meteor_pixfmt_table) / \\\n\t\t\t\t   sizeof(meteor_pixfmt_table[0]) )",
      "#define PIXFMT_TABLE_SIZE ( sizeof(pixfmt_table) / sizeof(pixfmt_table[0]) )"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "pf1->masks",
            "pf2->masks",
            "sizeof( pf1->masks )"
          ],
          "line": 4671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define METEOR_PIXFMT_TABLE_SIZE ( sizeof(meteor_pixfmt_table) / \\\n\t\t\t\t   sizeof(meteor_pixfmt_table[0]) )\n#define PIXFMT_TABLE_SIZE ( sizeof(pixfmt_table) / sizeof(pixfmt_table[0]) )\n\nstatic int oformat_meteor_to_bt( u_long format )\n{\n\tint    i;\n        struct meteor_pixfmt *pf1, *pf2;\n\n\t/*  Find format in compatibility table  */\n\tfor ( i = 0; i < METEOR_PIXFMT_TABLE_SIZE; i++ )\n\t\tif ( meteor_pixfmt_table[i].meteor_format == format )\n\t\t\tbreak;\n\n\tif ( i >= METEOR_PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\tpf1 = &meteor_pixfmt_table[i].public;\n\n\t/*  Match it with an entry in master pixel format table  */\n\tfor ( i = 0; i < PIXFMT_TABLE_SIZE; i++ ) {\n\t\tpf2 = &pixfmt_table[i].public;\n\n\t\tif (( pf1->type        == pf2->type        ) &&\n\t\t    ( pf1->Bpp         == pf2->Bpp         ) &&\n\t\t    !bcmp( pf1->masks, pf2->masks, sizeof( pf1->masks )) &&\n\t\t    ( pf1->swap_bytes  == pf2->swap_bytes  ) &&\n\t\t    ( pf1->swap_shorts == pf2->swap_shorts )) \n\t\t\tbreak;\n\t}\n\tif ( i >= PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\n\treturn i;\n}"
  },
  {
    "function_name": "pixfmt_swap_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4623-4642",
    "snippet": "static u_int pixfmt_swap_flags( int pixfmt )\n{\n\tstruct meteor_pixfmt *pf = &pixfmt_table[ pixfmt ].public;\n\tu_int\t\t      swapf = 0;\n\n\tswitch ( pf->Bpp ) {\n\tcase 2 : swapf = ( pf->swap_bytes ? 0 : BSWAP );\n\t\t break;\n\n\tcase 3 : /* no swaps supported for 3bpp - makes no sense w/ bt848 */\n\t\t break;\n\t\t \n\tcase 4 : if ( pf->swap_bytes )\n\t\t\tswapf = pf->swap_shorts ? 0 : WSWAP;\n\t\t else\n\t\t\tswapf = pf->swap_shorts ? BSWAP : (BSWAP | WSWAP);\n\t\t break;\n\t}\n\treturn swapf;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define WSWAP (BT848_COLOR_CTL_WSWAP_ODD | BT848_COLOR_CTL_WSWAP_EVEN)",
      "#define BSWAP (BT848_COLOR_CTL_BSWAP_ODD | BT848_COLOR_CTL_BSWAP_EVEN)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define WSWAP (BT848_COLOR_CTL_WSWAP_ODD | BT848_COLOR_CTL_WSWAP_EVEN)\n#define BSWAP (BT848_COLOR_CTL_BSWAP_ODD | BT848_COLOR_CTL_BSWAP_EVEN)\n\nstatic u_int pixfmt_swap_flags( int pixfmt )\n{\n\tstruct meteor_pixfmt *pf = &pixfmt_table[ pixfmt ].public;\n\tu_int\t\t      swapf = 0;\n\n\tswitch ( pf->Bpp ) {\n\tcase 2 : swapf = ( pf->swap_bytes ? 0 : BSWAP );\n\t\t break;\n\n\tcase 3 : /* no swaps supported for 3bpp - makes no sense w/ bt848 */\n\t\t break;\n\t\t \n\tcase 4 : if ( pf->swap_bytes )\n\t\t\tswapf = pf->swap_shorts ? 0 : WSWAP;\n\t\t else\n\t\t\tswapf = pf->swap_shorts ? BSWAP : (BSWAP | WSWAP);\n\t\t break;\n\t}\n\treturn swapf;\n}"
  },
  {
    "function_name": "set_fps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4567-4605",
    "snippet": "static void\nset_fps( bktr_ptr_t bktr, u_short fps )\n{\n\tbt848_ptr_t\tbt848;\n\tstruct format_params\t*fp;\n\tint i_flag;\n\n\tfp = &format_params[bktr->format_params];\n\n\tbt848 = bktr->base;\n\n\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\ti_flag = 1;\n\t\tbreak;\n\tcase METEOR_ONLY_ODD_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\ti_flag = 1;\n\t\tbreak;\n\tdefault:\n\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\ti_flag = 2;\n\t\tbreak;\n\t}\n\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\tbktr->fps = fps;\n\tbt848->tdec = 0;\n\n\tif (fps < fp->frame_rate)\n\t\tbt848->tdec = i_flag*(fp->frame_rate - fps) & 0x3f;\n\telse\n\t\tbt848->tdec = 0;\n\treturn;\n\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define ALL_INTS_CLEARED\t0xffffffff",
      "#define FIFO_RISC_DISABLED\t0"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALL_INTS_CLEARED\t0xffffffff\n#define FIFO_RISC_DISABLED\t0\n\nstatic void\nset_fps( bktr_ptr_t bktr, u_short fps )\n{\n\tbt848_ptr_t\tbt848;\n\tstruct format_params\t*fp;\n\tint i_flag;\n\n\tfp = &format_params[bktr->format_params];\n\n\tbt848 = bktr->base;\n\n\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\ti_flag = 1;\n\t\tbreak;\n\tcase METEOR_ONLY_ODD_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\ti_flag = 1;\n\t\tbreak;\n\tdefault:\n\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\ti_flag = 2;\n\t\tbreak;\n\t}\n\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\tbktr->fps = fps;\n\tbt848->tdec = 0;\n\n\tif (fps < fp->frame_rate)\n\t\tbt848->tdec = i_flag*(fp->frame_rate - fps) & 0x3f;\n\telse\n\t\tbt848->tdec = 0;\n\treturn;\n\n}"
  },
  {
    "function_name": "start_capture",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4505-4561",
    "snippet": "static void\nstart_capture( bktr_ptr_t bktr, unsigned type )\n{\n\tbt848_ptr_t\t\tbt848;\n\tu_char\t\t\ti_flag;\n\tstruct format_params   *fp;\n\n\tfp = &format_params[bktr->format_params];\n\n\t/*  If requested, clear out capture buf first  */\n\tif (bktr->clr_on_start && (bktr->video.addr == 0)) {\n\t\tbzero((caddr_t)bktr->bigbuf, \n\t\t      (size_t)bktr->rows * bktr->cols * bktr->frames *\n\t\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp);\n\t}\n\n\tbt848 = bktr->base;\n\n\tbt848->dstatus = 0;\n\tbt848->int_stat = bt848->int_stat;\n\n\tbktr->flags |= type;\n\tbktr->flags &= ~METEOR_WANT_MASK;\n\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\ti_flag = 1;\n\t\tbreak;\n\tcase METEOR_ONLY_ODD_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\ti_flag = 2;\n\t\tbreak;\n\tdefault:\n\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\ti_flag = 3;\n\t\tbreak;\n\t}\n\n\t/*  TDEC is only valid for continuous captures  */\n\tif ( type == METEOR_SINGLE ) {\n\t\tu_short\tfps_save = bktr->fps;\n\n\t\tset_fps(bktr, fp->frame_rate);\n\t\tbktr->fps = fps_save;\n\t}\n\telse\n\t\tset_fps(bktr, bktr->fps);\n\n\tif (bktr->dma_prog_loaded == FALSE) {\n\t\tbuild_dma_prog(bktr, i_flag);\n\t\tbktr->dma_prog_loaded = TRUE;\n\t}\n\t\n\n\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_dma_prog",
          "args": [
            "bktr",
            "i_flag"
          ],
          "line": 4554
        },
        "resolved": true,
        "details": {
          "function_name": "build_dma_prog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4299-4494",
          "snippet": "static void\nbuild_dma_prog( bktr_ptr_t bktr, char i_flag )\n{\n\tint\t\t\trows, cols,  interlace;\n\tbt848_ptr_t\t\tbt848;\n\tint\t\t\ttmp_int;\n\tunsigned int\t\ttemp;\t\n\tstruct format_params\t*fp;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\t\n\n\tfp = &format_params[bktr->format_params];\n\t\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t/* disable FIFO & RISC, leave other bits alone */\n\tbt848->gpio_dma_ctl &= ~FIFO_RISC_ENABLED;\n\n\t/* set video parameters */\n\tif (bktr->capture_area_enabled)\n\t  temp = ((quad_t ) fp->htotal* (quad_t) bktr->capture_area_x_size * 4096\n\t\t  / fp->scaled_htotal / bktr->cols) -  4096;\n\telse\n\t  temp = ((quad_t ) fp->htotal* (quad_t) fp->scaled_hactive * 4096\n\t\t  / fp->scaled_htotal / bktr->cols) -  4096;\n\n\t /* printf(\"HSCALE value is %d\\n\",temp); */\n\tbt848->e_hscale_lo = temp & 0xff;\n\tbt848->o_hscale_lo = temp & 0xff;\n\tbt848->e_hscale_hi = (temp >> 8) & 0xff;\n\tbt848->o_hscale_hi = (temp >> 8) & 0xff;\n \n\t/* horizontal active */\n\ttemp = bktr->cols;\n\t/* printf(\"HACTIVE value is %d\\n\",temp); */\n\tbt848->e_hactive_lo = temp & 0xff;\n\tbt848->o_hactive_lo = temp & 0xff;\n\tbt848->e_crop &= ~0x3;\n\tbt848->o_crop  &= ~0x3;\n\tbt848->e_crop |= (temp >> 8) & 0x3;\n\tbt848->o_crop  |= (temp >> 8) & 0x3;\n \n\t/* horizontal delay */\n\tif (bktr->capture_area_enabled)\n\t  temp = ( (fp->hdelay* fp->scaled_hactive + bktr->capture_area_x_offset* fp->scaled_htotal)\n\t\t * bktr->cols) / (bktr->capture_area_x_size * fp->hactive);\n\telse\n\t  temp = (fp->hdelay * bktr->cols) / fp->hactive;\n\n\ttemp = temp & 0x3fe;\n\n\t/* printf(\"HDELAY value is %d\\n\",temp); */\n\tbt848->e_delay_lo = temp & 0xff;\n\tbt848->o_delay_lo = temp & 0xff;\n\tbt848->e_crop &= ~0xc;\n\tbt848->o_crop &= ~0xc;\n\tbt848->e_crop |= (temp >> 6) & 0xc;\n\tbt848->o_crop |= (temp >> 6) & 0xc;\n\n\t/* vertical scale */\n\n\tif (bktr->capture_area_enabled) {\n\t  if (bktr->flags  & METEOR_ONLY_ODD_FIELDS ||\n\t      bktr->flags & METEOR_ONLY_EVEN_FIELDS)\n\t    tmp_int = 65536 -\n\t    (((bktr->capture_area_y_size  * 256 + (bktr->rows/2)) / bktr->rows) - 512);\n\t  else {\n\t    tmp_int = 65536 -\n\t    (((bktr->capture_area_y_size * 512 + (bktr->rows / 2)) /  bktr->rows) - 512);\n\t  }\n\t} else {\n\t  if (bktr->flags  & METEOR_ONLY_ODD_FIELDS ||\n\t      bktr->flags & METEOR_ONLY_EVEN_FIELDS)\n\t    tmp_int = 65536 -\n\t    (((fp->vactive  * 256 + (bktr->rows/2)) / bktr->rows) - 512);\n\t  else {\n\t    tmp_int = 65536  -\n\t    (((fp->vactive * 512 + (bktr->rows / 2)) /  bktr->rows) - 512);\n\t  }\n\t}\n\n\ttmp_int &= 0x1fff;\n\t/* printf(\"VSCALE value is %d\\n\",tmp_int); */\n\tbt848->e_vscale_lo = tmp_int & 0xff;\n\tbt848->o_vscale_lo = tmp_int & 0xff;\n\tbt848->e_vscale_hi &= ~0x1f;\n\tbt848->o_vscale_hi &= ~0x1f;\n\tbt848->e_vscale_hi |= (tmp_int >> 8) & 0x1f;\n\tbt848->o_vscale_hi |= (tmp_int >> 8) & 0x1f;\n\n \n\t/* vertical active */\n\tif (bktr->capture_area_enabled)\n\t  temp = bktr->capture_area_y_size;\n\telse\n\t  temp = fp->vactive;\n\t/* printf(\"VACTIVE is %d\\n\",temp); */\n\tbt848->e_crop &= ~0x30;\n\tbt848->e_crop |= (temp >> 4) & 0x30;\n\tbt848->e_vactive_lo = temp & 0xff;\n\tbt848->o_crop &= ~0x30;\n\tbt848->o_crop |= (temp >> 4) & 0x30;\n\tbt848->o_vactive_lo = temp & 0xff;\n \n\t/* vertical delay */\n\tif (bktr->capture_area_enabled)\n\t  temp = fp->vdelay + (bktr->capture_area_y_offset);\n\telse\n\t  temp = fp->vdelay;\n\t/* printf(\"VDELAY is %d\\n\",temp); */\n\tbt848->e_crop &= ~0xC0;\n\tbt848->e_crop |= (temp >> 2) & 0xC0;\n\tbt848->e_vdelay_lo = temp & 0xff;\n\tbt848->o_crop &= ~0xC0;\n\tbt848->o_crop |= (temp >> 2) & 0xC0;\n\tbt848->o_vdelay_lo = temp & 0xff;\n\n\t/* end of video params */\n\n\tif ((bktr->xtal_pll_mode == BT848_USE_PLL)\n\t   && (fp->iform_xtsel==BT848_IFORM_X_XT1)) {\n\t\tbt848->tgctrl=8; /* Select PLL mode */\n\t} else {\n\t\tbt848->tgctrl=0; /* Select Normal xtal 0/xtal 1 mode */\n\t}\n\n\t/* capture control */\n\tswitch (i_flag) {\n\tcase 1:\n\t        bktr->bktr_cap_ctl = \n\t\t    (BT848_CAP_CTL_DITH_FRAME | BT848_CAP_CTL_EVEN);\n\t\tbt848->e_vscale_hi &= ~0x20;\n\t\tbt848->o_vscale_hi &= ~0x20;\n\t\tinterlace = 1;\n\t\tbreak;\n\t case 2:\n \t        bktr->bktr_cap_ctl =\n\t\t\t(BT848_CAP_CTL_DITH_FRAME | BT848_CAP_CTL_ODD);\n\t\tbt848->e_vscale_hi &= ~0x20;\n\t\tbt848->o_vscale_hi &= ~0x20;\n\t\tinterlace = 1;\n\t\tbreak;\n\t default:\n \t        bktr->bktr_cap_ctl = \n\t\t\t(BT848_CAP_CTL_DITH_FRAME |\n\t\t\t BT848_CAP_CTL_EVEN | BT848_CAP_CTL_ODD);\n\t\tbt848->e_vscale_hi |= 0x20;\n\t\tbt848->o_vscale_hi |= 0x20;\n\t\tinterlace = 2;\n\t\tbreak;\n\t}\n\n\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\n\trows = bktr->rows;\n\tcols = bktr->cols;\n\n\tbktr->vbiflags &= ~VBI_CAPTURE;\t/* default - no vbi capture */\n\n\t/* If /dev/vbi is already open, then use the rgb_vbi RISC program */\n\tif ( (pf_int->public.type == METEOR_PIXTYPE_RGB)\n           &&(bktr->vbiflags & VBI_OPEN) ) {\n\t\tif (i_flag==1) bktr->bktr_cap_ctl |= BT848_CAP_CTL_VBI_EVEN;\n\t\tif (i_flag==2) bktr->bktr_cap_ctl |= BT848_CAP_CTL_VBI_ODD;\n\t\tif (i_flag==3) bktr->bktr_cap_ctl |=\n\t\t                BT848_CAP_CTL_VBI_EVEN | BT848_CAP_CTL_VBI_ODD;\n\t\tbktr->vbiflags |= VBI_CAPTURE;\n\t\trgb_vbi_prog(bktr, i_flag, cols, rows, interlace);\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type == METEOR_PIXTYPE_RGB ) {\n\t\trgb_prog(bktr, i_flag, cols, rows, interlace);\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV ) {\n\t\tyuv422_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV_PACKED ) {\n\t\tyuvpack_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV_12 ) {\n\t\tyuv12_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ALL_INTS_DISABLED\t0",
            "#define FIFO_RISC_ENABLED\t(BT848_DMA_CTL_FIFO_EN | BT848_DMA_CTL_RISC_EN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_ENABLED\t(BT848_DMA_CTL_FIFO_EN | BT848_DMA_CTL_RISC_EN)\n\nstatic void\nbuild_dma_prog( bktr_ptr_t bktr, char i_flag )\n{\n\tint\t\t\trows, cols,  interlace;\n\tbt848_ptr_t\t\tbt848;\n\tint\t\t\ttmp_int;\n\tunsigned int\t\ttemp;\t\n\tstruct format_params\t*fp;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\t\n\n\tfp = &format_params[bktr->format_params];\n\t\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t/* disable FIFO & RISC, leave other bits alone */\n\tbt848->gpio_dma_ctl &= ~FIFO_RISC_ENABLED;\n\n\t/* set video parameters */\n\tif (bktr->capture_area_enabled)\n\t  temp = ((quad_t ) fp->htotal* (quad_t) bktr->capture_area_x_size * 4096\n\t\t  / fp->scaled_htotal / bktr->cols) -  4096;\n\telse\n\t  temp = ((quad_t ) fp->htotal* (quad_t) fp->scaled_hactive * 4096\n\t\t  / fp->scaled_htotal / bktr->cols) -  4096;\n\n\t /* printf(\"HSCALE value is %d\\n\",temp); */\n\tbt848->e_hscale_lo = temp & 0xff;\n\tbt848->o_hscale_lo = temp & 0xff;\n\tbt848->e_hscale_hi = (temp >> 8) & 0xff;\n\tbt848->o_hscale_hi = (temp >> 8) & 0xff;\n \n\t/* horizontal active */\n\ttemp = bktr->cols;\n\t/* printf(\"HACTIVE value is %d\\n\",temp); */\n\tbt848->e_hactive_lo = temp & 0xff;\n\tbt848->o_hactive_lo = temp & 0xff;\n\tbt848->e_crop &= ~0x3;\n\tbt848->o_crop  &= ~0x3;\n\tbt848->e_crop |= (temp >> 8) & 0x3;\n\tbt848->o_crop  |= (temp >> 8) & 0x3;\n \n\t/* horizontal delay */\n\tif (bktr->capture_area_enabled)\n\t  temp = ( (fp->hdelay* fp->scaled_hactive + bktr->capture_area_x_offset* fp->scaled_htotal)\n\t\t * bktr->cols) / (bktr->capture_area_x_size * fp->hactive);\n\telse\n\t  temp = (fp->hdelay * bktr->cols) / fp->hactive;\n\n\ttemp = temp & 0x3fe;\n\n\t/* printf(\"HDELAY value is %d\\n\",temp); */\n\tbt848->e_delay_lo = temp & 0xff;\n\tbt848->o_delay_lo = temp & 0xff;\n\tbt848->e_crop &= ~0xc;\n\tbt848->o_crop &= ~0xc;\n\tbt848->e_crop |= (temp >> 6) & 0xc;\n\tbt848->o_crop |= (temp >> 6) & 0xc;\n\n\t/* vertical scale */\n\n\tif (bktr->capture_area_enabled) {\n\t  if (bktr->flags  & METEOR_ONLY_ODD_FIELDS ||\n\t      bktr->flags & METEOR_ONLY_EVEN_FIELDS)\n\t    tmp_int = 65536 -\n\t    (((bktr->capture_area_y_size  * 256 + (bktr->rows/2)) / bktr->rows) - 512);\n\t  else {\n\t    tmp_int = 65536 -\n\t    (((bktr->capture_area_y_size * 512 + (bktr->rows / 2)) /  bktr->rows) - 512);\n\t  }\n\t} else {\n\t  if (bktr->flags  & METEOR_ONLY_ODD_FIELDS ||\n\t      bktr->flags & METEOR_ONLY_EVEN_FIELDS)\n\t    tmp_int = 65536 -\n\t    (((fp->vactive  * 256 + (bktr->rows/2)) / bktr->rows) - 512);\n\t  else {\n\t    tmp_int = 65536  -\n\t    (((fp->vactive * 512 + (bktr->rows / 2)) /  bktr->rows) - 512);\n\t  }\n\t}\n\n\ttmp_int &= 0x1fff;\n\t/* printf(\"VSCALE value is %d\\n\",tmp_int); */\n\tbt848->e_vscale_lo = tmp_int & 0xff;\n\tbt848->o_vscale_lo = tmp_int & 0xff;\n\tbt848->e_vscale_hi &= ~0x1f;\n\tbt848->o_vscale_hi &= ~0x1f;\n\tbt848->e_vscale_hi |= (tmp_int >> 8) & 0x1f;\n\tbt848->o_vscale_hi |= (tmp_int >> 8) & 0x1f;\n\n \n\t/* vertical active */\n\tif (bktr->capture_area_enabled)\n\t  temp = bktr->capture_area_y_size;\n\telse\n\t  temp = fp->vactive;\n\t/* printf(\"VACTIVE is %d\\n\",temp); */\n\tbt848->e_crop &= ~0x30;\n\tbt848->e_crop |= (temp >> 4) & 0x30;\n\tbt848->e_vactive_lo = temp & 0xff;\n\tbt848->o_crop &= ~0x30;\n\tbt848->o_crop |= (temp >> 4) & 0x30;\n\tbt848->o_vactive_lo = temp & 0xff;\n \n\t/* vertical delay */\n\tif (bktr->capture_area_enabled)\n\t  temp = fp->vdelay + (bktr->capture_area_y_offset);\n\telse\n\t  temp = fp->vdelay;\n\t/* printf(\"VDELAY is %d\\n\",temp); */\n\tbt848->e_crop &= ~0xC0;\n\tbt848->e_crop |= (temp >> 2) & 0xC0;\n\tbt848->e_vdelay_lo = temp & 0xff;\n\tbt848->o_crop &= ~0xC0;\n\tbt848->o_crop |= (temp >> 2) & 0xC0;\n\tbt848->o_vdelay_lo = temp & 0xff;\n\n\t/* end of video params */\n\n\tif ((bktr->xtal_pll_mode == BT848_USE_PLL)\n\t   && (fp->iform_xtsel==BT848_IFORM_X_XT1)) {\n\t\tbt848->tgctrl=8; /* Select PLL mode */\n\t} else {\n\t\tbt848->tgctrl=0; /* Select Normal xtal 0/xtal 1 mode */\n\t}\n\n\t/* capture control */\n\tswitch (i_flag) {\n\tcase 1:\n\t        bktr->bktr_cap_ctl = \n\t\t    (BT848_CAP_CTL_DITH_FRAME | BT848_CAP_CTL_EVEN);\n\t\tbt848->e_vscale_hi &= ~0x20;\n\t\tbt848->o_vscale_hi &= ~0x20;\n\t\tinterlace = 1;\n\t\tbreak;\n\t case 2:\n \t        bktr->bktr_cap_ctl =\n\t\t\t(BT848_CAP_CTL_DITH_FRAME | BT848_CAP_CTL_ODD);\n\t\tbt848->e_vscale_hi &= ~0x20;\n\t\tbt848->o_vscale_hi &= ~0x20;\n\t\tinterlace = 1;\n\t\tbreak;\n\t default:\n \t        bktr->bktr_cap_ctl = \n\t\t\t(BT848_CAP_CTL_DITH_FRAME |\n\t\t\t BT848_CAP_CTL_EVEN | BT848_CAP_CTL_ODD);\n\t\tbt848->e_vscale_hi |= 0x20;\n\t\tbt848->o_vscale_hi |= 0x20;\n\t\tinterlace = 2;\n\t\tbreak;\n\t}\n\n\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\n\trows = bktr->rows;\n\tcols = bktr->cols;\n\n\tbktr->vbiflags &= ~VBI_CAPTURE;\t/* default - no vbi capture */\n\n\t/* If /dev/vbi is already open, then use the rgb_vbi RISC program */\n\tif ( (pf_int->public.type == METEOR_PIXTYPE_RGB)\n           &&(bktr->vbiflags & VBI_OPEN) ) {\n\t\tif (i_flag==1) bktr->bktr_cap_ctl |= BT848_CAP_CTL_VBI_EVEN;\n\t\tif (i_flag==2) bktr->bktr_cap_ctl |= BT848_CAP_CTL_VBI_ODD;\n\t\tif (i_flag==3) bktr->bktr_cap_ctl |=\n\t\t                BT848_CAP_CTL_VBI_EVEN | BT848_CAP_CTL_VBI_ODD;\n\t\tbktr->vbiflags |= VBI_CAPTURE;\n\t\trgb_vbi_prog(bktr, i_flag, cols, rows, interlace);\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type == METEOR_PIXTYPE_RGB ) {\n\t\trgb_prog(bktr, i_flag, cols, rows, interlace);\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV ) {\n\t\tyuv422_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV_PACKED ) {\n\t\tyuvpack_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV_12 ) {\n\t\tyuv12_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fps",
          "args": [
            "bktr",
            "bktr->fps"
          ],
          "line": 4551
        },
        "resolved": true,
        "details": {
          "function_name": "set_fps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4567-4605",
          "snippet": "static void\nset_fps( bktr_ptr_t bktr, u_short fps )\n{\n\tbt848_ptr_t\tbt848;\n\tstruct format_params\t*fp;\n\tint i_flag;\n\n\tfp = &format_params[bktr->format_params];\n\n\tbt848 = bktr->base;\n\n\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\ti_flag = 1;\n\t\tbreak;\n\tcase METEOR_ONLY_ODD_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\ti_flag = 1;\n\t\tbreak;\n\tdefault:\n\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\ti_flag = 2;\n\t\tbreak;\n\t}\n\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\tbktr->fps = fps;\n\tbt848->tdec = 0;\n\n\tif (fps < fp->frame_rate)\n\t\tbt848->tdec = i_flag*(fp->frame_rate - fps) & 0x3f;\n\telse\n\t\tbt848->tdec = 0;\n\treturn;\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ALL_INTS_CLEARED\t0xffffffff",
            "#define FIFO_RISC_DISABLED\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALL_INTS_CLEARED\t0xffffffff\n#define FIFO_RISC_DISABLED\t0\n\nstatic void\nset_fps( bktr_ptr_t bktr, u_short fps )\n{\n\tbt848_ptr_t\tbt848;\n\tstruct format_params\t*fp;\n\tint i_flag;\n\n\tfp = &format_params[bktr->format_params];\n\n\tbt848 = bktr->base;\n\n\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\ti_flag = 1;\n\t\tbreak;\n\tcase METEOR_ONLY_ODD_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\ti_flag = 1;\n\t\tbreak;\n\tdefault:\n\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\ti_flag = 2;\n\t\tbreak;\n\t}\n\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\tbktr->fps = fps;\n\tbt848->tdec = 0;\n\n\tif (fps < fp->frame_rate)\n\t\tbt848->tdec = i_flag*(fp->frame_rate - fps) & 0x3f;\n\telse\n\t\tbt848->tdec = 0;\n\treturn;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t)bktr->bigbuf",
            "(size_t)bktr->rows * bktr->cols * bktr->frames *\n\t\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp"
          ],
          "line": 4516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic void\nstart_capture( bktr_ptr_t bktr, unsigned type )\n{\n\tbt848_ptr_t\t\tbt848;\n\tu_char\t\t\ti_flag;\n\tstruct format_params   *fp;\n\n\tfp = &format_params[bktr->format_params];\n\n\t/*  If requested, clear out capture buf first  */\n\tif (bktr->clr_on_start && (bktr->video.addr == 0)) {\n\t\tbzero((caddr_t)bktr->bigbuf, \n\t\t      (size_t)bktr->rows * bktr->cols * bktr->frames *\n\t\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp);\n\t}\n\n\tbt848 = bktr->base;\n\n\tbt848->dstatus = 0;\n\tbt848->int_stat = bt848->int_stat;\n\n\tbktr->flags |= type;\n\tbktr->flags &= ~METEOR_WANT_MASK;\n\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\ti_flag = 1;\n\t\tbreak;\n\tcase METEOR_ONLY_ODD_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\ti_flag = 2;\n\t\tbreak;\n\tdefault:\n\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\ti_flag = 3;\n\t\tbreak;\n\t}\n\n\t/*  TDEC is only valid for continuous captures  */\n\tif ( type == METEOR_SINGLE ) {\n\t\tu_short\tfps_save = bktr->fps;\n\n\t\tset_fps(bktr, fp->frame_rate);\n\t\tbktr->fps = fps_save;\n\t}\n\telse\n\t\tset_fps(bktr, bktr->fps);\n\n\tif (bktr->dma_prog_loaded == FALSE) {\n\t\tbuild_dma_prog(bktr, i_flag);\n\t\tbktr->dma_prog_loaded = TRUE;\n\t}\n\t\n\n\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\n}"
  },
  {
    "function_name": "build_dma_prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4299-4494",
    "snippet": "static void\nbuild_dma_prog( bktr_ptr_t bktr, char i_flag )\n{\n\tint\t\t\trows, cols,  interlace;\n\tbt848_ptr_t\t\tbt848;\n\tint\t\t\ttmp_int;\n\tunsigned int\t\ttemp;\t\n\tstruct format_params\t*fp;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\t\n\n\tfp = &format_params[bktr->format_params];\n\t\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t/* disable FIFO & RISC, leave other bits alone */\n\tbt848->gpio_dma_ctl &= ~FIFO_RISC_ENABLED;\n\n\t/* set video parameters */\n\tif (bktr->capture_area_enabled)\n\t  temp = ((quad_t ) fp->htotal* (quad_t) bktr->capture_area_x_size * 4096\n\t\t  / fp->scaled_htotal / bktr->cols) -  4096;\n\telse\n\t  temp = ((quad_t ) fp->htotal* (quad_t) fp->scaled_hactive * 4096\n\t\t  / fp->scaled_htotal / bktr->cols) -  4096;\n\n\t /* printf(\"HSCALE value is %d\\n\",temp); */\n\tbt848->e_hscale_lo = temp & 0xff;\n\tbt848->o_hscale_lo = temp & 0xff;\n\tbt848->e_hscale_hi = (temp >> 8) & 0xff;\n\tbt848->o_hscale_hi = (temp >> 8) & 0xff;\n \n\t/* horizontal active */\n\ttemp = bktr->cols;\n\t/* printf(\"HACTIVE value is %d\\n\",temp); */\n\tbt848->e_hactive_lo = temp & 0xff;\n\tbt848->o_hactive_lo = temp & 0xff;\n\tbt848->e_crop &= ~0x3;\n\tbt848->o_crop  &= ~0x3;\n\tbt848->e_crop |= (temp >> 8) & 0x3;\n\tbt848->o_crop  |= (temp >> 8) & 0x3;\n \n\t/* horizontal delay */\n\tif (bktr->capture_area_enabled)\n\t  temp = ( (fp->hdelay* fp->scaled_hactive + bktr->capture_area_x_offset* fp->scaled_htotal)\n\t\t * bktr->cols) / (bktr->capture_area_x_size * fp->hactive);\n\telse\n\t  temp = (fp->hdelay * bktr->cols) / fp->hactive;\n\n\ttemp = temp & 0x3fe;\n\n\t/* printf(\"HDELAY value is %d\\n\",temp); */\n\tbt848->e_delay_lo = temp & 0xff;\n\tbt848->o_delay_lo = temp & 0xff;\n\tbt848->e_crop &= ~0xc;\n\tbt848->o_crop &= ~0xc;\n\tbt848->e_crop |= (temp >> 6) & 0xc;\n\tbt848->o_crop |= (temp >> 6) & 0xc;\n\n\t/* vertical scale */\n\n\tif (bktr->capture_area_enabled) {\n\t  if (bktr->flags  & METEOR_ONLY_ODD_FIELDS ||\n\t      bktr->flags & METEOR_ONLY_EVEN_FIELDS)\n\t    tmp_int = 65536 -\n\t    (((bktr->capture_area_y_size  * 256 + (bktr->rows/2)) / bktr->rows) - 512);\n\t  else {\n\t    tmp_int = 65536 -\n\t    (((bktr->capture_area_y_size * 512 + (bktr->rows / 2)) /  bktr->rows) - 512);\n\t  }\n\t} else {\n\t  if (bktr->flags  & METEOR_ONLY_ODD_FIELDS ||\n\t      bktr->flags & METEOR_ONLY_EVEN_FIELDS)\n\t    tmp_int = 65536 -\n\t    (((fp->vactive  * 256 + (bktr->rows/2)) / bktr->rows) - 512);\n\t  else {\n\t    tmp_int = 65536  -\n\t    (((fp->vactive * 512 + (bktr->rows / 2)) /  bktr->rows) - 512);\n\t  }\n\t}\n\n\ttmp_int &= 0x1fff;\n\t/* printf(\"VSCALE value is %d\\n\",tmp_int); */\n\tbt848->e_vscale_lo = tmp_int & 0xff;\n\tbt848->o_vscale_lo = tmp_int & 0xff;\n\tbt848->e_vscale_hi &= ~0x1f;\n\tbt848->o_vscale_hi &= ~0x1f;\n\tbt848->e_vscale_hi |= (tmp_int >> 8) & 0x1f;\n\tbt848->o_vscale_hi |= (tmp_int >> 8) & 0x1f;\n\n \n\t/* vertical active */\n\tif (bktr->capture_area_enabled)\n\t  temp = bktr->capture_area_y_size;\n\telse\n\t  temp = fp->vactive;\n\t/* printf(\"VACTIVE is %d\\n\",temp); */\n\tbt848->e_crop &= ~0x30;\n\tbt848->e_crop |= (temp >> 4) & 0x30;\n\tbt848->e_vactive_lo = temp & 0xff;\n\tbt848->o_crop &= ~0x30;\n\tbt848->o_crop |= (temp >> 4) & 0x30;\n\tbt848->o_vactive_lo = temp & 0xff;\n \n\t/* vertical delay */\n\tif (bktr->capture_area_enabled)\n\t  temp = fp->vdelay + (bktr->capture_area_y_offset);\n\telse\n\t  temp = fp->vdelay;\n\t/* printf(\"VDELAY is %d\\n\",temp); */\n\tbt848->e_crop &= ~0xC0;\n\tbt848->e_crop |= (temp >> 2) & 0xC0;\n\tbt848->e_vdelay_lo = temp & 0xff;\n\tbt848->o_crop &= ~0xC0;\n\tbt848->o_crop |= (temp >> 2) & 0xC0;\n\tbt848->o_vdelay_lo = temp & 0xff;\n\n\t/* end of video params */\n\n\tif ((bktr->xtal_pll_mode == BT848_USE_PLL)\n\t   && (fp->iform_xtsel==BT848_IFORM_X_XT1)) {\n\t\tbt848->tgctrl=8; /* Select PLL mode */\n\t} else {\n\t\tbt848->tgctrl=0; /* Select Normal xtal 0/xtal 1 mode */\n\t}\n\n\t/* capture control */\n\tswitch (i_flag) {\n\tcase 1:\n\t        bktr->bktr_cap_ctl = \n\t\t    (BT848_CAP_CTL_DITH_FRAME | BT848_CAP_CTL_EVEN);\n\t\tbt848->e_vscale_hi &= ~0x20;\n\t\tbt848->o_vscale_hi &= ~0x20;\n\t\tinterlace = 1;\n\t\tbreak;\n\t case 2:\n \t        bktr->bktr_cap_ctl =\n\t\t\t(BT848_CAP_CTL_DITH_FRAME | BT848_CAP_CTL_ODD);\n\t\tbt848->e_vscale_hi &= ~0x20;\n\t\tbt848->o_vscale_hi &= ~0x20;\n\t\tinterlace = 1;\n\t\tbreak;\n\t default:\n \t        bktr->bktr_cap_ctl = \n\t\t\t(BT848_CAP_CTL_DITH_FRAME |\n\t\t\t BT848_CAP_CTL_EVEN | BT848_CAP_CTL_ODD);\n\t\tbt848->e_vscale_hi |= 0x20;\n\t\tbt848->o_vscale_hi |= 0x20;\n\t\tinterlace = 2;\n\t\tbreak;\n\t}\n\n\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\n\trows = bktr->rows;\n\tcols = bktr->cols;\n\n\tbktr->vbiflags &= ~VBI_CAPTURE;\t/* default - no vbi capture */\n\n\t/* If /dev/vbi is already open, then use the rgb_vbi RISC program */\n\tif ( (pf_int->public.type == METEOR_PIXTYPE_RGB)\n           &&(bktr->vbiflags & VBI_OPEN) ) {\n\t\tif (i_flag==1) bktr->bktr_cap_ctl |= BT848_CAP_CTL_VBI_EVEN;\n\t\tif (i_flag==2) bktr->bktr_cap_ctl |= BT848_CAP_CTL_VBI_ODD;\n\t\tif (i_flag==3) bktr->bktr_cap_ctl |=\n\t\t                BT848_CAP_CTL_VBI_EVEN | BT848_CAP_CTL_VBI_ODD;\n\t\tbktr->vbiflags |= VBI_CAPTURE;\n\t\trgb_vbi_prog(bktr, i_flag, cols, rows, interlace);\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type == METEOR_PIXTYPE_RGB ) {\n\t\trgb_prog(bktr, i_flag, cols, rows, interlace);\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV ) {\n\t\tyuv422_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV_PACKED ) {\n\t\tyuvpack_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV_12 ) {\n\t\tyuv12_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define ALL_INTS_DISABLED\t0",
      "#define FIFO_RISC_ENABLED\t(BT848_DMA_CTL_FIFO_EN | BT848_DMA_CTL_RISC_EN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pixfmt_swap_flags",
          "args": [
            "bktr->pixfmt"
          ],
          "line": 4490
        },
        "resolved": true,
        "details": {
          "function_name": "pixfmt_swap_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4623-4642",
          "snippet": "static u_int pixfmt_swap_flags( int pixfmt )\n{\n\tstruct meteor_pixfmt *pf = &pixfmt_table[ pixfmt ].public;\n\tu_int\t\t      swapf = 0;\n\n\tswitch ( pf->Bpp ) {\n\tcase 2 : swapf = ( pf->swap_bytes ? 0 : BSWAP );\n\t\t break;\n\n\tcase 3 : /* no swaps supported for 3bpp - makes no sense w/ bt848 */\n\t\t break;\n\t\t \n\tcase 4 : if ( pf->swap_bytes )\n\t\t\tswapf = pf->swap_shorts ? 0 : WSWAP;\n\t\t else\n\t\t\tswapf = pf->swap_shorts ? BSWAP : (BSWAP | WSWAP);\n\t\t break;\n\t}\n\treturn swapf;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define WSWAP (BT848_COLOR_CTL_WSWAP_ODD | BT848_COLOR_CTL_WSWAP_EVEN)",
            "#define BSWAP (BT848_COLOR_CTL_BSWAP_ODD | BT848_COLOR_CTL_BSWAP_EVEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define WSWAP (BT848_COLOR_CTL_WSWAP_ODD | BT848_COLOR_CTL_WSWAP_EVEN)\n#define BSWAP (BT848_COLOR_CTL_BSWAP_ODD | BT848_COLOR_CTL_BSWAP_EVEN)\n\nstatic u_int pixfmt_swap_flags( int pixfmt )\n{\n\tstruct meteor_pixfmt *pf = &pixfmt_table[ pixfmt ].public;\n\tu_int\t\t      swapf = 0;\n\n\tswitch ( pf->Bpp ) {\n\tcase 2 : swapf = ( pf->swap_bytes ? 0 : BSWAP );\n\t\t break;\n\n\tcase 3 : /* no swaps supported for 3bpp - makes no sense w/ bt848 */\n\t\t break;\n\t\t \n\tcase 4 : if ( pf->swap_bytes )\n\t\t\tswapf = pf->swap_shorts ? 0 : WSWAP;\n\t\t else\n\t\t\tswapf = pf->swap_shorts ? BSWAP : (BSWAP | WSWAP);\n\t\t break;\n\t}\n\treturn swapf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "yuv12_prog",
          "args": [
            "bktr",
            "i_flag",
            "cols",
            "rows",
            "interlace"
          ],
          "line": 4489
        },
        "resolved": true,
        "details": {
          "function_name": "yuv12_prog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4185-4292",
          "snippet": "static void\nyuv12_prog( bktr_ptr_t bktr, char i_flag,\n\t     int cols, int rows, int interlace ){\n\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile unsigned int\tinst1;\n\tvolatile u_long\t\ttarget_buffer, t1, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 |\t3;\n\n\tbt848->adc = SYNC_LEVEL;\n\tbt848->oform = 0x0;\n \n\t/* Construct Write */\n \tinst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols); \n \tinst1  = OP_WRITES123  | OP_SOL | OP_EOL |  (cols); \n \tif (bktr->video.addr)\n \t\ttarget_buffer = (u_long) bktr->video.addr;\n \telse\n \t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n     \n\tbuffer = target_buffer;\n \tt1 = buffer;\n \n \t*dma_prog++ = OP_SYNC  | 1 << 15 |\tBKTR_FM3; /*sync, mode indicator packed data*/\n \t*dma_prog++ = 0;  /* NULL WORD */\n \t       \n \tfor (i = 0; i < (rows/interlace )/2 ; i++) {\n\t\t*dma_prog++ = inst;\n \t\t*dma_prog++ = cols/2 | (cols/2 << 16);\n \t\t*dma_prog++ = target_buffer;\n \t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n \t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/4) + i*cols/2 * interlace;\n \t\ttarget_buffer += interlace*cols;\n \t\t*dma_prog++ = inst1;\n \t\t*dma_prog++ = cols/2 | (cols/2 << 16);\n \t\t*dma_prog++ = target_buffer;\n \t\ttarget_buffer += interlace*cols;\n \n \t}\n \n \tswitch (i_flag) {\n \tcase 1:\n \t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;  /*sync vre*/\n \t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n \t\treturn;\n\n \tcase 2:\n \t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;  /*sync vro*/\n \t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n \t\treturn;\n \n \tcase 3:\n \t\t*dma_prog++ = OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\ttarget_buffer  = (u_long) buffer + cols;\n\t\tt1 = buffer + cols/2;\n\t\t*dma_prog++ = OP_SYNC   | 1 << 15 | BKTR_FM3; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < ((rows/interlace )/2 ) ; i++) {\n\t\t    *dma_prog++ = inst;\n\t\t    *dma_prog++ = cols/2 | (cols/2 << 16);\n         \t    *dma_prog++ = target_buffer;\n\t\t    *dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t    *dma_prog++ = t1 + (cols*rows) + (cols*rows/4) + i*cols/2 * interlace;\n\t\t    target_buffer += interlace*cols;\n\t\t    *dma_prog++ = inst1;\n\t\t    *dma_prog++ = cols/2 | (cols/2 << 16);\n\t\t    *dma_prog++ = target_buffer;\n\t\t    target_buffer += interlace*cols;\n\n\t\t}\t\n\n\t\n\t}\n    \n\t*dma_prog++ = OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t*dma_prog++ = 0;  /* NULL WORD */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define OP_EOL\t      (1 << 26)",
            "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
            "#define OP_WRITES123  (0xb << 28)",
            "#define OP_WRITE123   (0x9 << 28)",
            "#define OP_SYNC\t      (0x8 << 28)",
            "#define OP_JUMP\t      (0x7 << 28)",
            "#define BKTR_VRO      0xC\t/* Marks the end of the odd field */",
            "#define BKTR_VRE      0x4\t/* Marks the end of the even field */",
            "#define BKTR_FM3      0xe\t/* planar data to follow */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_WRITES123  (0xb << 28)\n#define OP_WRITE123   (0x9 << 28)\n#define OP_SYNC\t      (0x8 << 28)\n#define OP_JUMP\t      (0x7 << 28)\n#define BKTR_VRO      0xC\t/* Marks the end of the odd field */\n#define BKTR_VRE      0x4\t/* Marks the end of the even field */\n#define BKTR_FM3      0xe\t/* planar data to follow */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic void\nyuv12_prog( bktr_ptr_t bktr, char i_flag,\n\t     int cols, int rows, int interlace ){\n\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile unsigned int\tinst1;\n\tvolatile u_long\t\ttarget_buffer, t1, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 |\t3;\n\n\tbt848->adc = SYNC_LEVEL;\n\tbt848->oform = 0x0;\n \n\t/* Construct Write */\n \tinst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols); \n \tinst1  = OP_WRITES123  | OP_SOL | OP_EOL |  (cols); \n \tif (bktr->video.addr)\n \t\ttarget_buffer = (u_long) bktr->video.addr;\n \telse\n \t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n     \n\tbuffer = target_buffer;\n \tt1 = buffer;\n \n \t*dma_prog++ = OP_SYNC  | 1 << 15 |\tBKTR_FM3; /*sync, mode indicator packed data*/\n \t*dma_prog++ = 0;  /* NULL WORD */\n \t       \n \tfor (i = 0; i < (rows/interlace )/2 ; i++) {\n\t\t*dma_prog++ = inst;\n \t\t*dma_prog++ = cols/2 | (cols/2 << 16);\n \t\t*dma_prog++ = target_buffer;\n \t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n \t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/4) + i*cols/2 * interlace;\n \t\ttarget_buffer += interlace*cols;\n \t\t*dma_prog++ = inst1;\n \t\t*dma_prog++ = cols/2 | (cols/2 << 16);\n \t\t*dma_prog++ = target_buffer;\n \t\ttarget_buffer += interlace*cols;\n \n \t}\n \n \tswitch (i_flag) {\n \tcase 1:\n \t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;  /*sync vre*/\n \t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n \t\treturn;\n\n \tcase 2:\n \t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;  /*sync vro*/\n \t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n \t\treturn;\n \n \tcase 3:\n \t\t*dma_prog++ = OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\ttarget_buffer  = (u_long) buffer + cols;\n\t\tt1 = buffer + cols/2;\n\t\t*dma_prog++ = OP_SYNC   | 1 << 15 | BKTR_FM3; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < ((rows/interlace )/2 ) ; i++) {\n\t\t    *dma_prog++ = inst;\n\t\t    *dma_prog++ = cols/2 | (cols/2 << 16);\n         \t    *dma_prog++ = target_buffer;\n\t\t    *dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t    *dma_prog++ = t1 + (cols*rows) + (cols*rows/4) + i*cols/2 * interlace;\n\t\t    target_buffer += interlace*cols;\n\t\t    *dma_prog++ = inst1;\n\t\t    *dma_prog++ = cols/2 | (cols/2 << 16);\n\t\t    *dma_prog++ = target_buffer;\n\t\t    target_buffer += interlace*cols;\n\n\t\t}\t\n\n\t\n\t}\n    \n\t*dma_prog++ = OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t*dma_prog++ = 0;  /* NULL WORD */\n}"
        }
      },
      {
        "call_info": {
          "callee": "yuvpack_prog",
          "args": [
            "bktr",
            "i_flag",
            "cols",
            "rows",
            "interlace"
          ],
          "line": 4483
        },
        "resolved": true,
        "details": {
          "function_name": "yuvpack_prog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "3950-4063",
          "snippet": "static void\nyuvpack_prog( bktr_ptr_t bktr, char i_flag,\n\t      int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile unsigned int\tinst3;\n\tvolatile u_long\t\ttarget_buffer, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tint\t\t\tb;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tbt848->e_scloop |= BT848_E_SCLOOP_CAGC; /* enable chroma comb */\n\tbt848->o_scloop |= BT848_O_SCLOOP_CAGC;\n\n\tbt848->color_ctl_rgb_ded = 1;\n\tbt848->color_ctl_gamma = 1;\n\tbt848->adc = SYNC_LEVEL;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 | 1 << 2 | 3;\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n    \n\t/* write , sol, eol */\n\tinst = OP_WRITE\t | OP_SOL | (cols);\n\t/* write , sol, eol */\n\tinst3 = OP_WRITE | OP_EOL | (cols);\n\n\tif (bktr->video.addr)\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\telse\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\n\tbuffer = target_buffer;\n\n\t/* contruct sync : for video packet format */\n\t/* sync, mode indicator packed data */\n\t*dma_prog++ = OP_SYNC | 1 << 15 | BKTR_FM1;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\tb = cols;\n\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t*dma_prog++ = inst;\n\t\t*dma_prog++ = target_buffer;\n\t\t*dma_prog++ = inst3;\n\t\t*dma_prog++ = target_buffer + b; \n\t\ttarget_buffer += interlace*(cols * 2);\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC\t | 1 << 24 | 1 << 15 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP  ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\ttarget_buffer =\t (u_long) buffer + cols*2;\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC | 1 << 24 |  1 << 15 | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < (rows/interlace) ; i++) {\n\t\t\t*dma_prog++ = inst;\n\t\t\t*dma_prog++ = target_buffer;\n\t\t\t*dma_prog++ = inst3;\n\t\t\t*dma_prog++ = target_buffer + b;\n\t\t\ttarget_buffer += interlace * ( cols*2);\n\t\t}\n\t}\n\n\t/* sync vro IRQ bit */\n\t*dma_prog++ = OP_SYNC   |  1 << 24  | 1 << 15 |  BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\n\t*dma_prog++ = OP_JUMP;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t*dma_prog++ = 0;  /* NULL WORD */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define OP_EOL\t      (1 << 26)",
            "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
            "#define OP_SYNC\t      (0x8 << 28)",
            "#define OP_JUMP\t      (0x7 << 28)",
            "#define OP_WRITE      (0x1 << 28)",
            "#define BKTR_VRO      0xC\t/* Marks the end of the odd field */",
            "#define BKTR_VRE      0x4\t/* Marks the end of the even field */",
            "#define BKTR_FM1      0x6\t/* packed data to follow */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_SYNC\t      (0x8 << 28)\n#define OP_JUMP\t      (0x7 << 28)\n#define OP_WRITE      (0x1 << 28)\n#define BKTR_VRO      0xC\t/* Marks the end of the odd field */\n#define BKTR_VRE      0x4\t/* Marks the end of the even field */\n#define BKTR_FM1      0x6\t/* packed data to follow */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic void\nyuvpack_prog( bktr_ptr_t bktr, char i_flag,\n\t      int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile unsigned int\tinst3;\n\tvolatile u_long\t\ttarget_buffer, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tint\t\t\tb;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tbt848->e_scloop |= BT848_E_SCLOOP_CAGC; /* enable chroma comb */\n\tbt848->o_scloop |= BT848_O_SCLOOP_CAGC;\n\n\tbt848->color_ctl_rgb_ded = 1;\n\tbt848->color_ctl_gamma = 1;\n\tbt848->adc = SYNC_LEVEL;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 | 1 << 2 | 3;\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n    \n\t/* write , sol, eol */\n\tinst = OP_WRITE\t | OP_SOL | (cols);\n\t/* write , sol, eol */\n\tinst3 = OP_WRITE | OP_EOL | (cols);\n\n\tif (bktr->video.addr)\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\telse\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\n\tbuffer = target_buffer;\n\n\t/* contruct sync : for video packet format */\n\t/* sync, mode indicator packed data */\n\t*dma_prog++ = OP_SYNC | 1 << 15 | BKTR_FM1;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\tb = cols;\n\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t*dma_prog++ = inst;\n\t\t*dma_prog++ = target_buffer;\n\t\t*dma_prog++ = inst3;\n\t\t*dma_prog++ = target_buffer + b; \n\t\ttarget_buffer += interlace*(cols * 2);\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC\t | 1 << 24 | 1 << 15 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP  ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\ttarget_buffer =\t (u_long) buffer + cols*2;\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC | 1 << 24 |  1 << 15 | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < (rows/interlace) ; i++) {\n\t\t\t*dma_prog++ = inst;\n\t\t\t*dma_prog++ = target_buffer;\n\t\t\t*dma_prog++ = inst3;\n\t\t\t*dma_prog++ = target_buffer + b;\n\t\t\ttarget_buffer += interlace * ( cols*2);\n\t\t}\n\t}\n\n\t/* sync vro IRQ bit */\n\t*dma_prog++ = OP_SYNC   |  1 << 24  | 1 << 15 |  BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\n\t*dma_prog++ = OP_JUMP;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t*dma_prog++ = 0;  /* NULL WORD */\n}"
        }
      },
      {
        "call_info": {
          "callee": "yuv422_prog",
          "args": [
            "bktr",
            "i_flag",
            "cols",
            "rows",
            "interlace"
          ],
          "line": 4477
        },
        "resolved": true,
        "details": {
          "function_name": "yuv422_prog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4069-4179",
          "snippet": "static void\nyuv422_prog( bktr_ptr_t bktr, char i_flag,\n\t     int cols, int rows, int interlace ){\n\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile u_long\t\ttarget_buffer, t1, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 |\t3;\n\n\tbt848->adc = SYNC_LEVEL;\n\tbt848->oform = 0x00;\n\n\tbt848->e_control |= BT848_E_CONTROL_LDEC; /* disable luma decimation */\n\tbt848->o_control |= BT848_O_CONTROL_LDEC;\n\n\tbt848->e_scloop |= BT848_O_SCLOOP_CAGC;\t/* chroma agc enable */\n\tbt848->o_scloop |= BT848_O_SCLOOP_CAGC; \n\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n\tbt848->o_vscale_hi |= 0x40;\n\n\t/* disable gamma correction removal */\n\tbt848->color_ctl_gamma = 1;\n\n\t/* Construct Write */\n\tinst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols); \n\tif (bktr->video.addr)\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\telse\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n    \n\tbuffer = target_buffer;\n\n\tt1 = buffer;\n\n\t/* contruct sync : for video packet format */\n\t*dma_prog++ = OP_SYNC  | 1 << 15 |\tBKTR_FM3; /*sync, mode indicator packed data*/\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\tfor (i = 0; i < (rows/interlace ) ; i++) {\n\t\t*dma_prog++ = inst;\n\t\t*dma_prog++ = cols/2 | cols/2 << 16;\n\t\t*dma_prog++ = target_buffer;\n\t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/2) + i*cols/2 * interlace;\n\t\ttarget_buffer += interlace*cols;\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;  /*sync vre*/\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP ;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;  /*sync vre*/\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t*dma_prog++ = OP_SYNC\t| 1 << 24 |  1 << 15 |   BKTR_VRO; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP  ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\ttarget_buffer  = (u_long) buffer + cols;\n\t\tt1 = buffer + cols/2;\n\t\t*dma_prog++ = OP_SYNC\t|   1 << 15 | BKTR_FM3; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < (rows/interlace )  ; i++) {\n\t\t\t*dma_prog++ = inst;\n\t\t\t*dma_prog++ = cols/2 | cols/2 << 16;\n\t\t\t*dma_prog++ = target_buffer;\n\t\t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/2) + i*cols/2 * interlace;\n\t\t\ttarget_buffer += interlace*cols;\n\t\t}\n\t}\n    \n\t*dma_prog++ = OP_SYNC  | 1 << 24 | 1 << 15 |   BKTR_VRE; \n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define OP_EOL\t      (1 << 26)",
            "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
            "#define OP_WRITE123   (0x9 << 28)",
            "#define OP_SYNC\t      (0x8 << 28)",
            "#define OP_JUMP\t      (0x7 << 28)",
            "#define BKTR_VRO      0xC\t/* Marks the end of the odd field */",
            "#define BKTR_VRE      0x4\t/* Marks the end of the even field */",
            "#define BKTR_FM3      0xe\t/* planar data to follow */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_WRITE123   (0x9 << 28)\n#define OP_SYNC\t      (0x8 << 28)\n#define OP_JUMP\t      (0x7 << 28)\n#define BKTR_VRO      0xC\t/* Marks the end of the odd field */\n#define BKTR_VRE      0x4\t/* Marks the end of the even field */\n#define BKTR_FM3      0xe\t/* planar data to follow */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic void\nyuv422_prog( bktr_ptr_t bktr, char i_flag,\n\t     int cols, int rows, int interlace ){\n\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile u_long\t\ttarget_buffer, t1, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 |\t3;\n\n\tbt848->adc = SYNC_LEVEL;\n\tbt848->oform = 0x00;\n\n\tbt848->e_control |= BT848_E_CONTROL_LDEC; /* disable luma decimation */\n\tbt848->o_control |= BT848_O_CONTROL_LDEC;\n\n\tbt848->e_scloop |= BT848_O_SCLOOP_CAGC;\t/* chroma agc enable */\n\tbt848->o_scloop |= BT848_O_SCLOOP_CAGC; \n\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n\tbt848->o_vscale_hi |= 0x40;\n\n\t/* disable gamma correction removal */\n\tbt848->color_ctl_gamma = 1;\n\n\t/* Construct Write */\n\tinst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols); \n\tif (bktr->video.addr)\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\telse\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n    \n\tbuffer = target_buffer;\n\n\tt1 = buffer;\n\n\t/* contruct sync : for video packet format */\n\t*dma_prog++ = OP_SYNC  | 1 << 15 |\tBKTR_FM3; /*sync, mode indicator packed data*/\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\tfor (i = 0; i < (rows/interlace ) ; i++) {\n\t\t*dma_prog++ = inst;\n\t\t*dma_prog++ = cols/2 | cols/2 << 16;\n\t\t*dma_prog++ = target_buffer;\n\t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/2) + i*cols/2 * interlace;\n\t\ttarget_buffer += interlace*cols;\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;  /*sync vre*/\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP ;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;  /*sync vre*/\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t*dma_prog++ = OP_SYNC\t| 1 << 24 |  1 << 15 |   BKTR_VRO; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP  ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\ttarget_buffer  = (u_long) buffer + cols;\n\t\tt1 = buffer + cols/2;\n\t\t*dma_prog++ = OP_SYNC\t|   1 << 15 | BKTR_FM3; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < (rows/interlace )  ; i++) {\n\t\t\t*dma_prog++ = inst;\n\t\t\t*dma_prog++ = cols/2 | cols/2 << 16;\n\t\t\t*dma_prog++ = target_buffer;\n\t\t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/2) + i*cols/2 * interlace;\n\t\t\ttarget_buffer += interlace*cols;\n\t\t}\n\t}\n    \n\t*dma_prog++ = OP_SYNC  | 1 << 24 | 1 << 15 |   BKTR_VRE; \n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgb_prog",
          "args": [
            "bktr",
            "i_flag",
            "cols",
            "rows",
            "interlace"
          ],
          "line": 4472
        },
        "resolved": true,
        "details": {
          "function_name": "rgb_prog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "3784-3944",
          "snippet": "static void\nrgb_prog( bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\ttarget_buffer, buffer, target,width;\n\tvolatile u_long\t\tpitch;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tu_int                   Bpp = pf_int->public.Bpp;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\tbt848->vbi_pack_size     = 0;\t    \n\tbt848->vbi_pack_del      = 0;\n\tbt848->adc               = SYNC_LEVEL;\n\n\tbt848->oform = 0x00;\n\n \tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n \tbt848->o_vscale_hi |= 0x40;\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\n \t/* disable gamma correction removal */\n \tbt848->color_ctl_gamma = 1;\n\n\n\tif (cols > 385 ) {\n\t    bt848->e_vtc = 0;\n\t    bt848->o_vtc = 0;\n\t} else {\n\t    bt848->e_vtc = 1;\n\t    bt848->o_vtc = 1;\n\t}\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n\n\tif (bktr->video.addr) {\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\t\tpitch = bktr->video.width;\n\t}\n\telse {\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\t\tpitch = cols*Bpp;\n\t}\n\n\tbuffer = target_buffer;\n\n\t/* contruct sync : for video packet format */\n\t*dma_prog++ = OP_SYNC  | BKTR_RESYNC | BKTR_FM1;\n\n\t/* sync, mode indicator packed data */\n\t*dma_prog++ = 0;  /* NULL WORD */\n\twidth = cols;\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t    target = target_buffer;\n\t    if ( notclipped(bktr, i, width)) {\n\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t      Bpp, (volatile u_char **) &target,  cols);\n\n\t    } else {\n\t\twhile(getline(bktr, i)) {\n\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target, cols);\n\t\t    }\n\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\tsplit(bktr,(volatile u_long **) &dma_prog,\n\t\t\t      bktr->yclip2 - bktr->yclip,\n\t\t\t      OP_SKIP,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    target_buffer += interlace * pitch;\n\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP; ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t        target_buffer = buffer + pitch; \n\n\t\tdma_prog = (u_long *) bktr->odd_dma_prog;\n\n\t\t/* sync vre IRQ bit */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n                width = cols;\n\t\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t    target = target_buffer;\n\t\t    if ( notclipped(bktr, i, width)) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    } else {\n\t\t\twhile(getline(bktr, i)) {\n\t\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t\t      Bpp, (volatile u_char **) &target,\n\t\t\t\t      cols);\n\t\t\t    }\t\n\t\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->yclip2 - bktr->yclip, OP_SKIP,\n\t\t\t\t      Bpp, (volatile u_char **)  &target,  cols);\n\t\t\t    }\t\n\n\t\t\t}\t\n\n\t\t    }\n\n\t\t    target_buffer += interlace * pitch;\n\n\t\t}\n\t}\n\n\t/* sync vre IRQ bit */\n\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BKTR_GEN_IRQ  (1 << 24)",
            "#define BKTR_RESYNC   (1 << 15)",
            "#define OP_SYNC\t      (0x8 << 28)",
            "#define OP_JUMP\t      (0x7 << 28)",
            "#define OP_SKIP       (0x2 << 28)",
            "#define OP_WRITE      (0x1 << 28)",
            "#define BKTR_VRO      0xC\t/* Marks the end of the odd field */",
            "#define BKTR_VRE      0x4\t/* Marks the end of the even field */",
            "#define BKTR_FM1      0x6\t/* packed data to follow */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BKTR_GEN_IRQ  (1 << 24)\n#define BKTR_RESYNC   (1 << 15)\n#define OP_SYNC\t      (0x8 << 28)\n#define OP_JUMP\t      (0x7 << 28)\n#define OP_SKIP       (0x2 << 28)\n#define OP_WRITE      (0x1 << 28)\n#define BKTR_VRO      0xC\t/* Marks the end of the odd field */\n#define BKTR_VRE      0x4\t/* Marks the end of the even field */\n#define BKTR_FM1      0x6\t/* packed data to follow */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic void\nrgb_prog( bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\ttarget_buffer, buffer, target,width;\n\tvolatile u_long\t\tpitch;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tu_int                   Bpp = pf_int->public.Bpp;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\tbt848->vbi_pack_size     = 0;\t    \n\tbt848->vbi_pack_del      = 0;\n\tbt848->adc               = SYNC_LEVEL;\n\n\tbt848->oform = 0x00;\n\n \tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n \tbt848->o_vscale_hi |= 0x40;\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\n \t/* disable gamma correction removal */\n \tbt848->color_ctl_gamma = 1;\n\n\n\tif (cols > 385 ) {\n\t    bt848->e_vtc = 0;\n\t    bt848->o_vtc = 0;\n\t} else {\n\t    bt848->e_vtc = 1;\n\t    bt848->o_vtc = 1;\n\t}\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n\n\tif (bktr->video.addr) {\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\t\tpitch = bktr->video.width;\n\t}\n\telse {\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\t\tpitch = cols*Bpp;\n\t}\n\n\tbuffer = target_buffer;\n\n\t/* contruct sync : for video packet format */\n\t*dma_prog++ = OP_SYNC  | BKTR_RESYNC | BKTR_FM1;\n\n\t/* sync, mode indicator packed data */\n\t*dma_prog++ = 0;  /* NULL WORD */\n\twidth = cols;\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t    target = target_buffer;\n\t    if ( notclipped(bktr, i, width)) {\n\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t      Bpp, (volatile u_char **) &target,  cols);\n\n\t    } else {\n\t\twhile(getline(bktr, i)) {\n\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target, cols);\n\t\t    }\n\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\tsplit(bktr,(volatile u_long **) &dma_prog,\n\t\t\t      bktr->yclip2 - bktr->yclip,\n\t\t\t      OP_SKIP,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    target_buffer += interlace * pitch;\n\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP; ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t        target_buffer = buffer + pitch; \n\n\t\tdma_prog = (u_long *) bktr->odd_dma_prog;\n\n\t\t/* sync vre IRQ bit */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n                width = cols;\n\t\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t    target = target_buffer;\n\t\t    if ( notclipped(bktr, i, width)) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    } else {\n\t\t\twhile(getline(bktr, i)) {\n\t\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t\t      Bpp, (volatile u_char **) &target,\n\t\t\t\t      cols);\n\t\t\t    }\t\n\t\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->yclip2 - bktr->yclip, OP_SKIP,\n\t\t\t\t      Bpp, (volatile u_char **)  &target,  cols);\n\t\t\t    }\t\n\n\t\t\t}\t\n\n\t\t    }\n\n\t\t    target_buffer += interlace * pitch;\n\n\t\t}\n\t}\n\n\t/* sync vre IRQ bit */\n\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rgb_vbi_prog",
          "args": [
            "bktr",
            "i_flag",
            "cols",
            "rows",
            "interlace"
          ],
          "line": 4467
        },
        "resolved": true,
        "details": {
          "function_name": "rgb_vbi_prog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "3577-3779",
          "snippet": "static void\nrgb_vbi_prog( bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\ttarget_buffer, buffer, target,width;\n\tvolatile u_long\t\tpitch;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tu_int                   Bpp = pf_int->public.Bpp;\n\tunsigned int            vbisamples;     /* VBI samples per line */\n\tunsigned int            vbilines;       /* VBI lines per field */\n\tunsigned int            num_dwords;     /* DWORDS per line */\n\n\tvbisamples = format_params[bktr->format_params].vbi_num_samples;\n\tvbilines   = format_params[bktr->format_params].vbi_num_lines;\n\tnum_dwords = vbisamples/4;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\tbt848->adc               = SYNC_LEVEL;\n\tbt848->vbi_pack_size     = ((num_dwords))     & 0xff;\n\tbt848->vbi_pack_del      = ((num_dwords)>> 8) & 0x01; /* no hdelay    */\n\t\t\t\t\t\t\t      /* no ext frame */\n\n\tbt848->oform = 0x00;\n\n \tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n \tbt848->o_vscale_hi |= 0x40;\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\n \t/* disable gamma correction removal */\n \tbt848->color_ctl_gamma = 1;\n\n\n\tif (cols > 385 ) {\n\t    bt848->e_vtc = 0;\n\t    bt848->o_vtc = 0;\n\t} else {\n\t    bt848->e_vtc = 1;\n\t    bt848->o_vtc = 1;\n\t}\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n\n\tif (bktr->video.addr) {\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\t\tpitch = bktr->video.width;\n\t}\n\telse {\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\t\tpitch = cols*Bpp;\n\t}\n\n\tbuffer = target_buffer;\n\n\n\t/* store the VBI data */\n\t/* look for sync with packed data */\n\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t*dma_prog++ = 0;\n\tfor(i = 0; i < vbilines; i++) {\n\t\t*dma_prog++ = OP_WRITE | OP_SOL | OP_EOL | vbisamples;\n\t\t*dma_prog++ = (u_long) vtophys(bktr->vbidata +\n\t\t\t\t\t(i * VBI_LINE_SIZE));\n\t}\n\n\t/* store the video image */\n\t/* look for sync with packed data */\n\t*dma_prog++ = OP_SYNC  | BKTR_RESYNC | BKTR_FM1;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\twidth = cols;\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t    target = target_buffer;\n\t    if ( notclipped(bktr, i, width)) {\n\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t      Bpp, (volatile u_char **) &target,  cols);\n\n\t    } else {\n\t\twhile(getline(bktr, i)) {\n\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target, cols);\n\t\t    }\n\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\tsplit(bktr,(volatile u_long **) &dma_prog,\n\t\t\t      bktr->yclip2 - bktr->yclip,\n\t\t\t      OP_SKIP,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    target_buffer += interlace * pitch;\n\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* EVEN field grabs. Look for end of 'Even Field' Marker\n\t\t * We cannot look for VRO, because we have not enabled ODD\n\t\t * field capture\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* ODD field grabs. Look for end of 'Odd Field' Marker\n\t\t * We cannot look for VRE, because we have not enabled EVEN\n\t\t * field capture\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* INTERLACED grabs (ODD then EVEN). We have read the old field\n\t\t * so look for the end of 'Odd Field' Marker.\n\t\t * Then jump to the 'odd_dma_prog' which actually captures\n\t\t * the EVEN field!\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t        target_buffer = buffer + pitch; \n\n\t\tdma_prog = (u_long *) bktr->odd_dma_prog;\n\n\t\t/* store the VBI data */\n\t\t/* look for sync with packed data */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;\n\t\tfor(i = 0; i < vbilines; i++) {\n\t\t\t*dma_prog++ = OP_WRITE | OP_SOL | OP_EOL | vbisamples;\n\t\t\t*dma_prog++ = (u_long) vtophys(bktr->vbidata +\n\t\t\t\t\t((i+MAX_VBI_LINES) * VBI_LINE_SIZE));\n\t\t}\n\n\t\t/* store the video image */\n\t\t/* look for sync with packed data */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\twidth = cols;\n\t\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t    target = target_buffer;\n\t\t    if ( notclipped(bktr, i, width)) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    } else {\n\t\t\twhile(getline(bktr, i)) {\n\t\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t\t      Bpp, (volatile u_char **) &target,\n\t\t\t\t      cols);\n\t\t\t    }\t\n\t\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->yclip2 - bktr->yclip, OP_SKIP,\n\t\t\t\t      Bpp, (volatile u_char **)  &target,  cols);\n\t\t\t    }\t\n\n\t\t\t}\t\n\n\t\t    }\n\n\t\t    target_buffer += interlace * pitch;\n\n\t\t}\n\t}\n\n\t/* Look for end of 'Even Field' */\n\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define BKTR_GEN_IRQ  (1 << 24)",
            "#define BKTR_RESYNC   (1 << 15)",
            "#define OP_EOL\t      (1 << 26)",
            "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
            "#define OP_SYNC\t      (0x8 << 28)",
            "#define OP_JUMP\t      (0x7 << 28)",
            "#define OP_SKIP       (0x2 << 28)",
            "#define OP_WRITE      (0x1 << 28)",
            "#define BKTR_VRO      0xC\t/* Marks the end of the odd field */",
            "#define BKTR_VRE      0x4\t/* Marks the end of the even field */",
            "#define BKTR_FM1      0x6\t/* packed data to follow */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
            "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */",
            "#define VBI_LINE_SIZE         2048 /* Store upto 2048 bytes per line */",
            "#define MAX_VBI_LINES\t      16   /* Maximum for all vidoe formats */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BKTR_GEN_IRQ  (1 << 24)\n#define BKTR_RESYNC   (1 << 15)\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_SYNC\t      (0x8 << 28)\n#define OP_JUMP\t      (0x7 << 28)\n#define OP_SKIP       (0x2 << 28)\n#define OP_WRITE      (0x1 << 28)\n#define BKTR_VRO      0xC\t/* Marks the end of the odd field */\n#define BKTR_VRE      0x4\t/* Marks the end of the even field */\n#define BKTR_FM1      0x6\t/* packed data to follow */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n#define VBI_LINE_SIZE         2048 /* Store upto 2048 bytes per line */\n#define MAX_VBI_LINES\t      16   /* Maximum for all vidoe formats */\n\nstatic void\nrgb_vbi_prog( bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\ttarget_buffer, buffer, target,width;\n\tvolatile u_long\t\tpitch;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tu_int                   Bpp = pf_int->public.Bpp;\n\tunsigned int            vbisamples;     /* VBI samples per line */\n\tunsigned int            vbilines;       /* VBI lines per field */\n\tunsigned int            num_dwords;     /* DWORDS per line */\n\n\tvbisamples = format_params[bktr->format_params].vbi_num_samples;\n\tvbilines   = format_params[bktr->format_params].vbi_num_lines;\n\tnum_dwords = vbisamples/4;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\tbt848->adc               = SYNC_LEVEL;\n\tbt848->vbi_pack_size     = ((num_dwords))     & 0xff;\n\tbt848->vbi_pack_del      = ((num_dwords)>> 8) & 0x01; /* no hdelay    */\n\t\t\t\t\t\t\t      /* no ext frame */\n\n\tbt848->oform = 0x00;\n\n \tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n \tbt848->o_vscale_hi |= 0x40;\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\n \t/* disable gamma correction removal */\n \tbt848->color_ctl_gamma = 1;\n\n\n\tif (cols > 385 ) {\n\t    bt848->e_vtc = 0;\n\t    bt848->o_vtc = 0;\n\t} else {\n\t    bt848->e_vtc = 1;\n\t    bt848->o_vtc = 1;\n\t}\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n\n\tif (bktr->video.addr) {\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\t\tpitch = bktr->video.width;\n\t}\n\telse {\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\t\tpitch = cols*Bpp;\n\t}\n\n\tbuffer = target_buffer;\n\n\n\t/* store the VBI data */\n\t/* look for sync with packed data */\n\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t*dma_prog++ = 0;\n\tfor(i = 0; i < vbilines; i++) {\n\t\t*dma_prog++ = OP_WRITE | OP_SOL | OP_EOL | vbisamples;\n\t\t*dma_prog++ = (u_long) vtophys(bktr->vbidata +\n\t\t\t\t\t(i * VBI_LINE_SIZE));\n\t}\n\n\t/* store the video image */\n\t/* look for sync with packed data */\n\t*dma_prog++ = OP_SYNC  | BKTR_RESYNC | BKTR_FM1;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\twidth = cols;\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t    target = target_buffer;\n\t    if ( notclipped(bktr, i, width)) {\n\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t      Bpp, (volatile u_char **) &target,  cols);\n\n\t    } else {\n\t\twhile(getline(bktr, i)) {\n\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target, cols);\n\t\t    }\n\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\tsplit(bktr,(volatile u_long **) &dma_prog,\n\t\t\t      bktr->yclip2 - bktr->yclip,\n\t\t\t      OP_SKIP,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    target_buffer += interlace * pitch;\n\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* EVEN field grabs. Look for end of 'Even Field' Marker\n\t\t * We cannot look for VRO, because we have not enabled ODD\n\t\t * field capture\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* ODD field grabs. Look for end of 'Odd Field' Marker\n\t\t * We cannot look for VRE, because we have not enabled EVEN\n\t\t * field capture\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* INTERLACED grabs (ODD then EVEN). We have read the old field\n\t\t * so look for the end of 'Odd Field' Marker.\n\t\t * Then jump to the 'odd_dma_prog' which actually captures\n\t\t * the EVEN field!\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t        target_buffer = buffer + pitch; \n\n\t\tdma_prog = (u_long *) bktr->odd_dma_prog;\n\n\t\t/* store the VBI data */\n\t\t/* look for sync with packed data */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;\n\t\tfor(i = 0; i < vbilines; i++) {\n\t\t\t*dma_prog++ = OP_WRITE | OP_SOL | OP_EOL | vbisamples;\n\t\t\t*dma_prog++ = (u_long) vtophys(bktr->vbidata +\n\t\t\t\t\t((i+MAX_VBI_LINES) * VBI_LINE_SIZE));\n\t\t}\n\n\t\t/* store the video image */\n\t\t/* look for sync with packed data */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\twidth = cols;\n\t\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t    target = target_buffer;\n\t\t    if ( notclipped(bktr, i, width)) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    } else {\n\t\t\twhile(getline(bktr, i)) {\n\t\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t\t      Bpp, (volatile u_char **) &target,\n\t\t\t\t      cols);\n\t\t\t    }\t\n\t\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->yclip2 - bktr->yclip, OP_SKIP,\n\t\t\t\t      Bpp, (volatile u_char **)  &target,  cols);\n\t\t\t    }\t\n\n\t\t\t}\t\n\n\t\t    }\n\n\t\t    target_buffer += interlace * pitch;\n\n\t\t}\n\t}\n\n\t/* Look for end of 'Even Field' */\n\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_ENABLED\t(BT848_DMA_CTL_FIFO_EN | BT848_DMA_CTL_RISC_EN)\n\nstatic void\nbuild_dma_prog( bktr_ptr_t bktr, char i_flag )\n{\n\tint\t\t\trows, cols,  interlace;\n\tbt848_ptr_t\t\tbt848;\n\tint\t\t\ttmp_int;\n\tunsigned int\t\ttemp;\t\n\tstruct format_params\t*fp;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\t\n\n\tfp = &format_params[bktr->format_params];\n\t\n\tbt848 = bktr->base;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t/* disable FIFO & RISC, leave other bits alone */\n\tbt848->gpio_dma_ctl &= ~FIFO_RISC_ENABLED;\n\n\t/* set video parameters */\n\tif (bktr->capture_area_enabled)\n\t  temp = ((quad_t ) fp->htotal* (quad_t) bktr->capture_area_x_size * 4096\n\t\t  / fp->scaled_htotal / bktr->cols) -  4096;\n\telse\n\t  temp = ((quad_t ) fp->htotal* (quad_t) fp->scaled_hactive * 4096\n\t\t  / fp->scaled_htotal / bktr->cols) -  4096;\n\n\t /* printf(\"HSCALE value is %d\\n\",temp); */\n\tbt848->e_hscale_lo = temp & 0xff;\n\tbt848->o_hscale_lo = temp & 0xff;\n\tbt848->e_hscale_hi = (temp >> 8) & 0xff;\n\tbt848->o_hscale_hi = (temp >> 8) & 0xff;\n \n\t/* horizontal active */\n\ttemp = bktr->cols;\n\t/* printf(\"HACTIVE value is %d\\n\",temp); */\n\tbt848->e_hactive_lo = temp & 0xff;\n\tbt848->o_hactive_lo = temp & 0xff;\n\tbt848->e_crop &= ~0x3;\n\tbt848->o_crop  &= ~0x3;\n\tbt848->e_crop |= (temp >> 8) & 0x3;\n\tbt848->o_crop  |= (temp >> 8) & 0x3;\n \n\t/* horizontal delay */\n\tif (bktr->capture_area_enabled)\n\t  temp = ( (fp->hdelay* fp->scaled_hactive + bktr->capture_area_x_offset* fp->scaled_htotal)\n\t\t * bktr->cols) / (bktr->capture_area_x_size * fp->hactive);\n\telse\n\t  temp = (fp->hdelay * bktr->cols) / fp->hactive;\n\n\ttemp = temp & 0x3fe;\n\n\t/* printf(\"HDELAY value is %d\\n\",temp); */\n\tbt848->e_delay_lo = temp & 0xff;\n\tbt848->o_delay_lo = temp & 0xff;\n\tbt848->e_crop &= ~0xc;\n\tbt848->o_crop &= ~0xc;\n\tbt848->e_crop |= (temp >> 6) & 0xc;\n\tbt848->o_crop |= (temp >> 6) & 0xc;\n\n\t/* vertical scale */\n\n\tif (bktr->capture_area_enabled) {\n\t  if (bktr->flags  & METEOR_ONLY_ODD_FIELDS ||\n\t      bktr->flags & METEOR_ONLY_EVEN_FIELDS)\n\t    tmp_int = 65536 -\n\t    (((bktr->capture_area_y_size  * 256 + (bktr->rows/2)) / bktr->rows) - 512);\n\t  else {\n\t    tmp_int = 65536 -\n\t    (((bktr->capture_area_y_size * 512 + (bktr->rows / 2)) /  bktr->rows) - 512);\n\t  }\n\t} else {\n\t  if (bktr->flags  & METEOR_ONLY_ODD_FIELDS ||\n\t      bktr->flags & METEOR_ONLY_EVEN_FIELDS)\n\t    tmp_int = 65536 -\n\t    (((fp->vactive  * 256 + (bktr->rows/2)) / bktr->rows) - 512);\n\t  else {\n\t    tmp_int = 65536  -\n\t    (((fp->vactive * 512 + (bktr->rows / 2)) /  bktr->rows) - 512);\n\t  }\n\t}\n\n\ttmp_int &= 0x1fff;\n\t/* printf(\"VSCALE value is %d\\n\",tmp_int); */\n\tbt848->e_vscale_lo = tmp_int & 0xff;\n\tbt848->o_vscale_lo = tmp_int & 0xff;\n\tbt848->e_vscale_hi &= ~0x1f;\n\tbt848->o_vscale_hi &= ~0x1f;\n\tbt848->e_vscale_hi |= (tmp_int >> 8) & 0x1f;\n\tbt848->o_vscale_hi |= (tmp_int >> 8) & 0x1f;\n\n \n\t/* vertical active */\n\tif (bktr->capture_area_enabled)\n\t  temp = bktr->capture_area_y_size;\n\telse\n\t  temp = fp->vactive;\n\t/* printf(\"VACTIVE is %d\\n\",temp); */\n\tbt848->e_crop &= ~0x30;\n\tbt848->e_crop |= (temp >> 4) & 0x30;\n\tbt848->e_vactive_lo = temp & 0xff;\n\tbt848->o_crop &= ~0x30;\n\tbt848->o_crop |= (temp >> 4) & 0x30;\n\tbt848->o_vactive_lo = temp & 0xff;\n \n\t/* vertical delay */\n\tif (bktr->capture_area_enabled)\n\t  temp = fp->vdelay + (bktr->capture_area_y_offset);\n\telse\n\t  temp = fp->vdelay;\n\t/* printf(\"VDELAY is %d\\n\",temp); */\n\tbt848->e_crop &= ~0xC0;\n\tbt848->e_crop |= (temp >> 2) & 0xC0;\n\tbt848->e_vdelay_lo = temp & 0xff;\n\tbt848->o_crop &= ~0xC0;\n\tbt848->o_crop |= (temp >> 2) & 0xC0;\n\tbt848->o_vdelay_lo = temp & 0xff;\n\n\t/* end of video params */\n\n\tif ((bktr->xtal_pll_mode == BT848_USE_PLL)\n\t   && (fp->iform_xtsel==BT848_IFORM_X_XT1)) {\n\t\tbt848->tgctrl=8; /* Select PLL mode */\n\t} else {\n\t\tbt848->tgctrl=0; /* Select Normal xtal 0/xtal 1 mode */\n\t}\n\n\t/* capture control */\n\tswitch (i_flag) {\n\tcase 1:\n\t        bktr->bktr_cap_ctl = \n\t\t    (BT848_CAP_CTL_DITH_FRAME | BT848_CAP_CTL_EVEN);\n\t\tbt848->e_vscale_hi &= ~0x20;\n\t\tbt848->o_vscale_hi &= ~0x20;\n\t\tinterlace = 1;\n\t\tbreak;\n\t case 2:\n \t        bktr->bktr_cap_ctl =\n\t\t\t(BT848_CAP_CTL_DITH_FRAME | BT848_CAP_CTL_ODD);\n\t\tbt848->e_vscale_hi &= ~0x20;\n\t\tbt848->o_vscale_hi &= ~0x20;\n\t\tinterlace = 1;\n\t\tbreak;\n\t default:\n \t        bktr->bktr_cap_ctl = \n\t\t\t(BT848_CAP_CTL_DITH_FRAME |\n\t\t\t BT848_CAP_CTL_EVEN | BT848_CAP_CTL_ODD);\n\t\tbt848->e_vscale_hi |= 0x20;\n\t\tbt848->o_vscale_hi |= 0x20;\n\t\tinterlace = 2;\n\t\tbreak;\n\t}\n\n\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\n\trows = bktr->rows;\n\tcols = bktr->cols;\n\n\tbktr->vbiflags &= ~VBI_CAPTURE;\t/* default - no vbi capture */\n\n\t/* If /dev/vbi is already open, then use the rgb_vbi RISC program */\n\tif ( (pf_int->public.type == METEOR_PIXTYPE_RGB)\n           &&(bktr->vbiflags & VBI_OPEN) ) {\n\t\tif (i_flag==1) bktr->bktr_cap_ctl |= BT848_CAP_CTL_VBI_EVEN;\n\t\tif (i_flag==2) bktr->bktr_cap_ctl |= BT848_CAP_CTL_VBI_ODD;\n\t\tif (i_flag==3) bktr->bktr_cap_ctl |=\n\t\t                BT848_CAP_CTL_VBI_EVEN | BT848_CAP_CTL_VBI_ODD;\n\t\tbktr->vbiflags |= VBI_CAPTURE;\n\t\trgb_vbi_prog(bktr, i_flag, cols, rows, interlace);\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type == METEOR_PIXTYPE_RGB ) {\n\t\trgb_prog(bktr, i_flag, cols, rows, interlace);\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV ) {\n\t\tyuv422_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV_PACKED ) {\n\t\tyuvpack_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\n\tif ( pf_int->public.type  == METEOR_PIXTYPE_YUV_12 ) {\n\t\tyuv12_prog(bktr, i_flag, cols, rows, interlace);\n\t\tbt848->color_ctl_swap = pixfmt_swap_flags( bktr->pixfmt );\n\t\treturn;\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "yuv12_prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4185-4292",
    "snippet": "static void\nyuv12_prog( bktr_ptr_t bktr, char i_flag,\n\t     int cols, int rows, int interlace ){\n\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile unsigned int\tinst1;\n\tvolatile u_long\t\ttarget_buffer, t1, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 |\t3;\n\n\tbt848->adc = SYNC_LEVEL;\n\tbt848->oform = 0x0;\n \n\t/* Construct Write */\n \tinst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols); \n \tinst1  = OP_WRITES123  | OP_SOL | OP_EOL |  (cols); \n \tif (bktr->video.addr)\n \t\ttarget_buffer = (u_long) bktr->video.addr;\n \telse\n \t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n     \n\tbuffer = target_buffer;\n \tt1 = buffer;\n \n \t*dma_prog++ = OP_SYNC  | 1 << 15 |\tBKTR_FM3; /*sync, mode indicator packed data*/\n \t*dma_prog++ = 0;  /* NULL WORD */\n \t       \n \tfor (i = 0; i < (rows/interlace )/2 ; i++) {\n\t\t*dma_prog++ = inst;\n \t\t*dma_prog++ = cols/2 | (cols/2 << 16);\n \t\t*dma_prog++ = target_buffer;\n \t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n \t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/4) + i*cols/2 * interlace;\n \t\ttarget_buffer += interlace*cols;\n \t\t*dma_prog++ = inst1;\n \t\t*dma_prog++ = cols/2 | (cols/2 << 16);\n \t\t*dma_prog++ = target_buffer;\n \t\ttarget_buffer += interlace*cols;\n \n \t}\n \n \tswitch (i_flag) {\n \tcase 1:\n \t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;  /*sync vre*/\n \t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n \t\treturn;\n\n \tcase 2:\n \t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;  /*sync vro*/\n \t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n \t\treturn;\n \n \tcase 3:\n \t\t*dma_prog++ = OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\ttarget_buffer  = (u_long) buffer + cols;\n\t\tt1 = buffer + cols/2;\n\t\t*dma_prog++ = OP_SYNC   | 1 << 15 | BKTR_FM3; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < ((rows/interlace )/2 ) ; i++) {\n\t\t    *dma_prog++ = inst;\n\t\t    *dma_prog++ = cols/2 | (cols/2 << 16);\n         \t    *dma_prog++ = target_buffer;\n\t\t    *dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t    *dma_prog++ = t1 + (cols*rows) + (cols*rows/4) + i*cols/2 * interlace;\n\t\t    target_buffer += interlace*cols;\n\t\t    *dma_prog++ = inst1;\n\t\t    *dma_prog++ = cols/2 | (cols/2 << 16);\n\t\t    *dma_prog++ = target_buffer;\n\t\t    target_buffer += interlace*cols;\n\n\t\t}\t\n\n\t\n\t}\n    \n\t*dma_prog++ = OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t*dma_prog++ = 0;  /* NULL WORD */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define OP_EOL\t      (1 << 26)",
      "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
      "#define OP_WRITES123  (0xb << 28)",
      "#define OP_WRITE123   (0x9 << 28)",
      "#define OP_SYNC\t      (0x8 << 28)",
      "#define OP_JUMP\t      (0x7 << 28)",
      "#define BKTR_VRO      0xC\t/* Marks the end of the odd field */",
      "#define BKTR_VRE      0x4\t/* Marks the end of the even field */",
      "#define BKTR_FM3      0xe\t/* planar data to follow */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->odd_dma_prog"
          ],
          "line": 4257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->bigbuf"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_WRITES123  (0xb << 28)\n#define OP_WRITE123   (0x9 << 28)\n#define OP_SYNC\t      (0x8 << 28)\n#define OP_JUMP\t      (0x7 << 28)\n#define BKTR_VRO      0xC\t/* Marks the end of the odd field */\n#define BKTR_VRE      0x4\t/* Marks the end of the even field */\n#define BKTR_FM3      0xe\t/* planar data to follow */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic void\nyuv12_prog( bktr_ptr_t bktr, char i_flag,\n\t     int cols, int rows, int interlace ){\n\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile unsigned int\tinst1;\n\tvolatile u_long\t\ttarget_buffer, t1, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 |\t3;\n\n\tbt848->adc = SYNC_LEVEL;\n\tbt848->oform = 0x0;\n \n\t/* Construct Write */\n \tinst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols); \n \tinst1  = OP_WRITES123  | OP_SOL | OP_EOL |  (cols); \n \tif (bktr->video.addr)\n \t\ttarget_buffer = (u_long) bktr->video.addr;\n \telse\n \t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n     \n\tbuffer = target_buffer;\n \tt1 = buffer;\n \n \t*dma_prog++ = OP_SYNC  | 1 << 15 |\tBKTR_FM3; /*sync, mode indicator packed data*/\n \t*dma_prog++ = 0;  /* NULL WORD */\n \t       \n \tfor (i = 0; i < (rows/interlace )/2 ; i++) {\n\t\t*dma_prog++ = inst;\n \t\t*dma_prog++ = cols/2 | (cols/2 << 16);\n \t\t*dma_prog++ = target_buffer;\n \t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n \t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/4) + i*cols/2 * interlace;\n \t\ttarget_buffer += interlace*cols;\n \t\t*dma_prog++ = inst1;\n \t\t*dma_prog++ = cols/2 | (cols/2 << 16);\n \t\t*dma_prog++ = target_buffer;\n \t\ttarget_buffer += interlace*cols;\n \n \t}\n \n \tswitch (i_flag) {\n \tcase 1:\n \t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;  /*sync vre*/\n \t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n \t\treturn;\n\n \tcase 2:\n \t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;  /*sync vro*/\n \t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n \t\treturn;\n \n \tcase 3:\n \t\t*dma_prog++ = OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\ttarget_buffer  = (u_long) buffer + cols;\n\t\tt1 = buffer + cols/2;\n\t\t*dma_prog++ = OP_SYNC   | 1 << 15 | BKTR_FM3; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < ((rows/interlace )/2 ) ; i++) {\n\t\t    *dma_prog++ = inst;\n\t\t    *dma_prog++ = cols/2 | (cols/2 << 16);\n         \t    *dma_prog++ = target_buffer;\n\t\t    *dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t    *dma_prog++ = t1 + (cols*rows) + (cols*rows/4) + i*cols/2 * interlace;\n\t\t    target_buffer += interlace*cols;\n\t\t    *dma_prog++ = inst1;\n\t\t    *dma_prog++ = cols/2 | (cols/2 << 16);\n\t\t    *dma_prog++ = target_buffer;\n\t\t    target_buffer += interlace*cols;\n\n\t\t}\t\n\n\t\n\t}\n    \n\t*dma_prog++ = OP_SYNC |  1 << 24 | 1 << 15 | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t*dma_prog++ = 0;  /* NULL WORD */\n}"
  },
  {
    "function_name": "yuv422_prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "4069-4179",
    "snippet": "static void\nyuv422_prog( bktr_ptr_t bktr, char i_flag,\n\t     int cols, int rows, int interlace ){\n\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile u_long\t\ttarget_buffer, t1, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 |\t3;\n\n\tbt848->adc = SYNC_LEVEL;\n\tbt848->oform = 0x00;\n\n\tbt848->e_control |= BT848_E_CONTROL_LDEC; /* disable luma decimation */\n\tbt848->o_control |= BT848_O_CONTROL_LDEC;\n\n\tbt848->e_scloop |= BT848_O_SCLOOP_CAGC;\t/* chroma agc enable */\n\tbt848->o_scloop |= BT848_O_SCLOOP_CAGC; \n\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n\tbt848->o_vscale_hi |= 0x40;\n\n\t/* disable gamma correction removal */\n\tbt848->color_ctl_gamma = 1;\n\n\t/* Construct Write */\n\tinst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols); \n\tif (bktr->video.addr)\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\telse\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n    \n\tbuffer = target_buffer;\n\n\tt1 = buffer;\n\n\t/* contruct sync : for video packet format */\n\t*dma_prog++ = OP_SYNC  | 1 << 15 |\tBKTR_FM3; /*sync, mode indicator packed data*/\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\tfor (i = 0; i < (rows/interlace ) ; i++) {\n\t\t*dma_prog++ = inst;\n\t\t*dma_prog++ = cols/2 | cols/2 << 16;\n\t\t*dma_prog++ = target_buffer;\n\t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/2) + i*cols/2 * interlace;\n\t\ttarget_buffer += interlace*cols;\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;  /*sync vre*/\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP ;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;  /*sync vre*/\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t*dma_prog++ = OP_SYNC\t| 1 << 24 |  1 << 15 |   BKTR_VRO; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP  ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\ttarget_buffer  = (u_long) buffer + cols;\n\t\tt1 = buffer + cols/2;\n\t\t*dma_prog++ = OP_SYNC\t|   1 << 15 | BKTR_FM3; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < (rows/interlace )  ; i++) {\n\t\t\t*dma_prog++ = inst;\n\t\t\t*dma_prog++ = cols/2 | cols/2 << 16;\n\t\t\t*dma_prog++ = target_buffer;\n\t\t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/2) + i*cols/2 * interlace;\n\t\t\ttarget_buffer += interlace*cols;\n\t\t}\n\t}\n    \n\t*dma_prog++ = OP_SYNC  | 1 << 24 | 1 << 15 |   BKTR_VRE; \n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define OP_EOL\t      (1 << 26)",
      "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
      "#define OP_WRITE123   (0x9 << 28)",
      "#define OP_SYNC\t      (0x8 << 28)",
      "#define OP_JUMP\t      (0x7 << 28)",
      "#define BKTR_VRO      0xC\t/* Marks the end of the odd field */",
      "#define BKTR_VRE      0x4\t/* Marks the end of the even field */",
      "#define BKTR_FM3      0xe\t/* planar data to follow */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->odd_dma_prog"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->bigbuf"
          ],
          "line": 4110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_WRITE123   (0x9 << 28)\n#define OP_SYNC\t      (0x8 << 28)\n#define OP_JUMP\t      (0x7 << 28)\n#define BKTR_VRO      0xC\t/* Marks the end of the odd field */\n#define BKTR_VRE      0x4\t/* Marks the end of the even field */\n#define BKTR_FM3      0xe\t/* planar data to follow */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic void\nyuv422_prog( bktr_ptr_t bktr, char i_flag,\n\t     int cols, int rows, int interlace ){\n\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile u_long\t\ttarget_buffer, t1, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 |\t3;\n\n\tbt848->adc = SYNC_LEVEL;\n\tbt848->oform = 0x00;\n\n\tbt848->e_control |= BT848_E_CONTROL_LDEC; /* disable luma decimation */\n\tbt848->o_control |= BT848_O_CONTROL_LDEC;\n\n\tbt848->e_scloop |= BT848_O_SCLOOP_CAGC;\t/* chroma agc enable */\n\tbt848->o_scloop |= BT848_O_SCLOOP_CAGC; \n\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n\tbt848->o_vscale_hi |= 0x40;\n\n\t/* disable gamma correction removal */\n\tbt848->color_ctl_gamma = 1;\n\n\t/* Construct Write */\n\tinst  = OP_WRITE123  | OP_SOL | OP_EOL |  (cols); \n\tif (bktr->video.addr)\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\telse\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n    \n\tbuffer = target_buffer;\n\n\tt1 = buffer;\n\n\t/* contruct sync : for video packet format */\n\t*dma_prog++ = OP_SYNC  | 1 << 15 |\tBKTR_FM3; /*sync, mode indicator packed data*/\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\tfor (i = 0; i < (rows/interlace ) ; i++) {\n\t\t*dma_prog++ = inst;\n\t\t*dma_prog++ = cols/2 | cols/2 << 16;\n\t\t*dma_prog++ = target_buffer;\n\t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/2) + i*cols/2 * interlace;\n\t\ttarget_buffer += interlace*cols;\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;  /*sync vre*/\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP ;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;  /*sync vre*/\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t*dma_prog++ = OP_SYNC\t| 1 << 24 |  1 << 15 |   BKTR_VRO; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP  ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\ttarget_buffer  = (u_long) buffer + cols;\n\t\tt1 = buffer + cols/2;\n\t\t*dma_prog++ = OP_SYNC\t|   1 << 15 | BKTR_FM3; \n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < (rows/interlace )  ; i++) {\n\t\t\t*dma_prog++ = inst;\n\t\t\t*dma_prog++ = cols/2 | cols/2 << 16;\n\t\t\t*dma_prog++ = target_buffer;\n\t\t\t*dma_prog++ = t1 + (cols*rows) + i*cols/2 * interlace;\n\t\t\t*dma_prog++ = t1 + (cols*rows) + (cols*rows/2) + i*cols/2 * interlace;\n\t\t\ttarget_buffer += interlace*cols;\n\t\t}\n\t}\n    \n\t*dma_prog++ = OP_SYNC  | 1 << 24 | 1 << 15 |   BKTR_VRE; \n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n}"
  },
  {
    "function_name": "yuvpack_prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "3950-4063",
    "snippet": "static void\nyuvpack_prog( bktr_ptr_t bktr, char i_flag,\n\t      int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile unsigned int\tinst3;\n\tvolatile u_long\t\ttarget_buffer, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tint\t\t\tb;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tbt848->e_scloop |= BT848_E_SCLOOP_CAGC; /* enable chroma comb */\n\tbt848->o_scloop |= BT848_O_SCLOOP_CAGC;\n\n\tbt848->color_ctl_rgb_ded = 1;\n\tbt848->color_ctl_gamma = 1;\n\tbt848->adc = SYNC_LEVEL;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 | 1 << 2 | 3;\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n    \n\t/* write , sol, eol */\n\tinst = OP_WRITE\t | OP_SOL | (cols);\n\t/* write , sol, eol */\n\tinst3 = OP_WRITE | OP_EOL | (cols);\n\n\tif (bktr->video.addr)\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\telse\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\n\tbuffer = target_buffer;\n\n\t/* contruct sync : for video packet format */\n\t/* sync, mode indicator packed data */\n\t*dma_prog++ = OP_SYNC | 1 << 15 | BKTR_FM1;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\tb = cols;\n\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t*dma_prog++ = inst;\n\t\t*dma_prog++ = target_buffer;\n\t\t*dma_prog++ = inst3;\n\t\t*dma_prog++ = target_buffer + b; \n\t\ttarget_buffer += interlace*(cols * 2);\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC\t | 1 << 24 | 1 << 15 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP  ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\ttarget_buffer =\t (u_long) buffer + cols*2;\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC | 1 << 24 |  1 << 15 | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < (rows/interlace) ; i++) {\n\t\t\t*dma_prog++ = inst;\n\t\t\t*dma_prog++ = target_buffer;\n\t\t\t*dma_prog++ = inst3;\n\t\t\t*dma_prog++ = target_buffer + b;\n\t\t\ttarget_buffer += interlace * ( cols*2);\n\t\t}\n\t}\n\n\t/* sync vro IRQ bit */\n\t*dma_prog++ = OP_SYNC   |  1 << 24  | 1 << 15 |  BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\n\t*dma_prog++ = OP_JUMP;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t*dma_prog++ = 0;  /* NULL WORD */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define OP_EOL\t      (1 << 26)",
      "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
      "#define OP_SYNC\t      (0x8 << 28)",
      "#define OP_JUMP\t      (0x7 << 28)",
      "#define OP_WRITE      (0x1 << 28)",
      "#define BKTR_VRO      0xC\t/* Marks the end of the odd field */",
      "#define BKTR_VRE      0x4\t/* Marks the end of the even field */",
      "#define BKTR_FM1      0x6\t/* packed data to follow */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->odd_dma_prog"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->bigbuf"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_SYNC\t      (0x8 << 28)\n#define OP_JUMP\t      (0x7 << 28)\n#define OP_WRITE      (0x1 << 28)\n#define BKTR_VRO      0xC\t/* Marks the end of the odd field */\n#define BKTR_VRE      0x4\t/* Marks the end of the even field */\n#define BKTR_FM1      0x6\t/* packed data to follow */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic void\nyuvpack_prog( bktr_ptr_t bktr, char i_flag,\n\t      int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tvolatile unsigned int\tinst;\n\tvolatile unsigned int\tinst3;\n\tvolatile u_long\t\ttarget_buffer, buffer;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tint\t\t\tb;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\n\tbt848->e_scloop |= BT848_E_SCLOOP_CAGC; /* enable chroma comb */\n\tbt848->o_scloop |= BT848_O_SCLOOP_CAGC;\n\n\tbt848->color_ctl_rgb_ded = 1;\n\tbt848->color_ctl_gamma = 1;\n\tbt848->adc = SYNC_LEVEL;\n\n\tbktr->capcontrol =   1 << 6 | 1 << 4 | 1 << 2 | 3;\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n    \n\t/* write , sol, eol */\n\tinst = OP_WRITE\t | OP_SOL | (cols);\n\t/* write , sol, eol */\n\tinst3 = OP_WRITE | OP_EOL | (cols);\n\n\tif (bktr->video.addr)\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\telse\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\n\tbuffer = target_buffer;\n\n\t/* contruct sync : for video packet format */\n\t/* sync, mode indicator packed data */\n\t*dma_prog++ = OP_SYNC | 1 << 15 | BKTR_FM1;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\tb = cols;\n\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t*dma_prog++ = inst;\n\t\t*dma_prog++ = target_buffer;\n\t\t*dma_prog++ = inst3;\n\t\t*dma_prog++ = target_buffer + b; \n\t\ttarget_buffer += interlace*(cols * 2);\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC  | 1 << 24 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC\t | 1 << 24 | 1 << 15 | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP  ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t\ttarget_buffer =\t (u_long) buffer + cols*2;\n\n\t\tdma_prog = (u_long * ) bktr->odd_dma_prog;\n\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC | 1 << 24 |  1 << 15 | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\tfor (i = 0; i < (rows/interlace) ; i++) {\n\t\t\t*dma_prog++ = inst;\n\t\t\t*dma_prog++ = target_buffer;\n\t\t\t*dma_prog++ = inst3;\n\t\t\t*dma_prog++ = target_buffer + b;\n\t\t\ttarget_buffer += interlace * ( cols*2);\n\t\t}\n\t}\n\n\t/* sync vro IRQ bit */\n\t*dma_prog++ = OP_SYNC   |  1 << 24  | 1 << 15 |  BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\n\t*dma_prog++ = OP_JUMP;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t*dma_prog++ = 0;  /* NULL WORD */\n}"
  },
  {
    "function_name": "rgb_prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "3784-3944",
    "snippet": "static void\nrgb_prog( bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\ttarget_buffer, buffer, target,width;\n\tvolatile u_long\t\tpitch;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tu_int                   Bpp = pf_int->public.Bpp;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\tbt848->vbi_pack_size     = 0;\t    \n\tbt848->vbi_pack_del      = 0;\n\tbt848->adc               = SYNC_LEVEL;\n\n\tbt848->oform = 0x00;\n\n \tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n \tbt848->o_vscale_hi |= 0x40;\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\n \t/* disable gamma correction removal */\n \tbt848->color_ctl_gamma = 1;\n\n\n\tif (cols > 385 ) {\n\t    bt848->e_vtc = 0;\n\t    bt848->o_vtc = 0;\n\t} else {\n\t    bt848->e_vtc = 1;\n\t    bt848->o_vtc = 1;\n\t}\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n\n\tif (bktr->video.addr) {\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\t\tpitch = bktr->video.width;\n\t}\n\telse {\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\t\tpitch = cols*Bpp;\n\t}\n\n\tbuffer = target_buffer;\n\n\t/* contruct sync : for video packet format */\n\t*dma_prog++ = OP_SYNC  | BKTR_RESYNC | BKTR_FM1;\n\n\t/* sync, mode indicator packed data */\n\t*dma_prog++ = 0;  /* NULL WORD */\n\twidth = cols;\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t    target = target_buffer;\n\t    if ( notclipped(bktr, i, width)) {\n\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t      Bpp, (volatile u_char **) &target,  cols);\n\n\t    } else {\n\t\twhile(getline(bktr, i)) {\n\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target, cols);\n\t\t    }\n\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\tsplit(bktr,(volatile u_long **) &dma_prog,\n\t\t\t      bktr->yclip2 - bktr->yclip,\n\t\t\t      OP_SKIP,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    target_buffer += interlace * pitch;\n\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP; ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t        target_buffer = buffer + pitch; \n\n\t\tdma_prog = (u_long *) bktr->odd_dma_prog;\n\n\t\t/* sync vre IRQ bit */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n                width = cols;\n\t\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t    target = target_buffer;\n\t\t    if ( notclipped(bktr, i, width)) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    } else {\n\t\t\twhile(getline(bktr, i)) {\n\t\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t\t      Bpp, (volatile u_char **) &target,\n\t\t\t\t      cols);\n\t\t\t    }\t\n\t\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->yclip2 - bktr->yclip, OP_SKIP,\n\t\t\t\t      Bpp, (volatile u_char **)  &target,  cols);\n\t\t\t    }\t\n\n\t\t\t}\t\n\n\t\t    }\n\n\t\t    target_buffer += interlace * pitch;\n\n\t\t}\n\t}\n\n\t/* sync vre IRQ bit */\n\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BKTR_GEN_IRQ  (1 << 24)",
      "#define BKTR_RESYNC   (1 << 15)",
      "#define OP_SYNC\t      (0x8 << 28)",
      "#define OP_JUMP\t      (0x7 << 28)",
      "#define OP_SKIP       (0x2 << 28)",
      "#define OP_WRITE      (0x1 << 28)",
      "#define BKTR_VRO      0xC\t/* Marks the end of the odd field */",
      "#define BKTR_VRE      0x4\t/* Marks the end of the even field */",
      "#define BKTR_FM1      0x6\t/* packed data to follow */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 3942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split",
          "args": [
            "bktr",
            "(volatile u_long **) &dma_prog",
            "bktr->yclip2 - bktr->yclip",
            "OP_SKIP",
            "Bpp",
            "(volatile u_char **)  &target",
            "cols"
          ],
          "line": 3924
        },
        "resolved": true,
        "details": {
          "function_name": "split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "3491-3571",
          "snippet": "static bool_t split(bktr_reg_t * bktr, volatile u_long **dma_prog, int width ,\n\t\t    u_long operation, int pixel_width,\n\t\t    volatile u_char ** target_buffer, int cols ) {\n\n u_long flag, flag2;\n struct meteor_pixfmt *pf = &pixfmt_table[ bktr->pixfmt ].public;\n u_int  skip, start_skip;\n\n  /*  For RGB24, we need to align the component in FIFO Byte Lane 0         */\n  /*    to the 1st byte in the mem dword containing our start addr.         */\n  /*    BTW, we know this pixfmt's 1st byte is Blue; thus the start addr    */\n  /*     must be Blue.                                                      */\n  start_skip = 0;\n  if (( pf->type == METEOR_PIXTYPE_RGB ) && ( pf->Bpp == 3 ))\n\t  switch ( ((uintptr_t) (volatile void *) *target_buffer) % 4 ) {\n\t  case 2 : start_skip = 4 ; break;\n\t  case 1 : start_skip = 8 ; break;\n\t  }\n\n if ((width * pixel_width) < DMA_BT848_SPLIT ) {\n     if (  width == cols) {\n\t flag = OP_SOL | OP_EOL;\n       } else if (bktr->current_col == 0 ) {\n\t    flag  = OP_SOL;\n       } else if (bktr->current_col == cols) {\n\t    flag = OP_EOL;\n       } else flag = 0;\t\n\n     skip = 0;\n     if (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t     *(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t     flag &= ~OP_SOL;\n\t     skip = start_skip;\n     }\n\n     *(*dma_prog)++ = operation | flag  | (width * pixel_width - skip);\n     if (operation != OP_SKIP ) \n\t *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer;\n\n     *target_buffer += width * pixel_width;\n     bktr->current_col += width;\n\n } else {\n\n\tif (bktr->current_col == 0 && width == cols) {\n\t    flag = OP_SOL ;\n\t    flag2 = OP_EOL;\n        } else if (bktr->current_col == 0 ) {\n\t    flag = OP_SOL;\n\t    flag2 = 0;\n\t} else if (bktr->current_col >= cols)  {\n\t    flag =  0;\n\t    flag2 = OP_EOL;\n\t} else {\n\t    flag =  0;\n\t    flag2 = 0;\n\t}\n\n\tskip = 0;\n\tif (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t\t*(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t\tflag &= ~OP_SOL;\n\t\tskip = start_skip;\n\t}\n\n\t*(*dma_prog)++ = operation  | flag |\n\t      (width * pixel_width / 2 - skip);\n\tif (operation != OP_SKIP ) \n\t      *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer ;\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\n\tif ( operation == OP_WRITE )\n\t\toperation = OP_WRITEC;\n\t*(*dma_prog)++ = operation | flag2 |\n\t    (width * pixel_width / 2);\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\t  bktr->current_col += width;\n\n    }\n return TRUE;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define OP_EOL\t      (1 << 26)",
            "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
            "#define OP_WRITEC     (0x5 << 28)",
            "#define OP_SKIP       (0x2 << 28)",
            "#define OP_WRITE      (0x1 << 28)",
            "#define DMA_BT848_SPLIT 319*2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_WRITEC     (0x5 << 28)\n#define OP_SKIP       (0x2 << 28)\n#define OP_WRITE      (0x1 << 28)\n#define DMA_BT848_SPLIT 319*2\n\nstatic bool_t split(bktr_reg_t * bktr, volatile u_long **dma_prog, int width ,\n\t\t    u_long operation, int pixel_width,\n\t\t    volatile u_char ** target_buffer, int cols ) {\n\n u_long flag, flag2;\n struct meteor_pixfmt *pf = &pixfmt_table[ bktr->pixfmt ].public;\n u_int  skip, start_skip;\n\n  /*  For RGB24, we need to align the component in FIFO Byte Lane 0         */\n  /*    to the 1st byte in the mem dword containing our start addr.         */\n  /*    BTW, we know this pixfmt's 1st byte is Blue; thus the start addr    */\n  /*     must be Blue.                                                      */\n  start_skip = 0;\n  if (( pf->type == METEOR_PIXTYPE_RGB ) && ( pf->Bpp == 3 ))\n\t  switch ( ((uintptr_t) (volatile void *) *target_buffer) % 4 ) {\n\t  case 2 : start_skip = 4 ; break;\n\t  case 1 : start_skip = 8 ; break;\n\t  }\n\n if ((width * pixel_width) < DMA_BT848_SPLIT ) {\n     if (  width == cols) {\n\t flag = OP_SOL | OP_EOL;\n       } else if (bktr->current_col == 0 ) {\n\t    flag  = OP_SOL;\n       } else if (bktr->current_col == cols) {\n\t    flag = OP_EOL;\n       } else flag = 0;\t\n\n     skip = 0;\n     if (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t     *(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t     flag &= ~OP_SOL;\n\t     skip = start_skip;\n     }\n\n     *(*dma_prog)++ = operation | flag  | (width * pixel_width - skip);\n     if (operation != OP_SKIP ) \n\t *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer;\n\n     *target_buffer += width * pixel_width;\n     bktr->current_col += width;\n\n } else {\n\n\tif (bktr->current_col == 0 && width == cols) {\n\t    flag = OP_SOL ;\n\t    flag2 = OP_EOL;\n        } else if (bktr->current_col == 0 ) {\n\t    flag = OP_SOL;\n\t    flag2 = 0;\n\t} else if (bktr->current_col >= cols)  {\n\t    flag =  0;\n\t    flag2 = OP_EOL;\n\t} else {\n\t    flag =  0;\n\t    flag2 = 0;\n\t}\n\n\tskip = 0;\n\tif (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t\t*(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t\tflag &= ~OP_SOL;\n\t\tskip = start_skip;\n\t}\n\n\t*(*dma_prog)++ = operation  | flag |\n\t      (width * pixel_width / 2 - skip);\n\tif (operation != OP_SKIP ) \n\t      *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer ;\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\n\tif ( operation == OP_WRITE )\n\t\toperation = OP_WRITEC;\n\t*(*dma_prog)++ = operation | flag2 |\n\t    (width * pixel_width / 2);\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\t  bktr->current_col += width;\n\n    }\n return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "bktr",
            "i"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "3447-3489",
          "snippet": "bool_t getline(bktr_reg_t *bktr, int x ) {\n    int i, j;\n    bktr_clip_t * clip_node ;\n    \n    if (bktr->line_length == 0 || \n\tbktr->current_col >= bktr->line_length) return FALSE;\n\n    bktr->y = min(bktr->last_y, bktr->line_length);\n    bktr->y2 = bktr->line_length;\n\n    bktr->yclip = bktr->yclip2 = -1;\n    for (i = bktr->clip_start; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t    if (bktr->last_y <= clip_node->y_min) {\n\t\tbktr->y =      min(bktr->last_y, bktr->line_length);\n\t\tbktr->y2 =     min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip =  min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\tbktr->last_y = bktr->yclip2;\n\t\tbktr->clip_start = i;\n\t\t\n\t\tfor (j = i+1; j  < bktr->max_clip_node; j++ ) {\n\t\t    clip_node = (bktr_clip_t *) &bktr->clip_list[j];\n\t\t    if (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t\t\tif (bktr->last_y >= clip_node->y_min) {\n\t\t\t    bktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\t\t    bktr->last_y = bktr->yclip2;\n\t\t\t    bktr->clip_start = j;\n\t\t\t}\t\n\t\t    } else break  ;\n\t\t}\t\n\t\treturn TRUE;\n\t    }\t\n\t}\n    }\n\n    if (bktr->current_col <= bktr->line_length) {\n\tbktr->current_col = bktr->line_length;\n\treturn TRUE;\n    }\n    return FALSE;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nbool_t getline(bktr_reg_t *bktr, int x ) {\n    int i, j;\n    bktr_clip_t * clip_node ;\n    \n    if (bktr->line_length == 0 || \n\tbktr->current_col >= bktr->line_length) return FALSE;\n\n    bktr->y = min(bktr->last_y, bktr->line_length);\n    bktr->y2 = bktr->line_length;\n\n    bktr->yclip = bktr->yclip2 = -1;\n    for (i = bktr->clip_start; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t    if (bktr->last_y <= clip_node->y_min) {\n\t\tbktr->y =      min(bktr->last_y, bktr->line_length);\n\t\tbktr->y2 =     min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip =  min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\tbktr->last_y = bktr->yclip2;\n\t\tbktr->clip_start = i;\n\t\t\n\t\tfor (j = i+1; j  < bktr->max_clip_node; j++ ) {\n\t\t    clip_node = (bktr_clip_t *) &bktr->clip_list[j];\n\t\t    if (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t\t\tif (bktr->last_y >= clip_node->y_min) {\n\t\t\t    bktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\t\t    bktr->last_y = bktr->yclip2;\n\t\t\t    bktr->clip_start = j;\n\t\t\t}\t\n\t\t    } else break  ;\n\t\t}\t\n\t\treturn TRUE;\n\t    }\t\n\t}\n    }\n\n    if (bktr->current_col <= bktr->line_length) {\n\tbktr->current_col = bktr->line_length;\n\treturn TRUE;\n    }\n    return FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "notclipped",
          "args": [
            "bktr",
            "i",
            "width"
          ],
          "line": 3911
        },
        "resolved": true,
        "details": {
          "function_name": "notclipped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "3420-3445",
          "snippet": "bool_t notclipped (bktr_reg_t * bktr, int x, int width) {\n    int i;\n    bktr_clip_t * clip_node;\n    bktr->clip_start = -1;\n    bktr->last_y = 0;\n    bktr->y = 0;\n    bktr->y2 = width;\n    bktr->line_length = width;\n    bktr->yclip = -1;\n    bktr->yclip2 = -1;\n    bktr->current_col = 0;\n    \n    if (bktr->max_clip_node == 0 ) return TRUE;\n    clip_node = (bktr_clip_t *) &bktr->clip_list[0];\n\n\n    for (i = 0; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max  ) {\n\t    bktr->clip_start = i;\n\t    return FALSE;\n\t}\n    }\t\n    \n    return TRUE;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nbool_t notclipped (bktr_reg_t * bktr, int x, int width) {\n    int i;\n    bktr_clip_t * clip_node;\n    bktr->clip_start = -1;\n    bktr->last_y = 0;\n    bktr->y = 0;\n    bktr->y2 = width;\n    bktr->line_length = width;\n    bktr->yclip = -1;\n    bktr->yclip2 = -1;\n    bktr->current_col = 0;\n    \n    if (bktr->max_clip_node == 0 ) return TRUE;\n    clip_node = (bktr_clip_t *) &bktr->clip_list[0];\n\n\n    for (i = 0; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max  ) {\n\t    bktr->clip_start = i;\n\t    return FALSE;\n\t}\n    }\t\n    \n    return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->odd_dma_prog"
          ],
          "line": 3895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->bigbuf"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BKTR_GEN_IRQ  (1 << 24)\n#define BKTR_RESYNC   (1 << 15)\n#define OP_SYNC\t      (0x8 << 28)\n#define OP_JUMP\t      (0x7 << 28)\n#define OP_SKIP       (0x2 << 28)\n#define OP_WRITE      (0x1 << 28)\n#define BKTR_VRO      0xC\t/* Marks the end of the odd field */\n#define BKTR_VRE      0x4\t/* Marks the end of the even field */\n#define BKTR_FM1      0x6\t/* packed data to follow */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic void\nrgb_prog( bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\ttarget_buffer, buffer, target,width;\n\tvolatile u_long\t\tpitch;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tu_int                   Bpp = pf_int->public.Bpp;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\tbt848->vbi_pack_size     = 0;\t    \n\tbt848->vbi_pack_del      = 0;\n\tbt848->adc               = SYNC_LEVEL;\n\n\tbt848->oform = 0x00;\n\n \tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n \tbt848->o_vscale_hi |= 0x40;\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\n \t/* disable gamma correction removal */\n \tbt848->color_ctl_gamma = 1;\n\n\n\tif (cols > 385 ) {\n\t    bt848->e_vtc = 0;\n\t    bt848->o_vtc = 0;\n\t} else {\n\t    bt848->e_vtc = 1;\n\t    bt848->o_vtc = 1;\n\t}\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n\n\tif (bktr->video.addr) {\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\t\tpitch = bktr->video.width;\n\t}\n\telse {\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\t\tpitch = cols*Bpp;\n\t}\n\n\tbuffer = target_buffer;\n\n\t/* contruct sync : for video packet format */\n\t*dma_prog++ = OP_SYNC  | BKTR_RESYNC | BKTR_FM1;\n\n\t/* sync, mode indicator packed data */\n\t*dma_prog++ = 0;  /* NULL WORD */\n\twidth = cols;\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t    target = target_buffer;\n\t    if ( notclipped(bktr, i, width)) {\n\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t      Bpp, (volatile u_char **) &target,  cols);\n\n\t    } else {\n\t\twhile(getline(bktr, i)) {\n\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target, cols);\n\t\t    }\n\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\tsplit(bktr,(volatile u_long **) &dma_prog,\n\t\t\t      bktr->yclip2 - bktr->yclip,\n\t\t\t      OP_SKIP,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    target_buffer += interlace * pitch;\n\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* sync vre */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* sync vro */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\t*dma_prog++ = OP_JUMP; ;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t        target_buffer = buffer + pitch; \n\n\t\tdma_prog = (u_long *) bktr->odd_dma_prog;\n\n\t\t/* sync vre IRQ bit */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n                width = cols;\n\t\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t    target = target_buffer;\n\t\t    if ( notclipped(bktr, i, width)) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    } else {\n\t\t\twhile(getline(bktr, i)) {\n\t\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t\t      Bpp, (volatile u_char **) &target,\n\t\t\t\t      cols);\n\t\t\t    }\t\n\t\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->yclip2 - bktr->yclip, OP_SKIP,\n\t\t\t\t      Bpp, (volatile u_char **)  &target,  cols);\n\t\t\t    }\t\n\n\t\t\t}\t\n\n\t\t    }\n\n\t\t    target_buffer += interlace * pitch;\n\n\t\t}\n\t}\n\n\t/* sync vre IRQ bit */\n\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n}"
  },
  {
    "function_name": "rgb_vbi_prog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "3577-3779",
    "snippet": "static void\nrgb_vbi_prog( bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\ttarget_buffer, buffer, target,width;\n\tvolatile u_long\t\tpitch;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tu_int                   Bpp = pf_int->public.Bpp;\n\tunsigned int            vbisamples;     /* VBI samples per line */\n\tunsigned int            vbilines;       /* VBI lines per field */\n\tunsigned int            num_dwords;     /* DWORDS per line */\n\n\tvbisamples = format_params[bktr->format_params].vbi_num_samples;\n\tvbilines   = format_params[bktr->format_params].vbi_num_lines;\n\tnum_dwords = vbisamples/4;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\tbt848->adc               = SYNC_LEVEL;\n\tbt848->vbi_pack_size     = ((num_dwords))     & 0xff;\n\tbt848->vbi_pack_del      = ((num_dwords)>> 8) & 0x01; /* no hdelay    */\n\t\t\t\t\t\t\t      /* no ext frame */\n\n\tbt848->oform = 0x00;\n\n \tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n \tbt848->o_vscale_hi |= 0x40;\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\n \t/* disable gamma correction removal */\n \tbt848->color_ctl_gamma = 1;\n\n\n\tif (cols > 385 ) {\n\t    bt848->e_vtc = 0;\n\t    bt848->o_vtc = 0;\n\t} else {\n\t    bt848->e_vtc = 1;\n\t    bt848->o_vtc = 1;\n\t}\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n\n\tif (bktr->video.addr) {\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\t\tpitch = bktr->video.width;\n\t}\n\telse {\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\t\tpitch = cols*Bpp;\n\t}\n\n\tbuffer = target_buffer;\n\n\n\t/* store the VBI data */\n\t/* look for sync with packed data */\n\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t*dma_prog++ = 0;\n\tfor(i = 0; i < vbilines; i++) {\n\t\t*dma_prog++ = OP_WRITE | OP_SOL | OP_EOL | vbisamples;\n\t\t*dma_prog++ = (u_long) vtophys(bktr->vbidata +\n\t\t\t\t\t(i * VBI_LINE_SIZE));\n\t}\n\n\t/* store the video image */\n\t/* look for sync with packed data */\n\t*dma_prog++ = OP_SYNC  | BKTR_RESYNC | BKTR_FM1;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\twidth = cols;\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t    target = target_buffer;\n\t    if ( notclipped(bktr, i, width)) {\n\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t      Bpp, (volatile u_char **) &target,  cols);\n\n\t    } else {\n\t\twhile(getline(bktr, i)) {\n\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target, cols);\n\t\t    }\n\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\tsplit(bktr,(volatile u_long **) &dma_prog,\n\t\t\t      bktr->yclip2 - bktr->yclip,\n\t\t\t      OP_SKIP,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    target_buffer += interlace * pitch;\n\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* EVEN field grabs. Look for end of 'Even Field' Marker\n\t\t * We cannot look for VRO, because we have not enabled ODD\n\t\t * field capture\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* ODD field grabs. Look for end of 'Odd Field' Marker\n\t\t * We cannot look for VRE, because we have not enabled EVEN\n\t\t * field capture\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* INTERLACED grabs (ODD then EVEN). We have read the old field\n\t\t * so look for the end of 'Odd Field' Marker.\n\t\t * Then jump to the 'odd_dma_prog' which actually captures\n\t\t * the EVEN field!\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t        target_buffer = buffer + pitch; \n\n\t\tdma_prog = (u_long *) bktr->odd_dma_prog;\n\n\t\t/* store the VBI data */\n\t\t/* look for sync with packed data */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;\n\t\tfor(i = 0; i < vbilines; i++) {\n\t\t\t*dma_prog++ = OP_WRITE | OP_SOL | OP_EOL | vbisamples;\n\t\t\t*dma_prog++ = (u_long) vtophys(bktr->vbidata +\n\t\t\t\t\t((i+MAX_VBI_LINES) * VBI_LINE_SIZE));\n\t\t}\n\n\t\t/* store the video image */\n\t\t/* look for sync with packed data */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\twidth = cols;\n\t\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t    target = target_buffer;\n\t\t    if ( notclipped(bktr, i, width)) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    } else {\n\t\t\twhile(getline(bktr, i)) {\n\t\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t\t      Bpp, (volatile u_char **) &target,\n\t\t\t\t      cols);\n\t\t\t    }\t\n\t\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->yclip2 - bktr->yclip, OP_SKIP,\n\t\t\t\t      Bpp, (volatile u_char **)  &target,  cols);\n\t\t\t    }\t\n\n\t\t\t}\t\n\n\t\t    }\n\n\t\t    target_buffer += interlace * pitch;\n\n\t\t}\n\t}\n\n\t/* Look for end of 'Even Field' */\n\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define BKTR_GEN_IRQ  (1 << 24)",
      "#define BKTR_RESYNC   (1 << 15)",
      "#define OP_EOL\t      (1 << 26)",
      "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
      "#define OP_SYNC\t      (0x8 << 28)",
      "#define OP_JUMP\t      (0x7 << 28)",
      "#define OP_SKIP       (0x2 << 28)",
      "#define OP_WRITE      (0x1 << 28)",
      "#define BKTR_VRO      0xC\t/* Marks the end of the odd field */",
      "#define BKTR_VRE      0x4\t/* Marks the end of the even field */",
      "#define BKTR_FM1      0x6\t/* packed data to follow */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */",
      "#define VBI_LINE_SIZE         2048 /* Store upto 2048 bytes per line */",
      "#define MAX_VBI_LINES\t      16   /* Maximum for all vidoe formats */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split",
          "args": [
            "bktr",
            "(volatile u_long **) &dma_prog",
            "bktr->yclip2 - bktr->yclip",
            "OP_SKIP",
            "Bpp",
            "(volatile u_char **)  &target",
            "cols"
          ],
          "line": 3757
        },
        "resolved": true,
        "details": {
          "function_name": "split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "3491-3571",
          "snippet": "static bool_t split(bktr_reg_t * bktr, volatile u_long **dma_prog, int width ,\n\t\t    u_long operation, int pixel_width,\n\t\t    volatile u_char ** target_buffer, int cols ) {\n\n u_long flag, flag2;\n struct meteor_pixfmt *pf = &pixfmt_table[ bktr->pixfmt ].public;\n u_int  skip, start_skip;\n\n  /*  For RGB24, we need to align the component in FIFO Byte Lane 0         */\n  /*    to the 1st byte in the mem dword containing our start addr.         */\n  /*    BTW, we know this pixfmt's 1st byte is Blue; thus the start addr    */\n  /*     must be Blue.                                                      */\n  start_skip = 0;\n  if (( pf->type == METEOR_PIXTYPE_RGB ) && ( pf->Bpp == 3 ))\n\t  switch ( ((uintptr_t) (volatile void *) *target_buffer) % 4 ) {\n\t  case 2 : start_skip = 4 ; break;\n\t  case 1 : start_skip = 8 ; break;\n\t  }\n\n if ((width * pixel_width) < DMA_BT848_SPLIT ) {\n     if (  width == cols) {\n\t flag = OP_SOL | OP_EOL;\n       } else if (bktr->current_col == 0 ) {\n\t    flag  = OP_SOL;\n       } else if (bktr->current_col == cols) {\n\t    flag = OP_EOL;\n       } else flag = 0;\t\n\n     skip = 0;\n     if (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t     *(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t     flag &= ~OP_SOL;\n\t     skip = start_skip;\n     }\n\n     *(*dma_prog)++ = operation | flag  | (width * pixel_width - skip);\n     if (operation != OP_SKIP ) \n\t *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer;\n\n     *target_buffer += width * pixel_width;\n     bktr->current_col += width;\n\n } else {\n\n\tif (bktr->current_col == 0 && width == cols) {\n\t    flag = OP_SOL ;\n\t    flag2 = OP_EOL;\n        } else if (bktr->current_col == 0 ) {\n\t    flag = OP_SOL;\n\t    flag2 = 0;\n\t} else if (bktr->current_col >= cols)  {\n\t    flag =  0;\n\t    flag2 = OP_EOL;\n\t} else {\n\t    flag =  0;\n\t    flag2 = 0;\n\t}\n\n\tskip = 0;\n\tif (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t\t*(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t\tflag &= ~OP_SOL;\n\t\tskip = start_skip;\n\t}\n\n\t*(*dma_prog)++ = operation  | flag |\n\t      (width * pixel_width / 2 - skip);\n\tif (operation != OP_SKIP ) \n\t      *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer ;\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\n\tif ( operation == OP_WRITE )\n\t\toperation = OP_WRITEC;\n\t*(*dma_prog)++ = operation | flag2 |\n\t    (width * pixel_width / 2);\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\t  bktr->current_col += width;\n\n    }\n return TRUE;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define OP_EOL\t      (1 << 26)",
            "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
            "#define OP_WRITEC     (0x5 << 28)",
            "#define OP_SKIP       (0x2 << 28)",
            "#define OP_WRITE      (0x1 << 28)",
            "#define DMA_BT848_SPLIT 319*2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_WRITEC     (0x5 << 28)\n#define OP_SKIP       (0x2 << 28)\n#define OP_WRITE      (0x1 << 28)\n#define DMA_BT848_SPLIT 319*2\n\nstatic bool_t split(bktr_reg_t * bktr, volatile u_long **dma_prog, int width ,\n\t\t    u_long operation, int pixel_width,\n\t\t    volatile u_char ** target_buffer, int cols ) {\n\n u_long flag, flag2;\n struct meteor_pixfmt *pf = &pixfmt_table[ bktr->pixfmt ].public;\n u_int  skip, start_skip;\n\n  /*  For RGB24, we need to align the component in FIFO Byte Lane 0         */\n  /*    to the 1st byte in the mem dword containing our start addr.         */\n  /*    BTW, we know this pixfmt's 1st byte is Blue; thus the start addr    */\n  /*     must be Blue.                                                      */\n  start_skip = 0;\n  if (( pf->type == METEOR_PIXTYPE_RGB ) && ( pf->Bpp == 3 ))\n\t  switch ( ((uintptr_t) (volatile void *) *target_buffer) % 4 ) {\n\t  case 2 : start_skip = 4 ; break;\n\t  case 1 : start_skip = 8 ; break;\n\t  }\n\n if ((width * pixel_width) < DMA_BT848_SPLIT ) {\n     if (  width == cols) {\n\t flag = OP_SOL | OP_EOL;\n       } else if (bktr->current_col == 0 ) {\n\t    flag  = OP_SOL;\n       } else if (bktr->current_col == cols) {\n\t    flag = OP_EOL;\n       } else flag = 0;\t\n\n     skip = 0;\n     if (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t     *(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t     flag &= ~OP_SOL;\n\t     skip = start_skip;\n     }\n\n     *(*dma_prog)++ = operation | flag  | (width * pixel_width - skip);\n     if (operation != OP_SKIP ) \n\t *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer;\n\n     *target_buffer += width * pixel_width;\n     bktr->current_col += width;\n\n } else {\n\n\tif (bktr->current_col == 0 && width == cols) {\n\t    flag = OP_SOL ;\n\t    flag2 = OP_EOL;\n        } else if (bktr->current_col == 0 ) {\n\t    flag = OP_SOL;\n\t    flag2 = 0;\n\t} else if (bktr->current_col >= cols)  {\n\t    flag =  0;\n\t    flag2 = OP_EOL;\n\t} else {\n\t    flag =  0;\n\t    flag2 = 0;\n\t}\n\n\tskip = 0;\n\tif (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t\t*(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t\tflag &= ~OP_SOL;\n\t\tskip = start_skip;\n\t}\n\n\t*(*dma_prog)++ = operation  | flag |\n\t      (width * pixel_width / 2 - skip);\n\tif (operation != OP_SKIP ) \n\t      *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer ;\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\n\tif ( operation == OP_WRITE )\n\t\toperation = OP_WRITEC;\n\t*(*dma_prog)++ = operation | flag2 |\n\t    (width * pixel_width / 2);\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\t  bktr->current_col += width;\n\n    }\n return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getline",
          "args": [
            "bktr",
            "i"
          ],
          "line": 3749
        },
        "resolved": true,
        "details": {
          "function_name": "getline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "3447-3489",
          "snippet": "bool_t getline(bktr_reg_t *bktr, int x ) {\n    int i, j;\n    bktr_clip_t * clip_node ;\n    \n    if (bktr->line_length == 0 || \n\tbktr->current_col >= bktr->line_length) return FALSE;\n\n    bktr->y = min(bktr->last_y, bktr->line_length);\n    bktr->y2 = bktr->line_length;\n\n    bktr->yclip = bktr->yclip2 = -1;\n    for (i = bktr->clip_start; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t    if (bktr->last_y <= clip_node->y_min) {\n\t\tbktr->y =      min(bktr->last_y, bktr->line_length);\n\t\tbktr->y2 =     min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip =  min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\tbktr->last_y = bktr->yclip2;\n\t\tbktr->clip_start = i;\n\t\t\n\t\tfor (j = i+1; j  < bktr->max_clip_node; j++ ) {\n\t\t    clip_node = (bktr_clip_t *) &bktr->clip_list[j];\n\t\t    if (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t\t\tif (bktr->last_y >= clip_node->y_min) {\n\t\t\t    bktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\t\t    bktr->last_y = bktr->yclip2;\n\t\t\t    bktr->clip_start = j;\n\t\t\t}\t\n\t\t    } else break  ;\n\t\t}\t\n\t\treturn TRUE;\n\t    }\t\n\t}\n    }\n\n    if (bktr->current_col <= bktr->line_length) {\n\tbktr->current_col = bktr->line_length;\n\treturn TRUE;\n    }\n    return FALSE;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nbool_t getline(bktr_reg_t *bktr, int x ) {\n    int i, j;\n    bktr_clip_t * clip_node ;\n    \n    if (bktr->line_length == 0 || \n\tbktr->current_col >= bktr->line_length) return FALSE;\n\n    bktr->y = min(bktr->last_y, bktr->line_length);\n    bktr->y2 = bktr->line_length;\n\n    bktr->yclip = bktr->yclip2 = -1;\n    for (i = bktr->clip_start; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t    if (bktr->last_y <= clip_node->y_min) {\n\t\tbktr->y =      min(bktr->last_y, bktr->line_length);\n\t\tbktr->y2 =     min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip =  min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\tbktr->last_y = bktr->yclip2;\n\t\tbktr->clip_start = i;\n\t\t\n\t\tfor (j = i+1; j  < bktr->max_clip_node; j++ ) {\n\t\t    clip_node = (bktr_clip_t *) &bktr->clip_list[j];\n\t\t    if (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t\t\tif (bktr->last_y >= clip_node->y_min) {\n\t\t\t    bktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\t\t    bktr->last_y = bktr->yclip2;\n\t\t\t    bktr->clip_start = j;\n\t\t\t}\t\n\t\t    } else break  ;\n\t\t}\t\n\t\treturn TRUE;\n\t    }\t\n\t}\n    }\n\n    if (bktr->current_col <= bktr->line_length) {\n\tbktr->current_col = bktr->line_length;\n\treturn TRUE;\n    }\n    return FALSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "notclipped",
          "args": [
            "bktr",
            "i",
            "width"
          ],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "notclipped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "3420-3445",
          "snippet": "bool_t notclipped (bktr_reg_t * bktr, int x, int width) {\n    int i;\n    bktr_clip_t * clip_node;\n    bktr->clip_start = -1;\n    bktr->last_y = 0;\n    bktr->y = 0;\n    bktr->y2 = width;\n    bktr->line_length = width;\n    bktr->yclip = -1;\n    bktr->yclip2 = -1;\n    bktr->current_col = 0;\n    \n    if (bktr->max_clip_node == 0 ) return TRUE;\n    clip_node = (bktr_clip_t *) &bktr->clip_list[0];\n\n\n    for (i = 0; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max  ) {\n\t    bktr->clip_start = i;\n\t    return FALSE;\n\t}\n    }\t\n    \n    return TRUE;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nbool_t notclipped (bktr_reg_t * bktr, int x, int width) {\n    int i;\n    bktr_clip_t * clip_node;\n    bktr->clip_start = -1;\n    bktr->last_y = 0;\n    bktr->y = 0;\n    bktr->y2 = width;\n    bktr->line_length = width;\n    bktr->yclip = -1;\n    bktr->yclip2 = -1;\n    bktr->current_col = 0;\n    \n    if (bktr->max_clip_node == 0 ) return TRUE;\n    clip_node = (bktr_clip_t *) &bktr->clip_list[0];\n\n\n    for (i = 0; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max  ) {\n\t    bktr->clip_start = i;\n\t    return FALSE;\n\t}\n    }\t\n    \n    return TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->vbidata +\n\t\t\t\t\t((i+MAX_VBI_LINES) * VBI_LINE_SIZE)"
          ],
          "line": 3733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->odd_dma_prog"
          ],
          "line": 3717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->vbidata +\n\t\t\t\t\t(i * VBI_LINE_SIZE)"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->bigbuf"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define BKTR_GEN_IRQ  (1 << 24)\n#define BKTR_RESYNC   (1 << 15)\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_SYNC\t      (0x8 << 28)\n#define OP_JUMP\t      (0x7 << 28)\n#define OP_SKIP       (0x2 << 28)\n#define OP_WRITE      (0x1 << 28)\n#define BKTR_VRO      0xC\t/* Marks the end of the odd field */\n#define BKTR_VRE      0x4\t/* Marks the end of the even field */\n#define BKTR_FM1      0x6\t/* packed data to follow */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n#define VBI_LINE_SIZE         2048 /* Store upto 2048 bytes per line */\n#define MAX_VBI_LINES\t      16   /* Maximum for all vidoe formats */\n\nstatic void\nrgb_vbi_prog( bktr_ptr_t bktr, char i_flag, int cols, int rows, int interlace )\n{\n\tint\t\t\ti;\n\tbt848_ptr_t\t\tbt848;\n\tvolatile u_long\t\ttarget_buffer, buffer, target,width;\n\tvolatile u_long\t\tpitch;\n\tvolatile  u_long\t*dma_prog;\n        struct meteor_pixfmt_internal *pf_int = &pixfmt_table[ bktr->pixfmt ];\n\tu_int                   Bpp = pf_int->public.Bpp;\n\tunsigned int            vbisamples;     /* VBI samples per line */\n\tunsigned int            vbilines;       /* VBI lines per field */\n\tunsigned int            num_dwords;     /* DWORDS per line */\n\n\tvbisamples = format_params[bktr->format_params].vbi_num_samples;\n\tvbilines   = format_params[bktr->format_params].vbi_num_lines;\n\tnum_dwords = vbisamples/4;\n\n\tbt848 = bktr->base;\n\n\tbt848->color_fmt         = pf_int->color_fmt;\n\tbt848->adc               = SYNC_LEVEL;\n\tbt848->vbi_pack_size     = ((num_dwords))     & 0xff;\n\tbt848->vbi_pack_del      = ((num_dwords)>> 8) & 0x01; /* no hdelay    */\n\t\t\t\t\t\t\t      /* no ext frame */\n\n\tbt848->oform = 0x00;\n\n \tbt848->e_vscale_hi |= 0x40; /* set chroma comb */\n \tbt848->o_vscale_hi |= 0x40;\n\tbt848->e_vscale_hi &= ~0x80; /* clear Ycomb */\n\tbt848->o_vscale_hi &= ~0x80;\n\n \t/* disable gamma correction removal */\n \tbt848->color_ctl_gamma = 1;\n\n\n\tif (cols > 385 ) {\n\t    bt848->e_vtc = 0;\n\t    bt848->o_vtc = 0;\n\t} else {\n\t    bt848->e_vtc = 1;\n\t    bt848->o_vtc = 1;\n\t}\n\tbktr->capcontrol = 3 << 2 |  3;\n\n\tdma_prog = (u_long *) bktr->dma_prog;\n\n\t/* Construct Write */\n\n\tif (bktr->video.addr) {\n\t\ttarget_buffer = (u_long) bktr->video.addr;\n\t\tpitch = bktr->video.width;\n\t}\n\telse {\n\t\ttarget_buffer = (u_long) vtophys(bktr->bigbuf);\n\t\tpitch = cols*Bpp;\n\t}\n\n\tbuffer = target_buffer;\n\n\n\t/* store the VBI data */\n\t/* look for sync with packed data */\n\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t*dma_prog++ = 0;\n\tfor(i = 0; i < vbilines; i++) {\n\t\t*dma_prog++ = OP_WRITE | OP_SOL | OP_EOL | vbisamples;\n\t\t*dma_prog++ = (u_long) vtophys(bktr->vbidata +\n\t\t\t\t\t(i * VBI_LINE_SIZE));\n\t}\n\n\t/* store the video image */\n\t/* look for sync with packed data */\n\t*dma_prog++ = OP_SYNC  | BKTR_RESYNC | BKTR_FM1;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\twidth = cols;\n\tfor (i = 0; i < (rows/interlace); i++) {\n\t    target = target_buffer;\n\t    if ( notclipped(bktr, i, width)) {\n\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t      Bpp, (volatile u_char **) &target,  cols);\n\n\t    } else {\n\t\twhile(getline(bktr, i)) {\n\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target, cols);\n\t\t    }\n\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\tsplit(bktr,(volatile u_long **) &dma_prog,\n\t\t\t      bktr->yclip2 - bktr->yclip,\n\t\t\t      OP_SKIP,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    target_buffer += interlace * pitch;\n\n\t}\n\n\tswitch (i_flag) {\n\tcase 1:\n\t\t/* EVEN field grabs. Look for end of 'Even Field' Marker\n\t\t * We cannot look for VRO, because we have not enabled ODD\n\t\t * field capture\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 2:\n\t\t/* ODD field grabs. Look for end of 'Odd Field' Marker\n\t\t * We cannot look for VRE, because we have not enabled EVEN\n\t\t * field capture\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog);\n\t\treturn;\n\n\tcase 3:\n\t\t/* INTERLACED grabs (ODD then EVEN). We have read the old field\n\t\t * so look for the end of 'Odd Field' Marker.\n\t\t * Then jump to the 'odd_dma_prog' which actually captures\n\t\t * the EVEN field!\n\t\t */\n\t\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRO;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t\t*dma_prog++ = OP_JUMP;\n\t\t*dma_prog = (u_long ) vtophys(bktr->odd_dma_prog);\n\t\tbreak;\n\t}\n\n\tif (interlace == 2) {\n\n\t        target_buffer = buffer + pitch; \n\n\t\tdma_prog = (u_long *) bktr->odd_dma_prog;\n\n\t\t/* store the VBI data */\n\t\t/* look for sync with packed data */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;\n\t\tfor(i = 0; i < vbilines; i++) {\n\t\t\t*dma_prog++ = OP_WRITE | OP_SOL | OP_EOL | vbisamples;\n\t\t\t*dma_prog++ = (u_long) vtophys(bktr->vbidata +\n\t\t\t\t\t((i+MAX_VBI_LINES) * VBI_LINE_SIZE));\n\t\t}\n\n\t\t/* store the video image */\n\t\t/* look for sync with packed data */\n\t\t*dma_prog++ = OP_SYNC | BKTR_RESYNC | BKTR_FM1;\n\t\t*dma_prog++ = 0;  /* NULL WORD */\n\t\twidth = cols;\n\t\tfor (i = 0; i < (rows/interlace); i++) {\n\t\t    target = target_buffer;\n\t\t    if ( notclipped(bktr, i, width)) {\n\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t      Bpp, (volatile u_char **) &target,  cols);\n\t\t    } else {\n\t\t\twhile(getline(bktr, i)) {\n\t\t\t    if (bktr->y != bktr->y2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->y2 - bktr->y, OP_WRITE,\n\t\t\t\t      Bpp, (volatile u_char **) &target,\n\t\t\t\t      cols);\n\t\t\t    }\t\n\t\t\t    if (bktr->yclip != bktr->yclip2 ) {\n\t\t\t\tsplit(bktr, (volatile u_long **) &dma_prog,\n\t\t\t\t      bktr->yclip2 - bktr->yclip, OP_SKIP,\n\t\t\t\t      Bpp, (volatile u_char **)  &target,  cols);\n\t\t\t    }\t\n\n\t\t\t}\t\n\n\t\t    }\n\n\t\t    target_buffer += interlace * pitch;\n\n\t\t}\n\t}\n\n\t/* Look for end of 'Even Field' */\n\t*dma_prog++ = OP_SYNC | BKTR_GEN_IRQ | BKTR_RESYNC | BKTR_VRE;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n\t*dma_prog++ = OP_JUMP ;\n\t*dma_prog++ = (u_long ) vtophys(bktr->dma_prog) ;\n\t*dma_prog++ = 0;  /* NULL WORD */\n\n}"
  },
  {
    "function_name": "split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "3491-3571",
    "snippet": "static bool_t split(bktr_reg_t * bktr, volatile u_long **dma_prog, int width ,\n\t\t    u_long operation, int pixel_width,\n\t\t    volatile u_char ** target_buffer, int cols ) {\n\n u_long flag, flag2;\n struct meteor_pixfmt *pf = &pixfmt_table[ bktr->pixfmt ].public;\n u_int  skip, start_skip;\n\n  /*  For RGB24, we need to align the component in FIFO Byte Lane 0         */\n  /*    to the 1st byte in the mem dword containing our start addr.         */\n  /*    BTW, we know this pixfmt's 1st byte is Blue; thus the start addr    */\n  /*     must be Blue.                                                      */\n  start_skip = 0;\n  if (( pf->type == METEOR_PIXTYPE_RGB ) && ( pf->Bpp == 3 ))\n\t  switch ( ((uintptr_t) (volatile void *) *target_buffer) % 4 ) {\n\t  case 2 : start_skip = 4 ; break;\n\t  case 1 : start_skip = 8 ; break;\n\t  }\n\n if ((width * pixel_width) < DMA_BT848_SPLIT ) {\n     if (  width == cols) {\n\t flag = OP_SOL | OP_EOL;\n       } else if (bktr->current_col == 0 ) {\n\t    flag  = OP_SOL;\n       } else if (bktr->current_col == cols) {\n\t    flag = OP_EOL;\n       } else flag = 0;\t\n\n     skip = 0;\n     if (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t     *(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t     flag &= ~OP_SOL;\n\t     skip = start_skip;\n     }\n\n     *(*dma_prog)++ = operation | flag  | (width * pixel_width - skip);\n     if (operation != OP_SKIP ) \n\t *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer;\n\n     *target_buffer += width * pixel_width;\n     bktr->current_col += width;\n\n } else {\n\n\tif (bktr->current_col == 0 && width == cols) {\n\t    flag = OP_SOL ;\n\t    flag2 = OP_EOL;\n        } else if (bktr->current_col == 0 ) {\n\t    flag = OP_SOL;\n\t    flag2 = 0;\n\t} else if (bktr->current_col >= cols)  {\n\t    flag =  0;\n\t    flag2 = OP_EOL;\n\t} else {\n\t    flag =  0;\n\t    flag2 = 0;\n\t}\n\n\tskip = 0;\n\tif (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t\t*(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t\tflag &= ~OP_SOL;\n\t\tskip = start_skip;\n\t}\n\n\t*(*dma_prog)++ = operation  | flag |\n\t      (width * pixel_width / 2 - skip);\n\tif (operation != OP_SKIP ) \n\t      *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer ;\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\n\tif ( operation == OP_WRITE )\n\t\toperation = OP_WRITEC;\n\t*(*dma_prog)++ = operation | flag2 |\n\t    (width * pixel_width / 2);\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\t  bktr->current_col += width;\n\n    }\n return TRUE;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define OP_EOL\t      (1 << 26)",
      "#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */",
      "#define OP_WRITEC     (0x5 << 28)",
      "#define OP_SKIP       (0x2 << 28)",
      "#define OP_WRITE      (0x1 << 28)",
      "#define DMA_BT848_SPLIT 319*2"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define OP_EOL\t      (1 << 26)\n#define OP_SOL\t      (1 << 27)\t\t/* first instr for scanline */\n#define OP_WRITEC     (0x5 << 28)\n#define OP_SKIP       (0x2 << 28)\n#define OP_WRITE      (0x1 << 28)\n#define DMA_BT848_SPLIT 319*2\n\nstatic bool_t split(bktr_reg_t * bktr, volatile u_long **dma_prog, int width ,\n\t\t    u_long operation, int pixel_width,\n\t\t    volatile u_char ** target_buffer, int cols ) {\n\n u_long flag, flag2;\n struct meteor_pixfmt *pf = &pixfmt_table[ bktr->pixfmt ].public;\n u_int  skip, start_skip;\n\n  /*  For RGB24, we need to align the component in FIFO Byte Lane 0         */\n  /*    to the 1st byte in the mem dword containing our start addr.         */\n  /*    BTW, we know this pixfmt's 1st byte is Blue; thus the start addr    */\n  /*     must be Blue.                                                      */\n  start_skip = 0;\n  if (( pf->type == METEOR_PIXTYPE_RGB ) && ( pf->Bpp == 3 ))\n\t  switch ( ((uintptr_t) (volatile void *) *target_buffer) % 4 ) {\n\t  case 2 : start_skip = 4 ; break;\n\t  case 1 : start_skip = 8 ; break;\n\t  }\n\n if ((width * pixel_width) < DMA_BT848_SPLIT ) {\n     if (  width == cols) {\n\t flag = OP_SOL | OP_EOL;\n       } else if (bktr->current_col == 0 ) {\n\t    flag  = OP_SOL;\n       } else if (bktr->current_col == cols) {\n\t    flag = OP_EOL;\n       } else flag = 0;\t\n\n     skip = 0;\n     if (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t     *(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t     flag &= ~OP_SOL;\n\t     skip = start_skip;\n     }\n\n     *(*dma_prog)++ = operation | flag  | (width * pixel_width - skip);\n     if (operation != OP_SKIP ) \n\t *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer;\n\n     *target_buffer += width * pixel_width;\n     bktr->current_col += width;\n\n } else {\n\n\tif (bktr->current_col == 0 && width == cols) {\n\t    flag = OP_SOL ;\n\t    flag2 = OP_EOL;\n        } else if (bktr->current_col == 0 ) {\n\t    flag = OP_SOL;\n\t    flag2 = 0;\n\t} else if (bktr->current_col >= cols)  {\n\t    flag =  0;\n\t    flag2 = OP_EOL;\n\t} else {\n\t    flag =  0;\n\t    flag2 = 0;\n\t}\n\n\tskip = 0;\n\tif (( flag & OP_SOL ) && ( start_skip > 0 )) {\n\t\t*(*dma_prog)++ = OP_SKIP | OP_SOL | start_skip;\n\t\tflag &= ~OP_SOL;\n\t\tskip = start_skip;\n\t}\n\n\t*(*dma_prog)++ = operation  | flag |\n\t      (width * pixel_width / 2 - skip);\n\tif (operation != OP_SKIP ) \n\t      *(*dma_prog)++ = (uintptr_t) (volatile void *) *target_buffer ;\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\n\tif ( operation == OP_WRITE )\n\t\toperation = OP_WRITEC;\n\t*(*dma_prog)++ = operation | flag2 |\n\t    (width * pixel_width / 2);\n\t*target_buffer +=  (width * pixel_width / 2) ;\n\t  bktr->current_col += width;\n\n    }\n return TRUE;\n}"
  },
  {
    "function_name": "getline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "3447-3489",
    "snippet": "bool_t getline(bktr_reg_t *bktr, int x ) {\n    int i, j;\n    bktr_clip_t * clip_node ;\n    \n    if (bktr->line_length == 0 || \n\tbktr->current_col >= bktr->line_length) return FALSE;\n\n    bktr->y = min(bktr->last_y, bktr->line_length);\n    bktr->y2 = bktr->line_length;\n\n    bktr->yclip = bktr->yclip2 = -1;\n    for (i = bktr->clip_start; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t    if (bktr->last_y <= clip_node->y_min) {\n\t\tbktr->y =      min(bktr->last_y, bktr->line_length);\n\t\tbktr->y2 =     min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip =  min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\tbktr->last_y = bktr->yclip2;\n\t\tbktr->clip_start = i;\n\t\t\n\t\tfor (j = i+1; j  < bktr->max_clip_node; j++ ) {\n\t\t    clip_node = (bktr_clip_t *) &bktr->clip_list[j];\n\t\t    if (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t\t\tif (bktr->last_y >= clip_node->y_min) {\n\t\t\t    bktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\t\t    bktr->last_y = bktr->yclip2;\n\t\t\t    bktr->clip_start = j;\n\t\t\t}\t\n\t\t    } else break  ;\n\t\t}\t\n\t\treturn TRUE;\n\t    }\t\n\t}\n    }\n\n    if (bktr->current_col <= bktr->line_length) {\n\tbktr->current_col = bktr->line_length;\n\treturn TRUE;\n    }\n    return FALSE;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "clip_node->y_max",
            "bktr->line_length"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "ti_free_rx_ring_mini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "964-979",
          "snippet": "void ti_free_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MINI_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_mini_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_free_rx_ring_mini",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_rx_ring_mini;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MINI_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_mini_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nbool_t getline(bktr_reg_t *bktr, int x ) {\n    int i, j;\n    bktr_clip_t * clip_node ;\n    \n    if (bktr->line_length == 0 || \n\tbktr->current_col >= bktr->line_length) return FALSE;\n\n    bktr->y = min(bktr->last_y, bktr->line_length);\n    bktr->y2 = bktr->line_length;\n\n    bktr->yclip = bktr->yclip2 = -1;\n    for (i = bktr->clip_start; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t    if (bktr->last_y <= clip_node->y_min) {\n\t\tbktr->y =      min(bktr->last_y, bktr->line_length);\n\t\tbktr->y2 =     min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip =  min(clip_node->y_min, bktr->line_length);\n\t\tbktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\tbktr->last_y = bktr->yclip2;\n\t\tbktr->clip_start = i;\n\t\t\n\t\tfor (j = i+1; j  < bktr->max_clip_node; j++ ) {\n\t\t    clip_node = (bktr_clip_t *) &bktr->clip_list[j];\n\t\t    if (x >= clip_node->x_min && x <= clip_node->x_max) {\n\t\t\tif (bktr->last_y >= clip_node->y_min) {\n\t\t\t    bktr->yclip2 = min(clip_node->y_max, bktr->line_length);\n\t\t\t    bktr->last_y = bktr->yclip2;\n\t\t\t    bktr->clip_start = j;\n\t\t\t}\t\n\t\t    } else break  ;\n\t\t}\t\n\t\treturn TRUE;\n\t    }\t\n\t}\n    }\n\n    if (bktr->current_col <= bktr->line_length) {\n\tbktr->current_col = bktr->line_length;\n\treturn TRUE;\n    }\n    return FALSE;\n}"
  },
  {
    "function_name": "notclipped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "3420-3445",
    "snippet": "bool_t notclipped (bktr_reg_t * bktr, int x, int width) {\n    int i;\n    bktr_clip_t * clip_node;\n    bktr->clip_start = -1;\n    bktr->last_y = 0;\n    bktr->y = 0;\n    bktr->y2 = width;\n    bktr->line_length = width;\n    bktr->yclip = -1;\n    bktr->yclip2 = -1;\n    bktr->current_col = 0;\n    \n    if (bktr->max_clip_node == 0 ) return TRUE;\n    clip_node = (bktr_clip_t *) &bktr->clip_list[0];\n\n\n    for (i = 0; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max  ) {\n\t    bktr->clip_start = i;\n\t    return FALSE;\n\t}\n    }\t\n    \n    return TRUE;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nbool_t notclipped (bktr_reg_t * bktr, int x, int width) {\n    int i;\n    bktr_clip_t * clip_node;\n    bktr->clip_start = -1;\n    bktr->last_y = 0;\n    bktr->y = 0;\n    bktr->y2 = width;\n    bktr->line_length = width;\n    bktr->yclip = -1;\n    bktr->yclip2 = -1;\n    bktr->current_col = 0;\n    \n    if (bktr->max_clip_node == 0 ) return TRUE;\n    clip_node = (bktr_clip_t *) &bktr->clip_list[0];\n\n\n    for (i = 0; i < bktr->max_clip_node; i++ ) {\n\tclip_node = (bktr_clip_t *) &bktr->clip_list[i];\n\tif (x >= clip_node->x_min && x <= clip_node->x_max  ) {\n\t    bktr->clip_start = i;\n\t    return FALSE;\n\t}\n    }\t\n    \n    return TRUE;\n}"
  },
  {
    "function_name": "dump_bt848",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "3346-3373",
    "snippet": "static int\ndump_bt848( bt848_ptr_t bt848 )\n{\n\tvolatile u_char *bt848r = (u_char *)bt848;\n\tint\tr[60]={\n\t\t\t   4,    8, 0xc, 0x8c, 0x10, 0x90, 0x14, 0x94, \n\t\t\t0x18, 0x98, 0x1c, 0x9c, 0x20, 0xa0, 0x24, 0xa4,\n\t\t\t0x28, 0x2c, 0xac, 0x30, 0x34, 0x38, 0x3c, 0x40,\n\t\t\t0xc0, 0x48, 0x4c, 0xcc, 0x50, 0xd0, 0xd4, 0x60,\n\t\t\t0x64, 0x68, 0x6c, 0xec, 0xd8, 0xdc, 0xe0, 0xe4,\n\t\t\t0,\t 0,    0,    0\n\t\t   };\n\tint\ti;\n\n\tfor (i = 0; i < 40; i+=4) {\n\t\tprintf(\" Reg:value : \\t%x:%x \\t%x:%x \\t %x:%x \\t %x:%x\\n\",\n\t\t       r[i], bt848r[r[i]],\n\t\t       r[i+1], bt848r[r[i+1]],\n\t\t       r[i+2], bt848r[r[i+2]],\n\t\t       r[i+3], bt848r[r[i+3]]);\n\t}\n\n\tprintf(\" INT STAT %x \\n\",  bt848->int_stat);\n\tprintf(\" Reg INT_MASK %x \\n\",  bt848->int_mask);\n\tprintf(\" Reg GPIO_DMA_CTL %x \\n\", bt848->gpio_dma_ctl);\n\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" Reg GPIO_DMA_CTL %x \\n\"",
            "bt848->gpio_dma_ctl"
          ],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ndump_bt848( bt848_ptr_t bt848 )\n{\n\tvolatile u_char *bt848r = (u_char *)bt848;\n\tint\tr[60]={\n\t\t\t   4,    8, 0xc, 0x8c, 0x10, 0x90, 0x14, 0x94, \n\t\t\t0x18, 0x98, 0x1c, 0x9c, 0x20, 0xa0, 0x24, 0xa4,\n\t\t\t0x28, 0x2c, 0xac, 0x30, 0x34, 0x38, 0x3c, 0x40,\n\t\t\t0xc0, 0x48, 0x4c, 0xcc, 0x50, 0xd0, 0xd4, 0x60,\n\t\t\t0x64, 0x68, 0x6c, 0xec, 0xd8, 0xdc, 0xe0, 0xe4,\n\t\t\t0,\t 0,    0,    0\n\t\t   };\n\tint\ti;\n\n\tfor (i = 0; i < 40; i+=4) {\n\t\tprintf(\" Reg:value : \\t%x:%x \\t%x:%x \\t %x:%x \\t %x:%x\\n\",\n\t\t       r[i], bt848r[r[i]],\n\t\t       r[i+1], bt848r[r[i+1]],\n\t\t       r[i+2], bt848r[r[i+2]],\n\t\t       r[i+3], bt848r[r[i+3]]);\n\t}\n\n\tprintf(\" INT STAT %x \\n\",  bt848->int_stat);\n\tprintf(\" Reg INT_MASK %x \\n\",  bt848->int_mask);\n\tprintf(\" Reg GPIO_DMA_CTL %x \\n\", bt848->gpio_dma_ctl);\n\n\treturn( 0 );\n}"
  },
  {
    "function_name": "vbi_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "2142-2177",
    "snippet": "static int\nvbi_read(bktr_ptr_t bktr, dev_t dev, struct uio *uio)\n{\n\tint             readsize, readsize2;\n\tint             status;\n\n\tif(bktr->vbisize == 0)\n\t\tstatus = tsleep(VBI_SLEEP, BKTRPRI, \"vbi\", 0);\n\n\treadsize = (int)uio->uio_iov->iov_len;\n\n\t/* We cannot read more bytes than there are in the circular buffer */\n\tif (readsize > bktr->vbisize) readsize = bktr->vbisize;\n\n\t/* Check if we can read this number of bytes without having to wrap around the circular buffer */\n\tif((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {\n\t\t/* We need to wrap around */\n\n                readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);\n                status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);\n        } else {\n\t\t/* We do not need to wrap around */\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);\n        }\n\n\t/* Update the number of bytes left to read */\n        bktr->vbisize -= readsize;\n\n\t/* Update vbistart */\n        bktr->vbistart += readsize;\n\tbktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */\n\n        return( status );\n\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_SLEEP   ((caddr_t)bktr + 1)",
      "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
      "#define BKTRPRI (PZERO+8)|PCATCH"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(caddr_t)bktr->vbibuffer + bktr->vbistart",
            "readsize",
            "uio"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(caddr_t)bktr->vbibuffer",
            "(readsize - readsize2)",
            "uio"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(caddr_t)bktr->vbibuffer + bktr->vbistart",
            "readsize2",
            "uio"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "VBI_SLEEP",
            "BKTRPRI",
            "\"vbi\"",
            "0"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_SLEEP   ((caddr_t)bktr + 1)\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define BKTRPRI (PZERO+8)|PCATCH\n\nstatic int\nvbi_read(bktr_ptr_t bktr, dev_t dev, struct uio *uio)\n{\n\tint             readsize, readsize2;\n\tint             status;\n\n\tif(bktr->vbisize == 0)\n\t\tstatus = tsleep(VBI_SLEEP, BKTRPRI, \"vbi\", 0);\n\n\treadsize = (int)uio->uio_iov->iov_len;\n\n\t/* We cannot read more bytes than there are in the circular buffer */\n\tif (readsize > bktr->vbisize) readsize = bktr->vbisize;\n\n\t/* Check if we can read this number of bytes without having to wrap around the circular buffer */\n\tif((bktr->vbistart + readsize) >= VBI_BUFFER_SIZE) {\n\t\t/* We need to wrap around */\n\n                readsize2 = VBI_BUFFER_SIZE - bktr->vbistart;\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize2, uio);\n                status += uiomove((caddr_t)bktr->vbibuffer, (readsize - readsize2), uio);\n        } else {\n\t\t/* We do not need to wrap around */\n                status = uiomove((caddr_t)bktr->vbibuffer + bktr->vbistart, readsize, uio);\n        }\n\n\t/* Update the number of bytes left to read */\n        bktr->vbisize -= readsize;\n\n\t/* Update vbistart */\n        bktr->vbistart += readsize;\n\tbktr->vbistart = bktr->vbistart % VBI_BUFFER_SIZE; /* wrap around if needed */\n\n        return( status );\n\n}"
  },
  {
    "function_name": "video_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "2085-2133",
    "snippet": "static int\nvideo_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)\n{\n        bt848_ptr_t     bt848;\n        int             status;\n        int             count;\n\n\n        bt848 = bktr->base;\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tif (bktr->flags & METEOR_CAP_MASK)\n\t\treturn( EIO );\t/* already capturing */\n\n        bt848->cap_ctl = bktr->bktr_cap_ctl;\n\n\n\tcount = bktr->rows * bktr->cols * \n\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp;\n\n\tif ((int) uio->uio_iov->iov_len < count)\n\t\treturn( EINVAL );\n\n\tbktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);\n\n\t/* capture one frame */\n\tstart_capture(bktr, METEOR_SINGLE);\n\t/* wait for capture to complete */\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n                          BT848_INT_RISCI      |\n                          BT848_INT_VSYNC      |\n                          BT848_INT_FMTCHG;\n\n\n\tstatus = tsleep(BKTR_SLEEP, BKTRPRI, \"captur\", 0);\n\tif (!status)\t\t/* successful capture */\n\t\tstatus = uiomove((caddr_t)bktr->bigbuf, count, uio);\n\telse\n\t\tprintf (\"bktr%d: read: tsleep error %d\\n\", unit, status);\n\n\tbktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);\n\n\treturn( status );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define ALL_INTS_CLEARED\t0xffffffff",
      "#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN",
      "#define BKTR_SLEEP  ((caddr_t)bktr    )",
      "#define BKTRPRI (PZERO+8)|PCATCH"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bktr%d: read: tsleep error %d\\n\"",
            "unit",
            "status"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(caddr_t)bktr->bigbuf",
            "count",
            "uio"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "BKTR_SLEEP",
            "BKTRPRI",
            "\"captur\"",
            "0"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_capture",
          "args": [
            "bktr",
            "METEOR_SINGLE"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "start_capture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4505-4561",
          "snippet": "static void\nstart_capture( bktr_ptr_t bktr, unsigned type )\n{\n\tbt848_ptr_t\t\tbt848;\n\tu_char\t\t\ti_flag;\n\tstruct format_params   *fp;\n\n\tfp = &format_params[bktr->format_params];\n\n\t/*  If requested, clear out capture buf first  */\n\tif (bktr->clr_on_start && (bktr->video.addr == 0)) {\n\t\tbzero((caddr_t)bktr->bigbuf, \n\t\t      (size_t)bktr->rows * bktr->cols * bktr->frames *\n\t\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp);\n\t}\n\n\tbt848 = bktr->base;\n\n\tbt848->dstatus = 0;\n\tbt848->int_stat = bt848->int_stat;\n\n\tbktr->flags |= type;\n\tbktr->flags &= ~METEOR_WANT_MASK;\n\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\ti_flag = 1;\n\t\tbreak;\n\tcase METEOR_ONLY_ODD_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\ti_flag = 2;\n\t\tbreak;\n\tdefault:\n\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\ti_flag = 3;\n\t\tbreak;\n\t}\n\n\t/*  TDEC is only valid for continuous captures  */\n\tif ( type == METEOR_SINGLE ) {\n\t\tu_short\tfps_save = bktr->fps;\n\n\t\tset_fps(bktr, fp->frame_rate);\n\t\tbktr->fps = fps_save;\n\t}\n\telse\n\t\tset_fps(bktr, bktr->fps);\n\n\tif (bktr->dma_prog_loaded == FALSE) {\n\t\tbuild_dma_prog(bktr, i_flag);\n\t\tbktr->dma_prog_loaded = TRUE;\n\t}\n\t\n\n\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic void\nstart_capture( bktr_ptr_t bktr, unsigned type )\n{\n\tbt848_ptr_t\t\tbt848;\n\tu_char\t\t\ti_flag;\n\tstruct format_params   *fp;\n\n\tfp = &format_params[bktr->format_params];\n\n\t/*  If requested, clear out capture buf first  */\n\tif (bktr->clr_on_start && (bktr->video.addr == 0)) {\n\t\tbzero((caddr_t)bktr->bigbuf, \n\t\t      (size_t)bktr->rows * bktr->cols * bktr->frames *\n\t\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp);\n\t}\n\n\tbt848 = bktr->base;\n\n\tbt848->dstatus = 0;\n\tbt848->int_stat = bt848->int_stat;\n\n\tbktr->flags |= type;\n\tbktr->flags &= ~METEOR_WANT_MASK;\n\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\ti_flag = 1;\n\t\tbreak;\n\tcase METEOR_ONLY_ODD_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\ti_flag = 2;\n\t\tbreak;\n\tdefault:\n\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\ti_flag = 3;\n\t\tbreak;\n\t}\n\n\t/*  TDEC is only valid for continuous captures  */\n\tif ( type == METEOR_SINGLE ) {\n\t\tu_short\tfps_save = bktr->fps;\n\n\t\tset_fps(bktr, fp->frame_rate);\n\t\tbktr->fps = fps_save;\n\t}\n\telse\n\t\tset_fps(bktr, bktr->fps);\n\n\tif (bktr->dma_prog_loaded == FALSE) {\n\t\tbuild_dma_prog(bktr, i_flag);\n\t\tbktr->dma_prog_loaded = TRUE;\n\t}\n\t\n\n\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALL_INTS_CLEARED\t0xffffffff\n#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n#define BKTRPRI (PZERO+8)|PCATCH\n\nstatic int\nvideo_read(bktr_ptr_t bktr, int unit, dev_t dev, struct uio *uio)\n{\n        bt848_ptr_t     bt848;\n        int             status;\n        int             count;\n\n\n        bt848 = bktr->base;\n\n\tif (bktr->bigbuf == 0)\t/* no frame buffer allocated (ioctl failed) */\n\t\treturn( ENOMEM );\n\n\tif (bktr->flags & METEOR_CAP_MASK)\n\t\treturn( EIO );\t/* already capturing */\n\n        bt848->cap_ctl = bktr->bktr_cap_ctl;\n\n\n\tcount = bktr->rows * bktr->cols * \n\t\tpixfmt_table[ bktr->pixfmt ].public.Bpp;\n\n\tif ((int) uio->uio_iov->iov_len < count)\n\t\treturn( EINVAL );\n\n\tbktr->flags &= ~(METEOR_CAP_MASK | METEOR_WANT_MASK);\n\n\t/* capture one frame */\n\tstart_capture(bktr, METEOR_SINGLE);\n\t/* wait for capture to complete */\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n                          BT848_INT_RISCI      |\n                          BT848_INT_VSYNC      |\n                          BT848_INT_FMTCHG;\n\n\n\tstatus = tsleep(BKTR_SLEEP, BKTRPRI, \"captur\", 0);\n\tif (!status)\t\t/* successful capture */\n\t\tstatus = uiomove((caddr_t)bktr->bigbuf, count, uio);\n\telse\n\t\tprintf (\"bktr%d: read: tsleep error %d\\n\", unit, status);\n\n\tbktr->flags &= ~(METEOR_SINGLE | METEOR_WANT_MASK);\n\n\treturn( status );\n}"
  },
  {
    "function_name": "vbi_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "2073-2080",
    "snippet": "static int\nvbi_close( bktr_ptr_t bktr )\n{\n\n\tbktr->vbiflags &= ~VBI_OPEN;\n\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\nvbi_close( bktr_ptr_t bktr )\n{\n\n\tbktr->vbiflags &= ~VBI_OPEN;\n\n\treturn( 0 );\n}"
  },
  {
    "function_name": "tuner_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "2059-2071",
    "snippet": "static int\ntuner_close( bktr_ptr_t bktr )\n{\n\tbktr->tflags &= ~TUNER_OPEN;\n\n\t/* mute the audio by switching the mux */\n\tset_audio( bktr, AUDIO_MUTE );\n\n\t/* disable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en = bktr->base->gpio_out_en & ~bktr->card.gpio_mux_bits;\n\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_audio",
          "args": [
            "bktr",
            "AUDIO_MUTE"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "set_audio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6494-6590",
          "snippet": "static int\nset_audio( bktr_ptr_t bktr, int cmd )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\ttemp;\n\tvolatile u_char\tidx;\n\n#if defined( AUDIOMUX_DISCOVER )\n\tif ( cmd >= 200 )\n\t\tcmd -= 200;\n\telse\n#endif /* AUDIOMUX_DISCOVER */\n\n\t/* check for existance of audio MUXes */\n\tif ( !bktr->card.audiomuxs[ 4 ] )\n\t\treturn( -1 );\n\n\tswitch (cmd) {\n\tcase AUDIO_TUNER:\n#ifdef BKTR_REVERSEMUTE\n\t\tbktr->audio_mux_select = 3;\n#else\n\t\tbktr->audio_mux_select = 0;\n#endif\n\n\t\tif (bktr->reverse_mute ) \n\t\t      bktr->audio_mux_select = 0;\n\t\telse\t\n\t\t    bktr->audio_mux_select = 3;\n\n\t\tbreak;\n\tcase AUDIO_EXTERN:\n\t\tbktr->audio_mux_select = 1;\n\t\tbreak;\n\tcase AUDIO_INTERN:\n\t\tbktr->audio_mux_select = 2;\n\t\tbreak;\n\tcase AUDIO_MUTE:\n\t\tbktr->audio_mute_state = TRUE;\t/* set mute */\n\t\tbreak;\n\tcase AUDIO_UNMUTE:\n\t\tbktr->audio_mute_state = FALSE;\t/* clear mute */\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bktr: audio cmd error %02x\\n\", cmd);\n\t\treturn( -1 );\n\t}\n\n\n\t/* Most cards have a simple audio multiplexer to select the\n\t * audio source. The I/O_GV card has a more advanced multiplexer\n\t * and requires special handling.\n\t */\n        if ( bktr->bt848_card == CARD_IO_GV ) {\n                set_bctv_audio( bktr );\n                return( 0 );\n\t}\n\n\t/* Proceed with the simpler audio multiplexer code for the majority\n\t * of Bt848 cards.\n\t */\n\n\tbt848 =\tbktr->base;\n\n\t/*\n\t * Leave the upper bits of the GPIO port alone in case they control\n\t * something like the dbx or teletext chips.  This doesn't guarantee\n\t * success, but follows the rule of least astonishment.\n\t */\n\n\tif ( bktr->audio_mute_state == TRUE ) {\n#ifdef BKTR_REVERSEMUTE\n\t\tidx = 0;\n#else\n\t\tidx = 3;\n#endif\n\n\t\tif (bktr->reverse_mute )\n\t\t  idx  = 3;\n\t\telse\t\n\t\t  idx  = 0;\n\n\t}\n\telse\n\t\tidx = bktr->audio_mux_select;\n\n\ttemp = bt848->gpio_data & ~bktr->card.gpio_mux_bits;\n\tbt848->gpio_data =\n#if defined( AUDIOMUX_DISCOVER )\n\t\tbt848->gpio_data = temp | (cmd & 0xff);\n\t\tprintf(\"cmd: %d audio mux %x temp %x \\n\", cmd,bktr->card.audiomuxs[ idx ], temp );\n#else\n\t\ttemp | bktr->card.audiomuxs[ idx ];\n#endif /* AUDIOMUX_DISCOVER */\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define CARD_IO_GV\t\t9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CARD_IO_GV\t\t9\n\nstatic int\nset_audio( bktr_ptr_t bktr, int cmd )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\ttemp;\n\tvolatile u_char\tidx;\n\n#if defined( AUDIOMUX_DISCOVER )\n\tif ( cmd >= 200 )\n\t\tcmd -= 200;\n\telse\n#endif /* AUDIOMUX_DISCOVER */\n\n\t/* check for existance of audio MUXes */\n\tif ( !bktr->card.audiomuxs[ 4 ] )\n\t\treturn( -1 );\n\n\tswitch (cmd) {\n\tcase AUDIO_TUNER:\n#ifdef BKTR_REVERSEMUTE\n\t\tbktr->audio_mux_select = 3;\n#else\n\t\tbktr->audio_mux_select = 0;\n#endif\n\n\t\tif (bktr->reverse_mute ) \n\t\t      bktr->audio_mux_select = 0;\n\t\telse\t\n\t\t    bktr->audio_mux_select = 3;\n\n\t\tbreak;\n\tcase AUDIO_EXTERN:\n\t\tbktr->audio_mux_select = 1;\n\t\tbreak;\n\tcase AUDIO_INTERN:\n\t\tbktr->audio_mux_select = 2;\n\t\tbreak;\n\tcase AUDIO_MUTE:\n\t\tbktr->audio_mute_state = TRUE;\t/* set mute */\n\t\tbreak;\n\tcase AUDIO_UNMUTE:\n\t\tbktr->audio_mute_state = FALSE;\t/* clear mute */\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bktr: audio cmd error %02x\\n\", cmd);\n\t\treturn( -1 );\n\t}\n\n\n\t/* Most cards have a simple audio multiplexer to select the\n\t * audio source. The I/O_GV card has a more advanced multiplexer\n\t * and requires special handling.\n\t */\n        if ( bktr->bt848_card == CARD_IO_GV ) {\n                set_bctv_audio( bktr );\n                return( 0 );\n\t}\n\n\t/* Proceed with the simpler audio multiplexer code for the majority\n\t * of Bt848 cards.\n\t */\n\n\tbt848 =\tbktr->base;\n\n\t/*\n\t * Leave the upper bits of the GPIO port alone in case they control\n\t * something like the dbx or teletext chips.  This doesn't guarantee\n\t * success, but follows the rule of least astonishment.\n\t */\n\n\tif ( bktr->audio_mute_state == TRUE ) {\n#ifdef BKTR_REVERSEMUTE\n\t\tidx = 0;\n#else\n\t\tidx = 3;\n#endif\n\n\t\tif (bktr->reverse_mute )\n\t\t  idx  = 3;\n\t\telse\t\n\t\t  idx  = 0;\n\n\t}\n\telse\n\t\tidx = bktr->audio_mux_select;\n\n\ttemp = bt848->gpio_data & ~bktr->card.gpio_mux_bits;\n\tbt848->gpio_data =\n#if defined( AUDIOMUX_DISCOVER )\n\t\tbt848->gpio_data = temp | (cmd & 0xff);\n\t\tprintf(\"cmd: %d audio mux %x temp %x \\n\", cmd,bktr->card.audiomuxs[ idx ], temp );\n#else\n\t\ttemp | bktr->card.audiomuxs[ idx ];\n#endif /* AUDIOMUX_DISCOVER */\n\n\treturn( 0 );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_close( bktr_ptr_t bktr )\n{\n\tbktr->tflags &= ~TUNER_OPEN;\n\n\t/* mute the audio by switching the mux */\n\tset_audio( bktr, AUDIO_MUTE );\n\n\t/* disable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en = bktr->base->gpio_out_en & ~bktr->card.gpio_mux_bits;\n\n\treturn( 0 );\n}"
  },
  {
    "function_name": "video_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "2029-2052",
    "snippet": "static int\nvideo_close( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t\tbt848;\n\n\tbktr->flags &= ~(METEOR_OPEN     |\n\t\t\t METEOR_SINGLE   |\n\t\t\t METEOR_CAP_MASK |\n\t\t\t METEOR_WANT_MASK);\n\n\tbt848 = bktr->base;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->cap_ctl = CAPTURE_OFF;\n\n\tbktr->dma_prog_loaded = FALSE;\n\tbt848->tdec = 0;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */\n\tbt848->sreset = 0xf;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define CAPTURE_OFF\t\t0",
      "#define ALL_INTS_CLEARED\t0xffffffff",
      "#define ALL_INTS_DISABLED\t0",
      "#define FIFO_RISC_DISABLED\t0"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CAPTURE_OFF\t\t0\n#define ALL_INTS_CLEARED\t0xffffffff\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n\nstatic int\nvideo_close( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t\tbt848;\n\n\tbktr->flags &= ~(METEOR_OPEN     |\n\t\t\t METEOR_SINGLE   |\n\t\t\t METEOR_CAP_MASK |\n\t\t\t METEOR_WANT_MASK);\n\n\tbt848 = bktr->base;\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->cap_ctl = CAPTURE_OFF;\n\n\tbktr->dma_prog_loaded = FALSE;\n\tbt848->tdec = 0;\n\tbt848->int_mask = ALL_INTS_DISABLED;\n\n/** FIXME: is 0xf magic, wouldn't 0x00 work ??? */\n\tbt848->sreset = 0xf;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\treturn( 0 );\n}"
  },
  {
    "function_name": "tuner_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "1994-2021",
    "snippet": "static int\ntuner_open( bktr_ptr_t bktr )\n{\n\tif ( !(bktr->tflags & TUNER_INITALIZED) )\t/* device not found */\n\t\treturn( ENXIO );\t\n\n\tif ( bktr->tflags & TUNER_OPEN )\t\t/* already open */\n\t\treturn( 0 );\n\n\tbktr->tflags |= TUNER_OPEN;\n        bktr->tuner.radio_mode = 0;\n\n\t/* enable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en |= bktr->card.gpio_mux_bits;\n\n\t/* unmute the audio stream */\n\tset_audio( bktr, AUDIO_UNMUTE );\n\n\t/* enable stereo if appropriate on TDA audio chip */\n\tif ( bktr->card.dbx )\n\t\tinit_BTSC( bktr );\n\n\t/* reset the MSP34xx stereo audio chip */\n\tif ( bktr->card.msp3400c )\n\t\tmsp_reset( bktr );\n\t\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msp_reset",
          "args": [
            "bktr"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "msp_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5080-5101",
          "snippet": "static void msp_reset( bktr_ptr_t bktr ) {\n\n#ifndef BKTR_NO_MSP_RESET\n\t/* put into reset mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x80);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n\n\t/* put back to operational mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n#endif\n\treturn;\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define MSP3400C_WADDR\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define MSP3400C_WADDR\t\t0x80\n\nstatic void msp_reset( bktr_ptr_t bktr ) {\n\n#ifndef BKTR_NO_MSP_RESET\n\t/* put into reset mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x80);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n\n\t/* put back to operational mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n#endif\n\treturn;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_BTSC",
          "args": [
            "bktr"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "init_BTSC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6617-6627",
          "snippet": "static void \ninit_BTSC( bktr_ptr_t bktr )\n{\n    i2cWrite(bktr, TDA9850_WADDR, CON1ADDR, 0x08); /* noise threshold st */\n    i2cWrite(bktr, TDA9850_WADDR, CON2ADDR, 0x08); /* noise threshold sap */\n    i2cWrite(bktr, TDA9850_WADDR, CON3ADDR, 0x40); /* stereo mode */\n    i2cWrite(bktr, TDA9850_WADDR, CON4ADDR, 0x07); /* 0 dB input gain? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI1ADDR, 0x10); /* wideband alignment? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI2ADDR, 0x10); /* spectral alignment? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI3ADDR, 0x03);\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ALI3ADDR\t\t0x0a",
            "#define ALI2ADDR\t\t0x09",
            "#define ALI1ADDR\t\t0x08",
            "#define CON4ADDR\t\t0x07",
            "#define CON3ADDR\t\t0x06",
            "#define CON2ADDR\t\t0x05",
            "#define CON1ADDR\t\t0x04",
            "#define TDA9850_WADDR\t\t0xb6"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALI3ADDR\t\t0x0a\n#define ALI2ADDR\t\t0x09\n#define ALI1ADDR\t\t0x08\n#define CON4ADDR\t\t0x07\n#define CON3ADDR\t\t0x06\n#define CON2ADDR\t\t0x05\n#define CON1ADDR\t\t0x04\n#define TDA9850_WADDR\t\t0xb6\n\nstatic void \ninit_BTSC( bktr_ptr_t bktr )\n{\n    i2cWrite(bktr, TDA9850_WADDR, CON1ADDR, 0x08); /* noise threshold st */\n    i2cWrite(bktr, TDA9850_WADDR, CON2ADDR, 0x08); /* noise threshold sap */\n    i2cWrite(bktr, TDA9850_WADDR, CON3ADDR, 0x40); /* stereo mode */\n    i2cWrite(bktr, TDA9850_WADDR, CON4ADDR, 0x07); /* 0 dB input gain? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI1ADDR, 0x10); /* wideband alignment? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI2ADDR, 0x10); /* spectral alignment? */\n    i2cWrite(bktr, TDA9850_WADDR, ALI3ADDR, 0x03);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_audio",
          "args": [
            "bktr",
            "AUDIO_UNMUTE"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "set_audio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6494-6590",
          "snippet": "static int\nset_audio( bktr_ptr_t bktr, int cmd )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\ttemp;\n\tvolatile u_char\tidx;\n\n#if defined( AUDIOMUX_DISCOVER )\n\tif ( cmd >= 200 )\n\t\tcmd -= 200;\n\telse\n#endif /* AUDIOMUX_DISCOVER */\n\n\t/* check for existance of audio MUXes */\n\tif ( !bktr->card.audiomuxs[ 4 ] )\n\t\treturn( -1 );\n\n\tswitch (cmd) {\n\tcase AUDIO_TUNER:\n#ifdef BKTR_REVERSEMUTE\n\t\tbktr->audio_mux_select = 3;\n#else\n\t\tbktr->audio_mux_select = 0;\n#endif\n\n\t\tif (bktr->reverse_mute ) \n\t\t      bktr->audio_mux_select = 0;\n\t\telse\t\n\t\t    bktr->audio_mux_select = 3;\n\n\t\tbreak;\n\tcase AUDIO_EXTERN:\n\t\tbktr->audio_mux_select = 1;\n\t\tbreak;\n\tcase AUDIO_INTERN:\n\t\tbktr->audio_mux_select = 2;\n\t\tbreak;\n\tcase AUDIO_MUTE:\n\t\tbktr->audio_mute_state = TRUE;\t/* set mute */\n\t\tbreak;\n\tcase AUDIO_UNMUTE:\n\t\tbktr->audio_mute_state = FALSE;\t/* clear mute */\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bktr: audio cmd error %02x\\n\", cmd);\n\t\treturn( -1 );\n\t}\n\n\n\t/* Most cards have a simple audio multiplexer to select the\n\t * audio source. The I/O_GV card has a more advanced multiplexer\n\t * and requires special handling.\n\t */\n        if ( bktr->bt848_card == CARD_IO_GV ) {\n                set_bctv_audio( bktr );\n                return( 0 );\n\t}\n\n\t/* Proceed with the simpler audio multiplexer code for the majority\n\t * of Bt848 cards.\n\t */\n\n\tbt848 =\tbktr->base;\n\n\t/*\n\t * Leave the upper bits of the GPIO port alone in case they control\n\t * something like the dbx or teletext chips.  This doesn't guarantee\n\t * success, but follows the rule of least astonishment.\n\t */\n\n\tif ( bktr->audio_mute_state == TRUE ) {\n#ifdef BKTR_REVERSEMUTE\n\t\tidx = 0;\n#else\n\t\tidx = 3;\n#endif\n\n\t\tif (bktr->reverse_mute )\n\t\t  idx  = 3;\n\t\telse\t\n\t\t  idx  = 0;\n\n\t}\n\telse\n\t\tidx = bktr->audio_mux_select;\n\n\ttemp = bt848->gpio_data & ~bktr->card.gpio_mux_bits;\n\tbt848->gpio_data =\n#if defined( AUDIOMUX_DISCOVER )\n\t\tbt848->gpio_data = temp | (cmd & 0xff);\n\t\tprintf(\"cmd: %d audio mux %x temp %x \\n\", cmd,bktr->card.audiomuxs[ idx ], temp );\n#else\n\t\ttemp | bktr->card.audiomuxs[ idx ];\n#endif /* AUDIOMUX_DISCOVER */\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define CARD_IO_GV\t\t9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define CARD_IO_GV\t\t9\n\nstatic int\nset_audio( bktr_ptr_t bktr, int cmd )\n{\n\tbt848_ptr_t\tbt848;\n\tu_long\t\ttemp;\n\tvolatile u_char\tidx;\n\n#if defined( AUDIOMUX_DISCOVER )\n\tif ( cmd >= 200 )\n\t\tcmd -= 200;\n\telse\n#endif /* AUDIOMUX_DISCOVER */\n\n\t/* check for existance of audio MUXes */\n\tif ( !bktr->card.audiomuxs[ 4 ] )\n\t\treturn( -1 );\n\n\tswitch (cmd) {\n\tcase AUDIO_TUNER:\n#ifdef BKTR_REVERSEMUTE\n\t\tbktr->audio_mux_select = 3;\n#else\n\t\tbktr->audio_mux_select = 0;\n#endif\n\n\t\tif (bktr->reverse_mute ) \n\t\t      bktr->audio_mux_select = 0;\n\t\telse\t\n\t\t    bktr->audio_mux_select = 3;\n\n\t\tbreak;\n\tcase AUDIO_EXTERN:\n\t\tbktr->audio_mux_select = 1;\n\t\tbreak;\n\tcase AUDIO_INTERN:\n\t\tbktr->audio_mux_select = 2;\n\t\tbreak;\n\tcase AUDIO_MUTE:\n\t\tbktr->audio_mute_state = TRUE;\t/* set mute */\n\t\tbreak;\n\tcase AUDIO_UNMUTE:\n\t\tbktr->audio_mute_state = FALSE;\t/* clear mute */\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"bktr: audio cmd error %02x\\n\", cmd);\n\t\treturn( -1 );\n\t}\n\n\n\t/* Most cards have a simple audio multiplexer to select the\n\t * audio source. The I/O_GV card has a more advanced multiplexer\n\t * and requires special handling.\n\t */\n        if ( bktr->bt848_card == CARD_IO_GV ) {\n                set_bctv_audio( bktr );\n                return( 0 );\n\t}\n\n\t/* Proceed with the simpler audio multiplexer code for the majority\n\t * of Bt848 cards.\n\t */\n\n\tbt848 =\tbktr->base;\n\n\t/*\n\t * Leave the upper bits of the GPIO port alone in case they control\n\t * something like the dbx or teletext chips.  This doesn't guarantee\n\t * success, but follows the rule of least astonishment.\n\t */\n\n\tif ( bktr->audio_mute_state == TRUE ) {\n#ifdef BKTR_REVERSEMUTE\n\t\tidx = 0;\n#else\n\t\tidx = 3;\n#endif\n\n\t\tif (bktr->reverse_mute )\n\t\t  idx  = 3;\n\t\telse\t\n\t\t  idx  = 0;\n\n\t}\n\telse\n\t\tidx = bktr->audio_mux_select;\n\n\ttemp = bt848->gpio_data & ~bktr->card.gpio_mux_bits;\n\tbt848->gpio_data =\n#if defined( AUDIOMUX_DISCOVER )\n\t\tbt848->gpio_data = temp | (cmd & 0xff);\n\t\tprintf(\"cmd: %d audio mux %x temp %x \\n\", cmd,bktr->card.audiomuxs[ idx ], temp );\n#else\n\t\ttemp | bktr->card.audiomuxs[ idx ];\n#endif /* AUDIOMUX_DISCOVER */\n\n\treturn( 0 );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ntuner_open( bktr_ptr_t bktr )\n{\n\tif ( !(bktr->tflags & TUNER_INITALIZED) )\t/* device not found */\n\t\treturn( ENXIO );\t\n\n\tif ( bktr->tflags & TUNER_OPEN )\t\t/* already open */\n\t\treturn( 0 );\n\n\tbktr->tflags |= TUNER_OPEN;\n        bktr->tuner.radio_mode = 0;\n\n\t/* enable drivers on the GPIO port that control the MUXes */\n\tbktr->base->gpio_out_en |= bktr->card.gpio_mux_bits;\n\n\t/* unmute the audio stream */\n\tset_audio( bktr, AUDIO_UNMUTE );\n\n\t/* enable stereo if appropriate on TDA audio chip */\n\tif ( bktr->card.dbx )\n\t\tinit_BTSC( bktr );\n\n\t/* reset the MSP34xx stereo audio chip */\n\tif ( bktr->card.msp3400c )\n\t\tmsp_reset( bktr );\n\t\n\treturn( 0 );\n}"
  },
  {
    "function_name": "vbi_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "1971-1989",
    "snippet": "static int\nvbi_open( bktr_ptr_t bktr )\n{\n\tif (bktr->vbiflags & VBI_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->vbiflags |= VBI_OPEN;\n\n\t/* reset the VBI circular buffer pointers and clear the buffers */\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbi_sequence_number = 0;\n\n\tbzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);\n\tbzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);\n\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
      "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t) bktr->vbidata",
            "VBI_DATA_SIZE"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t) bktr->vbibuffer",
            "VBI_BUFFER_SIZE"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n\nstatic int\nvbi_open( bktr_ptr_t bktr )\n{\n\tif (bktr->vbiflags & VBI_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->vbiflags |= VBI_OPEN;\n\n\t/* reset the VBI circular buffer pointers and clear the buffers */\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbi_sequence_number = 0;\n\n\tbzero((caddr_t) bktr->vbibuffer, VBI_BUFFER_SIZE);\n\tbzero((caddr_t) bktr->vbidata,  VBI_DATA_SIZE);\n\n\treturn( 0 );\n}"
  },
  {
    "function_name": "video_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "1861-1969",
    "snippet": "static int\nvideo_open( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t bt848;\n\tint frame_rate, video_format=0;\n\n\tif (bktr->flags & METEOR_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->flags |= METEOR_OPEN;\n\n\tbt848 = bktr->base;\n\n#ifdef BT848_DUMP\n\tdump_bt848( bt848 );\n#endif\n\n        bktr->clr_on_start = FALSE;\n\n\tbt848->dstatus = 0x00;\t\t\t/* clear device status reg. */\n\n\tbt848->adc = SYNC_LEVEL;\n\n#if BROOKTREE_SYSTEM_DEFAULT == BROOKTREE_PAL\n\tvideo_format = 0;\n#else\n\tvideo_format = 1;\n#endif\n\n\tif (bt848_format == 0 ) \n\t  video_format = 0;\n\n\tif (bt848_format == 1 ) \n\t  video_format = 1;\n\n\tif (video_format == 1 ) {\n\t  bt848->iform = BT848_IFORM_F_NTSCM;\n\t  bktr->format_params = BT848_IFORM_F_NTSCM;\n\n\t} else {\n\t  bt848->iform = BT848_IFORM_F_PALBDGHI;\n\t  bktr->format_params = BT848_IFORM_F_PALBDGHI;\n\n\t}\n\n\tbt848->iform |= format_params[bktr->format_params].iform_xtsel;\n\n\t/* work around for new Hauppauge 878 cards */\n\tif ((bktr->card.card_id == CARD_HAUPPAUGE) &&\n\t    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbt848->iform |= BT848_IFORM_M_MUX3;\n\telse\n\t\tbt848->iform |= BT848_IFORM_M_MUX1;\n\n\tbt848->adelay = format_params[bktr->format_params].adelay;\n\tbt848->bdelay = format_params[bktr->format_params].bdelay;\n\tframe_rate    = format_params[bktr->format_params].frame_rate;\n\n\t/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */\n\tif (bktr->xtal_pll_mode == BT848_USE_PLL) {\n\t\tbt848->tgctrl=0;\n\t\tbt848->pll_f_lo=0xf9;\n\t\tbt848->pll_f_hi=0xdc;\n\t\tbt848->pll_f_xci=0x8e;\n\t}\n\n\tbktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;\n\n\tbktr->max_clip_node = 0;\n\n\tbt848->color_ctl_gamma       = 1;\n\tbt848->color_ctl_rgb_ded     = 1;\n\tbt848->color_ctl_color_bars  = 0;\n\tbt848->color_ctl_ext_frmrate = 0;\n\tbt848->color_ctl_swap        = 0;\n\n\tbt848->e_hscale_lo = 170;\n\tbt848->o_hscale_lo = 170;\n\n\tbt848->e_delay_lo = 0x72;\n\tbt848->o_delay_lo = 0x72;\n\tbt848->e_scloop = 0;\n\tbt848->o_scloop = 0;\n\n\tbt848->vbi_pack_size = 0;\n\tbt848->vbi_pack_del = 0;\n\n\tbktr->fifo_errors = 0;\n\tbktr->dma_errors = 0;\n\tbktr->frames_captured = 0;\n\tbktr->even_fields_captured = 0;\n\tbktr->odd_fields_captured = 0;\n\tbktr->proc = (struct proc *)0;\n\tset_fps(bktr, frame_rate);\n\tbktr->video.addr = 0;\n\tbktr->video.width = 0;\n\tbktr->video.banksize = 0;\n\tbktr->video.ramsize = 0;\n\tbktr->pixfmt_compat = TRUE;\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\n\tbktr->capture_area_enabled = FALSE;\n\n\tbt848->int_mask = BT848_INT_MYSTERYBIT;\t/* if you take this out triton\n                                                   based motherboards will \n\t\t\t\t\t\t   operate unreliably */\n\treturn( 0 );\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define\tCARD_HAUPPAUGE\t\t2",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */",
      "#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oformat_meteor_to_bt",
          "args": [
            "bktr->format"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "oformat_meteor_to_bt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4651-4680",
          "snippet": "static int oformat_meteor_to_bt( u_long format )\n{\n\tint    i;\n        struct meteor_pixfmt *pf1, *pf2;\n\n\t/*  Find format in compatibility table  */\n\tfor ( i = 0; i < METEOR_PIXFMT_TABLE_SIZE; i++ )\n\t\tif ( meteor_pixfmt_table[i].meteor_format == format )\n\t\t\tbreak;\n\n\tif ( i >= METEOR_PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\tpf1 = &meteor_pixfmt_table[i].public;\n\n\t/*  Match it with an entry in master pixel format table  */\n\tfor ( i = 0; i < PIXFMT_TABLE_SIZE; i++ ) {\n\t\tpf2 = &pixfmt_table[i].public;\n\n\t\tif (( pf1->type        == pf2->type        ) &&\n\t\t    ( pf1->Bpp         == pf2->Bpp         ) &&\n\t\t    !bcmp( pf1->masks, pf2->masks, sizeof( pf1->masks )) &&\n\t\t    ( pf1->swap_bytes  == pf2->swap_bytes  ) &&\n\t\t    ( pf1->swap_shorts == pf2->swap_shorts )) \n\t\t\tbreak;\n\t}\n\tif ( i >= PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\n\treturn i;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define METEOR_PIXFMT_TABLE_SIZE ( sizeof(meteor_pixfmt_table) / \\\n\t\t\t\t   sizeof(meteor_pixfmt_table[0]) )",
            "#define PIXFMT_TABLE_SIZE ( sizeof(pixfmt_table) / sizeof(pixfmt_table[0]) )"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define METEOR_PIXFMT_TABLE_SIZE ( sizeof(meteor_pixfmt_table) / \\\n\t\t\t\t   sizeof(meteor_pixfmt_table[0]) )\n#define PIXFMT_TABLE_SIZE ( sizeof(pixfmt_table) / sizeof(pixfmt_table[0]) )\n\nstatic int oformat_meteor_to_bt( u_long format )\n{\n\tint    i;\n        struct meteor_pixfmt *pf1, *pf2;\n\n\t/*  Find format in compatibility table  */\n\tfor ( i = 0; i < METEOR_PIXFMT_TABLE_SIZE; i++ )\n\t\tif ( meteor_pixfmt_table[i].meteor_format == format )\n\t\t\tbreak;\n\n\tif ( i >= METEOR_PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\tpf1 = &meteor_pixfmt_table[i].public;\n\n\t/*  Match it with an entry in master pixel format table  */\n\tfor ( i = 0; i < PIXFMT_TABLE_SIZE; i++ ) {\n\t\tpf2 = &pixfmt_table[i].public;\n\n\t\tif (( pf1->type        == pf2->type        ) &&\n\t\t    ( pf1->Bpp         == pf2->Bpp         ) &&\n\t\t    !bcmp( pf1->masks, pf2->masks, sizeof( pf1->masks )) &&\n\t\t    ( pf1->swap_bytes  == pf2->swap_bytes  ) &&\n\t\t    ( pf1->swap_shorts == pf2->swap_shorts )) \n\t\t\tbreak;\n\t}\n\tif ( i >= PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fps",
          "args": [
            "bktr",
            "frame_rate"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "set_fps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4567-4605",
          "snippet": "static void\nset_fps( bktr_ptr_t bktr, u_short fps )\n{\n\tbt848_ptr_t\tbt848;\n\tstruct format_params\t*fp;\n\tint i_flag;\n\n\tfp = &format_params[bktr->format_params];\n\n\tbt848 = bktr->base;\n\n\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\ti_flag = 1;\n\t\tbreak;\n\tcase METEOR_ONLY_ODD_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\ti_flag = 1;\n\t\tbreak;\n\tdefault:\n\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\ti_flag = 2;\n\t\tbreak;\n\t}\n\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\tbktr->fps = fps;\n\tbt848->tdec = 0;\n\n\tif (fps < fp->frame_rate)\n\t\tbt848->tdec = i_flag*(fp->frame_rate - fps) & 0x3f;\n\telse\n\t\tbt848->tdec = 0;\n\treturn;\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define ALL_INTS_CLEARED\t0xffffffff",
            "#define FIFO_RISC_DISABLED\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define ALL_INTS_CLEARED\t0xffffffff\n#define FIFO_RISC_DISABLED\t0\n\nstatic void\nset_fps( bktr_ptr_t bktr, u_short fps )\n{\n\tbt848_ptr_t\tbt848;\n\tstruct format_params\t*fp;\n\tint i_flag;\n\n\tfp = &format_params[bktr->format_params];\n\n\tbt848 = bktr->base;\n\n\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\ti_flag = 1;\n\t\tbreak;\n\tcase METEOR_ONLY_ODD_FIELDS:\n\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\ti_flag = 1;\n\t\tbreak;\n\tdefault:\n\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\ti_flag = 2;\n\t\tbreak;\n\t}\n\n\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\tbt848->int_stat = ALL_INTS_CLEARED;\n\n\tbktr->fps = fps;\n\tbt848->tdec = 0;\n\n\tif (fps < fp->frame_rate)\n\t\tbt848->tdec = i_flag*(fp->frame_rate - fps) & 0x3f;\n\telse\n\t\tbt848->tdec = 0;\n\treturn;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_bt848",
          "args": [
            "bt848"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "dump_bt848",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "3346-3373",
          "snippet": "static int\ndump_bt848( bt848_ptr_t bt848 )\n{\n\tvolatile u_char *bt848r = (u_char *)bt848;\n\tint\tr[60]={\n\t\t\t   4,    8, 0xc, 0x8c, 0x10, 0x90, 0x14, 0x94, \n\t\t\t0x18, 0x98, 0x1c, 0x9c, 0x20, 0xa0, 0x24, 0xa4,\n\t\t\t0x28, 0x2c, 0xac, 0x30, 0x34, 0x38, 0x3c, 0x40,\n\t\t\t0xc0, 0x48, 0x4c, 0xcc, 0x50, 0xd0, 0xd4, 0x60,\n\t\t\t0x64, 0x68, 0x6c, 0xec, 0xd8, 0xdc, 0xe0, 0xe4,\n\t\t\t0,\t 0,    0,    0\n\t\t   };\n\tint\ti;\n\n\tfor (i = 0; i < 40; i+=4) {\n\t\tprintf(\" Reg:value : \\t%x:%x \\t%x:%x \\t %x:%x \\t %x:%x\\n\",\n\t\t       r[i], bt848r[r[i]],\n\t\t       r[i+1], bt848r[r[i+1]],\n\t\t       r[i+2], bt848r[r[i+2]],\n\t\t       r[i+3], bt848r[r[i+3]]);\n\t}\n\n\tprintf(\" INT STAT %x \\n\",  bt848->int_stat);\n\tprintf(\" Reg INT_MASK %x \\n\",  bt848->int_mask);\n\tprintf(\" Reg GPIO_DMA_CTL %x \\n\", bt848->gpio_dma_ctl);\n\n\treturn( 0 );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic int\ndump_bt848( bt848_ptr_t bt848 )\n{\n\tvolatile u_char *bt848r = (u_char *)bt848;\n\tint\tr[60]={\n\t\t\t   4,    8, 0xc, 0x8c, 0x10, 0x90, 0x14, 0x94, \n\t\t\t0x18, 0x98, 0x1c, 0x9c, 0x20, 0xa0, 0x24, 0xa4,\n\t\t\t0x28, 0x2c, 0xac, 0x30, 0x34, 0x38, 0x3c, 0x40,\n\t\t\t0xc0, 0x48, 0x4c, 0xcc, 0x50, 0xd0, 0xd4, 0x60,\n\t\t\t0x64, 0x68, 0x6c, 0xec, 0xd8, 0xdc, 0xe0, 0xe4,\n\t\t\t0,\t 0,    0,    0\n\t\t   };\n\tint\ti;\n\n\tfor (i = 0; i < 40; i+=4) {\n\t\tprintf(\" Reg:value : \\t%x:%x \\t%x:%x \\t %x:%x \\t %x:%x\\n\",\n\t\t       r[i], bt848r[r[i]],\n\t\t       r[i+1], bt848r[r[i+1]],\n\t\t       r[i+2], bt848r[r[i+2]],\n\t\t       r[i+3], bt848r[r[i+3]]);\n\t}\n\n\tprintf(\" INT STAT %x \\n\",  bt848->int_stat);\n\tprintf(\" Reg INT_MASK %x \\n\",  bt848->int_mask);\n\tprintf(\" Reg GPIO_DMA_CTL %x \\n\", bt848->gpio_dma_ctl);\n\n\treturn( 0 );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define\tCARD_HAUPPAUGE\t\t2\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_SYNC_T)\t/* threshold ~75 mV */\n#define SYNC_LEVEL\t\t(BT848_ADC_RESERVED |\t\\\n\t\t\t\t BT848_ADC_CRUSH)\t/* threshold ~125 mV */\n\nstatic int\nvideo_open( bktr_ptr_t bktr )\n{\n\tbt848_ptr_t bt848;\n\tint frame_rate, video_format=0;\n\n\tif (bktr->flags & METEOR_OPEN)\t\t/* device is busy */\n\t\treturn( EBUSY );\n\n\tbktr->flags |= METEOR_OPEN;\n\n\tbt848 = bktr->base;\n\n#ifdef BT848_DUMP\n\tdump_bt848( bt848 );\n#endif\n\n        bktr->clr_on_start = FALSE;\n\n\tbt848->dstatus = 0x00;\t\t\t/* clear device status reg. */\n\n\tbt848->adc = SYNC_LEVEL;\n\n#if BROOKTREE_SYSTEM_DEFAULT == BROOKTREE_PAL\n\tvideo_format = 0;\n#else\n\tvideo_format = 1;\n#endif\n\n\tif (bt848_format == 0 ) \n\t  video_format = 0;\n\n\tif (bt848_format == 1 ) \n\t  video_format = 1;\n\n\tif (video_format == 1 ) {\n\t  bt848->iform = BT848_IFORM_F_NTSCM;\n\t  bktr->format_params = BT848_IFORM_F_NTSCM;\n\n\t} else {\n\t  bt848->iform = BT848_IFORM_F_PALBDGHI;\n\t  bktr->format_params = BT848_IFORM_F_PALBDGHI;\n\n\t}\n\n\tbt848->iform |= format_params[bktr->format_params].iform_xtsel;\n\n\t/* work around for new Hauppauge 878 cards */\n\tif ((bktr->card.card_id == CARD_HAUPPAUGE) &&\n\t    (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbt848->iform |= BT848_IFORM_M_MUX3;\n\telse\n\t\tbt848->iform |= BT848_IFORM_M_MUX1;\n\n\tbt848->adelay = format_params[bktr->format_params].adelay;\n\tbt848->bdelay = format_params[bktr->format_params].bdelay;\n\tframe_rate    = format_params[bktr->format_params].frame_rate;\n\n\t/* enable PLL mode using 28Mhz crystal for PAL/SECAM users */\n\tif (bktr->xtal_pll_mode == BT848_USE_PLL) {\n\t\tbt848->tgctrl=0;\n\t\tbt848->pll_f_lo=0xf9;\n\t\tbt848->pll_f_hi=0xdc;\n\t\tbt848->pll_f_xci=0x8e;\n\t}\n\n\tbktr->flags = (bktr->flags & ~METEOR_DEV_MASK) | METEOR_DEV0;\n\n\tbktr->max_clip_node = 0;\n\n\tbt848->color_ctl_gamma       = 1;\n\tbt848->color_ctl_rgb_ded     = 1;\n\tbt848->color_ctl_color_bars  = 0;\n\tbt848->color_ctl_ext_frmrate = 0;\n\tbt848->color_ctl_swap        = 0;\n\n\tbt848->e_hscale_lo = 170;\n\tbt848->o_hscale_lo = 170;\n\n\tbt848->e_delay_lo = 0x72;\n\tbt848->o_delay_lo = 0x72;\n\tbt848->e_scloop = 0;\n\tbt848->o_scloop = 0;\n\n\tbt848->vbi_pack_size = 0;\n\tbt848->vbi_pack_del = 0;\n\n\tbktr->fifo_errors = 0;\n\tbktr->dma_errors = 0;\n\tbktr->frames_captured = 0;\n\tbktr->even_fields_captured = 0;\n\tbktr->odd_fields_captured = 0;\n\tbktr->proc = (struct proc *)0;\n\tset_fps(bktr, frame_rate);\n\tbktr->video.addr = 0;\n\tbktr->video.width = 0;\n\tbktr->video.banksize = 0;\n\tbktr->video.ramsize = 0;\n\tbktr->pixfmt_compat = TRUE;\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\n\tbktr->capture_area_enabled = FALSE;\n\n\tbt848->int_mask = BT848_INT_MYSTERYBIT;\t/* if you take this out triton\n                                                   based motherboards will \n\t\t\t\t\t\t   operate unreliably */\n\treturn( 0 );\n}"
  },
  {
    "function_name": "common_bktr_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "1608-1853",
    "snippet": "static int \ncommon_bktr_intr( void *arg )\n{ \n\tbktr_ptr_t\t\tbktr;\n\tbt848_ptr_t\t\tbt848;\n\tu_long\t\t\tbktr_status;\n\tu_char\t\t\tdstatus;\n\tu_long                  field;\n\tu_long                  w_field;\n\tu_long                  req_field;\n\n\tbktr = (bktr_ptr_t) arg;\n\tbt848 = bktr->base;\n\n\t/*\n\t * check to see if any interrupts are unmasked on this device.  If\n\t * none are, then we likely got here by way of being on a PCI shared\n\t * interrupt dispatch list.\n\t */\n\tif (bt848->int_mask == ALL_INTS_DISABLED)\n\t  \treturn 0;\t/* bail out now, before we do something we\n\t\t\t\t   shouldn't */\n\n\tif (!(bktr->flags & METEOR_OPEN)) {\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\t\t/* return; ?? */\n\t}\n\n\t/* record and clear the INTerrupt status bits */\n\tbktr_status = bt848->int_stat;\n\tbt848->int_stat = bktr_status & ~I2C_BITS;\t/* don't touch i2c */\n\n\t/* record and clear the device status register */\n\tdstatus = bt848->dstatus;\n\tbt848->dstatus = 0x00;\n\n#if defined( STATUS_SUM )\n\t/* add any new device status or INTerrupt status bits */\n\tstatus_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));\n\tstatus_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);\n#endif /* STATUS_SUM */\n\t/* printf( \" STATUS %x %x %x \\n\",\n\t\tdstatus, bktr_status, bt848->risc_count );\n\t*/\n\n\n\t/* if risc was disabled re-start process again */\n\tif ( !(bktr_status & BT848_INT_RISC_EN) ||\n\t     ((bktr_status &(BT848_INT_FBUS   |\n\t\t\t      BT848_INT_FTRGT  |\n\t\t\t      BT848_INT_FDSR   |\n\t\t\t      BT848_INT_PPERR  |\n\t\t\t      BT848_INT_RIPERR |\n\t\t\t      BT848_INT_PABORT |\n\t\t\t      BT848_INT_OCERR  |\n\t\t\t      BT848_INT_SCERR) ) != 0) ||\n\t     ((bt848->tdec == 0) && (bktr_status & TDEC_BITS)) ) {\n\n\t\tu_short\ttdec_save = bt848->tdec;\n\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t/*  Reset temporal decimation ctr  */\n\t\tbt848->tdec = 0;\n\t\tbt848->tdec = tdec_save;\n\t\t\n\t\t/*  Reset to no-fields captured state  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\n\t\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n\t\t\t\t  BT848_INT_RISCI      |\n\t\t\t\t  BT848_INT_VSYNC      |\n\t\t\t\t  BT848_INT_FMTCHG;\n\n\t\tbt848->cap_ctl = bktr->bktr_cap_ctl;\n\t\treturn 1;\n\t}\n\n\t/* If this is not a RISC program interrupt, return */\n\tif (!(bktr_status & BT848_INT_RISCI))\n\t\treturn 0;\n\n/**\n\tprintf( \"intr status %x %x %x\\n\",\n\t\tbktr_status, dstatus, bt848->risc_count );\n */\n\t\n\n\t/*\n\t * Disable future interrupts if a capture mode is not selected.\n\t * This can happen when we are in the process of closing or \n\t * changing capture modes, otherwise it shouldn't happen.\n\t */\n\tif (!(bktr->flags & METEOR_CAP_MASK))\n\t\tbt848->cap_ctl = CAPTURE_OFF;\n\n\t/*\n\t *  Register the completed field\n\t *    (For dual-field mode, require fields from the same frame)\n\t */\n\tfield = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;\n\tswitch ( bktr->flags & METEOR_WANT_MASK ) {\n\t\tcase METEOR_WANT_ODD  : w_field = ODD_F         ;  break;\n\t\tcase METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;\n\t\tdefault               : w_field = (ODD_F|EVEN_F);  break;\n\t}\n\tswitch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {\n\t\tcase METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;\n\t\tcase METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;\n\t\tdefault                      : req_field = (ODD_F|EVEN_F);  \n\t\t\t                       break;\n\t}\n\n\tif (( field == EVEN_F ) && ( w_field == EVEN_F ))\n\t\tbktr->flags &= ~METEOR_WANT_EVEN;\n\telse if (( field == ODD_F ) && ( req_field == ODD_F ) &&\n\t\t ( w_field == ODD_F ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == (ODD_F|EVEN_F) ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == ODD_F )) {\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\t\tbktr->flags |=  METEOR_WANT_EVEN;\n\t}\n\telse {\n\t\t/*  We're out of sync.  Start over.  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If we have a complete frame.\n\t */\n\tif (!(bktr->flags & METEOR_WANT_MASK)) {\n\t\tbktr->frames_captured++;\n\t\t/*\n\t\t * post the completion time. \n\t\t */\n\t\tif (bktr->flags & METEOR_WANT_TS) {\n\t\t\tstruct timeval *ts;\n\t\t\t\n\t\t\tif ((u_int) bktr->alloc_pages * PAGE_SIZE\n\t\t\t   <= (bktr->frame_size + sizeof(struct timeval))) {\n\t\t\t\tts =(struct timeval *)bktr->bigbuf +\n\t\t\t\t  bktr->frame_size;\n\t\t\t\t/* doesn't work in synch mode except\n\t\t\t\t *  for first frame */\n\t\t\t\t/* XXX */\n\t\t\t\tmicrotime(ts);\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Process the VBI data if it is being captured\n\t\t */\n\t\tif (bktr->vbiflags & VBI_CAPTURE) {\n                \tvbidecode(bktr);\n                \twakeup(VBI_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * Wake up the user in single capture mode.\n\t\t */\n\t\tif (bktr->flags & METEOR_SINGLE) {\n\n\t\t\t/* stop dma */\n\t\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t\t/* disable risc, leave fifo running */\n\t\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\t\twakeup(BKTR_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * If the user requested to be notified via signal,\n\t\t * let them know the frame is complete.\n\t\t */\n\n\t\tif (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))\n\t\t\tpsignal( bktr->proc,\n\t\t\t\t bktr->signal&(~METEOR_SIG_MODE_MASK) );\n\n\t\t/*\n\t\t * Reset the want flags if in continuous or\n\t\t * synchronous capture mode.\n\t\t */\n/*\n* XXX NOTE (Luigi):\n* currently we only support 3 capture modes: odd only, even only,\n* odd+even interlaced (odd field first). A fourth mode (non interlaced,\n* either even OR odd) could provide 60 (50 for PAL) pictures per\n* second, but it would require this routine to toggle the desired frame\n* each time, and one more different DMA program for the Bt848.\n* As a consequence, this fourth mode is currently unsupported.\n*/\n\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)",
      "#define I2C_BITS\t\t(BT848_INT_RACK | BT848_INT_I2CDONE)",
      "#define CAPTURE_OFF\t\t0",
      "#define ALL_INTS_DISABLED\t0",
      "#define FIFO_RISC_DISABLED\t0",
      "#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN",
      "#define STATUS_SUM",
      "#define VBI_SLEEP   ((caddr_t)bktr + 1)",
      "#define BKTR_SLEEP  ((caddr_t)bktr    )",
      "#define EVEN_F 0x02",
      "#define ODD_F  0x01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "psignal",
          "args": [
            "bktr->proc",
            "bktr->signal&(~METEOR_SIG_MODE_MASK)"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "BKTR_SLEEP"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vbidecode",
          "args": [
            "bktr"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "vbidecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "1567-1599",
          "snippet": "static void vbidecode(bktr_ptr_t bktr) {\n        unsigned char *dest;\n\tunsigned int  *seq_dest;\n\n\t/* Check if there is room in the buffer to insert the data. */\n\tif (bktr->vbisize + VBI_DATA_SIZE > VBI_BUFFER_SIZE) return;\n\n\t/* Copy the VBI data into the next free slot in the buffer. */\n\t/* 'dest' is the point in vbibuffer where we want to insert new data */\n        dest = (unsigned char *)bktr->vbibuffer + bktr->vbiinsert;\n        memcpy(dest, (unsigned char*)bktr->vbidata, VBI_DATA_SIZE);\n\n\t/* Write the VBI sequence number to the end of the vbi data */\n\t/* This is used by the AleVT teletext program */\n\t/* XXX This kind of pointer arithmetic look unportable */\n\tseq_dest = (unsigned int *)((unsigned char *)bktr->vbibuffer\n\t\t\t+ bktr->vbiinsert\n\t\t\t+ (VBI_DATA_SIZE - sizeof(bktr->vbi_sequence_number)));\n\t*seq_dest = bktr->vbi_sequence_number;\n\n\n\t/* Increment the vbiinsert pointer */\n\t/* This can wrap around */\n\tbktr->vbiinsert += VBI_DATA_SIZE;\n\tbktr->vbiinsert = (bktr->vbiinsert % VBI_BUFFER_SIZE);\n\n\t/* And increase the amount of vbi data in the buffer */\n\tbktr->vbisize = bktr->vbisize + VBI_DATA_SIZE;\n\n\t/* And increase the VBI sequence number */\n\t/* This can wrap around */\n\tbktr->vbi_sequence_number++;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
            "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n\nstatic void vbidecode(bktr_ptr_t bktr) {\n        unsigned char *dest;\n\tunsigned int  *seq_dest;\n\n\t/* Check if there is room in the buffer to insert the data. */\n\tif (bktr->vbisize + VBI_DATA_SIZE > VBI_BUFFER_SIZE) return;\n\n\t/* Copy the VBI data into the next free slot in the buffer. */\n\t/* 'dest' is the point in vbibuffer where we want to insert new data */\n        dest = (unsigned char *)bktr->vbibuffer + bktr->vbiinsert;\n        memcpy(dest, (unsigned char*)bktr->vbidata, VBI_DATA_SIZE);\n\n\t/* Write the VBI sequence number to the end of the vbi data */\n\t/* This is used by the AleVT teletext program */\n\t/* XXX This kind of pointer arithmetic look unportable */\n\tseq_dest = (unsigned int *)((unsigned char *)bktr->vbibuffer\n\t\t\t+ bktr->vbiinsert\n\t\t\t+ (VBI_DATA_SIZE - sizeof(bktr->vbi_sequence_number)));\n\t*seq_dest = bktr->vbi_sequence_number;\n\n\n\t/* Increment the vbiinsert pointer */\n\t/* This can wrap around */\n\tbktr->vbiinsert += VBI_DATA_SIZE;\n\tbktr->vbiinsert = (bktr->vbiinsert % VBI_BUFFER_SIZE);\n\n\t/* And increase the amount of vbi data in the buffer */\n\tbktr->vbisize = bktr->vbisize + VBI_DATA_SIZE;\n\n\t/* And increase the VBI sequence number */\n\t/* This can wrap around */\n\tbktr->vbi_sequence_number++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "ts"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "bktr->dma_prog"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define TDEC_BITS               (BT848_INT_FDSR | BT848_INT_FBUS)\n#define I2C_BITS\t\t(BT848_INT_RACK | BT848_INT_I2CDONE)\n#define CAPTURE_OFF\t\t0\n#define ALL_INTS_DISABLED\t0\n#define FIFO_RISC_DISABLED\t0\n#define FIFO_ENABLED\t\tBT848_DMA_CTL_FIFO_EN\n#define STATUS_SUM\n#define VBI_SLEEP   ((caddr_t)bktr + 1)\n#define BKTR_SLEEP  ((caddr_t)bktr    )\n#define EVEN_F 0x02\n#define ODD_F  0x01\n\nstatic int \ncommon_bktr_intr( void *arg )\n{ \n\tbktr_ptr_t\t\tbktr;\n\tbt848_ptr_t\t\tbt848;\n\tu_long\t\t\tbktr_status;\n\tu_char\t\t\tdstatus;\n\tu_long                  field;\n\tu_long                  w_field;\n\tu_long                  req_field;\n\n\tbktr = (bktr_ptr_t) arg;\n\tbt848 = bktr->base;\n\n\t/*\n\t * check to see if any interrupts are unmasked on this device.  If\n\t * none are, then we likely got here by way of being on a PCI shared\n\t * interrupt dispatch list.\n\t */\n\tif (bt848->int_mask == ALL_INTS_DISABLED)\n\t  \treturn 0;\t/* bail out now, before we do something we\n\t\t\t\t   shouldn't */\n\n\tif (!(bktr->flags & METEOR_OPEN)) {\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\t\t/* return; ?? */\n\t}\n\n\t/* record and clear the INTerrupt status bits */\n\tbktr_status = bt848->int_stat;\n\tbt848->int_stat = bktr_status & ~I2C_BITS;\t/* don't touch i2c */\n\n\t/* record and clear the device status register */\n\tdstatus = bt848->dstatus;\n\tbt848->dstatus = 0x00;\n\n#if defined( STATUS_SUM )\n\t/* add any new device status or INTerrupt status bits */\n\tstatus_sum |= (bktr_status & ~(BT848_INT_RSV0|BT848_INT_RSV1));\n\tstatus_sum |= ((dstatus & (BT848_DSTATUS_COF|BT848_DSTATUS_LOF)) << 6);\n#endif /* STATUS_SUM */\n\t/* printf( \" STATUS %x %x %x \\n\",\n\t\tdstatus, bktr_status, bt848->risc_count );\n\t*/\n\n\n\t/* if risc was disabled re-start process again */\n\tif ( !(bktr_status & BT848_INT_RISC_EN) ||\n\t     ((bktr_status &(BT848_INT_FBUS   |\n\t\t\t      BT848_INT_FTRGT  |\n\t\t\t      BT848_INT_FDSR   |\n\t\t\t      BT848_INT_PPERR  |\n\t\t\t      BT848_INT_RIPERR |\n\t\t\t      BT848_INT_PABORT |\n\t\t\t      BT848_INT_OCERR  |\n\t\t\t      BT848_INT_SCERR) ) != 0) ||\n\t     ((bt848->tdec == 0) && (bktr_status & TDEC_BITS)) ) {\n\n\t\tu_short\ttdec_save = bt848->tdec;\n\n\t\tbt848->gpio_dma_ctl = FIFO_RISC_DISABLED;\n\n\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t/*  Reset temporal decimation ctr  */\n\t\tbt848->tdec = 0;\n\t\tbt848->tdec = tdec_save;\n\t\t\n\t\t/*  Reset to no-fields captured state  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbt848->risc_strt_add = vtophys(bktr->dma_prog);\n\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\tbt848->gpio_dma_ctl = bktr->capcontrol;\n\n\t\tbt848->int_mask = BT848_INT_MYSTERYBIT |\n\t\t\t\t  BT848_INT_RISCI      |\n\t\t\t\t  BT848_INT_VSYNC      |\n\t\t\t\t  BT848_INT_FMTCHG;\n\n\t\tbt848->cap_ctl = bktr->bktr_cap_ctl;\n\t\treturn 1;\n\t}\n\n\t/* If this is not a RISC program interrupt, return */\n\tif (!(bktr_status & BT848_INT_RISCI))\n\t\treturn 0;\n\n/**\n\tprintf( \"intr status %x %x %x\\n\",\n\t\tbktr_status, dstatus, bt848->risc_count );\n */\n\t\n\n\t/*\n\t * Disable future interrupts if a capture mode is not selected.\n\t * This can happen when we are in the process of closing or \n\t * changing capture modes, otherwise it shouldn't happen.\n\t */\n\tif (!(bktr->flags & METEOR_CAP_MASK))\n\t\tbt848->cap_ctl = CAPTURE_OFF;\n\n\t/*\n\t *  Register the completed field\n\t *    (For dual-field mode, require fields from the same frame)\n\t */\n\tfield = ( bktr_status & BT848_INT_FIELD ) ? EVEN_F : ODD_F;\n\tswitch ( bktr->flags & METEOR_WANT_MASK ) {\n\t\tcase METEOR_WANT_ODD  : w_field = ODD_F         ;  break;\n\t\tcase METEOR_WANT_EVEN : w_field = EVEN_F        ;  break;\n\t\tdefault               : w_field = (ODD_F|EVEN_F);  break;\n\t}\n\tswitch ( bktr->flags & METEOR_ONLY_FIELDS_MASK ) {\n\t\tcase METEOR_ONLY_ODD_FIELDS  : req_field = ODD_F  ;  break;\n\t\tcase METEOR_ONLY_EVEN_FIELDS : req_field = EVEN_F ;  break;\n\t\tdefault                      : req_field = (ODD_F|EVEN_F);  \n\t\t\t                       break;\n\t}\n\n\tif (( field == EVEN_F ) && ( w_field == EVEN_F ))\n\t\tbktr->flags &= ~METEOR_WANT_EVEN;\n\telse if (( field == ODD_F ) && ( req_field == ODD_F ) &&\n\t\t ( w_field == ODD_F ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == (ODD_F|EVEN_F) ))\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\telse if (( field == ODD_F ) && ( req_field == (ODD_F|EVEN_F) ) &&\n\t\t ( w_field == ODD_F )) {\n\t\tbktr->flags &= ~METEOR_WANT_ODD;\n\t\tbktr->flags |=  METEOR_WANT_EVEN;\n\t}\n\telse {\n\t\t/*  We're out of sync.  Start over.  */\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/*\n\t * If we have a complete frame.\n\t */\n\tif (!(bktr->flags & METEOR_WANT_MASK)) {\n\t\tbktr->frames_captured++;\n\t\t/*\n\t\t * post the completion time. \n\t\t */\n\t\tif (bktr->flags & METEOR_WANT_TS) {\n\t\t\tstruct timeval *ts;\n\t\t\t\n\t\t\tif ((u_int) bktr->alloc_pages * PAGE_SIZE\n\t\t\t   <= (bktr->frame_size + sizeof(struct timeval))) {\n\t\t\t\tts =(struct timeval *)bktr->bigbuf +\n\t\t\t\t  bktr->frame_size;\n\t\t\t\t/* doesn't work in synch mode except\n\t\t\t\t *  for first frame */\n\t\t\t\t/* XXX */\n\t\t\t\tmicrotime(ts);\n\t\t\t}\n\t\t}\n\t\n\t\t/*\n\t\t * Process the VBI data if it is being captured\n\t\t */\n\t\tif (bktr->vbiflags & VBI_CAPTURE) {\n                \tvbidecode(bktr);\n                \twakeup(VBI_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * Wake up the user in single capture mode.\n\t\t */\n\t\tif (bktr->flags & METEOR_SINGLE) {\n\n\t\t\t/* stop dma */\n\t\t\tbt848->int_mask = ALL_INTS_DISABLED;\n\n\t\t\t/* disable risc, leave fifo running */\n\t\t\tbt848->gpio_dma_ctl = FIFO_ENABLED;\n\t\t\twakeup(BKTR_SLEEP);\n\t\t}\n\n\t\t/*\n\t\t * If the user requested to be notified via signal,\n\t\t * let them know the frame is complete.\n\t\t */\n\n\t\tif (bktr->proc && !(bktr->signal & METEOR_SIG_MODE_MASK))\n\t\t\tpsignal( bktr->proc,\n\t\t\t\t bktr->signal&(~METEOR_SIG_MODE_MASK) );\n\n\t\t/*\n\t\t * Reset the want flags if in continuous or\n\t\t * synchronous capture mode.\n\t\t */\n/*\n* XXX NOTE (Luigi):\n* currently we only support 3 capture modes: odd only, even only,\n* odd+even interlaced (odd field first). A fourth mode (non interlaced,\n* either even OR odd) could provide 60 (50 for PAL) pictures per\n* second, but it would require this routine to toggle the desired frame\n* each time, and one more different DMA program for the Bt848.\n* As a consequence, this fourth mode is currently unsupported.\n*/\n\n\t\tif (bktr->flags & (METEOR_CONTIN | METEOR_SYNCAP)) {\n\t\t\tswitch(bktr->flags & METEOR_ONLY_FIELDS_MASK) {\n\t\t\tcase METEOR_ONLY_ODD_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_ODD;\n\t\t\t\tbreak;\n\t\t\tcase METEOR_ONLY_EVEN_FIELDS:\n\t\t\t\tbktr->flags |= METEOR_WANT_EVEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbktr->flags |= METEOR_WANT_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "vbidecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "1567-1599",
    "snippet": "static void vbidecode(bktr_ptr_t bktr) {\n        unsigned char *dest;\n\tunsigned int  *seq_dest;\n\n\t/* Check if there is room in the buffer to insert the data. */\n\tif (bktr->vbisize + VBI_DATA_SIZE > VBI_BUFFER_SIZE) return;\n\n\t/* Copy the VBI data into the next free slot in the buffer. */\n\t/* 'dest' is the point in vbibuffer where we want to insert new data */\n        dest = (unsigned char *)bktr->vbibuffer + bktr->vbiinsert;\n        memcpy(dest, (unsigned char*)bktr->vbidata, VBI_DATA_SIZE);\n\n\t/* Write the VBI sequence number to the end of the vbi data */\n\t/* This is used by the AleVT teletext program */\n\t/* XXX This kind of pointer arithmetic look unportable */\n\tseq_dest = (unsigned int *)((unsigned char *)bktr->vbibuffer\n\t\t\t+ bktr->vbiinsert\n\t\t\t+ (VBI_DATA_SIZE - sizeof(bktr->vbi_sequence_number)));\n\t*seq_dest = bktr->vbi_sequence_number;\n\n\n\t/* Increment the vbiinsert pointer */\n\t/* This can wrap around */\n\tbktr->vbiinsert += VBI_DATA_SIZE;\n\tbktr->vbiinsert = (bktr->vbiinsert % VBI_BUFFER_SIZE);\n\n\t/* And increase the amount of vbi data in the buffer */\n\tbktr->vbisize = bktr->vbisize + VBI_DATA_SIZE;\n\n\t/* And increase the VBI sequence number */\n\t/* This can wrap around */\n\tbktr->vbi_sequence_number++;\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
      "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "(unsigned char*)bktr->vbidata",
            "VBI_DATA_SIZE"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n\nstatic void vbidecode(bktr_ptr_t bktr) {\n        unsigned char *dest;\n\tunsigned int  *seq_dest;\n\n\t/* Check if there is room in the buffer to insert the data. */\n\tif (bktr->vbisize + VBI_DATA_SIZE > VBI_BUFFER_SIZE) return;\n\n\t/* Copy the VBI data into the next free slot in the buffer. */\n\t/* 'dest' is the point in vbibuffer where we want to insert new data */\n        dest = (unsigned char *)bktr->vbibuffer + bktr->vbiinsert;\n        memcpy(dest, (unsigned char*)bktr->vbidata, VBI_DATA_SIZE);\n\n\t/* Write the VBI sequence number to the end of the vbi data */\n\t/* This is used by the AleVT teletext program */\n\t/* XXX This kind of pointer arithmetic look unportable */\n\tseq_dest = (unsigned int *)((unsigned char *)bktr->vbibuffer\n\t\t\t+ bktr->vbiinsert\n\t\t\t+ (VBI_DATA_SIZE - sizeof(bktr->vbi_sequence_number)));\n\t*seq_dest = bktr->vbi_sequence_number;\n\n\n\t/* Increment the vbiinsert pointer */\n\t/* This can wrap around */\n\tbktr->vbiinsert += VBI_DATA_SIZE;\n\tbktr->vbiinsert = (bktr->vbiinsert % VBI_BUFFER_SIZE);\n\n\t/* And increase the amount of vbi data in the buffer */\n\tbktr->vbisize = bktr->vbisize + VBI_DATA_SIZE;\n\n\t/* And increase the VBI sequence number */\n\t/* This can wrap around */\n\tbktr->vbi_sequence_number++;\n}"
  },
  {
    "function_name": "common_bktr_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
    "lines": "1447-1558",
    "snippet": "static void \ncommon_bktr_attach( bktr_ptr_t bktr, int unit, u_long pci_id, u_int rev )\n{\n\tbt848_ptr_t\tbt848;\n\tvm_offset_t\tbuf;\n\n\tbt848 = bktr->base;\n\n/***************************************/\n/* *** OS Specific memory routines *** */\n/***************************************/\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n        /* allocate space for dma program */\n        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);\n        bktr->odd_dma_prog = get_bktr_mem(bktr, &bktr->dm_oprog, DMA_PROG_ALLOC)\n;\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(bktr, &bktr->dm_vbibuffer, VBI_BUFFER_SIZE);\n\n        /* allocate space for pixel buffer */\n        if ( BROOKTREE_ALLOC )\n                buf = get_bktr_mem(bktr, &bktr->dm_mem, BROOKTREE_ALLOC);\n        else\n                buf = 0;\n#endif\n\n#if defined(__FreeBSD__) || defined(__bsdi__)\n\t/* allocate space for dma program */\n\tbktr->dma_prog     = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\tbktr->odd_dma_prog = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(unit, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(unit, VBI_BUFFER_SIZE);\n\n\t/* allocate space for pixel buffer */\n\tif ( BROOKTREE_ALLOC )\n\t\tbuf = get_bktr_mem(unit, BROOKTREE_ALLOC);\n\telse\n\t\tbuf = 0;\n#endif\n\n\tif ( bootverbose ) {\n\t\tprintf(\"bktr%d: buffer size %d, addr 0x%x\\n\",\n\t\t\tunit, BROOKTREE_ALLOC, vtophys(buf));\n\t}\n\n\tif ( buf != 0 ) {\n\t\tbktr->bigbuf = buf;\n\t\tbktr->alloc_pages = BROOKTREE_ALLOC_PAGES;\n\t\tbzero((caddr_t) bktr->bigbuf, BROOKTREE_ALLOC);\n\t} else {\n\t\tbktr->alloc_pages = 0;\n\t}\n\t\t\n\n\tbktr->flags = METEOR_INITALIZED | METEOR_AUTOMODE |\n\t\t      METEOR_DEV0 | METEOR_RGB16;\n\tbktr->dma_prog_loaded = FALSE;\n\tbktr->cols = 640;\n\tbktr->rows = 480;\n\tbktr->frames = 1;\t\t/* one frame */\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\tbktr->pixfmt_compat = TRUE;\n\n\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbiflags = 0;\n\n \n\t/* using the pci device id and revision id */\n\t/* and determine the card type            */\n\tswitch (pci_id) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) bktr->id = BROOKTREE_848A;\n\t\telse             bktr->id = BROOKTREE_848;\n\t\tbreak;\n        case BROOKTREE_849_PCI_ID:\n\t\tbktr->id = BROOKTREE_849A;\n\t\tbreak;\n        case BROOKTREE_878_PCI_ID:\n\t\tbktr->id = BROOKTREE_878;\n\t\tbreak;\n        case BROOKTREE_879_PCI_ID:\n\t\tbktr->id = BROOKTREE_879;\n\t\tbreak;\n\t};\n\n\tbktr->clr_on_start = FALSE;\n\n\t/* defaults for the tuner section of the card */\n\tbktr->tflags = TUNER_INITALIZED;\n\tbktr->tuner.frequency = 0;\n\tbktr->tuner.channel = 0;\n\tbktr->tuner.chnlset = DEFAULT_CHNLSET;\n\tbktr->audio_mux_select = 0;\n\tbktr->audio_mute_state = FALSE;\n\tbktr->bt848_card = -1;\n\tbktr->bt848_tuner = -1;\n\tbktr->reverse_mute = -1;\n\n\tprobeCard( bktr, TRUE );\n\n\t/* If there is an MSP Audio device, reset it and display the model */\n\tif (bktr->card.msp3400c)msp_reset(bktr);\n\tif (bktr->card.msp3400c)msp_read_id(bktr);\n\n}",
    "includes": [
      "#include <dev/pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <machine/bus.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/reboot.h>",
      "#include \"brktree_reg.h\"",
      "#include \"ioctl_bt848.h\"",
      "#include \"ioctl_meteor.h\"",
      "#include <i386/eisa/eisa.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/isa.h>",
      "#include <sys/device.h>",
      "#include <sys/sysctl.h>",
      "#include \"iicbus_if.h\"",
      "#include \"smbus_if.h\"",
      "#include <dev/iicbus/iiconf.h>",
      "#include <dev/smbus/smbconf.h>",
      "#include <pci/bt848_i2c.h>",
      "#include <pci/brktree_reg.h>",
      "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
      "#include <machine/ioctl_meteor.h>",
      "#include <pci/pcireg.h>",
      "#include <pci/pcivar.h>",
      "#include <machine/clock.h>      /* for DELAY */",
      "#include <machine/resource.h>\t/* used by newbus */",
      "#include <sys/rman.h>\t\t/* used by newbus */",
      "#include <machine/bus.h>\t/* used by newbus */",
      "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
      "#include <sys/devfsext.h>",
      "#include \"smbus.h\"",
      "#include <vm/vm_extern.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm.h>",
      "#include <sys/mman.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/kernel.h>",
      "#include <sys/uio.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"pci.h\"",
      "#include \"bktr.h\"",
      "#include \"opt_devfs.h\"",
      "#include \"opt_bktr.h\"",
      "#include \"bktr.h\""
    ],
    "macros_used": [
      "#define DEFAULT_CHNLSET\tCHNLSET_WEUROPE",
      "#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)",
      "#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)",
      "#define BROOKTREE_ALLOC\t\t(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)",
      "#define BROOKTREE_ALLOC_PAGES\t217*4",
      "#define DMA_PROG_ALLOC\t\t(8 * PAGE_SIZE)",
      "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msp_read_id",
          "args": [
            "bktr"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "msp_read_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "6781-6790",
          "snippet": "static void msp_read_id( bktr_ptr_t bktr ){\n    int rev1=0, rev2=0;\n    rev1 = msp_read(bktr, 0x12, 0x001e);\n    rev2 = msp_read(bktr, 0x12, 0x001f);\n\n    sprintf(bktr->msp_version_string, \"34%02d%c-%c%d\",\n      (rev2>>8)&0xff, (rev1&0xff)+'@', ((rev1>>8)&0xff)+'@', rev2&0x1f);\n\n    printf(\"Detected a MSP%s\\n\",bktr->msp_version_string); \n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic void msp_read_id( bktr_ptr_t bktr ){\n    int rev1=0, rev2=0;\n    rev1 = msp_read(bktr, 0x12, 0x001e);\n    rev2 = msp_read(bktr, 0x12, 0x001f);\n\n    sprintf(bktr->msp_version_string, \"34%02d%c-%c%d\",\n      (rev2>>8)&0xff, (rev1&0xff)+'@', ((rev1>>8)&0xff)+'@', rev2&0x1f);\n\n    printf(\"Detected a MSP%s\\n\",bktr->msp_version_string); \n}"
        }
      },
      {
        "call_info": {
          "callee": "msp_reset",
          "args": [
            "bktr"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "msp_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5080-5101",
          "snippet": "static void msp_reset( bktr_ptr_t bktr ) {\n\n#ifndef BKTR_NO_MSP_RESET\n\t/* put into reset mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x80);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n\n\t/* put back to operational mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n#endif\n\treturn;\n\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define MSP3400C_WADDR\t\t0x80"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define MSP3400C_WADDR\t\t0x80\n\nstatic void msp_reset( bktr_ptr_t bktr ) {\n\n#ifndef BKTR_NO_MSP_RESET\n\t/* put into reset mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x80);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n\n\t/* put back to operational mode */\n\ti2c_start(bktr);\n\ti2c_write_byte(bktr, MSP3400C_WADDR);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_write_byte(bktr, 0x00);\n\ti2c_stop(bktr);\n#endif\n\treturn;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "probeCard",
          "args": [
            "bktr",
            "TRUE"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "probeCard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "5356-5885",
          "snippet": "static void\nprobeCard( bktr_ptr_t bktr, int verbose )\n{\n\tint\t\tcard, i,j, card_found;\n\tint\t\tstatus;\n\tbt848_ptr_t\tbt848;\n\tu_char \t\tprobe_signature[128], *probe_temp;\n        int   \t\tany_i2c_devices;\n\tu_char \t\teeprom[256];\n\tu_char \t\ttuner_code = 0;\n\tint \t\ttuner_i2c_address = -1;\n\tint \t\teeprom_i2c_address = -1;\n\n\tbt848 = bktr->base;\n\n\t/* Select all GPIO bits as inputs */\n\tbt848->gpio_out_en = 0;\n\tif (bootverbose)\n\t    printf(\"bktr: GPIO is 0x%08x\\n\", bt848->gpio_data);\n\n#ifdef HAUPPAUGE_MSP_RESET\n\t/* Reset the MSP34xx audio chip. This resolves bootup card\n\t * detection problems with old Bt848 based Hauppauge cards with\n\t * MSP34xx stereo audio chips. This must be user enabled because\n\t * at this point the probe function does not know the card type. */\n        bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n#endif\n\n\t/* Check for the presence of i2c devices */\n        any_i2c_devices = check_for_i2c_devices( bktr );\n\n\n\t/* Check for a user specified override on the card selection */\n#if defined( OVERRIDE_CARD )\n\tbktr->card = cards[ (card = OVERRIDE_CARD) ];\n\tgoto checkEEPROM;\n#endif\n\tif (bktr->bt848_card != -1 ) {\n\t  bktr->card = cards[ (card = bktr->bt848_card) ];\n\t  goto checkEEPROM;\n\t}\n\n\n\t/* No override, so try and determine the make of the card */\n\n        /* On BT878/879 cards, read the sub-system vendor id */\n\t/* This identifies the manufacturer of the card and the model */\n\t/* In theory this can be read from PCI registers but this does not */\n\t/* appear to work on the FlyVideo 98. Hauppauge also warned that */\n\t/* the PCI registers are sometimes not loaded correctly. */\n\t/* Therefore, I will read the sub-system vendor ID from the EEPROM */\n\t/* (just like the Bt878 does during power up initialisation) */\n\n        if (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) {\n\n\t    /* Try and locate the EEPROM */\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\n                unsigned int subsystem_vendor_id; /* vendors PCI-SIG ID */\n                unsigned int subsystem_id;        /* board model number */\n\t\tunsigned int byte_252, byte_253, byte_254, byte_255;\n\n\t\tbktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\n\t        readEEProm(bktr, 0, 256, (u_char *) &eeprom );\n                byte_252 = (unsigned int)eeprom[252];\n                byte_253 = (unsigned int)eeprom[253];\n                byte_254 = (unsigned int)eeprom[254];\n                byte_255 = (unsigned int)eeprom[255];\n                \n                subsystem_id        = (byte_252 << 8) | byte_253;\n                subsystem_vendor_id = (byte_254 << 8) | byte_255;\n\n\t        if ( bootverbose ) \n\t            printf(\"subsystem 0x%04x 0x%04x\\n\",subsystem_vendor_id,\n\t\t                                  subsystem_id);\n\n                if (subsystem_vendor_id == VENDOR_AVER_MEDIA) {\n                    bktr->card = cards[ (card = CARD_AVER_MEDIA) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_HAUPPAUGE) {\n                    bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_FLYVIDEO) {\n                    bktr->card = cards[ (card = CARD_FLYVIDEO) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_STB) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                /* Vendor is unknown. We will use the standard probe code */\n\t\t/* which may not give best results */\n                printf(\"Warning - card vendor 0x%04x (model 0x%04x) unknown. This may cause poor performance\\n\",subsystem_vendor_id,subsystem_id);\n            }\n\t    else\n\t    {\n                printf(\"Warning - card has no configuration EEPROM. Cannot determine card make. This may cause poor performance\\n\");\n\t    }\n\t} /* end of bt878/bt879 card detection code */\n\n\t/* If we get to this point, we must have a Bt848/848A/849A card */\n\t/* or a Bt878/879 with an unknown subsystem vendor id */\n        /* Try and determine the make of card by clever i2c probing */\n\n   \t/* Check for i2c devices. If none, move on */\n\tif (!any_i2c_devices) {\n\t\tbktr->card = cards[ (card = CARD_INTEL) ];\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t\tgoto checkTuner;\n\t}\n\n\n        /* Look for Hauppauge, STB and Osprey cards by the presence */\n\t/* of an EEPROM */\n        /* Note: Bt878 based cards also use EEPROMs so we can only do this */\n        /* test on BT848/848A and 849A based cards. */\n\tif ((bktr->id==BROOKTREE_848)  ||\n\t    (bktr->id==BROOKTREE_848A) ||\n\t    (bktr->id==BROOKTREE_849A)) {\n\n            /* At i2c address 0xa0, look for Hauppauge and Osprey cards */\n            if ( (status = i2cRead( bktr, PFC8582_RADDR )) != ABSENT ) {\n\n\t\t    /* Read the eeprom contents */\n\t\t    bktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t            readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\t\t    /* For Hauppauge, check the EEPROM begins with 0x84 */\n\t\t    if (eeprom[0] == 0x84) {\n                            bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\n\t\t    /* For Osprey, check the EEPROM begins with \"MMAC\" */\n\t\t    if (  (eeprom[0] == 'M') &&(eeprom[1] == 'M')\n\t\t\t&&(eeprom[2] == 'A') &&(eeprom[3] == 'C')) {\n                            bktr->card = cards[ (card = CARD_OSPREY) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\t\t    printf(\"Warning: Unknown card type. EEPROM data not recognised\\n\");\n\t\t    printf(\"%x %x %x %x\\n\",eeprom[0],eeprom[1],eeprom[2],eeprom[3]);\n            }\n\n            /* look for an STB card */\n            if ( (status = i2cRead( bktr, X24C01_RADDR )) != ABSENT ) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = X24C01_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(128 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n            }\n\n\t}\n\n\tsignCard( bktr, 1, 128, (u_char *)  &probe_signature );\n\n\tif (bootverbose) {\n\t  printf(\"card signature \\n\");\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    printf(\" %02x \", probe_signature[j]);\n\t  }\n\t  printf(\"\\n\\n\");\n\t}\n\tfor (i = 0;\n\t     i < (sizeof bt848_card_signature)/ sizeof (struct bt848_card_sig);\n\t     i++ ) {\n\n\t  card_found = 1;\n\t  probe_temp = (u_char *) &bt848_card_signature[i].signature;\n\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    if ((probe_temp[j] & 0xf) != (probe_signature[j] & 0xf)) {\n\t      card_found = 0;\n\t      break;\n\t    }\n\n\t  }\n\t  if (card_found) {\n\t    bktr->card = cards[ card = bt848_card_signature[i].card];\n\t    bktr->card.tuner = &tuners[ bt848_card_signature[i].tuner];\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t    } else {\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t    }\n\t    goto checkDBX;\n\t  }\n\t}\n\n\t/* We do not know the card type. Default to Miro */\n\tbktr->card = cards[ (card = CARD_MIRO) ];\n\n\ncheckEEPROM:\n\t/* look for a configuration eeprom */\n\teeprom_i2c_address = locate_eeprom_address( bktr );\n\tif (eeprom_i2c_address != -1) {\n\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t} else {\n\t    bktr->card.eepromAddr = 0;\n\t    bktr->card.eepromSize = 0;\n\t}\n\n\ncheckTuner:\n\n\t/* look for a tuner */\n\ttuner_i2c_address = locate_tuner_address( bktr );\n\tif ( tuner_i2c_address == -1 ) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n#if defined( OVERRIDE_TUNER )\n\tbktr->card.tuner = &tuners[ OVERRIDE_TUNER ];\n\tgoto checkDBX;\n#endif\n\tif (bktr->bt848_tuner != -1 ) {\n\t  bktr->card.tuner = &tuners[ bktr->bt848_tuner & 0xff ];\n\t  goto checkDBX;\n\t}\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n\t/* differentiate type of tuner */\n\n\tswitch (card) {\n\tcase CARD_MIRO:\n\t    switch (((bt848->gpio_data >> 10)-1)&7) {\n\t    case 0: bktr->card.tuner = &tuners[ TEMIC_PAL ]; break;\n\t    case 1: bktr->card.tuner = &tuners[ PHILIPS_PAL ]; break;\n\t    case 2: bktr->card.tuner = &tuners[ PHILIPS_NTSC ]; break;\n\t    case 3: bktr->card.tuner = &tuners[ PHILIPS_SECAM ]; break;\n\t    case 4: bktr->card.tuner = &tuners[ NO_TUNER ]; break;\n\t    case 5: bktr->card.tuner = &tuners[ PHILIPS_PALI ]; break;\n\t    case 6: bktr->card.tuner = &tuners[ TEMIC_NTSC ]; break;\n\t    case 7: bktr->card.tuner = &tuners[ TEMIC_PALI ]; break;\n\t    }\n\t    goto checkDBX;\n\t    break;\n\n\tcase CARD_HAUPPAUGE:\n\t    /* Hauppauge kindly supplied the following Tuner Table */\n\t    /* FIXME: I think the tuners the driver selects for types */\n\t    /* 0x08 and 0x15 may be incorrect but no one has complained. */\n\t    /*\n   \t    \tID Tuner Model          Format         \tWe select Format\n\t   \t 0 NONE               \n\t\t 1 EXTERNAL             \n\t\t 2 OTHER                \n\t\t 3 Philips FI1216       BG \n\t\t 4 Philips FI1216MF     BGLL' \n\t\t 5 Philips FI1236       MN \t\tPHILIPS_NTSC\n\t\t 6 Philips FI1246       I \n\t\t 7 Philips FI1256       DK \n\t\t 8 Philips FI1216 MK2   BG \t\tPHILIPS_PALI\n\t\t 9 Philips FI1216MF MK2 BGLL' \n\t\t a Philips FI1236 MK2   MN \t\tPHILIPS_NTSC\n\t\t b Philips FI1246 MK2   I \t\tPHILIPS_PALI\n\t\t c Philips FI1256 MK2   DK \n\t\t d Temic 4032FY5        NTSC\t\tTEMIC_NTSC\n\t\t e Temic 4002FH5        BG\t\tTEMIC_PAL\n\t\t f Temic 4062FY5        I \t\tTEMIC_PALI\n\t\t10 Philips FR1216 MK2   BG \n\t\t11 Philips FR1216MF MK2 BGLL' \n\t\t12 Philips FR1236 MK2   MN \t\tPHILIPS_FR1236_NTSC\n\t\t13 Philips FR1246 MK2   I \n\t\t14 Philips FR1256 MK2   DK \n\t\t15 Philips FM1216       BG \t\tPHILIPS_FR1216_PAL\n\t\t16 Philips FM1216MF     BGLL' \n\t\t17 Philips FM1236       MN \t\tPHILIPS_FR1236_NTSC\n\t\t18 Philips FM1246       I \n\t\t19 Philips FM1256       DK \n\t\t1a Temic 4036FY5        MN - FI1236 MK2 clone\n\t\t1b Samsung TCPN9082D    MN \n\t\t1c Samsung TCPM9092P    Pal BG/I/DK \n\t\t1d Temic 4006FH5        BG \t\tPHILIPS_PALI clone\n\t\t1e Samsung TCPN9085D    MN/Radio \n\t\t1f Samsung TCPB9085P    Pal BG/I/DK / Radio \n\t\t20 Samsung TCPL9091P    Pal BG & Secam L/L' \n\t\t21 Temic 4039FY5        NTSC Radio\n\n\t    */\n\n\t    readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\n\t    /* Determine the model number from the eeprom */\n\t    {\n\t\tu_int model;\n\t\tu_int revision;\n\t\tmodel    = (eeprom[12] << 8  | eeprom[11]);\n\t\trevision = (eeprom[15] << 16 | eeprom[14] << 8 | eeprom[13]);\n\t\tif (verbose)\n\t\t    printf(\"Hauppauge Model %d %c%c%c%c\\n\",\n\t\t\tmodel,\n\t\t\t((revision >> 18) & 0x3f) + 32,\n\t\t\t((revision >> 12) & 0x3f) + 32,\n\t\t\t((revision >>  6) & 0x3f) + 32,\n\t\t\t((revision >>  0) & 0x3f) + 32 );\n\t    }\n\n\t    /* Determine the tuner type from the eeprom */\n\t    tuner_code = eeprom[9];\n\t    switch (tuner_code) {\n\n\t       case 0x5:\n               case 0x0a:\n\t       case 0x1a:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_NTSC  ];\n\t\t goto checkDBX;\n\n               case 0x12:\n\t       case 0x17:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1236_NTSC  ];\n\t\t goto checkDBX;\n\n\t       case 0x8:\n\t       case 0xb:\n\t       case 0x1d:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_PALI ];\n\t\t goto checkDBX;\n\n\t       case 0xd:\n\t\t bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n\t\t goto checkDBX;\n\n               case 0xe:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PAL];\n\t\t goto checkDBX;\n\n\t       case 0xf:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PALI ];\n\t\t goto checkDBX;\n\n               case 0x15:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1216_PAL];\n\t\t goto checkDBX;\n\n\t       default :\n\t\t printf(\"Warning - Unknown Hauppauge Tuner 0x%x\\n\",tuner_code);\n\t    }\n\t    break;\n\n\t} /* end switch(card) */\n\n        /* At this point, a goto checkDBX has not occured */\n        /* We have not been able to select a Tuner */\n        /* Some cards make use of the tuner address to */\n        /* identify the make/model of tuner */\n\n        /* At address 0xc0/0xc1 we often find a TEMIC NTSC */\n        if ( i2cRead( bktr, 0xc1 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n            goto checkDBX;\n        }\n  \n        /* At address 0xc6/0xc7 we often find a PHILIPS NTSC Tuner */\n        if ( i2cRead( bktr, 0xc7 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ PHILIPS_NTSC ];\n            goto checkDBX;\n        }\n\n        /* Address 0xc2/0xc3 is default (or common address) for several */\n\t/* tuners and we cannot tell which is which. */\n\t/* And for all other tuner i2c addresses, select the default */\n\tbktr->card.tuner = &tuners[ DEFAULT_TUNER ];\n\n\ncheckDBX:\n#if defined( OVERRIDE_DBX )\n\tbktr->card.dbx = OVERRIDE_DBX;\n\tgoto checkMSP;\n#endif\n   /* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSP;\n\t}\n\n\t/* probe for BTSC (dbx) chip */\n\tif ( i2cRead( bktr, TDA9850_RADDR ) != ABSENT )\n\t\tbktr->card.dbx = 1;\n\ncheckMSP:\n\t/* If this is a Hauppauge Bt878 card, we need to enable the\n\t * MSP 34xx audio chip. \n\t * If this is a Hauppauge Bt848 card, reset the MSP device.\n\t * The MSP reset line is wired to GPIO pin 5. On Bt878 cards a pulldown\n\t * resistor holds the device in reset until we set GPIO pin 5.\n         */\n\n\t/* Optionally skip the MSP reset. This is handy if you initialise the\n\t * MSP audio in another operating system (eg Windows) first and then\n\t * do a soft reboot.\n\t */\n\n#ifndef BKTR_NO_MSP_RESET\n\tif (card == CARD_HAUPPAUGE) {\n            bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n        }\n#endif\n\n#if defined( OVERRIDE_MSP )\n\tbktr->card.msp3400c = OVERRIDE_MSP;\n\tgoto checkMSPEnd;\n#endif\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSPEnd;\n\t}\n\n\tif ( i2cRead( bktr, MSP3400C_RADDR ) != ABSENT )\n\t\tbktr->card.msp3400c = 1;\n\ncheckMSPEnd:\n\n/* Start of Check Remote */\n        /* Check for the Hauppauge IR Remote Control */\n        /* If there is an external unit, the internal will be ignored */\n\n        bktr->remote_control = 0; /* initial value */\n\n        if (any_i2c_devices) {\n            if (i2cRead( bktr, HAUP_REMOTE_EXT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_EXT_RADDR;\n                }\n            else if (i2cRead( bktr, HAUP_REMOTE_INT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_INT_RADDR;\n                }\n\n        }\n        /* If a remote control is found, poll it 5 times to turn off the LED */\n        if (bktr->remote_control) {\n                int i;\n                for (i=0; i<5; i++)\n                        i2cRead( bktr, bktr->remote_control_addr );\n        }\n/* End of Check Remote */\n\n#if defined( BKTR_USE_PLL )\n\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\tgoto checkPLLEnd;\n#endif\n\t/* Default is to use XTALS and not PLL mode */\n\tbktr->xtal_pll_mode = BT848_USE_XTALS;\n\n\t/* Enable PLL mode for PAL/SECAM users on Hauppauge 878 cards */\n\tif ((card == CARD_HAUPPAUGE) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\n\t/* Enable PLL mode for OSPREY users */\n\tif (card == CARD_OSPREY)\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\t/* Enable PLL mode for PAL/SECAM users on FlyVideo 878 cards */\n\tif ((card == CARD_FLYVIDEO) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n#if defined( BKTR_USE_PLL )\ncheckPLLEnd:\n#endif\n\n\n\tbktr->card.tuner_pllAddr = tuner_i2c_address;\n\n\tif ( verbose ) {\n\t\tprintf( \"%s\", bktr->card.name );\n\t\tif ( bktr->card.tuner )\n\t\t\tprintf( \", %s tuner\", bktr->card.tuner->name );\n\t\tif ( bktr->card.dbx )\n\t\t\tprintf( \", dbx stereo\" );\n\t\tif ( bktr->card.msp3400c )\n\t\t\tprintf( \", msp3400c stereo\" );\n                if ( bktr->remote_control )\n                        printf( \", remote control\" );\n\t\tprintf( \".\\n\" );\n\t}\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define VENDOR_STB        0x10B4",
            "#define VENDOR_FLYVIDEO   0x1851",
            "#define VENDOR_HAUPPAUGE  0x0070",
            "#define VENDOR_AVER_MEDIA 0x1431",
            "#define ABSENT\t\t(-1)",
            "#define CARD_FLYVIDEO\t\t10",
            "#define\tCARD_OSPREY\t\t7",
            "#define\tCARD_AVER_MEDIA\t\t6",
            "#define\tCARD_INTEL\t\t4",
            "#define\tCARD_STB\t\t3",
            "#define\tCARD_HAUPPAUGE\t\t2",
            "#define\tCARD_MIRO\t\t1",
            "#define\tCARD_UNKNOWN\t\t0",
            "#define DEFAULT_TUNER\tPHILIPS_NTSC",
            "#define DEFAULT_TUNER\tPHILIPS_PALI",
            "#define PHILIPS_FR1216_PAL\t10",
            "#define PHILIPS_FR1236_NTSC     9",
            "#define PHILIPS_PALI\t\t8",
            "#define TEMIC_PALI\t\t7",
            "#define PHILIPS_SECAM\t\t6",
            "#define PHILIPS_PAL\t\t5",
            "#define PHILIPS_NTSC\t\t4",
            "#define TEMIC_PAL\t\t2",
            "#define TEMIC_NTSC\t\t1",
            "#define NO_TUNER\t\t0",
            "#define PFC8582_RADDR\t\t0xa1",
            "#define PFC8582_WADDR\t\t0xa0",
            "#define X24C01_RADDR\t\t0xaf",
            "#define X24C01_WADDR\t\t0xae",
            "#define MSP3400C_RADDR\t\t0x81",
            "#define TDA9850_RADDR\t\t0xb7",
            "#define HAUP_REMOTE_EXT_RADDR   0x35",
            "#define HAUP_REMOTE_INT_RADDR   0x31",
            "#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define VENDOR_STB        0x10B4\n#define VENDOR_FLYVIDEO   0x1851\n#define VENDOR_HAUPPAUGE  0x0070\n#define VENDOR_AVER_MEDIA 0x1431\n#define ABSENT\t\t(-1)\n#define CARD_FLYVIDEO\t\t10\n#define\tCARD_OSPREY\t\t7\n#define\tCARD_AVER_MEDIA\t\t6\n#define\tCARD_INTEL\t\t4\n#define\tCARD_STB\t\t3\n#define\tCARD_HAUPPAUGE\t\t2\n#define\tCARD_MIRO\t\t1\n#define\tCARD_UNKNOWN\t\t0\n#define DEFAULT_TUNER\tPHILIPS_NTSC\n#define DEFAULT_TUNER\tPHILIPS_PALI\n#define PHILIPS_FR1216_PAL\t10\n#define PHILIPS_FR1236_NTSC     9\n#define PHILIPS_PALI\t\t8\n#define TEMIC_PALI\t\t7\n#define PHILIPS_SECAM\t\t6\n#define PHILIPS_PAL\t\t5\n#define PHILIPS_NTSC\t\t4\n#define TEMIC_PAL\t\t2\n#define TEMIC_NTSC\t\t1\n#define NO_TUNER\t\t0\n#define PFC8582_RADDR\t\t0xa1\n#define PFC8582_WADDR\t\t0xa0\n#define X24C01_RADDR\t\t0xaf\n#define X24C01_WADDR\t\t0xae\n#define MSP3400C_RADDR\t\t0x81\n#define TDA9850_RADDR\t\t0xb7\n#define HAUP_REMOTE_EXT_RADDR   0x35\n#define HAUP_REMOTE_INT_RADDR   0x31\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n\nstatic void\nprobeCard( bktr_ptr_t bktr, int verbose )\n{\n\tint\t\tcard, i,j, card_found;\n\tint\t\tstatus;\n\tbt848_ptr_t\tbt848;\n\tu_char \t\tprobe_signature[128], *probe_temp;\n        int   \t\tany_i2c_devices;\n\tu_char \t\teeprom[256];\n\tu_char \t\ttuner_code = 0;\n\tint \t\ttuner_i2c_address = -1;\n\tint \t\teeprom_i2c_address = -1;\n\n\tbt848 = bktr->base;\n\n\t/* Select all GPIO bits as inputs */\n\tbt848->gpio_out_en = 0;\n\tif (bootverbose)\n\t    printf(\"bktr: GPIO is 0x%08x\\n\", bt848->gpio_data);\n\n#ifdef HAUPPAUGE_MSP_RESET\n\t/* Reset the MSP34xx audio chip. This resolves bootup card\n\t * detection problems with old Bt848 based Hauppauge cards with\n\t * MSP34xx stereo audio chips. This must be user enabled because\n\t * at this point the probe function does not know the card type. */\n        bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n        DELAY(2500); /* wait 2.5ms */\n        bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n        DELAY(2500); /* wait 2.5ms */\n#endif\n\n\t/* Check for the presence of i2c devices */\n        any_i2c_devices = check_for_i2c_devices( bktr );\n\n\n\t/* Check for a user specified override on the card selection */\n#if defined( OVERRIDE_CARD )\n\tbktr->card = cards[ (card = OVERRIDE_CARD) ];\n\tgoto checkEEPROM;\n#endif\n\tif (bktr->bt848_card != -1 ) {\n\t  bktr->card = cards[ (card = bktr->bt848_card) ];\n\t  goto checkEEPROM;\n\t}\n\n\n\t/* No override, so try and determine the make of the card */\n\n        /* On BT878/879 cards, read the sub-system vendor id */\n\t/* This identifies the manufacturer of the card and the model */\n\t/* In theory this can be read from PCI registers but this does not */\n\t/* appear to work on the FlyVideo 98. Hauppauge also warned that */\n\t/* the PCI registers are sometimes not loaded correctly. */\n\t/* Therefore, I will read the sub-system vendor ID from the EEPROM */\n\t/* (just like the Bt878 does during power up initialisation) */\n\n        if (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) {\n\n\t    /* Try and locate the EEPROM */\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\n                unsigned int subsystem_vendor_id; /* vendors PCI-SIG ID */\n                unsigned int subsystem_id;        /* board model number */\n\t\tunsigned int byte_252, byte_253, byte_254, byte_255;\n\n\t\tbktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\n\t        readEEProm(bktr, 0, 256, (u_char *) &eeprom );\n                byte_252 = (unsigned int)eeprom[252];\n                byte_253 = (unsigned int)eeprom[253];\n                byte_254 = (unsigned int)eeprom[254];\n                byte_255 = (unsigned int)eeprom[255];\n                \n                subsystem_id        = (byte_252 << 8) | byte_253;\n                subsystem_vendor_id = (byte_254 << 8) | byte_255;\n\n\t        if ( bootverbose ) \n\t            printf(\"subsystem 0x%04x 0x%04x\\n\",subsystem_vendor_id,\n\t\t                                  subsystem_id);\n\n                if (subsystem_vendor_id == VENDOR_AVER_MEDIA) {\n                    bktr->card = cards[ (card = CARD_AVER_MEDIA) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_HAUPPAUGE) {\n                    bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_FLYVIDEO) {\n                    bktr->card = cards[ (card = CARD_FLYVIDEO) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                if (subsystem_vendor_id == VENDOR_STB) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n                }\n\n                /* Vendor is unknown. We will use the standard probe code */\n\t\t/* which may not give best results */\n                printf(\"Warning - card vendor 0x%04x (model 0x%04x) unknown. This may cause poor performance\\n\",subsystem_vendor_id,subsystem_id);\n            }\n\t    else\n\t    {\n                printf(\"Warning - card has no configuration EEPROM. Cannot determine card make. This may cause poor performance\\n\");\n\t    }\n\t} /* end of bt878/bt879 card detection code */\n\n\t/* If we get to this point, we must have a Bt848/848A/849A card */\n\t/* or a Bt878/879 with an unknown subsystem vendor id */\n        /* Try and determine the make of card by clever i2c probing */\n\n   \t/* Check for i2c devices. If none, move on */\n\tif (!any_i2c_devices) {\n\t\tbktr->card = cards[ (card = CARD_INTEL) ];\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t\tgoto checkTuner;\n\t}\n\n\n        /* Look for Hauppauge, STB and Osprey cards by the presence */\n\t/* of an EEPROM */\n        /* Note: Bt878 based cards also use EEPROMs so we can only do this */\n        /* test on BT848/848A and 849A based cards. */\n\tif ((bktr->id==BROOKTREE_848)  ||\n\t    (bktr->id==BROOKTREE_848A) ||\n\t    (bktr->id==BROOKTREE_849A)) {\n\n            /* At i2c address 0xa0, look for Hauppauge and Osprey cards */\n            if ( (status = i2cRead( bktr, PFC8582_RADDR )) != ABSENT ) {\n\n\t\t    /* Read the eeprom contents */\n\t\t    bktr->card = cards[ (card = CARD_UNKNOWN) ];\n\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t            readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\t\t    /* For Hauppauge, check the EEPROM begins with 0x84 */\n\t\t    if (eeprom[0] == 0x84) {\n                            bktr->card = cards[ (card = CARD_HAUPPAUGE) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\n\t\t    /* For Osprey, check the EEPROM begins with \"MMAC\" */\n\t\t    if (  (eeprom[0] == 'M') &&(eeprom[1] == 'M')\n\t\t\t&&(eeprom[2] == 'A') &&(eeprom[3] == 'C')) {\n                            bktr->card = cards[ (card = CARD_OSPREY) ];\n\t\t\t    bktr->card.eepromAddr = PFC8582_WADDR;\n\t\t\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n                            goto checkTuner;\n\t\t    }\n\t\t    printf(\"Warning: Unknown card type. EEPROM data not recognised\\n\");\n\t\t    printf(\"%x %x %x %x\\n\",eeprom[0],eeprom[1],eeprom[2],eeprom[3]);\n            }\n\n            /* look for an STB card */\n            if ( (status = i2cRead( bktr, X24C01_RADDR )) != ABSENT ) {\n                    bktr->card = cards[ (card = CARD_STB) ];\n\t\t    bktr->card.eepromAddr = X24C01_WADDR;\n\t\t    bktr->card.eepromSize = (u_char)(128 / EEPROMBLOCKSIZE);\n                    goto checkTuner;\n            }\n\n\t}\n\n\tsignCard( bktr, 1, 128, (u_char *)  &probe_signature );\n\n\tif (bootverbose) {\n\t  printf(\"card signature \\n\");\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    printf(\" %02x \", probe_signature[j]);\n\t  }\n\t  printf(\"\\n\\n\");\n\t}\n\tfor (i = 0;\n\t     i < (sizeof bt848_card_signature)/ sizeof (struct bt848_card_sig);\n\t     i++ ) {\n\n\t  card_found = 1;\n\t  probe_temp = (u_char *) &bt848_card_signature[i].signature;\n\n\t  for (j = 0; j < Bt848_MAX_SIGN; j++) {\n\t    if ((probe_temp[j] & 0xf) != (probe_signature[j] & 0xf)) {\n\t      card_found = 0;\n\t      break;\n\t    }\n\n\t  }\n\t  if (card_found) {\n\t    bktr->card = cards[ card = bt848_card_signature[i].card];\n\t    bktr->card.tuner = &tuners[ bt848_card_signature[i].tuner];\n\t    eeprom_i2c_address = locate_eeprom_address( bktr );\n\t    if (eeprom_i2c_address != -1) {\n\t\tbktr->card.eepromAddr = eeprom_i2c_address;\n\t\tbktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t    } else {\n\t\tbktr->card.eepromAddr = 0;\n\t\tbktr->card.eepromSize = 0;\n\t    }\n\t    goto checkDBX;\n\t  }\n\t}\n\n\t/* We do not know the card type. Default to Miro */\n\tbktr->card = cards[ (card = CARD_MIRO) ];\n\n\ncheckEEPROM:\n\t/* look for a configuration eeprom */\n\teeprom_i2c_address = locate_eeprom_address( bktr );\n\tif (eeprom_i2c_address != -1) {\n\t    bktr->card.eepromAddr = eeprom_i2c_address;\n\t    bktr->card.eepromSize = (u_char)(256 / EEPROMBLOCKSIZE);\n\t} else {\n\t    bktr->card.eepromAddr = 0;\n\t    bktr->card.eepromSize = 0;\n\t}\n\n\ncheckTuner:\n\n\t/* look for a tuner */\n\ttuner_i2c_address = locate_tuner_address( bktr );\n\tif ( tuner_i2c_address == -1 ) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n#if defined( OVERRIDE_TUNER )\n\tbktr->card.tuner = &tuners[ OVERRIDE_TUNER ];\n\tgoto checkDBX;\n#endif\n\tif (bktr->bt848_tuner != -1 ) {\n\t  bktr->card.tuner = &tuners[ bktr->bt848_tuner & 0xff ];\n\t  goto checkDBX;\n\t}\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tbktr->card.tuner = &tuners[ NO_TUNER ];\n\t\tgoto checkDBX;\n\t}\n\n\t/* differentiate type of tuner */\n\n\tswitch (card) {\n\tcase CARD_MIRO:\n\t    switch (((bt848->gpio_data >> 10)-1)&7) {\n\t    case 0: bktr->card.tuner = &tuners[ TEMIC_PAL ]; break;\n\t    case 1: bktr->card.tuner = &tuners[ PHILIPS_PAL ]; break;\n\t    case 2: bktr->card.tuner = &tuners[ PHILIPS_NTSC ]; break;\n\t    case 3: bktr->card.tuner = &tuners[ PHILIPS_SECAM ]; break;\n\t    case 4: bktr->card.tuner = &tuners[ NO_TUNER ]; break;\n\t    case 5: bktr->card.tuner = &tuners[ PHILIPS_PALI ]; break;\n\t    case 6: bktr->card.tuner = &tuners[ TEMIC_NTSC ]; break;\n\t    case 7: bktr->card.tuner = &tuners[ TEMIC_PALI ]; break;\n\t    }\n\t    goto checkDBX;\n\t    break;\n\n\tcase CARD_HAUPPAUGE:\n\t    /* Hauppauge kindly supplied the following Tuner Table */\n\t    /* FIXME: I think the tuners the driver selects for types */\n\t    /* 0x08 and 0x15 may be incorrect but no one has complained. */\n\t    /*\n   \t    \tID Tuner Model          Format         \tWe select Format\n\t   \t 0 NONE               \n\t\t 1 EXTERNAL             \n\t\t 2 OTHER                \n\t\t 3 Philips FI1216       BG \n\t\t 4 Philips FI1216MF     BGLL' \n\t\t 5 Philips FI1236       MN \t\tPHILIPS_NTSC\n\t\t 6 Philips FI1246       I \n\t\t 7 Philips FI1256       DK \n\t\t 8 Philips FI1216 MK2   BG \t\tPHILIPS_PALI\n\t\t 9 Philips FI1216MF MK2 BGLL' \n\t\t a Philips FI1236 MK2   MN \t\tPHILIPS_NTSC\n\t\t b Philips FI1246 MK2   I \t\tPHILIPS_PALI\n\t\t c Philips FI1256 MK2   DK \n\t\t d Temic 4032FY5        NTSC\t\tTEMIC_NTSC\n\t\t e Temic 4002FH5        BG\t\tTEMIC_PAL\n\t\t f Temic 4062FY5        I \t\tTEMIC_PALI\n\t\t10 Philips FR1216 MK2   BG \n\t\t11 Philips FR1216MF MK2 BGLL' \n\t\t12 Philips FR1236 MK2   MN \t\tPHILIPS_FR1236_NTSC\n\t\t13 Philips FR1246 MK2   I \n\t\t14 Philips FR1256 MK2   DK \n\t\t15 Philips FM1216       BG \t\tPHILIPS_FR1216_PAL\n\t\t16 Philips FM1216MF     BGLL' \n\t\t17 Philips FM1236       MN \t\tPHILIPS_FR1236_NTSC\n\t\t18 Philips FM1246       I \n\t\t19 Philips FM1256       DK \n\t\t1a Temic 4036FY5        MN - FI1236 MK2 clone\n\t\t1b Samsung TCPN9082D    MN \n\t\t1c Samsung TCPM9092P    Pal BG/I/DK \n\t\t1d Temic 4006FH5        BG \t\tPHILIPS_PALI clone\n\t\t1e Samsung TCPN9085D    MN/Radio \n\t\t1f Samsung TCPB9085P    Pal BG/I/DK / Radio \n\t\t20 Samsung TCPL9091P    Pal BG & Secam L/L' \n\t\t21 Temic 4039FY5        NTSC Radio\n\n\t    */\n\n\t    readEEProm(bktr, 0, 128, (u_char *) &eeprom );\n\n\n\t    /* Determine the model number from the eeprom */\n\t    {\n\t\tu_int model;\n\t\tu_int revision;\n\t\tmodel    = (eeprom[12] << 8  | eeprom[11]);\n\t\trevision = (eeprom[15] << 16 | eeprom[14] << 8 | eeprom[13]);\n\t\tif (verbose)\n\t\t    printf(\"Hauppauge Model %d %c%c%c%c\\n\",\n\t\t\tmodel,\n\t\t\t((revision >> 18) & 0x3f) + 32,\n\t\t\t((revision >> 12) & 0x3f) + 32,\n\t\t\t((revision >>  6) & 0x3f) + 32,\n\t\t\t((revision >>  0) & 0x3f) + 32 );\n\t    }\n\n\t    /* Determine the tuner type from the eeprom */\n\t    tuner_code = eeprom[9];\n\t    switch (tuner_code) {\n\n\t       case 0x5:\n               case 0x0a:\n\t       case 0x1a:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_NTSC  ];\n\t\t goto checkDBX;\n\n               case 0x12:\n\t       case 0x17:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1236_NTSC  ];\n\t\t goto checkDBX;\n\n\t       case 0x8:\n\t       case 0xb:\n\t       case 0x1d:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_PALI ];\n\t\t goto checkDBX;\n\n\t       case 0xd:\n\t\t bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n\t\t goto checkDBX;\n\n               case 0xe:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PAL];\n\t\t goto checkDBX;\n\n\t       case 0xf:\n\t\t bktr->card.tuner = &tuners[ TEMIC_PALI ];\n\t\t goto checkDBX;\n\n               case 0x15:\n\t\t bktr->card.tuner = &tuners[ PHILIPS_FR1216_PAL];\n\t\t goto checkDBX;\n\n\t       default :\n\t\t printf(\"Warning - Unknown Hauppauge Tuner 0x%x\\n\",tuner_code);\n\t    }\n\t    break;\n\n\t} /* end switch(card) */\n\n        /* At this point, a goto checkDBX has not occured */\n        /* We have not been able to select a Tuner */\n        /* Some cards make use of the tuner address to */\n        /* identify the make/model of tuner */\n\n        /* At address 0xc0/0xc1 we often find a TEMIC NTSC */\n        if ( i2cRead( bktr, 0xc1 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ TEMIC_NTSC ];\n            goto checkDBX;\n        }\n  \n        /* At address 0xc6/0xc7 we often find a PHILIPS NTSC Tuner */\n        if ( i2cRead( bktr, 0xc7 ) != ABSENT ) {\n            bktr->card.tuner = &tuners[ PHILIPS_NTSC ];\n            goto checkDBX;\n        }\n\n        /* Address 0xc2/0xc3 is default (or common address) for several */\n\t/* tuners and we cannot tell which is which. */\n\t/* And for all other tuner i2c addresses, select the default */\n\tbktr->card.tuner = &tuners[ DEFAULT_TUNER ];\n\n\ncheckDBX:\n#if defined( OVERRIDE_DBX )\n\tbktr->card.dbx = OVERRIDE_DBX;\n\tgoto checkMSP;\n#endif\n   /* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSP;\n\t}\n\n\t/* probe for BTSC (dbx) chip */\n\tif ( i2cRead( bktr, TDA9850_RADDR ) != ABSENT )\n\t\tbktr->card.dbx = 1;\n\ncheckMSP:\n\t/* If this is a Hauppauge Bt878 card, we need to enable the\n\t * MSP 34xx audio chip. \n\t * If this is a Hauppauge Bt848 card, reset the MSP device.\n\t * The MSP reset line is wired to GPIO pin 5. On Bt878 cards a pulldown\n\t * resistor holds the device in reset until we set GPIO pin 5.\n         */\n\n\t/* Optionally skip the MSP reset. This is handy if you initialise the\n\t * MSP audio in another operating system (eg Windows) first and then\n\t * do a soft reboot.\n\t */\n\n#ifndef BKTR_NO_MSP_RESET\n\tif (card == CARD_HAUPPAUGE) {\n            bt848->gpio_out_en = bt848->gpio_out_en | (1<<5);\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data & ~(1<<5); /* write '0' */\n            DELAY(2500); /* wait 2.5ms */\n            bt848->gpio_data   = bt848->gpio_data | (1<<5);  /* write '1' */\n            DELAY(2500); /* wait 2.5ms */\n        }\n#endif\n\n#if defined( OVERRIDE_MSP )\n\tbktr->card.msp3400c = OVERRIDE_MSP;\n\tgoto checkMSPEnd;\n#endif\n\n\t/* Check for i2c devices */\n\tif (!any_i2c_devices) {\n\t\tgoto checkMSPEnd;\n\t}\n\n\tif ( i2cRead( bktr, MSP3400C_RADDR ) != ABSENT )\n\t\tbktr->card.msp3400c = 1;\n\ncheckMSPEnd:\n\n/* Start of Check Remote */\n        /* Check for the Hauppauge IR Remote Control */\n        /* If there is an external unit, the internal will be ignored */\n\n        bktr->remote_control = 0; /* initial value */\n\n        if (any_i2c_devices) {\n            if (i2cRead( bktr, HAUP_REMOTE_EXT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_EXT_RADDR;\n                }\n            else if (i2cRead( bktr, HAUP_REMOTE_INT_RADDR ) != ABSENT )\n                {\n                bktr->remote_control      = 1;\n                bktr->remote_control_addr = HAUP_REMOTE_INT_RADDR;\n                }\n\n        }\n        /* If a remote control is found, poll it 5 times to turn off the LED */\n        if (bktr->remote_control) {\n                int i;\n                for (i=0; i<5; i++)\n                        i2cRead( bktr, bktr->remote_control_addr );\n        }\n/* End of Check Remote */\n\n#if defined( BKTR_USE_PLL )\n\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\tgoto checkPLLEnd;\n#endif\n\t/* Default is to use XTALS and not PLL mode */\n\tbktr->xtal_pll_mode = BT848_USE_XTALS;\n\n\t/* Enable PLL mode for PAL/SECAM users on Hauppauge 878 cards */\n\tif ((card == CARD_HAUPPAUGE) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\n\t/* Enable PLL mode for OSPREY users */\n\tif (card == CARD_OSPREY)\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n\t/* Enable PLL mode for PAL/SECAM users on FlyVideo 878 cards */\n\tif ((card == CARD_FLYVIDEO) &&\n\t   (bktr->id==BROOKTREE_878 || bktr->id==BROOKTREE_879) )\n\t\tbktr->xtal_pll_mode = BT848_USE_PLL;\n\n#if defined( BKTR_USE_PLL )\ncheckPLLEnd:\n#endif\n\n\n\tbktr->card.tuner_pllAddr = tuner_i2c_address;\n\n\tif ( verbose ) {\n\t\tprintf( \"%s\", bktr->card.name );\n\t\tif ( bktr->card.tuner )\n\t\t\tprintf( \", %s tuner\", bktr->card.tuner->name );\n\t\tif ( bktr->card.dbx )\n\t\t\tprintf( \", dbx stereo\" );\n\t\tif ( bktr->card.msp3400c )\n\t\t\tprintf( \", msp3400c stereo\" );\n                if ( bktr->remote_control )\n                        printf( \", remote control\" );\n\t\tprintf( \".\\n\" );\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "oformat_meteor_to_bt",
          "args": [
            "bktr->format"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "oformat_meteor_to_bt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "4651-4680",
          "snippet": "static int oformat_meteor_to_bt( u_long format )\n{\n\tint    i;\n        struct meteor_pixfmt *pf1, *pf2;\n\n\t/*  Find format in compatibility table  */\n\tfor ( i = 0; i < METEOR_PIXFMT_TABLE_SIZE; i++ )\n\t\tif ( meteor_pixfmt_table[i].meteor_format == format )\n\t\t\tbreak;\n\n\tif ( i >= METEOR_PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\tpf1 = &meteor_pixfmt_table[i].public;\n\n\t/*  Match it with an entry in master pixel format table  */\n\tfor ( i = 0; i < PIXFMT_TABLE_SIZE; i++ ) {\n\t\tpf2 = &pixfmt_table[i].public;\n\n\t\tif (( pf1->type        == pf2->type        ) &&\n\t\t    ( pf1->Bpp         == pf2->Bpp         ) &&\n\t\t    !bcmp( pf1->masks, pf2->masks, sizeof( pf1->masks )) &&\n\t\t    ( pf1->swap_bytes  == pf2->swap_bytes  ) &&\n\t\t    ( pf1->swap_shorts == pf2->swap_shorts )) \n\t\t\tbreak;\n\t}\n\tif ( i >= PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\n\treturn i;\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [
            "#define METEOR_PIXFMT_TABLE_SIZE ( sizeof(meteor_pixfmt_table) / \\\n\t\t\t\t   sizeof(meteor_pixfmt_table[0]) )",
            "#define PIXFMT_TABLE_SIZE ( sizeof(pixfmt_table) / sizeof(pixfmt_table[0]) )"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define METEOR_PIXFMT_TABLE_SIZE ( sizeof(meteor_pixfmt_table) / \\\n\t\t\t\t   sizeof(meteor_pixfmt_table[0]) )\n#define PIXFMT_TABLE_SIZE ( sizeof(pixfmt_table) / sizeof(pixfmt_table[0]) )\n\nstatic int oformat_meteor_to_bt( u_long format )\n{\n\tint    i;\n        struct meteor_pixfmt *pf1, *pf2;\n\n\t/*  Find format in compatibility table  */\n\tfor ( i = 0; i < METEOR_PIXFMT_TABLE_SIZE; i++ )\n\t\tif ( meteor_pixfmt_table[i].meteor_format == format )\n\t\t\tbreak;\n\n\tif ( i >= METEOR_PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\tpf1 = &meteor_pixfmt_table[i].public;\n\n\t/*  Match it with an entry in master pixel format table  */\n\tfor ( i = 0; i < PIXFMT_TABLE_SIZE; i++ ) {\n\t\tpf2 = &pixfmt_table[i].public;\n\n\t\tif (( pf1->type        == pf2->type        ) &&\n\t\t    ( pf1->Bpp         == pf2->Bpp         ) &&\n\t\t    !bcmp( pf1->masks, pf2->masks, sizeof( pf1->masks )) &&\n\t\t    ( pf1->swap_bytes  == pf2->swap_bytes  ) &&\n\t\t    ( pf1->swap_shorts == pf2->swap_shorts )) \n\t\t\tbreak;\n\t}\n\tif ( i >= PIXFMT_TABLE_SIZE )\n\t\treturn -1;\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t) bktr->bigbuf",
            "BROOKTREE_ALLOC"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bktr%d: buffer size %d, addr 0x%x\\n\"",
            "unit",
            "BROOKTREE_ALLOC",
            "vtophys(buf)"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "buf"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bktr_mem",
          "args": [
            "unit",
            "BROOKTREE_ALLOC"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "get_bktr_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/brooktree848.c",
          "lines": "7942-7957",
          "snippet": "static vm_offset_t\nget_bktr_mem( int unit, unsigned size )\n{\n\tvm_offset_t\taddr = 0;\n\n\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff, 1<<24);\n\tif (addr == 0)\n\t\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff,\n\t\t\t\t\t\t\t\tPAGE_SIZE);\n\tif (addr == 0) {\n\t\tprintf(\"bktr%d: Unable to allocate %d bytes of memory.\\n\",\n\t\t\tunit, size);\n\t}\n\n\treturn( addr );\n}",
          "includes": [
            "#include <dev/pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/reboot.h>",
            "#include \"brktree_reg.h\"",
            "#include \"ioctl_bt848.h\"",
            "#include \"ioctl_meteor.h\"",
            "#include <i386/eisa/eisa.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/isa.h>",
            "#include <sys/device.h>",
            "#include <sys/sysctl.h>",
            "#include \"iicbus_if.h\"",
            "#include \"smbus_if.h\"",
            "#include <dev/iicbus/iiconf.h>",
            "#include <dev/smbus/smbconf.h>",
            "#include <pci/bt848_i2c.h>",
            "#include <pci/brktree_reg.h>",
            "#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */",
            "#include <machine/ioctl_meteor.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>      /* for DELAY */",
            "#include <machine/resource.h>\t/* used by newbus */",
            "#include <sys/rman.h>\t\t/* used by newbus */",
            "#include <machine/bus.h>\t/* used by newbus */",
            "#include <sys/bus.h>\t\t/* used by smbus and newbus */",
            "#include <sys/devfsext.h>",
            "#include \"smbus.h\"",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm.h>",
            "#include <sys/mman.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/uio.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bktr.h\"",
            "#include \"opt_devfs.h\"",
            "#include \"opt_bktr.h\"",
            "#include \"bktr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\nstatic vm_offset_t\nget_bktr_mem( int unit, unsigned size )\n{\n\tvm_offset_t\taddr = 0;\n\n\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff, 1<<24);\n\tif (addr == 0)\n\t\taddr = vm_page_alloc_contig(size, 0x100000, 0xffffffff,\n\t\t\t\t\t\t\t\tPAGE_SIZE);\n\tif (addr == 0) {\n\t\tprintf(\"bktr%d: Unable to allocate %d bytes of memory.\\n\",\n\t\t\tunit, size);\n\t}\n\n\treturn( addr );\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>        /* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <machine/bus.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/reboot.h>\n#include \"brktree_reg.h\"\n#include \"ioctl_bt848.h\"\n#include \"ioctl_meteor.h\"\n#include <i386/eisa/eisa.h>\n#include <i386/isa/dma.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/isa.h>\n#include <sys/device.h>\n#include <sys/sysctl.h>\n#include \"iicbus_if.h\"\n#include \"smbus_if.h\"\n#include <dev/iicbus/iiconf.h>\n#include <dev/smbus/smbconf.h>\n#include <pci/bt848_i2c.h>\n#include <pci/brktree_reg.h>\n#include <machine/ioctl_bt848.h>\t/* extensions to ioctl_meteor.h */\n#include <machine/ioctl_meteor.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>      /* for DELAY */\n#include <machine/resource.h>\t/* used by newbus */\n#include <sys/rman.h>\t\t/* used by newbus */\n#include <machine/bus.h>\t/* used by newbus */\n#include <sys/bus.h>\t\t/* used by smbus and newbus */\n#include <sys/devfsext.h>\n#include \"smbus.h\"\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm.h>\n#include <sys/mman.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/uio.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bktr.h\"\n#include \"opt_devfs.h\"\n#include \"opt_bktr.h\"\n#include \"bktr.h\"\n\n#define DEFAULT_CHNLSET\tCHNLSET_WEUROPE\n#define VBI_BUFFER_SIZE       (VBI_DATA_SIZE * VBI_BUFFER_ITEMS)\n#define VBI_DATA_SIZE         (VBI_LINE_SIZE * MAX_VBI_LINES * 2)\n#define BROOKTREE_ALLOC\t\t(BROOKTREE_ALLOC_PAGES * PAGE_SIZE)\n#define BROOKTREE_ALLOC_PAGES\t217*4\n#define DMA_PROG_ALLOC\t\t(8 * PAGE_SIZE)\n#define bootverbose (autoprint & (AC_VERBOSE|AC_DEBUG))\n\nstatic void \ncommon_bktr_attach( bktr_ptr_t bktr, int unit, u_long pci_id, u_int rev )\n{\n\tbt848_ptr_t\tbt848;\n\tvm_offset_t\tbuf;\n\n\tbt848 = bktr->base;\n\n/***************************************/\n/* *** OS Specific memory routines *** */\n/***************************************/\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n        /* allocate space for dma program */\n        bktr->dma_prog = get_bktr_mem(bktr, &bktr->dm_prog, DMA_PROG_ALLOC);\n        bktr->odd_dma_prog = get_bktr_mem(bktr, &bktr->dm_oprog, DMA_PROG_ALLOC)\n;\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(bktr, &bktr->dm_vbidata, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(bktr, &bktr->dm_vbibuffer, VBI_BUFFER_SIZE);\n\n        /* allocate space for pixel buffer */\n        if ( BROOKTREE_ALLOC )\n                buf = get_bktr_mem(bktr, &bktr->dm_mem, BROOKTREE_ALLOC);\n        else\n                buf = 0;\n#endif\n\n#if defined(__FreeBSD__) || defined(__bsdi__)\n\t/* allocate space for dma program */\n\tbktr->dma_prog     = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\tbktr->odd_dma_prog = get_bktr_mem(unit, DMA_PROG_ALLOC);\n\n\t/* allocte space for the VBI buffer */\n\tbktr->vbidata  = get_bktr_mem(unit, VBI_DATA_SIZE);\n\tbktr->vbibuffer = get_bktr_mem(unit, VBI_BUFFER_SIZE);\n\n\t/* allocate space for pixel buffer */\n\tif ( BROOKTREE_ALLOC )\n\t\tbuf = get_bktr_mem(unit, BROOKTREE_ALLOC);\n\telse\n\t\tbuf = 0;\n#endif\n\n\tif ( bootverbose ) {\n\t\tprintf(\"bktr%d: buffer size %d, addr 0x%x\\n\",\n\t\t\tunit, BROOKTREE_ALLOC, vtophys(buf));\n\t}\n\n\tif ( buf != 0 ) {\n\t\tbktr->bigbuf = buf;\n\t\tbktr->alloc_pages = BROOKTREE_ALLOC_PAGES;\n\t\tbzero((caddr_t) bktr->bigbuf, BROOKTREE_ALLOC);\n\t} else {\n\t\tbktr->alloc_pages = 0;\n\t}\n\t\t\n\n\tbktr->flags = METEOR_INITALIZED | METEOR_AUTOMODE |\n\t\t      METEOR_DEV0 | METEOR_RGB16;\n\tbktr->dma_prog_loaded = FALSE;\n\tbktr->cols = 640;\n\tbktr->rows = 480;\n\tbktr->frames = 1;\t\t/* one frame */\n\tbktr->format = METEOR_GEO_RGB16;\n\tbktr->pixfmt = oformat_meteor_to_bt( bktr->format );\n\tbktr->pixfmt_compat = TRUE;\n\n\n\tbktr->vbiinsert = 0;\n\tbktr->vbistart = 0;\n\tbktr->vbisize = 0;\n\tbktr->vbiflags = 0;\n\n \n\t/* using the pci device id and revision id */\n\t/* and determine the card type            */\n\tswitch (pci_id) {\n\tcase BROOKTREE_848_PCI_ID:\n\t\tif (rev == 0x12) bktr->id = BROOKTREE_848A;\n\t\telse             bktr->id = BROOKTREE_848;\n\t\tbreak;\n        case BROOKTREE_849_PCI_ID:\n\t\tbktr->id = BROOKTREE_849A;\n\t\tbreak;\n        case BROOKTREE_878_PCI_ID:\n\t\tbktr->id = BROOKTREE_878;\n\t\tbreak;\n        case BROOKTREE_879_PCI_ID:\n\t\tbktr->id = BROOKTREE_879;\n\t\tbreak;\n\t};\n\n\tbktr->clr_on_start = FALSE;\n\n\t/* defaults for the tuner section of the card */\n\tbktr->tflags = TUNER_INITALIZED;\n\tbktr->tuner.frequency = 0;\n\tbktr->tuner.channel = 0;\n\tbktr->tuner.chnlset = DEFAULT_CHNLSET;\n\tbktr->audio_mux_select = 0;\n\tbktr->audio_mute_state = FALSE;\n\tbktr->bt848_card = -1;\n\tbktr->bt848_tuner = -1;\n\tbktr->reverse_mute = -1;\n\n\tprobeCard( bktr, TRUE );\n\n\t/* If there is an MSP Audio device, reset it and display the model */\n\tif (bktr->card.msp3400c)msp_reset(bktr);\n\tif (bktr->card.msp3400c)msp_read_id(bktr);\n\n}"
  }
]