[
  {
    "function_name": "sea_information_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "1231-1446",
    "snippet": "void\nsea_information_transfer(sea)\n\tstruct sea_softc *sea;\n{\n\tint timeout;\n\tu_char msgout = MSG_NOOP;\n\tint len;\n\tint s;\n\tu_char *data;\n\tu_char phase, tmp, old_phase = PH_INVALID;\n\tstruct sea_scb *scb = sea->nexus;\n\tint loop;\n\n\tfor (timeout = 0; timeout < 10000000L; timeout++) {\n\t\ttmp = STATUS;\n\t\tif (tmp & STAT_PARITY)\n\t\t\tprintf(\"%s: parity error detected\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\tif (!(tmp & STAT_BSY)) {\n\t\t\tfor (loop = 0; loop < 20; loop++)\n\t\t\t\tif ((tmp = STATUS) & STAT_BSY)\n\t\t\t\t\tbreak;\n\t\t\tif (!(tmp & STAT_BSY)) {\n\t\t\t\tprintf(\"%s: !STAT_BSY unit in data transfer!\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\ts = splbio();\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tscb->flags = SCB_ERROR;\n\t\t\t\tsplx(s);\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* we only have a valid SCSI phase when REQ is asserted */\n\t\tif (!(tmp & STAT_REQ))\n\t\t\tcontinue;\n\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tphase = tmp & PH_MASK;\n\t\tif (phase != old_phase)\n\t\t\told_phase = phase;\n\n\t\tswitch (phase) {\n\t\tcase PH_DATAOUT:\n#ifdef SEA_NODATAOUT\n\t\t\tprintf(\"%s: SEA_NODATAOUT set, attempted DATAOUT aborted\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tmsgout = MSG_ABORT;\n\t\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\t\tbreak;\n#endif\n\t\tcase PH_DATAIN:\n\t\t\tif (!scb->data)\n\t\t\t\tprintf(\"no data address!\\n\");\n#ifdef SEA_BLINDTRANSFER\n\t\t\tif (scb->datalen && !(scb->datalen % BLOCK_SIZE)) {\n\t\t\t\twhile (scb->datalen) {\n\t\t\t\t\tfor (loop = 0; loop < 50000; loop++)\n\t\t\t\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!(tmp & STAT_REQ)) {\n\t\t\t\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\t\t\t/* XXX Do something? */\n\t\t\t\t\t}\n\t\t\t\t\tif (sea->type == FDOMAIN840)\n\t\t\t\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t\t\t\t       (tmp & 0xf5);\n\t\t\t\t\tif ((tmp & PH_MASK) != phase)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!(phase & STAT_IO)) {\n\t\t\t\t\t\tint block = BLOCK_SIZE; \n\t\t\t\t\t\tvoid *a = sea->maddr_dr;\n#ifdef SEA_ASSEMBLER\n\t\t\t\t\t\tasm(\"shr $2, %%ecx\\n\\t\\\n\t\t\t\t\t\t    cld\\n\\t\\\n\t\t\t\t\t\t    rep\\n\\t\\\n\t\t\t\t\t\t    movsl\" :\n\t\t\t\t\t\t    \"=S\" (scb->data), \n\t\t\t\t\t\t\t\"=c\" (block) ,\n\t\t\t\t\t\t    \"=D\" (a) :\n\t\t\t\t\t\t    \"0\" (scb->data),\n\t\t\t\t\t\t    \"2\" (a),\n\t\t\t\t\t\t    \"1\" (block) );\n#else\n\t\t\t\t\t\tfor (count = 0;\n\t\t\t\t\t\t    count < BLOCK_SIZE;\n\t\t\t\t\t\t    count++)\n\t\t\t\t\t\t\tDATA = *(scb->data++);\n#endif\n\t\t\t\t\t} else { \n\t\t\t\t\t\tint block = BLOCK_SIZE;\n\t\t\t\t\t\tvoid *a = sea->maddr_dr;\n#ifdef SEA_ASSEMBLER\n\t\t\t\t\t\tasm(\"shr $2, %%ecx\\n\\t\\\n\t\t\t\t\t\t    cld\\n\\t\\\n\t\t\t\t\t\t    rep\\n\\t\\\n\t\t\t\t\t\t    movsl\" :\n\t\t\t\t\t\t    \"=D\" (scb->data), \"=c\" (block) ,\n\t\t\t\t\t\t    \"=S\" (a) :\n\t\t\t\t\t\t    \"0\" (scb->data),\n\t\t\t\t\t\t\t\"2\" (a) ,\n\t\t\t\t\t\t    \"1\" (block) );\n#else\n\t\t\t\t\t        for (count = 0;\n\t\t\t\t\t\t    count < BLOCK_SIZE;\n\t\t\t\t\t\t    count++)\n\t\t\t\t\t\t\t*(scb->data++) = DATA;\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tscb->datalen -= BLOCK_SIZE;\n\t\t\t\t}\n\t\t\t}\n#endif \n\t\t\tif (scb->datalen)\n\t\t\t\tsea_transfer_pio(sea, &phase, &scb->datalen,\n\t\t\t\t    &scb->data);\n\t\t\tbreak;\n\t\tcase PH_MSGIN:\n\t\t\t/* Multibyte messages should not be present here. */\n\t\t\tlen = 1;\n\t\t\tdata = &tmp;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\t/* scb->MessageIn = tmp; */\n\n\t\t\tswitch (tmp) {\n\t\t\tcase MSG_ABORT:\n\t\t\t\tscb->flags = SCB_ABORTED;\n\t\t\t\tprintf(\"sea: command aborted by target\\n\");\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\tcase MSG_CMDCOMPLETE:\n\t\t\t\ts = splbio();\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tsplx(s);\n\t\t\t\tsea->busy[scb->xs->sc_link->target] &= \n\t\t\t\t    ~(1 << scb->xs->sc_link->lun);\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\tcase MSG_MESSAGE_REJECT:\n\t\t\t\tprintf(\"%s: message_reject recieved\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\tbreak;\n\t\t\tcase MSG_DISCONNECT:\n\t\t\t\ts = splbio();\n\t\t\t\tTAILQ_INSERT_TAIL(&sea->nexus_list,\n\t\t\t\t    scb, chain);\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsplx(s);\n\t\t\t\treturn;\n\t\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tcase MSG_RESTOREPOINTERS:\n\t\t\t\t/* save/restore of pointers are ignored */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * This should be handled in the pio data\n\t\t\t\t * transfer phase, as the ATN should be raised\n\t\t\t\t * before ACK goes false when rejecting a\n\t\t\t\t * message.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: unknown message in: %x\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname, tmp);\n\t\t\t\tbreak;\n\t\t\t} /* switch (tmp) */\n\t\t\tbreak;\n\t\tcase PH_MSGOUT:\n\t\t\tlen = 1;\n\t\t\tdata = &msgout;\n\t\t\t/* sea->last_message = msgout; */\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tif (msgout == MSG_ABORT) {\n\t\t\t\tprintf(\"%s: sent message abort to target\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\ts = splbio();\n\t\t\t\tsea->busy[scb->xs->sc_link->target] &= \n\t\t\t\t    ~(1 << scb->xs->sc_link->lun);\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tscb->flags = SCB_ABORTED;\n\t\t\t\tsplx(s); \n\t\t\t\t/* enable interrupt from scsi */\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmsgout = MSG_NOOP;\n\t\t\tbreak;\n\t\tcase PH_CMD:\n\t\t\tlen = scb->xs->cmdlen;\n\t\t\tdata = (char *) scb->xs->cmd;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tbreak;\n\t\tcase PH_STAT:\n\t\t\tlen = 1;\n\t\t\tdata = &tmp;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tscb->xs->status = tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"sea: unknown phase\\n\");\n\t\t} /* switch (phase) */\n\t} /* for (...) */\n\n\t/* If we get here we have got a timeout! */\n\tprintf(\"%s: timeout in data transfer\\n\", sea->sc_dev.dv_xname);\n\tscb->flags = SCB_TIMEOUT;\n\t/* XXX Should I clear scsi-bus state? */\n\tsea_done(sea, scb);\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
      "#define CONTROL\tSTATUS",
      "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
      "#define SCB_ERROR\t8",
      "#define SCB_TIMEOUT\t4",
      "#define SCB_ABORTED\t2",
      "#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */",
      "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
      "#define PH_INVALID\t0xff",
      "#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)",
      "#define PH_MSGIN\t(STAT_MSG | STAT_CD | STAT_IO)",
      "#define PH_MSGOUT\t(STAT_MSG | STAT_CD)",
      "#define PH_STAT\t\t(STAT_CD | STAT_IO)",
      "#define PH_CMD\t\t(STAT_CD)",
      "#define PH_DATAIN\t(STAT_IO)",
      "#define PH_DATAOUT\t(0)",
      "#define STAT_PARITY\t0x40\t\t/* parity error bit */",
      "#define STAT_REQ\t0x10\t\t/* scsi req */",
      "#define STAT_IO\t\t0x04\t\t/* scsi I/O */",
      "#define STAT_BSY\t0x01\t\t/* scsi busy */",
      "#define\tCMD_ATTN\t0x08\t\t/* scsi attention */",
      "#define\tSEA_ASSEMBLER\t\t/* Use assembly code for fast transfers */",
      "#define\tSEA_BLINDTRANSFER\t/* do blind transfers */",
      "#define BLOCK_SIZE\t512\t/* size of READ/WRITE areas on SCSI card */"
    ],
    "globals_used": [
      "void sea_done",
      "static void sea_information_transfer",
      "int sea_transfer_pio",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sea_done",
          "args": [
            "sea",
            "scb"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "sea_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "1177-1200",
          "snippet": "void\nsea_done(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\n\tuntimeout(sea_timeout, scb);\n\n\txs->resid = scb->datalen;\n\n\t/* XXXX need to get status */\n\tif (scb->flags == SCB_ACTIVE) {\n\t\txs->resid = 0;\n\t} else {\n\t\tif (scb->flags & (SCB_TIMEOUT | SCB_ABORTED))\n\t\t\txs->error = XS_TIMEOUT;\n\t\tif (scb->flags & SCB_ERROR)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t}\n\txs->flags |= ITSDONE;\n\tsea_free_scb(sea, scb, xs->flags);\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SCB_ERROR\t8",
            "#define SCB_TIMEOUT\t4",
            "#define SCB_ABORTED\t2",
            "#define\tSCB_ACTIVE\t1"
          ],
          "globals_used": [
            "void sea_timeout",
            "void sea_done",
            "void sea_free_scb",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define SCB_ERROR\t8\n#define SCB_TIMEOUT\t4\n#define SCB_ABORTED\t2\n#define\tSCB_ACTIVE\t1\n\nvoid sea_timeout;\nvoid sea_done;\nvoid sea_free_scb;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nvoid\nsea_done(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\n\tuntimeout(sea_timeout, scb);\n\n\txs->resid = scb->datalen;\n\n\t/* XXXX need to get status */\n\tif (scb->flags == SCB_ACTIVE) {\n\t\txs->resid = 0;\n\t} else {\n\t\tif (scb->flags & (SCB_TIMEOUT | SCB_ABORTED))\n\t\t\txs->error = XS_TIMEOUT;\n\t\tif (scb->flags & SCB_ERROR)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t}\n\txs->flags |= ITSDONE;\n\tsea_free_scb(sea, scb, xs->flags);\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: timeout in data transfer\\n\"",
            "sea->sc_dev.dv_xname"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sea_transfer_pio",
          "args": [
            "sea",
            "&phase",
            "&len",
            "&data"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "sea_transfer_pio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "934-1012",
          "snippet": "int\nsea_transfer_pio(sea, phase, count, data)\n\tstruct sea_softc *sea;\n\tu_char *phase;\n\tint *count;\n\tu_char **data;\n{\n\tregister u_char p = *phase, tmp;\n\tregister int c = *count;\n\tregister u_char *d = *data;\n\tint timeout;\n\n\tdo {\n\t\t/*\n\t\t * Wait for assertion of REQ, after which the phase bits will\n\t\t * be valid.\n\t\t */\n\t\tfor (timeout = 0; timeout < 50000; timeout++)\n\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\tbreak;\n\t\tif (!(tmp & STAT_REQ)) {\n\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check for phase mismatch.  Reached if the target decides\n\t\t * that it has finished the transfer.\n\t\t */\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tif ((tmp & PH_MASK) != p)\n\t\t\tbreak;\n\n\t\t/* Do actual transfer from SCSI bus to/from memory. */\n\t\tif (!(p & STAT_IO))\n\t\t\tDATA = *d;\n\t\telse\n\t\t\t*d = DATA;\n\t\t++d;\n\n\t\t/*\n\t\t * The SCSI standard suggests that in MSGOUT phase, the\n\t\t * initiator should drop ATN on the last byte of the message\n\t\t * phase after REQ has been asserted for the handshake but\n\t\t * before the initiator raises ACK.\n\t\t * Don't know how to accomplish this on the ST01/02.\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * XXX\n\t\t * The st01 code doesn't wait for STAT_REQ to be deasserted.\n\t\t * Is this ok?\n\t\t */\n\t\tfor (timeout = 0; timeout < 200000L; timeout++)\n\t\t\tif (!(STATUS & STAT_REQ))\n\t\t\t\tbreak;\n\t\tif (STATUS & STAT_REQ)\n\t\t\tprintf(\"%s: timeout on wait for !STAT_REQ\",\n\t\t\t    sea->sc_dev.dv_xname);\n#endif\n\t} while (--c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = STATUS;\n\tif (tmp & STAT_REQ)\n\t\t*phase = tmp & PH_MASK;\n\telse\n\t\t*phase = PH_INVALID;\n\n\tif (c && (*phase != p))\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */",
            "#define PH_INVALID\t0xff",
            "#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)",
            "#define STAT_REQ\t0x10\t\t/* scsi req */",
            "#define STAT_IO\t\t0x04\t\t/* scsi I/O */"
          ],
          "globals_used": [
            "int sea_transfer_pio",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */\n#define PH_INVALID\t0xff\n#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nint\nsea_transfer_pio(sea, phase, count, data)\n\tstruct sea_softc *sea;\n\tu_char *phase;\n\tint *count;\n\tu_char **data;\n{\n\tregister u_char p = *phase, tmp;\n\tregister int c = *count;\n\tregister u_char *d = *data;\n\tint timeout;\n\n\tdo {\n\t\t/*\n\t\t * Wait for assertion of REQ, after which the phase bits will\n\t\t * be valid.\n\t\t */\n\t\tfor (timeout = 0; timeout < 50000; timeout++)\n\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\tbreak;\n\t\tif (!(tmp & STAT_REQ)) {\n\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check for phase mismatch.  Reached if the target decides\n\t\t * that it has finished the transfer.\n\t\t */\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tif ((tmp & PH_MASK) != p)\n\t\t\tbreak;\n\n\t\t/* Do actual transfer from SCSI bus to/from memory. */\n\t\tif (!(p & STAT_IO))\n\t\t\tDATA = *d;\n\t\telse\n\t\t\t*d = DATA;\n\t\t++d;\n\n\t\t/*\n\t\t * The SCSI standard suggests that in MSGOUT phase, the\n\t\t * initiator should drop ATN on the last byte of the message\n\t\t * phase after REQ has been asserted for the handshake but\n\t\t * before the initiator raises ACK.\n\t\t * Don't know how to accomplish this on the ST01/02.\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * XXX\n\t\t * The st01 code doesn't wait for STAT_REQ to be deasserted.\n\t\t * Is this ok?\n\t\t */\n\t\tfor (timeout = 0; timeout < 200000L; timeout++)\n\t\t\tif (!(STATUS & STAT_REQ))\n\t\t\t\tbreak;\n\t\tif (STATUS & STAT_REQ)\n\t\t\tprintf(\"%s: timeout on wait for !STAT_REQ\",\n\t\t\t    sea->sc_dev.dv_xname);\n#endif\n\t} while (--c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = STATUS;\n\tif (tmp & STAT_REQ)\n\t\t*phase = tmp & PH_MASK;\n\telse\n\t\t*phase = PH_INVALID;\n\n\tif (c && (*phase != p))\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sea->nexus_list",
            "scb",
            "chain"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define CONTROL\tSTATUS\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define SCB_ERROR\t8\n#define SCB_TIMEOUT\t4\n#define SCB_ABORTED\t2\n#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define PH_INVALID\t0xff\n#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)\n#define PH_MSGIN\t(STAT_MSG | STAT_CD | STAT_IO)\n#define PH_MSGOUT\t(STAT_MSG | STAT_CD)\n#define PH_STAT\t\t(STAT_CD | STAT_IO)\n#define PH_CMD\t\t(STAT_CD)\n#define PH_DATAIN\t(STAT_IO)\n#define PH_DATAOUT\t(0)\n#define STAT_PARITY\t0x40\t\t/* parity error bit */\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n#define STAT_BSY\t0x01\t\t/* scsi busy */\n#define\tCMD_ATTN\t0x08\t\t/* scsi attention */\n#define\tSEA_ASSEMBLER\t\t/* Use assembly code for fast transfers */\n#define\tSEA_BLINDTRANSFER\t/* do blind transfers */\n#define BLOCK_SIZE\t512\t/* size of READ/WRITE areas on SCSI card */\n\nvoid sea_done;\nstatic void sea_information_transfer;\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nvoid\nsea_information_transfer(sea)\n\tstruct sea_softc *sea;\n{\n\tint timeout;\n\tu_char msgout = MSG_NOOP;\n\tint len;\n\tint s;\n\tu_char *data;\n\tu_char phase, tmp, old_phase = PH_INVALID;\n\tstruct sea_scb *scb = sea->nexus;\n\tint loop;\n\n\tfor (timeout = 0; timeout < 10000000L; timeout++) {\n\t\ttmp = STATUS;\n\t\tif (tmp & STAT_PARITY)\n\t\t\tprintf(\"%s: parity error detected\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\tif (!(tmp & STAT_BSY)) {\n\t\t\tfor (loop = 0; loop < 20; loop++)\n\t\t\t\tif ((tmp = STATUS) & STAT_BSY)\n\t\t\t\t\tbreak;\n\t\t\tif (!(tmp & STAT_BSY)) {\n\t\t\t\tprintf(\"%s: !STAT_BSY unit in data transfer!\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\ts = splbio();\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tscb->flags = SCB_ERROR;\n\t\t\t\tsplx(s);\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* we only have a valid SCSI phase when REQ is asserted */\n\t\tif (!(tmp & STAT_REQ))\n\t\t\tcontinue;\n\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tphase = tmp & PH_MASK;\n\t\tif (phase != old_phase)\n\t\t\told_phase = phase;\n\n\t\tswitch (phase) {\n\t\tcase PH_DATAOUT:\n#ifdef SEA_NODATAOUT\n\t\t\tprintf(\"%s: SEA_NODATAOUT set, attempted DATAOUT aborted\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tmsgout = MSG_ABORT;\n\t\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\t\tbreak;\n#endif\n\t\tcase PH_DATAIN:\n\t\t\tif (!scb->data)\n\t\t\t\tprintf(\"no data address!\\n\");\n#ifdef SEA_BLINDTRANSFER\n\t\t\tif (scb->datalen && !(scb->datalen % BLOCK_SIZE)) {\n\t\t\t\twhile (scb->datalen) {\n\t\t\t\t\tfor (loop = 0; loop < 50000; loop++)\n\t\t\t\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!(tmp & STAT_REQ)) {\n\t\t\t\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\t\t\t/* XXX Do something? */\n\t\t\t\t\t}\n\t\t\t\t\tif (sea->type == FDOMAIN840)\n\t\t\t\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t\t\t\t       (tmp & 0xf5);\n\t\t\t\t\tif ((tmp & PH_MASK) != phase)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!(phase & STAT_IO)) {\n\t\t\t\t\t\tint block = BLOCK_SIZE; \n\t\t\t\t\t\tvoid *a = sea->maddr_dr;\n#ifdef SEA_ASSEMBLER\n\t\t\t\t\t\tasm(\"shr $2, %%ecx\\n\\t\\\n\t\t\t\t\t\t    cld\\n\\t\\\n\t\t\t\t\t\t    rep\\n\\t\\\n\t\t\t\t\t\t    movsl\" :\n\t\t\t\t\t\t    \"=S\" (scb->data), \n\t\t\t\t\t\t\t\"=c\" (block) ,\n\t\t\t\t\t\t    \"=D\" (a) :\n\t\t\t\t\t\t    \"0\" (scb->data),\n\t\t\t\t\t\t    \"2\" (a),\n\t\t\t\t\t\t    \"1\" (block) );\n#else\n\t\t\t\t\t\tfor (count = 0;\n\t\t\t\t\t\t    count < BLOCK_SIZE;\n\t\t\t\t\t\t    count++)\n\t\t\t\t\t\t\tDATA = *(scb->data++);\n#endif\n\t\t\t\t\t} else { \n\t\t\t\t\t\tint block = BLOCK_SIZE;\n\t\t\t\t\t\tvoid *a = sea->maddr_dr;\n#ifdef SEA_ASSEMBLER\n\t\t\t\t\t\tasm(\"shr $2, %%ecx\\n\\t\\\n\t\t\t\t\t\t    cld\\n\\t\\\n\t\t\t\t\t\t    rep\\n\\t\\\n\t\t\t\t\t\t    movsl\" :\n\t\t\t\t\t\t    \"=D\" (scb->data), \"=c\" (block) ,\n\t\t\t\t\t\t    \"=S\" (a) :\n\t\t\t\t\t\t    \"0\" (scb->data),\n\t\t\t\t\t\t\t\"2\" (a) ,\n\t\t\t\t\t\t    \"1\" (block) );\n#else\n\t\t\t\t\t        for (count = 0;\n\t\t\t\t\t\t    count < BLOCK_SIZE;\n\t\t\t\t\t\t    count++)\n\t\t\t\t\t\t\t*(scb->data++) = DATA;\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tscb->datalen -= BLOCK_SIZE;\n\t\t\t\t}\n\t\t\t}\n#endif \n\t\t\tif (scb->datalen)\n\t\t\t\tsea_transfer_pio(sea, &phase, &scb->datalen,\n\t\t\t\t    &scb->data);\n\t\t\tbreak;\n\t\tcase PH_MSGIN:\n\t\t\t/* Multibyte messages should not be present here. */\n\t\t\tlen = 1;\n\t\t\tdata = &tmp;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\t/* scb->MessageIn = tmp; */\n\n\t\t\tswitch (tmp) {\n\t\t\tcase MSG_ABORT:\n\t\t\t\tscb->flags = SCB_ABORTED;\n\t\t\t\tprintf(\"sea: command aborted by target\\n\");\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\tcase MSG_CMDCOMPLETE:\n\t\t\t\ts = splbio();\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tsplx(s);\n\t\t\t\tsea->busy[scb->xs->sc_link->target] &= \n\t\t\t\t    ~(1 << scb->xs->sc_link->lun);\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\tcase MSG_MESSAGE_REJECT:\n\t\t\t\tprintf(\"%s: message_reject recieved\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\tbreak;\n\t\t\tcase MSG_DISCONNECT:\n\t\t\t\ts = splbio();\n\t\t\t\tTAILQ_INSERT_TAIL(&sea->nexus_list,\n\t\t\t\t    scb, chain);\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsplx(s);\n\t\t\t\treturn;\n\t\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tcase MSG_RESTOREPOINTERS:\n\t\t\t\t/* save/restore of pointers are ignored */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * This should be handled in the pio data\n\t\t\t\t * transfer phase, as the ATN should be raised\n\t\t\t\t * before ACK goes false when rejecting a\n\t\t\t\t * message.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: unknown message in: %x\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname, tmp);\n\t\t\t\tbreak;\n\t\t\t} /* switch (tmp) */\n\t\t\tbreak;\n\t\tcase PH_MSGOUT:\n\t\t\tlen = 1;\n\t\t\tdata = &msgout;\n\t\t\t/* sea->last_message = msgout; */\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tif (msgout == MSG_ABORT) {\n\t\t\t\tprintf(\"%s: sent message abort to target\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\ts = splbio();\n\t\t\t\tsea->busy[scb->xs->sc_link->target] &= \n\t\t\t\t    ~(1 << scb->xs->sc_link->lun);\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tscb->flags = SCB_ABORTED;\n\t\t\t\tsplx(s); \n\t\t\t\t/* enable interrupt from scsi */\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmsgout = MSG_NOOP;\n\t\t\tbreak;\n\t\tcase PH_CMD:\n\t\t\tlen = scb->xs->cmdlen;\n\t\t\tdata = (char *) scb->xs->cmd;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tbreak;\n\t\tcase PH_STAT:\n\t\t\tlen = 1;\n\t\t\tdata = &tmp;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tscb->xs->status = tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"sea: unknown phase\\n\");\n\t\t} /* switch (phase) */\n\t} /* for (...) */\n\n\t/* If we get here we have got a timeout! */\n\tprintf(\"%s: timeout in data transfer\\n\", sea->sc_dev.dv_xname);\n\tscb->flags = SCB_TIMEOUT;\n\t/* XXX Should I clear scsi-bus state? */\n\tsea_done(sea, scb);\n}"
  },
  {
    "function_name": "sea_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "1205-1225",
    "snippet": "int\nsea_poll(sea, xs, count)\n\tstruct sea_softc *sea;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint s;\n\n\twhile (count) {\n\t\t/* try to do something */\n\t\ts = splbio();\n\t\tif (!main_running)\n\t\t\tsea_main();\n\t\tsplx(s);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile int main_running = 0;",
      "static void sea_main",
      "int sea_poll",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sea_main",
          "args": [],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "sea_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "678-773",
          "snippet": "void\nsea_main()\n{\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint done;\n\tint unit;\n\tint s;\n\n\tmain_running = 1;\n\n\t/*\n\t * This should not be run with interrupts disabled, but use the splx\n\t * code instead.\n\t */\nloop:\n\tdone = 1;\n\tfor (unit = 0; unit < sea_cd.cd_ndevs; unit++) {\n\t\tsea = sea_cd.cd_devs[unit];\n\t\tif (!sea)\n\t\t\tcontinue;\n\t\ts = splbio();\n\t\tif (!sea->nexus) {\n\t\t\t/*\n\t\t\t * Search through the ready_list for a command\n\t\t\t * destined for a target that's not busy.\n\t\t\t */\n\t\t\tfor (scb = sea->ready_list.tqh_first; scb;\n\t\t\t    scb = scb->chain.tqe_next) {\n\t\t\t\tif (!(sea->busy[scb->xs->sc_link->target] &\n\t\t\t\t    (1 << scb->xs->sc_link->lun))) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->ready_list, scb,\n\t\t\t\t\t    chain);\n\t    \n\t\t\t\t\t/* Re-enable interrupts. */\n\t\t\t\t\tsplx(s);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to establish an I_T_L nexus.\n\t\t\t\t\t * On success, sea->nexus is set.\n\t\t\t\t\t * On failure, we must add the command\n\t\t\t\t\t * back to the issue queue so we can\n\t\t\t\t\t * keep trying.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * REQUEST_SENSE commands are issued\n\t\t\t\t\t * without tagged queueing, even on\n\t\t\t\t\t * SCSI-II devices because the\n\t\t\t\t\t * contingent alligence condition\n\t\t\t\t\t * exists for the entire unit.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * First check that if any device has\n\t\t\t\t\t * tried a reconnect while we have done\n\t\t\t\t\t * other things with interrupts\n\t\t\t\t\t * disabled.\n\t\t\t\t\t */\n\n\t\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sea_select(sea, scb)) {\n\t\t\t\t\t\ts = splbio();\n\t\t\t\t\t\tTAILQ_INSERT_HEAD(&sea->ready_list,\n\t\t\t\t\t\t    scb, chain);\n\t\t\t\t\t\tsplx(s);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t} /* if target/lun is not busy */\n\t\t\t} /* for scb */\n\t\t\tif (!sea->nexus) {\n\t\t\t\t/* check for reselection phase */\n\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* if (!sea->nexus) */\n      \n\t\tsplx(s);\n\t\tif (sea->nexus) {\t/* we are connected. Do the task */\n\t\t\tsea_information_transfer(sea);\n\t\t\tdone = 0;\n\t\t} else\n\t\t\tbreak;\n\t} /* for instance */\n\n\tif (!done)\n\t\tgoto loop;\n\n\tmain_running = 0;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define STAT_SEL\t0x20\t\t/* scsi select */",
            "#define STAT_IO\t\t0x04\t\t/* scsi I/O */"
          ],
          "globals_used": [
            "static volatile int main_running = 0;",
            "static void sea_main",
            "static void sea_information_transfer",
            "void sea_reselect",
            "int sea_select",
            "struct cfdriver sea_cd = {\n\tNULL, \"sea\", DV_DULL\n};",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n\nstatic volatile int main_running = 0;\nstatic void sea_main;\nstatic void sea_information_transfer;\nvoid sea_reselect;\nint sea_select;\nstruct cfdriver sea_cd = {\n\tNULL, \"sea\", DV_DULL\n};\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_main()\n{\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint done;\n\tint unit;\n\tint s;\n\n\tmain_running = 1;\n\n\t/*\n\t * This should not be run with interrupts disabled, but use the splx\n\t * code instead.\n\t */\nloop:\n\tdone = 1;\n\tfor (unit = 0; unit < sea_cd.cd_ndevs; unit++) {\n\t\tsea = sea_cd.cd_devs[unit];\n\t\tif (!sea)\n\t\t\tcontinue;\n\t\ts = splbio();\n\t\tif (!sea->nexus) {\n\t\t\t/*\n\t\t\t * Search through the ready_list for a command\n\t\t\t * destined for a target that's not busy.\n\t\t\t */\n\t\t\tfor (scb = sea->ready_list.tqh_first; scb;\n\t\t\t    scb = scb->chain.tqe_next) {\n\t\t\t\tif (!(sea->busy[scb->xs->sc_link->target] &\n\t\t\t\t    (1 << scb->xs->sc_link->lun))) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->ready_list, scb,\n\t\t\t\t\t    chain);\n\t    \n\t\t\t\t\t/* Re-enable interrupts. */\n\t\t\t\t\tsplx(s);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to establish an I_T_L nexus.\n\t\t\t\t\t * On success, sea->nexus is set.\n\t\t\t\t\t * On failure, we must add the command\n\t\t\t\t\t * back to the issue queue so we can\n\t\t\t\t\t * keep trying.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * REQUEST_SENSE commands are issued\n\t\t\t\t\t * without tagged queueing, even on\n\t\t\t\t\t * SCSI-II devices because the\n\t\t\t\t\t * contingent alligence condition\n\t\t\t\t\t * exists for the entire unit.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * First check that if any device has\n\t\t\t\t\t * tried a reconnect while we have done\n\t\t\t\t\t * other things with interrupts\n\t\t\t\t\t * disabled.\n\t\t\t\t\t */\n\n\t\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sea_select(sea, scb)) {\n\t\t\t\t\t\ts = splbio();\n\t\t\t\t\t\tTAILQ_INSERT_HEAD(&sea->ready_list,\n\t\t\t\t\t\t    scb, chain);\n\t\t\t\t\t\tsplx(s);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t} /* if target/lun is not busy */\n\t\t\t} /* for scb */\n\t\t\tif (!sea->nexus) {\n\t\t\t\t/* check for reselection phase */\n\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* if (!sea->nexus) */\n      \n\t\tsplx(s);\n\t\tif (sea->nexus) {\t/* we are connected. Do the task */\n\t\t\tsea_information_transfer(sea);\n\t\t\tdone = 0;\n\t\t} else\n\t\t\tbreak;\n\t} /* for instance */\n\n\tif (!done)\n\t\tgoto loop;\n\n\tmain_running = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic volatile int main_running = 0;\nstatic void sea_main;\nint sea_poll;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nint\nsea_poll(sea, xs, count)\n\tstruct sea_softc *sea;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint s;\n\n\twhile (count) {\n\t\t/* try to do something */\n\t\ts = splbio();\n\t\tif (!main_running)\n\t\t\tsea_main();\n\t\tsplx(s);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "sea_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "1177-1200",
    "snippet": "void\nsea_done(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\n\tuntimeout(sea_timeout, scb);\n\n\txs->resid = scb->datalen;\n\n\t/* XXXX need to get status */\n\tif (scb->flags == SCB_ACTIVE) {\n\t\txs->resid = 0;\n\t} else {\n\t\tif (scb->flags & (SCB_TIMEOUT | SCB_ABORTED))\n\t\t\txs->error = XS_TIMEOUT;\n\t\tif (scb->flags & SCB_ERROR)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t}\n\txs->flags |= ITSDONE;\n\tsea_free_scb(sea, scb, xs->flags);\n\tscsi_done(xs);\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define SCB_ERROR\t8",
      "#define SCB_TIMEOUT\t4",
      "#define SCB_ABORTED\t2",
      "#define\tSCB_ACTIVE\t1"
    ],
    "globals_used": [
      "void sea_timeout",
      "void sea_done",
      "void sea_free_scb",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sea_free_scb",
          "args": [
            "sea",
            "scb",
            "xs->flags"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "sea_free_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "775-796",
          "snippet": "void\nsea_free_scb(sea, scb, flags)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tscb->flags = SCB_FREE;\n\tTAILQ_INSERT_HEAD(&sea->free_list, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (!scb->chain.tqe_next)\n\t\twakeup((caddr_t)&sea->free_list);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tSCB_FREE\t0"
          ],
          "globals_used": [
            "void sea_free_scb",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tSCB_FREE\t0\n\nvoid sea_free_scb;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nvoid\nsea_free_scb(sea, scb, flags)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tscb->flags = SCB_FREE;\n\tTAILQ_INSERT_HEAD(&sea->free_list, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (!scb->chain.tqe_next)\n\t\twakeup((caddr_t)&sea->free_list);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "sea_timeout",
            "scb"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define SCB_ERROR\t8\n#define SCB_TIMEOUT\t4\n#define SCB_ABORTED\t2\n#define\tSCB_ACTIVE\t1\n\nvoid sea_timeout;\nvoid sea_done;\nvoid sea_free_scb;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nvoid\nsea_done(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\n\tuntimeout(sea_timeout, scb);\n\n\txs->resid = scb->datalen;\n\n\t/* XXXX need to get status */\n\tif (scb->flags == SCB_ACTIVE) {\n\t\txs->resid = 0;\n\t} else {\n\t\tif (scb->flags & (SCB_TIMEOUT | SCB_ABORTED))\n\t\t\txs->error = XS_TIMEOUT;\n\t\tif (scb->flags & SCB_ERROR)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t}\n\txs->flags |= ITSDONE;\n\tsea_free_scb(sea, scb, xs->flags);\n\tscsi_done(xs);\n}"
  },
  {
    "function_name": "sea_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "1116-1175",
    "snippet": "int\nsea_abort(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tstruct sea_scb *tmp;\n\tu_char msg, phase, *msgptr;\n\tint len;\n\n\t/*\n\t * If the command hasn't been issued yet, we simply remove it from the\n\t * issue queue\n\t * XXX Could avoid this loop.\n\t */\n\tfor (tmp = sea->ready_list.tqh_first; tmp; tmp = tmp->chain.tqe_next)\n\t\tif (scb == tmp) {\n\t\t\tTAILQ_REMOVE(&sea->ready_list, scb, chain);\n\t\t\t/* XXX Set some type of error result for operation. */\n\t\t\treturn 1;\n\t\t}\n\n\t/*\n\t * If any commands are connected, we're going to fail the abort and let\n\t * the high level SCSI driver retry at a later time or issue a reset.\n\t */\n\tif (sea->nexus)\n\t\treturn 0;\n\n\t/*\n\t * If the command is currently disconnected from the bus, and there are\n\t * no connected commands, we reconnect the I_T_L or I_T_L_Q nexus\n\t * associated with it, go into message out, and send an abort message.\n\t */\n\tfor (tmp = sea->nexus_list.tqh_first; tmp;\n\t    tmp = tmp->chain.tqe_next)\n\t\tif (scb == tmp) {\n\t\t\tif (sea_select(sea, scb))\n\t\t\t\treturn 0;\n\n\t\t\tmsg = MSG_ABORT;\n\t\t\tmsgptr = &msg;\n\t\t\tlen = 1;\n\t\t\tphase = PH_MSGOUT;\n\t\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &msgptr);\n\n\t\t\tfor (tmp = sea->nexus_list.tqh_first; tmp;\n\t\t\t    tmp = tmp->chain.tqe_next)\n\t\t\t\tif (scb == tmp) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->nexus_list,\n\t\t\t\t\t    scb, chain);\n\t\t\t\t\t/* XXX Set some type of error result\n\t\t\t\t\t   for the operation. */\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t}\n\n\t/* Command not found in any queue; race condition? */\n\treturn 1;\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define CONTROL\tSTATUS",
      "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
      "#define PH_MSGOUT\t(STAT_MSG | STAT_CD)",
      "#define\tCMD_ATTN\t0x08\t\t/* scsi attention */"
    ],
    "globals_used": [
      "int sea_select",
      "int sea_transfer_pio",
      "int sea_abort",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sea->nexus_list",
            "scb",
            "chain"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sea_transfer_pio",
          "args": [
            "sea",
            "&phase",
            "&len",
            "&msgptr"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "sea_transfer_pio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "934-1012",
          "snippet": "int\nsea_transfer_pio(sea, phase, count, data)\n\tstruct sea_softc *sea;\n\tu_char *phase;\n\tint *count;\n\tu_char **data;\n{\n\tregister u_char p = *phase, tmp;\n\tregister int c = *count;\n\tregister u_char *d = *data;\n\tint timeout;\n\n\tdo {\n\t\t/*\n\t\t * Wait for assertion of REQ, after which the phase bits will\n\t\t * be valid.\n\t\t */\n\t\tfor (timeout = 0; timeout < 50000; timeout++)\n\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\tbreak;\n\t\tif (!(tmp & STAT_REQ)) {\n\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check for phase mismatch.  Reached if the target decides\n\t\t * that it has finished the transfer.\n\t\t */\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tif ((tmp & PH_MASK) != p)\n\t\t\tbreak;\n\n\t\t/* Do actual transfer from SCSI bus to/from memory. */\n\t\tif (!(p & STAT_IO))\n\t\t\tDATA = *d;\n\t\telse\n\t\t\t*d = DATA;\n\t\t++d;\n\n\t\t/*\n\t\t * The SCSI standard suggests that in MSGOUT phase, the\n\t\t * initiator should drop ATN on the last byte of the message\n\t\t * phase after REQ has been asserted for the handshake but\n\t\t * before the initiator raises ACK.\n\t\t * Don't know how to accomplish this on the ST01/02.\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * XXX\n\t\t * The st01 code doesn't wait for STAT_REQ to be deasserted.\n\t\t * Is this ok?\n\t\t */\n\t\tfor (timeout = 0; timeout < 200000L; timeout++)\n\t\t\tif (!(STATUS & STAT_REQ))\n\t\t\t\tbreak;\n\t\tif (STATUS & STAT_REQ)\n\t\t\tprintf(\"%s: timeout on wait for !STAT_REQ\",\n\t\t\t    sea->sc_dev.dv_xname);\n#endif\n\t} while (--c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = STATUS;\n\tif (tmp & STAT_REQ)\n\t\t*phase = tmp & PH_MASK;\n\telse\n\t\t*phase = PH_INVALID;\n\n\tif (c && (*phase != p))\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */",
            "#define PH_INVALID\t0xff",
            "#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)",
            "#define STAT_REQ\t0x10\t\t/* scsi req */",
            "#define STAT_IO\t\t0x04\t\t/* scsi I/O */"
          ],
          "globals_used": [
            "int sea_transfer_pio",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */\n#define PH_INVALID\t0xff\n#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nint\nsea_transfer_pio(sea, phase, count, data)\n\tstruct sea_softc *sea;\n\tu_char *phase;\n\tint *count;\n\tu_char **data;\n{\n\tregister u_char p = *phase, tmp;\n\tregister int c = *count;\n\tregister u_char *d = *data;\n\tint timeout;\n\n\tdo {\n\t\t/*\n\t\t * Wait for assertion of REQ, after which the phase bits will\n\t\t * be valid.\n\t\t */\n\t\tfor (timeout = 0; timeout < 50000; timeout++)\n\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\tbreak;\n\t\tif (!(tmp & STAT_REQ)) {\n\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check for phase mismatch.  Reached if the target decides\n\t\t * that it has finished the transfer.\n\t\t */\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tif ((tmp & PH_MASK) != p)\n\t\t\tbreak;\n\n\t\t/* Do actual transfer from SCSI bus to/from memory. */\n\t\tif (!(p & STAT_IO))\n\t\t\tDATA = *d;\n\t\telse\n\t\t\t*d = DATA;\n\t\t++d;\n\n\t\t/*\n\t\t * The SCSI standard suggests that in MSGOUT phase, the\n\t\t * initiator should drop ATN on the last byte of the message\n\t\t * phase after REQ has been asserted for the handshake but\n\t\t * before the initiator raises ACK.\n\t\t * Don't know how to accomplish this on the ST01/02.\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * XXX\n\t\t * The st01 code doesn't wait for STAT_REQ to be deasserted.\n\t\t * Is this ok?\n\t\t */\n\t\tfor (timeout = 0; timeout < 200000L; timeout++)\n\t\t\tif (!(STATUS & STAT_REQ))\n\t\t\t\tbreak;\n\t\tif (STATUS & STAT_REQ)\n\t\t\tprintf(\"%s: timeout on wait for !STAT_REQ\",\n\t\t\t    sea->sc_dev.dv_xname);\n#endif\n\t} while (--c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = STATUS;\n\tif (tmp & STAT_REQ)\n\t\t*phase = tmp & PH_MASK;\n\telse\n\t\t*phase = PH_INVALID;\n\n\tif (c && (*phase != p))\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sea_select",
          "args": [
            "sea",
            "scb"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "sea_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "1020-1111",
          "snippet": "int\nsea_select(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tu_char msg[3], phase;\n\tu_char *data;\n\tint len;\n\tint timeout;\n\n\tCONTROL = BASE_CMD;\n\tDATA = sea->our_id_mask;\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_START_ARB;\n\n\t/* wait for arbitration to complete */\n\tfor (timeout = 0; timeout < 3000000L; timeout++)\n\t\tif (STATUS & STAT_ARB_CMPL)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_ARB_CMPL)) {\n\t\tif (STATUS & STAT_SEL) {\n\t\t\tprintf(\"%s: arbitration lost\\n\", sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_ERROR;\n\t\t} else {\n\t\t\tprintf(\"%s: arbitration timeout\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_TIMEOUT;\n\t\t}\n\t\tCONTROL = BASE_CMD;\n\t\treturn -1;\n\t}\n\n\tdelay(2);\n\tDATA = (u_char)((1 << scb->xs->sc_link->target) | sea->our_id_mask);\n\tCONTROL =\n#ifdef SEA_NOMSGS\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL;\n#else\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL | CMD_ATTN;\n#endif\n\tdelay(1); \n\n\t/* wait for a bsy from target */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_BSY)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_BSY)) {\n\t\t/* should return some error to the higher level driver */\n\t\tCONTROL = BASE_CMD;\n\t\tscb->flags |= SCB_TIMEOUT;\n\t\treturn 0;\n\t}\n\n\t/* Try to make the target to take a message from us */\n#ifdef SEA_NOMSGS\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE;\n#else\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_ATTN;\n#endif\n\tdelay(1);\n  \n\t/* should start a msg_out phase */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_REQ)\n\t\t\tbreak;\n\t/* Remove ATN. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\tif (!(STATUS & STAT_REQ)) {\n\t\t/*\n\t\t * This should not be taken as an error, but more like an\n\t\t * unsupported feature!  Should set a flag indicating that the\n\t\t * target don't support messages, and continue without failure.\n\t\t * (THIS IS NOT AN ERROR!)\n\t\t */\n\t} else {\n\t\tmsg[0] = MSG_IDENTIFY(scb->xs->sc_link->lun, 1);\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\t/* Should do test on result of sea_transfer_pio(). */\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t}\n\tif (!(STATUS & STAT_BSY))\n\t\tprintf(\"%s: after successful arbitrate: no STAT_BSY!\\n\",\n\t\t    sea->sc_dev.dv_xname);\n  \n\tsea->nexus = scb;\n\tsea->busy[scb->xs->sc_link->target] |= 1 << scb->xs->sc_link->lun;\n\t/* This assignment should depend on possibility to send a message to target. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* XXX Reset pointer in command? */\n\treturn 0;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
            "#define CONTROL\tSTATUS",
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define SCB_ERROR\t8",
            "#define SCB_TIMEOUT\t4",
            "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
            "#define PH_MSGOUT\t(STAT_MSG | STAT_CD)",
            "#define STAT_ARB_CMPL\t0x80\t\t/* arbitration complete bit */",
            "#define STAT_SEL\t0x20\t\t/* scsi select */",
            "#define STAT_REQ\t0x10\t\t/* scsi req */",
            "#define STAT_BSY\t0x01\t\t/* scsi busy */",
            "#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */",
            "#define CMD_INTR\t0x40\t\t/* enable scsi interrupts */",
            "#define CMD_START_ARB\t0x10\t\t/* start arbitration bit */",
            "#define\tCMD_ATTN\t0x08\t\t/* scsi attention */",
            "#define CMD_SEL\t\t0x02\t\t/* scsi select */"
          ],
          "globals_used": [
            "int sea_select",
            "int sea_transfer_pio",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define CONTROL\tSTATUS\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define SCB_ERROR\t8\n#define SCB_TIMEOUT\t4\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define PH_MSGOUT\t(STAT_MSG | STAT_CD)\n#define STAT_ARB_CMPL\t0x80\t\t/* arbitration complete bit */\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_BSY\t0x01\t\t/* scsi busy */\n#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */\n#define CMD_INTR\t0x40\t\t/* enable scsi interrupts */\n#define CMD_START_ARB\t0x10\t\t/* start arbitration bit */\n#define\tCMD_ATTN\t0x08\t\t/* scsi attention */\n#define CMD_SEL\t\t0x02\t\t/* scsi select */\n\nint sea_select;\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nint\nsea_select(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tu_char msg[3], phase;\n\tu_char *data;\n\tint len;\n\tint timeout;\n\n\tCONTROL = BASE_CMD;\n\tDATA = sea->our_id_mask;\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_START_ARB;\n\n\t/* wait for arbitration to complete */\n\tfor (timeout = 0; timeout < 3000000L; timeout++)\n\t\tif (STATUS & STAT_ARB_CMPL)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_ARB_CMPL)) {\n\t\tif (STATUS & STAT_SEL) {\n\t\t\tprintf(\"%s: arbitration lost\\n\", sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_ERROR;\n\t\t} else {\n\t\t\tprintf(\"%s: arbitration timeout\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_TIMEOUT;\n\t\t}\n\t\tCONTROL = BASE_CMD;\n\t\treturn -1;\n\t}\n\n\tdelay(2);\n\tDATA = (u_char)((1 << scb->xs->sc_link->target) | sea->our_id_mask);\n\tCONTROL =\n#ifdef SEA_NOMSGS\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL;\n#else\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL | CMD_ATTN;\n#endif\n\tdelay(1); \n\n\t/* wait for a bsy from target */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_BSY)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_BSY)) {\n\t\t/* should return some error to the higher level driver */\n\t\tCONTROL = BASE_CMD;\n\t\tscb->flags |= SCB_TIMEOUT;\n\t\treturn 0;\n\t}\n\n\t/* Try to make the target to take a message from us */\n#ifdef SEA_NOMSGS\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE;\n#else\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_ATTN;\n#endif\n\tdelay(1);\n  \n\t/* should start a msg_out phase */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_REQ)\n\t\t\tbreak;\n\t/* Remove ATN. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\tif (!(STATUS & STAT_REQ)) {\n\t\t/*\n\t\t * This should not be taken as an error, but more like an\n\t\t * unsupported feature!  Should set a flag indicating that the\n\t\t * target don't support messages, and continue without failure.\n\t\t * (THIS IS NOT AN ERROR!)\n\t\t */\n\t} else {\n\t\tmsg[0] = MSG_IDENTIFY(scb->xs->sc_link->lun, 1);\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\t/* Should do test on result of sea_transfer_pio(). */\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t}\n\tif (!(STATUS & STAT_BSY))\n\t\tprintf(\"%s: after successful arbitrate: no STAT_BSY!\\n\",\n\t\t    sea->sc_dev.dv_xname);\n  \n\tsea->nexus = scb;\n\tsea->busy[scb->xs->sc_link->target] |= 1 << scb->xs->sc_link->lun;\n\t/* This assignment should depend on possibility to send a message to target. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* XXX Reset pointer in command? */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sea->ready_list",
            "scb",
            "chain"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define CONTROL\tSTATUS\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define PH_MSGOUT\t(STAT_MSG | STAT_CD)\n#define\tCMD_ATTN\t0x08\t\t/* scsi attention */\n\nint sea_select;\nint sea_transfer_pio;\nint sea_abort;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nint\nsea_abort(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tstruct sea_scb *tmp;\n\tu_char msg, phase, *msgptr;\n\tint len;\n\n\t/*\n\t * If the command hasn't been issued yet, we simply remove it from the\n\t * issue queue\n\t * XXX Could avoid this loop.\n\t */\n\tfor (tmp = sea->ready_list.tqh_first; tmp; tmp = tmp->chain.tqe_next)\n\t\tif (scb == tmp) {\n\t\t\tTAILQ_REMOVE(&sea->ready_list, scb, chain);\n\t\t\t/* XXX Set some type of error result for operation. */\n\t\t\treturn 1;\n\t\t}\n\n\t/*\n\t * If any commands are connected, we're going to fail the abort and let\n\t * the high level SCSI driver retry at a later time or issue a reset.\n\t */\n\tif (sea->nexus)\n\t\treturn 0;\n\n\t/*\n\t * If the command is currently disconnected from the bus, and there are\n\t * no connected commands, we reconnect the I_T_L or I_T_L_Q nexus\n\t * associated with it, go into message out, and send an abort message.\n\t */\n\tfor (tmp = sea->nexus_list.tqh_first; tmp;\n\t    tmp = tmp->chain.tqe_next)\n\t\tif (scb == tmp) {\n\t\t\tif (sea_select(sea, scb))\n\t\t\t\treturn 0;\n\n\t\t\tmsg = MSG_ABORT;\n\t\t\tmsgptr = &msg;\n\t\t\tlen = 1;\n\t\t\tphase = PH_MSGOUT;\n\t\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &msgptr);\n\n\t\t\tfor (tmp = sea->nexus_list.tqh_first; tmp;\n\t\t\t    tmp = tmp->chain.tqe_next)\n\t\t\t\tif (scb == tmp) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->nexus_list,\n\t\t\t\t\t    scb, chain);\n\t\t\t\t\t/* XXX Set some type of error result\n\t\t\t\t\t   for the operation. */\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t}\n\n\t/* Command not found in any queue; race condition? */\n\treturn 1;\n}"
  },
  {
    "function_name": "sea_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "1020-1111",
    "snippet": "int\nsea_select(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tu_char msg[3], phase;\n\tu_char *data;\n\tint len;\n\tint timeout;\n\n\tCONTROL = BASE_CMD;\n\tDATA = sea->our_id_mask;\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_START_ARB;\n\n\t/* wait for arbitration to complete */\n\tfor (timeout = 0; timeout < 3000000L; timeout++)\n\t\tif (STATUS & STAT_ARB_CMPL)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_ARB_CMPL)) {\n\t\tif (STATUS & STAT_SEL) {\n\t\t\tprintf(\"%s: arbitration lost\\n\", sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_ERROR;\n\t\t} else {\n\t\t\tprintf(\"%s: arbitration timeout\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_TIMEOUT;\n\t\t}\n\t\tCONTROL = BASE_CMD;\n\t\treturn -1;\n\t}\n\n\tdelay(2);\n\tDATA = (u_char)((1 << scb->xs->sc_link->target) | sea->our_id_mask);\n\tCONTROL =\n#ifdef SEA_NOMSGS\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL;\n#else\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL | CMD_ATTN;\n#endif\n\tdelay(1); \n\n\t/* wait for a bsy from target */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_BSY)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_BSY)) {\n\t\t/* should return some error to the higher level driver */\n\t\tCONTROL = BASE_CMD;\n\t\tscb->flags |= SCB_TIMEOUT;\n\t\treturn 0;\n\t}\n\n\t/* Try to make the target to take a message from us */\n#ifdef SEA_NOMSGS\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE;\n#else\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_ATTN;\n#endif\n\tdelay(1);\n  \n\t/* should start a msg_out phase */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_REQ)\n\t\t\tbreak;\n\t/* Remove ATN. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\tif (!(STATUS & STAT_REQ)) {\n\t\t/*\n\t\t * This should not be taken as an error, but more like an\n\t\t * unsupported feature!  Should set a flag indicating that the\n\t\t * target don't support messages, and continue without failure.\n\t\t * (THIS IS NOT AN ERROR!)\n\t\t */\n\t} else {\n\t\tmsg[0] = MSG_IDENTIFY(scb->xs->sc_link->lun, 1);\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\t/* Should do test on result of sea_transfer_pio(). */\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t}\n\tif (!(STATUS & STAT_BSY))\n\t\tprintf(\"%s: after successful arbitrate: no STAT_BSY!\\n\",\n\t\t    sea->sc_dev.dv_xname);\n  \n\tsea->nexus = scb;\n\tsea->busy[scb->xs->sc_link->target] |= 1 << scb->xs->sc_link->lun;\n\t/* This assignment should depend on possibility to send a message to target. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* XXX Reset pointer in command? */\n\treturn 0;\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
      "#define CONTROL\tSTATUS",
      "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
      "#define SCB_ERROR\t8",
      "#define SCB_TIMEOUT\t4",
      "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
      "#define PH_MSGOUT\t(STAT_MSG | STAT_CD)",
      "#define STAT_ARB_CMPL\t0x80\t\t/* arbitration complete bit */",
      "#define STAT_SEL\t0x20\t\t/* scsi select */",
      "#define STAT_REQ\t0x10\t\t/* scsi req */",
      "#define STAT_BSY\t0x01\t\t/* scsi busy */",
      "#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */",
      "#define CMD_INTR\t0x40\t\t/* enable scsi interrupts */",
      "#define CMD_START_ARB\t0x10\t\t/* start arbitration bit */",
      "#define\tCMD_ATTN\t0x08\t\t/* scsi attention */",
      "#define CMD_SEL\t\t0x02\t\t/* scsi select */"
    ],
    "globals_used": [
      "int sea_select",
      "int sea_transfer_pio",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: after successful arbitrate: no STAT_BSY!\\n\"",
            "sea->sc_dev.dv_xname"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sea_transfer_pio",
          "args": [
            "sea",
            "&phase",
            "&len",
            "&data"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "sea_transfer_pio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "934-1012",
          "snippet": "int\nsea_transfer_pio(sea, phase, count, data)\n\tstruct sea_softc *sea;\n\tu_char *phase;\n\tint *count;\n\tu_char **data;\n{\n\tregister u_char p = *phase, tmp;\n\tregister int c = *count;\n\tregister u_char *d = *data;\n\tint timeout;\n\n\tdo {\n\t\t/*\n\t\t * Wait for assertion of REQ, after which the phase bits will\n\t\t * be valid.\n\t\t */\n\t\tfor (timeout = 0; timeout < 50000; timeout++)\n\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\tbreak;\n\t\tif (!(tmp & STAT_REQ)) {\n\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check for phase mismatch.  Reached if the target decides\n\t\t * that it has finished the transfer.\n\t\t */\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tif ((tmp & PH_MASK) != p)\n\t\t\tbreak;\n\n\t\t/* Do actual transfer from SCSI bus to/from memory. */\n\t\tif (!(p & STAT_IO))\n\t\t\tDATA = *d;\n\t\telse\n\t\t\t*d = DATA;\n\t\t++d;\n\n\t\t/*\n\t\t * The SCSI standard suggests that in MSGOUT phase, the\n\t\t * initiator should drop ATN on the last byte of the message\n\t\t * phase after REQ has been asserted for the handshake but\n\t\t * before the initiator raises ACK.\n\t\t * Don't know how to accomplish this on the ST01/02.\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * XXX\n\t\t * The st01 code doesn't wait for STAT_REQ to be deasserted.\n\t\t * Is this ok?\n\t\t */\n\t\tfor (timeout = 0; timeout < 200000L; timeout++)\n\t\t\tif (!(STATUS & STAT_REQ))\n\t\t\t\tbreak;\n\t\tif (STATUS & STAT_REQ)\n\t\t\tprintf(\"%s: timeout on wait for !STAT_REQ\",\n\t\t\t    sea->sc_dev.dv_xname);\n#endif\n\t} while (--c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = STATUS;\n\tif (tmp & STAT_REQ)\n\t\t*phase = tmp & PH_MASK;\n\telse\n\t\t*phase = PH_INVALID;\n\n\tif (c && (*phase != p))\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */",
            "#define PH_INVALID\t0xff",
            "#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)",
            "#define STAT_REQ\t0x10\t\t/* scsi req */",
            "#define STAT_IO\t\t0x04\t\t/* scsi I/O */"
          ],
          "globals_used": [
            "int sea_transfer_pio",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */\n#define PH_INVALID\t0xff\n#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nint\nsea_transfer_pio(sea, phase, count, data)\n\tstruct sea_softc *sea;\n\tu_char *phase;\n\tint *count;\n\tu_char **data;\n{\n\tregister u_char p = *phase, tmp;\n\tregister int c = *count;\n\tregister u_char *d = *data;\n\tint timeout;\n\n\tdo {\n\t\t/*\n\t\t * Wait for assertion of REQ, after which the phase bits will\n\t\t * be valid.\n\t\t */\n\t\tfor (timeout = 0; timeout < 50000; timeout++)\n\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\tbreak;\n\t\tif (!(tmp & STAT_REQ)) {\n\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check for phase mismatch.  Reached if the target decides\n\t\t * that it has finished the transfer.\n\t\t */\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tif ((tmp & PH_MASK) != p)\n\t\t\tbreak;\n\n\t\t/* Do actual transfer from SCSI bus to/from memory. */\n\t\tif (!(p & STAT_IO))\n\t\t\tDATA = *d;\n\t\telse\n\t\t\t*d = DATA;\n\t\t++d;\n\n\t\t/*\n\t\t * The SCSI standard suggests that in MSGOUT phase, the\n\t\t * initiator should drop ATN on the last byte of the message\n\t\t * phase after REQ has been asserted for the handshake but\n\t\t * before the initiator raises ACK.\n\t\t * Don't know how to accomplish this on the ST01/02.\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * XXX\n\t\t * The st01 code doesn't wait for STAT_REQ to be deasserted.\n\t\t * Is this ok?\n\t\t */\n\t\tfor (timeout = 0; timeout < 200000L; timeout++)\n\t\t\tif (!(STATUS & STAT_REQ))\n\t\t\t\tbreak;\n\t\tif (STATUS & STAT_REQ)\n\t\t\tprintf(\"%s: timeout on wait for !STAT_REQ\",\n\t\t\t    sea->sc_dev.dv_xname);\n#endif\n\t} while (--c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = STATUS;\n\tif (tmp & STAT_REQ)\n\t\t*phase = tmp & PH_MASK;\n\telse\n\t\t*phase = PH_INVALID;\n\n\tif (c && (*phase != p))\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSG_IDENTIFY",
          "args": [
            "scb->xs->sc_link->lun",
            "1"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SEA_NOMSGS",
          "args": [
            "BASE_CMD & ~CMD_INTR"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(1 << scb->xs->sc_link->target) | sea->our_id_mask"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define CONTROL\tSTATUS\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define SCB_ERROR\t8\n#define SCB_TIMEOUT\t4\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define PH_MSGOUT\t(STAT_MSG | STAT_CD)\n#define STAT_ARB_CMPL\t0x80\t\t/* arbitration complete bit */\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_BSY\t0x01\t\t/* scsi busy */\n#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */\n#define CMD_INTR\t0x40\t\t/* enable scsi interrupts */\n#define CMD_START_ARB\t0x10\t\t/* start arbitration bit */\n#define\tCMD_ATTN\t0x08\t\t/* scsi attention */\n#define CMD_SEL\t\t0x02\t\t/* scsi select */\n\nint sea_select;\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nint\nsea_select(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tu_char msg[3], phase;\n\tu_char *data;\n\tint len;\n\tint timeout;\n\n\tCONTROL = BASE_CMD;\n\tDATA = sea->our_id_mask;\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_START_ARB;\n\n\t/* wait for arbitration to complete */\n\tfor (timeout = 0; timeout < 3000000L; timeout++)\n\t\tif (STATUS & STAT_ARB_CMPL)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_ARB_CMPL)) {\n\t\tif (STATUS & STAT_SEL) {\n\t\t\tprintf(\"%s: arbitration lost\\n\", sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_ERROR;\n\t\t} else {\n\t\t\tprintf(\"%s: arbitration timeout\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_TIMEOUT;\n\t\t}\n\t\tCONTROL = BASE_CMD;\n\t\treturn -1;\n\t}\n\n\tdelay(2);\n\tDATA = (u_char)((1 << scb->xs->sc_link->target) | sea->our_id_mask);\n\tCONTROL =\n#ifdef SEA_NOMSGS\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL;\n#else\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL | CMD_ATTN;\n#endif\n\tdelay(1); \n\n\t/* wait for a bsy from target */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_BSY)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_BSY)) {\n\t\t/* should return some error to the higher level driver */\n\t\tCONTROL = BASE_CMD;\n\t\tscb->flags |= SCB_TIMEOUT;\n\t\treturn 0;\n\t}\n\n\t/* Try to make the target to take a message from us */\n#ifdef SEA_NOMSGS\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE;\n#else\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_ATTN;\n#endif\n\tdelay(1);\n  \n\t/* should start a msg_out phase */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_REQ)\n\t\t\tbreak;\n\t/* Remove ATN. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\tif (!(STATUS & STAT_REQ)) {\n\t\t/*\n\t\t * This should not be taken as an error, but more like an\n\t\t * unsupported feature!  Should set a flag indicating that the\n\t\t * target don't support messages, and continue without failure.\n\t\t * (THIS IS NOT AN ERROR!)\n\t\t */\n\t} else {\n\t\tmsg[0] = MSG_IDENTIFY(scb->xs->sc_link->lun, 1);\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\t/* Should do test on result of sea_transfer_pio(). */\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t}\n\tif (!(STATUS & STAT_BSY))\n\t\tprintf(\"%s: after successful arbitrate: no STAT_BSY!\\n\",\n\t\t    sea->sc_dev.dv_xname);\n  \n\tsea->nexus = scb;\n\tsea->busy[scb->xs->sc_link->target] |= 1 << scb->xs->sc_link->lun;\n\t/* This assignment should depend on possibility to send a message to target. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* XXX Reset pointer in command? */\n\treturn 0;\n}"
  },
  {
    "function_name": "sea_transfer_pio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "934-1012",
    "snippet": "int\nsea_transfer_pio(sea, phase, count, data)\n\tstruct sea_softc *sea;\n\tu_char *phase;\n\tint *count;\n\tu_char **data;\n{\n\tregister u_char p = *phase, tmp;\n\tregister int c = *count;\n\tregister u_char *d = *data;\n\tint timeout;\n\n\tdo {\n\t\t/*\n\t\t * Wait for assertion of REQ, after which the phase bits will\n\t\t * be valid.\n\t\t */\n\t\tfor (timeout = 0; timeout < 50000; timeout++)\n\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\tbreak;\n\t\tif (!(tmp & STAT_REQ)) {\n\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check for phase mismatch.  Reached if the target decides\n\t\t * that it has finished the transfer.\n\t\t */\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tif ((tmp & PH_MASK) != p)\n\t\t\tbreak;\n\n\t\t/* Do actual transfer from SCSI bus to/from memory. */\n\t\tif (!(p & STAT_IO))\n\t\t\tDATA = *d;\n\t\telse\n\t\t\t*d = DATA;\n\t\t++d;\n\n\t\t/*\n\t\t * The SCSI standard suggests that in MSGOUT phase, the\n\t\t * initiator should drop ATN on the last byte of the message\n\t\t * phase after REQ has been asserted for the handshake but\n\t\t * before the initiator raises ACK.\n\t\t * Don't know how to accomplish this on the ST01/02.\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * XXX\n\t\t * The st01 code doesn't wait for STAT_REQ to be deasserted.\n\t\t * Is this ok?\n\t\t */\n\t\tfor (timeout = 0; timeout < 200000L; timeout++)\n\t\t\tif (!(STATUS & STAT_REQ))\n\t\t\t\tbreak;\n\t\tif (STATUS & STAT_REQ)\n\t\t\tprintf(\"%s: timeout on wait for !STAT_REQ\",\n\t\t\t    sea->sc_dev.dv_xname);\n#endif\n\t} while (--c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = STATUS;\n\tif (tmp & STAT_REQ)\n\t\t*phase = tmp & PH_MASK;\n\telse\n\t\t*phase = PH_INVALID;\n\n\tif (c && (*phase != p))\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
      "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
      "#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */",
      "#define PH_INVALID\t0xff",
      "#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)",
      "#define STAT_REQ\t0x10\t\t/* scsi req */",
      "#define STAT_IO\t\t0x04\t\t/* scsi I/O */"
    ],
    "globals_used": [
      "int sea_transfer_pio",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: timeout on wait for !STAT_REQ\"",
            "sea->sc_dev.dv_xname"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */\n#define PH_INVALID\t0xff\n#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nint\nsea_transfer_pio(sea, phase, count, data)\n\tstruct sea_softc *sea;\n\tu_char *phase;\n\tint *count;\n\tu_char **data;\n{\n\tregister u_char p = *phase, tmp;\n\tregister int c = *count;\n\tregister u_char *d = *data;\n\tint timeout;\n\n\tdo {\n\t\t/*\n\t\t * Wait for assertion of REQ, after which the phase bits will\n\t\t * be valid.\n\t\t */\n\t\tfor (timeout = 0; timeout < 50000; timeout++)\n\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\tbreak;\n\t\tif (!(tmp & STAT_REQ)) {\n\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check for phase mismatch.  Reached if the target decides\n\t\t * that it has finished the transfer.\n\t\t */\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tif ((tmp & PH_MASK) != p)\n\t\t\tbreak;\n\n\t\t/* Do actual transfer from SCSI bus to/from memory. */\n\t\tif (!(p & STAT_IO))\n\t\t\tDATA = *d;\n\t\telse\n\t\t\t*d = DATA;\n\t\t++d;\n\n\t\t/*\n\t\t * The SCSI standard suggests that in MSGOUT phase, the\n\t\t * initiator should drop ATN on the last byte of the message\n\t\t * phase after REQ has been asserted for the handshake but\n\t\t * before the initiator raises ACK.\n\t\t * Don't know how to accomplish this on the ST01/02.\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * XXX\n\t\t * The st01 code doesn't wait for STAT_REQ to be deasserted.\n\t\t * Is this ok?\n\t\t */\n\t\tfor (timeout = 0; timeout < 200000L; timeout++)\n\t\t\tif (!(STATUS & STAT_REQ))\n\t\t\t\tbreak;\n\t\tif (STATUS & STAT_REQ)\n\t\t\tprintf(\"%s: timeout on wait for !STAT_REQ\",\n\t\t\t    sea->sc_dev.dv_xname);\n#endif\n\t} while (--c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = STATUS;\n\tif (tmp & STAT_REQ)\n\t\t*phase = tmp & PH_MASK;\n\telse\n\t\t*phase = PH_INVALID;\n\n\tif (c && (*phase != p))\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "sea_reselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "837-929",
    "snippet": "void\nsea_reselect(sea)\n\tstruct sea_softc *sea;\n{\n\tu_char target_mask;\n\tint i;\n\tu_char lun, phase;\n\tu_char msg[3];\n\tint len;\n\tu_char *data;\n\tstruct sea_scb *scb;\n\tint abort = 0;\n  \n\tif (!((target_mask = STATUS) & STAT_SEL)) {\n\t\tprintf(\"%s: wrong state 0x%x\\n\", sea->sc_dev.dv_xname,\n\t\t    target_mask);\n\t\treturn;\n\t}\n\n\t/* wait for a device to win the reselection phase */\n\t/* signals this by asserting the I/O signal */\n\tfor (i = 10; i && (STATUS & (STAT_SEL | STAT_IO | STAT_BSY)) !=\n\t    (STAT_SEL | STAT_IO | 0); i--);\n\t/* !! Check for timeout here */\n\t/* the data bus contains original initiator id ORed with target id */\n\ttarget_mask = DATA;\n\t/* see that we really are the initiator */\n\tif (!(target_mask & sea->our_id_mask)) {\n\t\tprintf(\"%s: polled reselection was not for me: 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, target_mask);\n\t\treturn;\n\t}\n\t/* find target who won */\n\ttarget_mask &= ~sea->our_id_mask;\n\t/* host responds by asserting the BSY signal */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE | CMD_BSY;\n\t/* target should respond by deasserting the SEL signal */\n\tfor (i = 50000; i && (STATUS & STAT_SEL); i++);\n\t/* remove the busy status */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* we are connected. Now we wait for the MSGIN condition */\n\tfor (i = 50000; i && !(STATUS & STAT_REQ); i--);\n\t/* !! Add timeout check here */\n\t/* hope we get an IDENTIFY message */\n\tlen = 3;\n\tdata = msg;\n\tphase = PH_MSGIN;\n\tsea_transfer_pio(sea, &phase, &len, &data); \n\n\tif (MSG_ISIDENTIFY(msg[0])) {\n\t\tprintf(\"%s: expecting IDENTIFY message, got 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, msg[0]);\n\t\tabort = 1;\n\t\tscb = NULL;\n\t} else {\n\t\tlun = msg[0] & 0x07;\n\n\t\t/*\n\t\t * Find the command corresponding to the I_T_L or I_T_L_Q nexus\n\t\t * we just reestablished, and remove it from the disconnected\n\t\t * queue.\n\t\t */\n\t\tfor (scb = sea->nexus_list.tqh_first; scb;\n\t\t    scb = scb->chain.tqe_next)\n\t\t\tif (target_mask == (1 << scb->xs->sc_link->target) &&\n\t\t\t    lun == scb->xs->sc_link->lun) {\n\t\t\t\tTAILQ_REMOVE(&sea->nexus_list, scb,\n\t\t\t\t    chain);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!scb) {\n\t\t\tprintf(\"%s: target %02x lun %d not disconnected\\n\",\n\t\t\t    sea->sc_dev.dv_xname, target_mask, lun);\n\t\t\t/*\n\t\t\t * Since we have an established nexus that we can't do\n\t\t\t * anything with, we must abort it.\n\t\t\t */\n\t\t\tabort = 1;\n\t\t}\n\t}\n\n\tif (abort) {\n\t\tmsg[0] = MSG_ABORT;\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t} else\n\t\tsea->nexus = scb;\n\n\treturn;\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
      "#define CONTROL\tSTATUS",
      "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
      "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
      "#define PH_MSGIN\t(STAT_MSG | STAT_CD | STAT_IO)",
      "#define PH_MSGOUT\t(STAT_MSG | STAT_CD)",
      "#define STAT_SEL\t0x20\t\t/* scsi select */",
      "#define STAT_REQ\t0x10\t\t/* scsi req */",
      "#define STAT_IO\t\t0x04\t\t/* scsi I/O */",
      "#define STAT_BSY\t0x01\t\t/* scsi busy */",
      "#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */",
      "#define\tCMD_ATTN\t0x08\t\t/* scsi attention */",
      "#define CMD_BSY\t\t0x04\t\t/* scsi busy */"
    ],
    "globals_used": [
      "void sea_reselect",
      "int sea_transfer_pio",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sea_transfer_pio",
          "args": [
            "sea",
            "&phase",
            "&len",
            "&data"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "sea_transfer_pio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "934-1012",
          "snippet": "int\nsea_transfer_pio(sea, phase, count, data)\n\tstruct sea_softc *sea;\n\tu_char *phase;\n\tint *count;\n\tu_char **data;\n{\n\tregister u_char p = *phase, tmp;\n\tregister int c = *count;\n\tregister u_char *d = *data;\n\tint timeout;\n\n\tdo {\n\t\t/*\n\t\t * Wait for assertion of REQ, after which the phase bits will\n\t\t * be valid.\n\t\t */\n\t\tfor (timeout = 0; timeout < 50000; timeout++)\n\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\tbreak;\n\t\tif (!(tmp & STAT_REQ)) {\n\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check for phase mismatch.  Reached if the target decides\n\t\t * that it has finished the transfer.\n\t\t */\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tif ((tmp & PH_MASK) != p)\n\t\t\tbreak;\n\n\t\t/* Do actual transfer from SCSI bus to/from memory. */\n\t\tif (!(p & STAT_IO))\n\t\t\tDATA = *d;\n\t\telse\n\t\t\t*d = DATA;\n\t\t++d;\n\n\t\t/*\n\t\t * The SCSI standard suggests that in MSGOUT phase, the\n\t\t * initiator should drop ATN on the last byte of the message\n\t\t * phase after REQ has been asserted for the handshake but\n\t\t * before the initiator raises ACK.\n\t\t * Don't know how to accomplish this on the ST01/02.\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * XXX\n\t\t * The st01 code doesn't wait for STAT_REQ to be deasserted.\n\t\t * Is this ok?\n\t\t */\n\t\tfor (timeout = 0; timeout < 200000L; timeout++)\n\t\t\tif (!(STATUS & STAT_REQ))\n\t\t\t\tbreak;\n\t\tif (STATUS & STAT_REQ)\n\t\t\tprintf(\"%s: timeout on wait for !STAT_REQ\",\n\t\t\t    sea->sc_dev.dv_xname);\n#endif\n\t} while (--c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = STATUS;\n\tif (tmp & STAT_REQ)\n\t\t*phase = tmp & PH_MASK;\n\telse\n\t\t*phase = PH_INVALID;\n\n\tif (c && (*phase != p))\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */",
            "#define PH_INVALID\t0xff",
            "#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)",
            "#define STAT_REQ\t0x10\t\t/* scsi req */",
            "#define STAT_IO\t\t0x04\t\t/* scsi I/O */"
          ],
          "globals_used": [
            "int sea_transfer_pio",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */\n#define PH_INVALID\t0xff\n#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nint\nsea_transfer_pio(sea, phase, count, data)\n\tstruct sea_softc *sea;\n\tu_char *phase;\n\tint *count;\n\tu_char **data;\n{\n\tregister u_char p = *phase, tmp;\n\tregister int c = *count;\n\tregister u_char *d = *data;\n\tint timeout;\n\n\tdo {\n\t\t/*\n\t\t * Wait for assertion of REQ, after which the phase bits will\n\t\t * be valid.\n\t\t */\n\t\tfor (timeout = 0; timeout < 50000; timeout++)\n\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\tbreak;\n\t\tif (!(tmp & STAT_REQ)) {\n\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check for phase mismatch.  Reached if the target decides\n\t\t * that it has finished the transfer.\n\t\t */\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tif ((tmp & PH_MASK) != p)\n\t\t\tbreak;\n\n\t\t/* Do actual transfer from SCSI bus to/from memory. */\n\t\tif (!(p & STAT_IO))\n\t\t\tDATA = *d;\n\t\telse\n\t\t\t*d = DATA;\n\t\t++d;\n\n\t\t/*\n\t\t * The SCSI standard suggests that in MSGOUT phase, the\n\t\t * initiator should drop ATN on the last byte of the message\n\t\t * phase after REQ has been asserted for the handshake but\n\t\t * before the initiator raises ACK.\n\t\t * Don't know how to accomplish this on the ST01/02.\n\t\t */\n\n#if 0\n\t\t/*\n\t\t * XXX\n\t\t * The st01 code doesn't wait for STAT_REQ to be deasserted.\n\t\t * Is this ok?\n\t\t */\n\t\tfor (timeout = 0; timeout < 200000L; timeout++)\n\t\t\tif (!(STATUS & STAT_REQ))\n\t\t\t\tbreak;\n\t\tif (STATUS & STAT_REQ)\n\t\t\tprintf(\"%s: timeout on wait for !STAT_REQ\",\n\t\t\t    sea->sc_dev.dv_xname);\n#endif\n\t} while (--c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = STATUS;\n\tif (tmp & STAT_REQ)\n\t\t*phase = tmp & PH_MASK;\n\telse\n\t\t*phase = PH_INVALID;\n\n\tif (c && (*phase != p))\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: target %02x lun %d not disconnected\\n\"",
            "sea->sc_dev.dv_xname",
            "target_mask",
            "lun"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sea->nexus_list",
            "scb",
            "chain"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSG_ISIDENTIFY",
          "args": [
            "msg[0]"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define CONTROL\tSTATUS\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define PH_MSGIN\t(STAT_MSG | STAT_CD | STAT_IO)\n#define PH_MSGOUT\t(STAT_MSG | STAT_CD)\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n#define STAT_BSY\t0x01\t\t/* scsi busy */\n#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */\n#define\tCMD_ATTN\t0x08\t\t/* scsi attention */\n#define CMD_BSY\t\t0x04\t\t/* scsi busy */\n\nvoid sea_reselect;\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_reselect(sea)\n\tstruct sea_softc *sea;\n{\n\tu_char target_mask;\n\tint i;\n\tu_char lun, phase;\n\tu_char msg[3];\n\tint len;\n\tu_char *data;\n\tstruct sea_scb *scb;\n\tint abort = 0;\n  \n\tif (!((target_mask = STATUS) & STAT_SEL)) {\n\t\tprintf(\"%s: wrong state 0x%x\\n\", sea->sc_dev.dv_xname,\n\t\t    target_mask);\n\t\treturn;\n\t}\n\n\t/* wait for a device to win the reselection phase */\n\t/* signals this by asserting the I/O signal */\n\tfor (i = 10; i && (STATUS & (STAT_SEL | STAT_IO | STAT_BSY)) !=\n\t    (STAT_SEL | STAT_IO | 0); i--);\n\t/* !! Check for timeout here */\n\t/* the data bus contains original initiator id ORed with target id */\n\ttarget_mask = DATA;\n\t/* see that we really are the initiator */\n\tif (!(target_mask & sea->our_id_mask)) {\n\t\tprintf(\"%s: polled reselection was not for me: 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, target_mask);\n\t\treturn;\n\t}\n\t/* find target who won */\n\ttarget_mask &= ~sea->our_id_mask;\n\t/* host responds by asserting the BSY signal */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE | CMD_BSY;\n\t/* target should respond by deasserting the SEL signal */\n\tfor (i = 50000; i && (STATUS & STAT_SEL); i++);\n\t/* remove the busy status */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* we are connected. Now we wait for the MSGIN condition */\n\tfor (i = 50000; i && !(STATUS & STAT_REQ); i--);\n\t/* !! Add timeout check here */\n\t/* hope we get an IDENTIFY message */\n\tlen = 3;\n\tdata = msg;\n\tphase = PH_MSGIN;\n\tsea_transfer_pio(sea, &phase, &len, &data); \n\n\tif (MSG_ISIDENTIFY(msg[0])) {\n\t\tprintf(\"%s: expecting IDENTIFY message, got 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, msg[0]);\n\t\tabort = 1;\n\t\tscb = NULL;\n\t} else {\n\t\tlun = msg[0] & 0x07;\n\n\t\t/*\n\t\t * Find the command corresponding to the I_T_L or I_T_L_Q nexus\n\t\t * we just reestablished, and remove it from the disconnected\n\t\t * queue.\n\t\t */\n\t\tfor (scb = sea->nexus_list.tqh_first; scb;\n\t\t    scb = scb->chain.tqe_next)\n\t\t\tif (target_mask == (1 << scb->xs->sc_link->target) &&\n\t\t\t    lun == scb->xs->sc_link->lun) {\n\t\t\t\tTAILQ_REMOVE(&sea->nexus_list, scb,\n\t\t\t\t    chain);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!scb) {\n\t\t\tprintf(\"%s: target %02x lun %d not disconnected\\n\",\n\t\t\t    sea->sc_dev.dv_xname, target_mask, lun);\n\t\t\t/*\n\t\t\t * Since we have an established nexus that we can't do\n\t\t\t * anything with, we must abort it.\n\t\t\t */\n\t\t\tabort = 1;\n\t\t}\n\t}\n\n\tif (abort) {\n\t\tmsg[0] = MSG_ABORT;\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t} else\n\t\tsea->nexus = scb;\n\n\treturn;\n}"
  },
  {
    "function_name": "sea_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "798-835",
    "snippet": "void\nsea_timeout(arg)\n\tvoid *arg;\n{\n\tstruct sea_scb *scb = arg;\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct sea_softc *sea = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t \tscb->xs->retries = 0;\n\t\tscb->flags |= SCB_ABORTED;\n\t\tsea_done(sea, scb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->flags |= SCB_ABORTED;\n\t\tsea_abort(sea, scb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(sea_timeout, scb, 2 * hz);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define SCB_ABORTED\t2"
    ],
    "globals_used": [
      "void sea_timeout",
      "void sea_done",
      "int sea_abort",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "sea_timeout",
            "scb",
            "2 * hz"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "sea_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "798-835",
          "snippet": "void\nsea_timeout(arg)\n\tvoid *arg;\n{\n\tstruct sea_scb *scb = arg;\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct sea_softc *sea = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t \tscb->xs->retries = 0;\n\t\tscb->flags |= SCB_ABORTED;\n\t\tsea_done(sea, scb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->flags |= SCB_ABORTED;\n\t\tsea_abort(sea, scb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(sea_timeout, scb, 2 * hz);\n\t}\n\n\tsplx(s);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sea_abort",
          "args": [
            "sea",
            "scb"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "sea_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "1116-1175",
          "snippet": "int\nsea_abort(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tstruct sea_scb *tmp;\n\tu_char msg, phase, *msgptr;\n\tint len;\n\n\t/*\n\t * If the command hasn't been issued yet, we simply remove it from the\n\t * issue queue\n\t * XXX Could avoid this loop.\n\t */\n\tfor (tmp = sea->ready_list.tqh_first; tmp; tmp = tmp->chain.tqe_next)\n\t\tif (scb == tmp) {\n\t\t\tTAILQ_REMOVE(&sea->ready_list, scb, chain);\n\t\t\t/* XXX Set some type of error result for operation. */\n\t\t\treturn 1;\n\t\t}\n\n\t/*\n\t * If any commands are connected, we're going to fail the abort and let\n\t * the high level SCSI driver retry at a later time or issue a reset.\n\t */\n\tif (sea->nexus)\n\t\treturn 0;\n\n\t/*\n\t * If the command is currently disconnected from the bus, and there are\n\t * no connected commands, we reconnect the I_T_L or I_T_L_Q nexus\n\t * associated with it, go into message out, and send an abort message.\n\t */\n\tfor (tmp = sea->nexus_list.tqh_first; tmp;\n\t    tmp = tmp->chain.tqe_next)\n\t\tif (scb == tmp) {\n\t\t\tif (sea_select(sea, scb))\n\t\t\t\treturn 0;\n\n\t\t\tmsg = MSG_ABORT;\n\t\t\tmsgptr = &msg;\n\t\t\tlen = 1;\n\t\t\tphase = PH_MSGOUT;\n\t\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &msgptr);\n\n\t\t\tfor (tmp = sea->nexus_list.tqh_first; tmp;\n\t\t\t    tmp = tmp->chain.tqe_next)\n\t\t\t\tif (scb == tmp) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->nexus_list,\n\t\t\t\t\t    scb, chain);\n\t\t\t\t\t/* XXX Set some type of error result\n\t\t\t\t\t   for the operation. */\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t}\n\n\t/* Command not found in any queue; race condition? */\n\treturn 1;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define CONTROL\tSTATUS",
            "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
            "#define PH_MSGOUT\t(STAT_MSG | STAT_CD)",
            "#define\tCMD_ATTN\t0x08\t\t/* scsi attention */"
          ],
          "globals_used": [
            "int sea_select",
            "int sea_transfer_pio",
            "int sea_abort",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define CONTROL\tSTATUS\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define PH_MSGOUT\t(STAT_MSG | STAT_CD)\n#define\tCMD_ATTN\t0x08\t\t/* scsi attention */\n\nint sea_select;\nint sea_transfer_pio;\nint sea_abort;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nint\nsea_abort(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tstruct sea_scb *tmp;\n\tu_char msg, phase, *msgptr;\n\tint len;\n\n\t/*\n\t * If the command hasn't been issued yet, we simply remove it from the\n\t * issue queue\n\t * XXX Could avoid this loop.\n\t */\n\tfor (tmp = sea->ready_list.tqh_first; tmp; tmp = tmp->chain.tqe_next)\n\t\tif (scb == tmp) {\n\t\t\tTAILQ_REMOVE(&sea->ready_list, scb, chain);\n\t\t\t/* XXX Set some type of error result for operation. */\n\t\t\treturn 1;\n\t\t}\n\n\t/*\n\t * If any commands are connected, we're going to fail the abort and let\n\t * the high level SCSI driver retry at a later time or issue a reset.\n\t */\n\tif (sea->nexus)\n\t\treturn 0;\n\n\t/*\n\t * If the command is currently disconnected from the bus, and there are\n\t * no connected commands, we reconnect the I_T_L or I_T_L_Q nexus\n\t * associated with it, go into message out, and send an abort message.\n\t */\n\tfor (tmp = sea->nexus_list.tqh_first; tmp;\n\t    tmp = tmp->chain.tqe_next)\n\t\tif (scb == tmp) {\n\t\t\tif (sea_select(sea, scb))\n\t\t\t\treturn 0;\n\n\t\t\tmsg = MSG_ABORT;\n\t\t\tmsgptr = &msg;\n\t\t\tlen = 1;\n\t\t\tphase = PH_MSGOUT;\n\t\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &msgptr);\n\n\t\t\tfor (tmp = sea->nexus_list.tqh_first; tmp;\n\t\t\t    tmp = tmp->chain.tqe_next)\n\t\t\t\tif (scb == tmp) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->nexus_list,\n\t\t\t\t\t    scb, chain);\n\t\t\t\t\t/* XXX Set some type of error result\n\t\t\t\t\t   for the operation. */\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t}\n\n\t/* Command not found in any queue; race condition? */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sea_done",
          "args": [
            "sea",
            "scb"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "sea_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "1177-1200",
          "snippet": "void\nsea_done(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\n\tuntimeout(sea_timeout, scb);\n\n\txs->resid = scb->datalen;\n\n\t/* XXXX need to get status */\n\tif (scb->flags == SCB_ACTIVE) {\n\t\txs->resid = 0;\n\t} else {\n\t\tif (scb->flags & (SCB_TIMEOUT | SCB_ABORTED))\n\t\t\txs->error = XS_TIMEOUT;\n\t\tif (scb->flags & SCB_ERROR)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t}\n\txs->flags |= ITSDONE;\n\tsea_free_scb(sea, scb, xs->flags);\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SCB_ERROR\t8",
            "#define SCB_TIMEOUT\t4",
            "#define SCB_ABORTED\t2",
            "#define\tSCB_ACTIVE\t1"
          ],
          "globals_used": [
            "void sea_timeout",
            "void sea_done",
            "void sea_free_scb",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define SCB_ERROR\t8\n#define SCB_TIMEOUT\t4\n#define SCB_ABORTED\t2\n#define\tSCB_ACTIVE\t1\n\nvoid sea_timeout;\nvoid sea_done;\nvoid sea_free_scb;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nvoid\nsea_done(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tstruct scsi_xfer *xs = scb->xs;\n\n\tuntimeout(sea_timeout, scb);\n\n\txs->resid = scb->datalen;\n\n\t/* XXXX need to get status */\n\tif (scb->flags == SCB_ACTIVE) {\n\t\txs->resid = 0;\n\t} else {\n\t\tif (scb->flags & (SCB_TIMEOUT | SCB_ABORTED))\n\t\t\txs->error = XS_TIMEOUT;\n\t\tif (scb->flags & SCB_ERROR)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t}\n\txs->flags |= ITSDONE;\n\tsea_free_scb(sea, scb, xs->flags);\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define SCB_ABORTED\t2\n\nvoid sea_timeout;\nvoid sea_done;\nint sea_abort;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nvoid\nsea_timeout(arg)\n\tvoid *arg;\n{\n\tstruct sea_scb *scb = arg;\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct sea_softc *sea = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t \tscb->xs->retries = 0;\n\t\tscb->flags |= SCB_ABORTED;\n\t\tsea_done(sea, scb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->flags |= SCB_ABORTED;\n\t\tsea_abort(sea, scb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(sea_timeout, scb, 2 * hz);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "sea_free_scb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "775-796",
    "snippet": "void\nsea_free_scb(sea, scb, flags)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tscb->flags = SCB_FREE;\n\tTAILQ_INSERT_HEAD(&sea->free_list, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (!scb->chain.tqe_next)\n\t\twakeup((caddr_t)&sea->free_list);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tSCB_FREE\t0"
    ],
    "globals_used": [
      "void sea_free_scb",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t)&sea->free_list"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sea->free_list",
            "scb",
            "chain"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tSCB_FREE\t0\n\nvoid sea_free_scb;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nvoid\nsea_free_scb(sea, scb, flags)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tscb->flags = SCB_FREE;\n\tTAILQ_INSERT_HEAD(&sea->free_list, scb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (!scb->chain.tqe_next)\n\t\twakeup((caddr_t)&sea->free_list);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "sea_main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "678-773",
    "snippet": "void\nsea_main()\n{\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint done;\n\tint unit;\n\tint s;\n\n\tmain_running = 1;\n\n\t/*\n\t * This should not be run with interrupts disabled, but use the splx\n\t * code instead.\n\t */\nloop:\n\tdone = 1;\n\tfor (unit = 0; unit < sea_cd.cd_ndevs; unit++) {\n\t\tsea = sea_cd.cd_devs[unit];\n\t\tif (!sea)\n\t\t\tcontinue;\n\t\ts = splbio();\n\t\tif (!sea->nexus) {\n\t\t\t/*\n\t\t\t * Search through the ready_list for a command\n\t\t\t * destined for a target that's not busy.\n\t\t\t */\n\t\t\tfor (scb = sea->ready_list.tqh_first; scb;\n\t\t\t    scb = scb->chain.tqe_next) {\n\t\t\t\tif (!(sea->busy[scb->xs->sc_link->target] &\n\t\t\t\t    (1 << scb->xs->sc_link->lun))) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->ready_list, scb,\n\t\t\t\t\t    chain);\n\t    \n\t\t\t\t\t/* Re-enable interrupts. */\n\t\t\t\t\tsplx(s);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to establish an I_T_L nexus.\n\t\t\t\t\t * On success, sea->nexus is set.\n\t\t\t\t\t * On failure, we must add the command\n\t\t\t\t\t * back to the issue queue so we can\n\t\t\t\t\t * keep trying.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * REQUEST_SENSE commands are issued\n\t\t\t\t\t * without tagged queueing, even on\n\t\t\t\t\t * SCSI-II devices because the\n\t\t\t\t\t * contingent alligence condition\n\t\t\t\t\t * exists for the entire unit.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * First check that if any device has\n\t\t\t\t\t * tried a reconnect while we have done\n\t\t\t\t\t * other things with interrupts\n\t\t\t\t\t * disabled.\n\t\t\t\t\t */\n\n\t\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sea_select(sea, scb)) {\n\t\t\t\t\t\ts = splbio();\n\t\t\t\t\t\tTAILQ_INSERT_HEAD(&sea->ready_list,\n\t\t\t\t\t\t    scb, chain);\n\t\t\t\t\t\tsplx(s);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t} /* if target/lun is not busy */\n\t\t\t} /* for scb */\n\t\t\tif (!sea->nexus) {\n\t\t\t\t/* check for reselection phase */\n\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* if (!sea->nexus) */\n      \n\t\tsplx(s);\n\t\tif (sea->nexus) {\t/* we are connected. Do the task */\n\t\t\tsea_information_transfer(sea);\n\t\t\tdone = 0;\n\t\t} else\n\t\t\tbreak;\n\t} /* for instance */\n\n\tif (!done)\n\t\tgoto loop;\n\n\tmain_running = 0;\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
      "#define STAT_SEL\t0x20\t\t/* scsi select */",
      "#define STAT_IO\t\t0x04\t\t/* scsi I/O */"
    ],
    "globals_used": [
      "static volatile int main_running = 0;",
      "static void sea_main",
      "static void sea_information_transfer",
      "void sea_reselect",
      "int sea_select",
      "struct cfdriver sea_cd = {\n\tNULL, \"sea\", DV_DULL\n};",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sea_information_transfer",
          "args": [
            "sea"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "sea_information_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "1231-1446",
          "snippet": "void\nsea_information_transfer(sea)\n\tstruct sea_softc *sea;\n{\n\tint timeout;\n\tu_char msgout = MSG_NOOP;\n\tint len;\n\tint s;\n\tu_char *data;\n\tu_char phase, tmp, old_phase = PH_INVALID;\n\tstruct sea_scb *scb = sea->nexus;\n\tint loop;\n\n\tfor (timeout = 0; timeout < 10000000L; timeout++) {\n\t\ttmp = STATUS;\n\t\tif (tmp & STAT_PARITY)\n\t\t\tprintf(\"%s: parity error detected\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\tif (!(tmp & STAT_BSY)) {\n\t\t\tfor (loop = 0; loop < 20; loop++)\n\t\t\t\tif ((tmp = STATUS) & STAT_BSY)\n\t\t\t\t\tbreak;\n\t\t\tif (!(tmp & STAT_BSY)) {\n\t\t\t\tprintf(\"%s: !STAT_BSY unit in data transfer!\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\ts = splbio();\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tscb->flags = SCB_ERROR;\n\t\t\t\tsplx(s);\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* we only have a valid SCSI phase when REQ is asserted */\n\t\tif (!(tmp & STAT_REQ))\n\t\t\tcontinue;\n\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tphase = tmp & PH_MASK;\n\t\tif (phase != old_phase)\n\t\t\told_phase = phase;\n\n\t\tswitch (phase) {\n\t\tcase PH_DATAOUT:\n#ifdef SEA_NODATAOUT\n\t\t\tprintf(\"%s: SEA_NODATAOUT set, attempted DATAOUT aborted\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tmsgout = MSG_ABORT;\n\t\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\t\tbreak;\n#endif\n\t\tcase PH_DATAIN:\n\t\t\tif (!scb->data)\n\t\t\t\tprintf(\"no data address!\\n\");\n#ifdef SEA_BLINDTRANSFER\n\t\t\tif (scb->datalen && !(scb->datalen % BLOCK_SIZE)) {\n\t\t\t\twhile (scb->datalen) {\n\t\t\t\t\tfor (loop = 0; loop < 50000; loop++)\n\t\t\t\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!(tmp & STAT_REQ)) {\n\t\t\t\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\t\t\t/* XXX Do something? */\n\t\t\t\t\t}\n\t\t\t\t\tif (sea->type == FDOMAIN840)\n\t\t\t\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t\t\t\t       (tmp & 0xf5);\n\t\t\t\t\tif ((tmp & PH_MASK) != phase)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!(phase & STAT_IO)) {\n\t\t\t\t\t\tint block = BLOCK_SIZE; \n\t\t\t\t\t\tvoid *a = sea->maddr_dr;\n#ifdef SEA_ASSEMBLER\n\t\t\t\t\t\tasm(\"shr $2, %%ecx\\n\\t\\\n\t\t\t\t\t\t    cld\\n\\t\\\n\t\t\t\t\t\t    rep\\n\\t\\\n\t\t\t\t\t\t    movsl\" :\n\t\t\t\t\t\t    \"=S\" (scb->data), \n\t\t\t\t\t\t\t\"=c\" (block) ,\n\t\t\t\t\t\t    \"=D\" (a) :\n\t\t\t\t\t\t    \"0\" (scb->data),\n\t\t\t\t\t\t    \"2\" (a),\n\t\t\t\t\t\t    \"1\" (block) );\n#else\n\t\t\t\t\t\tfor (count = 0;\n\t\t\t\t\t\t    count < BLOCK_SIZE;\n\t\t\t\t\t\t    count++)\n\t\t\t\t\t\t\tDATA = *(scb->data++);\n#endif\n\t\t\t\t\t} else { \n\t\t\t\t\t\tint block = BLOCK_SIZE;\n\t\t\t\t\t\tvoid *a = sea->maddr_dr;\n#ifdef SEA_ASSEMBLER\n\t\t\t\t\t\tasm(\"shr $2, %%ecx\\n\\t\\\n\t\t\t\t\t\t    cld\\n\\t\\\n\t\t\t\t\t\t    rep\\n\\t\\\n\t\t\t\t\t\t    movsl\" :\n\t\t\t\t\t\t    \"=D\" (scb->data), \"=c\" (block) ,\n\t\t\t\t\t\t    \"=S\" (a) :\n\t\t\t\t\t\t    \"0\" (scb->data),\n\t\t\t\t\t\t\t\"2\" (a) ,\n\t\t\t\t\t\t    \"1\" (block) );\n#else\n\t\t\t\t\t        for (count = 0;\n\t\t\t\t\t\t    count < BLOCK_SIZE;\n\t\t\t\t\t\t    count++)\n\t\t\t\t\t\t\t*(scb->data++) = DATA;\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tscb->datalen -= BLOCK_SIZE;\n\t\t\t\t}\n\t\t\t}\n#endif \n\t\t\tif (scb->datalen)\n\t\t\t\tsea_transfer_pio(sea, &phase, &scb->datalen,\n\t\t\t\t    &scb->data);\n\t\t\tbreak;\n\t\tcase PH_MSGIN:\n\t\t\t/* Multibyte messages should not be present here. */\n\t\t\tlen = 1;\n\t\t\tdata = &tmp;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\t/* scb->MessageIn = tmp; */\n\n\t\t\tswitch (tmp) {\n\t\t\tcase MSG_ABORT:\n\t\t\t\tscb->flags = SCB_ABORTED;\n\t\t\t\tprintf(\"sea: command aborted by target\\n\");\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\tcase MSG_CMDCOMPLETE:\n\t\t\t\ts = splbio();\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tsplx(s);\n\t\t\t\tsea->busy[scb->xs->sc_link->target] &= \n\t\t\t\t    ~(1 << scb->xs->sc_link->lun);\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\tcase MSG_MESSAGE_REJECT:\n\t\t\t\tprintf(\"%s: message_reject recieved\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\tbreak;\n\t\t\tcase MSG_DISCONNECT:\n\t\t\t\ts = splbio();\n\t\t\t\tTAILQ_INSERT_TAIL(&sea->nexus_list,\n\t\t\t\t    scb, chain);\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsplx(s);\n\t\t\t\treturn;\n\t\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tcase MSG_RESTOREPOINTERS:\n\t\t\t\t/* save/restore of pointers are ignored */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * This should be handled in the pio data\n\t\t\t\t * transfer phase, as the ATN should be raised\n\t\t\t\t * before ACK goes false when rejecting a\n\t\t\t\t * message.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: unknown message in: %x\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname, tmp);\n\t\t\t\tbreak;\n\t\t\t} /* switch (tmp) */\n\t\t\tbreak;\n\t\tcase PH_MSGOUT:\n\t\t\tlen = 1;\n\t\t\tdata = &msgout;\n\t\t\t/* sea->last_message = msgout; */\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tif (msgout == MSG_ABORT) {\n\t\t\t\tprintf(\"%s: sent message abort to target\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\ts = splbio();\n\t\t\t\tsea->busy[scb->xs->sc_link->target] &= \n\t\t\t\t    ~(1 << scb->xs->sc_link->lun);\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tscb->flags = SCB_ABORTED;\n\t\t\t\tsplx(s); \n\t\t\t\t/* enable interrupt from scsi */\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmsgout = MSG_NOOP;\n\t\t\tbreak;\n\t\tcase PH_CMD:\n\t\t\tlen = scb->xs->cmdlen;\n\t\t\tdata = (char *) scb->xs->cmd;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tbreak;\n\t\tcase PH_STAT:\n\t\t\tlen = 1;\n\t\t\tdata = &tmp;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tscb->xs->status = tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"sea: unknown phase\\n\");\n\t\t} /* switch (phase) */\n\t} /* for (...) */\n\n\t/* If we get here we have got a timeout! */\n\tprintf(\"%s: timeout in data transfer\\n\", sea->sc_dev.dv_xname);\n\tscb->flags = SCB_TIMEOUT;\n\t/* XXX Should I clear scsi-bus state? */\n\tsea_done(sea, scb);\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
            "#define CONTROL\tSTATUS",
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define SCB_ERROR\t8",
            "#define SCB_TIMEOUT\t4",
            "#define SCB_ABORTED\t2",
            "#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */",
            "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
            "#define PH_INVALID\t0xff",
            "#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)",
            "#define PH_MSGIN\t(STAT_MSG | STAT_CD | STAT_IO)",
            "#define PH_MSGOUT\t(STAT_MSG | STAT_CD)",
            "#define PH_STAT\t\t(STAT_CD | STAT_IO)",
            "#define PH_CMD\t\t(STAT_CD)",
            "#define PH_DATAIN\t(STAT_IO)",
            "#define PH_DATAOUT\t(0)",
            "#define STAT_PARITY\t0x40\t\t/* parity error bit */",
            "#define STAT_REQ\t0x10\t\t/* scsi req */",
            "#define STAT_IO\t\t0x04\t\t/* scsi I/O */",
            "#define STAT_BSY\t0x01\t\t/* scsi busy */",
            "#define\tCMD_ATTN\t0x08\t\t/* scsi attention */",
            "#define\tSEA_ASSEMBLER\t\t/* Use assembly code for fast transfers */",
            "#define\tSEA_BLINDTRANSFER\t/* do blind transfers */",
            "#define BLOCK_SIZE\t512\t/* size of READ/WRITE areas on SCSI card */"
          ],
          "globals_used": [
            "void sea_done",
            "static void sea_information_transfer",
            "int sea_transfer_pio",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define CONTROL\tSTATUS\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define SCB_ERROR\t8\n#define SCB_TIMEOUT\t4\n#define SCB_ABORTED\t2\n#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define PH_INVALID\t0xff\n#define PH_MASK\t\t(STAT_MSG | STAT_CD | STAT_IO)\n#define PH_MSGIN\t(STAT_MSG | STAT_CD | STAT_IO)\n#define PH_MSGOUT\t(STAT_MSG | STAT_CD)\n#define PH_STAT\t\t(STAT_CD | STAT_IO)\n#define PH_CMD\t\t(STAT_CD)\n#define PH_DATAIN\t(STAT_IO)\n#define PH_DATAOUT\t(0)\n#define STAT_PARITY\t0x40\t\t/* parity error bit */\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n#define STAT_BSY\t0x01\t\t/* scsi busy */\n#define\tCMD_ATTN\t0x08\t\t/* scsi attention */\n#define\tSEA_ASSEMBLER\t\t/* Use assembly code for fast transfers */\n#define\tSEA_BLINDTRANSFER\t/* do blind transfers */\n#define BLOCK_SIZE\t512\t/* size of READ/WRITE areas on SCSI card */\n\nvoid sea_done;\nstatic void sea_information_transfer;\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nvoid\nsea_information_transfer(sea)\n\tstruct sea_softc *sea;\n{\n\tint timeout;\n\tu_char msgout = MSG_NOOP;\n\tint len;\n\tint s;\n\tu_char *data;\n\tu_char phase, tmp, old_phase = PH_INVALID;\n\tstruct sea_scb *scb = sea->nexus;\n\tint loop;\n\n\tfor (timeout = 0; timeout < 10000000L; timeout++) {\n\t\ttmp = STATUS;\n\t\tif (tmp & STAT_PARITY)\n\t\t\tprintf(\"%s: parity error detected\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\tif (!(tmp & STAT_BSY)) {\n\t\t\tfor (loop = 0; loop < 20; loop++)\n\t\t\t\tif ((tmp = STATUS) & STAT_BSY)\n\t\t\t\t\tbreak;\n\t\t\tif (!(tmp & STAT_BSY)) {\n\t\t\t\tprintf(\"%s: !STAT_BSY unit in data transfer!\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\ts = splbio();\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tscb->flags = SCB_ERROR;\n\t\t\t\tsplx(s);\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* we only have a valid SCSI phase when REQ is asserted */\n\t\tif (!(tmp & STAT_REQ))\n\t\t\tcontinue;\n\n\t\tif (sea->type == FDOMAIN840)\n\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t       (tmp & 0xf5);\n\t\tphase = tmp & PH_MASK;\n\t\tif (phase != old_phase)\n\t\t\told_phase = phase;\n\n\t\tswitch (phase) {\n\t\tcase PH_DATAOUT:\n#ifdef SEA_NODATAOUT\n\t\t\tprintf(\"%s: SEA_NODATAOUT set, attempted DATAOUT aborted\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tmsgout = MSG_ABORT;\n\t\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\t\tbreak;\n#endif\n\t\tcase PH_DATAIN:\n\t\t\tif (!scb->data)\n\t\t\t\tprintf(\"no data address!\\n\");\n#ifdef SEA_BLINDTRANSFER\n\t\t\tif (scb->datalen && !(scb->datalen % BLOCK_SIZE)) {\n\t\t\t\twhile (scb->datalen) {\n\t\t\t\t\tfor (loop = 0; loop < 50000; loop++)\n\t\t\t\t\t\tif ((tmp = STATUS) & STAT_REQ)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!(tmp & STAT_REQ)) {\n\t\t\t\t\t\tprintf(\"%s: timeout waiting for STAT_REQ\\n\",\n\t\t\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\t\t\t/* XXX Do something? */\n\t\t\t\t\t}\n\t\t\t\t\tif (sea->type == FDOMAIN840)\n\t\t\t\t\t\ttmp = ((tmp & 0x08) >> 2) |\n\t\t\t\t\t\t      ((tmp & 0x02) << 2) |\n\t\t\t\t\t\t       (tmp & 0xf5);\n\t\t\t\t\tif ((tmp & PH_MASK) != phase)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!(phase & STAT_IO)) {\n\t\t\t\t\t\tint block = BLOCK_SIZE; \n\t\t\t\t\t\tvoid *a = sea->maddr_dr;\n#ifdef SEA_ASSEMBLER\n\t\t\t\t\t\tasm(\"shr $2, %%ecx\\n\\t\\\n\t\t\t\t\t\t    cld\\n\\t\\\n\t\t\t\t\t\t    rep\\n\\t\\\n\t\t\t\t\t\t    movsl\" :\n\t\t\t\t\t\t    \"=S\" (scb->data), \n\t\t\t\t\t\t\t\"=c\" (block) ,\n\t\t\t\t\t\t    \"=D\" (a) :\n\t\t\t\t\t\t    \"0\" (scb->data),\n\t\t\t\t\t\t    \"2\" (a),\n\t\t\t\t\t\t    \"1\" (block) );\n#else\n\t\t\t\t\t\tfor (count = 0;\n\t\t\t\t\t\t    count < BLOCK_SIZE;\n\t\t\t\t\t\t    count++)\n\t\t\t\t\t\t\tDATA = *(scb->data++);\n#endif\n\t\t\t\t\t} else { \n\t\t\t\t\t\tint block = BLOCK_SIZE;\n\t\t\t\t\t\tvoid *a = sea->maddr_dr;\n#ifdef SEA_ASSEMBLER\n\t\t\t\t\t\tasm(\"shr $2, %%ecx\\n\\t\\\n\t\t\t\t\t\t    cld\\n\\t\\\n\t\t\t\t\t\t    rep\\n\\t\\\n\t\t\t\t\t\t    movsl\" :\n\t\t\t\t\t\t    \"=D\" (scb->data), \"=c\" (block) ,\n\t\t\t\t\t\t    \"=S\" (a) :\n\t\t\t\t\t\t    \"0\" (scb->data),\n\t\t\t\t\t\t\t\"2\" (a) ,\n\t\t\t\t\t\t    \"1\" (block) );\n#else\n\t\t\t\t\t        for (count = 0;\n\t\t\t\t\t\t    count < BLOCK_SIZE;\n\t\t\t\t\t\t    count++)\n\t\t\t\t\t\t\t*(scb->data++) = DATA;\n#endif\n\t\t\t\t\t}\n\t\t\t\t\tscb->datalen -= BLOCK_SIZE;\n\t\t\t\t}\n\t\t\t}\n#endif \n\t\t\tif (scb->datalen)\n\t\t\t\tsea_transfer_pio(sea, &phase, &scb->datalen,\n\t\t\t\t    &scb->data);\n\t\t\tbreak;\n\t\tcase PH_MSGIN:\n\t\t\t/* Multibyte messages should not be present here. */\n\t\t\tlen = 1;\n\t\t\tdata = &tmp;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\t/* scb->MessageIn = tmp; */\n\n\t\t\tswitch (tmp) {\n\t\t\tcase MSG_ABORT:\n\t\t\t\tscb->flags = SCB_ABORTED;\n\t\t\t\tprintf(\"sea: command aborted by target\\n\");\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\tcase MSG_CMDCOMPLETE:\n\t\t\t\ts = splbio();\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tsplx(s);\n\t\t\t\tsea->busy[scb->xs->sc_link->target] &= \n\t\t\t\t    ~(1 << scb->xs->sc_link->lun);\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\tcase MSG_MESSAGE_REJECT:\n\t\t\t\tprintf(\"%s: message_reject recieved\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\tbreak;\n\t\t\tcase MSG_DISCONNECT:\n\t\t\t\ts = splbio();\n\t\t\t\tTAILQ_INSERT_TAIL(&sea->nexus_list,\n\t\t\t\t    scb, chain);\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tCONTROL = BASE_CMD;\n\t\t\t\tsplx(s);\n\t\t\t\treturn;\n\t\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tcase MSG_RESTOREPOINTERS:\n\t\t\t\t/* save/restore of pointers are ignored */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * This should be handled in the pio data\n\t\t\t\t * transfer phase, as the ATN should be raised\n\t\t\t\t * before ACK goes false when rejecting a\n\t\t\t\t * message.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: unknown message in: %x\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname, tmp);\n\t\t\t\tbreak;\n\t\t\t} /* switch (tmp) */\n\t\t\tbreak;\n\t\tcase PH_MSGOUT:\n\t\t\tlen = 1;\n\t\t\tdata = &msgout;\n\t\t\t/* sea->last_message = msgout; */\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tif (msgout == MSG_ABORT) {\n\t\t\t\tprintf(\"%s: sent message abort to target\\n\",\n\t\t\t\t    sea->sc_dev.dv_xname);\n\t\t\t\ts = splbio();\n\t\t\t\tsea->busy[scb->xs->sc_link->target] &= \n\t\t\t\t    ~(1 << scb->xs->sc_link->lun);\n\t\t\t\tsea->nexus = NULL;\n\t\t\t\tscb->flags = SCB_ABORTED;\n\t\t\t\tsplx(s); \n\t\t\t\t/* enable interrupt from scsi */\n\t\t\t\tsea_done(sea, scb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmsgout = MSG_NOOP;\n\t\t\tbreak;\n\t\tcase PH_CMD:\n\t\t\tlen = scb->xs->cmdlen;\n\t\t\tdata = (char *) scb->xs->cmd;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tbreak;\n\t\tcase PH_STAT:\n\t\t\tlen = 1;\n\t\t\tdata = &tmp;\n\t\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t\t\tscb->xs->status = tmp;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"sea: unknown phase\\n\");\n\t\t} /* switch (phase) */\n\t} /* for (...) */\n\n\t/* If we get here we have got a timeout! */\n\tprintf(\"%s: timeout in data transfer\\n\", sea->sc_dev.dv_xname);\n\tscb->flags = SCB_TIMEOUT;\n\t/* XXX Should I clear scsi-bus state? */\n\tsea_done(sea, scb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sea_reselect",
          "args": [
            "sea"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "sea_reselect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "837-929",
          "snippet": "void\nsea_reselect(sea)\n\tstruct sea_softc *sea;\n{\n\tu_char target_mask;\n\tint i;\n\tu_char lun, phase;\n\tu_char msg[3];\n\tint len;\n\tu_char *data;\n\tstruct sea_scb *scb;\n\tint abort = 0;\n  \n\tif (!((target_mask = STATUS) & STAT_SEL)) {\n\t\tprintf(\"%s: wrong state 0x%x\\n\", sea->sc_dev.dv_xname,\n\t\t    target_mask);\n\t\treturn;\n\t}\n\n\t/* wait for a device to win the reselection phase */\n\t/* signals this by asserting the I/O signal */\n\tfor (i = 10; i && (STATUS & (STAT_SEL | STAT_IO | STAT_BSY)) !=\n\t    (STAT_SEL | STAT_IO | 0); i--);\n\t/* !! Check for timeout here */\n\t/* the data bus contains original initiator id ORed with target id */\n\ttarget_mask = DATA;\n\t/* see that we really are the initiator */\n\tif (!(target_mask & sea->our_id_mask)) {\n\t\tprintf(\"%s: polled reselection was not for me: 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, target_mask);\n\t\treturn;\n\t}\n\t/* find target who won */\n\ttarget_mask &= ~sea->our_id_mask;\n\t/* host responds by asserting the BSY signal */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE | CMD_BSY;\n\t/* target should respond by deasserting the SEL signal */\n\tfor (i = 50000; i && (STATUS & STAT_SEL); i++);\n\t/* remove the busy status */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* we are connected. Now we wait for the MSGIN condition */\n\tfor (i = 50000; i && !(STATUS & STAT_REQ); i--);\n\t/* !! Add timeout check here */\n\t/* hope we get an IDENTIFY message */\n\tlen = 3;\n\tdata = msg;\n\tphase = PH_MSGIN;\n\tsea_transfer_pio(sea, &phase, &len, &data); \n\n\tif (MSG_ISIDENTIFY(msg[0])) {\n\t\tprintf(\"%s: expecting IDENTIFY message, got 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, msg[0]);\n\t\tabort = 1;\n\t\tscb = NULL;\n\t} else {\n\t\tlun = msg[0] & 0x07;\n\n\t\t/*\n\t\t * Find the command corresponding to the I_T_L or I_T_L_Q nexus\n\t\t * we just reestablished, and remove it from the disconnected\n\t\t * queue.\n\t\t */\n\t\tfor (scb = sea->nexus_list.tqh_first; scb;\n\t\t    scb = scb->chain.tqe_next)\n\t\t\tif (target_mask == (1 << scb->xs->sc_link->target) &&\n\t\t\t    lun == scb->xs->sc_link->lun) {\n\t\t\t\tTAILQ_REMOVE(&sea->nexus_list, scb,\n\t\t\t\t    chain);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!scb) {\n\t\t\tprintf(\"%s: target %02x lun %d not disconnected\\n\",\n\t\t\t    sea->sc_dev.dv_xname, target_mask, lun);\n\t\t\t/*\n\t\t\t * Since we have an established nexus that we can't do\n\t\t\t * anything with, we must abort it.\n\t\t\t */\n\t\t\tabort = 1;\n\t\t}\n\t}\n\n\tif (abort) {\n\t\tmsg[0] = MSG_ABORT;\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t} else\n\t\tsea->nexus = scb;\n\n\treturn;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
            "#define CONTROL\tSTATUS",
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
            "#define PH_MSGIN\t(STAT_MSG | STAT_CD | STAT_IO)",
            "#define PH_MSGOUT\t(STAT_MSG | STAT_CD)",
            "#define STAT_SEL\t0x20\t\t/* scsi select */",
            "#define STAT_REQ\t0x10\t\t/* scsi req */",
            "#define STAT_IO\t\t0x04\t\t/* scsi I/O */",
            "#define STAT_BSY\t0x01\t\t/* scsi busy */",
            "#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */",
            "#define\tCMD_ATTN\t0x08\t\t/* scsi attention */",
            "#define CMD_BSY\t\t0x04\t\t/* scsi busy */"
          ],
          "globals_used": [
            "void sea_reselect",
            "int sea_transfer_pio",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define CONTROL\tSTATUS\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define PH_MSGIN\t(STAT_MSG | STAT_CD | STAT_IO)\n#define PH_MSGOUT\t(STAT_MSG | STAT_CD)\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n#define STAT_BSY\t0x01\t\t/* scsi busy */\n#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */\n#define\tCMD_ATTN\t0x08\t\t/* scsi attention */\n#define CMD_BSY\t\t0x04\t\t/* scsi busy */\n\nvoid sea_reselect;\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_reselect(sea)\n\tstruct sea_softc *sea;\n{\n\tu_char target_mask;\n\tint i;\n\tu_char lun, phase;\n\tu_char msg[3];\n\tint len;\n\tu_char *data;\n\tstruct sea_scb *scb;\n\tint abort = 0;\n  \n\tif (!((target_mask = STATUS) & STAT_SEL)) {\n\t\tprintf(\"%s: wrong state 0x%x\\n\", sea->sc_dev.dv_xname,\n\t\t    target_mask);\n\t\treturn;\n\t}\n\n\t/* wait for a device to win the reselection phase */\n\t/* signals this by asserting the I/O signal */\n\tfor (i = 10; i && (STATUS & (STAT_SEL | STAT_IO | STAT_BSY)) !=\n\t    (STAT_SEL | STAT_IO | 0); i--);\n\t/* !! Check for timeout here */\n\t/* the data bus contains original initiator id ORed with target id */\n\ttarget_mask = DATA;\n\t/* see that we really are the initiator */\n\tif (!(target_mask & sea->our_id_mask)) {\n\t\tprintf(\"%s: polled reselection was not for me: 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, target_mask);\n\t\treturn;\n\t}\n\t/* find target who won */\n\ttarget_mask &= ~sea->our_id_mask;\n\t/* host responds by asserting the BSY signal */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE | CMD_BSY;\n\t/* target should respond by deasserting the SEL signal */\n\tfor (i = 50000; i && (STATUS & STAT_SEL); i++);\n\t/* remove the busy status */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* we are connected. Now we wait for the MSGIN condition */\n\tfor (i = 50000; i && !(STATUS & STAT_REQ); i--);\n\t/* !! Add timeout check here */\n\t/* hope we get an IDENTIFY message */\n\tlen = 3;\n\tdata = msg;\n\tphase = PH_MSGIN;\n\tsea_transfer_pio(sea, &phase, &len, &data); \n\n\tif (MSG_ISIDENTIFY(msg[0])) {\n\t\tprintf(\"%s: expecting IDENTIFY message, got 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, msg[0]);\n\t\tabort = 1;\n\t\tscb = NULL;\n\t} else {\n\t\tlun = msg[0] & 0x07;\n\n\t\t/*\n\t\t * Find the command corresponding to the I_T_L or I_T_L_Q nexus\n\t\t * we just reestablished, and remove it from the disconnected\n\t\t * queue.\n\t\t */\n\t\tfor (scb = sea->nexus_list.tqh_first; scb;\n\t\t    scb = scb->chain.tqe_next)\n\t\t\tif (target_mask == (1 << scb->xs->sc_link->target) &&\n\t\t\t    lun == scb->xs->sc_link->lun) {\n\t\t\t\tTAILQ_REMOVE(&sea->nexus_list, scb,\n\t\t\t\t    chain);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!scb) {\n\t\t\tprintf(\"%s: target %02x lun %d not disconnected\\n\",\n\t\t\t    sea->sc_dev.dv_xname, target_mask, lun);\n\t\t\t/*\n\t\t\t * Since we have an established nexus that we can't do\n\t\t\t * anything with, we must abort it.\n\t\t\t */\n\t\t\tabort = 1;\n\t\t}\n\t}\n\n\tif (abort) {\n\t\tmsg[0] = MSG_ABORT;\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t} else\n\t\tsea->nexus = scb;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sea->ready_list",
            "scb",
            "chain"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sea_select",
          "args": [
            "sea",
            "scb"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "sea_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "1020-1111",
          "snippet": "int\nsea_select(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tu_char msg[3], phase;\n\tu_char *data;\n\tint len;\n\tint timeout;\n\n\tCONTROL = BASE_CMD;\n\tDATA = sea->our_id_mask;\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_START_ARB;\n\n\t/* wait for arbitration to complete */\n\tfor (timeout = 0; timeout < 3000000L; timeout++)\n\t\tif (STATUS & STAT_ARB_CMPL)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_ARB_CMPL)) {\n\t\tif (STATUS & STAT_SEL) {\n\t\t\tprintf(\"%s: arbitration lost\\n\", sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_ERROR;\n\t\t} else {\n\t\t\tprintf(\"%s: arbitration timeout\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_TIMEOUT;\n\t\t}\n\t\tCONTROL = BASE_CMD;\n\t\treturn -1;\n\t}\n\n\tdelay(2);\n\tDATA = (u_char)((1 << scb->xs->sc_link->target) | sea->our_id_mask);\n\tCONTROL =\n#ifdef SEA_NOMSGS\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL;\n#else\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL | CMD_ATTN;\n#endif\n\tdelay(1); \n\n\t/* wait for a bsy from target */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_BSY)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_BSY)) {\n\t\t/* should return some error to the higher level driver */\n\t\tCONTROL = BASE_CMD;\n\t\tscb->flags |= SCB_TIMEOUT;\n\t\treturn 0;\n\t}\n\n\t/* Try to make the target to take a message from us */\n#ifdef SEA_NOMSGS\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE;\n#else\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_ATTN;\n#endif\n\tdelay(1);\n  \n\t/* should start a msg_out phase */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_REQ)\n\t\t\tbreak;\n\t/* Remove ATN. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\tif (!(STATUS & STAT_REQ)) {\n\t\t/*\n\t\t * This should not be taken as an error, but more like an\n\t\t * unsupported feature!  Should set a flag indicating that the\n\t\t * target don't support messages, and continue without failure.\n\t\t * (THIS IS NOT AN ERROR!)\n\t\t */\n\t} else {\n\t\tmsg[0] = MSG_IDENTIFY(scb->xs->sc_link->lun, 1);\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\t/* Should do test on result of sea_transfer_pio(). */\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t}\n\tif (!(STATUS & STAT_BSY))\n\t\tprintf(\"%s: after successful arbitrate: no STAT_BSY!\\n\",\n\t\t    sea->sc_dev.dv_xname);\n  \n\tsea->nexus = scb;\n\tsea->busy[scb->xs->sc_link->target] |= 1 << scb->xs->sc_link->lun;\n\t/* This assignment should depend on possibility to send a message to target. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* XXX Reset pointer in command? */\n\treturn 0;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
            "#define CONTROL\tSTATUS",
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define SCB_ERROR\t8",
            "#define SCB_TIMEOUT\t4",
            "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
            "#define PH_MSGOUT\t(STAT_MSG | STAT_CD)",
            "#define STAT_ARB_CMPL\t0x80\t\t/* arbitration complete bit */",
            "#define STAT_SEL\t0x20\t\t/* scsi select */",
            "#define STAT_REQ\t0x10\t\t/* scsi req */",
            "#define STAT_BSY\t0x01\t\t/* scsi busy */",
            "#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */",
            "#define CMD_INTR\t0x40\t\t/* enable scsi interrupts */",
            "#define CMD_START_ARB\t0x10\t\t/* start arbitration bit */",
            "#define\tCMD_ATTN\t0x08\t\t/* scsi attention */",
            "#define CMD_SEL\t\t0x02\t\t/* scsi select */"
          ],
          "globals_used": [
            "int sea_select",
            "int sea_transfer_pio",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define CONTROL\tSTATUS\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define SCB_ERROR\t8\n#define SCB_TIMEOUT\t4\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define PH_MSGOUT\t(STAT_MSG | STAT_CD)\n#define STAT_ARB_CMPL\t0x80\t\t/* arbitration complete bit */\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_BSY\t0x01\t\t/* scsi busy */\n#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */\n#define CMD_INTR\t0x40\t\t/* enable scsi interrupts */\n#define CMD_START_ARB\t0x10\t\t/* start arbitration bit */\n#define\tCMD_ATTN\t0x08\t\t/* scsi attention */\n#define CMD_SEL\t\t0x02\t\t/* scsi select */\n\nint sea_select;\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nint\nsea_select(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\tu_char msg[3], phase;\n\tu_char *data;\n\tint len;\n\tint timeout;\n\n\tCONTROL = BASE_CMD;\n\tDATA = sea->our_id_mask;\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_START_ARB;\n\n\t/* wait for arbitration to complete */\n\tfor (timeout = 0; timeout < 3000000L; timeout++)\n\t\tif (STATUS & STAT_ARB_CMPL)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_ARB_CMPL)) {\n\t\tif (STATUS & STAT_SEL) {\n\t\t\tprintf(\"%s: arbitration lost\\n\", sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_ERROR;\n\t\t} else {\n\t\t\tprintf(\"%s: arbitration timeout\\n\",\n\t\t\t    sea->sc_dev.dv_xname);\n\t\t\tscb->flags |= SCB_TIMEOUT;\n\t\t}\n\t\tCONTROL = BASE_CMD;\n\t\treturn -1;\n\t}\n\n\tdelay(2);\n\tDATA = (u_char)((1 << scb->xs->sc_link->target) | sea->our_id_mask);\n\tCONTROL =\n#ifdef SEA_NOMSGS\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL;\n#else\n\t    (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_SEL | CMD_ATTN;\n#endif\n\tdelay(1); \n\n\t/* wait for a bsy from target */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_BSY)\n\t\t\tbreak;\n\tif (!(STATUS & STAT_BSY)) {\n\t\t/* should return some error to the higher level driver */\n\t\tCONTROL = BASE_CMD;\n\t\tscb->flags |= SCB_TIMEOUT;\n\t\treturn 0;\n\t}\n\n\t/* Try to make the target to take a message from us */\n#ifdef SEA_NOMSGS\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE;\n#else\n\tCONTROL = (BASE_CMD & ~CMD_INTR) | CMD_DRVR_ENABLE | CMD_ATTN;\n#endif\n\tdelay(1);\n  \n\t/* should start a msg_out phase */\n\tfor (timeout = 0; timeout < 2000000L; timeout++)\n\t\tif (STATUS & STAT_REQ)\n\t\t\tbreak;\n\t/* Remove ATN. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\tif (!(STATUS & STAT_REQ)) {\n\t\t/*\n\t\t * This should not be taken as an error, but more like an\n\t\t * unsupported feature!  Should set a flag indicating that the\n\t\t * target don't support messages, and continue without failure.\n\t\t * (THIS IS NOT AN ERROR!)\n\t\t */\n\t} else {\n\t\tmsg[0] = MSG_IDENTIFY(scb->xs->sc_link->lun, 1);\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\t/* Should do test on result of sea_transfer_pio(). */\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t}\n\tif (!(STATUS & STAT_BSY))\n\t\tprintf(\"%s: after successful arbitrate: no STAT_BSY!\\n\",\n\t\t    sea->sc_dev.dv_xname);\n  \n\tsea->nexus = scb;\n\tsea->busy[scb->xs->sc_link->target] |= 1 << scb->xs->sc_link->lun;\n\t/* This assignment should depend on possibility to send a message to target. */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* XXX Reset pointer in command? */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sea->ready_list",
            "scb",
            "chain"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n\nstatic volatile int main_running = 0;\nstatic void sea_main;\nstatic void sea_information_transfer;\nvoid sea_reselect;\nint sea_select;\nstruct cfdriver sea_cd = {\n\tNULL, \"sea\", DV_DULL\n};\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_main()\n{\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint done;\n\tint unit;\n\tint s;\n\n\tmain_running = 1;\n\n\t/*\n\t * This should not be run with interrupts disabled, but use the splx\n\t * code instead.\n\t */\nloop:\n\tdone = 1;\n\tfor (unit = 0; unit < sea_cd.cd_ndevs; unit++) {\n\t\tsea = sea_cd.cd_devs[unit];\n\t\tif (!sea)\n\t\t\tcontinue;\n\t\ts = splbio();\n\t\tif (!sea->nexus) {\n\t\t\t/*\n\t\t\t * Search through the ready_list for a command\n\t\t\t * destined for a target that's not busy.\n\t\t\t */\n\t\t\tfor (scb = sea->ready_list.tqh_first; scb;\n\t\t\t    scb = scb->chain.tqe_next) {\n\t\t\t\tif (!(sea->busy[scb->xs->sc_link->target] &\n\t\t\t\t    (1 << scb->xs->sc_link->lun))) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->ready_list, scb,\n\t\t\t\t\t    chain);\n\t    \n\t\t\t\t\t/* Re-enable interrupts. */\n\t\t\t\t\tsplx(s);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to establish an I_T_L nexus.\n\t\t\t\t\t * On success, sea->nexus is set.\n\t\t\t\t\t * On failure, we must add the command\n\t\t\t\t\t * back to the issue queue so we can\n\t\t\t\t\t * keep trying.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * REQUEST_SENSE commands are issued\n\t\t\t\t\t * without tagged queueing, even on\n\t\t\t\t\t * SCSI-II devices because the\n\t\t\t\t\t * contingent alligence condition\n\t\t\t\t\t * exists for the entire unit.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * First check that if any device has\n\t\t\t\t\t * tried a reconnect while we have done\n\t\t\t\t\t * other things with interrupts\n\t\t\t\t\t * disabled.\n\t\t\t\t\t */\n\n\t\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sea_select(sea, scb)) {\n\t\t\t\t\t\ts = splbio();\n\t\t\t\t\t\tTAILQ_INSERT_HEAD(&sea->ready_list,\n\t\t\t\t\t\t    scb, chain);\n\t\t\t\t\t\tsplx(s);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t} /* if target/lun is not busy */\n\t\t\t} /* for scb */\n\t\t\tif (!sea->nexus) {\n\t\t\t\t/* check for reselection phase */\n\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* if (!sea->nexus) */\n      \n\t\tsplx(s);\n\t\tif (sea->nexus) {\t/* we are connected. Do the task */\n\t\t\tsea_information_transfer(sea);\n\t\t\tdone = 0;\n\t\t} else\n\t\t\tbreak;\n\t} /* for instance */\n\n\tif (!done)\n\t\tgoto loop;\n\n\tmain_running = 0;\n}"
  },
  {
    "function_name": "sea_send_scb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "661-671",
    "snippet": "void\nsea_send_scb(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sea->ready_list, scb, chain);\n\t/* Try to do some work on the card. */\n\tif (!main_running)\n\t\tsea_main();\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile int main_running = 0;",
      "static void sea_main",
      "void sea_send_scb",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sea_main",
          "args": [],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "sea_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "678-773",
          "snippet": "void\nsea_main()\n{\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint done;\n\tint unit;\n\tint s;\n\n\tmain_running = 1;\n\n\t/*\n\t * This should not be run with interrupts disabled, but use the splx\n\t * code instead.\n\t */\nloop:\n\tdone = 1;\n\tfor (unit = 0; unit < sea_cd.cd_ndevs; unit++) {\n\t\tsea = sea_cd.cd_devs[unit];\n\t\tif (!sea)\n\t\t\tcontinue;\n\t\ts = splbio();\n\t\tif (!sea->nexus) {\n\t\t\t/*\n\t\t\t * Search through the ready_list for a command\n\t\t\t * destined for a target that's not busy.\n\t\t\t */\n\t\t\tfor (scb = sea->ready_list.tqh_first; scb;\n\t\t\t    scb = scb->chain.tqe_next) {\n\t\t\t\tif (!(sea->busy[scb->xs->sc_link->target] &\n\t\t\t\t    (1 << scb->xs->sc_link->lun))) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->ready_list, scb,\n\t\t\t\t\t    chain);\n\t    \n\t\t\t\t\t/* Re-enable interrupts. */\n\t\t\t\t\tsplx(s);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to establish an I_T_L nexus.\n\t\t\t\t\t * On success, sea->nexus is set.\n\t\t\t\t\t * On failure, we must add the command\n\t\t\t\t\t * back to the issue queue so we can\n\t\t\t\t\t * keep trying.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * REQUEST_SENSE commands are issued\n\t\t\t\t\t * without tagged queueing, even on\n\t\t\t\t\t * SCSI-II devices because the\n\t\t\t\t\t * contingent alligence condition\n\t\t\t\t\t * exists for the entire unit.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * First check that if any device has\n\t\t\t\t\t * tried a reconnect while we have done\n\t\t\t\t\t * other things with interrupts\n\t\t\t\t\t * disabled.\n\t\t\t\t\t */\n\n\t\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sea_select(sea, scb)) {\n\t\t\t\t\t\ts = splbio();\n\t\t\t\t\t\tTAILQ_INSERT_HEAD(&sea->ready_list,\n\t\t\t\t\t\t    scb, chain);\n\t\t\t\t\t\tsplx(s);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t} /* if target/lun is not busy */\n\t\t\t} /* for scb */\n\t\t\tif (!sea->nexus) {\n\t\t\t\t/* check for reselection phase */\n\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* if (!sea->nexus) */\n      \n\t\tsplx(s);\n\t\tif (sea->nexus) {\t/* we are connected. Do the task */\n\t\t\tsea_information_transfer(sea);\n\t\t\tdone = 0;\n\t\t} else\n\t\t\tbreak;\n\t} /* for instance */\n\n\tif (!done)\n\t\tgoto loop;\n\n\tmain_running = 0;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define STAT_SEL\t0x20\t\t/* scsi select */",
            "#define STAT_IO\t\t0x04\t\t/* scsi I/O */"
          ],
          "globals_used": [
            "static volatile int main_running = 0;",
            "static void sea_main",
            "static void sea_information_transfer",
            "void sea_reselect",
            "int sea_select",
            "struct cfdriver sea_cd = {\n\tNULL, \"sea\", DV_DULL\n};",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n\nstatic volatile int main_running = 0;\nstatic void sea_main;\nstatic void sea_information_transfer;\nvoid sea_reselect;\nint sea_select;\nstruct cfdriver sea_cd = {\n\tNULL, \"sea\", DV_DULL\n};\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_main()\n{\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint done;\n\tint unit;\n\tint s;\n\n\tmain_running = 1;\n\n\t/*\n\t * This should not be run with interrupts disabled, but use the splx\n\t * code instead.\n\t */\nloop:\n\tdone = 1;\n\tfor (unit = 0; unit < sea_cd.cd_ndevs; unit++) {\n\t\tsea = sea_cd.cd_devs[unit];\n\t\tif (!sea)\n\t\t\tcontinue;\n\t\ts = splbio();\n\t\tif (!sea->nexus) {\n\t\t\t/*\n\t\t\t * Search through the ready_list for a command\n\t\t\t * destined for a target that's not busy.\n\t\t\t */\n\t\t\tfor (scb = sea->ready_list.tqh_first; scb;\n\t\t\t    scb = scb->chain.tqe_next) {\n\t\t\t\tif (!(sea->busy[scb->xs->sc_link->target] &\n\t\t\t\t    (1 << scb->xs->sc_link->lun))) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->ready_list, scb,\n\t\t\t\t\t    chain);\n\t    \n\t\t\t\t\t/* Re-enable interrupts. */\n\t\t\t\t\tsplx(s);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to establish an I_T_L nexus.\n\t\t\t\t\t * On success, sea->nexus is set.\n\t\t\t\t\t * On failure, we must add the command\n\t\t\t\t\t * back to the issue queue so we can\n\t\t\t\t\t * keep trying.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * REQUEST_SENSE commands are issued\n\t\t\t\t\t * without tagged queueing, even on\n\t\t\t\t\t * SCSI-II devices because the\n\t\t\t\t\t * contingent alligence condition\n\t\t\t\t\t * exists for the entire unit.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * First check that if any device has\n\t\t\t\t\t * tried a reconnect while we have done\n\t\t\t\t\t * other things with interrupts\n\t\t\t\t\t * disabled.\n\t\t\t\t\t */\n\n\t\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sea_select(sea, scb)) {\n\t\t\t\t\t\ts = splbio();\n\t\t\t\t\t\tTAILQ_INSERT_HEAD(&sea->ready_list,\n\t\t\t\t\t\t    scb, chain);\n\t\t\t\t\t\tsplx(s);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t} /* if target/lun is not busy */\n\t\t\t} /* for scb */\n\t\t\tif (!sea->nexus) {\n\t\t\t\t/* check for reselection phase */\n\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* if (!sea->nexus) */\n      \n\t\tsplx(s);\n\t\tif (sea->nexus) {\t/* we are connected. Do the task */\n\t\t\tsea_information_transfer(sea);\n\t\t\tdone = 0;\n\t\t} else\n\t\t\tbreak;\n\t} /* for instance */\n\n\tif (!done)\n\t\tgoto loop;\n\n\tmain_running = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sea->ready_list",
            "scb",
            "chain"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic volatile int main_running = 0;\nstatic void sea_main;\nvoid sea_send_scb;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_send_scb(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sea->ready_list, scb, chain);\n\t/* Try to do some work on the card. */\n\tif (!main_running)\n\t\tsea_main();\n}"
  },
  {
    "function_name": "sea_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "538-607",
    "snippet": "int\nsea_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct sea_softc *sea = sc_link->adapter_softc;\n\tstruct sea_scb *scb;\n\tint flags;\n\tint s;\n\n\tSC_DEBUG(sc_link, SDEV_DB2, (\"sea_scsi_cmd\\n\"));\n\n\tflags = xs->flags;\n\tif ((flags & (ITSDONE|INUSE)) != INUSE) {\n\t\tprintf(\"%s: done or not in use?\\n\", sea->sc_dev.dv_xname);\n\t\txs->flags &= ~ITSDONE;\n\t\txs->flags |= INUSE;\n\t}\n\tif ((scb = sea_get_scb(sea, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\tscb->flags = SCB_ACTIVE;\n\tscb->xs = xs;\n\n\tif (flags & SCSI_RESET) {\n\t\t/*\n\t\t * Try to send a reset command to the card.\n\t\t * XXX Not implemented.\n\t\t */\n\t\tprintf(\"%s: resetting\\n\", sea->sc_dev.dv_xname);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn COMPLETE;\n\t}\n\n\t/*\n\t * Put all the arguments for the xfer in the scb\n\t */\n\tscb->datalen = xs->datalen;\n\tscb->data = xs->data;\n\n#ifdef SEA_DEBUGQUEUE\n\tsea_queue_length(sea);\n#endif\n\n\ts = splbio();\n\n\tsea_send_scb(sea, scb);\n\n\t/*\n\t * Usually return SUCCESSFULLY QUEUED\n\t */\n\tif ((flags & SCSI_POLL) == 0) {\n\t\ttimeout(sea_timeout, scb, (xs->timeout * hz) / 1000);\n\t\tsplx(s);\n\t\treturn SUCCESSFULLY_QUEUED;\n\t}\n\n\tsplx(s);\n\n\t/*\n\t * If we can't use interrupts, poll on completion\n\t */\n\tif (sea_poll(sea, xs, xs->timeout)) {\n\t\tsea_timeout(scb);\n\t\tif (sea_poll(sea, xs, 2000))\n\t\t\tsea_timeout(scb);\n\t}\n\treturn COMPLETE;\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tSCB_ACTIVE\t1"
    ],
    "globals_used": [
      "int sea_scsi_cmd",
      "void sea_timeout",
      "struct sea_scb *sea_get_scb",
      "int sea_poll",
      "void sea_send_scb",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sea_timeout",
          "args": [
            "scb"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "sea_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "798-835",
          "snippet": "void\nsea_timeout(arg)\n\tvoid *arg;\n{\n\tstruct sea_scb *scb = arg;\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct sea_softc *sea = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t \tscb->xs->retries = 0;\n\t\tscb->flags |= SCB_ABORTED;\n\t\tsea_done(sea, scb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->flags |= SCB_ABORTED;\n\t\tsea_abort(sea, scb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(sea_timeout, scb, 2 * hz);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define SCB_ABORTED\t2"
          ],
          "globals_used": [
            "void sea_timeout",
            "void sea_done",
            "int sea_abort",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define SCB_ABORTED\t2\n\nvoid sea_timeout;\nvoid sea_done;\nint sea_abort;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nvoid\nsea_timeout(arg)\n\tvoid *arg;\n{\n\tstruct sea_scb *scb = arg;\n\tstruct scsi_xfer *xs = scb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct sea_softc *sea = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (scb->flags & SCB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t \tscb->xs->retries = 0;\n\t\tscb->flags |= SCB_ABORTED;\n\t\tsea_done(sea, scb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tscb->flags |= SCB_ABORTED;\n\t\tsea_abort(sea, scb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(sea_timeout, scb, 2 * hz);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sea_poll",
          "args": [
            "sea",
            "xs",
            "2000"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "sea_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "1205-1225",
          "snippet": "int\nsea_poll(sea, xs, count)\n\tstruct sea_softc *sea;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint s;\n\n\twhile (count) {\n\t\t/* try to do something */\n\t\ts = splbio();\n\t\tif (!main_running)\n\t\t\tsea_main();\n\t\tsplx(s);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int main_running = 0;",
            "static void sea_main",
            "int sea_poll",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic volatile int main_running = 0;\nstatic void sea_main;\nint sea_poll;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nint\nsea_poll(sea, xs, count)\n\tstruct sea_softc *sea;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\tint s;\n\n\twhile (count) {\n\t\t/* try to do something */\n\t\ts = splbio();\n\t\tif (!main_running)\n\t\t\tsea_main();\n\t\tsplx(s);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sea_send_scb",
          "args": [
            "sea",
            "scb"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "sea_send_scb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "661-671",
          "snippet": "void\nsea_send_scb(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sea->ready_list, scb, chain);\n\t/* Try to do some work on the card. */\n\tif (!main_running)\n\t\tsea_main();\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int main_running = 0;",
            "static void sea_main",
            "void sea_send_scb",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic volatile int main_running = 0;\nstatic void sea_main;\nvoid sea_send_scb;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_send_scb(sea, scb)\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n{\n\n\tTAILQ_INSERT_TAIL(&sea->ready_list, scb, chain);\n\t/* Try to do some work on the card. */\n\tif (!main_running)\n\t\tsea_main();\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sea_queue_length",
          "args": [
            "sea"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "sea_queue_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "320-334",
          "snippet": "void\nsea_queue_length(sea)\n\tstruct sea_softc *sea;\n{\n\tstruct sea_scb *scb;\n\tint connected, issued, disconnected;\n\n\tconnected = sea->nexus ? 1 : 0;\n\tfor (scb = sea->ready_list.tqh_first, issued = 0; scb;\n\t    scb = scb->chain.tqe_next, issued++);\n\tfor (scb = sea->nexus_list.tqh_first, disconnected = 0; scb;\n\t    scb = scb->chain.tqe_next, disconnected++);\n\tprintf(\"%s: length: %d/%d/%d\\n\", sea->sc_dev.dv_xname, connected,\n\t    issued, disconnected);\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_queue_length(sea)\n\tstruct sea_softc *sea;\n{\n\tstruct sea_scb *scb;\n\tint connected, issued, disconnected;\n\n\tconnected = sea->nexus ? 1 : 0;\n\tfor (scb = sea->ready_list.tqh_first, issued = 0; scb;\n\t    scb = scb->chain.tqe_next, issued++);\n\tfor (scb = sea->nexus_list.tqh_first, disconnected = 0; scb;\n\t    scb = scb->chain.tqe_next, disconnected++);\n\tprintf(\"%s: length: %d/%d/%d\\n\", sea->sc_dev.dv_xname, connected,\n\t    issued, disconnected);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: resetting\\n\"",
            "sea->sc_dev.dv_xname"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sea_get_scb",
          "args": [
            "sea",
            "flags"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB2",
            "(\"sea_scsi_cmd\\n\")"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tSCB_ACTIVE\t1\n\nint sea_scsi_cmd;\nvoid sea_timeout;\nstruct sea_scb *sea_get_scb;\nint sea_poll;\nvoid sea_send_scb;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\nint flags;\n\nint\nsea_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct sea_softc *sea = sc_link->adapter_softc;\n\tstruct sea_scb *scb;\n\tint flags;\n\tint s;\n\n\tSC_DEBUG(sc_link, SDEV_DB2, (\"sea_scsi_cmd\\n\"));\n\n\tflags = xs->flags;\n\tif ((flags & (ITSDONE|INUSE)) != INUSE) {\n\t\tprintf(\"%s: done or not in use?\\n\", sea->sc_dev.dv_xname);\n\t\txs->flags &= ~ITSDONE;\n\t\txs->flags |= INUSE;\n\t}\n\tif ((scb = sea_get_scb(sea, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\tscb->flags = SCB_ACTIVE;\n\tscb->xs = xs;\n\n\tif (flags & SCSI_RESET) {\n\t\t/*\n\t\t * Try to send a reset command to the card.\n\t\t * XXX Not implemented.\n\t\t */\n\t\tprintf(\"%s: resetting\\n\", sea->sc_dev.dv_xname);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn COMPLETE;\n\t}\n\n\t/*\n\t * Put all the arguments for the xfer in the scb\n\t */\n\tscb->datalen = xs->datalen;\n\tscb->data = xs->data;\n\n#ifdef SEA_DEBUGQUEUE\n\tsea_queue_length(sea);\n#endif\n\n\ts = splbio();\n\n\tsea_send_scb(sea, scb);\n\n\t/*\n\t * Usually return SUCCESSFULLY QUEUED\n\t */\n\tif ((flags & SCSI_POLL) == 0) {\n\t\ttimeout(sea_timeout, scb, (xs->timeout * hz) / 1000);\n\t\tsplx(s);\n\t\treturn SUCCESSFULLY_QUEUED;\n\t}\n\n\tsplx(s);\n\n\t/*\n\t * If we can't use interrupts, poll on completion\n\t */\n\tif (sea_poll(sea, xs, xs->timeout)) {\n\t\tsea_timeout(scb);\n\t\tif (sea_poll(sea, xs, 2000))\n\t\t\tsea_timeout(scb);\n\t}\n\treturn COMPLETE;\n}"
  },
  {
    "function_name": "sea_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "495-532",
    "snippet": "void\nsea_init(sea)\n\tstruct sea_softc *sea;\n{\n\tint i;\n  \n\t/* Reset the scsi bus (I don't know if this is needed */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE | CMD_RST;\n\tdelay(25);\t/* hold reset for at least 25 microseconds */\n\tCONTROL = BASE_CMD;\n\tdelay(10); \t/* wait a Bus Clear Delay (800 ns + bus free delay (800 ns) */\n\n\t/* Set our id (don't know anything about this) */\n\tswitch (sea->type) {\n\tcase SEAGATE:\n\t\tsea->our_id = 7;\n\t\tbreak;\n\tcase FDOMAIN:\n\tcase FDOMAIN840:\n\t\tsea->our_id = 6;\n\t\tbreak;\n\t}\n\tsea->our_id_mask = 1 << sea->our_id;\n\n\t/* init fields used by our routines */\n\tsea->nexus = 0;\n\tTAILQ_INIT(&sea->ready_list);\n\tTAILQ_INIT(&sea->nexus_list);\n\tTAILQ_INIT(&sea->free_list);\n\tfor (i = 0; i < 8; i++)\n\t\tsea->busy[i] = 0x00;\n\n\t/* link up the free list of scbs */\n\tsea->numscbs = SCB_TABLE_SIZE;\n\tfor (i = 0; i < SCB_TABLE_SIZE; i++) {\n\t\tTAILQ_INSERT_TAIL(&sea->free_list, &sea->scb[i], chain);\n\t}\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define CONTROL\tSTATUS",
      "#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */",
      "#define\tFDOMAIN\t\t2\t/* Future Domain TMC-{885,950} */",
      "#define\tSEAGATE\t\t1\t/* Seagate ST0[12] */",
      "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
      "#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */",
      "#define CMD_RST\t\t0x01\t\t/* scsi reset */",
      "#define SCB_TABLE_SIZE\t8\t/* start with 8 scb entries in table */"
    ],
    "globals_used": [
      "void sea_init",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sea->free_list",
            "&sea->scb[i]",
            "chain"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sea->free_list"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sea->nexus_list"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sea->ready_list"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define CONTROL\tSTATUS\n#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */\n#define\tFDOMAIN\t\t2\t/* Future Domain TMC-{885,950} */\n#define\tSEAGATE\t\t1\t/* Seagate ST0[12] */\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */\n#define CMD_RST\t\t0x01\t\t/* scsi reset */\n#define SCB_TABLE_SIZE\t8\t/* start with 8 scb entries in table */\n\nvoid sea_init;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_init(sea)\n\tstruct sea_softc *sea;\n{\n\tint i;\n  \n\t/* Reset the scsi bus (I don't know if this is needed */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE | CMD_RST;\n\tdelay(25);\t/* hold reset for at least 25 microseconds */\n\tCONTROL = BASE_CMD;\n\tdelay(10); \t/* wait a Bus Clear Delay (800 ns + bus free delay (800 ns) */\n\n\t/* Set our id (don't know anything about this) */\n\tswitch (sea->type) {\n\tcase SEAGATE:\n\t\tsea->our_id = 7;\n\t\tbreak;\n\tcase FDOMAIN:\n\tcase FDOMAIN840:\n\t\tsea->our_id = 6;\n\t\tbreak;\n\t}\n\tsea->our_id_mask = 1 << sea->our_id;\n\n\t/* init fields used by our routines */\n\tsea->nexus = 0;\n\tTAILQ_INIT(&sea->ready_list);\n\tTAILQ_INIT(&sea->nexus_list);\n\tTAILQ_INIT(&sea->free_list);\n\tfor (i = 0; i < 8; i++)\n\t\tsea->busy[i] = 0x00;\n\n\t/* link up the free list of scbs */\n\tsea->numscbs = SCB_TABLE_SIZE;\n\tfor (i = 0; i < SCB_TABLE_SIZE; i++) {\n\t\tTAILQ_INSERT_TAIL(&sea->free_list, &sea->scb[i], chain);\n\t}\n}"
  },
  {
    "function_name": "seaintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "459-490",
    "snippet": "int\nseaintr(arg)\n\tvoid *arg;\n{\n\tstruct sea_softc *sea = arg;\n\n#ifdef DEBUG\t/* extra overhead, and only needed for intr debugging */\n\tif ((STATUS & STAT_PARITY) == 0 &&\n\t    (STATUS & (STAT_SEL | STAT_IO)) != (STAT_SEL | STAT_IO))\n\t\treturn 0;\n#endif\n\nloop:\n\t/* dispatch to appropriate routine if found and done=0 */\n\t/* should check to see that this card really caused the interrupt */\n\n\tif (STATUS & STAT_PARITY) {\n\t\t/* Parity error interrupt */\n\t\tprintf(\"%s: parity error\\n\", sea->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif ((STATUS & (STAT_SEL | STAT_IO)) == (STAT_SEL | STAT_IO)) {\n\t\t/* Reselect interrupt */\n\t\tsea_reselect(sea);\n\t\tif (!main_running)\n\t\t\tsea_main();\n\t\tgoto loop;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
      "#define STAT_PARITY\t0x40\t\t/* parity error bit */",
      "#define STAT_SEL\t0x20\t\t/* scsi select */",
      "#define STAT_IO\t\t0x04\t\t/* scsi I/O */"
    ],
    "globals_used": [
      "static volatile int main_running = 0;",
      "int seaintr",
      "static void sea_main",
      "void sea_reselect",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sea_main",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "sea_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "678-773",
          "snippet": "void\nsea_main()\n{\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint done;\n\tint unit;\n\tint s;\n\n\tmain_running = 1;\n\n\t/*\n\t * This should not be run with interrupts disabled, but use the splx\n\t * code instead.\n\t */\nloop:\n\tdone = 1;\n\tfor (unit = 0; unit < sea_cd.cd_ndevs; unit++) {\n\t\tsea = sea_cd.cd_devs[unit];\n\t\tif (!sea)\n\t\t\tcontinue;\n\t\ts = splbio();\n\t\tif (!sea->nexus) {\n\t\t\t/*\n\t\t\t * Search through the ready_list for a command\n\t\t\t * destined for a target that's not busy.\n\t\t\t */\n\t\t\tfor (scb = sea->ready_list.tqh_first; scb;\n\t\t\t    scb = scb->chain.tqe_next) {\n\t\t\t\tif (!(sea->busy[scb->xs->sc_link->target] &\n\t\t\t\t    (1 << scb->xs->sc_link->lun))) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->ready_list, scb,\n\t\t\t\t\t    chain);\n\t    \n\t\t\t\t\t/* Re-enable interrupts. */\n\t\t\t\t\tsplx(s);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to establish an I_T_L nexus.\n\t\t\t\t\t * On success, sea->nexus is set.\n\t\t\t\t\t * On failure, we must add the command\n\t\t\t\t\t * back to the issue queue so we can\n\t\t\t\t\t * keep trying.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * REQUEST_SENSE commands are issued\n\t\t\t\t\t * without tagged queueing, even on\n\t\t\t\t\t * SCSI-II devices because the\n\t\t\t\t\t * contingent alligence condition\n\t\t\t\t\t * exists for the entire unit.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * First check that if any device has\n\t\t\t\t\t * tried a reconnect while we have done\n\t\t\t\t\t * other things with interrupts\n\t\t\t\t\t * disabled.\n\t\t\t\t\t */\n\n\t\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sea_select(sea, scb)) {\n\t\t\t\t\t\ts = splbio();\n\t\t\t\t\t\tTAILQ_INSERT_HEAD(&sea->ready_list,\n\t\t\t\t\t\t    scb, chain);\n\t\t\t\t\t\tsplx(s);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t} /* if target/lun is not busy */\n\t\t\t} /* for scb */\n\t\t\tif (!sea->nexus) {\n\t\t\t\t/* check for reselection phase */\n\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* if (!sea->nexus) */\n      \n\t\tsplx(s);\n\t\tif (sea->nexus) {\t/* we are connected. Do the task */\n\t\t\tsea_information_transfer(sea);\n\t\t\tdone = 0;\n\t\t} else\n\t\t\tbreak;\n\t} /* for instance */\n\n\tif (!done)\n\t\tgoto loop;\n\n\tmain_running = 0;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define STAT_SEL\t0x20\t\t/* scsi select */",
            "#define STAT_IO\t\t0x04\t\t/* scsi I/O */"
          ],
          "globals_used": [
            "static volatile int main_running = 0;",
            "static void sea_main",
            "static void sea_information_transfer",
            "void sea_reselect",
            "int sea_select",
            "struct cfdriver sea_cd = {\n\tNULL, \"sea\", DV_DULL\n};",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n\nstatic volatile int main_running = 0;\nstatic void sea_main;\nstatic void sea_information_transfer;\nvoid sea_reselect;\nint sea_select;\nstruct cfdriver sea_cd = {\n\tNULL, \"sea\", DV_DULL\n};\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_main()\n{\n\tstruct sea_softc *sea;\n\tstruct sea_scb *scb;\n\tint done;\n\tint unit;\n\tint s;\n\n\tmain_running = 1;\n\n\t/*\n\t * This should not be run with interrupts disabled, but use the splx\n\t * code instead.\n\t */\nloop:\n\tdone = 1;\n\tfor (unit = 0; unit < sea_cd.cd_ndevs; unit++) {\n\t\tsea = sea_cd.cd_devs[unit];\n\t\tif (!sea)\n\t\t\tcontinue;\n\t\ts = splbio();\n\t\tif (!sea->nexus) {\n\t\t\t/*\n\t\t\t * Search through the ready_list for a command\n\t\t\t * destined for a target that's not busy.\n\t\t\t */\n\t\t\tfor (scb = sea->ready_list.tqh_first; scb;\n\t\t\t    scb = scb->chain.tqe_next) {\n\t\t\t\tif (!(sea->busy[scb->xs->sc_link->target] &\n\t\t\t\t    (1 << scb->xs->sc_link->lun))) {\n\t\t\t\t\tTAILQ_REMOVE(&sea->ready_list, scb,\n\t\t\t\t\t    chain);\n\t    \n\t\t\t\t\t/* Re-enable interrupts. */\n\t\t\t\t\tsplx(s);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Attempt to establish an I_T_L nexus.\n\t\t\t\t\t * On success, sea->nexus is set.\n\t\t\t\t\t * On failure, we must add the command\n\t\t\t\t\t * back to the issue queue so we can\n\t\t\t\t\t * keep trying.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * REQUEST_SENSE commands are issued\n\t\t\t\t\t * without tagged queueing, even on\n\t\t\t\t\t * SCSI-II devices because the\n\t\t\t\t\t * contingent alligence condition\n\t\t\t\t\t * exists for the entire unit.\n\t\t\t\t\t */\n\n\t\t\t\t\t/*\n\t\t\t\t\t * First check that if any device has\n\t\t\t\t\t * tried a reconnect while we have done\n\t\t\t\t\t * other things with interrupts\n\t\t\t\t\t * disabled.\n\t\t\t\t\t */\n\n\t\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sea_select(sea, scb)) {\n\t\t\t\t\t\ts = splbio();\n\t\t\t\t\t\tTAILQ_INSERT_HEAD(&sea->ready_list,\n\t\t\t\t\t\t    scb, chain);\n\t\t\t\t\t\tsplx(s);\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t} /* if target/lun is not busy */\n\t\t\t} /* for scb */\n\t\t\tif (!sea->nexus) {\n\t\t\t\t/* check for reselection phase */\n\t\t\t\tif ((STATUS & (STAT_SEL | STAT_IO)) ==\n\t\t\t\t    (STAT_SEL | STAT_IO)) {\n\t\t\t\t\tsea_reselect(sea);\n\t\t\t\t}\n\t\t\t}\n\t\t} /* if (!sea->nexus) */\n      \n\t\tsplx(s);\n\t\tif (sea->nexus) {\t/* we are connected. Do the task */\n\t\t\tsea_information_transfer(sea);\n\t\t\tdone = 0;\n\t\t} else\n\t\t\tbreak;\n\t} /* for instance */\n\n\tif (!done)\n\t\tgoto loop;\n\n\tmain_running = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sea_reselect",
          "args": [
            "sea"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "sea_reselect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "837-929",
          "snippet": "void\nsea_reselect(sea)\n\tstruct sea_softc *sea;\n{\n\tu_char target_mask;\n\tint i;\n\tu_char lun, phase;\n\tu_char msg[3];\n\tint len;\n\tu_char *data;\n\tstruct sea_scb *scb;\n\tint abort = 0;\n  \n\tif (!((target_mask = STATUS) & STAT_SEL)) {\n\t\tprintf(\"%s: wrong state 0x%x\\n\", sea->sc_dev.dv_xname,\n\t\t    target_mask);\n\t\treturn;\n\t}\n\n\t/* wait for a device to win the reselection phase */\n\t/* signals this by asserting the I/O signal */\n\tfor (i = 10; i && (STATUS & (STAT_SEL | STAT_IO | STAT_BSY)) !=\n\t    (STAT_SEL | STAT_IO | 0); i--);\n\t/* !! Check for timeout here */\n\t/* the data bus contains original initiator id ORed with target id */\n\ttarget_mask = DATA;\n\t/* see that we really are the initiator */\n\tif (!(target_mask & sea->our_id_mask)) {\n\t\tprintf(\"%s: polled reselection was not for me: 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, target_mask);\n\t\treturn;\n\t}\n\t/* find target who won */\n\ttarget_mask &= ~sea->our_id_mask;\n\t/* host responds by asserting the BSY signal */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE | CMD_BSY;\n\t/* target should respond by deasserting the SEL signal */\n\tfor (i = 50000; i && (STATUS & STAT_SEL); i++);\n\t/* remove the busy status */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* we are connected. Now we wait for the MSGIN condition */\n\tfor (i = 50000; i && !(STATUS & STAT_REQ); i--);\n\t/* !! Add timeout check here */\n\t/* hope we get an IDENTIFY message */\n\tlen = 3;\n\tdata = msg;\n\tphase = PH_MSGIN;\n\tsea_transfer_pio(sea, &phase, &len, &data); \n\n\tif (MSG_ISIDENTIFY(msg[0])) {\n\t\tprintf(\"%s: expecting IDENTIFY message, got 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, msg[0]);\n\t\tabort = 1;\n\t\tscb = NULL;\n\t} else {\n\t\tlun = msg[0] & 0x07;\n\n\t\t/*\n\t\t * Find the command corresponding to the I_T_L or I_T_L_Q nexus\n\t\t * we just reestablished, and remove it from the disconnected\n\t\t * queue.\n\t\t */\n\t\tfor (scb = sea->nexus_list.tqh_first; scb;\n\t\t    scb = scb->chain.tqe_next)\n\t\t\tif (target_mask == (1 << scb->xs->sc_link->target) &&\n\t\t\t    lun == scb->xs->sc_link->lun) {\n\t\t\t\tTAILQ_REMOVE(&sea->nexus_list, scb,\n\t\t\t\t    chain);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!scb) {\n\t\t\tprintf(\"%s: target %02x lun %d not disconnected\\n\",\n\t\t\t    sea->sc_dev.dv_xname, target_mask, lun);\n\t\t\t/*\n\t\t\t * Since we have an established nexus that we can't do\n\t\t\t * anything with, we must abort it.\n\t\t\t */\n\t\t\tabort = 1;\n\t\t}\n\t}\n\n\tif (abort) {\n\t\tmsg[0] = MSG_ABORT;\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t} else\n\t\tsea->nexus = scb;\n\n\treturn;\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define DATA\t(*(volatile u_char *)sea->maddr_dr)",
            "#define CONTROL\tSTATUS",
            "#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)",
            "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
            "#define PH_MSGIN\t(STAT_MSG | STAT_CD | STAT_IO)",
            "#define PH_MSGOUT\t(STAT_MSG | STAT_CD)",
            "#define STAT_SEL\t0x20\t\t/* scsi select */",
            "#define STAT_REQ\t0x10\t\t/* scsi req */",
            "#define STAT_IO\t\t0x04\t\t/* scsi I/O */",
            "#define STAT_BSY\t0x01\t\t/* scsi busy */",
            "#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */",
            "#define\tCMD_ATTN\t0x08\t\t/* scsi attention */",
            "#define CMD_BSY\t\t0x04\t\t/* scsi busy */"
          ],
          "globals_used": [
            "void sea_reselect",
            "int sea_transfer_pio",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define DATA\t(*(volatile u_char *)sea->maddr_dr)\n#define CONTROL\tSTATUS\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define PH_MSGIN\t(STAT_MSG | STAT_CD | STAT_IO)\n#define PH_MSGOUT\t(STAT_MSG | STAT_CD)\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_REQ\t0x10\t\t/* scsi req */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n#define STAT_BSY\t0x01\t\t/* scsi busy */\n#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */\n#define\tCMD_ATTN\t0x08\t\t/* scsi attention */\n#define CMD_BSY\t\t0x04\t\t/* scsi busy */\n\nvoid sea_reselect;\nint sea_transfer_pio;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_reselect(sea)\n\tstruct sea_softc *sea;\n{\n\tu_char target_mask;\n\tint i;\n\tu_char lun, phase;\n\tu_char msg[3];\n\tint len;\n\tu_char *data;\n\tstruct sea_scb *scb;\n\tint abort = 0;\n  \n\tif (!((target_mask = STATUS) & STAT_SEL)) {\n\t\tprintf(\"%s: wrong state 0x%x\\n\", sea->sc_dev.dv_xname,\n\t\t    target_mask);\n\t\treturn;\n\t}\n\n\t/* wait for a device to win the reselection phase */\n\t/* signals this by asserting the I/O signal */\n\tfor (i = 10; i && (STATUS & (STAT_SEL | STAT_IO | STAT_BSY)) !=\n\t    (STAT_SEL | STAT_IO | 0); i--);\n\t/* !! Check for timeout here */\n\t/* the data bus contains original initiator id ORed with target id */\n\ttarget_mask = DATA;\n\t/* see that we really are the initiator */\n\tif (!(target_mask & sea->our_id_mask)) {\n\t\tprintf(\"%s: polled reselection was not for me: 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, target_mask);\n\t\treturn;\n\t}\n\t/* find target who won */\n\ttarget_mask &= ~sea->our_id_mask;\n\t/* host responds by asserting the BSY signal */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE | CMD_BSY;\n\t/* target should respond by deasserting the SEL signal */\n\tfor (i = 50000; i && (STATUS & STAT_SEL); i++);\n\t/* remove the busy status */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE;\n\t/* we are connected. Now we wait for the MSGIN condition */\n\tfor (i = 50000; i && !(STATUS & STAT_REQ); i--);\n\t/* !! Add timeout check here */\n\t/* hope we get an IDENTIFY message */\n\tlen = 3;\n\tdata = msg;\n\tphase = PH_MSGIN;\n\tsea_transfer_pio(sea, &phase, &len, &data); \n\n\tif (MSG_ISIDENTIFY(msg[0])) {\n\t\tprintf(\"%s: expecting IDENTIFY message, got 0x%x\\n\",\n\t\t    sea->sc_dev.dv_xname, msg[0]);\n\t\tabort = 1;\n\t\tscb = NULL;\n\t} else {\n\t\tlun = msg[0] & 0x07;\n\n\t\t/*\n\t\t * Find the command corresponding to the I_T_L or I_T_L_Q nexus\n\t\t * we just reestablished, and remove it from the disconnected\n\t\t * queue.\n\t\t */\n\t\tfor (scb = sea->nexus_list.tqh_first; scb;\n\t\t    scb = scb->chain.tqe_next)\n\t\t\tif (target_mask == (1 << scb->xs->sc_link->target) &&\n\t\t\t    lun == scb->xs->sc_link->lun) {\n\t\t\t\tTAILQ_REMOVE(&sea->nexus_list, scb,\n\t\t\t\t    chain);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!scb) {\n\t\t\tprintf(\"%s: target %02x lun %d not disconnected\\n\",\n\t\t\t    sea->sc_dev.dv_xname, target_mask, lun);\n\t\t\t/*\n\t\t\t * Since we have an established nexus that we can't do\n\t\t\t * anything with, we must abort it.\n\t\t\t */\n\t\t\tabort = 1;\n\t\t}\n\t}\n\n\tif (abort) {\n\t\tmsg[0] = MSG_ABORT;\n\t\tlen = 1;\n\t\tdata = msg;\n\t\tphase = PH_MSGOUT;\n\t\tCONTROL = BASE_CMD | CMD_ATTN;\n\t\tsea_transfer_pio(sea, &phase, &len, &data);\n\t} else\n\t\tsea->nexus = scb;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: parity error\\n\"",
            "sea->sc_dev.dv_xname"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tSTATUS\t(*(volatile u_char *)sea->maddr_cr_sr)\n#define STAT_PARITY\t0x40\t\t/* parity error bit */\n#define STAT_SEL\t0x20\t\t/* scsi select */\n#define STAT_IO\t\t0x04\t\t/* scsi I/O */\n\nstatic volatile int main_running = 0;\nint seaintr;\nstatic void sea_main;\nvoid sea_reselect;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nint\nseaintr(arg)\n\tvoid *arg;\n{\n\tstruct sea_softc *sea = arg;\n\n#ifdef DEBUG\t/* extra overhead, and only needed for intr debugging */\n\tif ((STATUS & STAT_PARITY) == 0 &&\n\t    (STATUS & (STAT_SEL | STAT_IO)) != (STAT_SEL | STAT_IO))\n\t\treturn 0;\n#endif\n\nloop:\n\t/* dispatch to appropriate routine if found and done=0 */\n\t/* should check to see that this card really caused the interrupt */\n\n\tif (STATUS & STAT_PARITY) {\n\t\t/* Parity error interrupt */\n\t\tprintf(\"%s: parity error\\n\", sea->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\tif ((STATUS & (STAT_SEL | STAT_IO)) == (STAT_SEL | STAT_IO)) {\n\t\t/* Reselect interrupt */\n\t\tsea_reselect(sea);\n\t\tif (!main_running)\n\t\t\tsea_main();\n\t\tgoto loop;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "seaattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "426-454",
    "snippet": "void\nseaattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct sea_softc *sea = (void *)self;\n\n\tsea_init(sea);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tsea->sc_link.adapter_softc = sea;\n\tsea->sc_link.adapter_target = sea->our_id;\n\tsea->sc_link.adapter = &sea_switch;\n\tsea->sc_link.device = &sea_dev;\n\tsea->sc_link.openings = 1;\n  \n\tprintf(\"\\n\");\n\n\tsea->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_BIO, seaintr, sea, sea->sc_dev.dv_xname);\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tconfig_found(self, &sea->sc_link, seaprint);\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int seaintr",
      "void sea_init",
      "struct scsi_adapter sea_switch = {\n\tsea_scsi_cmd,\n\tminphys,\t/* no special minphys(), since driver uses PIO */\n\t0,\n\t0,\n};",
      "struct scsi_device sea_dev = {\n\tNULL,\t\t/* use default error handler */\n\tNULL,\t\t/* have a queue, served by this */\n\tNULL,\t\t/* have no async handler */\n\tNULL,\t\t/* Use default 'done' routine */\n};",
      "void\tseaattach",
      "int\tseaprint",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "&sea->sc_link",
            "seaprint"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_BIO",
            "seaintr",
            "sea",
            "sea->sc_dev.dv_xname"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sea_init",
          "args": [
            "sea"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "sea_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
          "lines": "495-532",
          "snippet": "void\nsea_init(sea)\n\tstruct sea_softc *sea;\n{\n\tint i;\n  \n\t/* Reset the scsi bus (I don't know if this is needed */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE | CMD_RST;\n\tdelay(25);\t/* hold reset for at least 25 microseconds */\n\tCONTROL = BASE_CMD;\n\tdelay(10); \t/* wait a Bus Clear Delay (800 ns + bus free delay (800 ns) */\n\n\t/* Set our id (don't know anything about this) */\n\tswitch (sea->type) {\n\tcase SEAGATE:\n\t\tsea->our_id = 7;\n\t\tbreak;\n\tcase FDOMAIN:\n\tcase FDOMAIN840:\n\t\tsea->our_id = 6;\n\t\tbreak;\n\t}\n\tsea->our_id_mask = 1 << sea->our_id;\n\n\t/* init fields used by our routines */\n\tsea->nexus = 0;\n\tTAILQ_INIT(&sea->ready_list);\n\tTAILQ_INIT(&sea->nexus_list);\n\tTAILQ_INIT(&sea->free_list);\n\tfor (i = 0; i < 8; i++)\n\t\tsea->busy[i] = 0x00;\n\n\t/* link up the free list of scbs */\n\tsea->numscbs = SCB_TABLE_SIZE;\n\tfor (i = 0; i < SCB_TABLE_SIZE; i++) {\n\t\tTAILQ_INSERT_TAIL(&sea->free_list, &sea->scb[i], chain);\n\t}\n}",
          "includes": [
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define CONTROL\tSTATUS",
            "#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */",
            "#define\tFDOMAIN\t\t2\t/* Future Domain TMC-{885,950} */",
            "#define\tSEAGATE\t\t1\t/* Seagate ST0[12] */",
            "#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)",
            "#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */",
            "#define CMD_RST\t\t0x01\t\t/* scsi reset */",
            "#define SCB_TABLE_SIZE\t8\t/* start with 8 scb entries in table */"
          ],
          "globals_used": [
            "void sea_init",
            "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define CONTROL\tSTATUS\n#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */\n#define\tFDOMAIN\t\t2\t/* Future Domain TMC-{885,950} */\n#define\tSEAGATE\t\t1\t/* Seagate ST0[12] */\n#define BASE_CMD\t(CMD_INTR | CMD_EN_PARITY)\n#define CMD_DRVR_ENABLE\t0x80\t\t/* scsi enable */\n#define CMD_RST\t\t0x01\t\t/* scsi reset */\n#define SCB_TABLE_SIZE\t8\t/* start with 8 scb entries in table */\n\nvoid sea_init;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_init(sea)\n\tstruct sea_softc *sea;\n{\n\tint i;\n  \n\t/* Reset the scsi bus (I don't know if this is needed */\n\tCONTROL = BASE_CMD | CMD_DRVR_ENABLE | CMD_RST;\n\tdelay(25);\t/* hold reset for at least 25 microseconds */\n\tCONTROL = BASE_CMD;\n\tdelay(10); \t/* wait a Bus Clear Delay (800 ns + bus free delay (800 ns) */\n\n\t/* Set our id (don't know anything about this) */\n\tswitch (sea->type) {\n\tcase SEAGATE:\n\t\tsea->our_id = 7;\n\t\tbreak;\n\tcase FDOMAIN:\n\tcase FDOMAIN840:\n\t\tsea->our_id = 6;\n\t\tbreak;\n\t}\n\tsea->our_id_mask = 1 << sea->our_id;\n\n\t/* init fields used by our routines */\n\tsea->nexus = 0;\n\tTAILQ_INIT(&sea->ready_list);\n\tTAILQ_INIT(&sea->nexus_list);\n\tTAILQ_INIT(&sea->free_list);\n\tfor (i = 0; i < 8; i++)\n\t\tsea->busy[i] = 0x00;\n\n\t/* link up the free list of scbs */\n\tsea->numscbs = SCB_TABLE_SIZE;\n\tfor (i = 0; i < SCB_TABLE_SIZE; i++) {\n\t\tTAILQ_INSERT_TAIL(&sea->free_list, &sea->scb[i], chain);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint seaintr;\nvoid sea_init;\nstruct scsi_adapter sea_switch = {\n\tsea_scsi_cmd,\n\tminphys,\t/* no special minphys(), since driver uses PIO */\n\t0,\n\t0,\n};\nstruct scsi_device sea_dev = {\n\tNULL,\t\t/* use default error handler */\n\tNULL,\t\t/* have a queue, served by this */\n\tNULL,\t\t/* have no async handler */\n\tNULL,\t\t/* Use default 'done' routine */\n};\nvoid\tseaattach;\nint\tseaprint;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nseaattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct sea_softc *sea = (void *)self;\n\n\tsea_init(sea);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tsea->sc_link.adapter_softc = sea;\n\tsea->sc_link.adapter_target = sea->our_id;\n\tsea->sc_link.adapter = &sea_switch;\n\tsea->sc_link.device = &sea_dev;\n\tsea->sc_link.openings = 1;\n  \n\tprintf(\"\\n\");\n\n\tsea->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_BIO, seaintr, sea, sea->sc_dev.dv_xname);\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tconfig_found(self, &sea->sc_link, seaprint);\n}"
  },
  {
    "function_name": "seaprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "413-421",
    "snippet": "int\nseaprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\tif (name != NULL)       \n\t\tprintf(\"%s: scsibus \", name);\n\treturn UNCONF;\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tseaprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: scsibus \"",
            "name"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tseaprint;\n\nint\nseaprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\tif (name != NULL)       \n\t\tprintf(\"%s: scsibus \", name);\n\treturn UNCONF;\n}"
  },
  {
    "function_name": "seaprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "343-411",
    "snippet": "int\nseaprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct sea_softc *sea = match;\n\tstruct isa_attach_args *ia = aux;\n\tint i;\n\n\t/*\n\t * Could try to find a board by looking through all possible addresses.\n\t * This is not done the right way now, because I have not found a way\n\t * to get a boards virtual memory address given its physical.  There is\n\t * a function that returns the physical address for a given virtual\n\t * address, but not the other way around.\n\t */\n\n\tif (ia->ia_maddr == MADDRUNK) {\n\t\t/* XXX */\n\t\treturn 0;\n\t} else\n\t\tsea->maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\t\n\t/* check board type */\t/* No way to define this through config */\n\tfor (i = 0; i < nsignatures; i++)\n\t\tif (!bcmp(sea->maddr + signatures[i].offset,\n\t\t    signatures[i].signature, signatures[i].length)) {\n\t\t\tsea->type = signatures[i].type;\n\t\t\tbreak;\n\t\t}\n\n\t/* Find controller and data memory addresses */\n\tswitch (sea->type) {\n\tcase SEAGATE:\n\tcase FDOMAIN840:\n\t\tsea->maddr_cr_sr =\n\t\t    (void *) (((u_char *)sea->maddr) + 0x1a00);\n\t\tsea->maddr_dr =\n\t\t    (void *) (((u_char *)sea->maddr) + 0x1c00);\n\t\tbreak;\n\tcase FDOMAIN:\n\t\tsea->maddr_cr_sr =\n\t\t    (void *) (((u_char *)sea->maddr) + 0x1c00);\n\t\tsea->maddr_dr =\n\t\t    (void *) (((u_char *)sea->maddr) + 0x1e00);\n\t\tbreak;\n\tdefault:\n#if 0\n\t\tprintf(\"%s: board type unknown at address %p\\n\",\n\t\t    sea->sc_dev.dv_xname, sea->maddr);\n#endif\n\t\treturn 0;\n\t}\n\n\t/* Test controller RAM (works the same way on future domain cards?) */\n\t*((u_char *)sea->maddr + SEA_RAMOFFSET) = 0xa5;\n\t*((u_char *)sea->maddr + SEA_RAMOFFSET + 1) = 0x5a;\n\n\tif ((*((u_char *)sea->maddr + SEA_RAMOFFSET) != 0xa5) ||\n\t    (*((u_char *)sea->maddr + SEA_RAMOFFSET + 1) != 0x5a)) {\n\t\tprintf(\"%s: board RAM failure\\n\", sea->sc_dev.dv_xname);\n\t\treturn 0;\n\t}\n  \n\tia->ia_drq = DRQUNK;\n\tia->ia_msize = 0x2000;\n\tia->ia_iosize = 0;\n\treturn 1;\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tnsignatures\t(sizeof(signatures) / sizeof(signatures[0]))",
      "#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */",
      "#define\tFDOMAIN\t\t2\t/* Future Domain TMC-{885,950} */",
      "#define\tSEAGATE\t\t1\t/* Seagate ST0[12] */",
      "#define SEA_RAMOFFSET\t0x00001800"
    ],
    "globals_used": [
      "static const BiosSignature signatures[] = {\n{\"ST01 v1.7  (C) Copyright 1987 Seagate\", 15, 37, SEAGATE},\n{\"SCSI BIOS 2.00  (C) Copyright 1987 Seagate\", 15, 40, SEAGATE},\n\n/*\n * The following two lines are NOT mistakes. One detects ROM revision\n * 3.0.0, the other 3.2. Since seagate has only one type of SCSI adapter,\n * and this is not going to change, the \"SEAGATE\" and \"SCSI\" together\n * are probably \"good enough\"\n */\n{\"SEAGATE SCSI BIOS \", 16, 17, SEAGATE},\n{\"SEAGATE SCSI BIOS \", 17, 17, SEAGATE},\n\n/*\n * However, future domain makes several incompatible SCSI boards, so specific\n * signatures must be used.\n */\n{\"FUTURE DOMAIN CORP. (C) 1986-1989 V5.0C2/14/89\", 5, 45, FDOMAIN},\n{\"FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/89\", 5, 46, FDOMAIN},\n{\"FUTURE DOMAIN CORP. (C) 1986-1990 V6.0105/31/90\",5, 47, FDOMAIN},\n{\"FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90\",5, 47, FDOMAIN},\n{\"FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90\", 5, 46, FDOMAIN},\n{\"FUTURE DOMAIN CORP. (C) 1992 V8.00.004/02/92\",   5, 44, FDOMAIN},\n{\"FUTURE DOMAIN TMC-950\",\t\t\t   5, 21, FDOMAIN},\n};",
      "int\tseaprobe",
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: board RAM failure\\n\"",
            "sea->sc_dev.dv_xname"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "sea->maddr + signatures[i].offset",
            "signatures[i].signature",
            "signatures[i].length"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISA_HOLE_VADDR",
          "args": [
            "ia->ia_maddr"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tnsignatures\t(sizeof(signatures) / sizeof(signatures[0]))\n#define\tFDOMAIN840\t3\t/* Future Domain TMC-{84[01],88[01]} */\n#define\tFDOMAIN\t\t2\t/* Future Domain TMC-{885,950} */\n#define\tSEAGATE\t\t1\t/* Seagate ST0[12] */\n#define SEA_RAMOFFSET\t0x00001800\n\nstatic const BiosSignature signatures[] = {\n{\"ST01 v1.7  (C) Copyright 1987 Seagate\", 15, 37, SEAGATE},\n{\"SCSI BIOS 2.00  (C) Copyright 1987 Seagate\", 15, 40, SEAGATE},\n\n/*\n * The following two lines are NOT mistakes. One detects ROM revision\n * 3.0.0, the other 3.2. Since seagate has only one type of SCSI adapter,\n * and this is not going to change, the \"SEAGATE\" and \"SCSI\" together\n * are probably \"good enough\"\n */\n{\"SEAGATE SCSI BIOS \", 16, 17, SEAGATE},\n{\"SEAGATE SCSI BIOS \", 17, 17, SEAGATE},\n\n/*\n * However, future domain makes several incompatible SCSI boards, so specific\n * signatures must be used.\n */\n{\"FUTURE DOMAIN CORP. (C) 1986-1989 V5.0C2/14/89\", 5, 45, FDOMAIN},\n{\"FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/89\", 5, 46, FDOMAIN},\n{\"FUTURE DOMAIN CORP. (C) 1986-1990 V6.0105/31/90\",5, 47, FDOMAIN},\n{\"FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90\",5, 47, FDOMAIN},\n{\"FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90\", 5, 46, FDOMAIN},\n{\"FUTURE DOMAIN CORP. (C) 1992 V8.00.004/02/92\",   5, 44, FDOMAIN},\n{\"FUTURE DOMAIN TMC-950\",\t\t\t   5, 21, FDOMAIN},\n};\nint\tseaprobe;\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nint\nseaprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct sea_softc *sea = match;\n\tstruct isa_attach_args *ia = aux;\n\tint i;\n\n\t/*\n\t * Could try to find a board by looking through all possible addresses.\n\t * This is not done the right way now, because I have not found a way\n\t * to get a boards virtual memory address given its physical.  There is\n\t * a function that returns the physical address for a given virtual\n\t * address, but not the other way around.\n\t */\n\n\tif (ia->ia_maddr == MADDRUNK) {\n\t\t/* XXX */\n\t\treturn 0;\n\t} else\n\t\tsea->maddr = ISA_HOLE_VADDR(ia->ia_maddr);\n\t\n\t/* check board type */\t/* No way to define this through config */\n\tfor (i = 0; i < nsignatures; i++)\n\t\tif (!bcmp(sea->maddr + signatures[i].offset,\n\t\t    signatures[i].signature, signatures[i].length)) {\n\t\t\tsea->type = signatures[i].type;\n\t\t\tbreak;\n\t\t}\n\n\t/* Find controller and data memory addresses */\n\tswitch (sea->type) {\n\tcase SEAGATE:\n\tcase FDOMAIN840:\n\t\tsea->maddr_cr_sr =\n\t\t    (void *) (((u_char *)sea->maddr) + 0x1a00);\n\t\tsea->maddr_dr =\n\t\t    (void *) (((u_char *)sea->maddr) + 0x1c00);\n\t\tbreak;\n\tcase FDOMAIN:\n\t\tsea->maddr_cr_sr =\n\t\t    (void *) (((u_char *)sea->maddr) + 0x1c00);\n\t\tsea->maddr_dr =\n\t\t    (void *) (((u_char *)sea->maddr) + 0x1e00);\n\t\tbreak;\n\tdefault:\n#if 0\n\t\tprintf(\"%s: board type unknown at address %p\\n\",\n\t\t    sea->sc_dev.dv_xname, sea->maddr);\n#endif\n\t\treturn 0;\n\t}\n\n\t/* Test controller RAM (works the same way on future domain cards?) */\n\t*((u_char *)sea->maddr + SEA_RAMOFFSET) = 0xa5;\n\t*((u_char *)sea->maddr + SEA_RAMOFFSET + 1) = 0x5a;\n\n\tif ((*((u_char *)sea->maddr + SEA_RAMOFFSET) != 0xa5) ||\n\t    (*((u_char *)sea->maddr + SEA_RAMOFFSET + 1) != 0x5a)) {\n\t\tprintf(\"%s: board RAM failure\\n\", sea->sc_dev.dv_xname);\n\t\treturn 0;\n\t}\n  \n\tia->ia_drq = DRQUNK;\n\tia->ia_msize = 0x2000;\n\tia->ia_iosize = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "sea_queue_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/seagate.c",
    "lines": "320-334",
    "snippet": "void\nsea_queue_length(sea)\n\tstruct sea_softc *sea;\n{\n\tstruct sea_scb *scb;\n\tint connected, issued, disconnected;\n\n\tconnected = sea->nexus ? 1 : 0;\n\tfor (scb = sea->ready_list.tqh_first, issued = 0; scb;\n\t    scb = scb->chain.tqe_next, issued++);\n\tfor (scb = sea->nexus_list.tqh_first, disconnected = 0; scb;\n\t    scb = scb->chain.tqe_next, disconnected++);\n\tprintf(\"%s: length: %d/%d/%d\\n\", sea->sc_dev.dv_xname, connected,\n\t    issued, disconnected);\n}",
    "includes": [
      "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_all.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: length: %d/%d/%d\\n\"",
            "sea->sc_dev.dv_xname",
            "connected",
            "issued",
            "disconnected"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct sea_scb *\nsea_get_scb(sea, flags)\n\tstruct sea_softc *sea;\n\nvoid\nsea_queue_length(sea)\n\tstruct sea_softc *sea;\n{\n\tstruct sea_scb *scb;\n\tint connected, issued, disconnected;\n\n\tconnected = sea->nexus ? 1 : 0;\n\tfor (scb = sea->ready_list.tqh_first, issued = 0; scb;\n\t    scb = scb->chain.tqe_next, issued++);\n\tfor (scb = sea->nexus_list.tqh_first, disconnected = 0; scb;\n\t    scb = scb->chain.tqe_next, disconnected++);\n\tprintf(\"%s: length: %d/%d/%d\\n\", sea->sc_dev.dv_xname, connected,\n\t    issued, disconnected);\n}"
  }
]