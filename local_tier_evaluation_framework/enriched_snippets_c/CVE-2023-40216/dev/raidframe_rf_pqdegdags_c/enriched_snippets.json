[
  {
    "function_name": "rf_PQWriteDoubleRecoveryFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pqdegdags.c",
    "lines": "276-371",
    "snippet": "int \nrf_PQWriteDoubleRecoveryFunc(node)\n\tRF_DagNode_t *node;\n{\n\t/* The situation:\n\t * \n\t * We are doing a write that hits only one failed data unit. The other\n\t * failed data unit is not being overwritten, so we need to generate\n\t * it.\n\t * \n\t * For the moment, we assume all the nonfailed data being written is in\n\t * the shadow of the failed data unit. (i.e,, either a single data\n\t * unit write or the entire failed stripe unit is being overwritten. )\n\t * \n\t * Recovery strategy: apply the recovery data to the parity and q. Use P\n\t * & Q to recover the second failed data unit in P. Zero fill Q, then\n\t * apply the recovered data to p. Then apply the data being written to\n\t * the failed drive. Then walk through the surviving drives, applying\n\t * new data when it exists, othewise the recovery data. Quite a mess.\n\t * \n\t * \n\t * The params\n\t * \n\t * read pda0, read pda1, ... read pda (numDataCol-3), write pda0, ... ,\n\t * write pda (numStripeUnitAccess - numDataFailed), failed pda,\n\t * raidPtr, asmap */\n\n\tint     np = node->numParams;\n\tRF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np - 1].p;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 2].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     i;\n\tRF_RaidAddr_t sosAddr;\n\tunsigned coeff;\n\tRF_StripeCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;\n\tRF_PhysDiskAddr_t *ppda, *qpda, *pda, npda;\n\tint     numDataCol = layoutPtr->numDataCol;\n\tRF_Etimer_t timer;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\n\tRF_ASSERT(node->numResults == 2);\n\tRF_ASSERT(asmap->failedPDAs[1] == NULL);\n\tRF_ETIMER_START(timer);\n\tppda = node->results[0];\n\tqpda = node->results[1];\n\t/* apply the recovery data */\n\tfor (i = 0; i < numDataCol - 2; i++)\n\t\tapplyPDA(raidPtr, node->params[i].p, ppda, qpda, node->dagHdr->bp);\n\n\t/* determine the other failed data unit */\n\tpda = asmap->failedPDAs[0];\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\t/* need to determine the column of the other failed disk */\n\tcoeff = rf_RaidAddressToStripeUnitID(layoutPtr, pda->raidAddress);\n\t/* compute the data unit offset within the column */\n\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\tfor (i = 0; i < numDataCol; i++) {\n\t\tnpda.raidAddress = sosAddr + (i * secPerSU);\n\t\t(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);\n\t\t/* skip over dead disks */\n\t\tif (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))\n\t\t\tif (i != coeff)\n\t\t\t\tbreak;\n\t}\n\tRF_ASSERT(i < numDataCol);\n\t/* recover the data. The column we want to recover we write over the\n\t * parity. The column we don't care about we dump in q. */\n\tif (coeff < i)\t\t/* recovering 'a' */\n\t\trf_PQ_recover((unsigned long *) ppda->bufPtr, (unsigned long *) qpda->bufPtr, (unsigned long *) ppda->bufPtr, (unsigned long *) qpda->bufPtr, rf_RaidAddressToByte(raidPtr, pda->numSector), coeff, i);\n\telse\t\t\t/* recovering 'b' */\n\t\trf_PQ_recover((unsigned long *) ppda->bufPtr, (unsigned long *) qpda->bufPtr, (unsigned long *) qpda->bufPtr, (unsigned long *) ppda->bufPtr, rf_RaidAddressToByte(raidPtr, pda->numSector), i, coeff);\n\n\t/* OK. The valid data is in P. Zero fill Q, then inc it into it. */\n\tbzero(qpda->bufPtr, rf_RaidAddressToByte(raidPtr, qpda->numSector));\n\trf_IncQ((unsigned long *) qpda->bufPtr, (unsigned long *) ppda->bufPtr, rf_RaidAddressToByte(raidPtr, qpda->numSector), i);\n\n\t/* now apply all the write data to the buffer */\n\t/* single stripe unit write case: the failed data is only thing we are\n\t * writing. */\n\tRF_ASSERT(asmap->numStripeUnitsAccessed == 1);\n\t/* dest, src, len, coeff */\n\trf_IncQ((unsigned long *) qpda->bufPtr, (unsigned long *) asmap->failedPDAs[0]->bufPtr, rf_RaidAddressToByte(raidPtr, qpda->numSector), coeff);\n\trf_bxor(asmap->failedPDAs[0]->bufPtr, ppda->bufPtr, rf_RaidAddressToByte(raidPtr, ppda->numSector), node->dagHdr->bp);\n\n\t/* now apply all the recovery data */\n\tfor (i = 0; i < numDataCol - 2; i++)\n\t\tapplyPDA(raidPtr, node->params[i].p, ppda, qpda, node->dagHdr->bp);\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\tif (tracerec)\n\t\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\n\trf_GenericWakeupFunc(node, 0);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_pqdegdags.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "applyPDA",
          "args": [
            "raidPtr",
            "node->params[i].p",
            "ppda",
            "qpda",
            "node->dagHdr->bp"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "applyPDA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pqdegdags.c",
          "lines": "120-166",
          "snippet": "static void \napplyPDA(raidPtr, pda, ppda, qpda, bp)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tRF_PhysDiskAddr_t *ppda;\n\tRF_PhysDiskAddr_t *qpda;\n\tvoid   *bp;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t s0off = rf_StripeUnitOffset(layoutPtr, ppda->startSector);\n\tRF_SectorCount_t s0len = ppda->numSector, len;\n\tRF_SectorNum_t suoffset;\n\tunsigned coeff;\n\tchar   *pbuf = ppda->bufPtr;\n\tchar   *qbuf = qpda->bufPtr;\n\tchar   *buf;\n\tint     delta;\n\n\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\tlen = pda->numSector;\n\t/* see if pda intersects a recovery pda */\n\tif ((suoffset < s0off + s0len) && (suoffset + len > s0off)) {\n\t\tbuf = pda->bufPtr;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), pda->raidAddress);\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\n\t\tif (suoffset < s0off) {\n\t\t\tdelta = s0off - suoffset;\n\t\t\tbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tsuoffset = s0off;\n\t\t\tlen -= delta;\n\t\t}\n\t\tif (suoffset > s0off) {\n\t\t\tdelta = suoffset - s0off;\n\t\t\tpbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tqbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t}\n\t\tif ((suoffset + len) > (s0len + s0off))\n\t\t\tlen = s0len + s0off - suoffset;\n\n\t\t/* src, dest, len */\n\t\trf_bxor(buf, pbuf, rf_RaidAddressToByte(raidPtr, len), bp);\n\n\t\t/* dest, src, len, coeff */\n\t\trf_IncQ((unsigned long *) qbuf, (unsigned long *) buf, rf_RaidAddressToByte(raidPtr, len), coeff);\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_pqdegdags.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_pqdegdags.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \napplyPDA(raidPtr, pda, ppda, qpda, bp)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tRF_PhysDiskAddr_t *ppda;\n\tRF_PhysDiskAddr_t *qpda;\n\tvoid   *bp;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t s0off = rf_StripeUnitOffset(layoutPtr, ppda->startSector);\n\tRF_SectorCount_t s0len = ppda->numSector, len;\n\tRF_SectorNum_t suoffset;\n\tunsigned coeff;\n\tchar   *pbuf = ppda->bufPtr;\n\tchar   *qbuf = qpda->bufPtr;\n\tchar   *buf;\n\tint     delta;\n\n\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\tlen = pda->numSector;\n\t/* see if pda intersects a recovery pda */\n\tif ((suoffset < s0off + s0len) && (suoffset + len > s0off)) {\n\t\tbuf = pda->bufPtr;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), pda->raidAddress);\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\n\t\tif (suoffset < s0off) {\n\t\t\tdelta = s0off - suoffset;\n\t\t\tbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tsuoffset = s0off;\n\t\t\tlen -= delta;\n\t\t}\n\t\tif (suoffset > s0off) {\n\t\t\tdelta = suoffset - s0off;\n\t\t\tpbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tqbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t}\n\t\tif ((suoffset + len) > (s0len + s0off))\n\t\t\tlen = s0len + s0off - suoffset;\n\n\t\t/* src, dest, len */\n\t\trf_bxor(buf, pbuf, rf_RaidAddressToByte(raidPtr, len), bp);\n\n\t\t/* dest, src, len, coeff */\n\t\trf_IncQ((unsigned long *) qbuf, (unsigned long *) buf, rf_RaidAddressToByte(raidPtr, len), coeff);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_bxor",
          "args": [
            "asmap->failedPDAs[0]->bufPtr",
            "ppda->bufPtr",
            "rf_RaidAddressToByte(raidPtr, ppda->numSector)",
            "node->dagHdr->bp"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "rf_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "880-893",
          "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "ppda->numSector"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_IncQ",
          "args": [
            "(unsigned long *) qpda->bufPtr",
            "(unsigned long *) asmap->failedPDAs[0]->bufPtr",
            "rf_RaidAddressToByte(raidPtr, qpda->numSector)",
            "coeff"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "rf_IncQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "666-725",
          "snippet": "void \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "qpda->numSector"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "asmap->numStripeUnitsAccessed == 1"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "qpda->numSector"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "qpda->bufPtr",
            "rf_RaidAddressToByte(raidPtr, qpda->numSector)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "qpda->numSector"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_PQ_recover",
          "args": [
            "(unsigned long *) ppda->bufPtr",
            "(unsigned long *) qpda->bufPtr",
            "(unsigned long *) qpda->bufPtr",
            "(unsigned long *) ppda->bufPtr",
            "rf_RaidAddressToByte(raidPtr, pda->numSector)",
            "i",
            "coeff"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PQ_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "820-864",
          "snippet": "void \nrf_PQ_recover(pbuf, qbuf, abuf, bbuf, length, coeff_a, coeff_b)\n\tunsigned long *pbuf;\n\tunsigned long *qbuf;\n\tunsigned long *abuf;\n\tunsigned long *bbuf;\n\tunsigned length;\n\tunsigned coeff_a;\n\tunsigned coeff_b;\n{\n\tunsigned long p, q, a, a0, a1;\n\tint     col = (29 * coeff_a) + coeff_b;\n\tunsigned char *q0 = &(rf_qinv[col][0]);\n\n\tlength /= 8;\n\twhile (length) {\n\t\tp = *pbuf++;\n\t\tq = *qbuf++;\n\t\ta0 = EXTRACT(p, 0);\n\t\ta1 = EXTRACT(q, 0);\n\t\ta = q0[a0 << 5 | a1];\n#define MF(i) \\\n      a0 = EXTRACT(p,i); \\\n      a1 = EXTRACT(q,i); \\\n      a  = a | INSERT(q0[a0<<5 | a1],i)\n\n\t\tMF(1);\n\t\tMF(2);\n\t\tMF(3);\n\t\tMF(4);\n\t\tMF(5);\n\t\tMF(6);\n#if 0\n\t\tMF(7);\n\t\tMF(8);\n\t\tMF(9);\n\t\tMF(10);\n\t\tMF(11);\n\t\tMF(12);\n#endif\t\t\t\t/* 0 */\n\t\t*abuf++ = a;\n\t\t*bbuf++ = a ^ p;\n\t\tlength--;\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_PQ_recover(pbuf, qbuf, abuf, bbuf, length, coeff_a, coeff_b)\n\tunsigned long *pbuf;\n\tunsigned long *qbuf;\n\tunsigned long *abuf;\n\tunsigned long *bbuf;\n\tunsigned length;\n\tunsigned coeff_a;\n\tunsigned coeff_b;\n{\n\tunsigned long p, q, a, a0, a1;\n\tint     col = (29 * coeff_a) + coeff_b;\n\tunsigned char *q0 = &(rf_qinv[col][0]);\n\n\tlength /= 8;\n\twhile (length) {\n\t\tp = *pbuf++;\n\t\tq = *qbuf++;\n\t\ta0 = EXTRACT(p, 0);\n\t\ta1 = EXTRACT(q, 0);\n\t\ta = q0[a0 << 5 | a1];\n#define MF(i) \\\n      a0 = EXTRACT(p,i); \\\n      a1 = EXTRACT(q,i); \\\n      a  = a | INSERT(q0[a0<<5 | a1],i)\n\n\t\tMF(1);\n\t\tMF(2);\n\t\tMF(3);\n\t\tMF(4);\n\t\tMF(5);\n\t\tMF(6);\n#if 0\n\t\tMF(7);\n\t\tMF(8);\n\t\tMF(9);\n\t\tMF(10);\n\t\tMF(11);\n\t\tMF(12);\n#endif\t\t\t\t/* 0 */\n\t\t*abuf++ = a;\n\t\t*bbuf++ = a ^ p;\n\t\tlength--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "pda->numSector"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "pda->numSector"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i < numDataCol"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "raidPtr->Disks[npda.row][npda.col].status"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "npda.raidAddress",
            "&(npda.row)",
            "&(npda.col)",
            "&(npda.startSector)",
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "asmap->raidAddress"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "asmap->failedPDAs[1] == NULL"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->numResults == 2"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_pqdegdags.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_PQWriteDoubleRecoveryFunc(node)\n\tRF_DagNode_t *node;\n{\n\t/* The situation:\n\t * \n\t * We are doing a write that hits only one failed data unit. The other\n\t * failed data unit is not being overwritten, so we need to generate\n\t * it.\n\t * \n\t * For the moment, we assume all the nonfailed data being written is in\n\t * the shadow of the failed data unit. (i.e,, either a single data\n\t * unit write or the entire failed stripe unit is being overwritten. )\n\t * \n\t * Recovery strategy: apply the recovery data to the parity and q. Use P\n\t * & Q to recover the second failed data unit in P. Zero fill Q, then\n\t * apply the recovered data to p. Then apply the data being written to\n\t * the failed drive. Then walk through the surviving drives, applying\n\t * new data when it exists, othewise the recovery data. Quite a mess.\n\t * \n\t * \n\t * The params\n\t * \n\t * read pda0, read pda1, ... read pda (numDataCol-3), write pda0, ... ,\n\t * write pda (numStripeUnitAccess - numDataFailed), failed pda,\n\t * raidPtr, asmap */\n\n\tint     np = node->numParams;\n\tRF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np - 1].p;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 2].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     i;\n\tRF_RaidAddr_t sosAddr;\n\tunsigned coeff;\n\tRF_StripeCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;\n\tRF_PhysDiskAddr_t *ppda, *qpda, *pda, npda;\n\tint     numDataCol = layoutPtr->numDataCol;\n\tRF_Etimer_t timer;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\n\tRF_ASSERT(node->numResults == 2);\n\tRF_ASSERT(asmap->failedPDAs[1] == NULL);\n\tRF_ETIMER_START(timer);\n\tppda = node->results[0];\n\tqpda = node->results[1];\n\t/* apply the recovery data */\n\tfor (i = 0; i < numDataCol - 2; i++)\n\t\tapplyPDA(raidPtr, node->params[i].p, ppda, qpda, node->dagHdr->bp);\n\n\t/* determine the other failed data unit */\n\tpda = asmap->failedPDAs[0];\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\t/* need to determine the column of the other failed disk */\n\tcoeff = rf_RaidAddressToStripeUnitID(layoutPtr, pda->raidAddress);\n\t/* compute the data unit offset within the column */\n\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\tfor (i = 0; i < numDataCol; i++) {\n\t\tnpda.raidAddress = sosAddr + (i * secPerSU);\n\t\t(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);\n\t\t/* skip over dead disks */\n\t\tif (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))\n\t\t\tif (i != coeff)\n\t\t\t\tbreak;\n\t}\n\tRF_ASSERT(i < numDataCol);\n\t/* recover the data. The column we want to recover we write over the\n\t * parity. The column we don't care about we dump in q. */\n\tif (coeff < i)\t\t/* recovering 'a' */\n\t\trf_PQ_recover((unsigned long *) ppda->bufPtr, (unsigned long *) qpda->bufPtr, (unsigned long *) ppda->bufPtr, (unsigned long *) qpda->bufPtr, rf_RaidAddressToByte(raidPtr, pda->numSector), coeff, i);\n\telse\t\t\t/* recovering 'b' */\n\t\trf_PQ_recover((unsigned long *) ppda->bufPtr, (unsigned long *) qpda->bufPtr, (unsigned long *) qpda->bufPtr, (unsigned long *) ppda->bufPtr, rf_RaidAddressToByte(raidPtr, pda->numSector), i, coeff);\n\n\t/* OK. The valid data is in P. Zero fill Q, then inc it into it. */\n\tbzero(qpda->bufPtr, rf_RaidAddressToByte(raidPtr, qpda->numSector));\n\trf_IncQ((unsigned long *) qpda->bufPtr, (unsigned long *) ppda->bufPtr, rf_RaidAddressToByte(raidPtr, qpda->numSector), i);\n\n\t/* now apply all the write data to the buffer */\n\t/* single stripe unit write case: the failed data is only thing we are\n\t * writing. */\n\tRF_ASSERT(asmap->numStripeUnitsAccessed == 1);\n\t/* dest, src, len, coeff */\n\trf_IncQ((unsigned long *) qpda->bufPtr, (unsigned long *) asmap->failedPDAs[0]->bufPtr, rf_RaidAddressToByte(raidPtr, qpda->numSector), coeff);\n\trf_bxor(asmap->failedPDAs[0]->bufPtr, ppda->bufPtr, rf_RaidAddressToByte(raidPtr, ppda->numSector), node->dagHdr->bp);\n\n\t/* now apply all the recovery data */\n\tfor (i = 0; i < numDataCol - 2; i++)\n\t\tapplyPDA(raidPtr, node->params[i].p, ppda, qpda, node->dagHdr->bp);\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\tif (tracerec)\n\t\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\n\trf_GenericWakeupFunc(node, 0);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_PQDoubleRecoveryFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pqdegdags.c",
    "lines": "187-274",
    "snippet": "int \nrf_PQDoubleRecoveryFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tRF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np - 1].p;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 2].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     d, i;\n\tunsigned coeff;\n\tRF_RaidAddr_t sosAddr, suoffset;\n\tRF_SectorCount_t len, secPerSU = layoutPtr->sectorsPerStripeUnit;\n\tint     two = 0;\n\tRF_PhysDiskAddr_t *ppda, *ppda2, *qpda, *qpda2, *pda, npda;\n\tchar   *buf;\n\tint     numDataCol = layoutPtr->numDataCol;\n\tRF_Etimer_t timer;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\n\tRF_ETIMER_START(timer);\n\n\tif (asmap->failedPDAs[1] &&\n\t    (asmap->failedPDAs[1]->numSector + asmap->failedPDAs[0]->numSector < secPerSU)) {\n\t\tRF_ASSERT(0);\n\t\tppda = node->params[np - 6].p;\n\t\tppda2 = node->params[np - 5].p;\n\t\tqpda = node->params[np - 4].p;\n\t\tqpda2 = node->params[np - 3].p;\n\t\td = (np - 6);\n\t\ttwo = 1;\n\t} else {\n\t\tppda = node->params[np - 4].p;\n\t\tqpda = node->params[np - 3].p;\n\t\td = (np - 4);\n\t}\n\n\tfor (i = 0; i < d; i++) {\n\t\tpda = node->params[i].p;\n\t\tbuf = pda->bufPtr;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tlen = pda->numSector;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(layoutPtr, pda->raidAddress);\n\t\t/* compute the data unit offset within the column */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* see if pda intersects a recovery pda */\n\t\tapplyPDA(raidPtr, pda, ppda, qpda, node->dagHdr->bp);\n\t\tif (two)\n\t\t\tapplyPDA(raidPtr, pda, ppda, qpda, node->dagHdr->bp);\n\t}\n\n\t/* ok, we got the parity back to the point where we can recover. We\n\t * now need to determine the coeff of the columns that need to be\n\t * recovered. We can also only need to recover a single stripe unit. */\n\n\tif (asmap->failedPDAs[1] == NULL) {\t/* only a single stripe unit\n\t\t\t\t\t\t * to recover. */\n\t\tpda = asmap->failedPDAs[0];\n\t\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\t\t/* need to determine the column of the other failed disk */\n\t\tcoeff = rf_RaidAddressToStripeUnitID(layoutPtr, pda->raidAddress);\n\t\t/* compute the data unit offset within the column */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\tfor (i = 0; i < numDataCol; i++) {\n\t\t\tnpda.raidAddress = sosAddr + (i * secPerSU);\n\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);\n\t\t\t/* skip over dead disks */\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))\n\t\t\t\tif (i != coeff)\n\t\t\t\t\tbreak;\n\t\t}\n\t\tRF_ASSERT(i < numDataCol);\n\t\tRF_ASSERT(two == 0);\n\t\t/* recover the data. Since we need only want to recover one\n\t\t * column, we overwrite the parity with the other one. */\n\t\tif (coeff < i)\t/* recovering 'a' */\n\t\t\trf_PQ_recover((unsigned long *) ppda->bufPtr, (unsigned long *) qpda->bufPtr, (unsigned long *) pda->bufPtr, (unsigned long *) ppda->bufPtr, rf_RaidAddressToByte(raidPtr, pda->numSector), coeff, i);\n\t\telse\t\t/* recovering 'b' */\n\t\t\trf_PQ_recover((unsigned long *) ppda->bufPtr, (unsigned long *) qpda->bufPtr, (unsigned long *) ppda->bufPtr, (unsigned long *) pda->bufPtr, rf_RaidAddressToByte(raidPtr, pda->numSector), i, coeff);\n\t} else\n\t\tRF_PANIC();\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\tif (tracerec)\n\t\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_pqdegdags.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_PQ_recover",
          "args": [
            "(unsigned long *) ppda->bufPtr",
            "(unsigned long *) qpda->bufPtr",
            "(unsigned long *) ppda->bufPtr",
            "(unsigned long *) pda->bufPtr",
            "rf_RaidAddressToByte(raidPtr, pda->numSector)",
            "i",
            "coeff"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PQ_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "820-864",
          "snippet": "void \nrf_PQ_recover(pbuf, qbuf, abuf, bbuf, length, coeff_a, coeff_b)\n\tunsigned long *pbuf;\n\tunsigned long *qbuf;\n\tunsigned long *abuf;\n\tunsigned long *bbuf;\n\tunsigned length;\n\tunsigned coeff_a;\n\tunsigned coeff_b;\n{\n\tunsigned long p, q, a, a0, a1;\n\tint     col = (29 * coeff_a) + coeff_b;\n\tunsigned char *q0 = &(rf_qinv[col][0]);\n\n\tlength /= 8;\n\twhile (length) {\n\t\tp = *pbuf++;\n\t\tq = *qbuf++;\n\t\ta0 = EXTRACT(p, 0);\n\t\ta1 = EXTRACT(q, 0);\n\t\ta = q0[a0 << 5 | a1];\n#define MF(i) \\\n      a0 = EXTRACT(p,i); \\\n      a1 = EXTRACT(q,i); \\\n      a  = a | INSERT(q0[a0<<5 | a1],i)\n\n\t\tMF(1);\n\t\tMF(2);\n\t\tMF(3);\n\t\tMF(4);\n\t\tMF(5);\n\t\tMF(6);\n#if 0\n\t\tMF(7);\n\t\tMF(8);\n\t\tMF(9);\n\t\tMF(10);\n\t\tMF(11);\n\t\tMF(12);\n#endif\t\t\t\t/* 0 */\n\t\t*abuf++ = a;\n\t\t*bbuf++ = a ^ p;\n\t\tlength--;\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_PQ_recover(pbuf, qbuf, abuf, bbuf, length, coeff_a, coeff_b)\n\tunsigned long *pbuf;\n\tunsigned long *qbuf;\n\tunsigned long *abuf;\n\tunsigned long *bbuf;\n\tunsigned length;\n\tunsigned coeff_a;\n\tunsigned coeff_b;\n{\n\tunsigned long p, q, a, a0, a1;\n\tint     col = (29 * coeff_a) + coeff_b;\n\tunsigned char *q0 = &(rf_qinv[col][0]);\n\n\tlength /= 8;\n\twhile (length) {\n\t\tp = *pbuf++;\n\t\tq = *qbuf++;\n\t\ta0 = EXTRACT(p, 0);\n\t\ta1 = EXTRACT(q, 0);\n\t\ta = q0[a0 << 5 | a1];\n#define MF(i) \\\n      a0 = EXTRACT(p,i); \\\n      a1 = EXTRACT(q,i); \\\n      a  = a | INSERT(q0[a0<<5 | a1],i)\n\n\t\tMF(1);\n\t\tMF(2);\n\t\tMF(3);\n\t\tMF(4);\n\t\tMF(5);\n\t\tMF(6);\n#if 0\n\t\tMF(7);\n\t\tMF(8);\n\t\tMF(9);\n\t\tMF(10);\n\t\tMF(11);\n\t\tMF(12);\n#endif\t\t\t\t/* 0 */\n\t\t*abuf++ = a;\n\t\t*bbuf++ = a ^ p;\n\t\tlength--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "pda->numSector"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "pda->numSector"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "two == 0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i < numDataCol"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "raidPtr->Disks[npda.row][npda.col].status"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "npda.raidAddress",
            "&(npda.row)",
            "&(npda.col)",
            "&(npda.startSector)",
            "0"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "asmap->raidAddress"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "applyPDA",
          "args": [
            "raidPtr",
            "pda",
            "ppda",
            "qpda",
            "node->dagHdr->bp"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "applyPDA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pqdegdags.c",
          "lines": "120-166",
          "snippet": "static void \napplyPDA(raidPtr, pda, ppda, qpda, bp)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tRF_PhysDiskAddr_t *ppda;\n\tRF_PhysDiskAddr_t *qpda;\n\tvoid   *bp;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t s0off = rf_StripeUnitOffset(layoutPtr, ppda->startSector);\n\tRF_SectorCount_t s0len = ppda->numSector, len;\n\tRF_SectorNum_t suoffset;\n\tunsigned coeff;\n\tchar   *pbuf = ppda->bufPtr;\n\tchar   *qbuf = qpda->bufPtr;\n\tchar   *buf;\n\tint     delta;\n\n\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\tlen = pda->numSector;\n\t/* see if pda intersects a recovery pda */\n\tif ((suoffset < s0off + s0len) && (suoffset + len > s0off)) {\n\t\tbuf = pda->bufPtr;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), pda->raidAddress);\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\n\t\tif (suoffset < s0off) {\n\t\t\tdelta = s0off - suoffset;\n\t\t\tbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tsuoffset = s0off;\n\t\t\tlen -= delta;\n\t\t}\n\t\tif (suoffset > s0off) {\n\t\t\tdelta = suoffset - s0off;\n\t\t\tpbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tqbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t}\n\t\tif ((suoffset + len) > (s0len + s0off))\n\t\t\tlen = s0len + s0off - suoffset;\n\n\t\t/* src, dest, len */\n\t\trf_bxor(buf, pbuf, rf_RaidAddressToByte(raidPtr, len), bp);\n\n\t\t/* dest, src, len, coeff */\n\t\trf_IncQ((unsigned long *) qbuf, (unsigned long *) buf, rf_RaidAddressToByte(raidPtr, len), coeff);\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_pqdegdags.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_pqdegdags.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \napplyPDA(raidPtr, pda, ppda, qpda, bp)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tRF_PhysDiskAddr_t *ppda;\n\tRF_PhysDiskAddr_t *qpda;\n\tvoid   *bp;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t s0off = rf_StripeUnitOffset(layoutPtr, ppda->startSector);\n\tRF_SectorCount_t s0len = ppda->numSector, len;\n\tRF_SectorNum_t suoffset;\n\tunsigned coeff;\n\tchar   *pbuf = ppda->bufPtr;\n\tchar   *qbuf = qpda->bufPtr;\n\tchar   *buf;\n\tint     delta;\n\n\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\tlen = pda->numSector;\n\t/* see if pda intersects a recovery pda */\n\tif ((suoffset < s0off + s0len) && (suoffset + len > s0off)) {\n\t\tbuf = pda->bufPtr;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), pda->raidAddress);\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\n\t\tif (suoffset < s0off) {\n\t\t\tdelta = s0off - suoffset;\n\t\t\tbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tsuoffset = s0off;\n\t\t\tlen -= delta;\n\t\t}\n\t\tif (suoffset > s0off) {\n\t\t\tdelta = suoffset - s0off;\n\t\t\tpbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tqbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t}\n\t\tif ((suoffset + len) > (s0len + s0off))\n\t\t\tlen = s0len + s0off - suoffset;\n\n\t\t/* src, dest, len */\n\t\trf_bxor(buf, pbuf, rf_RaidAddressToByte(raidPtr, len), bp);\n\n\t\t/* dest, src, len, coeff */\n\t\trf_IncQ((unsigned long *) qbuf, (unsigned long *) buf, rf_RaidAddressToByte(raidPtr, len), coeff);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda->startSector"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_pqdegdags.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_PQDoubleRecoveryFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tRF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np - 1].p;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 2].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     d, i;\n\tunsigned coeff;\n\tRF_RaidAddr_t sosAddr, suoffset;\n\tRF_SectorCount_t len, secPerSU = layoutPtr->sectorsPerStripeUnit;\n\tint     two = 0;\n\tRF_PhysDiskAddr_t *ppda, *ppda2, *qpda, *qpda2, *pda, npda;\n\tchar   *buf;\n\tint     numDataCol = layoutPtr->numDataCol;\n\tRF_Etimer_t timer;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\n\tRF_ETIMER_START(timer);\n\n\tif (asmap->failedPDAs[1] &&\n\t    (asmap->failedPDAs[1]->numSector + asmap->failedPDAs[0]->numSector < secPerSU)) {\n\t\tRF_ASSERT(0);\n\t\tppda = node->params[np - 6].p;\n\t\tppda2 = node->params[np - 5].p;\n\t\tqpda = node->params[np - 4].p;\n\t\tqpda2 = node->params[np - 3].p;\n\t\td = (np - 6);\n\t\ttwo = 1;\n\t} else {\n\t\tppda = node->params[np - 4].p;\n\t\tqpda = node->params[np - 3].p;\n\t\td = (np - 4);\n\t}\n\n\tfor (i = 0; i < d; i++) {\n\t\tpda = node->params[i].p;\n\t\tbuf = pda->bufPtr;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tlen = pda->numSector;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(layoutPtr, pda->raidAddress);\n\t\t/* compute the data unit offset within the column */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\t/* see if pda intersects a recovery pda */\n\t\tapplyPDA(raidPtr, pda, ppda, qpda, node->dagHdr->bp);\n\t\tif (two)\n\t\t\tapplyPDA(raidPtr, pda, ppda, qpda, node->dagHdr->bp);\n\t}\n\n\t/* ok, we got the parity back to the point where we can recover. We\n\t * now need to determine the coeff of the columns that need to be\n\t * recovered. We can also only need to recover a single stripe unit. */\n\n\tif (asmap->failedPDAs[1] == NULL) {\t/* only a single stripe unit\n\t\t\t\t\t\t * to recover. */\n\t\tpda = asmap->failedPDAs[0];\n\t\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\t\t/* need to determine the column of the other failed disk */\n\t\tcoeff = rf_RaidAddressToStripeUnitID(layoutPtr, pda->raidAddress);\n\t\t/* compute the data unit offset within the column */\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\t\tfor (i = 0; i < numDataCol; i++) {\n\t\t\tnpda.raidAddress = sosAddr + (i * secPerSU);\n\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);\n\t\t\t/* skip over dead disks */\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))\n\t\t\t\tif (i != coeff)\n\t\t\t\t\tbreak;\n\t\t}\n\t\tRF_ASSERT(i < numDataCol);\n\t\tRF_ASSERT(two == 0);\n\t\t/* recover the data. Since we need only want to recover one\n\t\t * column, we overwrite the parity with the other one. */\n\t\tif (coeff < i)\t/* recovering 'a' */\n\t\t\trf_PQ_recover((unsigned long *) ppda->bufPtr, (unsigned long *) qpda->bufPtr, (unsigned long *) pda->bufPtr, (unsigned long *) ppda->bufPtr, rf_RaidAddressToByte(raidPtr, pda->numSector), coeff, i);\n\t\telse\t\t/* recovering 'b' */\n\t\t\trf_PQ_recover((unsigned long *) ppda->bufPtr, (unsigned long *) qpda->bufPtr, (unsigned long *) ppda->bufPtr, (unsigned long *) pda->bufPtr, rf_RaidAddressToByte(raidPtr, pda->numSector), i, coeff);\n\t} else\n\t\tRF_PANIC();\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\tif (tracerec)\n\t\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\n\treturn (0);\n}"
  },
  {
    "function_name": "applyPDA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pqdegdags.c",
    "lines": "120-166",
    "snippet": "static void \napplyPDA(raidPtr, pda, ppda, qpda, bp)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tRF_PhysDiskAddr_t *ppda;\n\tRF_PhysDiskAddr_t *qpda;\n\tvoid   *bp;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t s0off = rf_StripeUnitOffset(layoutPtr, ppda->startSector);\n\tRF_SectorCount_t s0len = ppda->numSector, len;\n\tRF_SectorNum_t suoffset;\n\tunsigned coeff;\n\tchar   *pbuf = ppda->bufPtr;\n\tchar   *qbuf = qpda->bufPtr;\n\tchar   *buf;\n\tint     delta;\n\n\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\tlen = pda->numSector;\n\t/* see if pda intersects a recovery pda */\n\tif ((suoffset < s0off + s0len) && (suoffset + len > s0off)) {\n\t\tbuf = pda->bufPtr;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), pda->raidAddress);\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\n\t\tif (suoffset < s0off) {\n\t\t\tdelta = s0off - suoffset;\n\t\t\tbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tsuoffset = s0off;\n\t\t\tlen -= delta;\n\t\t}\n\t\tif (suoffset > s0off) {\n\t\t\tdelta = suoffset - s0off;\n\t\t\tpbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tqbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t}\n\t\tif ((suoffset + len) > (s0len + s0off))\n\t\t\tlen = s0len + s0off - suoffset;\n\n\t\t/* src, dest, len */\n\t\trf_bxor(buf, pbuf, rf_RaidAddressToByte(raidPtr, len), bp);\n\n\t\t/* dest, src, len, coeff */\n\t\trf_IncQ((unsigned long *) qbuf, (unsigned long *) buf, rf_RaidAddressToByte(raidPtr, len), coeff);\n\t}\n}",
    "includes": [
      "#include \"rf_pq.h\"",
      "#include \"rf_pqdegdags.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_IncQ",
          "args": [
            "(unsigned long *) qbuf",
            "(unsigned long *) buf",
            "rf_RaidAddressToByte(raidPtr, len)",
            "coeff"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "rf_IncQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_pq.c",
          "lines": "666-725",
          "snippet": "void \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}",
          "includes": [
            "#include \"rf_pq.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_pqdeg.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_pqdeg.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_IncQ(dest, buf, length, coeff)\n\tunsigned long *dest;\n\tunsigned long *buf;\n\tunsigned length;\n\tunsigned coeff;\n{\n\tunsigned long a, d, new;\n\tunsigned long a1, a2;\n\tunsigned int *q = &(rf_qfor[28 - coeff][0]);\n\tunsigned r = rf_rn[coeff + 1];\n\n#define EXTRACT(a,i) ((a >> (5L*i)) & 0x1f)\n#define INSERT(a,i) (a << (5L*i))\n\n\tlength /= 8;\n\t/* 13 5 bit quants in a 64 bit word */\n\twhile (length) {\n\t\ta = *buf++;\n\t\td = *dest;\n\t\ta1 = EXTRACT(a, 0) ^ r;\n\t\ta2 = EXTRACT(a, 1) ^ r;\n\t\tnew = INSERT(a2, 1) | a1;\n\t\ta1 = EXTRACT(a, 2) ^ r;\n\t\ta2 = EXTRACT(a, 3) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 2) | INSERT(a2, 3);\n\t\ta1 = EXTRACT(a, 4) ^ r;\n\t\ta2 = EXTRACT(a, 5) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 4) | INSERT(a2, 5);\n\t\ta1 = EXTRACT(a, 5) ^ r;\n\t\ta2 = EXTRACT(a, 6) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 5) | INSERT(a2, 6);\n#if RF_LONGSHIFT > 2\n\t\ta1 = EXTRACT(a, 7) ^ r;\n\t\ta2 = EXTRACT(a, 8) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 7) | INSERT(a2, 8);\n\t\ta1 = EXTRACT(a, 9) ^ r;\n\t\ta2 = EXTRACT(a, 10) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 9) | INSERT(a2, 10);\n\t\ta1 = EXTRACT(a, 11) ^ r;\n\t\ta2 = EXTRACT(a, 12) ^ r;\n\t\ta1 = q[a1];\n\t\ta2 = q[a2];\n\t\tnew = new | INSERT(a1, 11) | INSERT(a2, 12);\n#endif\t\t\t\t/* RF_LONGSHIFT > 2 */\n\t\td ^= new;\n\t\t*dest++ = d;\n\t\tlength--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "len"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_bxor",
          "args": [
            "buf",
            "pbuf",
            "rf_RaidAddressToByte(raidPtr, len)",
            "bp"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "rf_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "880-893",
          "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "len"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "delta"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "delta"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "delta"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "&(raidPtr->Layout)",
            "pda->raidAddress"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda->startSector"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "ppda->startSector"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_pq.h\"\n#include \"rf_pqdegdags.h\"\n#include \"rf_general.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \napplyPDA(raidPtr, pda, ppda, qpda, bp)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tRF_PhysDiskAddr_t *ppda;\n\tRF_PhysDiskAddr_t *qpda;\n\tvoid   *bp;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t s0off = rf_StripeUnitOffset(layoutPtr, ppda->startSector);\n\tRF_SectorCount_t s0len = ppda->numSector, len;\n\tRF_SectorNum_t suoffset;\n\tunsigned coeff;\n\tchar   *pbuf = ppda->bufPtr;\n\tchar   *qbuf = qpda->bufPtr;\n\tchar   *buf;\n\tint     delta;\n\n\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\tlen = pda->numSector;\n\t/* see if pda intersects a recovery pda */\n\tif ((suoffset < s0off + s0len) && (suoffset + len > s0off)) {\n\t\tbuf = pda->bufPtr;\n\t\tcoeff = rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), pda->raidAddress);\n\t\tcoeff = (coeff % raidPtr->Layout.numDataCol);\n\n\t\tif (suoffset < s0off) {\n\t\t\tdelta = s0off - suoffset;\n\t\t\tbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tsuoffset = s0off;\n\t\t\tlen -= delta;\n\t\t}\n\t\tif (suoffset > s0off) {\n\t\t\tdelta = suoffset - s0off;\n\t\t\tpbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t\tqbuf += rf_RaidAddressToStripeUnitID(&(raidPtr->Layout), delta);\n\t\t}\n\t\tif ((suoffset + len) > (s0len + s0off))\n\t\t\tlen = s0len + s0off - suoffset;\n\n\t\t/* src, dest, len */\n\t\trf_bxor(buf, pbuf, rf_RaidAddressToByte(raidPtr, len), bp);\n\n\t\t/* dest, src, len, coeff */\n\t\trf_IncQ((unsigned long *) qbuf, (unsigned long *) buf, rf_RaidAddressToByte(raidPtr, len), coeff);\n\t}\n}"
  }
]