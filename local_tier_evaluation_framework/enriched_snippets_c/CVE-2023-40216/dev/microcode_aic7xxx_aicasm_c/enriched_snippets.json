[
  {
    "function_name": "process_scope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "657-721",
    "snippet": "void\nprocess_scope(scope_t *scope)\n{\n\t/*\n\t * We are \"leaving\" this scope.  We should now have\n\t * enough information to process the lists of scopes\n\t * we encapsulate.\n\t */\n\tscope_t *cur_scope;\n\tu_int skip_patch_count;\n\tu_int skip_instr_count;\n\n\tcur_scope = TAILQ_LAST(&scope->inner_scope, scope_tailq);\n\tskip_patch_count = 0;\n\tskip_instr_count = 0;\n\twhile (cur_scope != NULL) {\n\t\tu_int patch0_patch_skip;\n\n\t\tpatch0_patch_skip = 0;\n\t\tswitch (cur_scope->type) {\n\t\tcase SCOPE_IF:\n\t\tcase SCOPE_ELSE_IF:\n\t\t\tif (skip_instr_count != 0) {\n\t\t\t\t/* Create a tail patch */\n\t\t\t\tpatch0_patch_skip++;\n\t\t\t\tcur_scope->patches[1].skip_patch =\n\t\t\t\t    skip_patch_count + 1;\n\t\t\t\tcur_scope->patches[1].skip_instr =\n\t\t\t\t    skip_instr_count;\n\t\t\t}\n\n\t\t\t/* Count Head patch */\n\t\t\tpatch0_patch_skip++;\n\n\t\t\t/* Count any patches contained in our inner scope */\n\t\t\tpatch0_patch_skip += cur_scope->inner_scope_patches;\n\n\t\t\tcur_scope->patches[0].skip_patch = patch0_patch_skip;\n\t\t\tcur_scope->patches[0].skip_instr =\n\t\t\t    cur_scope->end_addr - cur_scope->begin_addr;\n\n\t\t\tskip_instr_count += cur_scope->patches[0].skip_instr;\n\n\t\t\tskip_patch_count += patch0_patch_skip;\n\t\t\tif (cur_scope->type == SCOPE_IF) {\n\t\t\t\tscope->inner_scope_patches += skip_patch_count;\n\t\t\t\tskip_patch_count = 0;\n\t\t\t        skip_instr_count = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCOPE_ELSE:\n\t\t\t/* Count any patches contained in our innter scope */\n\t\t\tskip_patch_count += cur_scope->inner_scope_patches;\n\n\t\t\tskip_instr_count += cur_scope->end_addr\n\t\t\t\t\t  - cur_scope->begin_addr;\n\t\t\tbreak;\n\t\tcase SCOPE_ROOT:\n\t\t\tstop(\"Unexpected scope type encountered\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\tcur_scope = TAILQ_PREV(cur_scope, scope_tailq, scope_links);\n\t}\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dump_scope(scope_t *scope);",
      "static void emit_patch(scope_t *scope, int patch);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_PREV",
          "args": [
            "cur_scope",
            "scope_tailq",
            "scope_links"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "\"Unexpected scope type encountered\"",
            "EX_SOFTWARE"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "576-621",
          "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "char *appname;",
            "FILE *ofile;",
            "char *ofilename;",
            "char *regfilename;",
            "FILE *regfile;",
            "char *listfilename;",
            "FILE *listfile;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_LAST",
          "args": [
            "&scope->inner_scope",
            "scope_tailq"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void dump_scope(scope_t *scope);\nstatic void emit_patch(scope_t *scope, int patch);\n\nvoid\nprocess_scope(scope_t *scope)\n{\n\t/*\n\t * We are \"leaving\" this scope.  We should now have\n\t * enough information to process the lists of scopes\n\t * we encapsulate.\n\t */\n\tscope_t *cur_scope;\n\tu_int skip_patch_count;\n\tu_int skip_instr_count;\n\n\tcur_scope = TAILQ_LAST(&scope->inner_scope, scope_tailq);\n\tskip_patch_count = 0;\n\tskip_instr_count = 0;\n\twhile (cur_scope != NULL) {\n\t\tu_int patch0_patch_skip;\n\n\t\tpatch0_patch_skip = 0;\n\t\tswitch (cur_scope->type) {\n\t\tcase SCOPE_IF:\n\t\tcase SCOPE_ELSE_IF:\n\t\t\tif (skip_instr_count != 0) {\n\t\t\t\t/* Create a tail patch */\n\t\t\t\tpatch0_patch_skip++;\n\t\t\t\tcur_scope->patches[1].skip_patch =\n\t\t\t\t    skip_patch_count + 1;\n\t\t\t\tcur_scope->patches[1].skip_instr =\n\t\t\t\t    skip_instr_count;\n\t\t\t}\n\n\t\t\t/* Count Head patch */\n\t\t\tpatch0_patch_skip++;\n\n\t\t\t/* Count any patches contained in our inner scope */\n\t\t\tpatch0_patch_skip += cur_scope->inner_scope_patches;\n\n\t\t\tcur_scope->patches[0].skip_patch = patch0_patch_skip;\n\t\t\tcur_scope->patches[0].skip_instr =\n\t\t\t    cur_scope->end_addr - cur_scope->begin_addr;\n\n\t\t\tskip_instr_count += cur_scope->patches[0].skip_instr;\n\n\t\t\tskip_patch_count += patch0_patch_skip;\n\t\t\tif (cur_scope->type == SCOPE_IF) {\n\t\t\t\tscope->inner_scope_patches += skip_patch_count;\n\t\t\t\tskip_patch_count = 0;\n\t\t\t        skip_instr_count = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCOPE_ELSE:\n\t\t\t/* Count any patches contained in our innter scope */\n\t\t\tskip_patch_count += cur_scope->inner_scope_patches;\n\n\t\t\tskip_instr_count += cur_scope->end_addr\n\t\t\t\t\t  - cur_scope->begin_addr;\n\t\t\tbreak;\n\t\tcase SCOPE_ROOT:\n\t\t\tstop(\"Unexpected scope type encountered\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\tcur_scope = TAILQ_PREV(cur_scope, scope_tailq, scope_links);\n\t}\n}"
  },
  {
    "function_name": "scope_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "637-655",
    "snippet": "scope_t *\nscope_alloc()\n{\n\tscope_t *new_scope;\n\n\tnew_scope = (scope_t *)malloc(sizeof(scope_t));\n\tif (new_scope == NULL)\n\t\tstop(\"Unable to malloc scope object\", EX_SOFTWARE);\n\tmemset(new_scope, 0, sizeof(*new_scope));\n\tTAILQ_INIT(&new_scope->inner_scope);\n\t\n\tif (SLIST_FIRST(&scope_stack) != NULL) {\n\t\tTAILQ_INSERT_TAIL(&SLIST_FIRST(&scope_stack)->inner_scope,\n\t\t\t\t  new_scope, scope_links);\n\t}\n\t/* This patch is now the current scope */\n\tSLIST_INSERT_HEAD(&scope_stack, new_scope, scope_stack_links);\n\treturn new_scope;\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dump_scope(scope_t *scope);",
      "static void emit_patch(scope_t *scope, int patch);",
      "struct scope_list scope_stack;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SLIST_INSERT_HEAD",
          "args": [
            "&scope_stack",
            "new_scope",
            "scope_stack_links"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&SLIST_FIRST(&scope_stack)->inner_scope",
            "new_scope",
            "scope_links"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_FIRST",
          "args": [
            "&scope_stack"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_FIRST",
          "args": [
            "&scope_stack"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&new_scope->inner_scope"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_scope",
            "0",
            "sizeof(*new_scope)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "\"Unable to malloc scope object\"",
            "EX_SOFTWARE"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "576-621",
          "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "char *appname;",
            "FILE *ofile;",
            "char *ofilename;",
            "char *regfilename;",
            "FILE *regfile;",
            "char *listfilename;",
            "FILE *listfile;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(scope_t)"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void dump_scope(scope_t *scope);\nstatic void emit_patch(scope_t *scope, int patch);\nstruct scope_list scope_stack;\n\nscope_t *\nscope_alloc()\n{\n\tscope_t *new_scope;\n\n\tnew_scope = (scope_t *)malloc(sizeof(scope_t));\n\tif (new_scope == NULL)\n\t\tstop(\"Unable to malloc scope object\", EX_SOFTWARE);\n\tmemset(new_scope, 0, sizeof(*new_scope));\n\tTAILQ_INIT(&new_scope->inner_scope);\n\t\n\tif (SLIST_FIRST(&scope_stack) != NULL) {\n\t\tTAILQ_INSERT_TAIL(&SLIST_FIRST(&scope_stack)->inner_scope,\n\t\t\t\t  new_scope, scope_links);\n\t}\n\t/* This patch is now the current scope */\n\tSLIST_INSERT_HEAD(&scope_stack, new_scope, scope_stack_links);\n\treturn new_scope;\n}"
  },
  {
    "function_name": "seq_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "623-635",
    "snippet": "struct instruction *\nseq_alloc()\n{\n\tstruct instruction *new_instr;\n\n\tnew_instr = (struct instruction *)malloc(sizeof(struct instruction));\n\tif (new_instr == NULL)\n\t\tstop(\"Unable to malloc instruction object\", EX_SOFTWARE);\n\tmemset(new_instr, 0, sizeof(*new_instr));\n\tTAILQ_INSERT_TAIL(&seq_program, new_instr, links);\n\tnew_instr->srcline = yylineno;\n\treturn new_instr;\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static TAILQ_HEAD(,instruction) seq_program;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&seq_program",
            "new_instr",
            "links"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_instr",
            "0",
            "sizeof(*new_instr)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "\"Unable to malloc instruction object\"",
            "EX_SOFTWARE"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "576-621",
          "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "char *appname;",
            "FILE *ofile;",
            "char *ofilename;",
            "char *regfilename;",
            "FILE *regfile;",
            "char *listfilename;",
            "FILE *listfile;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct instruction)"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic TAILQ_HEAD(,instruction) seq_program;\n\nstruct instruction *\nseq_alloc()\n{\n\tstruct instruction *new_instr;\n\n\tnew_instr = (struct instruction *)malloc(sizeof(struct instruction));\n\tif (new_instr == NULL)\n\t\tstop(\"Unable to malloc instruction object\", EX_SOFTWARE);\n\tmemset(new_instr, 0, sizeof(*new_instr));\n\tTAILQ_INSERT_TAIL(&seq_program, new_instr, links);\n\tnew_instr->srcline = yylineno;\n\treturn new_instr;\n}"
  },
  {
    "function_name": "stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "576-621",
    "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void output_code(FILE *ofile);",
      "char *appname;",
      "FILE *ofile;",
      "char *ofilename;",
      "char *regfilename;",
      "FILE *regfile;",
      "char *listfilename;",
      "FILE *listfile;",
      "symlist_t patch_functions;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "err_code"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symtable_close",
          "args": [],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "symtable_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
          "lines": "124-139",
          "snippet": "void\nsymtable_close()\n{\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\t\tDBT\t data;\n\n\t\twhile (symtable->seq(symtable, &key, &data, R_FIRST) == 0) {\n\t\t\tsymbol_t *stored_ptr;\n\n\t\t\tmemcpy(&stored_ptr, data.data, sizeof(stored_ptr));\n\t\t\tsymbol_delete(stored_ptr);\n\t\t}\n\t\tsymtable->close(symtable);\n\t}\n}",
          "includes": [
            "#include \"aicasm.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <db.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DB *symtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nstatic DB *symtable;\n\nvoid\nsymtable_close()\n{\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\t\tDBT\t data;\n\n\t\twhile (symtable->seq(symtable, &key, &data, R_FIRST) == 0) {\n\t\t\tsymbol_t *stored_ptr;\n\n\t\t\tmemcpy(&stored_ptr, data.data, sizeof(stored_ptr));\n\t\t\tsymbol_delete(stored_ptr);\n\t\t}\n\t\tsymtable->close(symtable);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "symlist_free",
          "args": [
            "&patch_functions"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "symlist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
          "lines": "270-283",
          "snippet": "void\nsymlist_free(symlist)\n\tsymlist_t *symlist;\n{\n\tsymbol_node_t *node1, *node2;\n\n\tnode1 = symlist->slh_first;\n\twhile (node1 != NULL) {\n\t\tnode2 = node1->links.sle_next;\n\t\tfree(node1);\n\t\tnode1 = node2;\n\t}\n\tSLIST_INIT(symlist);\n}",
          "includes": [
            "#include \"aicasm.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <db.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "symbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nsymbol_node_t *\nsymlist_search(symlist, symname)\n\tsymlist_t *symlist;\n\nvoid\nsymlist_free(symlist)\n\tsymlist_t *symlist;\n{\n\tsymbol_node_t *node1, *node2;\n\n\tnode1 = symlist->slh_first;\n\twhile (node1 != NULL) {\n\t\tnode2 = node1->links.sle_next;\n\t\tfree(node1);\n\t\tnode1 = node2;\n\t}\n\tSLIST_INIT(symlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "listfilename"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Removing %s due to error\\n\"",
            "appname",
            "listfilename"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "listfile"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "regfilename"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Removing %s due to error\\n\"",
            "appname",
            "regfilename"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "regfile"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "ofilename"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Removing %s due to error\\n\"",
            "appname",
            "ofilename"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "ofile"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "string"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Stopped at file %s, line %d - \"",
            "yyfilename",
            "yylineno"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: \"",
            "appname"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
  },
  {
    "function_name": "check_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "537-570",
    "snippet": "static int\ncheck_patch(patch_t **start_patch, int start_instr,\n\t    int *skip_addr, int *func_vals)\n{\n\tpatch_t *cur_patch;\n\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch != NULL && start_instr == cur_patch->begin) {\n\t\tif (func_vals[cur_patch->patch_func] == 0) {\n\t\t\tint skip;\n\n\t\t\t/* Start rejecting code */\n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tfor (skip = cur_patch->skip_patch;\n\t\t\t     skip > 0 && cur_patch != NULL;\n\t\t\t     skip--)\n\t\t\t\tcur_patch = TAILQ_NEXT(cur_patch, links);\n\t\t} else {\n\t\t\t/* Accepted this patch.  Advance to the next\n\t\t\t * one and wait for our intruction pointer to\n\t\t\t * hit this point.\n\t\t\t */\n\t\t\tcur_patch = TAILQ_NEXT(cur_patch, links);\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t/* Still skipping */\n\t\treturn (0);\n\n\treturn (1);\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void emit_patch(scope_t *scope, int patch);",
      "static int check_patch(patch_t **start_patch, int start_instr,\n\t\t       int *skip_addr, int *func_vals);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "cur_patch",
            "links"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "cur_patch",
            "links"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void emit_patch(scope_t *scope, int patch);\nstatic int check_patch(patch_t **start_patch, int start_instr,\n\t\t       int *skip_addr, int *func_vals);\n\nstatic int\ncheck_patch(patch_t **start_patch, int start_instr,\n\t    int *skip_addr, int *func_vals)\n{\n\tpatch_t *cur_patch;\n\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch != NULL && start_instr == cur_patch->begin) {\n\t\tif (func_vals[cur_patch->patch_func] == 0) {\n\t\t\tint skip;\n\n\t\t\t/* Start rejecting code */\n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tfor (skip = cur_patch->skip_patch;\n\t\t\t     skip > 0 && cur_patch != NULL;\n\t\t\t     skip--)\n\t\t\t\tcur_patch = TAILQ_NEXT(cur_patch, links);\n\t\t} else {\n\t\t\t/* Accepted this patch.  Advance to the next\n\t\t\t * one and wait for our intruction pointer to\n\t\t\t * hit this point.\n\t\t\t */\n\t\t\tcur_patch = TAILQ_NEXT(cur_patch, links);\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t/* Still skipping */\n\t\treturn (0);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "output_listing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "425-535",
    "snippet": "void\noutput_listing(FILE *listfile, char *ifilename)\n{\n\tchar buf[1024];\n\tFILE *ifile;\n\tstruct instruction *cur_instr;\n\tpatch_t *cur_patch;\n\tsymbol_node_t *cur_func;\n\tint *func_values;\n\tint instrcount;\n\tint instrptr;\n\tint line;\n\tint func_count;\n\tint skip_addr;\n\n\tinstrcount = 0;\n\tinstrptr = 0;\n\tline = 1;\n\tskip_addr = 0;\n\tif ((ifile = fopen(ifilename, \"r\")) == NULL) {\n\t\tperror(ifilename);\n\t\tstop(NULL, EX_DATAERR);\n\t}\n\n\t/*\n\t * Determine which options to apply to this listing.\n\t */\n\tfor (func_count = 0, cur_func = SLIST_FIRST(&patch_functions);\n\t    cur_func != NULL;\n\t    cur_func = SLIST_NEXT(cur_func, links))\n\t\tfunc_count++;\n\n\tif (func_count != 0) {\n\t\tfunc_values = (int *)malloc(func_count * sizeof(int));\n\n\t\tif (func_values == NULL)\n\t\t\tstop(\"Could not malloc\", EX_OSERR);\n\t\t\n\t\tfunc_values[0] = 0; /* FALSE func */\n\t\tfunc_count--;\n\n\t\t/*\n\t\t * Ask the user to fill in the return values for\n\t\t * the rest of the functions.\n\t\t */\n\t\t\n\t\t\n\t\tfor (cur_func = SLIST_FIRST(&patch_functions);\n\t\t     cur_func != NULL && SLIST_NEXT(cur_func, links) != NULL;\n\t\t     cur_func = SLIST_NEXT(cur_func, links), func_count--) {\n\t\t\tint input;\n\t\t\t\n\t\t\tfprintf(stdout, \"\\n(%s)\\n\", cur_func->symbol->name);\n\t\t\tfprintf(stdout,\n\t\t\t\t\"Enter the return value for \"\n\t\t\t\t\"this expression[T/F]:\");\n\n\t\t\twhile (1) {\n\n\t\t\t\tinput = getchar();\n\t\t\t\tinput = toupper(input);\n\n\t\t\t\tif (input == 'T') {\n\t\t\t\t\tfunc_values[func_count] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (input == 'F') {\n\t\t\t\t\tfunc_values[func_count] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isatty(fileno(stdin)) == 0)\n\t\t\t\tputchar(input);\n\t\t}\n\t\tfprintf(stdout, \"\\nThanks!\\n\");\n\t}\n\n\t/* Now output the listing */\n\tcur_patch = TAILQ_FIRST(&patches);\n\tfor(cur_instr = TAILQ_FIRST(&seq_program);\n\t    cur_instr != NULL;\n\t    cur_instr = TAILQ_NEXT(cur_instr, links), instrcount++) {\n\n\t\tif (check_patch(&cur_patch, instrcount,\n\t\t\t\t&skip_addr, func_values) == 0) {\n\t\t\t/* Don't count this instruction as it is in a patch\n\t\t\t * that was removed.\n\t\t\t */\n                        continue;\n\t\t}\n\n\t\twhile (line < cur_instr->srcline) {\n\t\t\tfgets(buf, sizeof(buf), ifile);\n\t\t\t\tfprintf(listfile, \"\\t\\t%s\", buf);\n\t\t\t\tline++;\n\t\t}\n\t\tfprintf(listfile, \"%03x %02x%02x%02x%02x\", instrptr,\n\t\t\tcur_instr->format.bytes[0],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[3]);\n\t\tfgets(buf, sizeof(buf), ifile);\n\t\tfprintf(listfile, \"\\t%s\", buf);\n\t\tline++;\n\t\tinstrptr++;\n\t}\n\t/* Dump the remainder of the file */\n\twhile(fgets(buf, sizeof(buf), ifile) != NULL)\n\t\tfprintf(listfile, \"\\t\\t%s\", buf);\n\n\tfclose(ifile);\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void output_listing(FILE *listfile, char *ifilename);",
      "static void emit_patch(scope_t *scope, int patch);",
      "FILE *listfile;",
      "static TAILQ_HEAD(,instruction) seq_program;",
      "symlist_t patch_functions;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "ifile"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "listfile",
            "\"\\t\\t%s\"",
            "buf"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "ifile"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "listfile",
            "\"\\t%s\"",
            "buf"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "ifile"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "listfile",
            "\"%03x %02x%02x%02x%02x\"",
            "instrptr",
            "cur_instr->format.bytes[0]",
            "cur_instr->format.bytes[1]",
            "cur_instr->format.bytes[2]",
            "cur_instr->format.bytes[3]"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "listfile",
            "\"\\t\\t%s\"",
            "buf"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "ifile"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_patch",
          "args": [
            "&cur_patch",
            "instrcount",
            "&skip_addr",
            "func_values"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "check_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "537-570",
          "snippet": "static int\ncheck_patch(patch_t **start_patch, int start_instr,\n\t    int *skip_addr, int *func_vals)\n{\n\tpatch_t *cur_patch;\n\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch != NULL && start_instr == cur_patch->begin) {\n\t\tif (func_vals[cur_patch->patch_func] == 0) {\n\t\t\tint skip;\n\n\t\t\t/* Start rejecting code */\n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tfor (skip = cur_patch->skip_patch;\n\t\t\t     skip > 0 && cur_patch != NULL;\n\t\t\t     skip--)\n\t\t\t\tcur_patch = TAILQ_NEXT(cur_patch, links);\n\t\t} else {\n\t\t\t/* Accepted this patch.  Advance to the next\n\t\t\t * one and wait for our intruction pointer to\n\t\t\t * hit this point.\n\t\t\t */\n\t\t\tcur_patch = TAILQ_NEXT(cur_patch, links);\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t/* Still skipping */\n\t\treturn (0);\n\n\treturn (1);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void emit_patch(scope_t *scope, int patch);",
            "static int check_patch(patch_t **start_patch, int start_instr,\n\t\t       int *skip_addr, int *func_vals);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void emit_patch(scope_t *scope, int patch);\nstatic int check_patch(patch_t **start_patch, int start_instr,\n\t\t       int *skip_addr, int *func_vals);\n\nstatic int\ncheck_patch(patch_t **start_patch, int start_instr,\n\t    int *skip_addr, int *func_vals)\n{\n\tpatch_t *cur_patch;\n\n\tcur_patch = *start_patch;\n\n\twhile (cur_patch != NULL && start_instr == cur_patch->begin) {\n\t\tif (func_vals[cur_patch->patch_func] == 0) {\n\t\t\tint skip;\n\n\t\t\t/* Start rejecting code */\n\t\t\t*skip_addr = start_instr + cur_patch->skip_instr;\n\t\t\tfor (skip = cur_patch->skip_patch;\n\t\t\t     skip > 0 && cur_patch != NULL;\n\t\t\t     skip--)\n\t\t\t\tcur_patch = TAILQ_NEXT(cur_patch, links);\n\t\t} else {\n\t\t\t/* Accepted this patch.  Advance to the next\n\t\t\t * one and wait for our intruction pointer to\n\t\t\t * hit this point.\n\t\t\t */\n\t\t\tcur_patch = TAILQ_NEXT(cur_patch, links);\n\t\t}\n\t}\n\n\t*start_patch = cur_patch;\n\tif (start_instr < *skip_addr)\n\t\t/* Still skipping */\n\t\treturn (0);\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "cur_instr",
            "links"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&seq_program"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&patches"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\nThanks!\\n\""
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putchar",
          "args": [
            "input"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "rcons_putchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rops.c",
          "lines": "116-135",
          "snippet": "void\nrcons_putchar(id, row, col, uc, attr)\n\tvoid *id;\n\tint row, col;\n\tu_int uc;\n\tlong attr;\n{\n\tstruct rcons *rc = id;\n\tint x, y, op;\n\tu_char help;\n\n\tx = col * rc->rc_font->width + rc->rc_xorigin;\n\ty = row * rc->rc_font->height + rc->rc_font_ascent + rc->rc_yorigin;\n\n\top = RAS_SRC;\n\tif ((attr != 0) ^ ((rc->rc_bits & RC_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\thelp = uc & 0xff;\n\traster_textn(rc->rc_sp, x, y, op, rc->rc_font, &help, 1);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wscons_raster.h>",
            "#include <dev/rcons/raster.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nrcons_putchar(id, row, col, uc, attr)\n\tvoid *id;\n\tint row, col;\n\tu_int uc;\n\tlong attr;\n{\n\tstruct rcons *rc = id;\n\tint x, y, op;\n\tu_char help;\n\n\tx = col * rc->rc_font->width + rc->rc_xorigin;\n\ty = row * rc->rc_font->height + rc->rc_font_ascent + rc->rc_yorigin;\n\n\top = RAS_SRC;\n\tif ((attr != 0) ^ ((rc->rc_bits & RC_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\thelp = uc & 0xff;\n\traster_textn(rc->rc_sp, x, y, op, rc->rc_font, &help, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "fileno(stdin)"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stdin"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "input"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getchar",
          "args": [],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Enter the return value for \"\n\t\t\t\t\"this expression[T/F]:\""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n(%s)\\n\"",
            "cur_func->symbol->name"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_NEXT",
          "args": [
            "cur_func",
            "links"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_NEXT",
          "args": [
            "cur_func",
            "links"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_FIRST",
          "args": [
            "&patch_functions"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "\"Could not malloc\"",
            "EX_OSERR"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "576-621",
          "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "char *appname;",
            "FILE *ofile;",
            "char *ofilename;",
            "char *regfilename;",
            "FILE *regfile;",
            "char *listfilename;",
            "FILE *listfile;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "func_count * sizeof(int)"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SLIST_NEXT",
          "args": [
            "cur_func",
            "links"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_FIRST",
          "args": [
            "&patch_functions"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "ifilename"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ata_perror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
          "lines": "177-210",
          "snippet": "void\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "ifilename",
            "\"r\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_listing(FILE *listfile, char *ifilename);\nstatic void emit_patch(scope_t *scope, int patch);\nFILE *listfile;\nstatic TAILQ_HEAD(,instruction) seq_program;\nsymlist_t patch_functions;\n\nvoid\noutput_listing(FILE *listfile, char *ifilename)\n{\n\tchar buf[1024];\n\tFILE *ifile;\n\tstruct instruction *cur_instr;\n\tpatch_t *cur_patch;\n\tsymbol_node_t *cur_func;\n\tint *func_values;\n\tint instrcount;\n\tint instrptr;\n\tint line;\n\tint func_count;\n\tint skip_addr;\n\n\tinstrcount = 0;\n\tinstrptr = 0;\n\tline = 1;\n\tskip_addr = 0;\n\tif ((ifile = fopen(ifilename, \"r\")) == NULL) {\n\t\tperror(ifilename);\n\t\tstop(NULL, EX_DATAERR);\n\t}\n\n\t/*\n\t * Determine which options to apply to this listing.\n\t */\n\tfor (func_count = 0, cur_func = SLIST_FIRST(&patch_functions);\n\t    cur_func != NULL;\n\t    cur_func = SLIST_NEXT(cur_func, links))\n\t\tfunc_count++;\n\n\tif (func_count != 0) {\n\t\tfunc_values = (int *)malloc(func_count * sizeof(int));\n\n\t\tif (func_values == NULL)\n\t\t\tstop(\"Could not malloc\", EX_OSERR);\n\t\t\n\t\tfunc_values[0] = 0; /* FALSE func */\n\t\tfunc_count--;\n\n\t\t/*\n\t\t * Ask the user to fill in the return values for\n\t\t * the rest of the functions.\n\t\t */\n\t\t\n\t\t\n\t\tfor (cur_func = SLIST_FIRST(&patch_functions);\n\t\t     cur_func != NULL && SLIST_NEXT(cur_func, links) != NULL;\n\t\t     cur_func = SLIST_NEXT(cur_func, links), func_count--) {\n\t\t\tint input;\n\t\t\t\n\t\t\tfprintf(stdout, \"\\n(%s)\\n\", cur_func->symbol->name);\n\t\t\tfprintf(stdout,\n\t\t\t\t\"Enter the return value for \"\n\t\t\t\t\"this expression[T/F]:\");\n\n\t\t\twhile (1) {\n\n\t\t\t\tinput = getchar();\n\t\t\t\tinput = toupper(input);\n\n\t\t\t\tif (input == 'T') {\n\t\t\t\t\tfunc_values[func_count] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (input == 'F') {\n\t\t\t\t\tfunc_values[func_count] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isatty(fileno(stdin)) == 0)\n\t\t\t\tputchar(input);\n\t\t}\n\t\tfprintf(stdout, \"\\nThanks!\\n\");\n\t}\n\n\t/* Now output the listing */\n\tcur_patch = TAILQ_FIRST(&patches);\n\tfor(cur_instr = TAILQ_FIRST(&seq_program);\n\t    cur_instr != NULL;\n\t    cur_instr = TAILQ_NEXT(cur_instr, links), instrcount++) {\n\n\t\tif (check_patch(&cur_patch, instrcount,\n\t\t\t\t&skip_addr, func_values) == 0) {\n\t\t\t/* Don't count this instruction as it is in a patch\n\t\t\t * that was removed.\n\t\t\t */\n                        continue;\n\t\t}\n\n\t\twhile (line < cur_instr->srcline) {\n\t\t\tfgets(buf, sizeof(buf), ifile);\n\t\t\t\tfprintf(listfile, \"\\t\\t%s\", buf);\n\t\t\t\tline++;\n\t\t}\n\t\tfprintf(listfile, \"%03x %02x%02x%02x%02x\", instrptr,\n\t\t\tcur_instr->format.bytes[0],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[3]);\n\t\tfgets(buf, sizeof(buf), ifile);\n\t\tfprintf(listfile, \"\\t%s\", buf);\n\t\tline++;\n\t\tinstrptr++;\n\t}\n\t/* Dump the remainder of the file */\n\twhile(fgets(buf, sizeof(buf), ifile) != NULL)\n\t\tfprintf(listfile, \"\\t\\t%s\", buf);\n\n\tfclose(ifile);\n}"
  },
  {
    "function_name": "emit_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "394-423",
    "snippet": "void\nemit_patch(scope_t *scope, int patch)\n{\n\tpatch_info_t *pinfo;\n\tpatch_t *new_patch;\n\n\tpinfo = &scope->patches[patch];\n\n\tif (pinfo->skip_instr == 0)\n\t\t/* No-Op patch */\n\t\treturn;\n\n\tnew_patch = (patch_t *)malloc(sizeof(*new_patch));\n\n\tif (new_patch == NULL)\n\t\tstop(\"Could not malloc patch structure\", EX_OSERR);\n\n\tmemset(new_patch, 0, sizeof(*new_patch));\n\n\tif (patch == 0) {\n\t\tnew_patch->patch_func = scope->func_num;\n\t\tnew_patch->begin = scope->begin_addr;\n\t} else {\n\t\tnew_patch->patch_func = 0;\n\t\tnew_patch->begin = scope->end_addr;\n\t}\n\tnew_patch->skip_instr = pinfo->skip_instr;\n\tnew_patch->skip_patch = pinfo->skip_patch;\n\tTAILQ_INSERT_TAIL(&patches, new_patch, links);\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dump_scope(scope_t *scope);",
      "static void emit_patch(scope_t *scope, int patch);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&patches",
            "new_patch",
            "links"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_patch",
            "0",
            "sizeof(*new_patch)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "\"Could not malloc patch structure\"",
            "EX_OSERR"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "576-621",
          "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "char *appname;",
            "FILE *ofile;",
            "char *ofilename;",
            "char *regfilename;",
            "FILE *regfile;",
            "char *listfilename;",
            "FILE *listfile;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*new_patch)"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void dump_scope(scope_t *scope);\nstatic void emit_patch(scope_t *scope, int patch);\n\nvoid\nemit_patch(scope_t *scope, int patch)\n{\n\tpatch_info_t *pinfo;\n\tpatch_t *new_patch;\n\n\tpinfo = &scope->patches[patch];\n\n\tif (pinfo->skip_instr == 0)\n\t\t/* No-Op patch */\n\t\treturn;\n\n\tnew_patch = (patch_t *)malloc(sizeof(*new_patch));\n\n\tif (new_patch == NULL)\n\t\tstop(\"Could not malloc patch structure\", EX_OSERR);\n\n\tmemset(new_patch, 0, sizeof(*new_patch));\n\n\tif (patch == 0) {\n\t\tnew_patch->patch_func = scope->func_num;\n\t\tnew_patch->begin = scope->begin_addr;\n\t} else {\n\t\tnew_patch->patch_func = 0;\n\t\tnew_patch->begin = scope->end_addr;\n\t}\n\tnew_patch->skip_instr = pinfo->skip_instr;\n\tnew_patch->skip_patch = pinfo->skip_patch;\n\tTAILQ_INSERT_TAIL(&patches, new_patch, links);\n}"
  },
  {
    "function_name": "dump_scope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "366-392",
    "snippet": "static void\ndump_scope(scope_t *scope)\n{\n\tscope_t *cur_scope;\n\n\t/*\n\t * Emit the first patch for this scope\n\t */\n\temit_patch(scope, 0);\n\n\t/*\n\t * Dump each scope within this one.\n\t */\n\tcur_scope = TAILQ_FIRST(&scope->inner_scope);\n\n\twhile (cur_scope != NULL) {\n\n\t\tdump_scope(cur_scope);\n\n\t\tcur_scope = TAILQ_NEXT(cur_scope, scope_links);\n\t}\n\n\t/*\n\t * Emit the second, closing, patch for this scope\n\t */\n\temit_patch(scope, 1);\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dump_scope(scope_t *scope);",
      "static void emit_patch(scope_t *scope, int patch);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emit_patch",
          "args": [
            "scope",
            "1"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "emit_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "394-423",
          "snippet": "void\nemit_patch(scope_t *scope, int patch)\n{\n\tpatch_info_t *pinfo;\n\tpatch_t *new_patch;\n\n\tpinfo = &scope->patches[patch];\n\n\tif (pinfo->skip_instr == 0)\n\t\t/* No-Op patch */\n\t\treturn;\n\n\tnew_patch = (patch_t *)malloc(sizeof(*new_patch));\n\n\tif (new_patch == NULL)\n\t\tstop(\"Could not malloc patch structure\", EX_OSERR);\n\n\tmemset(new_patch, 0, sizeof(*new_patch));\n\n\tif (patch == 0) {\n\t\tnew_patch->patch_func = scope->func_num;\n\t\tnew_patch->begin = scope->begin_addr;\n\t} else {\n\t\tnew_patch->patch_func = 0;\n\t\tnew_patch->begin = scope->end_addr;\n\t}\n\tnew_patch->skip_instr = pinfo->skip_instr;\n\tnew_patch->skip_patch = pinfo->skip_patch;\n\tTAILQ_INSERT_TAIL(&patches, new_patch, links);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dump_scope(scope_t *scope);",
            "static void emit_patch(scope_t *scope, int patch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void dump_scope(scope_t *scope);\nstatic void emit_patch(scope_t *scope, int patch);\n\nvoid\nemit_patch(scope_t *scope, int patch)\n{\n\tpatch_info_t *pinfo;\n\tpatch_t *new_patch;\n\n\tpinfo = &scope->patches[patch];\n\n\tif (pinfo->skip_instr == 0)\n\t\t/* No-Op patch */\n\t\treturn;\n\n\tnew_patch = (patch_t *)malloc(sizeof(*new_patch));\n\n\tif (new_patch == NULL)\n\t\tstop(\"Could not malloc patch structure\", EX_OSERR);\n\n\tmemset(new_patch, 0, sizeof(*new_patch));\n\n\tif (patch == 0) {\n\t\tnew_patch->patch_func = scope->func_num;\n\t\tnew_patch->begin = scope->begin_addr;\n\t} else {\n\t\tnew_patch->patch_func = 0;\n\t\tnew_patch->begin = scope->end_addr;\n\t}\n\tnew_patch->skip_instr = pinfo->skip_instr;\n\tnew_patch->skip_patch = pinfo->skip_patch;\n\tTAILQ_INSERT_TAIL(&patches, new_patch, links);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_NEXT",
          "args": [
            "cur_scope",
            "scope_links"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_scope",
          "args": [
            "cur_scope"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "dump_scope",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "366-392",
          "snippet": "static void\ndump_scope(scope_t *scope)\n{\n\tscope_t *cur_scope;\n\n\t/*\n\t * Emit the first patch for this scope\n\t */\n\temit_patch(scope, 0);\n\n\t/*\n\t * Dump each scope within this one.\n\t */\n\tcur_scope = TAILQ_FIRST(&scope->inner_scope);\n\n\twhile (cur_scope != NULL) {\n\n\t\tdump_scope(cur_scope);\n\n\t\tcur_scope = TAILQ_NEXT(cur_scope, scope_links);\n\t}\n\n\t/*\n\t * Emit the second, closing, patch for this scope\n\t */\n\temit_patch(scope, 1);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_FIRST",
          "args": [
            "&scope->inner_scope"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void dump_scope(scope_t *scope);\nstatic void emit_patch(scope_t *scope, int patch);\n\nstatic void\ndump_scope(scope_t *scope)\n{\n\tscope_t *cur_scope;\n\n\t/*\n\t * Emit the first patch for this scope\n\t */\n\temit_patch(scope, 0);\n\n\t/*\n\t * Dump each scope within this one.\n\t */\n\tcur_scope = TAILQ_FIRST(&scope->inner_scope);\n\n\twhile (cur_scope != NULL) {\n\n\t\tdump_scope(cur_scope);\n\n\t\tcur_scope = TAILQ_NEXT(cur_scope, scope_links);\n\t}\n\n\t/*\n\t * Emit the second, closing, patch for this scope\n\t */\n\temit_patch(scope, 1);\n}"
  },
  {
    "function_name": "output_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "296-342",
    "snippet": "static void\noutput_code(ofile)\n\tFILE *ofile;\n{\n\tstruct instruction *cur_instr;\n\tpatch_t *cur_patch;\n\tsymbol_node_t *cur_node;\n\tint instrcount;\n\n\tinstrcount = 0;\n\tfprintf(ofile,\n\"/*\n * DO NOT EDIT - This file is automatically generated.\n */\\n\");\n\n\tfprintf(ofile, \"static u_int8_t seqprog[] = {\\n\");\n\tfor(cur_instr = seq_program.tqh_first;\n\t    cur_instr != NULL;\n\t    cur_instr = cur_instr->links.tqe_next) {\n\n\t\tfprintf(ofile, \"\\t0x%02x, 0x%02x, 0x%02x, 0x%02x,\\n\",\n\t\t\tcur_instr->format.bytes[0],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[3]);\n\t\tinstrcount++;\n\t}\n\tfprintf(ofile, \"};\\n\\n\");\n\n\t/*\n\t *  Output patch information.  Patch functions first.\n\t */\n\tfor(cur_node = SLIST_FIRST(&patch_functions);\n\t    cur_node != NULL;\n\t    cur_node = SLIST_NEXT(cur_node,links)) {\n\t\tfprintf(ofile,\n\"static int ahc_patch%d_func(struct ahc_softc *ahc);\n\nstatic int\nahc_patch%d_func(struct ahc_softc *ahc)\n{\n\treturn (%s);\n}\\n\\n\",\n\t\t\tcur_node->symbol->info.condinfo->func_num,\n\t\t\tcur_node->symbol->info.condinfo->func_num,\n\t\t\tcur_node->symbol->name);\n\t}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void output_code(FILE *ofile);",
      "static void emit_patch(scope_t *scope, int patch);",
      "FILE *ofile;",
      "static TAILQ_HEAD(,instruction) seq_program;",
      "symlist_t patch_functions;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"static int ahc_patch%d_func(struct ahc_softc *ahc);\n\nstatic int\nahc_patch%d_func(struct ahc_softc *ahc)\n{\n\treturn (%s"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_func",
          "args": [
            "structahc_softc *ahc"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_NEXT",
          "args": [
            "cur_node",
            "links"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_FIRST",
          "args": [
            "&patch_functions"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"};\\n\\n\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"\\t0x%02x, 0x%02x, 0x%02x, 0x%02x,\\n\"",
            "cur_instr->format.bytes[0]",
            "cur_instr->format.bytes[1]",
            "cur_instr->format.bytes[2]",
            "cur_instr->format.bytes[3]"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"static u_int8_t seqprog[] = {\\n\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "ofile",
            "\"/*\n * DO NOT EDIT - This file is automatically generated.\n */\\n\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nstatic void emit_patch(scope_t *scope, int patch);\nFILE *ofile;\nstatic TAILQ_HEAD(,instruction) seq_program;\nsymlist_t patch_functions;\n\nstatic void\noutput_code(ofile)\n\tFILE *ofile;\n{\n\tstruct instruction *cur_instr;\n\tpatch_t *cur_patch;\n\tsymbol_node_t *cur_node;\n\tint instrcount;\n\n\tinstrcount = 0;\n\tfprintf(ofile,\n\"/*\n * DO NOT EDIT - This file is automatically generated.\n */\\n\");\n\n\tfprintf(ofile, \"static u_int8_t seqprog[] = {\\n\");\n\tfor(cur_instr = seq_program.tqh_first;\n\t    cur_instr != NULL;\n\t    cur_instr = cur_instr->links.tqe_next) {\n\n\t\tfprintf(ofile, \"\\t0x%02x, 0x%02x, 0x%02x, 0x%02x,\\n\",\n\t\t\tcur_instr->format.bytes[0],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[3]);\n\t\tinstrcount++;\n\t}\n\tfprintf(ofile, \"};\\n\\n\");\n\n\t/*\n\t *  Output patch information.  Patch functions first.\n\t */\n\tfor(cur_node = SLIST_FIRST(&patch_functions);\n\t    cur_node != NULL;\n\t    cur_node = SLIST_NEXT(cur_node,links)) {\n\t\tfprintf(ofile,\n\"static int ahc_patch%d_func(struct ahc_softc *ahc);\n\nstatic int\nahc_patch%d_func(struct ahc_softc *ahc)\n{\n\treturn (%s);\n}\\n\\n\",\n\t\t\tcur_node->symbol->info.condinfo->func_num,\n\t\t\tcur_node->symbol->info.condinfo->func_num,\n\t\t\tcur_node->symbol->name);\n\t}"
  },
  {
    "function_name": "back_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "267-294",
    "snippet": "static void\nback_patch()\n{\n\tstruct instruction *cur_instr;\n\n\tfor(cur_instr = seq_program.tqh_first;\n\t    cur_instr != NULL;\n\t    cur_instr = cur_instr->links.tqe_next) {\n\t\tif (cur_instr->patch_label != NULL) {\n\t\t\tstruct ins_format3 *f3_instr;\n\t\t\tu_int address;\n\n\t\t\tif (cur_instr->patch_label->type != LABEL) {\n\t\t\t\tchar buf[255];\n\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"Undefined label %s\",\n\t\t\t\t\t cur_instr->patch_label->name);\n\t\t\t\tstop(buf, EX_DATAERR);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tf3_instr = &cur_instr->format.format3;\n\t\t\taddress = f3_instr->address;\n\t\t\taddress += cur_instr->patch_label->info.linfo->address;\n\t\t\tf3_instr->address = address;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void back_patch(void);",
      "static TAILQ_HEAD(,instruction) seq_program;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "buf",
            "EX_DATAERR"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "576-621",
          "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "char *appname;",
            "FILE *ofile;",
            "char *ofilename;",
            "char *regfilename;",
            "FILE *regfile;",
            "char *listfilename;",
            "FILE *listfile;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"Undefined label %s\"",
            "cur_instr->patch_label->name"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void back_patch(void);\nstatic TAILQ_HEAD(,instruction) seq_program;\n\nstatic void\nback_patch()\n{\n\tstruct instruction *cur_instr;\n\n\tfor(cur_instr = seq_program.tqh_first;\n\t    cur_instr != NULL;\n\t    cur_instr = cur_instr->links.tqe_next) {\n\t\tif (cur_instr->patch_label != NULL) {\n\t\t\tstruct ins_format3 *f3_instr;\n\t\t\tu_int address;\n\n\t\t\tif (cur_instr->patch_label->type != LABEL) {\n\t\t\t\tchar buf[255];\n\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"Undefined label %s\",\n\t\t\t\t\t cur_instr->patch_label->name);\n\t\t\t\tstop(buf, EX_DATAERR);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tf3_instr = &cur_instr->format.format3;\n\t\t\taddress = f3_instr->address;\n\t\t\taddress += cur_instr->patch_label->info.linfo->address;\n\t\t\tf3_instr->address = address;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "255-265",
    "snippet": "static void\nusage()\n{\n\n\t(void)fprintf(stderr,\n\"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n\t\t\t[-r register_output_file] [-l program_list_file]\n\t\t\tinput_file\\n\",\n\t\t\tappname);\n\texit(EX_USAGE);\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void usage(void);",
      "char *appname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EX_USAGE"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n\t\t\t[-r register_output_file] [-l program_list_file]\n\t\t\tinput_file\\n\",appname"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void usage(void);\nchar *appname;\n\nstatic void\nusage()\n{\n\n\t(void)fprintf(stderr,\n\"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n\t\t\t[-r register_output_file] [-l program_list_file]\n\t\t\tinput_file\\n\",\n\t\t\tappname);\n\texit(EX_USAGE);\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
    "lines": "85-253",
    "snippet": "int\nmain(argc, argv)\n\tint argc;\n\tchar *argv[];\n{\n\textern char *optarg;\n\textern int optind;\n\tint  ch;\n\tint  retval;\n\tchar *inputfilename;\n\tscope_t *sentinal;\n\n\tTAILQ_INIT(&patches);\n\tSLIST_INIT(&search_path);\n\tTAILQ_INIT(&seq_program);\n\tSLIST_INIT(&scope_stack);\n\n\t/* Set Sentinal scope node */\n\tsentinal = scope_alloc();\n\tsentinal->type = SCOPE_ROOT;\n\t\n\tincludes_search_curdir = 1;\n\tappname = *argv;\n\tregfile = NULL;\n\tlistfile = NULL;\n#if DEBUG\n\tyy_flex_debug = 0;\n\tyydebug = 0;\n#endif\n\twhile ((ch = getopt(argc, argv, \"d:l:n:o:r:I:O:\")) != -1) {\n\t\tswitch(ch) {\n\t\tcase 'd':\n#if DEBUG\n\t\t\tif (strcmp(optarg, \"s\") == 0) {\n\t\t\t\tyy_flex_debug = 1;\n\t\t\t} else if (strcmp(optarg, \"p\") == 0) {\n\t\t\t\tyydebug = 1;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: -d Requires either an \"\n\t\t\t\t\t\"'s' or 'p' argument\\n\", appname);\n\t\t\t\tusage();\n\t\t\t}\n#else\n\t\t\tstop(\"-d: Assembler not built with debugging \"\n\t\t\t     \"information\", EX_SOFTWARE);\n#endif\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t/* Create a program listing */\n\t\t\tif ((listfile = fopen(optarg, \"w\")) == NULL) {\n\t\t\t\tperror(optarg);\n\t\t\t\tstop(NULL, EX_CANTCREAT);\n\t\t\t}\n\t\t\tlistfilename = optarg;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t/* Don't complain about the -nostdinc directrive */\n\t\t\tif (strcmp(optarg, \"ostdinc\")) {\n\t\t\t\tfprintf(stderr, \"%s: Unknown option -%c%s\\n\",\n\t\t\t\t\tappname, ch, optarg);\n\t\t\t\tusage();\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif ((ofile = fopen(optarg, \"w\")) == NULL) {\n\t\t\t\tperror(optarg);\n\t\t\t\tstop(NULL, EX_CANTCREAT);\n\t\t\t}\n\t\t\tofilename = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif ((regfile = fopen(optarg, \"w\")) == NULL) {\n\t\t\t\tperror(optarg);\n\t\t\t\tstop(NULL, EX_CANTCREAT);\n\t\t\t}\n\t\t\tregfilename = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t{\n\t\t\tpath_entry_t include_dir;\n\n\t\t\tif (strcmp(optarg, \"-\") == 0) {\n\t\t\t\tif (includes_search_curdir == 0) {\n\t\t\t\t\tfprintf(stderr, \"%s: Warning - '-I-' \"\n\t\t\t\t\t\t\t\"specified multiple \"\n\t\t\t\t\t\t\t\"times\\n\", appname);\n\t\t\t\t}\n\t\t\t\tincludes_search_curdir = 0;\n\t\t\t\tfor (include_dir = search_path.slh_first;\n\t\t\t\t     include_dir != NULL;\n\t\t\t\t     include_dir = include_dir->links.sle_next)\n\t\t\t\t\t/*\n\t\t\t\t\t * All entries before a '-I-' only\n\t\t\t\t\t * apply to includes specified with\n\t\t\t\t\t * quotes instead of \"<>\".\n\t\t\t\t\t */\n\t\t\t\t\tinclude_dir->quoted_includes_only = 1;\n\t\t\t} else {\n\t\t\t\tinclude_dir =\n\t\t\t\t    (path_entry_t)malloc(sizeof(*include_dir));\n\t\t\t\tif (include_dir == NULL) {\n\t\t\t\t\tperror(optarg);\n\t\t\t\t\tstop(NULL, EX_OSERR);\n\t\t\t\t}\n\t\t\t\tinclude_dir->directory = strdup(optarg);\n\t\t\t\tif (include_dir->directory == NULL) {\n\t\t\t\t\tperror(optarg);\n\t\t\t\t\tstop(NULL, EX_OSERR);\n\t\t\t\t}\n\t\t\t\tinclude_dir->quoted_includes_only = 0;\n\t\t\t\tSLIST_INSERT_HEAD(&search_path, include_dir,\n\t\t\t\t\t\t  links);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc != 1) {\n\t\tfprintf(stderr, \"%s: No input file specifiled\\n\", appname);\n\t\tusage();\n\t\t/* NOTREACHED */\n\t}\n\n\tsymtable_open();\n\tinputfilename = *argv;\n\tinclude_file(*argv, SOURCE_FILE);\n\tretval = yyparse();\n\tif (retval == 0) {\n\t\tif (SLIST_FIRST(&scope_stack) == NULL\n\t\t || SLIST_FIRST(&scope_stack)->type != SCOPE_ROOT) {\n\t\t\tstop(\"Unterminated conditional expression\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\t/* Process outmost scope */\n\t\tprocess_scope(SLIST_FIRST(&scope_stack));\n\t\t/*\n\t\t * Decend the tree of scopes and insert/emit\n\t\t * patches as appropriate.  We perform a depth first\n\t\t * tranversal, recursively handling each scope.\n\t\t */\n\t\t/* start at the root scope */\n\t\tdump_scope(SLIST_FIRST(&scope_stack));\n\n\t\t/* Patch up forward jump addresses */\n\t\tback_patch();\n\n\t\tif (ofile != NULL)\n\t\t\toutput_code(ofile);\n\t\tif (regfile != NULL) {\n\t\t\tsymtable_dump(regfile);\n\t\t}\n\t\tif (listfile != NULL)\n\t\t\toutput_listing(listfile, inputfilename);\n\t}\n\n\tstop(NULL, 0);\n\t/* NOTREACHED */\n\treturn (0);\n}",
    "includes": [
      "#include \"sequencer.h\"",
      "#include \"aicasm_symbol.h\"",
      "#include \"aicasm.h\"",
      "#include <unistd.h>",
      "#include <sysexits.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ctype.h>",
      "#include <sys/mman.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void usage(void);",
      "static void back_patch(void);",
      "static void output_code(FILE *ofile);",
      "static void dump_scope(scope_t *scope);",
      "struct path_list search_path;",
      "int includes_search_curdir;",
      "char *appname;",
      "FILE *ofile;",
      "char *ofilename;",
      "char *regfilename;",
      "FILE *regfile;",
      "char *listfilename;",
      "FILE *listfile;",
      "static TAILQ_HEAD(,instruction) seq_program;",
      "struct scope_list scope_stack;",
      "extern int yyparse"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stop",
          "args": [
            "NULL",
            "0"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "576-621",
          "snippet": "void\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "char *appname;",
            "FILE *ofile;",
            "char *ofilename;",
            "char *regfilename;",
            "FILE *regfile;",
            "char *listfilename;",
            "FILE *listfile;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nsymlist_t patch_functions;\n\nvoid\nstop(string, err_code)\n\tconst char *string;\n\tint  err_code;\n{\n\tif (string != NULL) {\n\t\tfprintf(stderr, \"%s: \", appname);\n\t\tif (yyfilename != NULL) {\n\t\t\tfprintf(stderr, \"Stopped at file %s, line %d - \",\n\t\t\t\tyyfilename, yylineno);\n\t\t}\n\t\tfprintf(stderr, \"%s\\n\", string);\n\t}\n\n\tif (ofile != NULL) {\n\t\tfclose(ofile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, ofilename);\n\t\t\tunlink(ofilename);\n\t\t}\n\t}\n\n\tif (regfile != NULL) {\n\t\tfclose(regfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, regfilename);\n\t\t\tunlink(regfilename);\n\t\t}\n\t}\n\n\tif (listfile != NULL) {\n\t\tfclose(listfile);\n\t\tif (err_code != 0) {\n\t\t\tfprintf(stderr, \"%s: Removing %s due to error\\n\",\n\t\t\t\tappname, listfilename);\n\t\t\tunlink(listfilename);\n\t\t}\n\t}\n\n\tsymlist_free(&patch_functions);\n\tsymtable_close();\n\n\texit(err_code);\n}"
        }
      },
      {
        "call_info": {
          "callee": "output_listing",
          "args": [
            "listfile",
            "inputfilename"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "output_listing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "425-535",
          "snippet": "void\noutput_listing(FILE *listfile, char *ifilename)\n{\n\tchar buf[1024];\n\tFILE *ifile;\n\tstruct instruction *cur_instr;\n\tpatch_t *cur_patch;\n\tsymbol_node_t *cur_func;\n\tint *func_values;\n\tint instrcount;\n\tint instrptr;\n\tint line;\n\tint func_count;\n\tint skip_addr;\n\n\tinstrcount = 0;\n\tinstrptr = 0;\n\tline = 1;\n\tskip_addr = 0;\n\tif ((ifile = fopen(ifilename, \"r\")) == NULL) {\n\t\tperror(ifilename);\n\t\tstop(NULL, EX_DATAERR);\n\t}\n\n\t/*\n\t * Determine which options to apply to this listing.\n\t */\n\tfor (func_count = 0, cur_func = SLIST_FIRST(&patch_functions);\n\t    cur_func != NULL;\n\t    cur_func = SLIST_NEXT(cur_func, links))\n\t\tfunc_count++;\n\n\tif (func_count != 0) {\n\t\tfunc_values = (int *)malloc(func_count * sizeof(int));\n\n\t\tif (func_values == NULL)\n\t\t\tstop(\"Could not malloc\", EX_OSERR);\n\t\t\n\t\tfunc_values[0] = 0; /* FALSE func */\n\t\tfunc_count--;\n\n\t\t/*\n\t\t * Ask the user to fill in the return values for\n\t\t * the rest of the functions.\n\t\t */\n\t\t\n\t\t\n\t\tfor (cur_func = SLIST_FIRST(&patch_functions);\n\t\t     cur_func != NULL && SLIST_NEXT(cur_func, links) != NULL;\n\t\t     cur_func = SLIST_NEXT(cur_func, links), func_count--) {\n\t\t\tint input;\n\t\t\t\n\t\t\tfprintf(stdout, \"\\n(%s)\\n\", cur_func->symbol->name);\n\t\t\tfprintf(stdout,\n\t\t\t\t\"Enter the return value for \"\n\t\t\t\t\"this expression[T/F]:\");\n\n\t\t\twhile (1) {\n\n\t\t\t\tinput = getchar();\n\t\t\t\tinput = toupper(input);\n\n\t\t\t\tif (input == 'T') {\n\t\t\t\t\tfunc_values[func_count] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (input == 'F') {\n\t\t\t\t\tfunc_values[func_count] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isatty(fileno(stdin)) == 0)\n\t\t\t\tputchar(input);\n\t\t}\n\t\tfprintf(stdout, \"\\nThanks!\\n\");\n\t}\n\n\t/* Now output the listing */\n\tcur_patch = TAILQ_FIRST(&patches);\n\tfor(cur_instr = TAILQ_FIRST(&seq_program);\n\t    cur_instr != NULL;\n\t    cur_instr = TAILQ_NEXT(cur_instr, links), instrcount++) {\n\n\t\tif (check_patch(&cur_patch, instrcount,\n\t\t\t\t&skip_addr, func_values) == 0) {\n\t\t\t/* Don't count this instruction as it is in a patch\n\t\t\t * that was removed.\n\t\t\t */\n                        continue;\n\t\t}\n\n\t\twhile (line < cur_instr->srcline) {\n\t\t\tfgets(buf, sizeof(buf), ifile);\n\t\t\t\tfprintf(listfile, \"\\t\\t%s\", buf);\n\t\t\t\tline++;\n\t\t}\n\t\tfprintf(listfile, \"%03x %02x%02x%02x%02x\", instrptr,\n\t\t\tcur_instr->format.bytes[0],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[3]);\n\t\tfgets(buf, sizeof(buf), ifile);\n\t\tfprintf(listfile, \"\\t%s\", buf);\n\t\tline++;\n\t\tinstrptr++;\n\t}\n\t/* Dump the remainder of the file */\n\twhile(fgets(buf, sizeof(buf), ifile) != NULL)\n\t\tfprintf(listfile, \"\\t\\t%s\", buf);\n\n\tfclose(ifile);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_listing(FILE *listfile, char *ifilename);",
            "static void emit_patch(scope_t *scope, int patch);",
            "FILE *listfile;",
            "static TAILQ_HEAD(,instruction) seq_program;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_listing(FILE *listfile, char *ifilename);\nstatic void emit_patch(scope_t *scope, int patch);\nFILE *listfile;\nstatic TAILQ_HEAD(,instruction) seq_program;\nsymlist_t patch_functions;\n\nvoid\noutput_listing(FILE *listfile, char *ifilename)\n{\n\tchar buf[1024];\n\tFILE *ifile;\n\tstruct instruction *cur_instr;\n\tpatch_t *cur_patch;\n\tsymbol_node_t *cur_func;\n\tint *func_values;\n\tint instrcount;\n\tint instrptr;\n\tint line;\n\tint func_count;\n\tint skip_addr;\n\n\tinstrcount = 0;\n\tinstrptr = 0;\n\tline = 1;\n\tskip_addr = 0;\n\tif ((ifile = fopen(ifilename, \"r\")) == NULL) {\n\t\tperror(ifilename);\n\t\tstop(NULL, EX_DATAERR);\n\t}\n\n\t/*\n\t * Determine which options to apply to this listing.\n\t */\n\tfor (func_count = 0, cur_func = SLIST_FIRST(&patch_functions);\n\t    cur_func != NULL;\n\t    cur_func = SLIST_NEXT(cur_func, links))\n\t\tfunc_count++;\n\n\tif (func_count != 0) {\n\t\tfunc_values = (int *)malloc(func_count * sizeof(int));\n\n\t\tif (func_values == NULL)\n\t\t\tstop(\"Could not malloc\", EX_OSERR);\n\t\t\n\t\tfunc_values[0] = 0; /* FALSE func */\n\t\tfunc_count--;\n\n\t\t/*\n\t\t * Ask the user to fill in the return values for\n\t\t * the rest of the functions.\n\t\t */\n\t\t\n\t\t\n\t\tfor (cur_func = SLIST_FIRST(&patch_functions);\n\t\t     cur_func != NULL && SLIST_NEXT(cur_func, links) != NULL;\n\t\t     cur_func = SLIST_NEXT(cur_func, links), func_count--) {\n\t\t\tint input;\n\t\t\t\n\t\t\tfprintf(stdout, \"\\n(%s)\\n\", cur_func->symbol->name);\n\t\t\tfprintf(stdout,\n\t\t\t\t\"Enter the return value for \"\n\t\t\t\t\"this expression[T/F]:\");\n\n\t\t\twhile (1) {\n\n\t\t\t\tinput = getchar();\n\t\t\t\tinput = toupper(input);\n\n\t\t\t\tif (input == 'T') {\n\t\t\t\t\tfunc_values[func_count] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (input == 'F') {\n\t\t\t\t\tfunc_values[func_count] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isatty(fileno(stdin)) == 0)\n\t\t\t\tputchar(input);\n\t\t}\n\t\tfprintf(stdout, \"\\nThanks!\\n\");\n\t}\n\n\t/* Now output the listing */\n\tcur_patch = TAILQ_FIRST(&patches);\n\tfor(cur_instr = TAILQ_FIRST(&seq_program);\n\t    cur_instr != NULL;\n\t    cur_instr = TAILQ_NEXT(cur_instr, links), instrcount++) {\n\n\t\tif (check_patch(&cur_patch, instrcount,\n\t\t\t\t&skip_addr, func_values) == 0) {\n\t\t\t/* Don't count this instruction as it is in a patch\n\t\t\t * that was removed.\n\t\t\t */\n                        continue;\n\t\t}\n\n\t\twhile (line < cur_instr->srcline) {\n\t\t\tfgets(buf, sizeof(buf), ifile);\n\t\t\t\tfprintf(listfile, \"\\t\\t%s\", buf);\n\t\t\t\tline++;\n\t\t}\n\t\tfprintf(listfile, \"%03x %02x%02x%02x%02x\", instrptr,\n\t\t\tcur_instr->format.bytes[0],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[3]);\n\t\tfgets(buf, sizeof(buf), ifile);\n\t\tfprintf(listfile, \"\\t%s\", buf);\n\t\tline++;\n\t\tinstrptr++;\n\t}\n\t/* Dump the remainder of the file */\n\twhile(fgets(buf, sizeof(buf), ifile) != NULL)\n\t\tfprintf(listfile, \"\\t\\t%s\", buf);\n\n\tfclose(ifile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "symtable_dump",
          "args": [
            "regfile"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "symtable_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
          "lines": "304-472",
          "snippet": "void\nsymtable_dump(ofile)\n\tFILE *ofile;\n{\n\t/*\n\t * Sort the registers by address with a simple insertion sort.\n\t * Put bitmasks next to the first register that defines them.\n\t * Put constants at the end.\n\t */\n\tsymlist_t registers;\n\tsymlist_t masks;\n\tsymlist_t constants;\n\tsymlist_t download_constants;\n\tsymlist_t aliases;\n\n\tSLIST_INIT(&registers);\n\tSLIST_INIT(&masks);\n\tSLIST_INIT(&constants);\n\tSLIST_INIT(&download_constants);\n\tSLIST_INIT(&aliases);\n\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\t\tDBT\t data;\n\t\tint\t flag = R_FIRST;\n\n\t\twhile (symtable->seq(symtable, &key, &data, flag) == 0) {\n\t\t\tsymbol_t *cursym;\n\n\t\t\tmemcpy(&cursym, data.data, sizeof(cursym));\n\t\t\tswitch(cursym->type) {\n\t\t\tcase REGISTER:\n\t\t\tcase SCBLOC:\n\t\t\tcase SRAMLOC:\n\t\t\t\tsymlist_add(&registers, cursym, SYMLIST_SORT);\n\t\t\t\tbreak;\n\t\t\tcase MASK:\n\t\t\tcase BIT:\n\t\t\t\tsymlist_add(&masks, cursym, SYMLIST_SORT);\n\t\t\t\tbreak;\n\t\t\tcase CONST:\n\t\t\t\tif (cursym->info.cinfo->define == FALSE) {\n\t\t\t\t\tsymlist_add(&constants, cursym,\n\t\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWNLOAD_CONST:\n\t\t\t\tsymlist_add(&download_constants, cursym,\n\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\tbreak;\n\t\t\tcase ALIAS:\n\t\t\t\tsymlist_add(&aliases, cursym,\n\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag = R_NEXT;\n\t\t}\n\n\t\t/* Put in the masks and bits */\n\t\twhile (masks.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tsymbol_node_t *regnode;\n\t\t\tchar *regname;\n\n\t\t\tcurnode = masks.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&masks, links);\n\n\t\t\tregnode =\n\t\t\t    curnode->symbol->info.minfo->symrefs.slh_first;\n\t\t\tregname = regnode->symbol->name;\n\t\t\tregnode = symlist_search(&registers, regname);\n\t\t\tSLIST_INSERT_AFTER(regnode, curnode, links);\n\t\t}\n\n\t\t/* Add the aliases */\n\t\twhile (aliases.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tsymbol_node_t *regnode;\n\t\t\tchar *regname;\n\n\t\t\tcurnode = aliases.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&aliases, links);\n\n\t\t\tregname = curnode->symbol->info.ainfo->parent->name;\n\t\t\tregnode = symlist_search(&registers, regname);\n\t\t\tSLIST_INSERT_AFTER(regnode, curnode, links);\n\t\t}\n\n\t\t/* Output what we have */\n\t\tfprintf(ofile,\n\"/*\n * DO NOT EDIT - This file is automatically generated.\n */\\n\");\n\t\twhile (registers.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tu_int8_t value;\n\t\t\tchar *tab_str;\n\t\t\tchar *tab_str2;\n\n\t\t\tcurnode = registers.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&registers, links);\n\t\t\tswitch(curnode->symbol->type) {\n\t\t\tcase REGISTER:\n\t\t\tcase SCBLOC:\n\t\t\tcase SRAMLOC:\n\t\t\t\tfprintf(ofile, \"\\n\");\n\t\t\t\tvalue = curnode->symbol->info.rinfo->address;\n\t\t\t\ttab_str = \"\\t\";\n\t\t\t\ttab_str2 = \"\\t\\t\";\n\t\t\t\tbreak;\n\t\t\tcase ALIAS:\n\t\t\t{\n\t\t\t\tsymbol_t *parent;\n\n\t\t\t\tparent = curnode->symbol->info.ainfo->parent;\n\t\t\t\tvalue = parent->info.rinfo->address;\n\t\t\t\ttab_str = \"\\t\";\n\t\t\t\ttab_str2 = \"\\t\\t\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MASK:\n\t\t\tcase BIT:\n\t\t\t\tvalue = curnode->symbol->info.minfo->mask;\n\t\t\t\ttab_str = \"\\t\\t\";\n\t\t\t\ttab_str2 = \"\\t\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalue = 0; /* Quiet compiler */\n\t\t\t\ttab_str = NULL;\n\t\t\t\ttab_str2 = NULL;\n\t\t\t\tstop(\"symtable_dump: Invalid symbol type \"\n\t\t\t\t     \"encountered\", EX_SOFTWARE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(ofile, \"#define%s%-16s%s0x%02x\\n\",\n\t\t\t\ttab_str, curnode->symbol->name, tab_str2,\n\t\t\t\tvalue);\n\t\t\tfree(curnode);\n\t\t}\n\t\tfprintf(ofile, \"\\n\\n\");\n\n\t\twhile (constants.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\n\t\t\tcurnode = constants.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&constants, links);\n\t\t\tfprintf(ofile, \"#define\\t%-8s\\t0x%02x\\n\",\n\t\t\t\tcurnode->symbol->name,\n\t\t\t\tcurnode->symbol->info.cinfo->value);\n\t\t\tfree(curnode);\n\t\t}\n\n\t\t\n\t\tfprintf(ofile, \"\\n\\n/* Downloaded Constant Definitions */\\n\");\n\n\t\twhile (download_constants.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\n\t\t\tcurnode = download_constants.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&download_constants, links);\n\t\t\tfprintf(ofile, \"#define\\t%-8s\\t0x%02x\\n\",\n\t\t\t\tcurnode->symbol->name,\n\t\t\t\tcurnode->symbol->info.cinfo->value);\n\t\t\tfree(curnode);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"aicasm.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <db.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DB *symtable;",
            "symbol_t *\nsymbol_create(name)\n\tchar *name;",
            "symbol_t *\nsymtable_get(name)\n\tchar *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nstatic DB *symtable;\nsymbol_t *\nsymbol_create(name)\n\tchar *name;\nsymbol_t *\nsymtable_get(name)\n\tchar *name;\n\nvoid\nsymtable_dump(ofile)\n\tFILE *ofile;\n{\n\t/*\n\t * Sort the registers by address with a simple insertion sort.\n\t * Put bitmasks next to the first register that defines them.\n\t * Put constants at the end.\n\t */\n\tsymlist_t registers;\n\tsymlist_t masks;\n\tsymlist_t constants;\n\tsymlist_t download_constants;\n\tsymlist_t aliases;\n\n\tSLIST_INIT(&registers);\n\tSLIST_INIT(&masks);\n\tSLIST_INIT(&constants);\n\tSLIST_INIT(&download_constants);\n\tSLIST_INIT(&aliases);\n\n\tif (symtable != NULL) {\n\t\tDBT\t key;\n\t\tDBT\t data;\n\t\tint\t flag = R_FIRST;\n\n\t\twhile (symtable->seq(symtable, &key, &data, flag) == 0) {\n\t\t\tsymbol_t *cursym;\n\n\t\t\tmemcpy(&cursym, data.data, sizeof(cursym));\n\t\t\tswitch(cursym->type) {\n\t\t\tcase REGISTER:\n\t\t\tcase SCBLOC:\n\t\t\tcase SRAMLOC:\n\t\t\t\tsymlist_add(&registers, cursym, SYMLIST_SORT);\n\t\t\t\tbreak;\n\t\t\tcase MASK:\n\t\t\tcase BIT:\n\t\t\t\tsymlist_add(&masks, cursym, SYMLIST_SORT);\n\t\t\t\tbreak;\n\t\t\tcase CONST:\n\t\t\t\tif (cursym->info.cinfo->define == FALSE) {\n\t\t\t\t\tsymlist_add(&constants, cursym,\n\t\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DOWNLOAD_CONST:\n\t\t\t\tsymlist_add(&download_constants, cursym,\n\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\tbreak;\n\t\t\tcase ALIAS:\n\t\t\t\tsymlist_add(&aliases, cursym,\n\t\t\t\t\t    SYMLIST_INSERT_HEAD);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag = R_NEXT;\n\t\t}\n\n\t\t/* Put in the masks and bits */\n\t\twhile (masks.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tsymbol_node_t *regnode;\n\t\t\tchar *regname;\n\n\t\t\tcurnode = masks.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&masks, links);\n\n\t\t\tregnode =\n\t\t\t    curnode->symbol->info.minfo->symrefs.slh_first;\n\t\t\tregname = regnode->symbol->name;\n\t\t\tregnode = symlist_search(&registers, regname);\n\t\t\tSLIST_INSERT_AFTER(regnode, curnode, links);\n\t\t}\n\n\t\t/* Add the aliases */\n\t\twhile (aliases.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tsymbol_node_t *regnode;\n\t\t\tchar *regname;\n\n\t\t\tcurnode = aliases.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&aliases, links);\n\n\t\t\tregname = curnode->symbol->info.ainfo->parent->name;\n\t\t\tregnode = symlist_search(&registers, regname);\n\t\t\tSLIST_INSERT_AFTER(regnode, curnode, links);\n\t\t}\n\n\t\t/* Output what we have */\n\t\tfprintf(ofile,\n\"/*\n * DO NOT EDIT - This file is automatically generated.\n */\\n\");\n\t\twhile (registers.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\t\t\tu_int8_t value;\n\t\t\tchar *tab_str;\n\t\t\tchar *tab_str2;\n\n\t\t\tcurnode = registers.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&registers, links);\n\t\t\tswitch(curnode->symbol->type) {\n\t\t\tcase REGISTER:\n\t\t\tcase SCBLOC:\n\t\t\tcase SRAMLOC:\n\t\t\t\tfprintf(ofile, \"\\n\");\n\t\t\t\tvalue = curnode->symbol->info.rinfo->address;\n\t\t\t\ttab_str = \"\\t\";\n\t\t\t\ttab_str2 = \"\\t\\t\";\n\t\t\t\tbreak;\n\t\t\tcase ALIAS:\n\t\t\t{\n\t\t\t\tsymbol_t *parent;\n\n\t\t\t\tparent = curnode->symbol->info.ainfo->parent;\n\t\t\t\tvalue = parent->info.rinfo->address;\n\t\t\t\ttab_str = \"\\t\";\n\t\t\t\ttab_str2 = \"\\t\\t\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase MASK:\n\t\t\tcase BIT:\n\t\t\t\tvalue = curnode->symbol->info.minfo->mask;\n\t\t\t\ttab_str = \"\\t\\t\";\n\t\t\t\ttab_str2 = \"\\t\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalue = 0; /* Quiet compiler */\n\t\t\t\ttab_str = NULL;\n\t\t\t\ttab_str2 = NULL;\n\t\t\t\tstop(\"symtable_dump: Invalid symbol type \"\n\t\t\t\t     \"encountered\", EX_SOFTWARE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfprintf(ofile, \"#define%s%-16s%s0x%02x\\n\",\n\t\t\t\ttab_str, curnode->symbol->name, tab_str2,\n\t\t\t\tvalue);\n\t\t\tfree(curnode);\n\t\t}\n\t\tfprintf(ofile, \"\\n\\n\");\n\n\t\twhile (constants.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\n\t\t\tcurnode = constants.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&constants, links);\n\t\t\tfprintf(ofile, \"#define\\t%-8s\\t0x%02x\\n\",\n\t\t\t\tcurnode->symbol->name,\n\t\t\t\tcurnode->symbol->info.cinfo->value);\n\t\t\tfree(curnode);\n\t\t}\n\n\t\t\n\t\tfprintf(ofile, \"\\n\\n/* Downloaded Constant Definitions */\\n\");\n\n\t\twhile (download_constants.slh_first != NULL) {\n\t\t\tsymbol_node_t *curnode;\n\n\t\t\tcurnode = download_constants.slh_first;\n\t\t\tSLIST_REMOVE_HEAD(&download_constants, links);\n\t\t\tfprintf(ofile, \"#define\\t%-8s\\t0x%02x\\n\",\n\t\t\t\tcurnode->symbol->name,\n\t\t\t\tcurnode->symbol->info.cinfo->value);\n\t\t\tfree(curnode);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "output_code",
          "args": [
            "ofile"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "output_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "296-342",
          "snippet": "static void\noutput_code(ofile)\n\tFILE *ofile;\n{\n\tstruct instruction *cur_instr;\n\tpatch_t *cur_patch;\n\tsymbol_node_t *cur_node;\n\tint instrcount;\n\n\tinstrcount = 0;\n\tfprintf(ofile,\n\"/*\n * DO NOT EDIT - This file is automatically generated.\n */\\n\");\n\n\tfprintf(ofile, \"static u_int8_t seqprog[] = {\\n\");\n\tfor(cur_instr = seq_program.tqh_first;\n\t    cur_instr != NULL;\n\t    cur_instr = cur_instr->links.tqe_next) {\n\n\t\tfprintf(ofile, \"\\t0x%02x, 0x%02x, 0x%02x, 0x%02x,\\n\",\n\t\t\tcur_instr->format.bytes[0],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[3]);\n\t\tinstrcount++;\n\t}\n\tfprintf(ofile, \"};\\n\\n\");\n\n\t/*\n\t *  Output patch information.  Patch functions first.\n\t */\n\tfor(cur_node = SLIST_FIRST(&patch_functions);\n\t    cur_node != NULL;\n\t    cur_node = SLIST_NEXT(cur_node,links)) {\n\t\tfprintf(ofile,\n\"static int ahc_patch%d_func(struct ahc_softc *ahc);\n\nstatic int\nahc_patch%d_func(struct ahc_softc *ahc)\n{\n\treturn (%s);\n}\\n\\n\",\n\t\t\tcur_node->symbol->info.condinfo->func_num,\n\t\t\tcur_node->symbol->info.condinfo->func_num,\n\t\t\tcur_node->symbol->name);\n\t}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void output_code(FILE *ofile);",
            "static void emit_patch(scope_t *scope, int patch);",
            "FILE *ofile;",
            "static TAILQ_HEAD(,instruction) seq_program;",
            "symlist_t patch_functions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void output_code(FILE *ofile);\nstatic void emit_patch(scope_t *scope, int patch);\nFILE *ofile;\nstatic TAILQ_HEAD(,instruction) seq_program;\nsymlist_t patch_functions;\n\nstatic void\noutput_code(ofile)\n\tFILE *ofile;\n{\n\tstruct instruction *cur_instr;\n\tpatch_t *cur_patch;\n\tsymbol_node_t *cur_node;\n\tint instrcount;\n\n\tinstrcount = 0;\n\tfprintf(ofile,\n\"/*\n * DO NOT EDIT - This file is automatically generated.\n */\\n\");\n\n\tfprintf(ofile, \"static u_int8_t seqprog[] = {\\n\");\n\tfor(cur_instr = seq_program.tqh_first;\n\t    cur_instr != NULL;\n\t    cur_instr = cur_instr->links.tqe_next) {\n\n\t\tfprintf(ofile, \"\\t0x%02x, 0x%02x, 0x%02x, 0x%02x,\\n\",\n\t\t\tcur_instr->format.bytes[0],\n\t\t\tcur_instr->format.bytes[1],\n\t\t\tcur_instr->format.bytes[2],\n\t\t\tcur_instr->format.bytes[3]);\n\t\tinstrcount++;\n\t}\n\tfprintf(ofile, \"};\\n\\n\");\n\n\t/*\n\t *  Output patch information.  Patch functions first.\n\t */\n\tfor(cur_node = SLIST_FIRST(&patch_functions);\n\t    cur_node != NULL;\n\t    cur_node = SLIST_NEXT(cur_node,links)) {\n\t\tfprintf(ofile,\n\"static int ahc_patch%d_func(struct ahc_softc *ahc);\n\nstatic int\nahc_patch%d_func(struct ahc_softc *ahc)\n{\n\treturn (%s);\n}\\n\\n\",\n\t\t\tcur_node->symbol->info.condinfo->func_num,\n\t\t\tcur_node->symbol->info.condinfo->func_num,\n\t\t\tcur_node->symbol->name);\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "back_patch",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "back_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "267-294",
          "snippet": "static void\nback_patch()\n{\n\tstruct instruction *cur_instr;\n\n\tfor(cur_instr = seq_program.tqh_first;\n\t    cur_instr != NULL;\n\t    cur_instr = cur_instr->links.tqe_next) {\n\t\tif (cur_instr->patch_label != NULL) {\n\t\t\tstruct ins_format3 *f3_instr;\n\t\t\tu_int address;\n\n\t\t\tif (cur_instr->patch_label->type != LABEL) {\n\t\t\t\tchar buf[255];\n\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"Undefined label %s\",\n\t\t\t\t\t cur_instr->patch_label->name);\n\t\t\t\tstop(buf, EX_DATAERR);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tf3_instr = &cur_instr->format.format3;\n\t\t\taddress = f3_instr->address;\n\t\t\taddress += cur_instr->patch_label->info.linfo->address;\n\t\t\tf3_instr->address = address;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void back_patch(void);",
            "static TAILQ_HEAD(,instruction) seq_program;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void back_patch(void);\nstatic TAILQ_HEAD(,instruction) seq_program;\n\nstatic void\nback_patch()\n{\n\tstruct instruction *cur_instr;\n\n\tfor(cur_instr = seq_program.tqh_first;\n\t    cur_instr != NULL;\n\t    cur_instr = cur_instr->links.tqe_next) {\n\t\tif (cur_instr->patch_label != NULL) {\n\t\t\tstruct ins_format3 *f3_instr;\n\t\t\tu_int address;\n\n\t\t\tif (cur_instr->patch_label->type != LABEL) {\n\t\t\t\tchar buf[255];\n\n\t\t\t\tsnprintf(buf, sizeof(buf),\n\t\t\t\t\t \"Undefined label %s\",\n\t\t\t\t\t cur_instr->patch_label->name);\n\t\t\t\tstop(buf, EX_DATAERR);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tf3_instr = &cur_instr->format.format3;\n\t\t\taddress = f3_instr->address;\n\t\t\taddress += cur_instr->patch_label->info.linfo->address;\n\t\t\tf3_instr->address = address;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_scope",
          "args": [
            "SLIST_FIRST(&scope_stack)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "dump_scope",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "366-392",
          "snippet": "static void\ndump_scope(scope_t *scope)\n{\n\tscope_t *cur_scope;\n\n\t/*\n\t * Emit the first patch for this scope\n\t */\n\temit_patch(scope, 0);\n\n\t/*\n\t * Dump each scope within this one.\n\t */\n\tcur_scope = TAILQ_FIRST(&scope->inner_scope);\n\n\twhile (cur_scope != NULL) {\n\n\t\tdump_scope(cur_scope);\n\n\t\tcur_scope = TAILQ_NEXT(cur_scope, scope_links);\n\t}\n\n\t/*\n\t * Emit the second, closing, patch for this scope\n\t */\n\temit_patch(scope, 1);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dump_scope(scope_t *scope);",
            "static void emit_patch(scope_t *scope, int patch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void dump_scope(scope_t *scope);\nstatic void emit_patch(scope_t *scope, int patch);\n\nstatic void\ndump_scope(scope_t *scope)\n{\n\tscope_t *cur_scope;\n\n\t/*\n\t * Emit the first patch for this scope\n\t */\n\temit_patch(scope, 0);\n\n\t/*\n\t * Dump each scope within this one.\n\t */\n\tcur_scope = TAILQ_FIRST(&scope->inner_scope);\n\n\twhile (cur_scope != NULL) {\n\n\t\tdump_scope(cur_scope);\n\n\t\tcur_scope = TAILQ_NEXT(cur_scope, scope_links);\n\t}\n\n\t/*\n\t * Emit the second, closing, patch for this scope\n\t */\n\temit_patch(scope, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SLIST_FIRST",
          "args": [
            "&scope_stack"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_scope",
          "args": [
            "SLIST_FIRST(&scope_stack)"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "process_scope",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "657-721",
          "snippet": "void\nprocess_scope(scope_t *scope)\n{\n\t/*\n\t * We are \"leaving\" this scope.  We should now have\n\t * enough information to process the lists of scopes\n\t * we encapsulate.\n\t */\n\tscope_t *cur_scope;\n\tu_int skip_patch_count;\n\tu_int skip_instr_count;\n\n\tcur_scope = TAILQ_LAST(&scope->inner_scope, scope_tailq);\n\tskip_patch_count = 0;\n\tskip_instr_count = 0;\n\twhile (cur_scope != NULL) {\n\t\tu_int patch0_patch_skip;\n\n\t\tpatch0_patch_skip = 0;\n\t\tswitch (cur_scope->type) {\n\t\tcase SCOPE_IF:\n\t\tcase SCOPE_ELSE_IF:\n\t\t\tif (skip_instr_count != 0) {\n\t\t\t\t/* Create a tail patch */\n\t\t\t\tpatch0_patch_skip++;\n\t\t\t\tcur_scope->patches[1].skip_patch =\n\t\t\t\t    skip_patch_count + 1;\n\t\t\t\tcur_scope->patches[1].skip_instr =\n\t\t\t\t    skip_instr_count;\n\t\t\t}\n\n\t\t\t/* Count Head patch */\n\t\t\tpatch0_patch_skip++;\n\n\t\t\t/* Count any patches contained in our inner scope */\n\t\t\tpatch0_patch_skip += cur_scope->inner_scope_patches;\n\n\t\t\tcur_scope->patches[0].skip_patch = patch0_patch_skip;\n\t\t\tcur_scope->patches[0].skip_instr =\n\t\t\t    cur_scope->end_addr - cur_scope->begin_addr;\n\n\t\t\tskip_instr_count += cur_scope->patches[0].skip_instr;\n\n\t\t\tskip_patch_count += patch0_patch_skip;\n\t\t\tif (cur_scope->type == SCOPE_IF) {\n\t\t\t\tscope->inner_scope_patches += skip_patch_count;\n\t\t\t\tskip_patch_count = 0;\n\t\t\t        skip_instr_count = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCOPE_ELSE:\n\t\t\t/* Count any patches contained in our innter scope */\n\t\t\tskip_patch_count += cur_scope->inner_scope_patches;\n\n\t\t\tskip_instr_count += cur_scope->end_addr\n\t\t\t\t\t  - cur_scope->begin_addr;\n\t\t\tbreak;\n\t\tcase SCOPE_ROOT:\n\t\t\tstop(\"Unexpected scope type encountered\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\tcur_scope = TAILQ_PREV(cur_scope, scope_tailq, scope_links);\n\t}\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dump_scope(scope_t *scope);",
            "static void emit_patch(scope_t *scope, int patch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void dump_scope(scope_t *scope);\nstatic void emit_patch(scope_t *scope, int patch);\n\nvoid\nprocess_scope(scope_t *scope)\n{\n\t/*\n\t * We are \"leaving\" this scope.  We should now have\n\t * enough information to process the lists of scopes\n\t * we encapsulate.\n\t */\n\tscope_t *cur_scope;\n\tu_int skip_patch_count;\n\tu_int skip_instr_count;\n\n\tcur_scope = TAILQ_LAST(&scope->inner_scope, scope_tailq);\n\tskip_patch_count = 0;\n\tskip_instr_count = 0;\n\twhile (cur_scope != NULL) {\n\t\tu_int patch0_patch_skip;\n\n\t\tpatch0_patch_skip = 0;\n\t\tswitch (cur_scope->type) {\n\t\tcase SCOPE_IF:\n\t\tcase SCOPE_ELSE_IF:\n\t\t\tif (skip_instr_count != 0) {\n\t\t\t\t/* Create a tail patch */\n\t\t\t\tpatch0_patch_skip++;\n\t\t\t\tcur_scope->patches[1].skip_patch =\n\t\t\t\t    skip_patch_count + 1;\n\t\t\t\tcur_scope->patches[1].skip_instr =\n\t\t\t\t    skip_instr_count;\n\t\t\t}\n\n\t\t\t/* Count Head patch */\n\t\t\tpatch0_patch_skip++;\n\n\t\t\t/* Count any patches contained in our inner scope */\n\t\t\tpatch0_patch_skip += cur_scope->inner_scope_patches;\n\n\t\t\tcur_scope->patches[0].skip_patch = patch0_patch_skip;\n\t\t\tcur_scope->patches[0].skip_instr =\n\t\t\t    cur_scope->end_addr - cur_scope->begin_addr;\n\n\t\t\tskip_instr_count += cur_scope->patches[0].skip_instr;\n\n\t\t\tskip_patch_count += patch0_patch_skip;\n\t\t\tif (cur_scope->type == SCOPE_IF) {\n\t\t\t\tscope->inner_scope_patches += skip_patch_count;\n\t\t\t\tskip_patch_count = 0;\n\t\t\t        skip_instr_count = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCOPE_ELSE:\n\t\t\t/* Count any patches contained in our innter scope */\n\t\t\tskip_patch_count += cur_scope->inner_scope_patches;\n\n\t\t\tskip_instr_count += cur_scope->end_addr\n\t\t\t\t\t  - cur_scope->begin_addr;\n\t\t\tbreak;\n\t\tcase SCOPE_ROOT:\n\t\t\tstop(\"Unexpected scope type encountered\", EX_SOFTWARE);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\tcur_scope = TAILQ_PREV(cur_scope, scope_tailq, scope_links);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SLIST_FIRST",
          "args": [
            "&scope_stack"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_FIRST",
          "args": [
            "&scope_stack"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_FIRST",
          "args": [
            "&scope_stack"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yyparse",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "include_file",
          "args": [
            "*argv",
            "SOURCE_FILE"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symtable_open",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "symtable_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm_symbol.c",
          "lines": "110-122",
          "snippet": "void\nsymtable_open()\n{\n\tsymtable = dbopen(/*filename*/NULL,\n\t\t\t  O_CREAT | O_NONBLOCK | O_RDWR, /*mode*/0, DB_HASH,\n\t\t\t  /*openinfo*/NULL);\n\n\tif (symtable == NULL) {\n\t\tperror(\"Symbol table creation failed\");\n\t\texit(EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n}",
          "includes": [
            "#include \"aicasm.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <db.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DB *symtable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"aicasm.h\"\n#include \"aicasm_symbol.h\"\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <db.h>\n#include <sys/types.h>\n\nstatic DB *symtable;\n\nvoid\nsymtable_open()\n{\n\tsymtable = dbopen(/*filename*/NULL,\n\t\t\t  O_CREAT | O_NONBLOCK | O_RDWR, /*mode*/0, DB_HASH,\n\t\t\t  /*openinfo*/NULL);\n\n\tif (symtable == NULL) {\n\t\tperror(\"Symbol table creation failed\");\n\t\texit(EX_SOFTWARE);\n\t\t/* NOTREACHED */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "255-265",
          "snippet": "static void\nusage()\n{\n\n\t(void)fprintf(stderr,\n\"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n\t\t\t[-r register_output_file] [-l program_list_file]\n\t\t\tinput_file\\n\",\n\t\t\tappname);\n\texit(EX_USAGE);\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void usage(void);",
            "char *appname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void usage(void);\nchar *appname;\n\nstatic void\nusage()\n{\n\n\t(void)fprintf(stderr,\n\"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n\t\t\t[-r register_output_file] [-l program_list_file]\n\t\t\tinput_file\\n\",\n\t\t\tappname);\n\texit(EX_USAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: No input file specifiled\\n\"",
            "appname"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INSERT_HEAD",
          "args": [
            "&search_path",
            "include_dir",
            "links"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "optarg"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "ata_perror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
          "lines": "177-210",
          "snippet": "void\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "optarg"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*include_dir)"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Warning - '-I-' \"\n\t\t\t\t\t\t\t\"specified multiple \"\n\t\t\t\t\t\t\t\"times\\n\"",
            "appname"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "optarg",
            "\"-\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "optarg",
            "\"w\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "optarg",
            "\"w\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Unknown option -%c%s\\n\"",
            "appname",
            "ch",
            "optarg"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "optarg",
            "\"ostdinc\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "optarg",
            "\"w\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: -d Requires either an \"\n\t\t\t\t\t\"'s' or 'p' argument\\n\"",
            "appname"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "optarg",
            "\"p\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "optarg",
            "\"s\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"d:l:n:o:r:I:O:\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scope_alloc",
          "args": [],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "scope_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/microcode/aic7xxx/aicasm.c",
          "lines": "637-655",
          "snippet": "scope_t *\nscope_alloc()\n{\n\tscope_t *new_scope;\n\n\tnew_scope = (scope_t *)malloc(sizeof(scope_t));\n\tif (new_scope == NULL)\n\t\tstop(\"Unable to malloc scope object\", EX_SOFTWARE);\n\tmemset(new_scope, 0, sizeof(*new_scope));\n\tTAILQ_INIT(&new_scope->inner_scope);\n\t\n\tif (SLIST_FIRST(&scope_stack) != NULL) {\n\t\tTAILQ_INSERT_TAIL(&SLIST_FIRST(&scope_stack)->inner_scope,\n\t\t\t\t  new_scope, scope_links);\n\t}\n\t/* This patch is now the current scope */\n\tSLIST_INSERT_HEAD(&scope_stack, new_scope, scope_stack_links);\n\treturn new_scope;\n}",
          "includes": [
            "#include \"sequencer.h\"",
            "#include \"aicasm_symbol.h\"",
            "#include \"aicasm.h\"",
            "#include <unistd.h>",
            "#include <sysexits.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ctype.h>",
            "#include <sys/mman.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dump_scope(scope_t *scope);",
            "static void emit_patch(scope_t *scope, int patch);",
            "struct scope_list scope_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void dump_scope(scope_t *scope);\nstatic void emit_patch(scope_t *scope, int patch);\nstruct scope_list scope_stack;\n\nscope_t *\nscope_alloc()\n{\n\tscope_t *new_scope;\n\n\tnew_scope = (scope_t *)malloc(sizeof(scope_t));\n\tif (new_scope == NULL)\n\t\tstop(\"Unable to malloc scope object\", EX_SOFTWARE);\n\tmemset(new_scope, 0, sizeof(*new_scope));\n\tTAILQ_INIT(&new_scope->inner_scope);\n\t\n\tif (SLIST_FIRST(&scope_stack) != NULL) {\n\t\tTAILQ_INSERT_TAIL(&SLIST_FIRST(&scope_stack)->inner_scope,\n\t\t\t\t  new_scope, scope_links);\n\t}\n\t/* This patch is now the current scope */\n\tSLIST_INSERT_HEAD(&scope_stack, new_scope, scope_stack_links);\n\treturn new_scope;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "&scope_stack"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&seq_program"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLIST_INIT",
          "args": [
            "&search_path"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&patches"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sequencer.h\"\n#include \"aicasm_symbol.h\"\n#include \"aicasm.h\"\n#include <unistd.h>\n#include <sysexits.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n\nstatic void usage(void);\nstatic void back_patch(void);\nstatic void output_code(FILE *ofile);\nstatic void dump_scope(scope_t *scope);\nstruct path_list search_path;\nint includes_search_curdir;\nchar *appname;\nFILE *ofile;\nchar *ofilename;\nchar *regfilename;\nFILE *regfile;\nchar *listfilename;\nFILE *listfile;\nstatic TAILQ_HEAD(,instruction) seq_program;\nstruct scope_list scope_stack;\nextern int yyparse;\n\nint\nmain(argc, argv)\n\tint argc;\n\tchar *argv[];\n{\n\textern char *optarg;\n\textern int optind;\n\tint  ch;\n\tint  retval;\n\tchar *inputfilename;\n\tscope_t *sentinal;\n\n\tTAILQ_INIT(&patches);\n\tSLIST_INIT(&search_path);\n\tTAILQ_INIT(&seq_program);\n\tSLIST_INIT(&scope_stack);\n\n\t/* Set Sentinal scope node */\n\tsentinal = scope_alloc();\n\tsentinal->type = SCOPE_ROOT;\n\t\n\tincludes_search_curdir = 1;\n\tappname = *argv;\n\tregfile = NULL;\n\tlistfile = NULL;\n#if DEBUG\n\tyy_flex_debug = 0;\n\tyydebug = 0;\n#endif\n\twhile ((ch = getopt(argc, argv, \"d:l:n:o:r:I:O:\")) != -1) {\n\t\tswitch(ch) {\n\t\tcase 'd':\n#if DEBUG\n\t\t\tif (strcmp(optarg, \"s\") == 0) {\n\t\t\t\tyy_flex_debug = 1;\n\t\t\t} else if (strcmp(optarg, \"p\") == 0) {\n\t\t\t\tyydebug = 1;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"%s: -d Requires either an \"\n\t\t\t\t\t\"'s' or 'p' argument\\n\", appname);\n\t\t\t\tusage();\n\t\t\t}\n#else\n\t\t\tstop(\"-d: Assembler not built with debugging \"\n\t\t\t     \"information\", EX_SOFTWARE);\n#endif\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t/* Create a program listing */\n\t\t\tif ((listfile = fopen(optarg, \"w\")) == NULL) {\n\t\t\t\tperror(optarg);\n\t\t\t\tstop(NULL, EX_CANTCREAT);\n\t\t\t}\n\t\t\tlistfilename = optarg;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t/* Don't complain about the -nostdinc directrive */\n\t\t\tif (strcmp(optarg, \"ostdinc\")) {\n\t\t\t\tfprintf(stderr, \"%s: Unknown option -%c%s\\n\",\n\t\t\t\t\tappname, ch, optarg);\n\t\t\t\tusage();\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif ((ofile = fopen(optarg, \"w\")) == NULL) {\n\t\t\t\tperror(optarg);\n\t\t\t\tstop(NULL, EX_CANTCREAT);\n\t\t\t}\n\t\t\tofilename = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif ((regfile = fopen(optarg, \"w\")) == NULL) {\n\t\t\t\tperror(optarg);\n\t\t\t\tstop(NULL, EX_CANTCREAT);\n\t\t\t}\n\t\t\tregfilename = optarg;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t{\n\t\t\tpath_entry_t include_dir;\n\n\t\t\tif (strcmp(optarg, \"-\") == 0) {\n\t\t\t\tif (includes_search_curdir == 0) {\n\t\t\t\t\tfprintf(stderr, \"%s: Warning - '-I-' \"\n\t\t\t\t\t\t\t\"specified multiple \"\n\t\t\t\t\t\t\t\"times\\n\", appname);\n\t\t\t\t}\n\t\t\t\tincludes_search_curdir = 0;\n\t\t\t\tfor (include_dir = search_path.slh_first;\n\t\t\t\t     include_dir != NULL;\n\t\t\t\t     include_dir = include_dir->links.sle_next)\n\t\t\t\t\t/*\n\t\t\t\t\t * All entries before a '-I-' only\n\t\t\t\t\t * apply to includes specified with\n\t\t\t\t\t * quotes instead of \"<>\".\n\t\t\t\t\t */\n\t\t\t\t\tinclude_dir->quoted_includes_only = 1;\n\t\t\t} else {\n\t\t\t\tinclude_dir =\n\t\t\t\t    (path_entry_t)malloc(sizeof(*include_dir));\n\t\t\t\tif (include_dir == NULL) {\n\t\t\t\t\tperror(optarg);\n\t\t\t\t\tstop(NULL, EX_OSERR);\n\t\t\t\t}\n\t\t\t\tinclude_dir->directory = strdup(optarg);\n\t\t\t\tif (include_dir->directory == NULL) {\n\t\t\t\t\tperror(optarg);\n\t\t\t\t\tstop(NULL, EX_OSERR);\n\t\t\t\t}\n\t\t\t\tinclude_dir->quoted_includes_only = 0;\n\t\t\t\tSLIST_INSERT_HEAD(&search_path, include_dir,\n\t\t\t\t\t\t  links);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (argc != 1) {\n\t\tfprintf(stderr, \"%s: No input file specifiled\\n\", appname);\n\t\tusage();\n\t\t/* NOTREACHED */\n\t}\n\n\tsymtable_open();\n\tinputfilename = *argv;\n\tinclude_file(*argv, SOURCE_FILE);\n\tretval = yyparse();\n\tif (retval == 0) {\n\t\tif (SLIST_FIRST(&scope_stack) == NULL\n\t\t || SLIST_FIRST(&scope_stack)->type != SCOPE_ROOT) {\n\t\t\tstop(\"Unterminated conditional expression\",\n\t\t\t     EX_DATAERR);\n\t\t\t/* NOTREACHED */\n\t\t}\n\n\t\t/* Process outmost scope */\n\t\tprocess_scope(SLIST_FIRST(&scope_stack));\n\t\t/*\n\t\t * Decend the tree of scopes and insert/emit\n\t\t * patches as appropriate.  We perform a depth first\n\t\t * tranversal, recursively handling each scope.\n\t\t */\n\t\t/* start at the root scope */\n\t\tdump_scope(SLIST_FIRST(&scope_stack));\n\n\t\t/* Patch up forward jump addresses */\n\t\tback_patch();\n\n\t\tif (ofile != NULL)\n\t\t\toutput_code(ofile);\n\t\tif (regfile != NULL) {\n\t\t\tsymtable_dump(regfile);\n\t\t}\n\t\tif (listfile != NULL)\n\t\t\toutput_listing(listfile, inputfilename);\n\t}\n\n\tstop(NULL, 0);\n\t/* NOTREACHED */\n\treturn (0);\n}"
  }
]