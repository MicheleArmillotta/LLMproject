[
  {
    "function_name": "rf_bxor3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "880-893",
    "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_longword_bxor3",
          "args": [
            "(unsigned long *) dst",
            "(unsigned long *) a",
            "(unsigned long *) b",
            "(unsigned long *) c",
            "len >> RF_LONGSHIFT",
            "bp"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "rf_longword_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "715-878",
          "snippet": "int \nrf_longword_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned long *dst;\n\tregister unsigned long *a;\n\tregister unsigned long *b;\n\tregister unsigned long *c;\n\tint     len;\t\t/* length in longwords */\n\tvoid   *bp;\n{\n\tunsigned long a0, a1, a2, a3, b0, b1, b2, b3;\n\tregister unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;\t/* per-page source/dest\n\t\t\t\t\t\t\t\t * pointers */\n\tint     longs_this_time;/* # longs to xor in the current iteration */\n\tchar    dst_is_a = 0;\n\n\tREMAP_VA(bp, a, pg_a);\n\tREMAP_VA(bp, b, pg_b);\n\tREMAP_VA(bp, c, pg_c);\n\tif (a == dst) {\n\t\tpg_dst = pg_a;\n\t\tdst_is_a = 1;\n\t} else {\n\t\tREMAP_VA(bp, dst, pg_dst);\n\t}\n\n\t/* align dest to cache line.  Can't cross a pg boundary on dst here. */\n\twhile ((((unsigned long) pg_dst) & 0x1f)) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, a, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, a, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tlen--;\n\t}\n\n\twhile (len > 4) {\n\t\tlongs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a), RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >> RF_LONGSHIFT);\n\t\ta += longs_this_time;\n\t\tb += longs_this_time;\n\t\tc += longs_this_time;\n\t\tdst += longs_this_time;\n\t\tlen -= longs_this_time;\n\t\twhile (longs_this_time >= 4) {\n\t\t\ta0 = pg_a[0];\n\t\t\tlongs_this_time -= 4;\n\n\t\t\ta1 = pg_a[1];\n\t\t\ta2 = pg_a[2];\n\n\t\t\ta3 = pg_a[3];\n\t\t\tpg_a += 4;\n\n\t\t\tb0 = pg_b[0];\n\t\t\tb1 = pg_b[1];\n\n\t\t\tb2 = pg_b[2];\n\t\t\tb3 = pg_b[3];\n\t\t\t/* start dual issue */\n\t\t\ta0 ^= b0;\n\t\t\tb0 = pg_c[0];\n\n\t\t\tpg_b += 4;\n\t\t\ta1 ^= b1;\n\n\t\t\ta2 ^= b2;\n\t\t\ta3 ^= b3;\n\n\t\t\tb1 = pg_c[1];\n\t\t\ta0 ^= b0;\n\n\t\t\tb2 = pg_c[2];\n\t\t\ta1 ^= b1;\n\n\t\t\tb3 = pg_c[3];\n\t\t\ta2 ^= b2;\n\n\t\t\tpg_dst[0] = a0;\n\t\t\ta3 ^= b3;\n\t\t\tpg_dst[1] = a1;\n\t\t\tpg_c += 4;\n\t\t\tpg_dst[2] = a2;\n\t\t\tpg_dst[3] = a3;\n\t\t\tpg_dst += 4;\n\t\t}\n\t\twhile (longs_this_time > 0) {\t/* cannot cross any page\n\t\t\t\t\t\t * boundaries here */\n\t\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\t\tlongs_this_time--;\n\t\t}\n\n\t\tif (len) {\n\t\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\t\tif (!pg_a)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t\tif (dst_is_a)\n\t\t\t\t\tpg_dst = pg_a;\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\t\tif (!pg_b)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\t\tif (!pg_c)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (!dst_is_a)\n\t\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\t\tif (!pg_dst)\n\t\t\t\t\t\treturn (EFAULT);\n\t\t\t\t}\n\t\t}\n\t}\n\twhile (len) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t\tif (dst_is_a)\n\t\t\t\tpg_dst = pg_a;\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (!dst_is_a)\n\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\tif (!pg_dst)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\tlen--;\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_longword_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned long *dst;\n\tregister unsigned long *a;\n\tregister unsigned long *b;\n\tregister unsigned long *c;\n\tint     len;\t\t/* length in longwords */\n\tvoid   *bp;\n{\n\tunsigned long a0, a1, a2, a3, b0, b1, b2, b3;\n\tregister unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;\t/* per-page source/dest\n\t\t\t\t\t\t\t\t * pointers */\n\tint     longs_this_time;/* # longs to xor in the current iteration */\n\tchar    dst_is_a = 0;\n\n\tREMAP_VA(bp, a, pg_a);\n\tREMAP_VA(bp, b, pg_b);\n\tREMAP_VA(bp, c, pg_c);\n\tif (a == dst) {\n\t\tpg_dst = pg_a;\n\t\tdst_is_a = 1;\n\t} else {\n\t\tREMAP_VA(bp, dst, pg_dst);\n\t}\n\n\t/* align dest to cache line.  Can't cross a pg boundary on dst here. */\n\twhile ((((unsigned long) pg_dst) & 0x1f)) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, a, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, a, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tlen--;\n\t}\n\n\twhile (len > 4) {\n\t\tlongs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a), RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >> RF_LONGSHIFT);\n\t\ta += longs_this_time;\n\t\tb += longs_this_time;\n\t\tc += longs_this_time;\n\t\tdst += longs_this_time;\n\t\tlen -= longs_this_time;\n\t\twhile (longs_this_time >= 4) {\n\t\t\ta0 = pg_a[0];\n\t\t\tlongs_this_time -= 4;\n\n\t\t\ta1 = pg_a[1];\n\t\t\ta2 = pg_a[2];\n\n\t\t\ta3 = pg_a[3];\n\t\t\tpg_a += 4;\n\n\t\t\tb0 = pg_b[0];\n\t\t\tb1 = pg_b[1];\n\n\t\t\tb2 = pg_b[2];\n\t\t\tb3 = pg_b[3];\n\t\t\t/* start dual issue */\n\t\t\ta0 ^= b0;\n\t\t\tb0 = pg_c[0];\n\n\t\t\tpg_b += 4;\n\t\t\ta1 ^= b1;\n\n\t\t\ta2 ^= b2;\n\t\t\ta3 ^= b3;\n\n\t\t\tb1 = pg_c[1];\n\t\t\ta0 ^= b0;\n\n\t\t\tb2 = pg_c[2];\n\t\t\ta1 ^= b1;\n\n\t\t\tb3 = pg_c[3];\n\t\t\ta2 ^= b2;\n\n\t\t\tpg_dst[0] = a0;\n\t\t\ta3 ^= b3;\n\t\t\tpg_dst[1] = a1;\n\t\t\tpg_c += 4;\n\t\t\tpg_dst[2] = a2;\n\t\t\tpg_dst[3] = a3;\n\t\t\tpg_dst += 4;\n\t\t}\n\t\twhile (longs_this_time > 0) {\t/* cannot cross any page\n\t\t\t\t\t\t * boundaries here */\n\t\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\t\tlongs_this_time--;\n\t\t}\n\n\t\tif (len) {\n\t\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\t\tif (!pg_a)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t\tif (dst_is_a)\n\t\t\t\t\tpg_dst = pg_a;\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\t\tif (!pg_b)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\t\tif (!pg_c)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (!dst_is_a)\n\t\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\t\tif (!pg_dst)\n\t\t\t\t\t\treturn (EFAULT);\n\t\t\t\t}\n\t\t}\n\t}\n\twhile (len) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t\tif (dst_is_a)\n\t\t\t\tpg_dst = pg_a;\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (!dst_is_a)\n\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\tif (!pg_dst)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\tlen--;\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UL",
          "args": [
            "c"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UL",
          "args": [
            "b"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UL",
          "args": [
            "a"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UL",
          "args": [
            "dst"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
  },
  {
    "function_name": "rf_longword_bxor3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "715-878",
    "snippet": "int \nrf_longword_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned long *dst;\n\tregister unsigned long *a;\n\tregister unsigned long *b;\n\tregister unsigned long *c;\n\tint     len;\t\t/* length in longwords */\n\tvoid   *bp;\n{\n\tunsigned long a0, a1, a2, a3, b0, b1, b2, b3;\n\tregister unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;\t/* per-page source/dest\n\t\t\t\t\t\t\t\t * pointers */\n\tint     longs_this_time;/* # longs to xor in the current iteration */\n\tchar    dst_is_a = 0;\n\n\tREMAP_VA(bp, a, pg_a);\n\tREMAP_VA(bp, b, pg_b);\n\tREMAP_VA(bp, c, pg_c);\n\tif (a == dst) {\n\t\tpg_dst = pg_a;\n\t\tdst_is_a = 1;\n\t} else {\n\t\tREMAP_VA(bp, dst, pg_dst);\n\t}\n\n\t/* align dest to cache line.  Can't cross a pg boundary on dst here. */\n\twhile ((((unsigned long) pg_dst) & 0x1f)) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, a, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, a, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tlen--;\n\t}\n\n\twhile (len > 4) {\n\t\tlongs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a), RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >> RF_LONGSHIFT);\n\t\ta += longs_this_time;\n\t\tb += longs_this_time;\n\t\tc += longs_this_time;\n\t\tdst += longs_this_time;\n\t\tlen -= longs_this_time;\n\t\twhile (longs_this_time >= 4) {\n\t\t\ta0 = pg_a[0];\n\t\t\tlongs_this_time -= 4;\n\n\t\t\ta1 = pg_a[1];\n\t\t\ta2 = pg_a[2];\n\n\t\t\ta3 = pg_a[3];\n\t\t\tpg_a += 4;\n\n\t\t\tb0 = pg_b[0];\n\t\t\tb1 = pg_b[1];\n\n\t\t\tb2 = pg_b[2];\n\t\t\tb3 = pg_b[3];\n\t\t\t/* start dual issue */\n\t\t\ta0 ^= b0;\n\t\t\tb0 = pg_c[0];\n\n\t\t\tpg_b += 4;\n\t\t\ta1 ^= b1;\n\n\t\t\ta2 ^= b2;\n\t\t\ta3 ^= b3;\n\n\t\t\tb1 = pg_c[1];\n\t\t\ta0 ^= b0;\n\n\t\t\tb2 = pg_c[2];\n\t\t\ta1 ^= b1;\n\n\t\t\tb3 = pg_c[3];\n\t\t\ta2 ^= b2;\n\n\t\t\tpg_dst[0] = a0;\n\t\t\ta3 ^= b3;\n\t\t\tpg_dst[1] = a1;\n\t\t\tpg_c += 4;\n\t\t\tpg_dst[2] = a2;\n\t\t\tpg_dst[3] = a3;\n\t\t\tpg_dst += 4;\n\t\t}\n\t\twhile (longs_this_time > 0) {\t/* cannot cross any page\n\t\t\t\t\t\t * boundaries here */\n\t\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\t\tlongs_this_time--;\n\t\t}\n\n\t\tif (len) {\n\t\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\t\tif (!pg_a)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t\tif (dst_is_a)\n\t\t\t\t\tpg_dst = pg_a;\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\t\tif (!pg_b)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\t\tif (!pg_c)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (!dst_is_a)\n\t\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\t\tif (!pg_dst)\n\t\t\t\t\t\treturn (EFAULT);\n\t\t\t\t}\n\t\t}\n\t}\n\twhile (len) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t\tif (dst_is_a)\n\t\t\t\tpg_dst = pg_a;\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (!dst_is_a)\n\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\tif (!pg_dst)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\tlen--;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "dst",
            "pg_dst"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "dst"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "c",
            "pg_c"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "c"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "b",
            "pg_b"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "b"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "a",
            "pg_a"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "a"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "dst",
            "pg_dst"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "dst"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "c",
            "pg_c"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "c"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "b",
            "pg_b"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "b"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "a",
            "pg_a"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "a"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "len",
            "RF_MIN(RF_BLIP(a), RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >> RF_LONGSHIFT"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "RF_BLIP(a)",
            "RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "RF_BLIP(b)",
            "RF_MIN(RF_BLIP(c), RF_BLIP(dst))"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "RF_BLIP(c)",
            "RF_BLIP(dst)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_BLIP",
          "args": [
            "dst"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_BLIP",
          "args": [
            "c"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_BLIP",
          "args": [
            "b"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_BLIP",
          "args": [
            "a"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "a",
            "pg_c"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "c"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "a",
            "pg_b"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "b"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "a",
            "pg_a"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "a"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "dst",
            "pg_dst"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "c",
            "pg_c"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "b",
            "pg_b"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "a",
            "pg_a"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_longword_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned long *dst;\n\tregister unsigned long *a;\n\tregister unsigned long *b;\n\tregister unsigned long *c;\n\tint     len;\t\t/* length in longwords */\n\tvoid   *bp;\n{\n\tunsigned long a0, a1, a2, a3, b0, b1, b2, b3;\n\tregister unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;\t/* per-page source/dest\n\t\t\t\t\t\t\t\t * pointers */\n\tint     longs_this_time;/* # longs to xor in the current iteration */\n\tchar    dst_is_a = 0;\n\n\tREMAP_VA(bp, a, pg_a);\n\tREMAP_VA(bp, b, pg_b);\n\tREMAP_VA(bp, c, pg_c);\n\tif (a == dst) {\n\t\tpg_dst = pg_a;\n\t\tdst_is_a = 1;\n\t} else {\n\t\tREMAP_VA(bp, dst, pg_dst);\n\t}\n\n\t/* align dest to cache line.  Can't cross a pg boundary on dst here. */\n\twhile ((((unsigned long) pg_dst) & 0x1f)) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, a, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, a, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tlen--;\n\t}\n\n\twhile (len > 4) {\n\t\tlongs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a), RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >> RF_LONGSHIFT);\n\t\ta += longs_this_time;\n\t\tb += longs_this_time;\n\t\tc += longs_this_time;\n\t\tdst += longs_this_time;\n\t\tlen -= longs_this_time;\n\t\twhile (longs_this_time >= 4) {\n\t\t\ta0 = pg_a[0];\n\t\t\tlongs_this_time -= 4;\n\n\t\t\ta1 = pg_a[1];\n\t\t\ta2 = pg_a[2];\n\n\t\t\ta3 = pg_a[3];\n\t\t\tpg_a += 4;\n\n\t\t\tb0 = pg_b[0];\n\t\t\tb1 = pg_b[1];\n\n\t\t\tb2 = pg_b[2];\n\t\t\tb3 = pg_b[3];\n\t\t\t/* start dual issue */\n\t\t\ta0 ^= b0;\n\t\t\tb0 = pg_c[0];\n\n\t\t\tpg_b += 4;\n\t\t\ta1 ^= b1;\n\n\t\t\ta2 ^= b2;\n\t\t\ta3 ^= b3;\n\n\t\t\tb1 = pg_c[1];\n\t\t\ta0 ^= b0;\n\n\t\t\tb2 = pg_c[2];\n\t\t\ta1 ^= b1;\n\n\t\t\tb3 = pg_c[3];\n\t\t\ta2 ^= b2;\n\n\t\t\tpg_dst[0] = a0;\n\t\t\ta3 ^= b3;\n\t\t\tpg_dst[1] = a1;\n\t\t\tpg_c += 4;\n\t\t\tpg_dst[2] = a2;\n\t\t\tpg_dst[3] = a3;\n\t\t\tpg_dst += 4;\n\t\t}\n\t\twhile (longs_this_time > 0) {\t/* cannot cross any page\n\t\t\t\t\t\t * boundaries here */\n\t\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\t\tlongs_this_time--;\n\t\t}\n\n\t\tif (len) {\n\t\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\t\tif (!pg_a)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t\tif (dst_is_a)\n\t\t\t\t\tpg_dst = pg_a;\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\t\tif (!pg_b)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\t\tif (!pg_c)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (!dst_is_a)\n\t\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\t\tif (!pg_dst)\n\t\t\t\t\t\treturn (EFAULT);\n\t\t\t\t}\n\t\t}\n\t}\n\twhile (len) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t\tif (dst_is_a)\n\t\t\t\tpg_dst = pg_a;\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (!dst_is_a)\n\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\tif (!pg_dst)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\tlen--;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_longword_bxor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "638-707",
    "snippet": "int \nrf_longword_bxor(src, dest, len, bp)\n\tregister unsigned long *src;\n\tregister unsigned long *dest;\n\tint     len;\t\t/* longwords */\n\tvoid   *bp;\n{\n\tregister unsigned long *end = src + len;\n\tregister unsigned long d0, d1, d2, d3, s0, s1, s2, s3;\t/* temps */\n\tregister unsigned long *pg_src, *pg_dest;\t/* per-page source/dest\n\t\t\t\t\t\t\t * pointers */\n\tint     longs_this_time;/* # longwords to xor in the current iteration */\n\n\tREMAP_VA(bp, src, pg_src);\n\tREMAP_VA(bp, dest, pg_dest);\n\tif (!pg_src || !pg_dest)\n\t\treturn (EFAULT);\n\n\twhile (len >= 4) {\n\t\tlongs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(pg_src), RF_BLIP(pg_dest)) >> RF_LONGSHIFT);\t/* note len in longwords */\n\t\tsrc += longs_this_time;\n\t\tdest += longs_this_time;\n\t\tlen -= longs_this_time;\n\t\twhile (longs_this_time >= 4) {\n\t\t\td0 = pg_dest[0];\n\t\t\td1 = pg_dest[1];\n\t\t\td2 = pg_dest[2];\n\t\t\td3 = pg_dest[3];\n\t\t\ts0 = pg_src[0];\n\t\t\ts1 = pg_src[1];\n\t\t\ts2 = pg_src[2];\n\t\t\ts3 = pg_src[3];\n\t\t\tpg_dest[0] = d0 ^ s0;\n\t\t\tpg_dest[1] = d1 ^ s1;\n\t\t\tpg_dest[2] = d2 ^ s2;\n\t\t\tpg_dest[3] = d3 ^ s3;\n\t\t\tpg_src += 4;\n\t\t\tpg_dest += 4;\n\t\t\tlongs_this_time -= 4;\n\t\t}\n\t\twhile (longs_this_time > 0) {\t/* cannot cross any page\n\t\t\t\t\t\t * boundaries here */\n\t\t\t*pg_dest++ ^= *pg_src++;\n\t\t\tlongs_this_time--;\n\t\t}\n\n\t\t/* either we're done, or we've reached a page boundary on one\n\t\t * (or possibly both) of the pointers */\n\t\tif (len) {\n\t\t\tif (RF_PAGE_ALIGNED(src))\n\t\t\t\tREMAP_VA(bp, src, pg_src);\n\t\t\tif (RF_PAGE_ALIGNED(dest))\n\t\t\t\tREMAP_VA(bp, dest, pg_dest);\n\t\t\tif (!pg_src || !pg_dest)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t}\n\twhile (src < end) {\n\t\t*pg_dest++ ^= *pg_src++;\n\t\tsrc++;\n\t\tdest++;\n\t\tlen--;\n\t\tif (RF_PAGE_ALIGNED(src))\n\t\t\tREMAP_VA(bp, src, pg_src);\n\t\tif (RF_PAGE_ALIGNED(dest))\n\t\t\tREMAP_VA(bp, dest, pg_dest);\n\t}\n\tRF_ASSERT(len == 0);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "len == 0"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "dest",
            "pg_dest"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "dest"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "src",
            "pg_src"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "src"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "dest",
            "pg_dest"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "dest"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "src",
            "pg_src"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PAGE_ALIGNED",
          "args": [
            "src"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "len",
            "RF_MIN(RF_BLIP(pg_src), RF_BLIP(pg_dest)) >> RF_LONGSHIFT"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "RF_BLIP(pg_src)",
            "RF_BLIP(pg_dest)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_BLIP",
          "args": [
            "pg_dest"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_BLIP",
          "args": [
            "pg_src"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "dest",
            "pg_dest"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REMAP_VA",
          "args": [
            "bp",
            "src",
            "pg_src"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_longword_bxor(src, dest, len, bp)\n\tregister unsigned long *src;\n\tregister unsigned long *dest;\n\tint     len;\t\t/* longwords */\n\tvoid   *bp;\n{\n\tregister unsigned long *end = src + len;\n\tregister unsigned long d0, d1, d2, d3, s0, s1, s2, s3;\t/* temps */\n\tregister unsigned long *pg_src, *pg_dest;\t/* per-page source/dest\n\t\t\t\t\t\t\t * pointers */\n\tint     longs_this_time;/* # longwords to xor in the current iteration */\n\n\tREMAP_VA(bp, src, pg_src);\n\tREMAP_VA(bp, dest, pg_dest);\n\tif (!pg_src || !pg_dest)\n\t\treturn (EFAULT);\n\n\twhile (len >= 4) {\n\t\tlongs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(pg_src), RF_BLIP(pg_dest)) >> RF_LONGSHIFT);\t/* note len in longwords */\n\t\tsrc += longs_this_time;\n\t\tdest += longs_this_time;\n\t\tlen -= longs_this_time;\n\t\twhile (longs_this_time >= 4) {\n\t\t\td0 = pg_dest[0];\n\t\t\td1 = pg_dest[1];\n\t\t\td2 = pg_dest[2];\n\t\t\td3 = pg_dest[3];\n\t\t\ts0 = pg_src[0];\n\t\t\ts1 = pg_src[1];\n\t\t\ts2 = pg_src[2];\n\t\t\ts3 = pg_src[3];\n\t\t\tpg_dest[0] = d0 ^ s0;\n\t\t\tpg_dest[1] = d1 ^ s1;\n\t\t\tpg_dest[2] = d2 ^ s2;\n\t\t\tpg_dest[3] = d3 ^ s3;\n\t\t\tpg_src += 4;\n\t\t\tpg_dest += 4;\n\t\t\tlongs_this_time -= 4;\n\t\t}\n\t\twhile (longs_this_time > 0) {\t/* cannot cross any page\n\t\t\t\t\t\t * boundaries here */\n\t\t\t*pg_dest++ ^= *pg_src++;\n\t\t\tlongs_this_time--;\n\t\t}\n\n\t\t/* either we're done, or we've reached a page boundary on one\n\t\t * (or possibly both) of the pointers */\n\t\tif (len) {\n\t\t\tif (RF_PAGE_ALIGNED(src))\n\t\t\t\tREMAP_VA(bp, src, pg_src);\n\t\t\tif (RF_PAGE_ALIGNED(dest))\n\t\t\t\tREMAP_VA(bp, dest, pg_dest);\n\t\t\tif (!pg_src || !pg_dest)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t}\n\twhile (src < end) {\n\t\t*pg_dest++ ^= *pg_src++;\n\t\tsrc++;\n\t\tdest++;\n\t\tlen--;\n\t\tif (RF_PAGE_ALIGNED(src))\n\t\t\tREMAP_VA(bp, src, pg_src);\n\t\tif (RF_PAGE_ALIGNED(dest))\n\t\t\tREMAP_VA(bp, dest, pg_dest);\n\t}\n\tRF_ASSERT(len == 0);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_bxor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "613-628",
    "snippet": "int \nrf_bxor(src, dest, len, bp)\n\tchar   *src;\n\tchar   *dest;\n\tint     len;\n\tvoid   *bp;\n{\n\tunsigned mask = sizeof(long) - 1, retcode = 0;\n\n\tif (!(((unsigned long) src) & mask) && !(((unsigned long) dest) & mask) && !(len & mask)) {\n\t\tretcode = rf_longword_bxor((unsigned long *) src, (unsigned long *) dest, len >> RF_LONGSHIFT, bp);\n\t} else {\n\t\tRF_ASSERT(0);\n\t}\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_longword_bxor",
          "args": [
            "(unsigned long *) src",
            "(unsigned long *) dest",
            "len >> RF_LONGSHIFT",
            "bp"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "rf_longword_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "715-878",
          "snippet": "int \nrf_longword_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned long *dst;\n\tregister unsigned long *a;\n\tregister unsigned long *b;\n\tregister unsigned long *c;\n\tint     len;\t\t/* length in longwords */\n\tvoid   *bp;\n{\n\tunsigned long a0, a1, a2, a3, b0, b1, b2, b3;\n\tregister unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;\t/* per-page source/dest\n\t\t\t\t\t\t\t\t * pointers */\n\tint     longs_this_time;/* # longs to xor in the current iteration */\n\tchar    dst_is_a = 0;\n\n\tREMAP_VA(bp, a, pg_a);\n\tREMAP_VA(bp, b, pg_b);\n\tREMAP_VA(bp, c, pg_c);\n\tif (a == dst) {\n\t\tpg_dst = pg_a;\n\t\tdst_is_a = 1;\n\t} else {\n\t\tREMAP_VA(bp, dst, pg_dst);\n\t}\n\n\t/* align dest to cache line.  Can't cross a pg boundary on dst here. */\n\twhile ((((unsigned long) pg_dst) & 0x1f)) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, a, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, a, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tlen--;\n\t}\n\n\twhile (len > 4) {\n\t\tlongs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a), RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >> RF_LONGSHIFT);\n\t\ta += longs_this_time;\n\t\tb += longs_this_time;\n\t\tc += longs_this_time;\n\t\tdst += longs_this_time;\n\t\tlen -= longs_this_time;\n\t\twhile (longs_this_time >= 4) {\n\t\t\ta0 = pg_a[0];\n\t\t\tlongs_this_time -= 4;\n\n\t\t\ta1 = pg_a[1];\n\t\t\ta2 = pg_a[2];\n\n\t\t\ta3 = pg_a[3];\n\t\t\tpg_a += 4;\n\n\t\t\tb0 = pg_b[0];\n\t\t\tb1 = pg_b[1];\n\n\t\t\tb2 = pg_b[2];\n\t\t\tb3 = pg_b[3];\n\t\t\t/* start dual issue */\n\t\t\ta0 ^= b0;\n\t\t\tb0 = pg_c[0];\n\n\t\t\tpg_b += 4;\n\t\t\ta1 ^= b1;\n\n\t\t\ta2 ^= b2;\n\t\t\ta3 ^= b3;\n\n\t\t\tb1 = pg_c[1];\n\t\t\ta0 ^= b0;\n\n\t\t\tb2 = pg_c[2];\n\t\t\ta1 ^= b1;\n\n\t\t\tb3 = pg_c[3];\n\t\t\ta2 ^= b2;\n\n\t\t\tpg_dst[0] = a0;\n\t\t\ta3 ^= b3;\n\t\t\tpg_dst[1] = a1;\n\t\t\tpg_c += 4;\n\t\t\tpg_dst[2] = a2;\n\t\t\tpg_dst[3] = a3;\n\t\t\tpg_dst += 4;\n\t\t}\n\t\twhile (longs_this_time > 0) {\t/* cannot cross any page\n\t\t\t\t\t\t * boundaries here */\n\t\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\t\tlongs_this_time--;\n\t\t}\n\n\t\tif (len) {\n\t\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\t\tif (!pg_a)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t\tif (dst_is_a)\n\t\t\t\t\tpg_dst = pg_a;\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\t\tif (!pg_b)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\t\tif (!pg_c)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (!dst_is_a)\n\t\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\t\tif (!pg_dst)\n\t\t\t\t\t\treturn (EFAULT);\n\t\t\t\t}\n\t\t}\n\t}\n\twhile (len) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t\tif (dst_is_a)\n\t\t\t\tpg_dst = pg_a;\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (!dst_is_a)\n\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\tif (!pg_dst)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\tlen--;\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_longword_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned long *dst;\n\tregister unsigned long *a;\n\tregister unsigned long *b;\n\tregister unsigned long *c;\n\tint     len;\t\t/* length in longwords */\n\tvoid   *bp;\n{\n\tunsigned long a0, a1, a2, a3, b0, b1, b2, b3;\n\tregister unsigned long *pg_a, *pg_b, *pg_c, *pg_dst;\t/* per-page source/dest\n\t\t\t\t\t\t\t\t * pointers */\n\tint     longs_this_time;/* # longs to xor in the current iteration */\n\tchar    dst_is_a = 0;\n\n\tREMAP_VA(bp, a, pg_a);\n\tREMAP_VA(bp, b, pg_b);\n\tREMAP_VA(bp, c, pg_c);\n\tif (a == dst) {\n\t\tpg_dst = pg_a;\n\t\tdst_is_a = 1;\n\t} else {\n\t\tREMAP_VA(bp, dst, pg_dst);\n\t}\n\n\t/* align dest to cache line.  Can't cross a pg boundary on dst here. */\n\twhile ((((unsigned long) pg_dst) & 0x1f)) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, a, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, a, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tlen--;\n\t}\n\n\twhile (len > 4) {\n\t\tlongs_this_time = RF_MIN(len, RF_MIN(RF_BLIP(a), RF_MIN(RF_BLIP(b), RF_MIN(RF_BLIP(c), RF_BLIP(dst)))) >> RF_LONGSHIFT);\n\t\ta += longs_this_time;\n\t\tb += longs_this_time;\n\t\tc += longs_this_time;\n\t\tdst += longs_this_time;\n\t\tlen -= longs_this_time;\n\t\twhile (longs_this_time >= 4) {\n\t\t\ta0 = pg_a[0];\n\t\t\tlongs_this_time -= 4;\n\n\t\t\ta1 = pg_a[1];\n\t\t\ta2 = pg_a[2];\n\n\t\t\ta3 = pg_a[3];\n\t\t\tpg_a += 4;\n\n\t\t\tb0 = pg_b[0];\n\t\t\tb1 = pg_b[1];\n\n\t\t\tb2 = pg_b[2];\n\t\t\tb3 = pg_b[3];\n\t\t\t/* start dual issue */\n\t\t\ta0 ^= b0;\n\t\t\tb0 = pg_c[0];\n\n\t\t\tpg_b += 4;\n\t\t\ta1 ^= b1;\n\n\t\t\ta2 ^= b2;\n\t\t\ta3 ^= b3;\n\n\t\t\tb1 = pg_c[1];\n\t\t\ta0 ^= b0;\n\n\t\t\tb2 = pg_c[2];\n\t\t\ta1 ^= b1;\n\n\t\t\tb3 = pg_c[3];\n\t\t\ta2 ^= b2;\n\n\t\t\tpg_dst[0] = a0;\n\t\t\ta3 ^= b3;\n\t\t\tpg_dst[1] = a1;\n\t\t\tpg_c += 4;\n\t\t\tpg_dst[2] = a2;\n\t\t\tpg_dst[3] = a3;\n\t\t\tpg_dst += 4;\n\t\t}\n\t\twhile (longs_this_time > 0) {\t/* cannot cross any page\n\t\t\t\t\t\t * boundaries here */\n\t\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\t\tlongs_this_time--;\n\t\t}\n\n\t\tif (len) {\n\t\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\t\tif (!pg_a)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t\tif (dst_is_a)\n\t\t\t\t\tpg_dst = pg_a;\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\t\tif (!pg_b)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\t\tif (!pg_c)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\t\tif (!dst_is_a)\n\t\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\t\tif (!pg_dst)\n\t\t\t\t\t\treturn (EFAULT);\n\t\t\t\t}\n\t\t}\n\t}\n\twhile (len) {\n\t\t*pg_dst++ = *pg_a++ ^ *pg_b++ ^ *pg_c++;\n\t\tdst++;\n\t\ta++;\n\t\tb++;\n\t\tc++;\n\t\tif (RF_PAGE_ALIGNED(a)) {\n\t\t\tREMAP_VA(bp, a, pg_a);\n\t\t\tif (!pg_a)\n\t\t\t\treturn (EFAULT);\n\t\t\tif (dst_is_a)\n\t\t\t\tpg_dst = pg_a;\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(b)) {\n\t\t\tREMAP_VA(bp, b, pg_b);\n\t\t\tif (!pg_b)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (RF_PAGE_ALIGNED(c)) {\n\t\t\tREMAP_VA(bp, c, pg_c);\n\t\t\tif (!pg_c)\n\t\t\t\treturn (EFAULT);\n\t\t}\n\t\tif (!dst_is_a)\n\t\t\tif (RF_PAGE_ALIGNED(dst)) {\n\t\t\t\tREMAP_VA(bp, dst, pg_dst);\n\t\t\t\tif (!pg_dst)\n\t\t\t\t\treturn (EFAULT);\n\t\t\t}\n\t\tlen--;\n\t}\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor(src, dest, len, bp)\n\tchar   *src;\n\tchar   *dest;\n\tint     len;\n\tvoid   *bp;\n{\n\tunsigned mask = sizeof(long) - 1, retcode = 0;\n\n\tif (!(((unsigned long) src) & mask) && !(((unsigned long) dest) & mask) && !(len & mask)) {\n\t\tretcode = rf_longword_bxor((unsigned long *) src, (unsigned long *) dest, len >> RF_LONGSHIFT, bp);\n\t} else {\n\t\tRF_ASSERT(0);\n\t}\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_XorIntoBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "588-607",
    "snippet": "int \nrf_XorIntoBuffer(raidPtr, pda, srcbuf, targbuf, bp)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *srcbuf;\n\tchar   *targbuf;\n\tvoid   *bp;\n{\n\tchar   *targptr;\n\tint     sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     SUOffset = pda->startSector % sectPerSU;\n\tint     length, retcode = 0;\n\n\tRF_ASSERT(pda->numSector <= sectPerSU);\n\n\ttargptr = targbuf + rf_RaidAddressToByte(raidPtr, SUOffset);\n\tlength = rf_RaidAddressToByte(raidPtr, pda->numSector);\n\tretcode = rf_bxor(srcbuf, targptr, length, bp);\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_bxor",
          "args": [
            "srcbuf",
            "targptr",
            "length",
            "bp"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "rf_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "880-893",
          "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "pda->numSector"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "SUOffset"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pda->numSector <= sectPerSU"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_XorIntoBuffer(raidPtr, pda, srcbuf, targbuf, bp)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *srcbuf;\n\tchar   *targbuf;\n\tvoid   *bp;\n{\n\tchar   *targptr;\n\tint     sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     SUOffset = pda->startSector % sectPerSU;\n\tint     length, retcode = 0;\n\n\tRF_ASSERT(pda->numSector <= sectPerSU);\n\n\ttargptr = targbuf + rf_RaidAddressToByte(raidPtr, SUOffset);\n\tlength = rf_RaidAddressToByte(raidPtr, pda->numSector);\n\tretcode = rf_bxor(srcbuf, targptr, length, bp);\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_RecoveryXorFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "545-574",
    "snippet": "int \nrf_RecoveryXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tint     i, retcode = 0;\n\tRF_PhysDiskAddr_t *pda;\n\tint     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 2; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\t\t\tretcode = rf_bxor(srcbuf, destbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "retcode"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_bxor",
          "args": [
            "srcbuf",
            "destbuf",
            "rf_RaidAddressToByte(raidPtr, pda->numSector)",
            "node->dagHdr->bp"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "rf_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "880-893",
          "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "pda->numSector"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "suoffset - failedSUOffset"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda->startSector"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "failedPDA->startSector"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_RecoveryXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tint     i, retcode = 0;\n\tRF_PhysDiskAddr_t *pda;\n\tint     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 2; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\t\t\tretcode = rf_bxor(srcbuf, destbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\n}"
  },
  {
    "function_name": "rf_SimpleXorFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "512-537",
    "snippet": "int \nrf_SimpleXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tint     i, retcode = 0;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_bxor((char *) node->params[i + 1].p, (char *) node->results[0],\n\t\t\t\t    rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[i].p)->numSector),\n\t\t\t\t    (struct buf *) node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "retcode"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_bxor",
          "args": [
            "(char *) node->params[i + 1].p",
            "(char *) node->results[0]",
            "rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[i].p)->numSector)",
            "(struct buf *) node->dagHdr->bp"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "rf_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "880-893",
          "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "((RF_PhysDiskAddr_t *) node->params[i].p)->numSector"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_SimpleXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tint     i, retcode = 0;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_bxor((char *) node->params[i + 1].p, (char *) node->results[0],\n\t\t\t\t    rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[i].p)->numSector),\n\t\t\t\t    (struct buf *) node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}"
  },
  {
    "function_name": "rf_RegularXorFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "485-510",
    "snippet": "int \nrf_RegularXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tint     i, retcode;\n\n\tretcode = 0;\n\tif (node->dagHdr->status == rf_enable) {\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,\n\t\t\t\t    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "retcode"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_XorIntoBuffer",
          "args": [
            "raidPtr",
            "(RF_PhysDiskAddr_t *) node->params[i].p",
            "(char *) node->params[i + 1].p",
            "(char *) node->results[0]",
            "node->dagHdr->bp"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "rf_XorIntoBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "588-607",
          "snippet": "int \nrf_XorIntoBuffer(raidPtr, pda, srcbuf, targbuf, bp)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *srcbuf;\n\tchar   *targbuf;\n\tvoid   *bp;\n{\n\tchar   *targptr;\n\tint     sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     SUOffset = pda->startSector % sectPerSU;\n\tint     length, retcode = 0;\n\n\tRF_ASSERT(pda->numSector <= sectPerSU);\n\n\ttargptr = targbuf + rf_RaidAddressToByte(raidPtr, SUOffset);\n\tlength = rf_RaidAddressToByte(raidPtr, pda->numSector);\n\tretcode = rf_bxor(srcbuf, targptr, length, bp);\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_XorIntoBuffer(raidPtr, pda, srcbuf, targbuf, bp)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *srcbuf;\n\tchar   *targbuf;\n\tvoid   *bp;\n{\n\tchar   *targptr;\n\tint     sectPerSU = raidPtr->Layout.sectorsPerStripeUnit;\n\tint     SUOffset = pda->startSector % sectPerSU;\n\tint     length, retcode = 0;\n\n\tRF_ASSERT(pda->numSector <= sectPerSU);\n\n\ttargptr = targbuf + rf_RaidAddressToByte(raidPtr, SUOffset);\n\tlength = rf_RaidAddressToByte(raidPtr, pda->numSector);\n\tretcode = rf_bxor(srcbuf, targptr, length, bp);\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_RegularXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tint     i, retcode;\n\n\tretcode = 0;\n\tif (node->dagHdr->status == rf_enable) {\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,\n\t\t\t\t    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}"
  },
  {
    "function_name": "rf_GenericWakeupFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "425-460",
    "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FinishNode",
          "args": [
            "node",
            "RF_INTR_CONTEXT"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FinishNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "642-653",
          "snippet": "int \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeDiskQueueData",
          "args": [
            "(RF_DiskQueueData_t *) node->dagFuncData"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "596-601",
          "snippet": "void \nrf_FreeDiskQueueData(p)\n\tRF_DiskQueueData_t *p;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, clean_dqd);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nvoid \nrf_FreeDiskQueueData(p)\n\tRF_DiskQueueData_t *p;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_dqd_freelist, p, next, clean_dqd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"status is %d \\n\"",
            "status"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_DiskWriteFuncForThreads",
          "args": [
            "node"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskWriteFuncForThreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "323-363",
          "snippet": "int \nrf_DiskWriteFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;\n\tunsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);\n\tunsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\tunsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\tunsigned which_ru = RF_EXTRACT_RU(node->params[3].v);\n\tRF_DiskQueueDataFlags_t flags = 0;\n\tRF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_WRITE : RF_IO_TYPE_NOP;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\tvoid   *b_proc = NULL;\n\n\tif (node->dagHdr->bp)\n\t\tb_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;\n\n\t/* normal processing (rollaway or forward recovery) begins here */\n\tRF_ASSERT(!(lock && unlock));\n\tflags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;\n\tflags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;\n\treq = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,\n\t    buf, parityStripeID, which_ru,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    (void *) node, NULL,\n\t    node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr),\n\t    flags, b_proc);\n\n\tif (!req) {\n\t\t(node->wakeFunc) (node, ENOMEM);\n\t} else {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_DiskWriteFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;\n\tunsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);\n\tunsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\tunsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\tunsigned which_ru = RF_EXTRACT_RU(node->params[3].v);\n\tRF_DiskQueueDataFlags_t flags = 0;\n\tRF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_WRITE : RF_IO_TYPE_NOP;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\tvoid   *b_proc = NULL;\n\n\tif (node->dagHdr->bp)\n\t\tb_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;\n\n\t/* normal processing (rollaway or forward recovery) begins here */\n\tRF_ASSERT(!(lock && unlock));\n\tflags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;\n\tflags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;\n\treq = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,\n\t    buf, parityStripeID, which_ru,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    (void *) node, NULL,\n\t    node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr),\n\t    flags, b_proc);\n\n\tif (!req) {\n\t\t(node->wakeFunc) (node, ENOMEM);\n\t} else {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);\n\t}\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
  },
  {
    "function_name": "rf_DiskUnlockFuncForThreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "396-419",
    "snippet": "int \nrf_DiskUnlockFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_NOP,\n\t    0L, 0, NULL, 0L, 0,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    (void *) node,\n\t    NULL, node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr),\n\t    RF_UNLOCK_DISK_QUEUE, NULL);\n\tif (!req)\n\t\t(node->wakeFunc) (node, ENOMEM);\n\telse {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, RF_IO_NORMAL_PRIORITY);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_DiskIOEnqueue",
          "args": [
            "&(dqs[pda->row][pda->col])",
            "req",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "350-404",
          "snippet": "void \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "node",
            "ENOMEM"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CreateDiskQueueData",
          "args": [
            "RF_IO_TYPE_NOP",
            "0L",
            "0",
            "NULL",
            "0L",
            "0",
            "(int (*) (void *, int)) node->wakeFunc",
            "(void *) node",
            "NULL",
            "node->dagHdr->tracerec",
            "(void *) (node->dagHdr->raidPtr)",
            "RF_UNLOCK_DISK_QUEUE",
            "NULL"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "515-552",
          "snippet": "RF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nRF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_DiskUnlockFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_NOP,\n\t    0L, 0, NULL, 0L, 0,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    (void *) node,\n\t    NULL, node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr),\n\t    RF_UNLOCK_DISK_QUEUE, NULL);\n\tif (!req)\n\t\t(node->wakeFunc) (node, ENOMEM);\n\telse {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, RF_IO_NORMAL_PRIORITY);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_DiskUndoFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "369-392",
    "snippet": "int \nrf_DiskUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_NOP,\n\t    0L, 0, NULL, 0L, 0,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    (void *) node,\n\t    NULL, node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr),\n\t    RF_UNLOCK_DISK_QUEUE, NULL);\n\tif (!req)\n\t\t(node->wakeFunc) (node, ENOMEM);\n\telse {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, RF_IO_NORMAL_PRIORITY);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_DiskIOEnqueue",
          "args": [
            "&(dqs[pda->row][pda->col])",
            "req",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "350-404",
          "snippet": "void \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "node",
            "ENOMEM"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CreateDiskQueueData",
          "args": [
            "RF_IO_TYPE_NOP",
            "0L",
            "0",
            "NULL",
            "0L",
            "0",
            "(int (*) (void *, int)) node->wakeFunc",
            "(void *) node",
            "NULL",
            "node->dagHdr->tracerec",
            "(void *) (node->dagHdr->raidPtr)",
            "RF_UNLOCK_DISK_QUEUE",
            "NULL"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "515-552",
          "snippet": "RF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nRF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_DiskUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\n\treq = rf_CreateDiskQueueData(RF_IO_TYPE_NOP,\n\t    0L, 0, NULL, 0L, 0,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    (void *) node,\n\t    NULL, node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr),\n\t    RF_UNLOCK_DISK_QUEUE, NULL);\n\tif (!req)\n\t\t(node->wakeFunc) (node, ENOMEM);\n\telse {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, RF_IO_NORMAL_PRIORITY);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_DiskWriteFuncForThreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "323-363",
    "snippet": "int \nrf_DiskWriteFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;\n\tunsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);\n\tunsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\tunsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\tunsigned which_ru = RF_EXTRACT_RU(node->params[3].v);\n\tRF_DiskQueueDataFlags_t flags = 0;\n\tRF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_WRITE : RF_IO_TYPE_NOP;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\tvoid   *b_proc = NULL;\n\n\tif (node->dagHdr->bp)\n\t\tb_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;\n\n\t/* normal processing (rollaway or forward recovery) begins here */\n\tRF_ASSERT(!(lock && unlock));\n\tflags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;\n\tflags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;\n\treq = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,\n\t    buf, parityStripeID, which_ru,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    (void *) node, NULL,\n\t    node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr),\n\t    flags, b_proc);\n\n\tif (!req) {\n\t\t(node->wakeFunc) (node, ENOMEM);\n\t} else {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_DiskIOEnqueue",
          "args": [
            "&(dqs[pda->row][pda->col])",
            "req",
            "priority"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "350-404",
          "snippet": "void \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "node",
            "ENOMEM"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CreateDiskQueueData",
          "args": [
            "iotype",
            "pda->startSector",
            "pda->numSector",
            "buf",
            "parityStripeID",
            "which_ru",
            "(int (*) (void *, int)) node->wakeFunc",
            "(void *) node",
            "NULL",
            "node->dagHdr->tracerec",
            "(void *) (node->dagHdr->raidPtr)",
            "flags",
            "b_proc"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "515-552",
          "snippet": "RF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nRF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!(lock && unlock)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_RU",
          "args": [
            "node->params[3].v"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_UNLOCK_FLAG",
          "args": [
            "node->params[3].v"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_LOCK_FLAG",
          "args": [
            "node->params[3].v"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_PRIORITY",
          "args": [
            "node->params[3].v"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_DiskWriteFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;\n\tunsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);\n\tunsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\tunsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\tunsigned which_ru = RF_EXTRACT_RU(node->params[3].v);\n\tRF_DiskQueueDataFlags_t flags = 0;\n\tRF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_WRITE : RF_IO_TYPE_NOP;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\tvoid   *b_proc = NULL;\n\n\tif (node->dagHdr->bp)\n\t\tb_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;\n\n\t/* normal processing (rollaway or forward recovery) begins here */\n\tRF_ASSERT(!(lock && unlock));\n\tflags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;\n\tflags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;\n\treq = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,\n\t    buf, parityStripeID, which_ru,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    (void *) node, NULL,\n\t    node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr),\n\t    flags, b_proc);\n\n\tif (!req) {\n\t\t(node->wakeFunc) (node, ENOMEM);\n\t} else {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_DiskReadFuncForThreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "281-317",
    "snippet": "int \nrf_DiskReadFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;\n\tunsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);\n\tunsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\tunsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\tunsigned which_ru = RF_EXTRACT_RU(node->params[3].v);\n\tRF_DiskQueueDataFlags_t flags = 0;\n\tRF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_READ : RF_IO_TYPE_NOP;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\tvoid   *b_proc = NULL;\n\n\tif (node->dagHdr->bp)\n\t\tb_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;\n\n\tRF_ASSERT(!(lock && unlock));\n\tflags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;\n\tflags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;\n\n\treq = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,\n\t    buf, parityStripeID, which_ru,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    node, NULL, node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr), flags, b_proc);\n\tif (!req) {\n\t\t(node->wakeFunc) (node, ENOMEM);\n\t} else {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_DiskIOEnqueue",
          "args": [
            "&(dqs[pda->row][pda->col])",
            "req",
            "priority"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskIOEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "350-404",
          "snippet": "void \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\n\nvoid \nrf_DiskIOEnqueue(queue, req, pri)\n\tRF_DiskQueue_t *queue;\n\tRF_DiskQueueData_t *req;\n\tint     pri;\n{\n\tRF_ETIMER_START(req->qtime);\n\tRF_ASSERT(req->type == RF_IO_TYPE_NOP || req->numSector);\n\treq->priority = pri;\n\n\tif (rf_queueDebug && (req->numSector == 0)) {\n\t\tprintf(\"Warning: Enqueueing zero-sector access\\n\");\n\t}\n\t/*\n         * kernel\n         */\n\tRF_LOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n\t/* locking request */\n\tif (RF_LOCKING_REQ(req)) {\n\t\tif (RF_QUEUE_EMPTY(queue)) {\n\t\t\tDprintf3(\"Dispatching pri %d locking op to r %d c %d (queue empty)\\n\", pri, queue->row, queue->col);\n\t\t\tRF_LOCK_QUEUE(queue);\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t} else {\n\t\t\tqueue->queueLength++;\t/* increment count of number\n\t\t\t\t\t\t * of requests waiting in this\n\t\t\t\t\t\t * queue */\n\t\t\tDprintf3(\"Enqueueing pri %d locking op to r %d c %d (queue not empty)\\n\", pri, queue->row, queue->col);\n\t\t\treq->queue = (void *) queue;\n\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t}\n\t}\n\t/* unlocking request */\n\telse\n\t\tif (RF_UNLOCKING_REQ(req)) {\t/* we'll do the actual unlock\n\t\t\t\t\t\t * when this I/O completes */\n\t\t\tDprintf3(\"Dispatching pri %d unlocking op to r %d c %d\\n\", pri, queue->row, queue->col);\n\t\t\tRF_ASSERT(RF_QUEUE_LOCKED(queue));\n\t\t\trf_DispatchKernelIO(queue, req);\n\t\t}\n\t/* normal request */\n\t\telse\n\t\t\tif (RF_OK_TO_DISPATCH(queue, req)) {\n\t\t\t\tDprintf3(\"Dispatching pri %d regular op to r %d c %d (ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\trf_DispatchKernelIO(queue, req);\n\t\t\t} else {\n\t\t\t\tqueue->queueLength++;\t/* increment count of\n\t\t\t\t\t\t\t * number of requests\n\t\t\t\t\t\t\t * waiting in this queue */\n\t\t\t\tDprintf3(\"Enqueueing pri %d regular op to r %d c %d (not ok to dispatch)\\n\", pri, queue->row, queue->col);\n\t\t\t\treq->queue = (void *) queue;\n\t\t\t\t(queue->qPtr->Enqueue) (queue->qHdr, req, pri);\n\t\t\t}\n\tRF_UNLOCK_QUEUE_MUTEX(queue, \"DiskIOEnqueue\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "node",
            "ENOMEM"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CreateDiskQueueData",
          "args": [
            "iotype",
            "pda->startSector",
            "pda->numSector",
            "buf",
            "parityStripeID",
            "which_ru",
            "(int (*) (void *, int)) node->wakeFunc",
            "node",
            "NULL",
            "node->dagHdr->tracerec",
            "(void *) (node->dagHdr->raidPtr)",
            "flags",
            "b_proc"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateDiskQueueData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_diskqueue.c",
          "lines": "515-552",
          "snippet": "RF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}",
          "includes": [
            "#include <sys/buf.h>",
            "#include \"rf_fifo.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_cvscan.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_dqd(RF_DiskQueueData_t *);",
            "static void clean_dqd(RF_DiskQueueData_t *);",
            "int     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);",
            "static RF_FreeList_t *rf_dqd_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/buf.h>\n#include \"rf_fifo.h\"\n#include \"rf_sstf.h\"\n#include \"rf_cvscan.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_configure.h\"\n#include \"rf_etimer.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic int init_dqd(RF_DiskQueueData_t *);\nstatic void clean_dqd(RF_DiskQueueData_t *);\nint     rf_DispatchKernelIO(RF_DiskQueue_t *, RF_DiskQueueData_t *);\nstatic RF_FreeList_t *rf_dqd_freelist;\n\nRF_DiskQueueData_t *\nrf_CreateDiskQueueData(\n    RF_IoType_t typ,\n    RF_SectorNum_t ssect,\n    RF_SectorCount_t nsect,\n    caddr_t buf,\n    RF_StripeNum_t parityStripeID,\n    RF_ReconUnitNum_t which_ru,\n    int (*wakeF) (void *, int),\n    void *arg,\n    RF_DiskQueueData_t * next,\n    RF_AccTraceEntry_t * tracerec,\n    void *raidPtr,\n    RF_DiskQueueDataFlags_t flags,\n    void *kb_proc)\n{\n\tRF_DiskQueueData_t *p;\n\n\tRF_FREELIST_GET_INIT(rf_dqd_freelist, p, next, (RF_DiskQueueData_t *), init_dqd);\n\n\tp->sectorOffset = ssect + rf_protectedSectors;\n\tp->numSector = nsect;\n\tp->type = typ;\n\tp->buf = buf;\n\tp->parityStripeID = parityStripeID;\n\tp->which_ru = which_ru;\n\tp->CompleteFunc = wakeF;\n\tp->argument = arg;\n\tp->next = next;\n\tp->tracerec = tracerec;\n\tp->priority = RF_IO_NORMAL_PRIORITY;\n\tp->AuxFunc = NULL;\n\tp->buf2 = NULL;\n\tp->raidPtr = raidPtr;\n\tp->flags = flags;\n\tp->b_proc = kb_proc;\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!(lock && unlock)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_RU",
          "args": [
            "node->params[3].v"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_UNLOCK_FLAG",
          "args": [
            "node->params[3].v"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_LOCK_FLAG",
          "args": [
            "node->params[3].v"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_EXTRACT_PRIORITY",
          "args": [
            "node->params[3].v"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_DiskReadFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;\n\tunsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);\n\tunsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\tunsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\tunsigned which_ru = RF_EXTRACT_RU(node->params[3].v);\n\tRF_DiskQueueDataFlags_t flags = 0;\n\tRF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_READ : RF_IO_TYPE_NOP;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\tvoid   *b_proc = NULL;\n\n\tif (node->dagHdr->bp)\n\t\tb_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;\n\n\tRF_ASSERT(!(lock && unlock));\n\tflags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;\n\tflags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;\n\n\treq = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,\n\t    buf, parityStripeID, which_ru,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    node, NULL, node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr), flags, b_proc);\n\tif (!req) {\n\t\t(node->wakeFunc) (node, ENOMEM);\n\t} else {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_NullNodeUndoFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "269-275",
    "snippet": "int \nrf_NullNodeUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\tnode->status = rf_undone;\n\treturn (rf_FinishNode(node, RF_THREAD_CONTEXT));\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FinishNode",
          "args": [
            "node",
            "RF_THREAD_CONTEXT"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FinishNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "642-653",
          "snippet": "int \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_NullNodeUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\tnode->status = rf_undone;\n\treturn (rf_FinishNode(node, RF_THREAD_CONTEXT));\n}"
  },
  {
    "function_name": "rf_NullNodeFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "261-267",
    "snippet": "int \nrf_NullNodeFunc(node)\n\tRF_DagNode_t *node;\n{\n\tnode->status = rf_good;\n\treturn (rf_FinishNode(node, RF_THREAD_CONTEXT));\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FinishNode",
          "args": [
            "node",
            "RF_THREAD_CONTEXT"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FinishNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "642-653",
          "snippet": "int \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_NullNodeFunc(node)\n\tRF_DagNode_t *node;\n{\n\tnode->status = rf_good;\n\treturn (rf_FinishNode(node, RF_THREAD_CONTEXT));\n}"
  },
  {
    "function_name": "rf_ParityLogOverwriteUndoFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "252-257",
    "snippet": "int \nrf_ParityLogOverwriteUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_ParityLogOverwriteUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ParityLogUpdateUndoFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "245-250",
    "snippet": "int \nrf_ParityLogUpdateUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_ParityLogUpdateUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ParityLogOverwriteFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "237-242",
    "snippet": "int \nrf_ParityLogOverwriteFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_ParityLogOverwriteFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ParityLogUpdateFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "231-236",
    "snippet": "int \nrf_ParityLogUpdateFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_ParityLogUpdateFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ParityLogOverwriteFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "204-228",
    "snippet": "int \nrf_ParityLogOverwriteFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_ParityLogData_t *logData;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tlogData = rf_CreateParityLogData(RF_OVERWRITE, pda, buf, (RF_Raid_t *) (node->dagHdr->raidPtr),\n\t\t    node->wakeFunc, (void *) node, node->dagHdr->tracerec, timer);\n\t\tif (logData)\n\t\t\trf_ParityLogAppend(logData, RF_FALSE, NULL, RF_FALSE);\n\t\telse {\n\t\t\tRF_ETIMER_STOP(timer);\n\t\t\tRF_ETIMER_EVAL(timer);\n\t\t\ttracerec->plog_us += RF_ETIMER_VAL_US(timer);\n\t\t\t(node->wakeFunc) (node, ENOMEM);\n\t\t}\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "node",
            "ENOMEM"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ParityLogAppend",
          "args": [
            "logData",
            "RF_FALSE",
            "NULL",
            "RF_FALSE"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ParityLogAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylog.c",
          "lines": "660-853",
          "snippet": "int \nrf_ParityLogAppend(\n    RF_ParityLogData_t * logData,\n    int finish,\n    RF_ParityLog_t ** incomingLog,\n    int clearReintFlag)\n{\n\tint     regionID, logItem, itemDone;\n\tRF_ParityLogData_t *item;\n\tint     punt, done = RF_FALSE;\n\tRF_ParityLog_t *log;\n\tRF_Raid_t *raidPtr;\n\tRF_Etimer_t timer;\n\tint     (*wakeFunc) (RF_DagNode_t * node, int status);\n\tvoid   *wakeArg;\n\n\t/* Add parity to the appropriate log, one sector at a time. This\n\t * routine is called is called by dag functions ParityLogUpdateFunc\n\t * and ParityLogOverwriteFunc and therefore MUST BE NONBLOCKING.\n\t * \n\t * Parity to be logged is contained in a linked-list (logData).  When\n\t * this routine returns, every sector in the list will be in one of\n\t * three places: 1) entered into the parity log 2) queued, waiting on\n\t * reintegration 3) queued, waiting on a core log\n\t * \n\t * Blocked work is passed to the ParityLoggingDiskManager for completion.\n\t * Later, as conditions which required the block are removed, the work\n\t * reenters this routine with the \"finish\" parameter set to \"RF_TRUE.\"\n\t * \n\t * NON-BLOCKING */\n\n\traidPtr = logData->common->raidPtr;\n\t/* lock the region for the first item in logData */\n\tRF_ASSERT(logData != NULL);\n\tregionID = logData->regionID;\n\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tRF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);\n\n\tif (clearReintFlag) {\n\t\t/* Enable flushing for this region.  Holding both locks\n\t\t * provides a synchronization barrier with DumpParityLogToDisk */\n\t\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);\n\t\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].reintInProgress == RF_TRUE);\n\t\traidPtr->regionInfo[regionID].diskCount = 0;\n\t\traidPtr->regionInfo[regionID].reintInProgress = RF_FALSE;\n\t\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);\t/* flushing is now\n\t\t\t\t\t\t\t\t\t\t * enabled */\n\t\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t}\n\t/* process each item in logData */\n\twhile (logData) {\n\t\t/* remove an item from logData */\n\t\titem = logData;\n\t\tlogData = logData->next;\n\t\titem->next = NULL;\n\t\titem->prev = NULL;\n\n\t\tif (rf_parityLogDebug)\n\t\t\tprintf(\"[appending parity log data, region %d, raidAddress %d, numSector %d]\\n\", item->regionID, (int) item->diskAddress.raidAddress, (int) item->diskAddress.numSector);\n\n\t\t/* see if we moved to a new region */\n\t\tif (regionID != item->regionID) {\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t\t\tregionID = item->regionID;\n\t\t\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);\n\t\t}\n\t\tpunt = RF_FALSE;/* Set to RF_TRUE if work is blocked.  This\n\t\t\t\t * can happen in one of two ways: 1) no core\n\t\t\t\t * log (AcquireParityLog) 2) waiting on\n\t\t\t\t * reintegration (DumpParityLogToDisk) If punt\n\t\t\t\t * is RF_TRUE, the dataItem was queued, so\n\t\t\t\t * skip to next item. */\n\n\t\t/* process item, one sector at a time, until all sectors\n\t\t * processed or we punt */\n\t\tif (item->diskAddress.numSector > 0)\n\t\t\tdone = RF_FALSE;\n\t\telse\n\t\t\tRF_ASSERT(0);\n\t\twhile (!punt && !done) {\n\t\t\t/* verify that a core log exists for this region */\n\t\t\tif (!raidPtr->regionInfo[regionID].coreLog) {\n\t\t\t\t/* Attempt to acquire a parity log. If\n\t\t\t\t * acquisition fails, queue remaining work in\n\t\t\t\t * data item and move to nextItem. */\n\t\t\t\tif (incomingLog) {\n\t\t\t\t\tif (*incomingLog) {\n\t\t\t\t\t\tRF_ASSERT((*incomingLog)->next == NULL);\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = *incomingLog;\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog->regionID = regionID;\n\t\t\t\t\t\t*incomingLog = NULL;\n\t\t\t\t\t} else\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t} else\n\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t/* Note: AcquireParityLog either returns a log\n\t\t\t\t * or enqueues currentItem */\n\t\t\t}\n\t\t\tif (!raidPtr->regionInfo[regionID].coreLog)\n\t\t\t\tpunt = RF_TRUE;\t/* failed to find a core log */\n\t\t\telse {\n\t\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);\n\t\t\t\t/* verify that the log has room for new\n\t\t\t\t * entries */\n\t\t\t\t/* if log is full, dump it to disk and grab a\n\t\t\t\t * new log */\n\t\t\t\tif (raidPtr->regionInfo[regionID].coreLog->numRecords == raidPtr->numSectorsPerLog) {\n\t\t\t\t\t/* log is full, dump it to disk */\n\t\t\t\t\tif (DumpParityLogToDisk(finish, item))\n\t\t\t\t\t\tpunt = RF_TRUE;\t/* dump unsuccessful,\n\t\t\t\t\t\t\t\t * blocked on\n\t\t\t\t\t\t\t\t * reintegration */\n\t\t\t\t\telse {\n\t\t\t\t\t\t/* dump was successful */\n\t\t\t\t\t  if (incomingLog) {\n\t\t\t\t\t\t\tif (*incomingLog) {\n\t\t\t\t\t\t\t\tRF_ASSERT((*incomingLog)->next == NULL);\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = *incomingLog;\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog->regionID = regionID;\n\t\t\t\t\t\t\t\t*incomingLog = NULL;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t\t\t/* if a core log is not\n\t\t\t\t\t\t * available, must queue work\n\t\t\t\t\t\t * and return */\n\t\t\t\t\t\tif (!raidPtr->regionInfo[regionID].coreLog)\n\t\t\t\t\t\t\tpunt = RF_TRUE;\t/* blocked on log\n\t\t\t\t\t\t\t\t\t * availability */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if we didn't punt on this item, attempt to add a\n\t\t\t * sector to the core log */\n\t\t\tif (!punt) {\n\t\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);\n\t\t\t\t/* at this point, we have a core log with\n\t\t\t\t * enough room for a sector */\n\t\t\t\t/* copy a sector into the log */\n\t\t\t\tlog = raidPtr->regionInfo[regionID].coreLog;\n\t\t\t\tRF_ASSERT(log->numRecords < raidPtr->numSectorsPerLog);\n\t\t\t\tlogItem = log->numRecords++;\n\t\t\t\tlog->records[logItem].parityAddr = item->diskAddress;\n\t\t\t\tRF_ASSERT(log->records[logItem].parityAddr.startSector >= raidPtr->regionInfo[regionID].parityStartAddr);\n\t\t\t\tRF_ASSERT(log->records[logItem].parityAddr.startSector < raidPtr->regionInfo[regionID].parityStartAddr + raidPtr->regionInfo[regionID].numSectorsParity);\n\t\t\t\tlog->records[logItem].parityAddr.numSector = 1;\n\t\t\t\tlog->records[logItem].operation = item->common->operation;\n\t\t\t\tbcopy((item->common->bufPtr + (item->bufOffset++ * (1 << item->common->raidPtr->logBytesPerSector))), log->bufPtr + (logItem * (1 << item->common->raidPtr->logBytesPerSector)), (1 << item->common->raidPtr->logBytesPerSector));\n\t\t\t\titem->diskAddress.numSector--;\n\t\t\t\titem->diskAddress.startSector++;\n\t\t\t\tif (item->diskAddress.numSector == 0)\n\t\t\t\t\tdone = RF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (!punt) {\n\t\t\t/* Processed this item completely, decrement count of\n\t\t\t * items to be processed. */\n\t\t\tRF_ASSERT(item->diskAddress.numSector == 0);\n\t\t\tRF_LOCK_MUTEX(item->common->mutex);\n\t\t\titem->common->cnt--;\n\t\t\tif (item->common->cnt == 0)\n\t\t\t\titemDone = RF_TRUE;\n\t\t\telse\n\t\t\t\titemDone = RF_FALSE;\n\t\t\tRF_UNLOCK_MUTEX(item->common->mutex);\n\t\t\tif (itemDone) {\n\t\t\t\t/* Finished processing all log data for this\n\t\t\t\t * IO Return structs to free list and invoke\n\t\t\t\t * wakeup function. */\n\t\t\t\ttimer = item->common->startTime;\t/* grab initial value of\n\t\t\t\t\t\t\t\t\t * timer */\n\t\t\t\tRF_ETIMER_STOP(timer);\n\t\t\t\tRF_ETIMER_EVAL(timer);\n\t\t\t\titem->common->tracerec->plog_us += RF_ETIMER_VAL_US(timer);\n\t\t\t\tif (rf_parityLogDebug)\n\t\t\t\t\tprintf(\"[waking process for region %d]\\n\", item->regionID);\n\t\t\t\twakeFunc = item->common->wakeFunc;\n\t\t\t\twakeArg = item->common->wakeArg;\n\t\t\t\tFreeParityLogCommonData(item->common);\n\t\t\t\tFreeParityLogData(item);\n\t\t\t\t(wakeFunc) (wakeArg, 0);\n\t\t\t} else\n\t\t\t\tFreeParityLogData(item);\n\t\t}\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[exiting ParityLogAppend]\\n\");\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_etimer.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_desc.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_ParityLogAppend(\n    RF_ParityLogData_t * logData,\n    int finish,\n    RF_ParityLog_t ** incomingLog,\n    int clearReintFlag)\n{\n\tint     regionID, logItem, itemDone;\n\tRF_ParityLogData_t *item;\n\tint     punt, done = RF_FALSE;\n\tRF_ParityLog_t *log;\n\tRF_Raid_t *raidPtr;\n\tRF_Etimer_t timer;\n\tint     (*wakeFunc) (RF_DagNode_t * node, int status);\n\tvoid   *wakeArg;\n\n\t/* Add parity to the appropriate log, one sector at a time. This\n\t * routine is called is called by dag functions ParityLogUpdateFunc\n\t * and ParityLogOverwriteFunc and therefore MUST BE NONBLOCKING.\n\t * \n\t * Parity to be logged is contained in a linked-list (logData).  When\n\t * this routine returns, every sector in the list will be in one of\n\t * three places: 1) entered into the parity log 2) queued, waiting on\n\t * reintegration 3) queued, waiting on a core log\n\t * \n\t * Blocked work is passed to the ParityLoggingDiskManager for completion.\n\t * Later, as conditions which required the block are removed, the work\n\t * reenters this routine with the \"finish\" parameter set to \"RF_TRUE.\"\n\t * \n\t * NON-BLOCKING */\n\n\traidPtr = logData->common->raidPtr;\n\t/* lock the region for the first item in logData */\n\tRF_ASSERT(logData != NULL);\n\tregionID = logData->regionID;\n\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tRF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);\n\n\tif (clearReintFlag) {\n\t\t/* Enable flushing for this region.  Holding both locks\n\t\t * provides a synchronization barrier with DumpParityLogToDisk */\n\t\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);\n\t\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].reintInProgress == RF_TRUE);\n\t\traidPtr->regionInfo[regionID].diskCount = 0;\n\t\traidPtr->regionInfo[regionID].reintInProgress = RF_FALSE;\n\t\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);\t/* flushing is now\n\t\t\t\t\t\t\t\t\t\t * enabled */\n\t\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t}\n\t/* process each item in logData */\n\twhile (logData) {\n\t\t/* remove an item from logData */\n\t\titem = logData;\n\t\tlogData = logData->next;\n\t\titem->next = NULL;\n\t\titem->prev = NULL;\n\n\t\tif (rf_parityLogDebug)\n\t\t\tprintf(\"[appending parity log data, region %d, raidAddress %d, numSector %d]\\n\", item->regionID, (int) item->diskAddress.raidAddress, (int) item->diskAddress.numSector);\n\n\t\t/* see if we moved to a new region */\n\t\tif (regionID != item->regionID) {\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t\t\tregionID = item->regionID;\n\t\t\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);\n\t\t}\n\t\tpunt = RF_FALSE;/* Set to RF_TRUE if work is blocked.  This\n\t\t\t\t * can happen in one of two ways: 1) no core\n\t\t\t\t * log (AcquireParityLog) 2) waiting on\n\t\t\t\t * reintegration (DumpParityLogToDisk) If punt\n\t\t\t\t * is RF_TRUE, the dataItem was queued, so\n\t\t\t\t * skip to next item. */\n\n\t\t/* process item, one sector at a time, until all sectors\n\t\t * processed or we punt */\n\t\tif (item->diskAddress.numSector > 0)\n\t\t\tdone = RF_FALSE;\n\t\telse\n\t\t\tRF_ASSERT(0);\n\t\twhile (!punt && !done) {\n\t\t\t/* verify that a core log exists for this region */\n\t\t\tif (!raidPtr->regionInfo[regionID].coreLog) {\n\t\t\t\t/* Attempt to acquire a parity log. If\n\t\t\t\t * acquisition fails, queue remaining work in\n\t\t\t\t * data item and move to nextItem. */\n\t\t\t\tif (incomingLog) {\n\t\t\t\t\tif (*incomingLog) {\n\t\t\t\t\t\tRF_ASSERT((*incomingLog)->next == NULL);\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = *incomingLog;\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog->regionID = regionID;\n\t\t\t\t\t\t*incomingLog = NULL;\n\t\t\t\t\t} else\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t} else\n\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t/* Note: AcquireParityLog either returns a log\n\t\t\t\t * or enqueues currentItem */\n\t\t\t}\n\t\t\tif (!raidPtr->regionInfo[regionID].coreLog)\n\t\t\t\tpunt = RF_TRUE;\t/* failed to find a core log */\n\t\t\telse {\n\t\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);\n\t\t\t\t/* verify that the log has room for new\n\t\t\t\t * entries */\n\t\t\t\t/* if log is full, dump it to disk and grab a\n\t\t\t\t * new log */\n\t\t\t\tif (raidPtr->regionInfo[regionID].coreLog->numRecords == raidPtr->numSectorsPerLog) {\n\t\t\t\t\t/* log is full, dump it to disk */\n\t\t\t\t\tif (DumpParityLogToDisk(finish, item))\n\t\t\t\t\t\tpunt = RF_TRUE;\t/* dump unsuccessful,\n\t\t\t\t\t\t\t\t * blocked on\n\t\t\t\t\t\t\t\t * reintegration */\n\t\t\t\t\telse {\n\t\t\t\t\t\t/* dump was successful */\n\t\t\t\t\t  if (incomingLog) {\n\t\t\t\t\t\t\tif (*incomingLog) {\n\t\t\t\t\t\t\t\tRF_ASSERT((*incomingLog)->next == NULL);\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = *incomingLog;\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog->regionID = regionID;\n\t\t\t\t\t\t\t\t*incomingLog = NULL;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t\t\t/* if a core log is not\n\t\t\t\t\t\t * available, must queue work\n\t\t\t\t\t\t * and return */\n\t\t\t\t\t\tif (!raidPtr->regionInfo[regionID].coreLog)\n\t\t\t\t\t\t\tpunt = RF_TRUE;\t/* blocked on log\n\t\t\t\t\t\t\t\t\t * availability */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if we didn't punt on this item, attempt to add a\n\t\t\t * sector to the core log */\n\t\t\tif (!punt) {\n\t\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);\n\t\t\t\t/* at this point, we have a core log with\n\t\t\t\t * enough room for a sector */\n\t\t\t\t/* copy a sector into the log */\n\t\t\t\tlog = raidPtr->regionInfo[regionID].coreLog;\n\t\t\t\tRF_ASSERT(log->numRecords < raidPtr->numSectorsPerLog);\n\t\t\t\tlogItem = log->numRecords++;\n\t\t\t\tlog->records[logItem].parityAddr = item->diskAddress;\n\t\t\t\tRF_ASSERT(log->records[logItem].parityAddr.startSector >= raidPtr->regionInfo[regionID].parityStartAddr);\n\t\t\t\tRF_ASSERT(log->records[logItem].parityAddr.startSector < raidPtr->regionInfo[regionID].parityStartAddr + raidPtr->regionInfo[regionID].numSectorsParity);\n\t\t\t\tlog->records[logItem].parityAddr.numSector = 1;\n\t\t\t\tlog->records[logItem].operation = item->common->operation;\n\t\t\t\tbcopy((item->common->bufPtr + (item->bufOffset++ * (1 << item->common->raidPtr->logBytesPerSector))), log->bufPtr + (logItem * (1 << item->common->raidPtr->logBytesPerSector)), (1 << item->common->raidPtr->logBytesPerSector));\n\t\t\t\titem->diskAddress.numSector--;\n\t\t\t\titem->diskAddress.startSector++;\n\t\t\t\tif (item->diskAddress.numSector == 0)\n\t\t\t\t\tdone = RF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (!punt) {\n\t\t\t/* Processed this item completely, decrement count of\n\t\t\t * items to be processed. */\n\t\t\tRF_ASSERT(item->diskAddress.numSector == 0);\n\t\t\tRF_LOCK_MUTEX(item->common->mutex);\n\t\t\titem->common->cnt--;\n\t\t\tif (item->common->cnt == 0)\n\t\t\t\titemDone = RF_TRUE;\n\t\t\telse\n\t\t\t\titemDone = RF_FALSE;\n\t\t\tRF_UNLOCK_MUTEX(item->common->mutex);\n\t\t\tif (itemDone) {\n\t\t\t\t/* Finished processing all log data for this\n\t\t\t\t * IO Return structs to free list and invoke\n\t\t\t\t * wakeup function. */\n\t\t\t\ttimer = item->common->startTime;\t/* grab initial value of\n\t\t\t\t\t\t\t\t\t * timer */\n\t\t\t\tRF_ETIMER_STOP(timer);\n\t\t\t\tRF_ETIMER_EVAL(timer);\n\t\t\t\titem->common->tracerec->plog_us += RF_ETIMER_VAL_US(timer);\n\t\t\t\tif (rf_parityLogDebug)\n\t\t\t\t\tprintf(\"[waking process for region %d]\\n\", item->regionID);\n\t\t\t\twakeFunc = item->common->wakeFunc;\n\t\t\t\twakeArg = item->common->wakeArg;\n\t\t\t\tFreeParityLogCommonData(item->common);\n\t\t\t\tFreeParityLogData(item);\n\t\t\t\t(wakeFunc) (wakeArg, 0);\n\t\t\t} else\n\t\t\t\tFreeParityLogData(item);\n\t\t}\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[exiting ParityLogAppend]\\n\");\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_CreateParityLogData",
          "args": [
            "RF_OVERWRITE",
            "pda",
            "buf",
            "(RF_Raid_t *) (node->dagHdr->raidPtr)",
            "node->wakeFunc",
            "(void *) node",
            "node->dagHdr->tracerec",
            "timer"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateParityLogData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylog.c",
          "lines": "262-335",
          "snippet": "RF_ParityLogData_t *\nrf_CreateParityLogData(\n    RF_ParityRecordType_t operation,\n    RF_PhysDiskAddr_t * pda,\n    caddr_t bufPtr,\n    RF_Raid_t * raidPtr,\n    int (*wakeFunc) (RF_DagNode_t * node, int status),\n    void *wakeArg,\n    RF_AccTraceEntry_t * tracerec,\n    RF_Etimer_t startTime)\n{\n\tRF_ParityLogData_t *data, *resultHead = NULL, *resultTail = NULL;\n\tRF_CommonLogData_t *common;\n\tRF_PhysDiskAddr_t *diskAddress;\n\tint     boundary, offset = 0;\n\n\t/* Return an initialized struct of info to be logged. Build one item\n\t * per physical disk address, one item per region.\n\t * \n\t * NON-BLOCKING */\n\n\tdiskAddress = pda;\n\tcommon = AllocParityLogCommonData(raidPtr);\n\tRF_ASSERT(common);\n\n\tcommon->operation = operation;\n\tcommon->bufPtr = bufPtr;\n\tcommon->raidPtr = raidPtr;\n\tcommon->wakeFunc = wakeFunc;\n\tcommon->wakeArg = wakeArg;\n\tcommon->tracerec = tracerec;\n\tcommon->startTime = startTime;\n\tcommon->cnt = 0;\n\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[entering CreateParityLogData]\\n\");\n\twhile (diskAddress) {\n\t\tcommon->cnt++;\n\t\tdata = AllocParityLogData(raidPtr);\n\t\tRF_ASSERT(data);\n\t\tdata->common = common;\n\t\tdata->next = NULL;\n\t\tdata->prev = NULL;\n\t\tdata->regionID = rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector);\n\t\tif (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + diskAddress->numSector - 1)) {\n\t\t\t/* disk address does not cross a region boundary */\n\t\t\tdata->diskAddress = *diskAddress;\n\t\t\tdata->bufOffset = offset;\n\t\t\toffset = offset + diskAddress->numSector;\n\t\t\tEnqueueParityLogData(data, &resultHead, &resultTail);\n\t\t\t/* adjust disk address */\n\t\t\tdiskAddress = diskAddress->next;\n\t\t} else {\n\t\t\t/* disk address crosses a region boundary */\n\t\t\t/* find address where region is crossed */\n\t\t\tboundary = 0;\n\t\t\twhile (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + boundary))\n\t\t\t\tboundary++;\n\n\t\t\t/* enter data before the boundary */\n\t\t\tdata->diskAddress = *diskAddress;\n\t\t\tdata->diskAddress.numSector = boundary;\n\t\t\tdata->bufOffset = offset;\n\t\t\toffset += boundary;\n\t\t\tEnqueueParityLogData(data, &resultHead, &resultTail);\n\t\t\t/* adjust disk address */\n\t\t\tdiskAddress->startSector += boundary;\n\t\t\tdiskAddress->numSector -= boundary;\n\t\t}\n\t}\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[leaving CreateParityLogData]\\n\");\n\treturn (resultHead);\n}",
          "includes": [
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_etimer.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_desc.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nRF_ParityLogData_t *\nrf_CreateParityLogData(\n    RF_ParityRecordType_t operation,\n    RF_PhysDiskAddr_t * pda,\n    caddr_t bufPtr,\n    RF_Raid_t * raidPtr,\n    int (*wakeFunc) (RF_DagNode_t * node, int status),\n    void *wakeArg,\n    RF_AccTraceEntry_t * tracerec,\n    RF_Etimer_t startTime)\n{\n\tRF_ParityLogData_t *data, *resultHead = NULL, *resultTail = NULL;\n\tRF_CommonLogData_t *common;\n\tRF_PhysDiskAddr_t *diskAddress;\n\tint     boundary, offset = 0;\n\n\t/* Return an initialized struct of info to be logged. Build one item\n\t * per physical disk address, one item per region.\n\t * \n\t * NON-BLOCKING */\n\n\tdiskAddress = pda;\n\tcommon = AllocParityLogCommonData(raidPtr);\n\tRF_ASSERT(common);\n\n\tcommon->operation = operation;\n\tcommon->bufPtr = bufPtr;\n\tcommon->raidPtr = raidPtr;\n\tcommon->wakeFunc = wakeFunc;\n\tcommon->wakeArg = wakeArg;\n\tcommon->tracerec = tracerec;\n\tcommon->startTime = startTime;\n\tcommon->cnt = 0;\n\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[entering CreateParityLogData]\\n\");\n\twhile (diskAddress) {\n\t\tcommon->cnt++;\n\t\tdata = AllocParityLogData(raidPtr);\n\t\tRF_ASSERT(data);\n\t\tdata->common = common;\n\t\tdata->next = NULL;\n\t\tdata->prev = NULL;\n\t\tdata->regionID = rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector);\n\t\tif (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + diskAddress->numSector - 1)) {\n\t\t\t/* disk address does not cross a region boundary */\n\t\t\tdata->diskAddress = *diskAddress;\n\t\t\tdata->bufOffset = offset;\n\t\t\toffset = offset + diskAddress->numSector;\n\t\t\tEnqueueParityLogData(data, &resultHead, &resultTail);\n\t\t\t/* adjust disk address */\n\t\t\tdiskAddress = diskAddress->next;\n\t\t} else {\n\t\t\t/* disk address crosses a region boundary */\n\t\t\t/* find address where region is crossed */\n\t\t\tboundary = 0;\n\t\t\twhile (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + boundary))\n\t\t\t\tboundary++;\n\n\t\t\t/* enter data before the boundary */\n\t\t\tdata->diskAddress = *diskAddress;\n\t\t\tdata->diskAddress.numSector = boundary;\n\t\t\tdata->bufOffset = offset;\n\t\t\toffset += boundary;\n\t\t\tEnqueueParityLogData(data, &resultHead, &resultTail);\n\t\t\t/* adjust disk address */\n\t\t\tdiskAddress->startSector += boundary;\n\t\t\tdiskAddress->numSector -= boundary;\n\t\t}\n\t}\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[leaving CreateParityLogData]\\n\");\n\treturn (resultHead);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_ParityLogOverwriteFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_ParityLogData_t *logData;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tlogData = rf_CreateParityLogData(RF_OVERWRITE, pda, buf, (RF_Raid_t *) (node->dagHdr->raidPtr),\n\t\t    node->wakeFunc, (void *) node, node->dagHdr->tracerec, timer);\n\t\tif (logData)\n\t\t\trf_ParityLogAppend(logData, RF_FALSE, NULL, RF_FALSE);\n\t\telse {\n\t\t\tRF_ETIMER_STOP(timer);\n\t\t\tRF_ETIMER_EVAL(timer);\n\t\t\ttracerec->plog_us += RF_ETIMER_VAL_US(timer);\n\t\t\t(node->wakeFunc) (node, ENOMEM);\n\t\t}\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ParityLogUpdateFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "172-198",
    "snippet": "int \nrf_ParityLogUpdateFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_ParityLogData_t *logData;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tlogData = rf_CreateParityLogData(RF_UPDATE, pda, buf,\n\t\t    (RF_Raid_t *) (node->dagHdr->raidPtr),\n\t\t    node->wakeFunc, (void *) node,\n\t\t    node->dagHdr->tracerec, timer);\n\t\tif (logData)\n\t\t\trf_ParityLogAppend(logData, RF_FALSE, NULL, RF_FALSE);\n\t\telse {\n\t\t\tRF_ETIMER_STOP(timer);\n\t\t\tRF_ETIMER_EVAL(timer);\n\t\t\ttracerec->plog_us += RF_ETIMER_VAL_US(timer);\n\t\t\t(node->wakeFunc) (node, ENOMEM);\n\t\t}\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "node",
            "ENOMEM"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ParityLogAppend",
          "args": [
            "logData",
            "RF_FALSE",
            "NULL",
            "RF_FALSE"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ParityLogAppend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylog.c",
          "lines": "660-853",
          "snippet": "int \nrf_ParityLogAppend(\n    RF_ParityLogData_t * logData,\n    int finish,\n    RF_ParityLog_t ** incomingLog,\n    int clearReintFlag)\n{\n\tint     regionID, logItem, itemDone;\n\tRF_ParityLogData_t *item;\n\tint     punt, done = RF_FALSE;\n\tRF_ParityLog_t *log;\n\tRF_Raid_t *raidPtr;\n\tRF_Etimer_t timer;\n\tint     (*wakeFunc) (RF_DagNode_t * node, int status);\n\tvoid   *wakeArg;\n\n\t/* Add parity to the appropriate log, one sector at a time. This\n\t * routine is called is called by dag functions ParityLogUpdateFunc\n\t * and ParityLogOverwriteFunc and therefore MUST BE NONBLOCKING.\n\t * \n\t * Parity to be logged is contained in a linked-list (logData).  When\n\t * this routine returns, every sector in the list will be in one of\n\t * three places: 1) entered into the parity log 2) queued, waiting on\n\t * reintegration 3) queued, waiting on a core log\n\t * \n\t * Blocked work is passed to the ParityLoggingDiskManager for completion.\n\t * Later, as conditions which required the block are removed, the work\n\t * reenters this routine with the \"finish\" parameter set to \"RF_TRUE.\"\n\t * \n\t * NON-BLOCKING */\n\n\traidPtr = logData->common->raidPtr;\n\t/* lock the region for the first item in logData */\n\tRF_ASSERT(logData != NULL);\n\tregionID = logData->regionID;\n\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tRF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);\n\n\tif (clearReintFlag) {\n\t\t/* Enable flushing for this region.  Holding both locks\n\t\t * provides a synchronization barrier with DumpParityLogToDisk */\n\t\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);\n\t\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].reintInProgress == RF_TRUE);\n\t\traidPtr->regionInfo[regionID].diskCount = 0;\n\t\traidPtr->regionInfo[regionID].reintInProgress = RF_FALSE;\n\t\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);\t/* flushing is now\n\t\t\t\t\t\t\t\t\t\t * enabled */\n\t\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t}\n\t/* process each item in logData */\n\twhile (logData) {\n\t\t/* remove an item from logData */\n\t\titem = logData;\n\t\tlogData = logData->next;\n\t\titem->next = NULL;\n\t\titem->prev = NULL;\n\n\t\tif (rf_parityLogDebug)\n\t\t\tprintf(\"[appending parity log data, region %d, raidAddress %d, numSector %d]\\n\", item->regionID, (int) item->diskAddress.raidAddress, (int) item->diskAddress.numSector);\n\n\t\t/* see if we moved to a new region */\n\t\tif (regionID != item->regionID) {\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t\t\tregionID = item->regionID;\n\t\t\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);\n\t\t}\n\t\tpunt = RF_FALSE;/* Set to RF_TRUE if work is blocked.  This\n\t\t\t\t * can happen in one of two ways: 1) no core\n\t\t\t\t * log (AcquireParityLog) 2) waiting on\n\t\t\t\t * reintegration (DumpParityLogToDisk) If punt\n\t\t\t\t * is RF_TRUE, the dataItem was queued, so\n\t\t\t\t * skip to next item. */\n\n\t\t/* process item, one sector at a time, until all sectors\n\t\t * processed or we punt */\n\t\tif (item->diskAddress.numSector > 0)\n\t\t\tdone = RF_FALSE;\n\t\telse\n\t\t\tRF_ASSERT(0);\n\t\twhile (!punt && !done) {\n\t\t\t/* verify that a core log exists for this region */\n\t\t\tif (!raidPtr->regionInfo[regionID].coreLog) {\n\t\t\t\t/* Attempt to acquire a parity log. If\n\t\t\t\t * acquisition fails, queue remaining work in\n\t\t\t\t * data item and move to nextItem. */\n\t\t\t\tif (incomingLog) {\n\t\t\t\t\tif (*incomingLog) {\n\t\t\t\t\t\tRF_ASSERT((*incomingLog)->next == NULL);\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = *incomingLog;\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog->regionID = regionID;\n\t\t\t\t\t\t*incomingLog = NULL;\n\t\t\t\t\t} else\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t} else\n\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t/* Note: AcquireParityLog either returns a log\n\t\t\t\t * or enqueues currentItem */\n\t\t\t}\n\t\t\tif (!raidPtr->regionInfo[regionID].coreLog)\n\t\t\t\tpunt = RF_TRUE;\t/* failed to find a core log */\n\t\t\telse {\n\t\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);\n\t\t\t\t/* verify that the log has room for new\n\t\t\t\t * entries */\n\t\t\t\t/* if log is full, dump it to disk and grab a\n\t\t\t\t * new log */\n\t\t\t\tif (raidPtr->regionInfo[regionID].coreLog->numRecords == raidPtr->numSectorsPerLog) {\n\t\t\t\t\t/* log is full, dump it to disk */\n\t\t\t\t\tif (DumpParityLogToDisk(finish, item))\n\t\t\t\t\t\tpunt = RF_TRUE;\t/* dump unsuccessful,\n\t\t\t\t\t\t\t\t * blocked on\n\t\t\t\t\t\t\t\t * reintegration */\n\t\t\t\t\telse {\n\t\t\t\t\t\t/* dump was successful */\n\t\t\t\t\t  if (incomingLog) {\n\t\t\t\t\t\t\tif (*incomingLog) {\n\t\t\t\t\t\t\t\tRF_ASSERT((*incomingLog)->next == NULL);\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = *incomingLog;\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog->regionID = regionID;\n\t\t\t\t\t\t\t\t*incomingLog = NULL;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t\t\t/* if a core log is not\n\t\t\t\t\t\t * available, must queue work\n\t\t\t\t\t\t * and return */\n\t\t\t\t\t\tif (!raidPtr->regionInfo[regionID].coreLog)\n\t\t\t\t\t\t\tpunt = RF_TRUE;\t/* blocked on log\n\t\t\t\t\t\t\t\t\t * availability */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if we didn't punt on this item, attempt to add a\n\t\t\t * sector to the core log */\n\t\t\tif (!punt) {\n\t\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);\n\t\t\t\t/* at this point, we have a core log with\n\t\t\t\t * enough room for a sector */\n\t\t\t\t/* copy a sector into the log */\n\t\t\t\tlog = raidPtr->regionInfo[regionID].coreLog;\n\t\t\t\tRF_ASSERT(log->numRecords < raidPtr->numSectorsPerLog);\n\t\t\t\tlogItem = log->numRecords++;\n\t\t\t\tlog->records[logItem].parityAddr = item->diskAddress;\n\t\t\t\tRF_ASSERT(log->records[logItem].parityAddr.startSector >= raidPtr->regionInfo[regionID].parityStartAddr);\n\t\t\t\tRF_ASSERT(log->records[logItem].parityAddr.startSector < raidPtr->regionInfo[regionID].parityStartAddr + raidPtr->regionInfo[regionID].numSectorsParity);\n\t\t\t\tlog->records[logItem].parityAddr.numSector = 1;\n\t\t\t\tlog->records[logItem].operation = item->common->operation;\n\t\t\t\tbcopy((item->common->bufPtr + (item->bufOffset++ * (1 << item->common->raidPtr->logBytesPerSector))), log->bufPtr + (logItem * (1 << item->common->raidPtr->logBytesPerSector)), (1 << item->common->raidPtr->logBytesPerSector));\n\t\t\t\titem->diskAddress.numSector--;\n\t\t\t\titem->diskAddress.startSector++;\n\t\t\t\tif (item->diskAddress.numSector == 0)\n\t\t\t\t\tdone = RF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (!punt) {\n\t\t\t/* Processed this item completely, decrement count of\n\t\t\t * items to be processed. */\n\t\t\tRF_ASSERT(item->diskAddress.numSector == 0);\n\t\t\tRF_LOCK_MUTEX(item->common->mutex);\n\t\t\titem->common->cnt--;\n\t\t\tif (item->common->cnt == 0)\n\t\t\t\titemDone = RF_TRUE;\n\t\t\telse\n\t\t\t\titemDone = RF_FALSE;\n\t\t\tRF_UNLOCK_MUTEX(item->common->mutex);\n\t\t\tif (itemDone) {\n\t\t\t\t/* Finished processing all log data for this\n\t\t\t\t * IO Return structs to free list and invoke\n\t\t\t\t * wakeup function. */\n\t\t\t\ttimer = item->common->startTime;\t/* grab initial value of\n\t\t\t\t\t\t\t\t\t * timer */\n\t\t\t\tRF_ETIMER_STOP(timer);\n\t\t\t\tRF_ETIMER_EVAL(timer);\n\t\t\t\titem->common->tracerec->plog_us += RF_ETIMER_VAL_US(timer);\n\t\t\t\tif (rf_parityLogDebug)\n\t\t\t\t\tprintf(\"[waking process for region %d]\\n\", item->regionID);\n\t\t\t\twakeFunc = item->common->wakeFunc;\n\t\t\t\twakeArg = item->common->wakeArg;\n\t\t\t\tFreeParityLogCommonData(item->common);\n\t\t\t\tFreeParityLogData(item);\n\t\t\t\t(wakeFunc) (wakeArg, 0);\n\t\t\t} else\n\t\t\t\tFreeParityLogData(item);\n\t\t}\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[exiting ParityLogAppend]\\n\");\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_etimer.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_desc.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_ParityLogAppend(\n    RF_ParityLogData_t * logData,\n    int finish,\n    RF_ParityLog_t ** incomingLog,\n    int clearReintFlag)\n{\n\tint     regionID, logItem, itemDone;\n\tRF_ParityLogData_t *item;\n\tint     punt, done = RF_FALSE;\n\tRF_ParityLog_t *log;\n\tRF_Raid_t *raidPtr;\n\tRF_Etimer_t timer;\n\tint     (*wakeFunc) (RF_DagNode_t * node, int status);\n\tvoid   *wakeArg;\n\n\t/* Add parity to the appropriate log, one sector at a time. This\n\t * routine is called is called by dag functions ParityLogUpdateFunc\n\t * and ParityLogOverwriteFunc and therefore MUST BE NONBLOCKING.\n\t * \n\t * Parity to be logged is contained in a linked-list (logData).  When\n\t * this routine returns, every sector in the list will be in one of\n\t * three places: 1) entered into the parity log 2) queued, waiting on\n\t * reintegration 3) queued, waiting on a core log\n\t * \n\t * Blocked work is passed to the ParityLoggingDiskManager for completion.\n\t * Later, as conditions which required the block are removed, the work\n\t * reenters this routine with the \"finish\" parameter set to \"RF_TRUE.\"\n\t * \n\t * NON-BLOCKING */\n\n\traidPtr = logData->common->raidPtr;\n\t/* lock the region for the first item in logData */\n\tRF_ASSERT(logData != NULL);\n\tregionID = logData->regionID;\n\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tRF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);\n\n\tif (clearReintFlag) {\n\t\t/* Enable flushing for this region.  Holding both locks\n\t\t * provides a synchronization barrier with DumpParityLogToDisk */\n\t\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);\n\t\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].reintInProgress == RF_TRUE);\n\t\traidPtr->regionInfo[regionID].diskCount = 0;\n\t\traidPtr->regionInfo[regionID].reintInProgress = RF_FALSE;\n\t\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].reintMutex);\t/* flushing is now\n\t\t\t\t\t\t\t\t\t\t * enabled */\n\t\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t}\n\t/* process each item in logData */\n\twhile (logData) {\n\t\t/* remove an item from logData */\n\t\titem = logData;\n\t\tlogData = logData->next;\n\t\titem->next = NULL;\n\t\titem->prev = NULL;\n\n\t\tif (rf_parityLogDebug)\n\t\t\tprintf(\"[appending parity log data, region %d, raidAddress %d, numSector %d]\\n\", item->regionID, (int) item->diskAddress.raidAddress, (int) item->diskAddress.numSector);\n\n\t\t/* see if we moved to a new region */\n\t\tif (regionID != item->regionID) {\n\t\t\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t\t\tregionID = item->regionID;\n\t\t\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].loggingEnabled);\n\t\t}\n\t\tpunt = RF_FALSE;/* Set to RF_TRUE if work is blocked.  This\n\t\t\t\t * can happen in one of two ways: 1) no core\n\t\t\t\t * log (AcquireParityLog) 2) waiting on\n\t\t\t\t * reintegration (DumpParityLogToDisk) If punt\n\t\t\t\t * is RF_TRUE, the dataItem was queued, so\n\t\t\t\t * skip to next item. */\n\n\t\t/* process item, one sector at a time, until all sectors\n\t\t * processed or we punt */\n\t\tif (item->diskAddress.numSector > 0)\n\t\t\tdone = RF_FALSE;\n\t\telse\n\t\t\tRF_ASSERT(0);\n\t\twhile (!punt && !done) {\n\t\t\t/* verify that a core log exists for this region */\n\t\t\tif (!raidPtr->regionInfo[regionID].coreLog) {\n\t\t\t\t/* Attempt to acquire a parity log. If\n\t\t\t\t * acquisition fails, queue remaining work in\n\t\t\t\t * data item and move to nextItem. */\n\t\t\t\tif (incomingLog) {\n\t\t\t\t\tif (*incomingLog) {\n\t\t\t\t\t\tRF_ASSERT((*incomingLog)->next == NULL);\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = *incomingLog;\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog->regionID = regionID;\n\t\t\t\t\t\t*incomingLog = NULL;\n\t\t\t\t\t} else\n\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t} else\n\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t/* Note: AcquireParityLog either returns a log\n\t\t\t\t * or enqueues currentItem */\n\t\t\t}\n\t\t\tif (!raidPtr->regionInfo[regionID].coreLog)\n\t\t\t\tpunt = RF_TRUE;\t/* failed to find a core log */\n\t\t\telse {\n\t\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);\n\t\t\t\t/* verify that the log has room for new\n\t\t\t\t * entries */\n\t\t\t\t/* if log is full, dump it to disk and grab a\n\t\t\t\t * new log */\n\t\t\t\tif (raidPtr->regionInfo[regionID].coreLog->numRecords == raidPtr->numSectorsPerLog) {\n\t\t\t\t\t/* log is full, dump it to disk */\n\t\t\t\t\tif (DumpParityLogToDisk(finish, item))\n\t\t\t\t\t\tpunt = RF_TRUE;\t/* dump unsuccessful,\n\t\t\t\t\t\t\t\t * blocked on\n\t\t\t\t\t\t\t\t * reintegration */\n\t\t\t\t\telse {\n\t\t\t\t\t\t/* dump was successful */\n\t\t\t\t\t  if (incomingLog) {\n\t\t\t\t\t\t\tif (*incomingLog) {\n\t\t\t\t\t\t\t\tRF_ASSERT((*incomingLog)->next == NULL);\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = *incomingLog;\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog->regionID = regionID;\n\t\t\t\t\t\t\t\t*incomingLog = NULL;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\traidPtr->regionInfo[regionID].coreLog = AcquireParityLog(item, finish);\n\t\t\t\t\t\t/* if a core log is not\n\t\t\t\t\t\t * available, must queue work\n\t\t\t\t\t\t * and return */\n\t\t\t\t\t\tif (!raidPtr->regionInfo[regionID].coreLog)\n\t\t\t\t\t\t\tpunt = RF_TRUE;\t/* blocked on log\n\t\t\t\t\t\t\t\t\t * availability */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if we didn't punt on this item, attempt to add a\n\t\t\t * sector to the core log */\n\t\t\tif (!punt) {\n\t\t\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog->next == NULL);\n\t\t\t\t/* at this point, we have a core log with\n\t\t\t\t * enough room for a sector */\n\t\t\t\t/* copy a sector into the log */\n\t\t\t\tlog = raidPtr->regionInfo[regionID].coreLog;\n\t\t\t\tRF_ASSERT(log->numRecords < raidPtr->numSectorsPerLog);\n\t\t\t\tlogItem = log->numRecords++;\n\t\t\t\tlog->records[logItem].parityAddr = item->diskAddress;\n\t\t\t\tRF_ASSERT(log->records[logItem].parityAddr.startSector >= raidPtr->regionInfo[regionID].parityStartAddr);\n\t\t\t\tRF_ASSERT(log->records[logItem].parityAddr.startSector < raidPtr->regionInfo[regionID].parityStartAddr + raidPtr->regionInfo[regionID].numSectorsParity);\n\t\t\t\tlog->records[logItem].parityAddr.numSector = 1;\n\t\t\t\tlog->records[logItem].operation = item->common->operation;\n\t\t\t\tbcopy((item->common->bufPtr + (item->bufOffset++ * (1 << item->common->raidPtr->logBytesPerSector))), log->bufPtr + (logItem * (1 << item->common->raidPtr->logBytesPerSector)), (1 << item->common->raidPtr->logBytesPerSector));\n\t\t\t\titem->diskAddress.numSector--;\n\t\t\t\titem->diskAddress.startSector++;\n\t\t\t\tif (item->diskAddress.numSector == 0)\n\t\t\t\t\tdone = RF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (!punt) {\n\t\t\t/* Processed this item completely, decrement count of\n\t\t\t * items to be processed. */\n\t\t\tRF_ASSERT(item->diskAddress.numSector == 0);\n\t\t\tRF_LOCK_MUTEX(item->common->mutex);\n\t\t\titem->common->cnt--;\n\t\t\tif (item->common->cnt == 0)\n\t\t\t\titemDone = RF_TRUE;\n\t\t\telse\n\t\t\t\titemDone = RF_FALSE;\n\t\t\tRF_UNLOCK_MUTEX(item->common->mutex);\n\t\t\tif (itemDone) {\n\t\t\t\t/* Finished processing all log data for this\n\t\t\t\t * IO Return structs to free list and invoke\n\t\t\t\t * wakeup function. */\n\t\t\t\ttimer = item->common->startTime;\t/* grab initial value of\n\t\t\t\t\t\t\t\t\t * timer */\n\t\t\t\tRF_ETIMER_STOP(timer);\n\t\t\t\tRF_ETIMER_EVAL(timer);\n\t\t\t\titem->common->tracerec->plog_us += RF_ETIMER_VAL_US(timer);\n\t\t\t\tif (rf_parityLogDebug)\n\t\t\t\t\tprintf(\"[waking process for region %d]\\n\", item->regionID);\n\t\t\t\twakeFunc = item->common->wakeFunc;\n\t\t\t\twakeArg = item->common->wakeArg;\n\t\t\t\tFreeParityLogCommonData(item->common);\n\t\t\t\tFreeParityLogData(item);\n\t\t\t\t(wakeFunc) (wakeArg, 0);\n\t\t\t} else\n\t\t\t\tFreeParityLogData(item);\n\t\t}\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[exiting ParityLogAppend]\\n\");\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_CreateParityLogData",
          "args": [
            "RF_UPDATE",
            "pda",
            "buf",
            "(RF_Raid_t *) (node->dagHdr->raidPtr)",
            "node->wakeFunc",
            "(void *) node",
            "node->dagHdr->tracerec",
            "timer"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateParityLogData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylog.c",
          "lines": "262-335",
          "snippet": "RF_ParityLogData_t *\nrf_CreateParityLogData(\n    RF_ParityRecordType_t operation,\n    RF_PhysDiskAddr_t * pda,\n    caddr_t bufPtr,\n    RF_Raid_t * raidPtr,\n    int (*wakeFunc) (RF_DagNode_t * node, int status),\n    void *wakeArg,\n    RF_AccTraceEntry_t * tracerec,\n    RF_Etimer_t startTime)\n{\n\tRF_ParityLogData_t *data, *resultHead = NULL, *resultTail = NULL;\n\tRF_CommonLogData_t *common;\n\tRF_PhysDiskAddr_t *diskAddress;\n\tint     boundary, offset = 0;\n\n\t/* Return an initialized struct of info to be logged. Build one item\n\t * per physical disk address, one item per region.\n\t * \n\t * NON-BLOCKING */\n\n\tdiskAddress = pda;\n\tcommon = AllocParityLogCommonData(raidPtr);\n\tRF_ASSERT(common);\n\n\tcommon->operation = operation;\n\tcommon->bufPtr = bufPtr;\n\tcommon->raidPtr = raidPtr;\n\tcommon->wakeFunc = wakeFunc;\n\tcommon->wakeArg = wakeArg;\n\tcommon->tracerec = tracerec;\n\tcommon->startTime = startTime;\n\tcommon->cnt = 0;\n\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[entering CreateParityLogData]\\n\");\n\twhile (diskAddress) {\n\t\tcommon->cnt++;\n\t\tdata = AllocParityLogData(raidPtr);\n\t\tRF_ASSERT(data);\n\t\tdata->common = common;\n\t\tdata->next = NULL;\n\t\tdata->prev = NULL;\n\t\tdata->regionID = rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector);\n\t\tif (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + diskAddress->numSector - 1)) {\n\t\t\t/* disk address does not cross a region boundary */\n\t\t\tdata->diskAddress = *diskAddress;\n\t\t\tdata->bufOffset = offset;\n\t\t\toffset = offset + diskAddress->numSector;\n\t\t\tEnqueueParityLogData(data, &resultHead, &resultTail);\n\t\t\t/* adjust disk address */\n\t\t\tdiskAddress = diskAddress->next;\n\t\t} else {\n\t\t\t/* disk address crosses a region boundary */\n\t\t\t/* find address where region is crossed */\n\t\t\tboundary = 0;\n\t\t\twhile (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + boundary))\n\t\t\t\tboundary++;\n\n\t\t\t/* enter data before the boundary */\n\t\t\tdata->diskAddress = *diskAddress;\n\t\t\tdata->diskAddress.numSector = boundary;\n\t\t\tdata->bufOffset = offset;\n\t\t\toffset += boundary;\n\t\t\tEnqueueParityLogData(data, &resultHead, &resultTail);\n\t\t\t/* adjust disk address */\n\t\t\tdiskAddress->startSector += boundary;\n\t\t\tdiskAddress->numSector -= boundary;\n\t\t}\n\t}\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[leaving CreateParityLogData]\\n\");\n\treturn (resultHead);\n}",
          "includes": [
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_etimer.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_desc.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nRF_ParityLogData_t *\nrf_CreateParityLogData(\n    RF_ParityRecordType_t operation,\n    RF_PhysDiskAddr_t * pda,\n    caddr_t bufPtr,\n    RF_Raid_t * raidPtr,\n    int (*wakeFunc) (RF_DagNode_t * node, int status),\n    void *wakeArg,\n    RF_AccTraceEntry_t * tracerec,\n    RF_Etimer_t startTime)\n{\n\tRF_ParityLogData_t *data, *resultHead = NULL, *resultTail = NULL;\n\tRF_CommonLogData_t *common;\n\tRF_PhysDiskAddr_t *diskAddress;\n\tint     boundary, offset = 0;\n\n\t/* Return an initialized struct of info to be logged. Build one item\n\t * per physical disk address, one item per region.\n\t * \n\t * NON-BLOCKING */\n\n\tdiskAddress = pda;\n\tcommon = AllocParityLogCommonData(raidPtr);\n\tRF_ASSERT(common);\n\n\tcommon->operation = operation;\n\tcommon->bufPtr = bufPtr;\n\tcommon->raidPtr = raidPtr;\n\tcommon->wakeFunc = wakeFunc;\n\tcommon->wakeArg = wakeArg;\n\tcommon->tracerec = tracerec;\n\tcommon->startTime = startTime;\n\tcommon->cnt = 0;\n\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[entering CreateParityLogData]\\n\");\n\twhile (diskAddress) {\n\t\tcommon->cnt++;\n\t\tdata = AllocParityLogData(raidPtr);\n\t\tRF_ASSERT(data);\n\t\tdata->common = common;\n\t\tdata->next = NULL;\n\t\tdata->prev = NULL;\n\t\tdata->regionID = rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector);\n\t\tif (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + diskAddress->numSector - 1)) {\n\t\t\t/* disk address does not cross a region boundary */\n\t\t\tdata->diskAddress = *diskAddress;\n\t\t\tdata->bufOffset = offset;\n\t\t\toffset = offset + diskAddress->numSector;\n\t\t\tEnqueueParityLogData(data, &resultHead, &resultTail);\n\t\t\t/* adjust disk address */\n\t\t\tdiskAddress = diskAddress->next;\n\t\t} else {\n\t\t\t/* disk address crosses a region boundary */\n\t\t\t/* find address where region is crossed */\n\t\t\tboundary = 0;\n\t\t\twhile (data->regionID == rf_MapRegionIDParityLogging(raidPtr, diskAddress->startSector + boundary))\n\t\t\t\tboundary++;\n\n\t\t\t/* enter data before the boundary */\n\t\t\tdata->diskAddress = *diskAddress;\n\t\t\tdata->diskAddress.numSector = boundary;\n\t\t\tdata->bufOffset = offset;\n\t\t\toffset += boundary;\n\t\t\tEnqueueParityLogData(data, &resultHead, &resultTail);\n\t\t\t/* adjust disk address */\n\t\t\tdiskAddress->startSector += boundary;\n\t\t\tdiskAddress->numSector -= boundary;\n\t\t}\n\t}\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[leaving CreateParityLogData]\\n\");\n\treturn (resultHead);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_ParityLogUpdateFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_ParityLogData_t *logData;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tlogData = rf_CreateParityLogData(RF_UPDATE, pda, buf,\n\t\t    (RF_Raid_t *) (node->dagHdr->raidPtr),\n\t\t    node->wakeFunc, (void *) node,\n\t\t    node->dagHdr->tracerec, timer);\n\t\tif (logData)\n\t\t\trf_ParityLogAppend(logData, RF_FALSE, NULL, RF_FALSE);\n\t\telse {\n\t\t\tRF_ETIMER_STOP(timer);\n\t\t\tRF_ETIMER_EVAL(timer);\n\t\t\ttracerec->plog_us += RF_ETIMER_VAL_US(timer);\n\t\t\t(node->wakeFunc) (node, ENOMEM);\n\t\t}\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_DiskReadMirrorUndoFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "159-164",
    "snippet": "int \nrf_DiskReadMirrorUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_DiskReadMirrorUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_DiskReadMirrorPartitionFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "148-157",
    "snippet": "int \nrf_DiskReadMirrorPartitionFunc(node)\n\tRF_DagNode_t *node;\n{\n\t/* select the mirror copy with the shortest queue and fill in node\n\t * parameters with physical disk address */\n\n\trf_SelectMirrorDiskPartition(node);\n\treturn (rf_DiskReadFunc(node));\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_DiskReadFunc",
          "args": [
            "node"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskReadFuncForThreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "281-317",
          "snippet": "int \nrf_DiskReadFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;\n\tunsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);\n\tunsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\tunsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\tunsigned which_ru = RF_EXTRACT_RU(node->params[3].v);\n\tRF_DiskQueueDataFlags_t flags = 0;\n\tRF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_READ : RF_IO_TYPE_NOP;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\tvoid   *b_proc = NULL;\n\n\tif (node->dagHdr->bp)\n\t\tb_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;\n\n\tRF_ASSERT(!(lock && unlock));\n\tflags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;\n\tflags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;\n\n\treq = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,\n\t    buf, parityStripeID, which_ru,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    node, NULL, node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr), flags, b_proc);\n\tif (!req) {\n\t\t(node->wakeFunc) (node, ENOMEM);\n\t} else {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_DiskReadFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;\n\tunsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);\n\tunsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\tunsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\tunsigned which_ru = RF_EXTRACT_RU(node->params[3].v);\n\tRF_DiskQueueDataFlags_t flags = 0;\n\tRF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_READ : RF_IO_TYPE_NOP;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\tvoid   *b_proc = NULL;\n\n\tif (node->dagHdr->bp)\n\t\tb_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;\n\n\tRF_ASSERT(!(lock && unlock));\n\tflags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;\n\tflags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;\n\n\treq = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,\n\t    buf, parityStripeID, which_ru,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    node, NULL, node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr), flags, b_proc);\n\tif (!req) {\n\t\t(node->wakeFunc) (node, ENOMEM);\n\t} else {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_SelectMirrorDiskPartition",
          "args": [
            "node"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "rf_SelectMirrorDiskPartition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "1251-1297",
          "snippet": "void \nrf_SelectMirrorDiskPartition(RF_DagNode_t * node)\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;\n\tRF_RowCol_t rowData, colData, rowMirror, colMirror;\n\tRF_PhysDiskAddr_t *data_pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *) node->params[4].p;\n\tRF_PhysDiskAddr_t *tmp_pda;\n\tRF_RaidDisk_t **disks = raidPtr->Disks;\n\tRF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;\n\tint     usemirror;\n\n\t/* return the [row col] of the disk with the shortest queue */\n\trowData = data_pda->row;\n\tcolData = data_pda->col;\n\trowMirror = mirror_pda->row;\n\tcolMirror = mirror_pda->col;\n\tdataQueue = &(dqs[rowData][colData]);\n\tmirrorQueue = &(dqs[rowMirror][colMirror]);\n\n\tusemirror = 0;\n\tif (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {\n\t\tusemirror = 0;\n\t} else\n\t\tif (RF_DEAD_DISK(disks[rowData][colData].status)) {\n\t\t\tusemirror = 1;\n\t\t} else \n\t\t\tif (raidPtr->parity_good == RF_RAID_DIRTY) {\n\t\t\t\t/* Trust only the main disk */\n\t\t\t\tusemirror = 0;\n\t\t} else\n\t\t\t\tif (data_pda->startSector < \n\t\t\t\t    (disks[rowData][colData].numBlocks / 2)) {\n\t\t\t\tusemirror = 0;\n\t\t\t} else {\n\t\t\t\tusemirror = 1;\n\t\t\t}\n\n\tif (usemirror) {\n\t\t/* use mirror (parity) disk, swap params 0 & 4 */\n\t\ttmp_pda = data_pda;\n\t\tnode->params[0].p = mirror_pda;\n\t\tnode->params[4].p = tmp_pda;\n\t} else {\n\t\t/* use data disk, leave param 0 unchanged */\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nvoid \nrf_SelectMirrorDiskPartition(RF_DagNode_t * node)\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;\n\tRF_RowCol_t rowData, colData, rowMirror, colMirror;\n\tRF_PhysDiskAddr_t *data_pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *) node->params[4].p;\n\tRF_PhysDiskAddr_t *tmp_pda;\n\tRF_RaidDisk_t **disks = raidPtr->Disks;\n\tRF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;\n\tint     usemirror;\n\n\t/* return the [row col] of the disk with the shortest queue */\n\trowData = data_pda->row;\n\tcolData = data_pda->col;\n\trowMirror = mirror_pda->row;\n\tcolMirror = mirror_pda->col;\n\tdataQueue = &(dqs[rowData][colData]);\n\tmirrorQueue = &(dqs[rowMirror][colMirror]);\n\n\tusemirror = 0;\n\tif (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {\n\t\tusemirror = 0;\n\t} else\n\t\tif (RF_DEAD_DISK(disks[rowData][colData].status)) {\n\t\t\tusemirror = 1;\n\t\t} else \n\t\t\tif (raidPtr->parity_good == RF_RAID_DIRTY) {\n\t\t\t\t/* Trust only the main disk */\n\t\t\t\tusemirror = 0;\n\t\t} else\n\t\t\t\tif (data_pda->startSector < \n\t\t\t\t    (disks[rowData][colData].numBlocks / 2)) {\n\t\t\t\tusemirror = 0;\n\t\t\t} else {\n\t\t\t\tusemirror = 1;\n\t\t\t}\n\n\tif (usemirror) {\n\t\t/* use mirror (parity) disk, swap params 0 & 4 */\n\t\ttmp_pda = data_pda;\n\t\tnode->params[0].p = mirror_pda;\n\t\tnode->params[4].p = tmp_pda;\n\t} else {\n\t\t/* use data disk, leave param 0 unchanged */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_DiskReadMirrorPartitionFunc(node)\n\tRF_DagNode_t *node;\n{\n\t/* select the mirror copy with the shortest queue and fill in node\n\t * parameters with physical disk address */\n\n\trf_SelectMirrorDiskPartition(node);\n\treturn (rf_DiskReadFunc(node));\n}"
  },
  {
    "function_name": "rf_DiskReadMirrorIdleFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "137-146",
    "snippet": "int \nrf_DiskReadMirrorIdleFunc(node)\n\tRF_DagNode_t *node;\n{\n\t/* select the mirror copy with the shortest queue and fill in node\n\t * parameters with physical disk address */\n\n\trf_SelectMirrorDiskIdle(node);\n\treturn (rf_DiskReadFunc(node));\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_DiskReadFunc",
          "args": [
            "node"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DiskReadFuncForThreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "281-317",
          "snippet": "int \nrf_DiskReadFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;\n\tunsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);\n\tunsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\tunsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\tunsigned which_ru = RF_EXTRACT_RU(node->params[3].v);\n\tRF_DiskQueueDataFlags_t flags = 0;\n\tRF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_READ : RF_IO_TYPE_NOP;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\tvoid   *b_proc = NULL;\n\n\tif (node->dagHdr->bp)\n\t\tb_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;\n\n\tRF_ASSERT(!(lock && unlock));\n\tflags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;\n\tflags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;\n\n\treq = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,\n\t    buf, parityStripeID, which_ru,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    node, NULL, node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr), flags, b_proc);\n\tif (!req) {\n\t\t(node->wakeFunc) (node, ENOMEM);\n\t} else {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_DiskReadFuncForThreads(node)\n\tRF_DagNode_t *node;\n{\n\tRF_DiskQueueData_t *req;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tcaddr_t buf = (caddr_t) node->params[1].p;\n\tRF_StripeNum_t parityStripeID = (RF_StripeNum_t) node->params[2].v;\n\tunsigned priority = RF_EXTRACT_PRIORITY(node->params[3].v);\n\tunsigned lock = RF_EXTRACT_LOCK_FLAG(node->params[3].v);\n\tunsigned unlock = RF_EXTRACT_UNLOCK_FLAG(node->params[3].v);\n\tunsigned which_ru = RF_EXTRACT_RU(node->params[3].v);\n\tRF_DiskQueueDataFlags_t flags = 0;\n\tRF_IoType_t iotype = (node->dagHdr->status == rf_enable) ? RF_IO_TYPE_READ : RF_IO_TYPE_NOP;\n\tRF_DiskQueue_t **dqs = ((RF_Raid_t *) (node->dagHdr->raidPtr))->Queues;\n\tvoid   *b_proc = NULL;\n\n\tif (node->dagHdr->bp)\n\t\tb_proc = (void *) ((struct buf *) node->dagHdr->bp)->b_proc;\n\n\tRF_ASSERT(!(lock && unlock));\n\tflags |= (lock) ? RF_LOCK_DISK_QUEUE : 0;\n\tflags |= (unlock) ? RF_UNLOCK_DISK_QUEUE : 0;\n\n\treq = rf_CreateDiskQueueData(iotype, pda->startSector, pda->numSector,\n\t    buf, parityStripeID, which_ru,\n\t    (int (*) (void *, int)) node->wakeFunc,\n\t    node, NULL, node->dagHdr->tracerec,\n\t    (void *) (node->dagHdr->raidPtr), flags, b_proc);\n\tif (!req) {\n\t\t(node->wakeFunc) (node, ENOMEM);\n\t} else {\n\t\tnode->dagFuncData = (void *) req;\n\t\trf_DiskIOEnqueue(&(dqs[pda->row][pda->col]), req, priority);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_SelectMirrorDiskIdle",
          "args": [
            "node"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "rf_SelectMirrorDiskIdle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "1176-1246",
          "snippet": "void \nrf_SelectMirrorDiskIdle(RF_DagNode_t * node)\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;\n\tRF_RowCol_t rowData, colData, rowMirror, colMirror;\n\tint     dataQueueLength, mirrorQueueLength, usemirror;\n\tRF_PhysDiskAddr_t *data_pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *) node->params[4].p;\n\tRF_PhysDiskAddr_t *tmp_pda;\n\tRF_RaidDisk_t **disks = raidPtr->Disks;\n\tRF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;\n\n\t/* return the [row col] of the disk with the shortest queue */\n\trowData = data_pda->row;\n\tcolData = data_pda->col;\n\trowMirror = mirror_pda->row;\n\tcolMirror = mirror_pda->col;\n\tdataQueue = &(dqs[rowData][colData]);\n\tmirrorQueue = &(dqs[rowMirror][colMirror]);\n\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_LOCK_QUEUE_MUTEX(dataQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\tdataQueueLength = dataQueue->queueLength + dataQueue->numOutstanding;\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_UNLOCK_QUEUE_MUTEX(dataQueue, \"SelectMirrorDiskIdle\");\n\tRF_LOCK_QUEUE_MUTEX(mirrorQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\tmirrorQueueLength = mirrorQueue->queueLength + mirrorQueue->numOutstanding;\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_UNLOCK_QUEUE_MUTEX(mirrorQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\n\tusemirror = 0;\n\tif (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {\n\t\tusemirror = 0;\n\t} else\n\t\tif (RF_DEAD_DISK(disks[rowData][colData].status)) {\n\t\t\tusemirror = 1;\n\t\t} else\n\t\t\tif (raidPtr->parity_good == RF_RAID_DIRTY) {\n\t\t\t\t/* Trust only the main disk */\n\t\t\t\tusemirror = 0;\n\t\t\t} else\n\t\t\tif (dataQueueLength < mirrorQueueLength) {\n\t\t\t\tusemirror = 0;\n\t\t\t} else\n\t\t\t\tif (mirrorQueueLength < dataQueueLength) {\n\t\t\t\t\tusemirror = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* queues are equal length. attempt\n\t\t\t\t\t * cleverness. */\n\t\t\t\t\tif (SNUM_DIFF(dataQueue->last_deq_sector, data_pda->startSector)\n\t\t\t\t\t    <= SNUM_DIFF(mirrorQueue->last_deq_sector, mirror_pda->startSector)) {\n\t\t\t\t\t\tusemirror = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusemirror = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\tif (usemirror) {\n\t\t/* use mirror (parity) disk, swap params 0 & 4 */\n\t\ttmp_pda = data_pda;\n\t\tnode->params[0].p = mirror_pda;\n\t\tnode->params[4].p = tmp_pda;\n\t} else {\n\t\t/* use data disk, leave param 0 unchanged */\n\t}\n\t/* printf(\"dataQueueLength %d, mirrorQueueLength\n\t * %d\\n\",dataQueueLength, mirrorQueueLength); */\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\n\nvoid \nrf_SelectMirrorDiskIdle(RF_DagNode_t * node)\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->dagHdr->raidPtr;\n\tRF_RowCol_t rowData, colData, rowMirror, colMirror;\n\tint     dataQueueLength, mirrorQueueLength, usemirror;\n\tRF_PhysDiskAddr_t *data_pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tRF_PhysDiskAddr_t *mirror_pda = (RF_PhysDiskAddr_t *) node->params[4].p;\n\tRF_PhysDiskAddr_t *tmp_pda;\n\tRF_RaidDisk_t **disks = raidPtr->Disks;\n\tRF_DiskQueue_t **dqs = raidPtr->Queues, *dataQueue, *mirrorQueue;\n\n\t/* return the [row col] of the disk with the shortest queue */\n\trowData = data_pda->row;\n\tcolData = data_pda->col;\n\trowMirror = mirror_pda->row;\n\tcolMirror = mirror_pda->col;\n\tdataQueue = &(dqs[rowData][colData]);\n\tmirrorQueue = &(dqs[rowMirror][colMirror]);\n\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_LOCK_QUEUE_MUTEX(dataQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\tdataQueueLength = dataQueue->queueLength + dataQueue->numOutstanding;\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_UNLOCK_QUEUE_MUTEX(dataQueue, \"SelectMirrorDiskIdle\");\n\tRF_LOCK_QUEUE_MUTEX(mirrorQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\tmirrorQueueLength = mirrorQueue->queueLength + mirrorQueue->numOutstanding;\n#ifdef RF_LOCK_QUEUES_TO_READ_LEN\n\tRF_UNLOCK_QUEUE_MUTEX(mirrorQueue, \"SelectMirrorDiskIdle\");\n#endif\t\t\t\t/* RF_LOCK_QUEUES_TO_READ_LEN */\n\n\tusemirror = 0;\n\tif (RF_DEAD_DISK(disks[rowMirror][colMirror].status)) {\n\t\tusemirror = 0;\n\t} else\n\t\tif (RF_DEAD_DISK(disks[rowData][colData].status)) {\n\t\t\tusemirror = 1;\n\t\t} else\n\t\t\tif (raidPtr->parity_good == RF_RAID_DIRTY) {\n\t\t\t\t/* Trust only the main disk */\n\t\t\t\tusemirror = 0;\n\t\t\t} else\n\t\t\tif (dataQueueLength < mirrorQueueLength) {\n\t\t\t\tusemirror = 0;\n\t\t\t} else\n\t\t\t\tif (mirrorQueueLength < dataQueueLength) {\n\t\t\t\t\tusemirror = 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* queues are equal length. attempt\n\t\t\t\t\t * cleverness. */\n\t\t\t\t\tif (SNUM_DIFF(dataQueue->last_deq_sector, data_pda->startSector)\n\t\t\t\t\t    <= SNUM_DIFF(mirrorQueue->last_deq_sector, mirror_pda->startSector)) {\n\t\t\t\t\t\tusemirror = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusemirror = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\tif (usemirror) {\n\t\t/* use mirror (parity) disk, swap params 0 & 4 */\n\t\ttmp_pda = data_pda;\n\t\tnode->params[0].p = mirror_pda;\n\t\tnode->params[4].p = tmp_pda;\n\t} else {\n\t\t/* use data disk, leave param 0 unchanged */\n\t}\n\t/* printf(\"dataQueueLength %d, mirrorQueueLength\n\t * %d\\n\",dataQueueLength, mirrorQueueLength); */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_DiskReadMirrorIdleFunc(node)\n\tRF_DagNode_t *node;\n{\n\t/* select the mirror copy with the shortest queue and fill in node\n\t * parameters with physical disk address */\n\n\trf_SelectMirrorDiskIdle(node);\n\treturn (rf_DiskReadFunc(node));\n}"
  },
  {
    "function_name": "rf_TerminateUndoFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "116-121",
    "snippet": "int \nrf_TerminateUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_TerminateUndoFunc(node)\n\tRF_DagNode_t *node;\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_TerminateFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "107-114",
    "snippet": "int \nrf_TerminateFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_ASSERT(node->dagHdr->numCommits == node->dagHdr->numCommitNodes);\n\tnode->status = rf_good;\n\treturn (rf_FinishNode(node, RF_THREAD_CONTEXT));\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
      "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
      "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FinishNode",
          "args": [
            "node",
            "RF_THREAD_CONTEXT"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FinishNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "642-653",
          "snippet": "int \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_FinishNode(\n    RF_DagNode_t * node,\n    int context)\n{\n\t/* as far as I can tell, retcode is not used -wvcii */\n\tint     retcode = RF_FALSE;\n\tnode->dagHdr->numNodesCompleted++;\n\tProcessNode(node, context);\n\n\treturn (retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->dagHdr->numCommits == node->dagHdr->numCommitNodes"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_TerminateFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_ASSERT(node->dagHdr->numCommits == node->dagHdr->numCommitNodes);\n\tnode->status = rf_good;\n\treturn (rf_FinishNode(node, RF_THREAD_CONTEXT));\n}"
  },
  {
    "function_name": "rf_ConfigureDAGFuncs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
    "lines": "85-100",
    "snippet": "int \nrf_ConfigureDAGFuncs(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tRF_ASSERT(((sizeof(long) == 8) && RF_LONGSHIFT == 3) || ((sizeof(long) == 4) && RF_LONGSHIFT == 2));\n\trf_DiskReadFunc = rf_DiskReadFuncForThreads;\n\trf_DiskReadUndoFunc = rf_DiskUndoFunc;\n\trf_DiskWriteFunc = rf_DiskWriteFuncForThreads;\n\trf_DiskWriteUndoFunc = rf_DiskUndoFunc;\n\trf_DiskUnlockFunc = rf_DiskUnlockFuncForThreads;\n\trf_DiskUnlockUndoFunc = rf_NullNodeUndoFunc;\n\trf_RegularXorUndoFunc = rf_NullNodeUndoFunc;\n\trf_SimpleXorUndoFunc = rf_NullNodeUndoFunc;\n\trf_RecoveryXorUndoFunc = rf_NullNodeUndoFunc;\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_paritylog.h\"",
      "#include \"rf_kintf.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_engine.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_acctrace.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_archs.h\"",
      "#include <sys/param.h>",
      "#include <sys/ioctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "((sizeof(long) == 8) && RF_LONGSHIFT == 3) || ((sizeof(long) == 4) && RF_LONGSHIFT == 2)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_ConfigureDAGFuncs(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tRF_ASSERT(((sizeof(long) == 8) && RF_LONGSHIFT == 3) || ((sizeof(long) == 4) && RF_LONGSHIFT == 2));\n\trf_DiskReadFunc = rf_DiskReadFuncForThreads;\n\trf_DiskReadUndoFunc = rf_DiskUndoFunc;\n\trf_DiskWriteFunc = rf_DiskWriteFuncForThreads;\n\trf_DiskWriteUndoFunc = rf_DiskUndoFunc;\n\trf_DiskUnlockFunc = rf_DiskUnlockFuncForThreads;\n\trf_DiskUnlockUndoFunc = rf_NullNodeUndoFunc;\n\trf_RegularXorUndoFunc = rf_NullNodeUndoFunc;\n\trf_SimpleXorUndoFunc = rf_NullNodeUndoFunc;\n\trf_RecoveryXorUndoFunc = rf_NullNodeUndoFunc;\n\treturn (0);\n}"
  }
]