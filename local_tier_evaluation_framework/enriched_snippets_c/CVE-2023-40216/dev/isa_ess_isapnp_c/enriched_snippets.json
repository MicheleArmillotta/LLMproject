[
  {
    "function_name": "ess_isapnp_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess_isapnp.c",
    "lines": "74-105",
    "snippet": "void ess_isapnp_attach(parent, self, aux)\n\t struct device *parent, *self;\n\t void *aux;\n{\n\tstruct ess_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\n\tprintf(\"\\n\");\n\n\tsc->sc_ic = ia->ia_ic;\n\tsc->sc_iot = ia->ia_iot;\n\tsc->sc_ioh = ia->ipa_io[0].h;\n\tsc->sc_iobase = ia->ipa_io[0].base;\n\n\tsc->sc_audio1.irq = ia->ipa_irq[0].num;\n\tsc->sc_audio1.ist = ia->ipa_irq[0].type;\n\tsc->sc_audio1.drq = ia->ipa_drq[0].num;\n\tsc->sc_audio2.irq = ia->ipa_irq[0].num;\n\tsc->sc_audio2.ist = ia->ipa_irq[0].type;\n\tsc->sc_audio2.drq = ia->ipa_drq[1].num;\n\n\tsc->sc_isa = parent->dv_parent;\n\n\tif (!essmatch(sc)) {\n\t\tprintf(\"%s: essmatch failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tprintf(\"%s:\", sc->sc_dev.dv_xname);\n\n\tessattach(sc);\n}",
    "includes": [
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ess_isapnp_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "essattach",
          "args": [
            "sc"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "essattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "884-1021",
          "snippet": "void\nessattach(sc)\n\tstruct ess_softc *sc;\n{\n\tstruct audio_attach_args arg;\n\tstruct audio_params pparams, rparams;\n\tint i;\n\tu_int v;\n\n\tif (ess_setup_sc(sc, 0)) {\n\t\tprintf(\": setup failed\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\": ESS Technology ES%s [version 0x%04x]\\n\", \n\t       essmodel[sc->sc_model], sc->sc_version);\n\n\tsc->sc_audio1.polled = sc->sc_audio1.irq == -1;\n\tif (!sc->sc_audio1.polled) {\n\t\tsc->sc_audio1.ih = isa_intr_establish(sc->sc_ic,\n\t\t    sc->sc_audio1.irq, sc->sc_audio1.ist, IPL_AUDIO,\n\t\t    ess_audio1_intr, sc, sc->sc_dev.dv_xname);\n\t\tprintf(\"%s: audio1 interrupting at irq %d\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_audio1.irq);\n\t} else\n\t\tprintf(\"%s: audio1 polled\\n\", sc->sc_dev.dv_xname);\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_audio1.drq,\n\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t       sc->sc_dev.dv_xname, sc->sc_audio1.drq);\n\t\treturn;\n\t}\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tsc->sc_audio2.polled = sc->sc_audio2.irq == -1;\n\t\tif (!sc->sc_audio2.polled) {\n\t\t\tsc->sc_audio2.ih = isa_intr_establish(sc->sc_ic,\n\t\t\t    sc->sc_audio2.irq, sc->sc_audio2.ist, IPL_AUDIO,\n\t\t\t    ess_audio2_intr, sc, sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: audio2 interrupting at irq %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->sc_audio2.irq);\n\t\t} else\n\t\t\tprintf(\"%s: audio2 polled\\n\", sc->sc_dev.dv_xname);\n\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_audio2.drq,\n\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, sc->sc_audio2.drq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* \n\t * Set record and play parameters to default values defined in\n\t * generic audio driver.\n\t */\n\tpparams = audio_default;\n\trparams = audio_default;\n\tess_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n\t/* Do a hardware reset on the mixer. */\n\tess_write_mix_reg(sc, ESS_MIX_RESET, ESS_MIX_RESET);\n\n\t/*\n\t * Set volume of Audio 1 to zero and disable Audio 1 DAC input\n\t * to playback mixer, since playback is always through Audio 2.\n\t */\n\tif (!ESS_USE_AUDIO1(sc->sc_model))\n\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_VOICE, 0);\n\tess_wdsp(sc, ESS_ACMD_DISABLE_SPKR);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ESS_SOURCE_MIC);\n\t\tsc->in_port = ESS_SOURCE_MIC;\n\t\tsc->ndevs = ESS_1788_NDEVS;\n\t} else {\n\t\t/*\n\t\t * Set hardware record source to use output of the record\n\t\t * mixer. We do the selection of record source in software by\n\t\t * setting the gain of the unused sources to zero. (See\n\t\t * ess_set_in_ports.)\n\t\t */\n\t\tess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ESS_SOURCE_MIXER);\n\t\tsc->in_mask = 1 << ESS_MIC_REC_VOL;\n\t\tsc->ndevs = ESS_1888_NDEVS;\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 0x10);\n\t\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 0x08);\n\t}\n\n\t/*\n\t * Set gain on each mixer device to a sensible value.\n\t * Devices not normally used are turned off, and other devices\n\t * are set to 50% volume.\n\t */\n\tfor (i = 0; i < sc->ndevs; i++) {\n\t\tswitch (i) {\n\t\tcase ESS_MIC_PLAY_VOL:\n\t\tcase ESS_LINE_PLAY_VOL:\n\t\tcase ESS_CD_PLAY_VOL:\n\t\tcase ESS_AUXB_PLAY_VOL:\n\t\tcase ESS_DAC_REC_VOL:\n\t\tcase ESS_LINE_REC_VOL:\n\t\tcase ESS_SYNTH_REC_VOL:\n\t\tcase ESS_CD_REC_VOL:\n\t\tcase ESS_AUXB_REC_VOL:\n\t\t\tv = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = ESS_4BIT_GAIN(AUDIO_MAX_GAIN / 2);\n\t\t\tbreak;\n\t\t}\n\t\tsc->gain[i][ESS_LEFT] = sc->gain[i][ESS_RIGHT] = v;\n\t\tess_set_gain(sc, i, 1);\n\t}\n\n\tess_setup(sc);\n\n\t/* Disable the speaker until the device is opened.  */\n\tess_speaker_off(sc);\n\tsc->spkr_state = SPKR_OFF;\n\n\tsprintf(ess_device.name, \"ES%s\", essmodel[sc->sc_model]);\n\tsprintf(ess_device.version, \"0x%04x\", sc->sc_version);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\taudio_attach_mi(&ess_1788_hw_if, sc, &sc->sc_dev);\n\telse\n\t\taudio_attach_mi(&ess_1888_hw_if, sc, &sc->sc_dev);\n\n\targ.type = AUDIODEV_TYPE_OPL;\n\targ.hwif = 0;\n\targ.hdl = 0;\n\t(void)config_found(&sc->sc_dev, &arg, audioprint);\n\n#ifdef AUDIO_DEBUG\n\tif (essdebug > 0)\n\t\tess_printsc(sc);\n#endif\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_setup_sc",
            "int\tess_set_params",
            "int\tess_audio1_intr",
            "int\tess_audio2_intr",
            "void\tess_speaker_off",
            "void\tess_setup",
            "void\tess_set_gain",
            "int\tess_set_in_ports",
            "int\tess_wdsp",
            "void\tess_write_mix_reg",
            "void\tess_clear_mreg_bits",
            "void\tess_set_mreg_bits",
            "static char *essmodel[] = {\n\t\"unsupported\",\n\t\"1888\",\n\t\"1887\",\n\t\"888\",\n\t\"1788\",\n\t\"1869\",\n\t\"1879\",\n\t\"1868\",\n\t\"1878\",\n};",
            "struct audio_device ess_device = {\n\t\"ESS Technology\",\n\t\"x\",\n\t\"ess\"\n};",
            "struct audio_hw_if ess_1788_hw_if = {\n\tess_open,\n\tess_1788_close,\n\tess_drain,\n\tess_query_encoding,\n\tess_set_params,\n\tess_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tess_audio1_halt,\n\tess_audio1_halt,\n\tess_speaker_ctl,\n\tess_getdev,\n\tNULL,\n\tess_set_port,\n\tess_get_port,\n\tess_query_devinfo,\n\tess_malloc,\n\tess_free,\n\tess_round_buffersize,\n\tess_mappage,\n\tess_1788_get_props,\n\tess_audio1_trigger_output,\n\tess_audio1_trigger_input,\n};",
            "struct audio_hw_if ess_1888_hw_if = {\n\tess_open,\n\tess_1888_close,\n\tess_drain,\n\tess_query_encoding,\n\tess_set_params,\n\tess_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tess_audio2_halt,\n\tess_audio1_halt,\n\tess_speaker_ctl,\n\tess_getdev,\n\tNULL,\n\tess_set_port,\n\tess_get_port,\n\tess_query_devinfo,\n\tess_malloc,\n\tess_free,\n\tess_round_buffersize,\n\tess_mappage,\n\tess_1888_get_props,\n\tess_audio2_trigger_output,\n\tess_audio1_trigger_input,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_setup_sc;\nint\tess_set_params;\nint\tess_audio1_intr;\nint\tess_audio2_intr;\nvoid\tess_speaker_off;\nvoid\tess_setup;\nvoid\tess_set_gain;\nint\tess_set_in_ports;\nint\tess_wdsp;\nvoid\tess_write_mix_reg;\nvoid\tess_clear_mreg_bits;\nvoid\tess_set_mreg_bits;\nstatic char *essmodel[] = {\n\t\"unsupported\",\n\t\"1888\",\n\t\"1887\",\n\t\"888\",\n\t\"1788\",\n\t\"1869\",\n\t\"1879\",\n\t\"1868\",\n\t\"1878\",\n};\nstruct audio_device ess_device = {\n\t\"ESS Technology\",\n\t\"x\",\n\t\"ess\"\n};\nstruct audio_hw_if ess_1788_hw_if = {\n\tess_open,\n\tess_1788_close,\n\tess_drain,\n\tess_query_encoding,\n\tess_set_params,\n\tess_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tess_audio1_halt,\n\tess_audio1_halt,\n\tess_speaker_ctl,\n\tess_getdev,\n\tNULL,\n\tess_set_port,\n\tess_get_port,\n\tess_query_devinfo,\n\tess_malloc,\n\tess_free,\n\tess_round_buffersize,\n\tess_mappage,\n\tess_1788_get_props,\n\tess_audio1_trigger_output,\n\tess_audio1_trigger_input,\n};\nstruct audio_hw_if ess_1888_hw_if = {\n\tess_open,\n\tess_1888_close,\n\tess_drain,\n\tess_query_encoding,\n\tess_set_params,\n\tess_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tess_audio2_halt,\n\tess_audio1_halt,\n\tess_speaker_ctl,\n\tess_getdev,\n\tNULL,\n\tess_set_port,\n\tess_get_port,\n\tess_query_devinfo,\n\tess_malloc,\n\tess_free,\n\tess_round_buffersize,\n\tess_mappage,\n\tess_1888_get_props,\n\tess_audio2_trigger_output,\n\tess_audio1_trigger_input,\n};\n\nvoid\nessattach(sc)\n\tstruct ess_softc *sc;\n{\n\tstruct audio_attach_args arg;\n\tstruct audio_params pparams, rparams;\n\tint i;\n\tu_int v;\n\n\tif (ess_setup_sc(sc, 0)) {\n\t\tprintf(\": setup failed\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\": ESS Technology ES%s [version 0x%04x]\\n\", \n\t       essmodel[sc->sc_model], sc->sc_version);\n\n\tsc->sc_audio1.polled = sc->sc_audio1.irq == -1;\n\tif (!sc->sc_audio1.polled) {\n\t\tsc->sc_audio1.ih = isa_intr_establish(sc->sc_ic,\n\t\t    sc->sc_audio1.irq, sc->sc_audio1.ist, IPL_AUDIO,\n\t\t    ess_audio1_intr, sc, sc->sc_dev.dv_xname);\n\t\tprintf(\"%s: audio1 interrupting at irq %d\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_audio1.irq);\n\t} else\n\t\tprintf(\"%s: audio1 polled\\n\", sc->sc_dev.dv_xname);\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_audio1.drq,\n\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t       sc->sc_dev.dv_xname, sc->sc_audio1.drq);\n\t\treturn;\n\t}\n\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tsc->sc_audio2.polled = sc->sc_audio2.irq == -1;\n\t\tif (!sc->sc_audio2.polled) {\n\t\t\tsc->sc_audio2.ih = isa_intr_establish(sc->sc_ic,\n\t\t\t    sc->sc_audio2.irq, sc->sc_audio2.ist, IPL_AUDIO,\n\t\t\t    ess_audio2_intr, sc, sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: audio2 interrupting at irq %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->sc_audio2.irq);\n\t\t} else\n\t\t\tprintf(\"%s: audio2 polled\\n\", sc->sc_dev.dv_xname);\n\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_audio2.drq,\n\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t       sc->sc_dev.dv_xname, sc->sc_audio2.drq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* \n\t * Set record and play parameters to default values defined in\n\t * generic audio driver.\n\t */\n\tpparams = audio_default;\n\trparams = audio_default;\n\tess_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n\t/* Do a hardware reset on the mixer. */\n\tess_write_mix_reg(sc, ESS_MIX_RESET, ESS_MIX_RESET);\n\n\t/*\n\t * Set volume of Audio 1 to zero and disable Audio 1 DAC input\n\t * to playback mixer, since playback is always through Audio 2.\n\t */\n\tif (!ESS_USE_AUDIO1(sc->sc_model))\n\t\tess_write_mix_reg(sc, ESS_MREG_VOLUME_VOICE, 0);\n\tess_wdsp(sc, ESS_ACMD_DISABLE_SPKR);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ESS_SOURCE_MIC);\n\t\tsc->in_port = ESS_SOURCE_MIC;\n\t\tsc->ndevs = ESS_1788_NDEVS;\n\t} else {\n\t\t/*\n\t\t * Set hardware record source to use output of the record\n\t\t * mixer. We do the selection of record source in software by\n\t\t * setting the gain of the unused sources to zero. (See\n\t\t * ess_set_in_ports.)\n\t\t */\n\t\tess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ESS_SOURCE_MIXER);\n\t\tsc->in_mask = 1 << ESS_MIC_REC_VOL;\n\t\tsc->ndevs = ESS_1888_NDEVS;\n\t\tess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 0x10);\n\t\tess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 0x08);\n\t}\n\n\t/*\n\t * Set gain on each mixer device to a sensible value.\n\t * Devices not normally used are turned off, and other devices\n\t * are set to 50% volume.\n\t */\n\tfor (i = 0; i < sc->ndevs; i++) {\n\t\tswitch (i) {\n\t\tcase ESS_MIC_PLAY_VOL:\n\t\tcase ESS_LINE_PLAY_VOL:\n\t\tcase ESS_CD_PLAY_VOL:\n\t\tcase ESS_AUXB_PLAY_VOL:\n\t\tcase ESS_DAC_REC_VOL:\n\t\tcase ESS_LINE_REC_VOL:\n\t\tcase ESS_SYNTH_REC_VOL:\n\t\tcase ESS_CD_REC_VOL:\n\t\tcase ESS_AUXB_REC_VOL:\n\t\t\tv = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = ESS_4BIT_GAIN(AUDIO_MAX_GAIN / 2);\n\t\t\tbreak;\n\t\t}\n\t\tsc->gain[i][ESS_LEFT] = sc->gain[i][ESS_RIGHT] = v;\n\t\tess_set_gain(sc, i, 1);\n\t}\n\n\tess_setup(sc);\n\n\t/* Disable the speaker until the device is opened.  */\n\tess_speaker_off(sc);\n\tsc->spkr_state = SPKR_OFF;\n\n\tsprintf(ess_device.name, \"ES%s\", essmodel[sc->sc_model]);\n\tsprintf(ess_device.version, \"0x%04x\", sc->sc_version);\n\n\tif (ESS_USE_AUDIO1(sc->sc_model))\n\t\taudio_attach_mi(&ess_1788_hw_if, sc, &sc->sc_dev);\n\telse\n\t\taudio_attach_mi(&ess_1888_hw_if, sc, &sc->sc_dev);\n\n\targ.type = AUDIODEV_TYPE_OPL;\n\targ.hwif = 0;\n\targ.hdl = 0;\n\t(void)config_found(&sc->sc_dev, &arg, audioprint);\n\n#ifdef AUDIO_DEBUG\n\tif (essdebug > 0)\n\t\tess_printsc(sc);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "essmatch",
          "args": [
            "sc"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "essmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess.c",
          "lines": "801-877",
          "snippet": "int\nessmatch(sc)\n\tstruct ess_softc *sc;\n{\n\tif (!ESS_BASE_VALID(sc->sc_iobase)) {\n\t\tprintf(\"ess: configured iobase 0x%x invalid\\n\", sc->sc_iobase);\n\t\treturn (0);\n\t}\n\n\t/* Configure the ESS chip for the desired audio base address. */\n\tif (ess_config_addr(sc))\n\t\treturn (0);\n\n\tif (ess_setup_sc(sc, 1)) \n\t\treturn (0);\n\n\tif (sc->sc_model == ESS_UNSUPPORTED) {\n\t\tDPRINTF((\"ess: Unsupported model\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* Check that requested DMA channels are valid and different. */\n\tif (!ESS_DRQ1_VALID(sc->sc_audio1.drq)) {\n\t\tprintf(\"ess: record drq %d invalid\\n\", sc->sc_audio1.drq);\n\t\treturn (0);\n\t}\n\tif (!isa_drq_isfree(sc->sc_isa, sc->sc_audio1.drq))\n\t\treturn (0);\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tif (!ESS_DRQ2_VALID(sc->sc_audio2.drq)) {\n\t\t\tprintf(\"ess: play drq %d invalid\\n\", sc->sc_audio2.drq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (sc->sc_audio1.drq == sc->sc_audio2.drq) {\n\t\t\tprintf(\"ess: play and record drq both %d\\n\",\n\t\t\t       sc->sc_audio1.drq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (!isa_drq_isfree(sc->sc_isa, sc->sc_audio2.drq))\n\t\t\treturn (0);\n\t}\n\t\n\t/* \n\t * The 1887 has an additional IRQ mode where both channels are mapped\n\t * to the same IRQ.\n\t */\n\tif (sc->sc_model == ESS_1887 &&\n\t    sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t    sc->sc_audio1.irq != -1 &&\n\t    ESS_IRQ12_VALID(sc->sc_audio1.irq))\n\t\tgoto irq_not1888;\n\n\t/* Check that requested IRQ lines are valid and different. */\n\tif (sc->sc_audio1.irq != -1 &&\n\t    !ESS_IRQ1_VALID(sc->sc_audio1.irq)) {\n\t\tprintf(\"ess: record irq %d invalid\\n\", sc->sc_audio1.irq);\n\t\treturn (0);\n\t}\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tif (sc->sc_audio2.irq != -1 &&\n\t\t    !ESS_IRQ2_VALID(sc->sc_audio2.irq)) {\n\t\t\tprintf(\"ess: play irq %d invalid\\n\", sc->sc_audio2.irq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t\t    sc->sc_audio1.irq != -1) {\n\t\t\tprintf(\"ess: play and record irq both %d\\n\",\n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn (0);\n\t\t}\n\t}\n\nirq_not1888:\n\t/* XXX should we check IRQs as well? */\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/isa/essreg.h>",
            "#include <dev/isa/essvar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tess_setup_sc",
            "int\tess_config_addr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/essreg.h>\n#include <dev/isa/essvar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/mulaw.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tess_setup_sc;\nint\tess_config_addr;\n\nint\nessmatch(sc)\n\tstruct ess_softc *sc;\n{\n\tif (!ESS_BASE_VALID(sc->sc_iobase)) {\n\t\tprintf(\"ess: configured iobase 0x%x invalid\\n\", sc->sc_iobase);\n\t\treturn (0);\n\t}\n\n\t/* Configure the ESS chip for the desired audio base address. */\n\tif (ess_config_addr(sc))\n\t\treturn (0);\n\n\tif (ess_setup_sc(sc, 1)) \n\t\treturn (0);\n\n\tif (sc->sc_model == ESS_UNSUPPORTED) {\n\t\tDPRINTF((\"ess: Unsupported model\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* Check that requested DMA channels are valid and different. */\n\tif (!ESS_DRQ1_VALID(sc->sc_audio1.drq)) {\n\t\tprintf(\"ess: record drq %d invalid\\n\", sc->sc_audio1.drq);\n\t\treturn (0);\n\t}\n\tif (!isa_drq_isfree(sc->sc_isa, sc->sc_audio1.drq))\n\t\treturn (0);\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tif (!ESS_DRQ2_VALID(sc->sc_audio2.drq)) {\n\t\t\tprintf(\"ess: play drq %d invalid\\n\", sc->sc_audio2.drq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (sc->sc_audio1.drq == sc->sc_audio2.drq) {\n\t\t\tprintf(\"ess: play and record drq both %d\\n\",\n\t\t\t       sc->sc_audio1.drq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (!isa_drq_isfree(sc->sc_isa, sc->sc_audio2.drq))\n\t\t\treturn (0);\n\t}\n\t\n\t/* \n\t * The 1887 has an additional IRQ mode where both channels are mapped\n\t * to the same IRQ.\n\t */\n\tif (sc->sc_model == ESS_1887 &&\n\t    sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t    sc->sc_audio1.irq != -1 &&\n\t    ESS_IRQ12_VALID(sc->sc_audio1.irq))\n\t\tgoto irq_not1888;\n\n\t/* Check that requested IRQ lines are valid and different. */\n\tif (sc->sc_audio1.irq != -1 &&\n\t    !ESS_IRQ1_VALID(sc->sc_audio1.irq)) {\n\t\tprintf(\"ess: record irq %d invalid\\n\", sc->sc_audio1.irq);\n\t\treturn (0);\n\t}\n\tif (!ESS_USE_AUDIO1(sc->sc_model)) {\n\t\tif (sc->sc_audio2.irq != -1 &&\n\t\t    !ESS_IRQ2_VALID(sc->sc_audio2.irq)) {\n\t\t\tprintf(\"ess: play irq %d invalid\\n\", sc->sc_audio2.irq);\n\t\t\treturn (0);\n\t\t}\n\t\tif (sc->sc_audio1.irq == sc->sc_audio2.irq &&\n\t\t    sc->sc_audio1.irq != -1) {\n\t\t\tprintf(\"ess: play and record irq both %d\\n\",\n\t\t\t       sc->sc_audio1.irq);\n\t\t\treturn (0);\n\t\t}\n\t}\n\nirq_not1888:\n\t/* XXX should we check IRQs as well? */\n\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/essvar.h>\n#include <dev/isa/essreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid ess_isapnp_attach;\n\nvoid ess_isapnp_attach(parent, self, aux)\n\t struct device *parent, *self;\n\t void *aux;\n{\n\tstruct ess_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\n\tprintf(\"\\n\");\n\n\tsc->sc_ic = ia->ia_ic;\n\tsc->sc_iot = ia->ia_iot;\n\tsc->sc_ioh = ia->ipa_io[0].h;\n\tsc->sc_iobase = ia->ipa_io[0].base;\n\n\tsc->sc_audio1.irq = ia->ipa_irq[0].num;\n\tsc->sc_audio1.ist = ia->ipa_irq[0].type;\n\tsc->sc_audio1.drq = ia->ipa_drq[0].num;\n\tsc->sc_audio2.irq = ia->ipa_irq[0].num;\n\tsc->sc_audio2.ist = ia->ipa_irq[0].type;\n\tsc->sc_audio2.drq = ia->ipa_drq[1].num;\n\n\tsc->sc_isa = parent->dv_parent;\n\n\tif (!essmatch(sc)) {\n\t\tprintf(\"%s: essmatch failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tprintf(\"%s:\", sc->sc_dev.dv_xname);\n\n\tessattach(sc);\n}"
  },
  {
    "function_name": "ess_isapnp_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ess_isapnp.c",
    "lines": "66-72",
    "snippet": "int\ness_isapnp_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn 1;\n}",
    "includes": [
      "#include <dev/isa/essvar.h>",
      "#include <dev/isa/essreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ess_isapnp_probe"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/essvar.h>\n#include <dev/isa/essreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint ess_isapnp_probe;\n\nint\ness_isapnp_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn 1;\n}"
  }
]