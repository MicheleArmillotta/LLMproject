[
  {
    "function_name": "sk_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1723-1771",
    "snippet": "void sk_stop(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tint\t\t\ti;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = sc_if->sk_softc;\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* Turn off various components of this interface. */\n\tSK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);\n\n\t/* Disable interrupts */\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask &= ~SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask &= ~SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Free RX and TX mbufs still in the queues. */\n\tfor (i = 0; i < SK_RX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_rx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SK_TX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_tx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_IMR",
            "sc->sk_intrmask"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_1",
          "args": [
            "sc_if",
            "0",
            "SK_LINKLED1_CTL",
            "SK_LINKLED_LINKSYNC_OFF"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_1",
          "args": [
            "sc_if",
            "0",
            "SK_LINKLED1_CTL",
            "SK_LINKLED_OFF"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_1",
          "args": [
            "sc_if",
            "0",
            "SK_TXLED1_CTL",
            "SK_RXLEDCTL_COUNTER_STOP"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_1",
          "args": [
            "sc_if",
            "0",
            "SK_RXLED1_CTL",
            "SK_RXLEDCTL_COUNTER_STOP"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_1",
          "args": [
            "sc_if",
            "0",
            "SK_TXAR1_COUNTERCTL",
            "SK_TXARCTL_OFF"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXRBS1_CTLTST",
            "SK_RBCTL_RESET|SK_RBCTL_OFF"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXQS1_BMU_CSR",
            "SK_TXBMU_OFFLINE"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXRB1_CTLTST",
            "SK_RBCTL_RESET|SK_RBCTL_OFF"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXQ1_BMU_CSR",
            "SK_RXBMU_OFFLINE"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXF1_CTL",
            "SK_FIFO_RESET"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_2",
          "args": [
            "sc_if",
            "0",
            "SK_TXF1_MACCTL",
            "SK_TXMACCTL_XMAC_RESET"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_stop;\n\nvoid sk_stop(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tint\t\t\ti;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = sc_if->sk_softc;\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* Turn off various components of this interface. */\n\tSK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);\n\n\t/* Disable interrupts */\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask &= ~SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask &= ~SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Free RX and TX mbufs still in the queues. */\n\tfor (i = 0; i < SK_RX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_rx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SK_TX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_tx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1620-1721",
    "snippet": "void sk_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sk_if_softc\t*sc_if = xsc;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tifp = &sc_if->arpcom.ac_if;\n\tsc = sc_if->sk_softc;\n\n\t/* Cancel pending I/O and free all RX/TX buffers. */\n\tsk_stop(sc_if);\n\n\t/* Configure LINK_SYNC LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_ON);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_ON);\n\n\t/* Configure RX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_START);\n\n\t/* Configure TX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_TXLEDCTL_COUNTER_START);\n\n\t/* Configure I2C registers */\n\n\t/* Configure XMAC(s) */\n\tsk_init_xmac(sc_if);\n\n\t/* Configure MAC FIFOs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_ON);\n\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_ON);\n\n\t/* Configure transmit arbiter(s) */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL,\n\t    SK_TXARCTL_ON|SK_TXARCTL_FSYNC_ON);\n\n\t/* Configure RAMbuffers */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_START, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_WR_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_RD_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_END, sc_if->sk_rx_ramend);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_ON);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_STORENFWD_ON);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_START, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_WR_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_RD_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_END, sc_if->sk_tx_ramend);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_ON);\n\n\t/* Configure BMUs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_rx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_HI, 0);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_tx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_HI, 0);\n\n\t/* Init descriptors */\n\tif (sk_init_rx_ring(sc_if) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc_if->sk_dev.dv_xname);\n\t\tsk_stop(sc_if);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\tsk_init_tx_ring(sc_if);\n\n\t/* Configure interrupt handling */\n\tCSR_READ_4(sc, SK_ISSR);\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask |= SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask |= SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Start BMUs. */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_START);\n\n\t/* Enable XMACs TX and RX state machines */\n\tSK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_init",
      "void sk_init_xmac",
      "void sk_stop",
      "int sk_init_rx_ring",
      "void sk_init_tx_ring"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_2",
          "args": [
            "sc_if",
            "XM_MMUCMD",
            "XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXQ1_BMU_CSR",
            "SK_RXBMU_RX_START"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_IMR",
            "sc->sk_intrmask"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "SK_ISSR"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_init_tx_ring",
          "args": [
            "sc_if"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "sk_init_tx_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "508-541",
          "snippet": "void sk_init_tx_ring(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_chain_data\t*cd;\n\tstruct sk_ring_data\t*rd;\n\tint\t\t\ti;\n\n\tcd = &sc_if->sk_cdata;\n\trd = sc_if->sk_rdata;\n\n\tbzero((char *)sc_if->sk_rdata->sk_tx_ring,\n\t    sizeof(struct sk_tx_desc) * SK_TX_RING_CNT);\n\n\tfor (i = 0; i < SK_TX_RING_CNT; i++) {\n\t\tcd->sk_tx_chain[i].sk_desc = &rd->sk_tx_ring[i];\n\t\tif (i == (SK_TX_RING_CNT - 1)) {\n\t\t\tcd->sk_tx_chain[i].sk_next =\n\t\t\t    &cd->sk_tx_chain[0];\n\t\t\trd->sk_tx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_tx_ring[0]);\n\t\t} else {\n\t\t\tcd->sk_tx_chain[i].sk_next =\n\t\t\t    &cd->sk_tx_chain[i + 1];\n\t\t\trd->sk_tx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_tx_ring[i + 1]);\n\t\t}\n\t}\n\n\tsc_if->sk_cdata.sk_tx_prod = 0;\n\tsc_if->sk_cdata.sk_tx_cons = 0;\n\tsc_if->sk_cdata.sk_tx_cnt = 0;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_init_tx_ring"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_init_tx_ring;\n\nvoid sk_init_tx_ring(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_chain_data\t*cd;\n\tstruct sk_ring_data\t*rd;\n\tint\t\t\ti;\n\n\tcd = &sc_if->sk_cdata;\n\trd = sc_if->sk_rdata;\n\n\tbzero((char *)sc_if->sk_rdata->sk_tx_ring,\n\t    sizeof(struct sk_tx_desc) * SK_TX_RING_CNT);\n\n\tfor (i = 0; i < SK_TX_RING_CNT; i++) {\n\t\tcd->sk_tx_chain[i].sk_desc = &rd->sk_tx_ring[i];\n\t\tif (i == (SK_TX_RING_CNT - 1)) {\n\t\t\tcd->sk_tx_chain[i].sk_next =\n\t\t\t    &cd->sk_tx_chain[0];\n\t\t\trd->sk_tx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_tx_ring[0]);\n\t\t} else {\n\t\t\tcd->sk_tx_chain[i].sk_next =\n\t\t\t    &cd->sk_tx_chain[i + 1];\n\t\t\trd->sk_tx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_tx_ring[i + 1]);\n\t\t}\n\t}\n\n\tsc_if->sk_cdata.sk_tx_prod = 0;\n\tsc_if->sk_cdata.sk_tx_cons = 0;\n\tsc_if->sk_cdata.sk_tx_cnt = 0;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_stop",
          "args": [
            "sc_if"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "sk_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "1723-1771",
          "snippet": "void sk_stop(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tint\t\t\ti;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = sc_if->sk_softc;\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* Turn off various components of this interface. */\n\tSK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);\n\n\t/* Disable interrupts */\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask &= ~SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask &= ~SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Free RX and TX mbufs still in the queues. */\n\tfor (i = 0; i < SK_RX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_rx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SK_TX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_tx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_stop;\n\nvoid sk_stop(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tint\t\t\ti;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = sc_if->sk_softc;\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* Turn off various components of this interface. */\n\tSK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);\n\n\t/* Disable interrupts */\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask &= ~SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask &= ~SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Free RX and TX mbufs still in the queues. */\n\tfor (i = 0; i < SK_RX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_rx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SK_TX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_tx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\"",
            "sc_if->sk_dev.dv_xname"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_init_rx_ring",
          "args": [
            "sc_if"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "sk_init_rx_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "469-506",
          "snippet": "int sk_init_rx_ring(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_chain_data\t*cd;\n\tstruct sk_ring_data\t*rd;\n\tint\t\t\ti;\n\n\tcd = &sc_if->sk_cdata;\n\trd = sc_if->sk_rdata;\n\n\tbzero((char *)rd->sk_rx_ring,\n\t    sizeof(struct sk_rx_desc) * SK_RX_RING_CNT);\n\n\tfor (i = 0; i < SK_RX_RING_CNT; i++) {\n\t\tcd->sk_rx_chain[i].sk_desc = &rd->sk_rx_ring[i];\n\t\tif (sk_newbuf(sc_if, &cd->sk_rx_chain[i], NULL) == ENOBUFS) {\n\t\t\tprintf(\"%s: failed alloc of %dth mbuf\\n\",\n\t\t\t    sc_if->sk_dev.dv_xname, i);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tif (i == (SK_RX_RING_CNT - 1)) {\n\t\t\tcd->sk_rx_chain[i].sk_next =\n\t\t\t    &cd->sk_rx_chain[0];\n\t\t\trd->sk_rx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_rx_ring[0]);\n\t\t} else {\n\t\t\tcd->sk_rx_chain[i].sk_next =\n\t\t\t    &cd->sk_rx_chain[i + 1];\n\t\t\trd->sk_rx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_rx_ring[i + 1]);\n\t\t}\n\t}\n\n\tsc_if->sk_cdata.sk_rx_prod = 0;\n\tsc_if->sk_cdata.sk_rx_cons = 0;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sk_newbuf",
            "int sk_init_rx_ring"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_newbuf;\nint sk_init_rx_ring;\n\nint sk_init_rx_ring(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_chain_data\t*cd;\n\tstruct sk_ring_data\t*rd;\n\tint\t\t\ti;\n\n\tcd = &sc_if->sk_cdata;\n\trd = sc_if->sk_rdata;\n\n\tbzero((char *)rd->sk_rx_ring,\n\t    sizeof(struct sk_rx_desc) * SK_RX_RING_CNT);\n\n\tfor (i = 0; i < SK_RX_RING_CNT; i++) {\n\t\tcd->sk_rx_chain[i].sk_desc = &rd->sk_rx_ring[i];\n\t\tif (sk_newbuf(sc_if, &cd->sk_rx_chain[i], NULL) == ENOBUFS) {\n\t\t\tprintf(\"%s: failed alloc of %dth mbuf\\n\",\n\t\t\t    sc_if->sk_dev.dv_xname, i);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tif (i == (SK_RX_RING_CNT - 1)) {\n\t\t\tcd->sk_rx_chain[i].sk_next =\n\t\t\t    &cd->sk_rx_chain[0];\n\t\t\trd->sk_rx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_rx_ring[0]);\n\t\t} else {\n\t\t\tcd->sk_rx_chain[i].sk_next =\n\t\t\t    &cd->sk_rx_chain[i + 1];\n\t\t\trd->sk_rx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_rx_ring[i + 1]);\n\t\t}\n\t}\n\n\tsc_if->sk_cdata.sk_rx_prod = 0;\n\tsc_if->sk_cdata.sk_rx_cons = 0;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXQS1_CURADDR_HI",
            "0"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXQS1_CURADDR_LO",
            "vtophys(&sc_if->sk_rdata->sk_tx_ring[0])"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc_if->sk_rdata->sk_tx_ring[0]"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXQS1_BMU_CSR",
            "SK_TXBMU_ONLINE"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXQ1_CURADDR_HI",
            "0"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXQ1_CURADDR_LO",
            "vtophys(&sc_if->sk_rdata->sk_rx_ring[0])"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc_if->sk_rdata->sk_rx_ring[0]"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXQ1_BMU_CSR",
            "SK_RXBMU_ONLINE"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXRBS1_CTLTST",
            "SK_RBCTL_ON"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXRBS1_END",
            "sc_if->sk_tx_ramend"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXRBS1_RD_PTR",
            "sc_if->sk_tx_ramstart"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXRBS1_WR_PTR",
            "sc_if->sk_tx_ramstart"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXRBS1_START",
            "sc_if->sk_tx_ramstart"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXRBS1_CTLTST",
            "SK_RBCTL_STORENFWD_ON"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "1",
            "SK_TXRBS1_CTLTST",
            "SK_RBCTL_UNRESET"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXRB1_CTLTST",
            "SK_RBCTL_ON"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXRB1_END",
            "sc_if->sk_rx_ramend"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXRB1_RD_PTR",
            "sc_if->sk_rx_ramstart"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXRB1_WR_PTR",
            "sc_if->sk_rx_ramstart"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXRB1_START",
            "sc_if->sk_rx_ramstart"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXRB1_CTLTST",
            "SK_RBCTL_UNRESET"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_1",
          "args": [
            "sc_if",
            "0",
            "SK_TXAR1_COUNTERCTL",
            "SK_TXARCTL_ON|SK_TXARCTL_FSYNC_ON"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_TXF1_CTL",
            "SK_FIFO_ON"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_TXF1_END",
            "SK_FIFO_END"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_TXF1_CTL",
            "SK_FIFO_UNRESET"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXF1_CTL",
            "SK_FIFO_ON"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXF1_END",
            "SK_FIFO_END"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_4",
          "args": [
            "sc_if",
            "0",
            "SK_RXF1_CTL",
            "SK_FIFO_UNRESET"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_init_xmac",
          "args": [
            "sc_if"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "sk_init_xmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "1502-1614",
          "snippet": "void sk_init_xmac(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = sc_if->sk_softc;\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* Unreset the XMAC. */\n\tSK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_UNRESET);\n\tDELAY(1000);\n\n\t/* Save the XMAC II revision */\n\tsc_if->sk_xmac_rev = XM_XMAC_REV(SK_XM_READ_4(sc_if, XM_DEVID));\n\n\t/* Set station address */\n\tSK_XM_WRITE_2(sc_if, XM_PAR0,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[0]));\n\tSK_XM_WRITE_2(sc_if, XM_PAR1,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[2]));\n\tSK_XM_WRITE_2(sc_if, XM_PAR2,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[4]));\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_STATION);\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);\n\t} else {\n\t\tSK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);\n\t} else {\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);\n\t}\n\n\t/* We don't need the FCS appended to the packet. */\n\tSK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_STRIPFCS);\n\n\t/* We want short frames padded to 60 bytes. */\n\tSK_XM_SETBIT_2(sc_if, XM_TXCMD, XM_TXCMD_AUTOPAD);\n\n\t/*\n\t * Enable the reception of all error frames. This is is\n\t * a necessary evil due to the design of the XMAC. The\n\t * XMAC's receive FIFO is only 8K in size, however jumbo\n\t * frames can be up to 9000 bytes in length. When bad\n\t * frame filtering is enabled, the XMAC's RX FIFO operates\n\t * in 'store and forward' mode. For this to work, the\n\t * entire frame has to fit into the FIFO, but that means\n\t * that jumbo frames larger than 8192 bytes will be\n\t * truncated. Disabling all bad frame filtering causes\n\t * the RX FIFO to operate in streaming mode, in which\n\t * case the XMAC will start transfering frames out of the\n\t * RX FIFO as soon as the FIFO threshold is reached.\n\t */\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_BADFRAMES|\n\t    XM_MODE_RX_GIANTS|XM_MODE_RX_RUNTS|XM_MODE_RX_CRCERRS|\n\t    XM_MODE_RX_INRANGELEN);\n\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tSK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);\n\telse\n\t\tSK_XM_CLRBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);\n\n\t/*\n\t * Bump up the transmit threshold. This helps hold off transmit\n\t * underruns when we're blasting traffic from both ports at once.\n\t */\n\tSK_XM_WRITE_2(sc_if, XM_TX_REQTHRESH, SK_XM_TX_FIFOTHRESH);\n\n\t/* Set multicast filter */\n\tsk_setmulti(sc_if);\n\n\t/* Clear and enable interrupts */\n\tSK_XM_READ_2(sc_if, XM_ISR);\n\tSK_XM_WRITE_2(sc_if, XM_IMR, XM_INTRS);\n\n\tsc_if->sk_link = 0;\n\n\t/* Configure MAC arbiter */\n\tswitch(sc_if->sk_xmac_rev) {\n\tcase XM_XMAC_REV_B2:\n\t\tsk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);\n\t\tbreak;\n\tcase XM_XMAC_REV_C1:\n\t\tsk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tsk_win_write_2(sc, SK_MACARB_CTL,\n\t    SK_MACARBCTL_UNRESET|SK_MACARBCTL_FASTOE_OFF);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_init_xmac",
            "void sk_win_write_2",
            "void sk_win_write_1",
            "void sk_setmulti"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_init_xmac;\nvoid sk_win_write_2;\nvoid sk_win_write_1;\nvoid sk_setmulti;\n\nvoid sk_init_xmac(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = sc_if->sk_softc;\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* Unreset the XMAC. */\n\tSK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_UNRESET);\n\tDELAY(1000);\n\n\t/* Save the XMAC II revision */\n\tsc_if->sk_xmac_rev = XM_XMAC_REV(SK_XM_READ_4(sc_if, XM_DEVID));\n\n\t/* Set station address */\n\tSK_XM_WRITE_2(sc_if, XM_PAR0,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[0]));\n\tSK_XM_WRITE_2(sc_if, XM_PAR1,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[2]));\n\tSK_XM_WRITE_2(sc_if, XM_PAR2,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[4]));\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_STATION);\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);\n\t} else {\n\t\tSK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);\n\t} else {\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);\n\t}\n\n\t/* We don't need the FCS appended to the packet. */\n\tSK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_STRIPFCS);\n\n\t/* We want short frames padded to 60 bytes. */\n\tSK_XM_SETBIT_2(sc_if, XM_TXCMD, XM_TXCMD_AUTOPAD);\n\n\t/*\n\t * Enable the reception of all error frames. This is is\n\t * a necessary evil due to the design of the XMAC. The\n\t * XMAC's receive FIFO is only 8K in size, however jumbo\n\t * frames can be up to 9000 bytes in length. When bad\n\t * frame filtering is enabled, the XMAC's RX FIFO operates\n\t * in 'store and forward' mode. For this to work, the\n\t * entire frame has to fit into the FIFO, but that means\n\t * that jumbo frames larger than 8192 bytes will be\n\t * truncated. Disabling all bad frame filtering causes\n\t * the RX FIFO to operate in streaming mode, in which\n\t * case the XMAC will start transfering frames out of the\n\t * RX FIFO as soon as the FIFO threshold is reached.\n\t */\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_BADFRAMES|\n\t    XM_MODE_RX_GIANTS|XM_MODE_RX_RUNTS|XM_MODE_RX_CRCERRS|\n\t    XM_MODE_RX_INRANGELEN);\n\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tSK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);\n\telse\n\t\tSK_XM_CLRBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);\n\n\t/*\n\t * Bump up the transmit threshold. This helps hold off transmit\n\t * underruns when we're blasting traffic from both ports at once.\n\t */\n\tSK_XM_WRITE_2(sc_if, XM_TX_REQTHRESH, SK_XM_TX_FIFOTHRESH);\n\n\t/* Set multicast filter */\n\tsk_setmulti(sc_if);\n\n\t/* Clear and enable interrupts */\n\tSK_XM_READ_2(sc_if, XM_ISR);\n\tSK_XM_WRITE_2(sc_if, XM_IMR, XM_INTRS);\n\n\tsc_if->sk_link = 0;\n\n\t/* Configure MAC arbiter */\n\tswitch(sc_if->sk_xmac_rev) {\n\tcase XM_XMAC_REV_B2:\n\t\tsk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);\n\t\tbreak;\n\tcase XM_XMAC_REV_C1:\n\t\tsk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tsk_win_write_2(sc, SK_MACARB_CTL,\n\t    SK_MACARBCTL_UNRESET|SK_MACARBCTL_FASTOE_OFF);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_1",
          "args": [
            "sc_if",
            "0",
            "SK_TXLED1_CTL",
            "SK_TXLEDCTL_COUNTER_START"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_1",
          "args": [
            "sc_if",
            "0",
            "SK_RXLED1_CTL",
            "SK_RXLEDCTL_COUNTER_START"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_1",
          "args": [
            "sc_if",
            "0",
            "SK_LINKLED1_CTL",
            "SK_LINKLED_LINKSYNC_ON"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_1",
          "args": [
            "sc_if",
            "0",
            "SK_LINKLED1_CTL",
            "SK_LINKLED_ON"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_init;\nvoid sk_init_xmac;\nvoid sk_stop;\nint sk_init_rx_ring;\nvoid sk_init_tx_ring;\n\nvoid sk_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sk_if_softc\t*sc_if = xsc;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tifp = &sc_if->arpcom.ac_if;\n\tsc = sc_if->sk_softc;\n\n\t/* Cancel pending I/O and free all RX/TX buffers. */\n\tsk_stop(sc_if);\n\n\t/* Configure LINK_SYNC LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_ON);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_ON);\n\n\t/* Configure RX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_START);\n\n\t/* Configure TX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_TXLEDCTL_COUNTER_START);\n\n\t/* Configure I2C registers */\n\n\t/* Configure XMAC(s) */\n\tsk_init_xmac(sc_if);\n\n\t/* Configure MAC FIFOs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_ON);\n\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_ON);\n\n\t/* Configure transmit arbiter(s) */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL,\n\t    SK_TXARCTL_ON|SK_TXARCTL_FSYNC_ON);\n\n\t/* Configure RAMbuffers */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_START, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_WR_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_RD_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_END, sc_if->sk_rx_ramend);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_ON);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_STORENFWD_ON);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_START, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_WR_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_RD_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_END, sc_if->sk_tx_ramend);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_ON);\n\n\t/* Configure BMUs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_rx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_HI, 0);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_tx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_HI, 0);\n\n\t/* Init descriptors */\n\tif (sk_init_rx_ring(sc_if) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc_if->sk_dev.dv_xname);\n\t\tsk_stop(sc_if);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\tsk_init_tx_ring(sc_if);\n\n\t/* Configure interrupt handling */\n\tCSR_READ_4(sc, SK_ISSR);\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask |= SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask |= SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Start BMUs. */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_START);\n\n\t/* Enable XMACs TX and RX state machines */\n\tSK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_init_xmac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1502-1614",
    "snippet": "void sk_init_xmac(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = sc_if->sk_softc;\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* Unreset the XMAC. */\n\tSK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_UNRESET);\n\tDELAY(1000);\n\n\t/* Save the XMAC II revision */\n\tsc_if->sk_xmac_rev = XM_XMAC_REV(SK_XM_READ_4(sc_if, XM_DEVID));\n\n\t/* Set station address */\n\tSK_XM_WRITE_2(sc_if, XM_PAR0,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[0]));\n\tSK_XM_WRITE_2(sc_if, XM_PAR1,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[2]));\n\tSK_XM_WRITE_2(sc_if, XM_PAR2,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[4]));\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_STATION);\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);\n\t} else {\n\t\tSK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);\n\t} else {\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);\n\t}\n\n\t/* We don't need the FCS appended to the packet. */\n\tSK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_STRIPFCS);\n\n\t/* We want short frames padded to 60 bytes. */\n\tSK_XM_SETBIT_2(sc_if, XM_TXCMD, XM_TXCMD_AUTOPAD);\n\n\t/*\n\t * Enable the reception of all error frames. This is is\n\t * a necessary evil due to the design of the XMAC. The\n\t * XMAC's receive FIFO is only 8K in size, however jumbo\n\t * frames can be up to 9000 bytes in length. When bad\n\t * frame filtering is enabled, the XMAC's RX FIFO operates\n\t * in 'store and forward' mode. For this to work, the\n\t * entire frame has to fit into the FIFO, but that means\n\t * that jumbo frames larger than 8192 bytes will be\n\t * truncated. Disabling all bad frame filtering causes\n\t * the RX FIFO to operate in streaming mode, in which\n\t * case the XMAC will start transfering frames out of the\n\t * RX FIFO as soon as the FIFO threshold is reached.\n\t */\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_BADFRAMES|\n\t    XM_MODE_RX_GIANTS|XM_MODE_RX_RUNTS|XM_MODE_RX_CRCERRS|\n\t    XM_MODE_RX_INRANGELEN);\n\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tSK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);\n\telse\n\t\tSK_XM_CLRBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);\n\n\t/*\n\t * Bump up the transmit threshold. This helps hold off transmit\n\t * underruns when we're blasting traffic from both ports at once.\n\t */\n\tSK_XM_WRITE_2(sc_if, XM_TX_REQTHRESH, SK_XM_TX_FIFOTHRESH);\n\n\t/* Set multicast filter */\n\tsk_setmulti(sc_if);\n\n\t/* Clear and enable interrupts */\n\tSK_XM_READ_2(sc_if, XM_ISR);\n\tSK_XM_WRITE_2(sc_if, XM_IMR, XM_INTRS);\n\n\tsc_if->sk_link = 0;\n\n\t/* Configure MAC arbiter */\n\tswitch(sc_if->sk_xmac_rev) {\n\tcase XM_XMAC_REV_B2:\n\t\tsk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);\n\t\tbreak;\n\tcase XM_XMAC_REV_C1:\n\t\tsk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tsk_win_write_2(sc, SK_MACARB_CTL,\n\t    SK_MACARBCTL_UNRESET|SK_MACARBCTL_FASTOE_OFF);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_init_xmac",
      "void sk_win_write_2",
      "void sk_win_write_1",
      "void sk_setmulti"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sk_win_write_2",
          "args": [
            "sc",
            "SK_MACARB_CTL",
            "SK_MACARBCTL_UNRESET|SK_MACARBCTL_FASTOE_OFF"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "sk_win_write_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "209-217",
          "snippet": "void sk_win_write_2(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), (u_int32_t)val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_win_write_2"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_win_write_2;\n\nvoid sk_win_write_2(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), (u_int32_t)val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_win_write_1",
          "args": [
            "sc",
            "SK_RECOVERY_CTL",
            "SK_RECOVERY_XMAC_B2"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "sk_win_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "219-227",
          "snippet": "void sk_win_write_1(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_1(sc, SK_WIN_BASE + SK_REG(reg), val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_win_write_1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_win_write_1;\n\nvoid sk_win_write_1(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_1(sc, SK_WIN_BASE + SK_REG(reg), val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "XM_IMR",
            "XM_INTRS"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_READ_2",
          "args": [
            "sc_if",
            "XM_ISR"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_setmulti",
          "args": [
            "sc_if"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "sk_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "406-467",
          "snippet": "void\nsk_setmulti(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct ifnet *ifp;\n\tu_int32_t hashes[2] = { 0, 0 };\n\tint h, i;\n\tstruct arpcom *ac = &sc_if->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t dummy[] = { 0, 0, 0, 0, 0 ,0 };\n\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < XM_RXFILT_MAX; i++)\n\t\tsk_setfilt(sc_if, (caddr_t)&dummy, i);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, 0);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, 0);\n\n\t/* Now program new ones. */\nallmulti:\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\t/* First find the tail of the list. */\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tgoto allmulti;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Program the first XM_RXFILT_MAX multicast groups\n\t\t\t * into the perfect filter. For all others,\n\t\t\t * use the hash table.\n\t\t\t */\n\t\t\tif (i < XM_RXFILT_MAX) {\n\t\t\t\tsk_setfilt(sc_if, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\th = sk_calchash(enm->enm_addrlo);\n\t\t\t\tif (h < 32)\n\t\t\t\t\thashes[0] |= (1 << h);\n\t\t\t\telse\n\t\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t}\n\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_HASH|\n\t    XM_MODE_RX_USE_PERFECT);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t sk_calchash",
            "void sk_setfilt",
            "void sk_setmulti"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t sk_calchash;\nvoid sk_setfilt;\nvoid sk_setmulti;\n\nvoid\nsk_setmulti(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct ifnet *ifp;\n\tu_int32_t hashes[2] = { 0, 0 };\n\tint h, i;\n\tstruct arpcom *ac = &sc_if->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t dummy[] = { 0, 0, 0, 0, 0 ,0 };\n\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < XM_RXFILT_MAX; i++)\n\t\tsk_setfilt(sc_if, (caddr_t)&dummy, i);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, 0);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, 0);\n\n\t/* Now program new ones. */\nallmulti:\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\t/* First find the tail of the list. */\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tgoto allmulti;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Program the first XM_RXFILT_MAX multicast groups\n\t\t\t * into the perfect filter. For all others,\n\t\t\t * use the hash table.\n\t\t\t */\n\t\t\tif (i < XM_RXFILT_MAX) {\n\t\t\t\tsk_setfilt(sc_if, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\th = sk_calchash(enm->enm_addrlo);\n\t\t\t\tif (h < 32)\n\t\t\t\t\thashes[0] |= (1 << h);\n\t\t\t\telse\n\t\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t}\n\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_HASH|\n\t    XM_MODE_RX_USE_PERFECT);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "XM_TX_REQTHRESH",
            "SK_XM_TX_FIFOTHRESH"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_CLRBIT_2",
          "args": [
            "sc_if",
            "XM_RXCMD",
            "XM_RXCMD_BIGPKTOK"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_2",
          "args": [
            "sc_if",
            "XM_RXCMD",
            "XM_RXCMD_BIGPKTOK"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_RX_BADFRAMES|\n\t    XM_MODE_RX_GIANTS|XM_MODE_RX_RUNTS|XM_MODE_RX_CRCERRS|\n\t    XM_MODE_RX_INRANGELEN"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_2",
          "args": [
            "sc_if",
            "XM_TXCMD",
            "XM_TXCMD_AUTOPAD"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_2",
          "args": [
            "sc_if",
            "XM_RXCMD",
            "XM_RXCMD_STRIPFCS"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_RX_NOBROAD"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_CLRBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_RX_NOBROAD"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_CLRBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_RX_PROMISC"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_RX_PROMISC"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_RX_USE_STATION"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "XM_PAR2",
            "*(u_int16_t *)(&sc_if->arpcom.ac_enaddr[4])"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "XM_PAR1",
            "*(u_int16_t *)(&sc_if->arpcom.ac_enaddr[2])"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "XM_PAR0",
            "*(u_int16_t *)(&sc_if->arpcom.ac_enaddr[0])"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XM_XMAC_REV",
          "args": [
            "SK_XM_READ_4(sc_if, XM_DEVID)"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_READ_4",
          "args": [
            "sc_if",
            "XM_DEVID"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_IF_WRITE_2",
          "args": [
            "sc_if",
            "0",
            "SK_TXF1_MACCTL",
            "SK_TXMACCTL_XMAC_UNRESET"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_init_xmac;\nvoid sk_win_write_2;\nvoid sk_win_write_1;\nvoid sk_setmulti;\n\nvoid sk_init_xmac(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = sc_if->sk_softc;\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* Unreset the XMAC. */\n\tSK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_UNRESET);\n\tDELAY(1000);\n\n\t/* Save the XMAC II revision */\n\tsc_if->sk_xmac_rev = XM_XMAC_REV(SK_XM_READ_4(sc_if, XM_DEVID));\n\n\t/* Set station address */\n\tSK_XM_WRITE_2(sc_if, XM_PAR0,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[0]));\n\tSK_XM_WRITE_2(sc_if, XM_PAR1,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[2]));\n\tSK_XM_WRITE_2(sc_if, XM_PAR2,\n\t    *(u_int16_t *)(&sc_if->arpcom.ac_enaddr[4]));\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_STATION);\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);\n\t} else {\n\t\tSK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_PROMISC);\n\t}\n\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\tSK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);\n\t} else {\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);\n\t}\n\n\t/* We don't need the FCS appended to the packet. */\n\tSK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_STRIPFCS);\n\n\t/* We want short frames padded to 60 bytes. */\n\tSK_XM_SETBIT_2(sc_if, XM_TXCMD, XM_TXCMD_AUTOPAD);\n\n\t/*\n\t * Enable the reception of all error frames. This is is\n\t * a necessary evil due to the design of the XMAC. The\n\t * XMAC's receive FIFO is only 8K in size, however jumbo\n\t * frames can be up to 9000 bytes in length. When bad\n\t * frame filtering is enabled, the XMAC's RX FIFO operates\n\t * in 'store and forward' mode. For this to work, the\n\t * entire frame has to fit into the FIFO, but that means\n\t * that jumbo frames larger than 8192 bytes will be\n\t * truncated. Disabling all bad frame filtering causes\n\t * the RX FIFO to operate in streaming mode, in which\n\t * case the XMAC will start transfering frames out of the\n\t * RX FIFO as soon as the FIFO threshold is reached.\n\t */\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_BADFRAMES|\n\t    XM_MODE_RX_GIANTS|XM_MODE_RX_RUNTS|XM_MODE_RX_CRCERRS|\n\t    XM_MODE_RX_INRANGELEN);\n\n\tif (ifp->if_mtu > (ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN))\n\t\tSK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);\n\telse\n\t\tSK_XM_CLRBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);\n\n\t/*\n\t * Bump up the transmit threshold. This helps hold off transmit\n\t * underruns when we're blasting traffic from both ports at once.\n\t */\n\tSK_XM_WRITE_2(sc_if, XM_TX_REQTHRESH, SK_XM_TX_FIFOTHRESH);\n\n\t/* Set multicast filter */\n\tsk_setmulti(sc_if);\n\n\t/* Clear and enable interrupts */\n\tSK_XM_READ_2(sc_if, XM_ISR);\n\tSK_XM_WRITE_2(sc_if, XM_IMR, XM_INTRS);\n\n\tsc_if->sk_link = 0;\n\n\t/* Configure MAC arbiter */\n\tswitch(sc_if->sk_xmac_rev) {\n\tcase XM_XMAC_REV_B2:\n\t\tsk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_B2);\n\t\tsk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);\n\t\tbreak;\n\tcase XM_XMAC_REV_C1:\n\t\tsk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_C1);\n\t\tsk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tsk_win_write_2(sc, SK_MACARB_CTL,\n\t    SK_MACARBCTL_UNRESET|SK_MACARBCTL_FASTOE_OFF);\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1436-1500",
    "snippet": "int sk_intr(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sk_softc\t\t*sc = xsc;\n\tstruct sk_if_softc\t*sc_if0 = NULL, *sc_if1 = NULL;\n\tstruct ifnet\t\t*ifp0 = NULL, *ifp1 = NULL;\n\tu_int32_t\t\tstatus;\n\tint\t\t\tclaimed = 0;\n\n\tsc_if0 = sc->sk_if[SK_PORT_A];\n\tsc_if1 = sc->sk_if[SK_PORT_B];\n\n\tif (sc_if0 != NULL)\n\t\tifp0 = &sc_if0->arpcom.ac_if;\n\tif (sc_if1 != NULL)\n\t\tifp1 = &sc_if0->arpcom.ac_if;\n\n\tfor (;;) {\n\t\tstatus = CSR_READ_4(sc, SK_ISSR);\n\t\tif (!(status & sc->sk_intrmask))\n\t\t\tbreak;\n\n\t\tclaimed = 1;\n\n\t\t/* Handle receive interrupts first. */\n\t\tif (status & SK_ISR_RX1_EOF) {\n\t\t\tsk_rxeof(sc_if0);\n\t\t\tCSR_WRITE_4(sc, SK_BMU_RX_CSR0,\n\t\t\t    SK_RXBMU_CLR_IRQ_EOF|SK_RXBMU_RX_START);\n\t\t}\n\t\tif (status & SK_ISR_RX2_EOF) {\n\t\t\tsk_rxeof(sc_if1);\n\t\t\tCSR_WRITE_4(sc, SK_BMU_RX_CSR1,\n\t\t\t    SK_RXBMU_CLR_IRQ_EOF|SK_RXBMU_RX_START);\n\t\t}\n\n\t\t/* Then transmit interrupts. */\n\t\tif (status & SK_ISR_TX1_S_EOF) {\n\t\t\tsk_txeof(sc_if0);\n\t\t\tCSR_WRITE_4(sc, SK_BMU_TXS_CSR0,\n\t\t\t    SK_TXBMU_CLR_IRQ_EOF);\n\t\t}\n\t\tif (status & SK_ISR_TX2_S_EOF) {\n\t\t\tsk_txeof(sc_if1);\n\t\t\tCSR_WRITE_4(sc, SK_BMU_TXS_CSR1,\n\t\t\t    SK_TXBMU_CLR_IRQ_EOF);\n\t\t}\n\n\t\t/* Then MAC interrupts. */\n\t\tif (status & SK_ISR_MAC1)\n\t\t\tsk_intr_xmac(sc_if0);\n\n\t\tif (status & SK_ISR_MAC2)\n\t\t\tsk_intr_xmac(sc_if1);\n\t}\n\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\tif (ifp0 != NULL && ifp0->if_snd.ifq_head != NULL)\n\t\tsk_start(ifp0);\n\tif (ifp1 != NULL && ifp1->if_snd.ifq_head != NULL)\n\t\tsk_start(ifp1);\n\n\treturn (claimed);\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sk_intr",
      "void sk_intr_xmac",
      "void sk_rxeof",
      "void sk_txeof",
      "void sk_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sk_start",
          "args": [
            "ifp1"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "sk_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "1213-1260",
          "snippet": "void sk_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n        struct sk_softc\t\t*sc;\n        struct sk_if_softc\t*sc_if;\n        struct mbuf\t\t*m_head = NULL;\n        u_int32_t\t\tidx;\n\n\tsc_if = ifp->if_softc;\n\tsc = sc_if->sk_softc;\n\n\tidx = sc_if->sk_cdata.sk_tx_prod;\n\n\twhile(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Pack the data into the transmit ring. If we\n\t\t * don't have room, set the OACTIVE flag and wait\n\t\t * for the NIC to drain the ring.\n\t\t */\n\t\tif (sk_encap(sc_if, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc_if->sk_cdata.sk_tx_prod = idx;\n\tCSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_START);\n\n\t/* Set a timeout in case the chip goes out to lunch. */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sk_encap",
            "void sk_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_encap;\nvoid sk_start;\n\nvoid sk_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n        struct sk_softc\t\t*sc;\n        struct sk_if_softc\t*sc_if;\n        struct mbuf\t\t*m_head = NULL;\n        u_int32_t\t\tidx;\n\n\tsc_if = ifp->if_softc;\n\tsc = sc_if->sk_softc;\n\n\tidx = sc_if->sk_cdata.sk_tx_prod;\n\n\twhile(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Pack the data into the transmit ring. If we\n\t\t * don't have room, set the OACTIVE flag and wait\n\t\t * for the NIC to drain the ring.\n\t\t */\n\t\tif (sk_encap(sc_if, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc_if->sk_cdata.sk_tx_prod = idx;\n\tCSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_START);\n\n\t/* Set a timeout in case the chip goes out to lunch. */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_IMR",
            "sc->sk_intrmask"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_intr_xmac",
          "args": [
            "sc_if1"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "sk_intr_xmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "1403-1434",
          "snippet": "void sk_intr_xmac(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_softc\t\t*sc;\n\tu_int16_t\t\tstatus;\n\tu_int16_t\t\tbmsr;\n\n\tsc = sc_if->sk_softc;\n\tstatus = SK_XM_READ_2(sc_if, XM_ISR);\n\n\tif (status & XM_ISR_LINKEVENT) {\n\t\tSK_XM_SETBIT_2(sc_if, XM_IMR, XM_IMR_LINKEVENT);\n\t\tif (sc_if->sk_link == 1)\n\t\t\tsc_if->sk_link = 0;\n\t}\n\n\tif (status & XM_ISR_AUTONEG_DONE) {\n\t\tbmsr = sk_phy_readreg(sc_if, XM_PHY_BMSR);\n\t\tif (bmsr & XM_BMSR_LINKSTAT) {\n\t\t\tsc_if->sk_link = 1;\n\t\t\tSK_XM_CLRBIT_2(sc_if, XM_IMR, XM_IMR_LINKEVENT);\n\t\t}\n\t}\n\n\tif (status & XM_IMR_TX_UNDERRUN)\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_TXFIFO);\n\n\tif (status & XM_IMR_RX_OVERRUN)\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_RXFIFO);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_intr_xmac",
            "u_int16_t sk_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_intr_xmac;\nu_int16_t sk_phy_readreg;\n\nvoid sk_intr_xmac(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_softc\t\t*sc;\n\tu_int16_t\t\tstatus;\n\tu_int16_t\t\tbmsr;\n\n\tsc = sc_if->sk_softc;\n\tstatus = SK_XM_READ_2(sc_if, XM_ISR);\n\n\tif (status & XM_ISR_LINKEVENT) {\n\t\tSK_XM_SETBIT_2(sc_if, XM_IMR, XM_IMR_LINKEVENT);\n\t\tif (sc_if->sk_link == 1)\n\t\t\tsc_if->sk_link = 0;\n\t}\n\n\tif (status & XM_ISR_AUTONEG_DONE) {\n\t\tbmsr = sk_phy_readreg(sc_if, XM_PHY_BMSR);\n\t\tif (bmsr & XM_BMSR_LINKSTAT) {\n\t\t\tsc_if->sk_link = 1;\n\t\t\tSK_XM_CLRBIT_2(sc_if, XM_IMR, XM_IMR_LINKEVENT);\n\t\t}\n\t}\n\n\tif (status & XM_IMR_TX_UNDERRUN)\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_TXFIFO);\n\n\tif (status & XM_IMR_RX_OVERRUN)\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_RXFIFO);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_BMU_TXS_CSR1",
            "SK_TXBMU_CLR_IRQ_EOF"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_txeof",
          "args": [
            "sc_if1"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "sk_txeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "1366-1401",
          "snippet": "void sk_txeof(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_tx_desc\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tidx;\n\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/*\n\t * Go through our tx ring and free mbufs for those\n\t * frames that have been sent.\n\t */\n\tidx = sc_if->sk_cdata.sk_tx_cons;\n\twhile(idx != sc_if->sk_cdata.sk_tx_prod) {\n\t\tcur_tx = &sc_if->sk_rdata->sk_tx_ring[idx];\n\t\tif (cur_tx->sk_ctl & SK_TXCTL_OWN)\n\t\t\tbreak;\n\t\tif (cur_tx->sk_ctl & SK_TXCTL_LASTFRAG)\n\t\t\tifp->if_opackets++;\n\t\tif (sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf = NULL;\n\t\t}\n\t\tsc_if->sk_cdata.sk_tx_cnt--;\n\t\tSK_INC(idx, SK_TX_RING_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc_if->sk_cdata.sk_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_txeof"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_txeof;\n\nvoid sk_txeof(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_tx_desc\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tidx;\n\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/*\n\t * Go through our tx ring and free mbufs for those\n\t * frames that have been sent.\n\t */\n\tidx = sc_if->sk_cdata.sk_tx_cons;\n\twhile(idx != sc_if->sk_cdata.sk_tx_prod) {\n\t\tcur_tx = &sc_if->sk_rdata->sk_tx_ring[idx];\n\t\tif (cur_tx->sk_ctl & SK_TXCTL_OWN)\n\t\t\tbreak;\n\t\tif (cur_tx->sk_ctl & SK_TXCTL_LASTFRAG)\n\t\t\tifp->if_opackets++;\n\t\tif (sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf = NULL;\n\t\t}\n\t\tsc_if->sk_cdata.sk_tx_cnt--;\n\t\tSK_INC(idx, SK_TX_RING_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc_if->sk_cdata.sk_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_BMU_TXS_CSR0",
            "SK_TXBMU_CLR_IRQ_EOF"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_BMU_RX_CSR1",
            "SK_RXBMU_CLR_IRQ_EOF|SK_RXBMU_RX_START"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_rxeof",
          "args": [
            "sc_if1"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "sk_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "1293-1364",
          "snippet": "void sk_rxeof(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct sk_chain\t\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tint\t\t\ti;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc_if->arpcom.ac_if;\n\ti = sc_if->sk_cdata.sk_rx_prod;\n\tcur_rx = &sc_if->sk_cdata.sk_rx_chain[i];\n\n\twhile(!(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl & SK_RXCTL_OWN)) {\n\n\t\tcur_rx = &sc_if->sk_cdata.sk_rx_chain[i];\n\t\trxstat = sc_if->sk_rdata->sk_rx_ring[i].sk_xmac_rxstat;\n\t\tm = cur_rx->sk_mbuf;\n\t\tcur_rx->sk_mbuf = NULL;\n\t\ttotal_len = SK_RXBYTES(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl);\n\t\tSK_INC(i, SK_RX_RING_CNT);\n\n\t\tif (rxstat & XM_RXSTAT_ERRFRAME) {\n\t\t\tifp->if_ierrors++;\n\t\t\tsk_newbuf(sc_if, cur_rx, m);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Try to allocate a new jumbo buffer. If that\n\t\t * fails, copy the packet to mbufs and put the\n\t\t * jumbo buffer back in the ring so it can be\n\t\t * re-used. If allocating mbufs fails, then we\n\t\t * have to drop the packet.\n\t\t */\n\t\tif (sk_newbuf(sc_if, cur_rx, NULL) == ENOBUFS) {\n\t\t\tstruct mbuf\t\t*m0;\n\t\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t\t    total_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tsk_newbuf(sc_if, cur_rx, m);\n\t\t\tif (m0 == NULL) {\n\t\t\t\tprintf(\"%s: no receive buffers \"\n\t\t\t\t    \"available -- packet dropped!\\n\",\n\t\t\t\t    sc_if->sk_dev.dv_xname);\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_adj(m0, ETHER_ALIGN);\n\t\t\tm = m0;\n\t\t} else {\n\t\t\tm->m_pkthdr.rcvif = ifp;\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\tsc_if->sk_cdata.sk_rx_prod = i;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_rxeof",
            "int sk_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_rxeof;\nint sk_newbuf;\n\nvoid sk_rxeof(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct sk_chain\t\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tint\t\t\ti;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc_if->arpcom.ac_if;\n\ti = sc_if->sk_cdata.sk_rx_prod;\n\tcur_rx = &sc_if->sk_cdata.sk_rx_chain[i];\n\n\twhile(!(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl & SK_RXCTL_OWN)) {\n\n\t\tcur_rx = &sc_if->sk_cdata.sk_rx_chain[i];\n\t\trxstat = sc_if->sk_rdata->sk_rx_ring[i].sk_xmac_rxstat;\n\t\tm = cur_rx->sk_mbuf;\n\t\tcur_rx->sk_mbuf = NULL;\n\t\ttotal_len = SK_RXBYTES(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl);\n\t\tSK_INC(i, SK_RX_RING_CNT);\n\n\t\tif (rxstat & XM_RXSTAT_ERRFRAME) {\n\t\t\tifp->if_ierrors++;\n\t\t\tsk_newbuf(sc_if, cur_rx, m);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Try to allocate a new jumbo buffer. If that\n\t\t * fails, copy the packet to mbufs and put the\n\t\t * jumbo buffer back in the ring so it can be\n\t\t * re-used. If allocating mbufs fails, then we\n\t\t * have to drop the packet.\n\t\t */\n\t\tif (sk_newbuf(sc_if, cur_rx, NULL) == ENOBUFS) {\n\t\t\tstruct mbuf\t\t*m0;\n\t\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t\t    total_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tsk_newbuf(sc_if, cur_rx, m);\n\t\t\tif (m0 == NULL) {\n\t\t\t\tprintf(\"%s: no receive buffers \"\n\t\t\t\t    \"available -- packet dropped!\\n\",\n\t\t\t\t    sc_if->sk_dev.dv_xname);\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_adj(m0, ETHER_ALIGN);\n\t\t\tm = m0;\n\t\t} else {\n\t\t\tm->m_pkthdr.rcvif = ifp;\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\tsc_if->sk_cdata.sk_rx_prod = i;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_BMU_RX_CSR0",
            "SK_RXBMU_CLR_IRQ_EOF|SK_RXBMU_RX_START"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "SK_ISSR"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_intr;\nvoid sk_intr_xmac;\nvoid sk_rxeof;\nvoid sk_txeof;\nvoid sk_start;\n\nint sk_intr(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sk_softc\t\t*sc = xsc;\n\tstruct sk_if_softc\t*sc_if0 = NULL, *sc_if1 = NULL;\n\tstruct ifnet\t\t*ifp0 = NULL, *ifp1 = NULL;\n\tu_int32_t\t\tstatus;\n\tint\t\t\tclaimed = 0;\n\n\tsc_if0 = sc->sk_if[SK_PORT_A];\n\tsc_if1 = sc->sk_if[SK_PORT_B];\n\n\tif (sc_if0 != NULL)\n\t\tifp0 = &sc_if0->arpcom.ac_if;\n\tif (sc_if1 != NULL)\n\t\tifp1 = &sc_if0->arpcom.ac_if;\n\n\tfor (;;) {\n\t\tstatus = CSR_READ_4(sc, SK_ISSR);\n\t\tif (!(status & sc->sk_intrmask))\n\t\t\tbreak;\n\n\t\tclaimed = 1;\n\n\t\t/* Handle receive interrupts first. */\n\t\tif (status & SK_ISR_RX1_EOF) {\n\t\t\tsk_rxeof(sc_if0);\n\t\t\tCSR_WRITE_4(sc, SK_BMU_RX_CSR0,\n\t\t\t    SK_RXBMU_CLR_IRQ_EOF|SK_RXBMU_RX_START);\n\t\t}\n\t\tif (status & SK_ISR_RX2_EOF) {\n\t\t\tsk_rxeof(sc_if1);\n\t\t\tCSR_WRITE_4(sc, SK_BMU_RX_CSR1,\n\t\t\t    SK_RXBMU_CLR_IRQ_EOF|SK_RXBMU_RX_START);\n\t\t}\n\n\t\t/* Then transmit interrupts. */\n\t\tif (status & SK_ISR_TX1_S_EOF) {\n\t\t\tsk_txeof(sc_if0);\n\t\t\tCSR_WRITE_4(sc, SK_BMU_TXS_CSR0,\n\t\t\t    SK_TXBMU_CLR_IRQ_EOF);\n\t\t}\n\t\tif (status & SK_ISR_TX2_S_EOF) {\n\t\t\tsk_txeof(sc_if1);\n\t\t\tCSR_WRITE_4(sc, SK_BMU_TXS_CSR1,\n\t\t\t    SK_TXBMU_CLR_IRQ_EOF);\n\t\t}\n\n\t\t/* Then MAC interrupts. */\n\t\tif (status & SK_ISR_MAC1)\n\t\t\tsk_intr_xmac(sc_if0);\n\n\t\tif (status & SK_ISR_MAC2)\n\t\t\tsk_intr_xmac(sc_if1);\n\t}\n\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\tif (ifp0 != NULL && ifp0->if_snd.ifq_head != NULL)\n\t\tsk_start(ifp0);\n\tif (ifp1 != NULL && ifp1->if_snd.ifq_head != NULL)\n\t\tsk_start(ifp1);\n\n\treturn (claimed);\n}"
  },
  {
    "function_name": "sk_intr_xmac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1403-1434",
    "snippet": "void sk_intr_xmac(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_softc\t\t*sc;\n\tu_int16_t\t\tstatus;\n\tu_int16_t\t\tbmsr;\n\n\tsc = sc_if->sk_softc;\n\tstatus = SK_XM_READ_2(sc_if, XM_ISR);\n\n\tif (status & XM_ISR_LINKEVENT) {\n\t\tSK_XM_SETBIT_2(sc_if, XM_IMR, XM_IMR_LINKEVENT);\n\t\tif (sc_if->sk_link == 1)\n\t\t\tsc_if->sk_link = 0;\n\t}\n\n\tif (status & XM_ISR_AUTONEG_DONE) {\n\t\tbmsr = sk_phy_readreg(sc_if, XM_PHY_BMSR);\n\t\tif (bmsr & XM_BMSR_LINKSTAT) {\n\t\t\tsc_if->sk_link = 1;\n\t\t\tSK_XM_CLRBIT_2(sc_if, XM_IMR, XM_IMR_LINKEVENT);\n\t\t}\n\t}\n\n\tif (status & XM_IMR_TX_UNDERRUN)\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_TXFIFO);\n\n\tif (status & XM_IMR_RX_OVERRUN)\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_RXFIFO);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_intr_xmac",
      "u_int16_t sk_phy_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_FLUSH_RXFIFO"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_FLUSH_TXFIFO"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_CLRBIT_2",
          "args": [
            "sc_if",
            "XM_IMR",
            "XM_IMR_LINKEVENT"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_phy_readreg",
          "args": [
            "sc_if",
            "XM_PHY_BMSR"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "sk_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "319-338",
          "snippet": "u_int16_t sk_phy_readreg(sc_if, reg)\n\tstruct sk_if_softc\t*sc_if;\n\tint\t\t\treg;\n{\n\tint\t\t\ti;\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT) {\n\t\tprintf(\"%s: phy failed to come ready\\n\",\n\t\t    sc_if->sk_dev.dv_xname);\n\t\treturn(0);\n\t}\n\n\treturn(SK_XM_READ_2(sc_if, XM_PHY_DATA));\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t sk_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t sk_phy_readreg;\n\nu_int16_t sk_phy_readreg(sc_if, reg)\n\tstruct sk_if_softc\t*sc_if;\n\tint\t\t\treg;\n{\n\tint\t\t\ti;\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT) {\n\t\tprintf(\"%s: phy failed to come ready\\n\",\n\t\t    sc_if->sk_dev.dv_xname);\n\t\treturn(0);\n\t}\n\n\treturn(SK_XM_READ_2(sc_if, XM_PHY_DATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_2",
          "args": [
            "sc_if",
            "XM_IMR",
            "XM_IMR_LINKEVENT"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_READ_2",
          "args": [
            "sc_if",
            "XM_ISR"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_intr_xmac;\nu_int16_t sk_phy_readreg;\n\nvoid sk_intr_xmac(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_softc\t\t*sc;\n\tu_int16_t\t\tstatus;\n\tu_int16_t\t\tbmsr;\n\n\tsc = sc_if->sk_softc;\n\tstatus = SK_XM_READ_2(sc_if, XM_ISR);\n\n\tif (status & XM_ISR_LINKEVENT) {\n\t\tSK_XM_SETBIT_2(sc_if, XM_IMR, XM_IMR_LINKEVENT);\n\t\tif (sc_if->sk_link == 1)\n\t\t\tsc_if->sk_link = 0;\n\t}\n\n\tif (status & XM_ISR_AUTONEG_DONE) {\n\t\tbmsr = sk_phy_readreg(sc_if, XM_PHY_BMSR);\n\t\tif (bmsr & XM_BMSR_LINKSTAT) {\n\t\t\tsc_if->sk_link = 1;\n\t\t\tSK_XM_CLRBIT_2(sc_if, XM_IMR, XM_IMR_LINKEVENT);\n\t\t}\n\t}\n\n\tif (status & XM_IMR_TX_UNDERRUN)\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_TXFIFO);\n\n\tif (status & XM_IMR_RX_OVERRUN)\n\t\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_RXFIFO);\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1366-1401",
    "snippet": "void sk_txeof(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_tx_desc\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tidx;\n\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/*\n\t * Go through our tx ring and free mbufs for those\n\t * frames that have been sent.\n\t */\n\tidx = sc_if->sk_cdata.sk_tx_cons;\n\twhile(idx != sc_if->sk_cdata.sk_tx_prod) {\n\t\tcur_tx = &sc_if->sk_rdata->sk_tx_ring[idx];\n\t\tif (cur_tx->sk_ctl & SK_TXCTL_OWN)\n\t\t\tbreak;\n\t\tif (cur_tx->sk_ctl & SK_TXCTL_LASTFRAG)\n\t\t\tifp->if_opackets++;\n\t\tif (sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf = NULL;\n\t\t}\n\t\tsc_if->sk_cdata.sk_tx_cnt--;\n\t\tSK_INC(idx, SK_TX_RING_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc_if->sk_cdata.sk_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_txeof"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SK_INC",
          "args": [
            "idx",
            "SK_TX_RING_CNT"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_txeof;\n\nvoid sk_txeof(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_tx_desc\t*cur_tx = NULL;\n\tstruct ifnet\t\t*ifp;\n\tu_int32_t\t\tidx;\n\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/*\n\t * Go through our tx ring and free mbufs for those\n\t * frames that have been sent.\n\t */\n\tidx = sc_if->sk_cdata.sk_tx_cons;\n\twhile(idx != sc_if->sk_cdata.sk_tx_prod) {\n\t\tcur_tx = &sc_if->sk_rdata->sk_tx_ring[idx];\n\t\tif (cur_tx->sk_ctl & SK_TXCTL_OWN)\n\t\t\tbreak;\n\t\tif (cur_tx->sk_ctl & SK_TXCTL_LASTFRAG)\n\t\t\tifp->if_opackets++;\n\t\tif (sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf = NULL;\n\t\t}\n\t\tsc_if->sk_cdata.sk_tx_cnt--;\n\t\tSK_INC(idx, SK_TX_RING_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc_if->sk_cdata.sk_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1293-1364",
    "snippet": "void sk_rxeof(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct sk_chain\t\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tint\t\t\ti;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc_if->arpcom.ac_if;\n\ti = sc_if->sk_cdata.sk_rx_prod;\n\tcur_rx = &sc_if->sk_cdata.sk_rx_chain[i];\n\n\twhile(!(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl & SK_RXCTL_OWN)) {\n\n\t\tcur_rx = &sc_if->sk_cdata.sk_rx_chain[i];\n\t\trxstat = sc_if->sk_rdata->sk_rx_ring[i].sk_xmac_rxstat;\n\t\tm = cur_rx->sk_mbuf;\n\t\tcur_rx->sk_mbuf = NULL;\n\t\ttotal_len = SK_RXBYTES(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl);\n\t\tSK_INC(i, SK_RX_RING_CNT);\n\n\t\tif (rxstat & XM_RXSTAT_ERRFRAME) {\n\t\t\tifp->if_ierrors++;\n\t\t\tsk_newbuf(sc_if, cur_rx, m);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Try to allocate a new jumbo buffer. If that\n\t\t * fails, copy the packet to mbufs and put the\n\t\t * jumbo buffer back in the ring so it can be\n\t\t * re-used. If allocating mbufs fails, then we\n\t\t * have to drop the packet.\n\t\t */\n\t\tif (sk_newbuf(sc_if, cur_rx, NULL) == ENOBUFS) {\n\t\t\tstruct mbuf\t\t*m0;\n\t\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t\t    total_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tsk_newbuf(sc_if, cur_rx, m);\n\t\t\tif (m0 == NULL) {\n\t\t\t\tprintf(\"%s: no receive buffers \"\n\t\t\t\t    \"available -- packet dropped!\\n\",\n\t\t\t\t    sc_if->sk_dev.dv_xname);\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_adj(m0, ETHER_ALIGN);\n\t\t\tm = m0;\n\t\t} else {\n\t\t\tm->m_pkthdr.rcvif = ifp;\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\tsc_if->sk_cdata.sk_rx_prod = i;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_rxeof",
      "int sk_newbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m0",
            "ETHER_ALIGN"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no receive buffers \"\n\t\t\t\t    \"available -- packet dropped!\\n\"",
            "sc_if->sk_dev.dv_xname"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_newbuf",
          "args": [
            "sc_if",
            "cur_rx",
            "m"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "sk_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "543-589",
          "snippet": "int sk_newbuf(sc_if, c, m)\n\tstruct sk_if_softc\t*sc_if;\n\tstruct sk_chain\t\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct sk_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc_if->sk_dev.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t} else {\n\t\t/*\n\t \t * We're re-using a previously allocated mbuf;\n\t\t * be sure to re-init pointers and lengths to\n\t\t * default values.\n\t\t */\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/*\n\t * Adjust alignment so packet payload begins on a\n\t * longword boundary. Mandatory for Alpha, useful on\n\t * x86 too.\n\t */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tr = c->sk_desc;\n\tc->sk_mbuf = m_new;\n\tr->sk_data_lo = vtophys(mtod(m_new, caddr_t));\n\tr->sk_ctl = m_new->m_len | SK_RXSTAT;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sk_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_newbuf;\n\nint sk_newbuf(sc_if, c, m)\n\tstruct sk_if_softc\t*sc_if;\n\tstruct sk_chain\t\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct sk_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc_if->sk_dev.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t} else {\n\t\t/*\n\t \t * We're re-using a previously allocated mbuf;\n\t\t * be sure to re-init pointers and lengths to\n\t\t * default values.\n\t\t */\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/*\n\t * Adjust alignment so packet payload begins on a\n\t * longword boundary. Mandatory for Alpha, useful on\n\t * x86 too.\n\t */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tr = c->sk_desc;\n\tc->sk_mbuf = m_new;\n\tr->sk_data_lo = vtophys(mtod(m_new, caddr_t));\n\tr->sk_ctl = m_new->m_len | SK_RXSTAT;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_devget",
          "args": [
            "mtod(m, char *) - ETHER_ALIGN",
            "total_len + ETHER_ALIGN",
            "0",
            "ifp",
            "NULL"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "char*"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_INC",
          "args": [
            "i",
            "SK_RX_RING_CNT"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_RXBYTES",
          "args": [
            "sc_if->sk_rdata->sk_rx_ring[i].sk_ctl"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_rxeof;\nint sk_newbuf;\n\nvoid sk_rxeof(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct ether_header\t*eh;\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\tstruct sk_chain\t\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tint\t\t\ti;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc_if->arpcom.ac_if;\n\ti = sc_if->sk_cdata.sk_rx_prod;\n\tcur_rx = &sc_if->sk_cdata.sk_rx_chain[i];\n\n\twhile(!(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl & SK_RXCTL_OWN)) {\n\n\t\tcur_rx = &sc_if->sk_cdata.sk_rx_chain[i];\n\t\trxstat = sc_if->sk_rdata->sk_rx_ring[i].sk_xmac_rxstat;\n\t\tm = cur_rx->sk_mbuf;\n\t\tcur_rx->sk_mbuf = NULL;\n\t\ttotal_len = SK_RXBYTES(sc_if->sk_rdata->sk_rx_ring[i].sk_ctl);\n\t\tSK_INC(i, SK_RX_RING_CNT);\n\n\t\tif (rxstat & XM_RXSTAT_ERRFRAME) {\n\t\t\tifp->if_ierrors++;\n\t\t\tsk_newbuf(sc_if, cur_rx, m);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Try to allocate a new jumbo buffer. If that\n\t\t * fails, copy the packet to mbufs and put the\n\t\t * jumbo buffer back in the ring so it can be\n\t\t * re-used. If allocating mbufs fails, then we\n\t\t * have to drop the packet.\n\t\t */\n\t\tif (sk_newbuf(sc_if, cur_rx, NULL) == ENOBUFS) {\n\t\t\tstruct mbuf\t\t*m0;\n\t\t\tm0 = m_devget(mtod(m, char *) - ETHER_ALIGN,\n\t\t\t    total_len + ETHER_ALIGN, 0, ifp, NULL);\n\t\t\tsk_newbuf(sc_if, cur_rx, m);\n\t\t\tif (m0 == NULL) {\n\t\t\t\tprintf(\"%s: no receive buffers \"\n\t\t\t\t    \"available -- packet dropped!\\n\",\n\t\t\t\t    sc_if->sk_dev.dv_xname);\n\t\t\t\tifp->if_ierrors++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tm_adj(m0, ETHER_ALIGN);\n\t\t\tm = m0;\n\t\t} else {\n\t\t\tm->m_pkthdr.rcvif = ifp;\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\tsc_if->sk_cdata.sk_rx_prod = i;\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1276-1291",
    "snippet": "void sk_shutdown(v)\n\tvoid *v;\n{\n\tstruct sk_softc\t\t*sc = v;\n\n\t/* Turn off the 'driver is loaded' LED. */\n\tCSR_WRITE_2(sc, SK_LED, SK_LED_GREEN_OFF);\n\n\t/*\n\t * Reset the GEnesis controller. Doing this should also\n\t * assert the resets on the attached XMAC(s).\n\t */\n\tsk_reset(sc);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_shutdown",
      "void sk_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sk_reset",
          "args": [
            "sc"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "sk_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "770-803",
          "snippet": "void sk_reset(sc)\n\tstruct sk_softc\t\t*sc;\n{\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_RESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_RESET);\n\tDELAY(1000);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_UNRESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_UNRESET);\n\n\t/* Configure packet arbiter */\n\tsk_win_write_2(sc, SK_PKTARB_CTL, SK_PKTARBCTL_UNRESET);\n\tsk_win_write_2(sc, SK_RXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_RXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\n\t/* Enable RAM interface */\n\tsk_win_write_4(sc, SK_RAMCTL, SK_RAMCTL_UNRESET);\n\n\t/*\n         * Configure interrupt moderation. The moderation timer\n\t * defers interrupts specified in the interrupt moderation\n\t * timer mask based on the timeout specified in the interrupt\n\t * moderation timer init register. Each bit in the timer\n\t * register represents 18.825ns, so to specify a timeout in\n\t * microseconds, we have to multiply by 54.\n\t */\n        sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(200));\n        sk_win_write_4(sc, SK_IMMR, SK_ISR_TX1_S_EOF|SK_ISR_TX2_S_EOF|\n\t    SK_ISR_RX1_EOF|SK_ISR_RX2_EOF);\n        sk_win_write_1(sc, SK_IMTIMERCTL, SK_IMCTL_START);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_reset",
            "void sk_win_write_4",
            "void sk_win_write_2",
            "void sk_win_write_1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_reset;\nvoid sk_win_write_4;\nvoid sk_win_write_2;\nvoid sk_win_write_1;\n\nvoid sk_reset(sc)\n\tstruct sk_softc\t\t*sc;\n{\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_RESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_RESET);\n\tDELAY(1000);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_UNRESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_UNRESET);\n\n\t/* Configure packet arbiter */\n\tsk_win_write_2(sc, SK_PKTARB_CTL, SK_PKTARBCTL_UNRESET);\n\tsk_win_write_2(sc, SK_RXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_RXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\n\t/* Enable RAM interface */\n\tsk_win_write_4(sc, SK_RAMCTL, SK_RAMCTL_UNRESET);\n\n\t/*\n         * Configure interrupt moderation. The moderation timer\n\t * defers interrupts specified in the interrupt moderation\n\t * timer mask based on the timeout specified in the interrupt\n\t * moderation timer init register. Each bit in the timer\n\t * register represents 18.825ns, so to specify a timeout in\n\t * microseconds, we have to multiply by 54.\n\t */\n        sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(200));\n        sk_win_write_4(sc, SK_IMMR, SK_ISR_TX1_S_EOF|SK_ISR_TX2_S_EOF|\n\t    SK_ISR_RX1_EOF|SK_ISR_RX2_EOF);\n        sk_win_write_1(sc, SK_IMTIMERCTL, SK_IMCTL_START);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "SK_LED",
            "SK_LED_GREEN_OFF"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_shutdown;\nvoid sk_reset;\n\nvoid sk_shutdown(v)\n\tvoid *v;\n{\n\tstruct sk_softc\t\t*sc = v;\n\n\t/* Turn off the 'driver is loaded' LED. */\n\tCSR_WRITE_2(sc, SK_LED, SK_LED_GREEN_OFF);\n\n\t/*\n\t * Reset the GEnesis controller. Doing this should also\n\t * assert the resets on the attached XMAC(s).\n\t */\n\tsk_reset(sc);\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1263-1274",
    "snippet": "void sk_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sk_if_softc\t*sc_if;\n\n\tsc_if = ifp->if_softc;\n\n\tprintf(\"%s: watchdog timeout\\n\", sc_if->sk_dev.dv_xname);\n\tsk_init(sc_if);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_init",
      "void sk_watchdog"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sk_init",
          "args": [
            "sc_if"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "sk_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "1620-1721",
          "snippet": "void sk_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sk_if_softc\t*sc_if = xsc;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tifp = &sc_if->arpcom.ac_if;\n\tsc = sc_if->sk_softc;\n\n\t/* Cancel pending I/O and free all RX/TX buffers. */\n\tsk_stop(sc_if);\n\n\t/* Configure LINK_SYNC LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_ON);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_ON);\n\n\t/* Configure RX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_START);\n\n\t/* Configure TX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_TXLEDCTL_COUNTER_START);\n\n\t/* Configure I2C registers */\n\n\t/* Configure XMAC(s) */\n\tsk_init_xmac(sc_if);\n\n\t/* Configure MAC FIFOs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_ON);\n\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_ON);\n\n\t/* Configure transmit arbiter(s) */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL,\n\t    SK_TXARCTL_ON|SK_TXARCTL_FSYNC_ON);\n\n\t/* Configure RAMbuffers */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_START, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_WR_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_RD_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_END, sc_if->sk_rx_ramend);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_ON);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_STORENFWD_ON);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_START, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_WR_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_RD_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_END, sc_if->sk_tx_ramend);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_ON);\n\n\t/* Configure BMUs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_rx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_HI, 0);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_tx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_HI, 0);\n\n\t/* Init descriptors */\n\tif (sk_init_rx_ring(sc_if) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc_if->sk_dev.dv_xname);\n\t\tsk_stop(sc_if);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\tsk_init_tx_ring(sc_if);\n\n\t/* Configure interrupt handling */\n\tCSR_READ_4(sc, SK_ISSR);\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask |= SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask |= SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Start BMUs. */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_START);\n\n\t/* Enable XMACs TX and RX state machines */\n\tSK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_init",
            "void sk_init_xmac",
            "void sk_stop",
            "int sk_init_rx_ring",
            "void sk_init_tx_ring"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_init;\nvoid sk_init_xmac;\nvoid sk_stop;\nint sk_init_rx_ring;\nvoid sk_init_tx_ring;\n\nvoid sk_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sk_if_softc\t*sc_if = xsc;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tifp = &sc_if->arpcom.ac_if;\n\tsc = sc_if->sk_softc;\n\n\t/* Cancel pending I/O and free all RX/TX buffers. */\n\tsk_stop(sc_if);\n\n\t/* Configure LINK_SYNC LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_ON);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_ON);\n\n\t/* Configure RX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_START);\n\n\t/* Configure TX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_TXLEDCTL_COUNTER_START);\n\n\t/* Configure I2C registers */\n\n\t/* Configure XMAC(s) */\n\tsk_init_xmac(sc_if);\n\n\t/* Configure MAC FIFOs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_ON);\n\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_ON);\n\n\t/* Configure transmit arbiter(s) */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL,\n\t    SK_TXARCTL_ON|SK_TXARCTL_FSYNC_ON);\n\n\t/* Configure RAMbuffers */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_START, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_WR_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_RD_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_END, sc_if->sk_rx_ramend);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_ON);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_STORENFWD_ON);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_START, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_WR_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_RD_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_END, sc_if->sk_tx_ramend);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_ON);\n\n\t/* Configure BMUs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_rx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_HI, 0);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_tx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_HI, 0);\n\n\t/* Init descriptors */\n\tif (sk_init_rx_ring(sc_if) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc_if->sk_dev.dv_xname);\n\t\tsk_stop(sc_if);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\tsk_init_tx_ring(sc_if);\n\n\t/* Configure interrupt handling */\n\tCSR_READ_4(sc, SK_ISSR);\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask |= SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask |= SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Start BMUs. */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_START);\n\n\t/* Enable XMACs TX and RX state machines */\n\tSK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: watchdog timeout\\n\"",
            "sc_if->sk_dev.dv_xname"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_init;\nvoid sk_watchdog;\n\nvoid sk_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sk_if_softc\t*sc_if;\n\n\tsc_if = ifp->if_softc;\n\n\tprintf(\"%s: watchdog timeout\\n\", sc_if->sk_dev.dv_xname);\n\tsk_init(sc_if);\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1213-1260",
    "snippet": "void sk_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n        struct sk_softc\t\t*sc;\n        struct sk_if_softc\t*sc_if;\n        struct mbuf\t\t*m_head = NULL;\n        u_int32_t\t\tidx;\n\n\tsc_if = ifp->if_softc;\n\tsc = sc_if->sk_softc;\n\n\tidx = sc_if->sk_cdata.sk_tx_prod;\n\n\twhile(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Pack the data into the transmit ring. If we\n\t\t * don't have room, set the OACTIVE flag and wait\n\t\t * for the NIC to drain the ring.\n\t\t */\n\t\tif (sk_encap(sc_if, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc_if->sk_cdata.sk_tx_prod = idx;\n\tCSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_START);\n\n\t/* Set a timeout in case the chip goes out to lunch. */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sk_encap",
      "void sk_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "sc_if->sk_tx_bmu",
            "SK_TXBMU_TX_START"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m_head"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_encap",
          "args": [
            "sc_if",
            "m_head",
            "&idx"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "sk_encap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "1164-1211",
          "snippet": "int sk_encap(sc_if, m_head, txidx)\n        struct sk_if_softc\t*sc_if;\n        struct mbuf\t\t*m_head;\n        u_int32_t\t\t*txidx;\n{\n\tstruct sk_tx_desc\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tu_int32_t\t\tfrag, cur, cnt = 0;\n\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\t/*\n\t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n\t * of fragments or hit the end of the mbuf chain.\n\t */\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif ((SK_TX_RING_CNT -\n\t\t\t    (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2)\n\t\t\t\treturn(ENOBUFS);\n\t\t\tf = &sc_if->sk_rdata->sk_tx_ring[frag];\n\t\t\tf->sk_data_lo = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->sk_ctl = m->m_len | SK_OPCODE_DEFAULT;\n\t\t\tif (cnt == 0)\n\t\t\t\tf->sk_ctl |= SK_TXCTL_FIRSTFRAG;\n\t\t\telse\n\t\t\t\tf->sk_ctl |= SK_TXCTL_OWN;\n\t\t\tcur = frag;\n\t\t\tSK_INC(frag, SK_TX_RING_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tsc_if->sk_rdata->sk_tx_ring[cur].sk_ctl |=\n\t\tSK_TXCTL_LASTFRAG|SK_TXCTL_EOF_INTR;\n\tsc_if->sk_cdata.sk_tx_chain[cur].sk_mbuf = m_head;\n\tsc_if->sk_rdata->sk_tx_ring[*txidx].sk_ctl |= SK_TXCTL_OWN;\n\tsc_if->sk_cdata.sk_tx_cnt += cnt;\n\n\t*txidx = frag;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sk_encap"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_encap;\n\nint sk_encap(sc_if, m_head, txidx)\n        struct sk_if_softc\t*sc_if;\n        struct mbuf\t\t*m_head;\n        u_int32_t\t\t*txidx;\n{\n\tstruct sk_tx_desc\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tu_int32_t\t\tfrag, cur, cnt = 0;\n\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\t/*\n\t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n\t * of fragments or hit the end of the mbuf chain.\n\t */\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif ((SK_TX_RING_CNT -\n\t\t\t    (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2)\n\t\t\t\treturn(ENOBUFS);\n\t\t\tf = &sc_if->sk_rdata->sk_tx_ring[frag];\n\t\t\tf->sk_data_lo = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->sk_ctl = m->m_len | SK_OPCODE_DEFAULT;\n\t\t\tif (cnt == 0)\n\t\t\t\tf->sk_ctl |= SK_TXCTL_FIRSTFRAG;\n\t\t\telse\n\t\t\t\tf->sk_ctl |= SK_TXCTL_OWN;\n\t\t\tcur = frag;\n\t\t\tSK_INC(frag, SK_TX_RING_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tsc_if->sk_rdata->sk_tx_ring[cur].sk_ctl |=\n\t\tSK_TXCTL_LASTFRAG|SK_TXCTL_EOF_INTR;\n\tsc_if->sk_cdata.sk_tx_chain[cur].sk_mbuf = m_head;\n\tsc_if->sk_rdata->sk_tx_ring[*txidx].sk_ctl |= SK_TXCTL_OWN;\n\tsc_if->sk_cdata.sk_tx_cnt += cnt;\n\n\t*txidx = frag;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_encap;\nvoid sk_start;\n\nvoid sk_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n        struct sk_softc\t\t*sc;\n        struct sk_if_softc\t*sc_if;\n        struct mbuf\t\t*m_head = NULL;\n        u_int32_t\t\tidx;\n\n\tsc_if = ifp->if_softc;\n\tsc = sc_if->sk_softc;\n\n\tidx = sc_if->sk_cdata.sk_tx_prod;\n\n\twhile(sc_if->sk_cdata.sk_tx_chain[idx].sk_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Pack the data into the transmit ring. If we\n\t\t * don't have room, set the OACTIVE flag and wait\n\t\t * for the NIC to drain the ring.\n\t\t */\n\t\tif (sk_encap(sc_if, m_head, &idx)) {\n\t\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m_head);\n#endif\n\t}\n\n\t/* Transmit */\n\tsc_if->sk_cdata.sk_tx_prod = idx;\n\tCSR_WRITE_4(sc, sc_if->sk_tx_bmu, SK_TXBMU_TX_START);\n\n\t/* Set a timeout in case the chip goes out to lunch. */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_encap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "1164-1211",
    "snippet": "int sk_encap(sc_if, m_head, txidx)\n        struct sk_if_softc\t*sc_if;\n        struct mbuf\t\t*m_head;\n        u_int32_t\t\t*txidx;\n{\n\tstruct sk_tx_desc\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tu_int32_t\t\tfrag, cur, cnt = 0;\n\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\t/*\n\t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n\t * of fragments or hit the end of the mbuf chain.\n\t */\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif ((SK_TX_RING_CNT -\n\t\t\t    (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2)\n\t\t\t\treturn(ENOBUFS);\n\t\t\tf = &sc_if->sk_rdata->sk_tx_ring[frag];\n\t\t\tf->sk_data_lo = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->sk_ctl = m->m_len | SK_OPCODE_DEFAULT;\n\t\t\tif (cnt == 0)\n\t\t\t\tf->sk_ctl |= SK_TXCTL_FIRSTFRAG;\n\t\t\telse\n\t\t\t\tf->sk_ctl |= SK_TXCTL_OWN;\n\t\t\tcur = frag;\n\t\t\tSK_INC(frag, SK_TX_RING_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tsc_if->sk_rdata->sk_tx_ring[cur].sk_ctl |=\n\t\tSK_TXCTL_LASTFRAG|SK_TXCTL_EOF_INTR;\n\tsc_if->sk_cdata.sk_tx_chain[cur].sk_mbuf = m_head;\n\tsc_if->sk_rdata->sk_tx_ring[*txidx].sk_ctl |= SK_TXCTL_OWN;\n\tsc_if->sk_cdata.sk_tx_cnt += cnt;\n\n\t*txidx = frag;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sk_encap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SK_INC",
          "args": [
            "frag",
            "SK_TX_RING_CNT"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m, vm_offset_t)"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "vm_offset_t"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_encap;\n\nint sk_encap(sc_if, m_head, txidx)\n        struct sk_if_softc\t*sc_if;\n        struct mbuf\t\t*m_head;\n        u_int32_t\t\t*txidx;\n{\n\tstruct sk_tx_desc\t*f = NULL;\n\tstruct mbuf\t\t*m;\n\tu_int32_t\t\tfrag, cur, cnt = 0;\n\n\tm = m_head;\n\tcur = frag = *txidx;\n\n\t/*\n\t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n\t * of fragments or hit the end of the mbuf chain.\n\t */\n\tfor (m = m_head; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif ((SK_TX_RING_CNT -\n\t\t\t    (sc_if->sk_cdata.sk_tx_cnt + cnt)) < 2)\n\t\t\t\treturn(ENOBUFS);\n\t\t\tf = &sc_if->sk_rdata->sk_tx_ring[frag];\n\t\t\tf->sk_data_lo = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->sk_ctl = m->m_len | SK_OPCODE_DEFAULT;\n\t\t\tif (cnt == 0)\n\t\t\t\tf->sk_ctl |= SK_TXCTL_FIRSTFRAG;\n\t\t\telse\n\t\t\t\tf->sk_ctl |= SK_TXCTL_OWN;\n\t\t\tcur = frag;\n\t\t\tSK_INC(frag, SK_TX_RING_CNT);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (m != NULL)\n\t\treturn(ENOBUFS);\n\n\tsc_if->sk_rdata->sk_tx_ring[cur].sk_ctl |=\n\t\tSK_TXCTL_LASTFRAG|SK_TXCTL_EOF_INTR;\n\tsc_if->sk_cdata.sk_tx_chain[cur].sk_mbuf = m_head;\n\tsc_if->sk_rdata->sk_tx_ring[*txidx].sk_ctl |= SK_TXCTL_OWN;\n\tsc_if->sk_cdata.sk_tx_cnt += cnt;\n\n\t*txidx = frag;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "skc_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "985-1162",
    "snippet": "void\nskc_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct sk_softc *sc = (struct sk_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tstruct skc_attach_args skca;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tint s;\n\tu_int32_t command;\n\n\ts = splimp();\n\n\t/*\n\t * Handle power management nonsense.\n\t */\n\tcommand = pci_conf_read(pc, pa->pa_tag, SK_PCI_CAPID) & 0x000000FF;\n\tif (command == 0x01) {\n\n\t\tcommand = pci_conf_read(pc, pa->pa_tag, SK_PCI_PWRMGMTCTRL);\n\t\tif (command & SK_PSTATE_MASK) {\n\t\t\tu_int32_t\t\tiobase, membase, irq;\n\n\t\t\t/* Save important PCI config data. */\n\t\t\tiobase = pci_conf_read(pc, pa->pa_tag, SK_PCI_LOIO);\n\t\t\tmembase = pci_conf_read(pc, pa->pa_tag, SK_PCI_LOMEM);\n\t\t\tirq = pci_conf_read(pc, pa->pa_tag, SK_PCI_INTLINE);\n\n\t\t\t/* Reset the power state. */\n\t\t\tprintf(\"%s chip is in D%d power mode \"\n\t\t\t    \"-- setting to D0\\n\", sc->sk_dev.dv_xname,\n\t\t\t    command & SK_PSTATE_MASK);\n\t\t\tcommand &= 0xFFFFFFFC;\n\t\t\tpci_conf_write(pc, pa->pa_tag,\n\t\t\t    SK_PCI_PWRMGMTCTRL, command);\n\n\t\t\t/* Restore PCI config data. */\n\t\t\tpci_conf_write(pc, pa->pa_tag, SK_PCI_LOIO, iobase);\n\t\t\tpci_conf_write(pc, pa->pa_tag, SK_PCI_LOMEM, membase);\n\t\t\tpci_conf_write(pc, pa->pa_tag, SK_PCI_INTLINE, irq);\n\t\t}\n\t}\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tcommand |= PCI_COMMAND_IO_ENABLE |\n\t    PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef SK_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable I/O ports!\\n\");\n\t\tgoto fail;\n\t}\n\t/*\n\t * Map control/status registers.\n\t */\n\tif (pci_io_find(pc, pa->pa_tag, SK_PCI_LOIO, &iobase, &iosize)) {\n\t\tprintf(\": can't find i/o space\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sk_bhandle)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->sk_btag = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tgoto fail;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, SK_PCI_LOMEM, &iobase, &iosize, NULL)){\n\t\tprintf(\": can't find mem space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sk_bhandle)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->sk_btag = pa->pa_memt;\n#endif\n\tsc->sc_dmatag = pa->pa_dmat;\n\n\t/* Allocate interrupt */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sk_intrhand = pci_intr_establish(pc, ih, IPL_NET, sk_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sk_intrhand == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\treturn;\n\t}\n\tprintf(\": %s\\n\", intrstr);\n\n\t/* Reset the adapter. */\n\tsk_reset(sc);\n\n\t/* Read and save vital product data from EEPROM. */\n\tsk_vpd_read(sc);\n\n\t/* Read and save RAM size and RAMbuffer offset */\n\tswitch(sk_win_read_1(sc, SK_EPROM0)) {\n\tcase SK_RAMSIZE_512K_64:\n\t\tsc->sk_ramsize = 0x80000;\n\t\tsc->sk_rboff = SK_RBOFF_0;\n\t\tbreak;\n\tcase SK_RAMSIZE_1024K_64:\n\t\tsc->sk_ramsize = 0x100000;\n\t\tsc->sk_rboff = SK_RBOFF_80000;\n\t\tbreak;\n\tcase SK_RAMSIZE_1024K_128:\n\t\tsc->sk_ramsize = 0x100000;\n\t\tsc->sk_rboff = SK_RBOFF_0;\n\t\tbreak;\n\tcase SK_RAMSIZE_2048K_128:\n\t\tsc->sk_ramsize = 0x200000;\n\t\tsc->sk_rboff = SK_RBOFF_0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown ram size: %d\\n\",\n\t\t    sc->sk_dev.dv_xname, sk_win_read_1(sc, SK_EPROM0));\n\t\tgoto fail;\n\t\tbreak;\n\t}\n\n\t/* Read and save physical media type */\n\tswitch(sk_win_read_1(sc, SK_PMDTYPE)) {\n\tcase SK_PMD_1000BASESX:\n\t\tsc->sk_pmd = IFM_1000_SX;\n\t\tbreak;\n\tcase SK_PMD_1000BASELX:\n\t\tsc->sk_pmd = IFM_1000_LX;\n\t\tbreak;\n\tcase SK_PMD_1000BASECX:\n\t\tsc->sk_pmd = IFM_1000_CX;\n\t\tbreak;\n\tcase SK_PMD_1000BASETX:\n\t\tsc->sk_pmd = IFM_1000_TX;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown media type: 0x%x\\n\",\n\t\t    sc->sk_dev.dv_xname, sk_win_read_1(sc, SK_PMDTYPE));\n\t\tgoto fail;\n\t}\n\n\t/* Announce the product name. */\n\tprintf(\"%s: %s\\n\", sc->sk_dev.dv_xname, sc->sk_vpd_prodname);\n\n\tskca.skc_port = SK_PORT_A;\n\t(void)config_found(&sc->sk_dev, &skca, skcprint);\n\n\tif (!(sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC)) {\n\t\tskca.skc_port = SK_PORT_B;\n\t\t(void)config_found(&sc->sk_dev, &skca, skcprint);\n\t}\n\n\t/* Turn on the 'driver is loaded' LED. */\n\tCSR_WRITE_2(sc, SK_LED, SK_LED_GREEN_ON);\n\nfail:\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define SK_USEIOSPACE"
    ],
    "globals_used": [
      "void skc_attach",
      "int skcprint",
      "int sk_intr",
      "void sk_reset",
      "u_int8_t sk_win_read_1",
      "void sk_vpd_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "SK_LED",
            "SK_LED_GREEN_ON"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&sc->sk_dev",
            "&skca",
            "skcprint"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_win_read_1",
          "args": [
            "sc",
            "SK_CONFIG"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "sk_win_read_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "191-197",
          "snippet": "u_int8_t sk_win_read_1(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg)));\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t sk_win_read_1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t sk_win_read_1;\n\nu_int8_t sk_win_read_1(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&sc->sk_dev",
            "&skca",
            "skcprint"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s\\n\"",
            "sc->sk_dev.dv_xname",
            "sc->sk_vpd_prodname"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_vpd_read",
          "args": [
            "sc"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "sk_vpd_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "275-317",
          "snippet": "void sk_vpd_read(sc)\n\tstruct sk_softc\t\t*sc;\n{\n\tint\t\t\tpos = 0, i;\n\tstruct vpd_res\t\tres;\n\n\tif (sc->sk_vpd_prodname != NULL)\n\t\tfree(sc->sk_vpd_prodname, M_DEVBUF);\n\tif (sc->sk_vpd_readonly != NULL)\n\t\tfree(sc->sk_vpd_readonly, M_DEVBUF);\n\tsc->sk_vpd_prodname = NULL;\n\tsc->sk_vpd_readonly = NULL;\n\n\tsk_vpd_read_res(sc, &res, pos);\n\n\tif (res.vr_id != VPD_RES_ID) {\n\t\tprintf(\"%s: bad VPD resource id: expected %x got %x\\n\",\n\t\t    sc->sk_dev.dv_xname, VPD_RES_ID, res.vr_id);\n\t\treturn;\n\t}\n\n\tpos += sizeof(res);\n\tsc->sk_vpd_prodname = malloc(res.vr_len + 1, M_DEVBUF, M_NOWAIT);\n\tfor (i = 0; i < res.vr_len; i++)\n\t\tsc->sk_vpd_prodname[i] = sk_vpd_readbyte(sc, i + pos);\n\tsc->sk_vpd_prodname[i] = '\\0';\n\tpos += i;\n\n\tsk_vpd_read_res(sc, &res, pos);\n\n\tif (res.vr_id != VPD_RES_READ) {\n\t\tprintf(\"%s: bad VPD resource id: expected %x got %x\\n\",\n\t\t    sc->sk_dev.dv_xname, VPD_RES_READ, res.vr_id);\n\t\treturn;\n\t}\n\n\tpos += sizeof(res);\n\tsc->sk_vpd_readonly = malloc(res.vr_len, M_DEVBUF, M_NOWAIT);\n\tfor (i = 0; i < res.vr_len + 1; i++)\n\t\tsc->sk_vpd_readonly[i] = sk_vpd_readbyte(sc, i + pos);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t sk_vpd_readbyte",
            "void sk_vpd_read_res",
            "void sk_vpd_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t sk_vpd_readbyte;\nvoid sk_vpd_read_res;\nvoid sk_vpd_read;\n\nvoid sk_vpd_read(sc)\n\tstruct sk_softc\t\t*sc;\n{\n\tint\t\t\tpos = 0, i;\n\tstruct vpd_res\t\tres;\n\n\tif (sc->sk_vpd_prodname != NULL)\n\t\tfree(sc->sk_vpd_prodname, M_DEVBUF);\n\tif (sc->sk_vpd_readonly != NULL)\n\t\tfree(sc->sk_vpd_readonly, M_DEVBUF);\n\tsc->sk_vpd_prodname = NULL;\n\tsc->sk_vpd_readonly = NULL;\n\n\tsk_vpd_read_res(sc, &res, pos);\n\n\tif (res.vr_id != VPD_RES_ID) {\n\t\tprintf(\"%s: bad VPD resource id: expected %x got %x\\n\",\n\t\t    sc->sk_dev.dv_xname, VPD_RES_ID, res.vr_id);\n\t\treturn;\n\t}\n\n\tpos += sizeof(res);\n\tsc->sk_vpd_prodname = malloc(res.vr_len + 1, M_DEVBUF, M_NOWAIT);\n\tfor (i = 0; i < res.vr_len; i++)\n\t\tsc->sk_vpd_prodname[i] = sk_vpd_readbyte(sc, i + pos);\n\tsc->sk_vpd_prodname[i] = '\\0';\n\tpos += i;\n\n\tsk_vpd_read_res(sc, &res, pos);\n\n\tif (res.vr_id != VPD_RES_READ) {\n\t\tprintf(\"%s: bad VPD resource id: expected %x got %x\\n\",\n\t\t    sc->sk_dev.dv_xname, VPD_RES_READ, res.vr_id);\n\t\treturn;\n\t}\n\n\tpos += sizeof(res);\n\tsc->sk_vpd_readonly = malloc(res.vr_len, M_DEVBUF, M_NOWAIT);\n\tfor (i = 0; i < res.vr_len + 1; i++)\n\t\tsc->sk_vpd_readonly[i] = sk_vpd_readbyte(sc, i + pos);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_reset",
          "args": [
            "sc"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "sk_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "770-803",
          "snippet": "void sk_reset(sc)\n\tstruct sk_softc\t\t*sc;\n{\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_RESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_RESET);\n\tDELAY(1000);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_UNRESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_UNRESET);\n\n\t/* Configure packet arbiter */\n\tsk_win_write_2(sc, SK_PKTARB_CTL, SK_PKTARBCTL_UNRESET);\n\tsk_win_write_2(sc, SK_RXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_RXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\n\t/* Enable RAM interface */\n\tsk_win_write_4(sc, SK_RAMCTL, SK_RAMCTL_UNRESET);\n\n\t/*\n         * Configure interrupt moderation. The moderation timer\n\t * defers interrupts specified in the interrupt moderation\n\t * timer mask based on the timeout specified in the interrupt\n\t * moderation timer init register. Each bit in the timer\n\t * register represents 18.825ns, so to specify a timeout in\n\t * microseconds, we have to multiply by 54.\n\t */\n        sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(200));\n        sk_win_write_4(sc, SK_IMMR, SK_ISR_TX1_S_EOF|SK_ISR_TX2_S_EOF|\n\t    SK_ISR_RX1_EOF|SK_ISR_RX2_EOF);\n        sk_win_write_1(sc, SK_IMTIMERCTL, SK_IMCTL_START);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_reset",
            "void sk_win_write_4",
            "void sk_win_write_2",
            "void sk_win_write_1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_reset;\nvoid sk_win_write_4;\nvoid sk_win_write_2;\nvoid sk_win_write_1;\n\nvoid sk_reset(sc)\n\tstruct sk_softc\t\t*sc;\n{\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_RESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_RESET);\n\tDELAY(1000);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_UNRESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_UNRESET);\n\n\t/* Configure packet arbiter */\n\tsk_win_write_2(sc, SK_PKTARB_CTL, SK_PKTARBCTL_UNRESET);\n\tsk_win_write_2(sc, SK_RXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_RXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\n\t/* Enable RAM interface */\n\tsk_win_write_4(sc, SK_RAMCTL, SK_RAMCTL_UNRESET);\n\n\t/*\n         * Configure interrupt moderation. The moderation timer\n\t * defers interrupts specified in the interrupt moderation\n\t * timer mask based on the timeout specified in the interrupt\n\t * moderation timer init register. Each bit in the timer\n\t * register represents 18.825ns, so to specify a timeout in\n\t * microseconds, we have to multiply by 54.\n\t */\n        sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(200));\n        sk_win_write_4(sc, SK_IMMR, SK_ISR_TX1_S_EOF|SK_ISR_TX2_S_EOF|\n\t    SK_ISR_RX1_EOF|SK_ISR_RX2_EOF);\n        sk_win_write_1(sc, SK_IMTIMERCTL, SK_IMCTL_START);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "sk_intr",
            "sc",
            "self->dv_xname"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "iobase",
            "iosize",
            "0",
            "&sc->sk_bhandle"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_LOMEM",
            "&iobase",
            "&iosize",
            "NULL"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_iot",
            "iobase",
            "iosize",
            "0",
            "&sc->sk_bhandle"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_LOIO",
            "&iobase",
            "&iosize"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "command"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_INTLINE",
            "irq"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_LOMEM",
            "membase"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_LOIO",
            "iobase"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_PWRMGMTCTRL",
            "command"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_INTLINE"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_LOMEM"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_LOIO"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_PWRMGMTCTRL"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pc",
            "pa->pa_tag",
            "SK_PCI_CAPID"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SK_USEIOSPACE\n\nvoid skc_attach;\nint skcprint;\nint sk_intr;\nvoid sk_reset;\nu_int8_t sk_win_read_1;\nvoid sk_vpd_read;\n\nvoid\nskc_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct sk_softc *sc = (struct sk_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tstruct skc_attach_args skca;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tint s;\n\tu_int32_t command;\n\n\ts = splimp();\n\n\t/*\n\t * Handle power management nonsense.\n\t */\n\tcommand = pci_conf_read(pc, pa->pa_tag, SK_PCI_CAPID) & 0x000000FF;\n\tif (command == 0x01) {\n\n\t\tcommand = pci_conf_read(pc, pa->pa_tag, SK_PCI_PWRMGMTCTRL);\n\t\tif (command & SK_PSTATE_MASK) {\n\t\t\tu_int32_t\t\tiobase, membase, irq;\n\n\t\t\t/* Save important PCI config data. */\n\t\t\tiobase = pci_conf_read(pc, pa->pa_tag, SK_PCI_LOIO);\n\t\t\tmembase = pci_conf_read(pc, pa->pa_tag, SK_PCI_LOMEM);\n\t\t\tirq = pci_conf_read(pc, pa->pa_tag, SK_PCI_INTLINE);\n\n\t\t\t/* Reset the power state. */\n\t\t\tprintf(\"%s chip is in D%d power mode \"\n\t\t\t    \"-- setting to D0\\n\", sc->sk_dev.dv_xname,\n\t\t\t    command & SK_PSTATE_MASK);\n\t\t\tcommand &= 0xFFFFFFFC;\n\t\t\tpci_conf_write(pc, pa->pa_tag,\n\t\t\t    SK_PCI_PWRMGMTCTRL, command);\n\n\t\t\t/* Restore PCI config data. */\n\t\t\tpci_conf_write(pc, pa->pa_tag, SK_PCI_LOIO, iobase);\n\t\t\tpci_conf_write(pc, pa->pa_tag, SK_PCI_LOMEM, membase);\n\t\t\tpci_conf_write(pc, pa->pa_tag, SK_PCI_INTLINE, irq);\n\t\t}\n\t}\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tcommand |= PCI_COMMAND_IO_ENABLE |\n\t    PCI_COMMAND_MEM_ENABLE |\n\t    PCI_COMMAND_MASTER_ENABLE;\n\tpci_conf_write(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG, command);\n\tcommand = pci_conf_read(pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef SK_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable I/O ports!\\n\");\n\t\tgoto fail;\n\t}\n\t/*\n\t * Map control/status registers.\n\t */\n\tif (pci_io_find(pc, pa->pa_tag, SK_PCI_LOIO, &iobase, &iosize)) {\n\t\tprintf(\": can't find i/o space\\n\");\n\t\treturn;\n\t}\n\tif (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->sk_bhandle)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->sk_btag = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tgoto fail;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, SK_PCI_LOMEM, &iobase, &iosize, NULL)){\n\t\tprintf(\": can't find mem space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->sk_bhandle)) {\n\t\tprintf(\": can't map mem space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->sk_btag = pa->pa_memt;\n#endif\n\tsc->sc_dmatag = pa->pa_dmat;\n\n\t/* Allocate interrupt */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sk_intrhand = pci_intr_establish(pc, ih, IPL_NET, sk_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sk_intrhand == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\treturn;\n\t}\n\tprintf(\": %s\\n\", intrstr);\n\n\t/* Reset the adapter. */\n\tsk_reset(sc);\n\n\t/* Read and save vital product data from EEPROM. */\n\tsk_vpd_read(sc);\n\n\t/* Read and save RAM size and RAMbuffer offset */\n\tswitch(sk_win_read_1(sc, SK_EPROM0)) {\n\tcase SK_RAMSIZE_512K_64:\n\t\tsc->sk_ramsize = 0x80000;\n\t\tsc->sk_rboff = SK_RBOFF_0;\n\t\tbreak;\n\tcase SK_RAMSIZE_1024K_64:\n\t\tsc->sk_ramsize = 0x100000;\n\t\tsc->sk_rboff = SK_RBOFF_80000;\n\t\tbreak;\n\tcase SK_RAMSIZE_1024K_128:\n\t\tsc->sk_ramsize = 0x100000;\n\t\tsc->sk_rboff = SK_RBOFF_0;\n\t\tbreak;\n\tcase SK_RAMSIZE_2048K_128:\n\t\tsc->sk_ramsize = 0x200000;\n\t\tsc->sk_rboff = SK_RBOFF_0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown ram size: %d\\n\",\n\t\t    sc->sk_dev.dv_xname, sk_win_read_1(sc, SK_EPROM0));\n\t\tgoto fail;\n\t\tbreak;\n\t}\n\n\t/* Read and save physical media type */\n\tswitch(sk_win_read_1(sc, SK_PMDTYPE)) {\n\tcase SK_PMD_1000BASESX:\n\t\tsc->sk_pmd = IFM_1000_SX;\n\t\tbreak;\n\tcase SK_PMD_1000BASELX:\n\t\tsc->sk_pmd = IFM_1000_LX;\n\t\tbreak;\n\tcase SK_PMD_1000BASECX:\n\t\tsc->sk_pmd = IFM_1000_CX;\n\t\tbreak;\n\tcase SK_PMD_1000BASETX:\n\t\tsc->sk_pmd = IFM_1000_TX;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown media type: 0x%x\\n\",\n\t\t    sc->sk_dev.dv_xname, sk_win_read_1(sc, SK_PMDTYPE));\n\t\tgoto fail;\n\t}\n\n\t/* Announce the product name. */\n\tprintf(\"%s: %s\\n\", sc->sk_dev.dv_xname, sc->sk_vpd_prodname);\n\n\tskca.skc_port = SK_PORT_A;\n\t(void)config_found(&sc->sk_dev, &skca, skcprint);\n\n\tif (!(sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC)) {\n\t\tskca.skc_port = SK_PORT_B;\n\t\t(void)config_found(&sc->sk_dev, &skca, skcprint);\n\t}\n\n\t/* Turn on the 'driver is loaded' LED. */\n\tCSR_WRITE_2(sc, SK_LED, SK_LED_GREEN_ON);\n\nfail:\n\tsplx(s);\n}"
  },
  {
    "function_name": "skcprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "966-979",
    "snippet": "int\nskcprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct skc_attach_args *sa = aux;\n\n\tif (pnp)\n\t\tprintf(\"sk port %c at %s\",\n\t\t    (sa->skc_port == SK_PORT_A) ? 'A' : 'B', pnp);\n\telse\n\t\tprintf(\" port %c\", (sa->skc_port == SK_PORT_A) ? 'A' : 'B');\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int skcprint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" port %c\"",
            "(sa->skc_port == SK_PORT_A) ? 'A' : 'B'"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint skcprint;\n\nint\nskcprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n\tstruct skc_attach_args *sa = aux;\n\n\tif (pnp)\n\t\tprintf(\"sk port %c at %s\",\n\t\t    (sa->skc_port == SK_PORT_A) ? 'A' : 'B', pnp);\n\telse\n\t\tprintf(\" port %c\", (sa->skc_port == SK_PORT_A) ? 'A' : 'B');\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "sk_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "822-964",
    "snippet": "void\nsk_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct sk_if_softc *sc_if = (struct sk_if_softc *) self;\n\tstruct sk_softc *sc = (struct sk_softc *)parent;\n\tstruct skc_attach_args *sa = aux;\n\tstruct ifnet *ifp;\n\tcaddr_t kva;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint i, rseg;\n\n\tsc_if->sk_port = sa->skc_port;\n\tsc_if->sk_softc = sc;\n\tsc->sk_if[sa->skc_port] = sc_if;\n\n\tif (sa->skc_port == SK_PORT_A)\n\t\tsc_if->sk_tx_bmu = SK_BMU_TXS_CSR0;\n\tif (sa->skc_port == SK_PORT_B)\n\t\tsc_if->sk_tx_bmu = SK_BMU_TXS_CSR1;\n\t\n\t/*\n\t * Get station address for this interface. Note that\n\t * dual port cards actually come with three station\n\t * addresses: one for each port, plus an extra. The\n\t * extra one is used by the SysKonnect driver software\n\t * as a 'virtual' station address for when both ports\n\t * are operating in failover mode. Currently we don't\n\t * use this extra address.\n\t */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tsc_if->arpcom.ac_enaddr[i] =\n\t\t    sk_win_read_1(sc, SK_MAC0_0 + (sa->skc_port * 8) + i);\n\n\n\tprintf(\": <XaQti Corp. XMAC II> address %s\\n\",\n\t    ether_sprintf(sc_if->arpcom.ac_enaddr));\n\n\t/*\n\t * Set up RAM buffer addresses. The NIC will have a certain\n\t * amount of SRAM on it, somewhere between 512K and 2MB. We\n\t * need to divide this up a) between the transmitter and\n \t * receiver and b) between the two XMACs, if this is a\n\t * dual port NIC. Our algotithm is to divide up the memory\n\t * evenly so that everyone gets a fair share.\n\t */\n\tif (sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC) {\n\t\tu_int32_t\t\tchunk, val;\n\n\t\tchunk = sc->sk_ramsize / 2;\n\t\tval = sc->sk_rboff / sizeof(u_int64_t);\n\t\tsc_if->sk_rx_ramstart = val;\n\t\tval += (chunk / sizeof(u_int64_t));\n\t\tsc_if->sk_rx_ramend = val - 1;\n\t\tsc_if->sk_tx_ramstart = val;\n\t\tval += (chunk / sizeof(u_int64_t));\n\t\tsc_if->sk_tx_ramend = val - 1;\n\t} else {\n\t\tu_int32_t\t\tchunk, val;\n\n\t\tchunk = sc->sk_ramsize / 4;\n\t\tval = (sc->sk_rboff + (chunk * 2 * sc_if->sk_port)) /\n\t\t    sizeof(u_int64_t);\n\t\tsc_if->sk_rx_ramstart = val;\n\t\tval += (chunk / sizeof(u_int64_t));\n\t\tsc_if->sk_rx_ramend = val - 1;\n\t\tsc_if->sk_tx_ramstart = val;\n\t\tval += (chunk / sizeof(u_int64_t));\n\t\tsc_if->sk_tx_ramend = val - 1;\n\t}\n\n\t/* Allocate the descriptor queues. */\n\tif (bus_dmamem_alloc(sc->sc_dmatag, sizeof(struct sk_ring_data),\n\t    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't alloc rx buffers\\n\", sc->sk_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamem_map(sc->sc_dmatag, &seg, rseg,\n\t    sizeof(struct sk_ring_data), &kva, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't map dma buffers (%d bytes)\\n\",\n\t\t       sc_if->sk_dev.dv_xname, sizeof(struct sk_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamap_create(sc->sc_dmatag, sizeof(struct sk_ring_data), 1,\n\t    sizeof(struct sk_ring_data), 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\"%s: can't create dma map\\n\", sc_if->sk_dev.dv_xname);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva,\n\t\t    sizeof(struct sk_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamap_load(sc->sc_dmatag, dmamap, kva,\n\t    sizeof(struct sk_ring_data), NULL, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't load dma map\\n\", sc_if->sk_dev.dv_xname);\n\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva,\n\t\t    sizeof(struct sk_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n        sc_if->sk_rdata = (struct sk_ring_data *)kva;\n\tbzero(sc_if->sk_rdata, sizeof(struct sk_ring_data));\n\n\tifp = &sc_if->arpcom.ac_if;\n\tifp->if_softc = sc_if;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = sk_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = sk_start;\n\tifp->if_watchdog = sk_watchdog;\n\tifp->if_baudrate = 1000000000;\n\tifp->if_snd.ifq_maxlen = SK_TX_RING_CNT - 1;\n\tbcopy(sc_if->sk_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\t/*\n\t * Do ifmedia setup.\n\t */\n\tifmedia_init(&sc_if->ifmedia, 0, sk_ifmedia_upd, sk_ifmedia_sts);\n\tifmedia_add(&sc_if->ifmedia, IFM_ETHER|sc->sk_pmd, 0, NULL);\n\tifmedia_add(&sc_if->ifmedia, IFM_ETHER|sc->sk_pmd|IFM_FDX, 0, NULL);\n\tifmedia_add(&sc_if->ifmedia, IFM_ETHER|sc->sk_pmd|IFM_HDX, 0, NULL);\n\tifmedia_add(&sc_if->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\tifmedia_set(&sc_if->ifmedia, IFM_ETHER|IFM_AUTO);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc_if->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\treturn;\n\nfail:\n\tsc->sk_if[sa->skc_port] = NULL;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_attach",
      "void sk_start",
      "int sk_ioctl",
      "void sk_watchdog",
      "int sk_ifmedia_upd",
      "void sk_ifmedia_sts",
      "u_int8_t sk_win_read_1"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc_if->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc_if->ifmedia",
            "IFM_ETHER|IFM_AUTO"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc_if->ifmedia",
            "IFM_ETHER|IFM_AUTO",
            "0",
            "NULL"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc_if->ifmedia",
            "IFM_ETHER|sc->sk_pmd|IFM_HDX",
            "0",
            "NULL"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc_if->ifmedia",
            "IFM_ETHER|sc->sk_pmd|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc_if->ifmedia",
            "IFM_ETHER|sc->sk_pmd",
            "0",
            "NULL"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc_if->ifmedia",
            "0",
            "sk_ifmedia_upd",
            "sk_ifmedia_sts"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc_if->sk_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc_if->sk_rdata",
            "sizeof(struct sk_ring_data)"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "kva",
            "sizeof(struct sk_ring_data)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "sc->sc_dmatag",
            "dmamap"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't load dma map\\n\"",
            "sc_if->sk_dev.dv_xname"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmatag",
            "dmamap",
            "kva",
            "sizeof(struct sk_ring_data)",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "kva",
            "sizeof(struct sk_ring_data)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmatag",
            "sizeof(struct sk_ring_data)",
            "1",
            "sizeof(struct sk_ring_data)",
            "0",
            "BUS_DMA_NOWAIT",
            "&dmamap"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmatag",
            "&seg",
            "rseg",
            "sizeof(struct sk_ring_data)",
            "&kva",
            "BUS_DMA_NOWAIT"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmatag",
            "sizeof(struct sk_ring_data)",
            "PAGE_SIZE",
            "0",
            "&seg",
            "1",
            "&rseg",
            "BUS_DMA_NOWAIT"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_win_read_1",
          "args": [
            "sc",
            "SK_CONFIG"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "sk_win_read_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "191-197",
          "snippet": "u_int8_t sk_win_read_1(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg)));\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t sk_win_read_1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t sk_win_read_1;\n\nu_int8_t sk_win_read_1(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc_if->arpcom.ac_enaddr"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_attach;\nvoid sk_start;\nint sk_ioctl;\nvoid sk_watchdog;\nint sk_ifmedia_upd;\nvoid sk_ifmedia_sts;\nu_int8_t sk_win_read_1;\n\nvoid\nsk_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct sk_if_softc *sc_if = (struct sk_if_softc *) self;\n\tstruct sk_softc *sc = (struct sk_softc *)parent;\n\tstruct skc_attach_args *sa = aux;\n\tstruct ifnet *ifp;\n\tcaddr_t kva;\n\tbus_dma_segment_t seg;\n\tbus_dmamap_t dmamap;\n\tint i, rseg;\n\n\tsc_if->sk_port = sa->skc_port;\n\tsc_if->sk_softc = sc;\n\tsc->sk_if[sa->skc_port] = sc_if;\n\n\tif (sa->skc_port == SK_PORT_A)\n\t\tsc_if->sk_tx_bmu = SK_BMU_TXS_CSR0;\n\tif (sa->skc_port == SK_PORT_B)\n\t\tsc_if->sk_tx_bmu = SK_BMU_TXS_CSR1;\n\t\n\t/*\n\t * Get station address for this interface. Note that\n\t * dual port cards actually come with three station\n\t * addresses: one for each port, plus an extra. The\n\t * extra one is used by the SysKonnect driver software\n\t * as a 'virtual' station address for when both ports\n\t * are operating in failover mode. Currently we don't\n\t * use this extra address.\n\t */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tsc_if->arpcom.ac_enaddr[i] =\n\t\t    sk_win_read_1(sc, SK_MAC0_0 + (sa->skc_port * 8) + i);\n\n\n\tprintf(\": <XaQti Corp. XMAC II> address %s\\n\",\n\t    ether_sprintf(sc_if->arpcom.ac_enaddr));\n\n\t/*\n\t * Set up RAM buffer addresses. The NIC will have a certain\n\t * amount of SRAM on it, somewhere between 512K and 2MB. We\n\t * need to divide this up a) between the transmitter and\n \t * receiver and b) between the two XMACs, if this is a\n\t * dual port NIC. Our algotithm is to divide up the memory\n\t * evenly so that everyone gets a fair share.\n\t */\n\tif (sk_win_read_1(sc, SK_CONFIG) & SK_CONFIG_SINGLEMAC) {\n\t\tu_int32_t\t\tchunk, val;\n\n\t\tchunk = sc->sk_ramsize / 2;\n\t\tval = sc->sk_rboff / sizeof(u_int64_t);\n\t\tsc_if->sk_rx_ramstart = val;\n\t\tval += (chunk / sizeof(u_int64_t));\n\t\tsc_if->sk_rx_ramend = val - 1;\n\t\tsc_if->sk_tx_ramstart = val;\n\t\tval += (chunk / sizeof(u_int64_t));\n\t\tsc_if->sk_tx_ramend = val - 1;\n\t} else {\n\t\tu_int32_t\t\tchunk, val;\n\n\t\tchunk = sc->sk_ramsize / 4;\n\t\tval = (sc->sk_rboff + (chunk * 2 * sc_if->sk_port)) /\n\t\t    sizeof(u_int64_t);\n\t\tsc_if->sk_rx_ramstart = val;\n\t\tval += (chunk / sizeof(u_int64_t));\n\t\tsc_if->sk_rx_ramend = val - 1;\n\t\tsc_if->sk_tx_ramstart = val;\n\t\tval += (chunk / sizeof(u_int64_t));\n\t\tsc_if->sk_tx_ramend = val - 1;\n\t}\n\n\t/* Allocate the descriptor queues. */\n\tif (bus_dmamem_alloc(sc->sc_dmatag, sizeof(struct sk_ring_data),\n\t    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't alloc rx buffers\\n\", sc->sk_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamem_map(sc->sc_dmatag, &seg, rseg,\n\t    sizeof(struct sk_ring_data), &kva, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't map dma buffers (%d bytes)\\n\",\n\t\t       sc_if->sk_dev.dv_xname, sizeof(struct sk_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamap_create(sc->sc_dmatag, sizeof(struct sk_ring_data), 1,\n\t    sizeof(struct sk_ring_data), 0, BUS_DMA_NOWAIT, &dmamap)) {\n\t\tprintf(\"%s: can't create dma map\\n\", sc_if->sk_dev.dv_xname);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva,\n\t\t    sizeof(struct sk_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n\tif (bus_dmamap_load(sc->sc_dmatag, dmamap, kva,\n\t    sizeof(struct sk_ring_data), NULL, BUS_DMA_NOWAIT)) {\n\t\tprintf(\"%s: can't load dma map\\n\", sc_if->sk_dev.dv_xname);\n\t\tbus_dmamap_destroy(sc->sc_dmatag, dmamap);\n\t\tbus_dmamem_unmap(sc->sc_dmatag, kva,\n\t\t    sizeof(struct sk_ring_data));\n\t\tbus_dmamem_free(sc->sc_dmatag, &seg, rseg);\n\t\tgoto fail;\n\t}\n        sc_if->sk_rdata = (struct sk_ring_data *)kva;\n\tbzero(sc_if->sk_rdata, sizeof(struct sk_ring_data));\n\n\tifp = &sc_if->arpcom.ac_if;\n\tifp->if_softc = sc_if;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = sk_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = sk_start;\n\tifp->if_watchdog = sk_watchdog;\n\tifp->if_baudrate = 1000000000;\n\tifp->if_snd.ifq_maxlen = SK_TX_RING_CNT - 1;\n\tbcopy(sc_if->sk_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\t/*\n\t * Do ifmedia setup.\n\t */\n\tifmedia_init(&sc_if->ifmedia, 0, sk_ifmedia_upd, sk_ifmedia_sts);\n\tifmedia_add(&sc_if->ifmedia, IFM_ETHER|sc->sk_pmd, 0, NULL);\n\tifmedia_add(&sc_if->ifmedia, IFM_ETHER|sc->sk_pmd|IFM_FDX, 0, NULL);\n\tifmedia_add(&sc_if->ifmedia, IFM_ETHER|sc->sk_pmd|IFM_HDX, 0, NULL);\n\tifmedia_add(&sc_if->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\tifmedia_set(&sc_if->ifmedia, IFM_ETHER|IFM_AUTO);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc_if->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\treturn;\n\nfail:\n\tsc->sk_if[sa->skc_port] = NULL;\n}"
  },
  {
    "function_name": "sk_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "805-816",
    "snippet": "int\nsk_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct skc_attach_args *sa = aux;\n\n\tif (sa->skc_port != SK_PORT_A && sa->skc_port != SK_PORT_B)\n\t\treturn(0);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sk_probe"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_probe;\n\nint\nsk_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct skc_attach_args *sa = aux;\n\n\tif (sa->skc_port != SK_PORT_A && sa->skc_port != SK_PORT_B)\n\t\treturn(0);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "sk_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "770-803",
    "snippet": "void sk_reset(sc)\n\tstruct sk_softc\t\t*sc;\n{\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_RESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_RESET);\n\tDELAY(1000);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_UNRESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_UNRESET);\n\n\t/* Configure packet arbiter */\n\tsk_win_write_2(sc, SK_PKTARB_CTL, SK_PKTARBCTL_UNRESET);\n\tsk_win_write_2(sc, SK_RXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_RXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\n\t/* Enable RAM interface */\n\tsk_win_write_4(sc, SK_RAMCTL, SK_RAMCTL_UNRESET);\n\n\t/*\n         * Configure interrupt moderation. The moderation timer\n\t * defers interrupts specified in the interrupt moderation\n\t * timer mask based on the timeout specified in the interrupt\n\t * moderation timer init register. Each bit in the timer\n\t * register represents 18.825ns, so to specify a timeout in\n\t * microseconds, we have to multiply by 54.\n\t */\n        sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(200));\n        sk_win_write_4(sc, SK_IMMR, SK_ISR_TX1_S_EOF|SK_ISR_TX2_S_EOF|\n\t    SK_ISR_RX1_EOF|SK_ISR_RX2_EOF);\n        sk_win_write_1(sc, SK_IMTIMERCTL, SK_IMCTL_START);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_reset",
      "void sk_win_write_4",
      "void sk_win_write_2",
      "void sk_win_write_1"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sk_win_write_1",
          "args": [
            "sc",
            "SK_IMTIMERCTL",
            "SK_IMCTL_START"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "sk_win_write_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "219-227",
          "snippet": "void sk_win_write_1(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_1(sc, SK_WIN_BASE + SK_REG(reg), val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_win_write_1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_win_write_1;\n\nvoid sk_win_write_1(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_1(sc, SK_WIN_BASE + SK_REG(reg), val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_win_write_4",
          "args": [
            "sc",
            "SK_IMMR",
            "SK_ISR_TX1_S_EOF|SK_ISR_TX2_S_EOF|\n\t    SK_ISR_RX1_EOF|SK_ISR_RX2_EOF"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "sk_win_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "199-207",
          "snippet": "void sk_win_write_4(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_4(sc, SK_WIN_BASE + SK_REG(reg), val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_win_write_4"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_win_write_4;\n\nvoid sk_win_write_4(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_4(sc, SK_WIN_BASE + SK_REG(reg), val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_IM_USECS",
          "args": [
            "200"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_win_write_2",
          "args": [
            "sc",
            "SK_TXPA2_TINIT",
            "SK_PKTARB_TIMEOUT"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "sk_win_write_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "209-217",
          "snippet": "void sk_win_write_2(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), (u_int32_t)val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_win_write_2"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_win_write_2;\n\nvoid sk_win_write_2(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), (u_int32_t)val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_CSR",
            "SK_CSR_MASTER_UNRESET"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_CSR",
            "SK_CSR_SW_UNRESET"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_CSR",
            "SK_CSR_MASTER_RESET"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_CSR",
            "SK_CSR_SW_RESET"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_reset;\nvoid sk_win_write_4;\nvoid sk_win_write_2;\nvoid sk_win_write_1;\n\nvoid sk_reset(sc)\n\tstruct sk_softc\t\t*sc;\n{\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_RESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_RESET);\n\tDELAY(1000);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_SW_UNRESET);\n\tCSR_WRITE_4(sc, SK_CSR, SK_CSR_MASTER_UNRESET);\n\n\t/* Configure packet arbiter */\n\tsk_win_write_2(sc, SK_PKTARB_CTL, SK_PKTARBCTL_UNRESET);\n\tsk_win_write_2(sc, SK_RXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA1_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_RXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\tsk_win_write_2(sc, SK_TXPA2_TINIT, SK_PKTARB_TIMEOUT);\n\n\t/* Enable RAM interface */\n\tsk_win_write_4(sc, SK_RAMCTL, SK_RAMCTL_UNRESET);\n\n\t/*\n         * Configure interrupt moderation. The moderation timer\n\t * defers interrupts specified in the interrupt moderation\n\t * timer mask based on the timeout specified in the interrupt\n\t * moderation timer init register. Each bit in the timer\n\t * register represents 18.825ns, so to specify a timeout in\n\t * microseconds, we have to multiply by 54.\n\t */\n        sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(200));\n        sk_win_write_4(sc, SK_IMMR, SK_ISR_TX1_S_EOF|SK_ISR_TX2_S_EOF|\n\t    SK_ISR_RX1_EOF|SK_ISR_RX2_EOF);\n        sk_win_write_1(sc, SK_IMTIMERCTL, SK_IMCTL_START);\n\n\treturn;\n}"
  },
  {
    "function_name": "skc_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "751-765",
    "snippet": "int\nskc_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\n\tif (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_SCHNEIDERKOCH)\n\t\treturn (0);\n\n\tif (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_SCHNEIDERKOCH_GE)\n\t\treturn (0);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int skc_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint skc_probe;\n\nint\nskc_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\n\tif (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_SCHNEIDERKOCH)\n\t\treturn (0);\n\n\tif (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_SCHNEIDERKOCH_GE)\n\t\treturn (0);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "sk_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "662-745",
    "snippet": "int\nsk_ioctl(ifp, command, data)\n\tstruct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct sk_if_softc *sc_if = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *) data;\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint s, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc_if->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tsk_init(sc_if);\n\t\t\tarp_ifinit(&sc_if->arpcom, ifa);\n\t\t\tbreak;\n#endif /* INET */\n\t\tdefault:\n\t\t\tsk_init(sc_if);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc_if->sk_if_flags & IFF_PROMISC)) {\n\t\t\t\tSK_XM_SETBIT_4(sc_if, XM_MODE,\n\t\t\t\t    XM_MODE_RX_PROMISC);\n\t\t\t\tsk_setmulti(sc_if);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc_if->sk_if_flags & IFF_PROMISC) {\n\t\t\t\tSK_XM_CLRBIT_4(sc_if, XM_MODE,\n\t\t\t\t    XM_MODE_RX_PROMISC);\n\t\t\t\tsk_setmulti(sc_if);\n\t\t\t} else\n\t\t\t\tsk_init(sc_if);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tsk_stop(sc_if);\n\t\t}\n\t\tsc_if->sk_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc_if->arpcom) :\n\t\t    ether_delmulti(ifr, &sc_if->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tsk_setmulti(sc_if);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc_if->ifmedia, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sk_ioctl",
      "void sk_init",
      "void sk_stop",
      "void sk_setmulti"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc_if->ifmedia",
            "command"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_setmulti",
          "args": [
            "sc_if"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "sk_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "406-467",
          "snippet": "void\nsk_setmulti(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct ifnet *ifp;\n\tu_int32_t hashes[2] = { 0, 0 };\n\tint h, i;\n\tstruct arpcom *ac = &sc_if->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t dummy[] = { 0, 0, 0, 0, 0 ,0 };\n\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < XM_RXFILT_MAX; i++)\n\t\tsk_setfilt(sc_if, (caddr_t)&dummy, i);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, 0);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, 0);\n\n\t/* Now program new ones. */\nallmulti:\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\t/* First find the tail of the list. */\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tgoto allmulti;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Program the first XM_RXFILT_MAX multicast groups\n\t\t\t * into the perfect filter. For all others,\n\t\t\t * use the hash table.\n\t\t\t */\n\t\t\tif (i < XM_RXFILT_MAX) {\n\t\t\t\tsk_setfilt(sc_if, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\th = sk_calchash(enm->enm_addrlo);\n\t\t\t\tif (h < 32)\n\t\t\t\t\thashes[0] |= (1 << h);\n\t\t\t\telse\n\t\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t}\n\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_HASH|\n\t    XM_MODE_RX_USE_PERFECT);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int32_t sk_calchash",
            "void sk_setfilt",
            "void sk_setmulti"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t sk_calchash;\nvoid sk_setfilt;\nvoid sk_setmulti;\n\nvoid\nsk_setmulti(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct ifnet *ifp;\n\tu_int32_t hashes[2] = { 0, 0 };\n\tint h, i;\n\tstruct arpcom *ac = &sc_if->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t dummy[] = { 0, 0, 0, 0, 0 ,0 };\n\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < XM_RXFILT_MAX; i++)\n\t\tsk_setfilt(sc_if, (caddr_t)&dummy, i);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, 0);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, 0);\n\n\t/* Now program new ones. */\nallmulti:\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\t/* First find the tail of the list. */\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tgoto allmulti;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Program the first XM_RXFILT_MAX multicast groups\n\t\t\t * into the perfect filter. For all others,\n\t\t\t * use the hash table.\n\t\t\t */\n\t\t\tif (i < XM_RXFILT_MAX) {\n\t\t\t\tsk_setfilt(sc_if, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\th = sk_calchash(enm->enm_addrlo);\n\t\t\t\tif (h < 32)\n\t\t\t\t\thashes[0] |= (1 << h);\n\t\t\t\telse\n\t\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t}\n\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_HASH|\n\t    XM_MODE_RX_USE_PERFECT);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc_if->arpcom"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc_if->arpcom"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_stop",
          "args": [
            "sc_if"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "sk_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "1723-1771",
          "snippet": "void sk_stop(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tint\t\t\ti;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = sc_if->sk_softc;\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* Turn off various components of this interface. */\n\tSK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);\n\n\t/* Disable interrupts */\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask &= ~SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask &= ~SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Free RX and TX mbufs still in the queues. */\n\tfor (i = 0; i < SK_RX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_rx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SK_TX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_tx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_stop;\n\nvoid sk_stop(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tint\t\t\ti;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\n\tsc = sc_if->sk_softc;\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* Turn off various components of this interface. */\n\tSK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_OFFLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);\n\n\t/* Disable interrupts */\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask &= ~SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask &= ~SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Free RX and TX mbufs still in the queues. */\n\tfor (i = 0; i < SK_RX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_rx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_rx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SK_TX_RING_CNT; i++) {\n\t\tif (sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf != NULL) {\n\t\t\tm_freem(sc_if->sk_cdata.sk_tx_chain[i].sk_mbuf);\n\t\t\tsc_if->sk_cdata.sk_tx_chain[i].sk_mbuf = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_init",
          "args": [
            "sc_if"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "sk_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "1620-1721",
          "snippet": "void sk_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sk_if_softc\t*sc_if = xsc;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tifp = &sc_if->arpcom.ac_if;\n\tsc = sc_if->sk_softc;\n\n\t/* Cancel pending I/O and free all RX/TX buffers. */\n\tsk_stop(sc_if);\n\n\t/* Configure LINK_SYNC LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_ON);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_ON);\n\n\t/* Configure RX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_START);\n\n\t/* Configure TX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_TXLEDCTL_COUNTER_START);\n\n\t/* Configure I2C registers */\n\n\t/* Configure XMAC(s) */\n\tsk_init_xmac(sc_if);\n\n\t/* Configure MAC FIFOs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_ON);\n\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_ON);\n\n\t/* Configure transmit arbiter(s) */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL,\n\t    SK_TXARCTL_ON|SK_TXARCTL_FSYNC_ON);\n\n\t/* Configure RAMbuffers */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_START, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_WR_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_RD_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_END, sc_if->sk_rx_ramend);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_ON);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_STORENFWD_ON);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_START, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_WR_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_RD_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_END, sc_if->sk_tx_ramend);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_ON);\n\n\t/* Configure BMUs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_rx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_HI, 0);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_tx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_HI, 0);\n\n\t/* Init descriptors */\n\tif (sk_init_rx_ring(sc_if) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc_if->sk_dev.dv_xname);\n\t\tsk_stop(sc_if);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\tsk_init_tx_ring(sc_if);\n\n\t/* Configure interrupt handling */\n\tCSR_READ_4(sc, SK_ISSR);\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask |= SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask |= SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Start BMUs. */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_START);\n\n\t/* Enable XMACs TX and RX state machines */\n\tSK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_init",
            "void sk_init_xmac",
            "void sk_stop",
            "int sk_init_rx_ring",
            "void sk_init_tx_ring"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_init;\nvoid sk_init_xmac;\nvoid sk_stop;\nint sk_init_rx_ring;\nvoid sk_init_tx_ring;\n\nvoid sk_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct sk_if_softc\t*sc_if = xsc;\n\tstruct sk_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tifp = &sc_if->arpcom.ac_if;\n\tsc = sc_if->sk_softc;\n\n\t/* Cancel pending I/O and free all RX/TX buffers. */\n\tsk_stop(sc_if);\n\n\t/* Configure LINK_SYNC LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_ON);\n\tSK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_ON);\n\n\t/* Configure RX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_START);\n\n\t/* Configure TX LED */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_TXLEDCTL_COUNTER_START);\n\n\t/* Configure I2C registers */\n\n\t/* Configure XMAC(s) */\n\tsk_init_xmac(sc_if);\n\n\t/* Configure MAC FIFOs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_ON);\n\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_END, SK_FIFO_END);\n\tSK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_ON);\n\n\t/* Configure transmit arbiter(s) */\n\tSK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL,\n\t    SK_TXARCTL_ON|SK_TXARCTL_FSYNC_ON);\n\n\t/* Configure RAMbuffers */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_START, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_WR_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_RD_PTR, sc_if->sk_rx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_END, sc_if->sk_rx_ramend);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_ON);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_UNRESET);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_STORENFWD_ON);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_START, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_WR_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_RD_PTR, sc_if->sk_tx_ramstart);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_END, sc_if->sk_tx_ramend);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_ON);\n\n\t/* Configure BMUs */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_rx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_HI, 0);\n\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_ONLINE);\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_LO,\n\t    vtophys(&sc_if->sk_rdata->sk_tx_ring[0]));\n\tSK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_HI, 0);\n\n\t/* Init descriptors */\n\tif (sk_init_rx_ring(sc_if) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no \"\n\t\t    \"memory for rx buffers\\n\", sc_if->sk_dev.dv_xname);\n\t\tsk_stop(sc_if);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\tsk_init_tx_ring(sc_if);\n\n\t/* Configure interrupt handling */\n\tCSR_READ_4(sc, SK_ISSR);\n\tif (sc_if->sk_port == SK_PORT_A)\n\t\tsc->sk_intrmask |= SK_INTRS1;\n\telse\n\t\tsc->sk_intrmask |= SK_INTRS2;\n\tCSR_WRITE_4(sc, SK_IMR, sc->sk_intrmask);\n\n\t/* Start BMUs. */\n\tSK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_START);\n\n\t/* Enable XMACs TX and RX state machines */\n\tSK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_XM_CLRBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_RX_PROMISC"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_RX_PROMISC"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc_if->arpcom",
            "ifa"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc_if->arpcom",
            "command",
            "data"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_ioctl;\nvoid sk_init;\nvoid sk_stop;\nvoid sk_setmulti;\n\nint\nsk_ioctl(ifp, command, data)\n\tstruct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct sk_if_softc *sc_if = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *) data;\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint s, error = 0;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc_if->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tsk_init(sc_if);\n\t\t\tarp_ifinit(&sc_if->arpcom, ifa);\n\t\t\tbreak;\n#endif /* INET */\n\t\tdefault:\n\t\t\tsk_init(sc_if);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc_if->sk_if_flags & IFF_PROMISC)) {\n\t\t\t\tSK_XM_SETBIT_4(sc_if, XM_MODE,\n\t\t\t\t    XM_MODE_RX_PROMISC);\n\t\t\t\tsk_setmulti(sc_if);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc_if->sk_if_flags & IFF_PROMISC) {\n\t\t\t\tSK_XM_CLRBIT_4(sc_if, XM_MODE,\n\t\t\t\t    XM_MODE_RX_PROMISC);\n\t\t\t\tsk_setmulti(sc_if);\n\t\t\t} else\n\t\t\t\tsk_init(sc_if);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tsk_stop(sc_if);\n\t\t}\n\t\tsc_if->sk_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc_if->arpcom) :\n\t\t    ether_delmulti(ifr, &sc_if->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tsk_setmulti(sc_if);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc_if->ifmedia, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}"
  },
  {
    "function_name": "sk_ifmedia_sts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "632-660",
    "snippet": "void sk_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct sk_softc\t\t*sc;\n\tstruct sk_if_softc\t*sc_if;\n\tu_int16_t\t\tbmsr, extsts;\n\n\tsc_if = ifp->if_softc;\n\tsc = sc_if->sk_softc;\n\n\tifmr->ifm_status = IFM_AVALID;\n\tifmr->ifm_active = IFM_ETHER;\n\n\tbmsr = sk_phy_readreg(sc_if, XM_PHY_BMSR);\n\textsts = sk_phy_readreg(sc_if, XM_PHY_EXTSTS);\n\n\tif (!(bmsr & XM_BMSR_LINKSTAT))\n\t\treturn;\n\n\tifmr->ifm_status |= IFM_ACTIVE;\n\tifmr->ifm_active |= sc->sk_pmd;;\n\tif (extsts & XM_EXTSTS_FULLDUPLEX)\n\t\tifmr->ifm_active |= IFM_FDX;\n\telse\n\t\tifmr->ifm_active |= IFM_HDX;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_ifmedia_sts",
      "u_int16_t sk_phy_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sk_phy_readreg",
          "args": [
            "sc_if",
            "XM_PHY_EXTSTS"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "sk_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "319-338",
          "snippet": "u_int16_t sk_phy_readreg(sc_if, reg)\n\tstruct sk_if_softc\t*sc_if;\n\tint\t\t\treg;\n{\n\tint\t\t\ti;\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT) {\n\t\tprintf(\"%s: phy failed to come ready\\n\",\n\t\t    sc_if->sk_dev.dv_xname);\n\t\treturn(0);\n\t}\n\n\treturn(SK_XM_READ_2(sc_if, XM_PHY_DATA));\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t sk_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t sk_phy_readreg;\n\nu_int16_t sk_phy_readreg(sc_if, reg)\n\tstruct sk_if_softc\t*sc_if;\n\tint\t\t\treg;\n{\n\tint\t\t\ti;\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT) {\n\t\tprintf(\"%s: phy failed to come ready\\n\",\n\t\t    sc_if->sk_dev.dv_xname);\n\t\treturn(0);\n\t}\n\n\treturn(SK_XM_READ_2(sc_if, XM_PHY_DATA));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_ifmedia_sts;\nu_int16_t sk_phy_readreg;\n\nvoid sk_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct sk_softc\t\t*sc;\n\tstruct sk_if_softc\t*sc_if;\n\tu_int16_t\t\tbmsr, extsts;\n\n\tsc_if = ifp->if_softc;\n\tsc = sc_if->sk_softc;\n\n\tifmr->ifm_status = IFM_AVALID;\n\tifmr->ifm_active = IFM_ETHER;\n\n\tbmsr = sk_phy_readreg(sc_if, XM_PHY_BMSR);\n\textsts = sk_phy_readreg(sc_if, XM_PHY_EXTSTS);\n\n\tif (!(bmsr & XM_BMSR_LINKSTAT))\n\t\treturn;\n\n\tifmr->ifm_status |= IFM_ACTIVE;\n\tifmr->ifm_active |= sc->sk_pmd;;\n\tif (extsts & XM_EXTSTS_FULLDUPLEX)\n\t\tifmr->ifm_active |= IFM_FDX;\n\telse\n\t\tifmr->ifm_active |= IFM_HDX;\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_ifmedia_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "594-627",
    "snippet": "int sk_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sk_if_softc\t*sc_if;\n\tstruct ifmedia\t\t*ifm;\n\n\tsc_if = ifp->if_softc;\n\tifm = &sc_if->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tswitch(IFM_SUBTYPE(ifm->ifm_media)) {\n\tcase IFM_AUTO:\n\t\tsk_phy_writereg(sc_if, XM_PHY_BMCR,\n\t\t    XM_BMCR_RENEGOTIATE|XM_BMCR_AUTONEGENBL);\n\t\tbreak;\n\tcase IFM_1000_LX:\n\tcase IFM_1000_SX:\n\tcase IFM_1000_CX:\n\tcase IFM_1000_TX:\n\t\tif ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)\n\t\t\tsk_phy_writereg(sc_if, XM_PHY_BMCR, XM_BMCR_DUPLEX);\n\t\telse\n\t\t\tsk_phy_writereg(sc_if, XM_PHY_BMCR, 0);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid media selected\\n\", sc_if->sk_dev.dv_xname);\n\t\treturn(EINVAL);\n\t\tbreak;\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sk_ifmedia_upd",
      "void sk_phy_writereg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: invalid media selected\\n\"",
            "sc_if->sk_dev.dv_xname"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_phy_writereg",
          "args": [
            "sc_if",
            "XM_PHY_BMCR",
            "0"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "sk_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "340-369",
          "snippet": "void sk_phy_writereg(sc_if, reg, val)\n\tstruct sk_if_softc\t*sc_if;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tint\t\t\ti;\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT) {\n\t\tprintf(\"%s: phy failed to come ready\\n\",\n\t\t    sc_if->sk_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_DATA, val);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT)\n\t\tprintf(\"%s: phy write timed out\\n\", sc_if->sk_dev.dv_xname);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_phy_writereg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_phy_writereg;\n\nvoid sk_phy_writereg(sc_if, reg, val)\n\tstruct sk_if_softc\t*sc_if;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tint\t\t\ti;\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT) {\n\t\tprintf(\"%s: phy failed to come ready\\n\",\n\t\t    sc_if->sk_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_DATA, val);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT)\n\t\tprintf(\"%s: phy write timed out\\n\", sc_if->sk_dev.dv_xname);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_TYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_ifmedia_upd;\nvoid sk_phy_writereg;\n\nint sk_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct sk_if_softc\t*sc_if;\n\tstruct ifmedia\t\t*ifm;\n\n\tsc_if = ifp->if_softc;\n\tifm = &sc_if->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tswitch(IFM_SUBTYPE(ifm->ifm_media)) {\n\tcase IFM_AUTO:\n\t\tsk_phy_writereg(sc_if, XM_PHY_BMCR,\n\t\t    XM_BMCR_RENEGOTIATE|XM_BMCR_AUTONEGENBL);\n\t\tbreak;\n\tcase IFM_1000_LX:\n\tcase IFM_1000_SX:\n\tcase IFM_1000_CX:\n\tcase IFM_1000_TX:\n\t\tif ((ifm->ifm_media & IFM_GMASK) == IFM_FDX)\n\t\t\tsk_phy_writereg(sc_if, XM_PHY_BMCR, XM_BMCR_DUPLEX);\n\t\telse\n\t\t\tsk_phy_writereg(sc_if, XM_PHY_BMCR, 0);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid media selected\\n\", sc_if->sk_dev.dv_xname);\n\t\treturn(EINVAL);\n\t\tbreak;\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sk_newbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "543-589",
    "snippet": "int sk_newbuf(sc_if, c, m)\n\tstruct sk_if_softc\t*sc_if;\n\tstruct sk_chain\t\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct sk_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc_if->sk_dev.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t} else {\n\t\t/*\n\t \t * We're re-using a previously allocated mbuf;\n\t\t * be sure to re-init pointers and lengths to\n\t\t * default values.\n\t\t */\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/*\n\t * Adjust alignment so packet payload begins on a\n\t * longword boundary. Mandatory for Alpha, useful on\n\t * x86 too.\n\t */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tr = c->sk_desc;\n\tc->sk_mbuf = m_new;\n\tr->sk_data_lo = vtophys(mtod(m_new, caddr_t));\n\tr->sk_ctl = m_new->m_len | SK_RXSTAT;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sk_newbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m_new",
            "ETHER_ALIGN"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\"",
            "sc_if->sk_dev.dv_xname"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_newbuf;\n\nint sk_newbuf(sc_if, c, m)\n\tstruct sk_if_softc\t*sc_if;\n\tstruct sk_chain\t\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct sk_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc_if->sk_dev.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t} else {\n\t\t/*\n\t \t * We're re-using a previously allocated mbuf;\n\t\t * be sure to re-init pointers and lengths to\n\t\t * default values.\n\t\t */\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/*\n\t * Adjust alignment so packet payload begins on a\n\t * longword boundary. Mandatory for Alpha, useful on\n\t * x86 too.\n\t */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tr = c->sk_desc;\n\tc->sk_mbuf = m_new;\n\tr->sk_data_lo = vtophys(mtod(m_new, caddr_t));\n\tr->sk_ctl = m_new->m_len | SK_RXSTAT;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sk_init_tx_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "508-541",
    "snippet": "void sk_init_tx_ring(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_chain_data\t*cd;\n\tstruct sk_ring_data\t*rd;\n\tint\t\t\ti;\n\n\tcd = &sc_if->sk_cdata;\n\trd = sc_if->sk_rdata;\n\n\tbzero((char *)sc_if->sk_rdata->sk_tx_ring,\n\t    sizeof(struct sk_tx_desc) * SK_TX_RING_CNT);\n\n\tfor (i = 0; i < SK_TX_RING_CNT; i++) {\n\t\tcd->sk_tx_chain[i].sk_desc = &rd->sk_tx_ring[i];\n\t\tif (i == (SK_TX_RING_CNT - 1)) {\n\t\t\tcd->sk_tx_chain[i].sk_next =\n\t\t\t    &cd->sk_tx_chain[0];\n\t\t\trd->sk_tx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_tx_ring[0]);\n\t\t} else {\n\t\t\tcd->sk_tx_chain[i].sk_next =\n\t\t\t    &cd->sk_tx_chain[i + 1];\n\t\t\trd->sk_tx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_tx_ring[i + 1]);\n\t\t}\n\t}\n\n\tsc_if->sk_cdata.sk_tx_prod = 0;\n\tsc_if->sk_cdata.sk_tx_cons = 0;\n\tsc_if->sk_cdata.sk_tx_cnt = 0;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_init_tx_ring"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&rd->sk_tx_ring[i + 1]"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&rd->sk_tx_ring[0]"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)sc_if->sk_rdata->sk_tx_ring",
            "sizeof(struct sk_tx_desc) * SK_TX_RING_CNT"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_init_tx_ring;\n\nvoid sk_init_tx_ring(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_chain_data\t*cd;\n\tstruct sk_ring_data\t*rd;\n\tint\t\t\ti;\n\n\tcd = &sc_if->sk_cdata;\n\trd = sc_if->sk_rdata;\n\n\tbzero((char *)sc_if->sk_rdata->sk_tx_ring,\n\t    sizeof(struct sk_tx_desc) * SK_TX_RING_CNT);\n\n\tfor (i = 0; i < SK_TX_RING_CNT; i++) {\n\t\tcd->sk_tx_chain[i].sk_desc = &rd->sk_tx_ring[i];\n\t\tif (i == (SK_TX_RING_CNT - 1)) {\n\t\t\tcd->sk_tx_chain[i].sk_next =\n\t\t\t    &cd->sk_tx_chain[0];\n\t\t\trd->sk_tx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_tx_ring[0]);\n\t\t} else {\n\t\t\tcd->sk_tx_chain[i].sk_next =\n\t\t\t    &cd->sk_tx_chain[i + 1];\n\t\t\trd->sk_tx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_tx_ring[i + 1]);\n\t\t}\n\t}\n\n\tsc_if->sk_cdata.sk_tx_prod = 0;\n\tsc_if->sk_cdata.sk_tx_cons = 0;\n\tsc_if->sk_cdata.sk_tx_cnt = 0;\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_init_rx_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "469-506",
    "snippet": "int sk_init_rx_ring(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_chain_data\t*cd;\n\tstruct sk_ring_data\t*rd;\n\tint\t\t\ti;\n\n\tcd = &sc_if->sk_cdata;\n\trd = sc_if->sk_rdata;\n\n\tbzero((char *)rd->sk_rx_ring,\n\t    sizeof(struct sk_rx_desc) * SK_RX_RING_CNT);\n\n\tfor (i = 0; i < SK_RX_RING_CNT; i++) {\n\t\tcd->sk_rx_chain[i].sk_desc = &rd->sk_rx_ring[i];\n\t\tif (sk_newbuf(sc_if, &cd->sk_rx_chain[i], NULL) == ENOBUFS) {\n\t\t\tprintf(\"%s: failed alloc of %dth mbuf\\n\",\n\t\t\t    sc_if->sk_dev.dv_xname, i);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tif (i == (SK_RX_RING_CNT - 1)) {\n\t\t\tcd->sk_rx_chain[i].sk_next =\n\t\t\t    &cd->sk_rx_chain[0];\n\t\t\trd->sk_rx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_rx_ring[0]);\n\t\t} else {\n\t\t\tcd->sk_rx_chain[i].sk_next =\n\t\t\t    &cd->sk_rx_chain[i + 1];\n\t\t\trd->sk_rx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_rx_ring[i + 1]);\n\t\t}\n\t}\n\n\tsc_if->sk_cdata.sk_rx_prod = 0;\n\tsc_if->sk_cdata.sk_rx_cons = 0;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int sk_newbuf",
      "int sk_init_rx_ring"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&rd->sk_rx_ring[i + 1]"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&rd->sk_rx_ring[0]"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed alloc of %dth mbuf\\n\"",
            "sc_if->sk_dev.dv_xname",
            "i"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_newbuf",
          "args": [
            "sc_if",
            "&cd->sk_rx_chain[i]",
            "NULL"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "sk_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "543-589",
          "snippet": "int sk_newbuf(sc_if, c, m)\n\tstruct sk_if_softc\t*sc_if;\n\tstruct sk_chain\t\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct sk_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc_if->sk_dev.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t} else {\n\t\t/*\n\t \t * We're re-using a previously allocated mbuf;\n\t\t * be sure to re-init pointers and lengths to\n\t\t * default values.\n\t\t */\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/*\n\t * Adjust alignment so packet payload begins on a\n\t * longword boundary. Mandatory for Alpha, useful on\n\t * x86 too.\n\t */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tr = c->sk_desc;\n\tc->sk_mbuf = m_new;\n\tr->sk_data_lo = vtophys(mtod(m_new, caddr_t));\n\tr->sk_ctl = m_new->m_len | SK_RXSTAT;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int sk_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_newbuf;\n\nint sk_newbuf(sc_if, c, m)\n\tstruct sk_if_softc\t*sc_if;\n\tstruct sk_chain\t\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\tstruct sk_rx_desc\t*r;\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list -- \"\n\t\t\t    \"packet dropped!\\n\", sc_if->sk_dev.dv_xname);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\n\t\t/* Allocate the jumbo buffer */\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t} else {\n\t\t/*\n\t \t * We're re-using a previously allocated mbuf;\n\t\t * be sure to re-init pointers and lengths to\n\t\t * default values.\n\t\t */\n\t\tm_new = m;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/*\n\t * Adjust alignment so packet payload begins on a\n\t * longword boundary. Mandatory for Alpha, useful on\n\t * x86 too.\n\t */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tr = c->sk_desc;\n\tc->sk_mbuf = m_new;\n\tr->sk_data_lo = vtophys(mtod(m_new, caddr_t));\n\tr->sk_ctl = m_new->m_len | SK_RXSTAT;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)rd->sk_rx_ring",
            "sizeof(struct sk_rx_desc) * SK_RX_RING_CNT"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint sk_newbuf;\nint sk_init_rx_ring;\n\nint sk_init_rx_ring(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct sk_chain_data\t*cd;\n\tstruct sk_ring_data\t*rd;\n\tint\t\t\ti;\n\n\tcd = &sc_if->sk_cdata;\n\trd = sc_if->sk_rdata;\n\n\tbzero((char *)rd->sk_rx_ring,\n\t    sizeof(struct sk_rx_desc) * SK_RX_RING_CNT);\n\n\tfor (i = 0; i < SK_RX_RING_CNT; i++) {\n\t\tcd->sk_rx_chain[i].sk_desc = &rd->sk_rx_ring[i];\n\t\tif (sk_newbuf(sc_if, &cd->sk_rx_chain[i], NULL) == ENOBUFS) {\n\t\t\tprintf(\"%s: failed alloc of %dth mbuf\\n\",\n\t\t\t    sc_if->sk_dev.dv_xname, i);\n\t\t\treturn(ENOBUFS);\n\t\t}\n\t\tif (i == (SK_RX_RING_CNT - 1)) {\n\t\t\tcd->sk_rx_chain[i].sk_next =\n\t\t\t    &cd->sk_rx_chain[0];\n\t\t\trd->sk_rx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_rx_ring[0]);\n\t\t} else {\n\t\t\tcd->sk_rx_chain[i].sk_next =\n\t\t\t    &cd->sk_rx_chain[i + 1];\n\t\t\trd->sk_rx_ring[i].sk_next = \n\t\t\t    vtophys(&rd->sk_rx_ring[i + 1]);\n\t\t}\n\t}\n\n\tsc_if->sk_cdata.sk_rx_prod = 0;\n\tsc_if->sk_cdata.sk_rx_cons = 0;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "sk_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "406-467",
    "snippet": "void\nsk_setmulti(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct ifnet *ifp;\n\tu_int32_t hashes[2] = { 0, 0 };\n\tint h, i;\n\tstruct arpcom *ac = &sc_if->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t dummy[] = { 0, 0, 0, 0, 0 ,0 };\n\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < XM_RXFILT_MAX; i++)\n\t\tsk_setfilt(sc_if, (caddr_t)&dummy, i);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, 0);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, 0);\n\n\t/* Now program new ones. */\nallmulti:\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\t/* First find the tail of the list. */\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tgoto allmulti;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Program the first XM_RXFILT_MAX multicast groups\n\t\t\t * into the perfect filter. For all others,\n\t\t\t * use the hash table.\n\t\t\t */\n\t\t\tif (i < XM_RXFILT_MAX) {\n\t\t\t\tsk_setfilt(sc_if, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\th = sk_calchash(enm->enm_addrlo);\n\t\t\t\tif (h < 32)\n\t\t\t\t\thashes[0] |= (1 << h);\n\t\t\t\telse\n\t\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t}\n\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_HASH|\n\t    XM_MODE_RX_USE_PERFECT);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int32_t sk_calchash",
      "void sk_setfilt",
      "void sk_setmulti"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SK_XM_WRITE_4",
          "args": [
            "sc_if",
            "XM_MAR2",
            "hashes[1]"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_4",
          "args": [
            "sc_if",
            "XM_MAR0",
            "hashes[0]"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_SETBIT_4",
          "args": [
            "sc_if",
            "XM_MODE",
            "XM_MODE_RX_USE_HASH|\n\t    XM_MODE_RX_USE_PERFECT"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_calchash",
          "args": [
            "enm->enm_addrlo"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "sk_calchash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "374-388",
          "snippet": "u_int32_t sk_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? SK_POLY : 0);\n\t}\n\n\treturn (~crc & ((1 << SK_BITS) - 1));\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define SK_BITS\t\t6",
            "#define SK_POLY\t\t0xEDB88320"
          ],
          "globals_used": [
            "u_int32_t sk_calchash"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SK_BITS\t\t6\n#define SK_POLY\t\t0xEDB88320\n\nu_int32_t sk_calchash;\n\nu_int32_t sk_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? SK_POLY : 0);\n\t}\n\n\treturn (~crc & ((1 << SK_BITS) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_setfilt",
          "args": [
            "sc_if",
            "enm->enm_addrlo",
            "i"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "sk_setfilt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "390-404",
          "snippet": "void sk_setfilt(sc_if, addr, slot)\n\tstruct sk_if_softc\t*sc_if;\n\tcaddr_t\t\t\taddr;\n\tint\t\t\tslot;\n{\n\tint\t\t\tbase;\n\n\tbase = XM_RXFILT_ENTRY(slot);\n\n\tSK_XM_WRITE_2(sc_if, base, *(u_int16_t *)(&addr[0]));\n\tSK_XM_WRITE_2(sc_if, base + 2, *(u_int16_t *)(&addr[2]));\n\tSK_XM_WRITE_2(sc_if, base + 4, *(u_int16_t *)(&addr[4]));\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_setfilt"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_setfilt;\n\nvoid sk_setfilt(sc_if, addr, slot)\n\tstruct sk_if_softc\t*sc_if;\n\tcaddr_t\t\t\taddr;\n\tint\t\t\tslot;\n{\n\tint\t\t\tbase;\n\n\tbase = XM_RXFILT_ENTRY(slot);\n\n\tSK_XM_WRITE_2(sc_if, base, *(u_int16_t *)(&addr[0]));\n\tSK_XM_WRITE_2(sc_if, base + 2, *(u_int16_t *)(&addr[2]));\n\tSK_XM_WRITE_2(sc_if, base + 4, *(u_int16_t *)(&addr[4]));\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "ETHER_ADDR_LEN"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_4",
          "args": [
            "sc_if",
            "XM_MAR2",
            "0"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_4",
          "args": [
            "sc_if",
            "XM_MAR0",
            "0"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t sk_calchash;\nvoid sk_setfilt;\nvoid sk_setmulti;\n\nvoid\nsk_setmulti(sc_if)\n\tstruct sk_if_softc\t*sc_if;\n{\n\tstruct ifnet *ifp;\n\tu_int32_t hashes[2] = { 0, 0 };\n\tint h, i;\n\tstruct arpcom *ac = &sc_if->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t dummy[] = { 0, 0, 0, 0, 0 ,0 };\n\n\tifp = &sc_if->arpcom.ac_if;\n\n\t/* First, zot all the existing filters. */\n\tfor (i = 1; i < XM_RXFILT_MAX; i++)\n\t\tsk_setfilt(sc_if, (caddr_t)&dummy, i);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, 0);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, 0);\n\n\t/* Now program new ones. */\nallmulti:\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\thashes[0] = 0xFFFFFFFF;\n\t\thashes[1] = 0xFFFFFFFF;\n\t} else {\n\t\ti = 1;\n\t\t/* First find the tail of the list. */\n\t\tETHER_FIRST_MULTI(step, ac, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t\tgoto allmulti;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Program the first XM_RXFILT_MAX multicast groups\n\t\t\t * into the perfect filter. For all others,\n\t\t\t * use the hash table.\n\t\t\t */\n\t\t\tif (i < XM_RXFILT_MAX) {\n\t\t\t\tsk_setfilt(sc_if, enm->enm_addrlo, i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\th = sk_calchash(enm->enm_addrlo);\n\t\t\t\tif (h < 32)\n\t\t\t\t\thashes[0] |= (1 << h);\n\t\t\t\telse\n\t\t\t\t\thashes[1] |= (1 << (h - 32));\n\t\t\t}\n\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\n\tSK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_HASH|\n\t    XM_MODE_RX_USE_PERFECT);\n\tSK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);\n\tSK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_setfilt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "390-404",
    "snippet": "void sk_setfilt(sc_if, addr, slot)\n\tstruct sk_if_softc\t*sc_if;\n\tcaddr_t\t\t\taddr;\n\tint\t\t\tslot;\n{\n\tint\t\t\tbase;\n\n\tbase = XM_RXFILT_ENTRY(slot);\n\n\tSK_XM_WRITE_2(sc_if, base, *(u_int16_t *)(&addr[0]));\n\tSK_XM_WRITE_2(sc_if, base + 2, *(u_int16_t *)(&addr[2]));\n\tSK_XM_WRITE_2(sc_if, base + 4, *(u_int16_t *)(&addr[4]));\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_setfilt"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "base + 4",
            "*(u_int16_t *)(&addr[4])"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "base + 2",
            "*(u_int16_t *)(&addr[2])"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "base",
            "*(u_int16_t *)(&addr[0])"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XM_RXFILT_ENTRY",
          "args": [
            "slot"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_setfilt;\n\nvoid sk_setfilt(sc_if, addr, slot)\n\tstruct sk_if_softc\t*sc_if;\n\tcaddr_t\t\t\taddr;\n\tint\t\t\tslot;\n{\n\tint\t\t\tbase;\n\n\tbase = XM_RXFILT_ENTRY(slot);\n\n\tSK_XM_WRITE_2(sc_if, base, *(u_int16_t *)(&addr[0]));\n\tSK_XM_WRITE_2(sc_if, base + 2, *(u_int16_t *)(&addr[2]));\n\tSK_XM_WRITE_2(sc_if, base + 4, *(u_int16_t *)(&addr[4]));\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_calchash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "374-388",
    "snippet": "u_int32_t sk_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? SK_POLY : 0);\n\t}\n\n\treturn (~crc & ((1 << SK_BITS) - 1));\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define SK_BITS\t\t6",
      "#define SK_POLY\t\t0xEDB88320"
    ],
    "globals_used": [
      "u_int32_t sk_calchash"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define SK_BITS\t\t6\n#define SK_POLY\t\t0xEDB88320\n\nu_int32_t sk_calchash;\n\nu_int32_t sk_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tidx, bit, data, crc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (idx = 0; idx < 6; idx++) {\n\t\tfor (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)\n\t\t\tcrc = (crc >> 1) ^ (((crc ^ data) & 1) ? SK_POLY : 0);\n\t}\n\n\treturn (~crc & ((1 << SK_BITS) - 1));\n}"
  },
  {
    "function_name": "sk_phy_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "340-369",
    "snippet": "void sk_phy_writereg(sc_if, reg, val)\n\tstruct sk_if_softc\t*sc_if;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tint\t\t\ti;\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT) {\n\t\tprintf(\"%s: phy failed to come ready\\n\",\n\t\t    sc_if->sk_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_DATA, val);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT)\n\t\tprintf(\"%s: phy write timed out\\n\", sc_if->sk_dev.dv_xname);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_phy_writereg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: phy write timed out\\n\"",
            "sc_if->sk_dev.dv_xname"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_XM_READ_2",
          "args": [
            "sc_if",
            "XM_MMUCMD"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "XM_PHY_DATA",
            "val"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_READ_2",
          "args": [
            "sc_if",
            "XM_MMUCMD"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "XM_PHY_ADDR",
            "reg"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_phy_writereg;\n\nvoid sk_phy_writereg(sc_if, reg, val)\n\tstruct sk_if_softc\t*sc_if;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tint\t\t\ti;\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT) {\n\t\tprintf(\"%s: phy failed to come ready\\n\",\n\t\t    sc_if->sk_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_DATA, val);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT)\n\t\tprintf(\"%s: phy write timed out\\n\", sc_if->sk_dev.dv_xname);\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_phy_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "319-338",
    "snippet": "u_int16_t sk_phy_readreg(sc_if, reg)\n\tstruct sk_if_softc\t*sc_if;\n\tint\t\t\treg;\n{\n\tint\t\t\ti;\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT) {\n\t\tprintf(\"%s: phy failed to come ready\\n\",\n\t\t    sc_if->sk_dev.dv_xname);\n\t\treturn(0);\n\t}\n\n\treturn(SK_XM_READ_2(sc_if, XM_PHY_DATA));\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int16_t sk_phy_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SK_XM_READ_2",
          "args": [
            "sc_if",
            "XM_PHY_DATA"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: phy failed to come ready\\n\"",
            "sc_if->sk_dev.dv_xname"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_XM_READ_2",
          "args": [
            "sc_if",
            "XM_MMUCMD"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_XM_WRITE_2",
          "args": [
            "sc_if",
            "XM_PHY_ADDR",
            "reg"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t sk_phy_readreg;\n\nu_int16_t sk_phy_readreg(sc_if, reg)\n\tstruct sk_if_softc\t*sc_if;\n\tint\t\t\treg;\n{\n\tint\t\t\ti;\n\n\tSK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tif (!(SK_XM_READ_2(sc_if, XM_MMUCMD) & XM_MMUCMD_PHYBUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT) {\n\t\tprintf(\"%s: phy failed to come ready\\n\",\n\t\t    sc_if->sk_dev.dv_xname);\n\t\treturn(0);\n\t}\n\n\treturn(SK_XM_READ_2(sc_if, XM_PHY_DATA));\n}"
  },
  {
    "function_name": "sk_vpd_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "275-317",
    "snippet": "void sk_vpd_read(sc)\n\tstruct sk_softc\t\t*sc;\n{\n\tint\t\t\tpos = 0, i;\n\tstruct vpd_res\t\tres;\n\n\tif (sc->sk_vpd_prodname != NULL)\n\t\tfree(sc->sk_vpd_prodname, M_DEVBUF);\n\tif (sc->sk_vpd_readonly != NULL)\n\t\tfree(sc->sk_vpd_readonly, M_DEVBUF);\n\tsc->sk_vpd_prodname = NULL;\n\tsc->sk_vpd_readonly = NULL;\n\n\tsk_vpd_read_res(sc, &res, pos);\n\n\tif (res.vr_id != VPD_RES_ID) {\n\t\tprintf(\"%s: bad VPD resource id: expected %x got %x\\n\",\n\t\t    sc->sk_dev.dv_xname, VPD_RES_ID, res.vr_id);\n\t\treturn;\n\t}\n\n\tpos += sizeof(res);\n\tsc->sk_vpd_prodname = malloc(res.vr_len + 1, M_DEVBUF, M_NOWAIT);\n\tfor (i = 0; i < res.vr_len; i++)\n\t\tsc->sk_vpd_prodname[i] = sk_vpd_readbyte(sc, i + pos);\n\tsc->sk_vpd_prodname[i] = '\\0';\n\tpos += i;\n\n\tsk_vpd_read_res(sc, &res, pos);\n\n\tif (res.vr_id != VPD_RES_READ) {\n\t\tprintf(\"%s: bad VPD resource id: expected %x got %x\\n\",\n\t\t    sc->sk_dev.dv_xname, VPD_RES_READ, res.vr_id);\n\t\treturn;\n\t}\n\n\tpos += sizeof(res);\n\tsc->sk_vpd_readonly = malloc(res.vr_len, M_DEVBUF, M_NOWAIT);\n\tfor (i = 0; i < res.vr_len + 1; i++)\n\t\tsc->sk_vpd_readonly[i] = sk_vpd_readbyte(sc, i + pos);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t sk_vpd_readbyte",
      "void sk_vpd_read_res",
      "void sk_vpd_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sk_vpd_readbyte",
          "args": [
            "sc",
            "i + pos"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "sk_vpd_readbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "240-258",
          "snippet": "u_int8_t sk_vpd_readbyte(sc, addr)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tint\t\t\ti;\n\n\tsk_win_write_2(sc, SK_PCI_REG(SK_PCI_VPD_ADDR), addr);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tDELAY(1);\n\t\tif (sk_win_read_2(sc,\n\t\t    SK_PCI_REG(SK_PCI_VPD_ADDR)) & SK_VPD_FLAG)\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT)\n\t\treturn(0);\n\n\treturn(sk_win_read_1(sc, SK_PCI_REG(SK_PCI_VPD_DATA)));\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t sk_win_read_2",
            "u_int8_t sk_win_read_1",
            "void sk_win_write_2",
            "u_int8_t sk_vpd_readbyte"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t sk_win_read_2;\nu_int8_t sk_win_read_1;\nvoid sk_win_write_2;\nu_int8_t sk_vpd_readbyte;\n\nu_int8_t sk_vpd_readbyte(sc, addr)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tint\t\t\ti;\n\n\tsk_win_write_2(sc, SK_PCI_REG(SK_PCI_VPD_ADDR), addr);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tDELAY(1);\n\t\tif (sk_win_read_2(sc,\n\t\t    SK_PCI_REG(SK_PCI_VPD_ADDR)) & SK_VPD_FLAG)\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT)\n\t\treturn(0);\n\n\treturn(sk_win_read_1(sc, SK_PCI_REG(SK_PCI_VPD_DATA)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "res.vr_len",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bad VPD resource id: expected %x got %x\\n\"",
            "sc->sk_dev.dv_xname",
            "VPD_RES_READ",
            "res.vr_id"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sk_vpd_read_res",
          "args": [
            "sc",
            "&res",
            "pos"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "sk_vpd_read_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "260-273",
          "snippet": "void sk_vpd_read_res(sc, res, addr)\n\tstruct sk_softc\t\t*sc;\n\tstruct vpd_res\t\t*res;\n\tint\t\t\taddr;\n{\n\tint\t\t\ti;\n\tu_int8_t\t\t*ptr;\n\n\tptr = (u_int8_t *)res;\n\tfor (i = 0; i < sizeof(struct vpd_res); i++)\n\t\tptr[i] = sk_vpd_readbyte(sc, i + addr);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t sk_vpd_readbyte",
            "void sk_vpd_read_res"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t sk_vpd_readbyte;\nvoid sk_vpd_read_res;\n\nvoid sk_vpd_read_res(sc, res, addr)\n\tstruct sk_softc\t\t*sc;\n\tstruct vpd_res\t\t*res;\n\tint\t\t\taddr;\n{\n\tint\t\t\ti;\n\tu_int8_t\t\t*ptr;\n\n\tptr = (u_int8_t *)res;\n\tfor (i = 0; i < sizeof(struct vpd_res); i++)\n\t\tptr[i] = sk_vpd_readbyte(sc, i + addr);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sc->sk_vpd_readonly",
            "M_DEVBUF"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "epic_freebsd_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "437-614",
          "snippet": "void\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include <pci/if_txvar.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_mib.h>",
            "#include <dev/pci/if_txvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sockio.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))",
            "#define EPIC_NOIFMEDIA\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\n#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))\n#define EPIC_NOIFMEDIA\t1\n\nvoid\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t sk_vpd_readbyte;\nvoid sk_vpd_read_res;\nvoid sk_vpd_read;\n\nvoid sk_vpd_read(sc)\n\tstruct sk_softc\t\t*sc;\n{\n\tint\t\t\tpos = 0, i;\n\tstruct vpd_res\t\tres;\n\n\tif (sc->sk_vpd_prodname != NULL)\n\t\tfree(sc->sk_vpd_prodname, M_DEVBUF);\n\tif (sc->sk_vpd_readonly != NULL)\n\t\tfree(sc->sk_vpd_readonly, M_DEVBUF);\n\tsc->sk_vpd_prodname = NULL;\n\tsc->sk_vpd_readonly = NULL;\n\n\tsk_vpd_read_res(sc, &res, pos);\n\n\tif (res.vr_id != VPD_RES_ID) {\n\t\tprintf(\"%s: bad VPD resource id: expected %x got %x\\n\",\n\t\t    sc->sk_dev.dv_xname, VPD_RES_ID, res.vr_id);\n\t\treturn;\n\t}\n\n\tpos += sizeof(res);\n\tsc->sk_vpd_prodname = malloc(res.vr_len + 1, M_DEVBUF, M_NOWAIT);\n\tfor (i = 0; i < res.vr_len; i++)\n\t\tsc->sk_vpd_prodname[i] = sk_vpd_readbyte(sc, i + pos);\n\tsc->sk_vpd_prodname[i] = '\\0';\n\tpos += i;\n\n\tsk_vpd_read_res(sc, &res, pos);\n\n\tif (res.vr_id != VPD_RES_READ) {\n\t\tprintf(\"%s: bad VPD resource id: expected %x got %x\\n\",\n\t\t    sc->sk_dev.dv_xname, VPD_RES_READ, res.vr_id);\n\t\treturn;\n\t}\n\n\tpos += sizeof(res);\n\tsc->sk_vpd_readonly = malloc(res.vr_len, M_DEVBUF, M_NOWAIT);\n\tfor (i = 0; i < res.vr_len + 1; i++)\n\t\tsc->sk_vpd_readonly[i] = sk_vpd_readbyte(sc, i + pos);\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_vpd_read_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "260-273",
    "snippet": "void sk_vpd_read_res(sc, res, addr)\n\tstruct sk_softc\t\t*sc;\n\tstruct vpd_res\t\t*res;\n\tint\t\t\taddr;\n{\n\tint\t\t\ti;\n\tu_int8_t\t\t*ptr;\n\n\tptr = (u_int8_t *)res;\n\tfor (i = 0; i < sizeof(struct vpd_res); i++)\n\t\tptr[i] = sk_vpd_readbyte(sc, i + addr);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t sk_vpd_readbyte",
      "void sk_vpd_read_res"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sk_vpd_readbyte",
          "args": [
            "sc",
            "i + addr"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "sk_vpd_readbyte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "240-258",
          "snippet": "u_int8_t sk_vpd_readbyte(sc, addr)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tint\t\t\ti;\n\n\tsk_win_write_2(sc, SK_PCI_REG(SK_PCI_VPD_ADDR), addr);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tDELAY(1);\n\t\tif (sk_win_read_2(sc,\n\t\t    SK_PCI_REG(SK_PCI_VPD_ADDR)) & SK_VPD_FLAG)\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT)\n\t\treturn(0);\n\n\treturn(sk_win_read_1(sc, SK_PCI_REG(SK_PCI_VPD_DATA)));\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t sk_win_read_2",
            "u_int8_t sk_win_read_1",
            "void sk_win_write_2",
            "u_int8_t sk_vpd_readbyte"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t sk_win_read_2;\nu_int8_t sk_win_read_1;\nvoid sk_win_write_2;\nu_int8_t sk_vpd_readbyte;\n\nu_int8_t sk_vpd_readbyte(sc, addr)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tint\t\t\ti;\n\n\tsk_win_write_2(sc, SK_PCI_REG(SK_PCI_VPD_ADDR), addr);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tDELAY(1);\n\t\tif (sk_win_read_2(sc,\n\t\t    SK_PCI_REG(SK_PCI_VPD_ADDR)) & SK_VPD_FLAG)\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT)\n\t\treturn(0);\n\n\treturn(sk_win_read_1(sc, SK_PCI_REG(SK_PCI_VPD_DATA)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t sk_vpd_readbyte;\nvoid sk_vpd_read_res;\n\nvoid sk_vpd_read_res(sc, res, addr)\n\tstruct sk_softc\t\t*sc;\n\tstruct vpd_res\t\t*res;\n\tint\t\t\taddr;\n{\n\tint\t\t\ti;\n\tu_int8_t\t\t*ptr;\n\n\tptr = (u_int8_t *)res;\n\tfor (i = 0; i < sizeof(struct vpd_res); i++)\n\t\tptr[i] = sk_vpd_readbyte(sc, i + addr);\n\n\treturn;\n}"
  },
  {
    "function_name": "sk_vpd_readbyte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "240-258",
    "snippet": "u_int8_t sk_vpd_readbyte(sc, addr)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tint\t\t\ti;\n\n\tsk_win_write_2(sc, SK_PCI_REG(SK_PCI_VPD_ADDR), addr);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tDELAY(1);\n\t\tif (sk_win_read_2(sc,\n\t\t    SK_PCI_REG(SK_PCI_VPD_ADDR)) & SK_VPD_FLAG)\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT)\n\t\treturn(0);\n\n\treturn(sk_win_read_1(sc, SK_PCI_REG(SK_PCI_VPD_DATA)));\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int16_t sk_win_read_2",
      "u_int8_t sk_win_read_1",
      "void sk_win_write_2",
      "u_int8_t sk_vpd_readbyte"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sk_win_read_1",
          "args": [
            "sc",
            "SK_PCI_REG(SK_PCI_VPD_DATA)"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "sk_win_read_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "191-197",
          "snippet": "u_int8_t sk_win_read_1(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg)));\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t sk_win_read_1"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t sk_win_read_1;\n\nu_int8_t sk_win_read_1(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_PCI_REG",
          "args": [
            "SK_PCI_VPD_DATA"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_win_read_2",
          "args": [
            "sc",
            "SK_PCI_REG(SK_PCI_VPD_ADDR)"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "sk_win_read_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "183-189",
          "snippet": "u_int16_t sk_win_read_2(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_2(sc, SK_WIN_BASE + SK_REG(reg)));\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t sk_win_read_2"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t sk_win_read_2;\n\nu_int16_t sk_win_read_2(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_2(sc, SK_WIN_BASE + SK_REG(reg)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_PCI_REG",
          "args": [
            "SK_PCI_VPD_ADDR"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sk_win_write_2",
          "args": [
            "sc",
            "SK_PCI_REG(SK_PCI_VPD_ADDR)",
            "addr"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "sk_win_write_2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
          "lines": "209-217",
          "snippet": "void sk_win_write_2(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), (u_int32_t)val);\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/xmaciireg.h>",
            "#include <dev/pci/if_skreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void sk_win_write_2"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_win_write_2;\n\nvoid sk_win_write_2(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), (u_int32_t)val);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SK_PCI_REG",
          "args": [
            "SK_PCI_VPD_ADDR"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t sk_win_read_2;\nu_int8_t sk_win_read_1;\nvoid sk_win_write_2;\nu_int8_t sk_vpd_readbyte;\n\nu_int8_t sk_vpd_readbyte(sc, addr)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\taddr;\n{\n\tint\t\t\ti;\n\n\tsk_win_write_2(sc, SK_PCI_REG(SK_PCI_VPD_ADDR), addr);\n\tfor (i = 0; i < SK_TIMEOUT; i++) {\n\t\tDELAY(1);\n\t\tif (sk_win_read_2(sc,\n\t\t    SK_PCI_REG(SK_PCI_VPD_ADDR)) & SK_VPD_FLAG)\n\t\t\tbreak;\n\t}\n\n\tif (i == SK_TIMEOUT)\n\t\treturn(0);\n\n\treturn(sk_win_read_1(sc, SK_PCI_REG(SK_PCI_VPD_DATA)));\n}"
  },
  {
    "function_name": "sk_win_write_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "219-227",
    "snippet": "void sk_win_write_1(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_1(sc, SK_WIN_BASE + SK_REG(reg), val);\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_win_write_1"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "SK_WIN_BASE + SK_REG(reg)",
            "val"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_REG",
          "args": [
            "reg"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_RAP",
            "SK_WIN(reg)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_WIN",
          "args": [
            "reg"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_win_write_1;\n\nvoid sk_win_write_1(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_1(sc, SK_WIN_BASE + SK_REG(reg), val);\n\treturn;\n}"
  },
  {
    "function_name": "sk_win_write_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "209-217",
    "snippet": "void sk_win_write_2(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), (u_int32_t)val);\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_win_write_2"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "SK_WIN_BASE + SK_REG(reg)",
            "(u_int32_t)val"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_REG",
          "args": [
            "reg"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_RAP",
            "SK_WIN(reg)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_WIN",
          "args": [
            "reg"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_win_write_2;\n\nvoid sk_win_write_2(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), (u_int32_t)val);\n\treturn;\n}"
  },
  {
    "function_name": "sk_win_write_4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "199-207",
    "snippet": "void sk_win_write_4(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_4(sc, SK_WIN_BASE + SK_REG(reg), val);\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void sk_win_write_4"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_WIN_BASE + SK_REG(reg)",
            "val"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_REG",
          "args": [
            "reg"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_RAP",
            "SK_WIN(reg)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_WIN",
          "args": [
            "reg"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid sk_win_write_4;\n\nvoid sk_win_write_4(sc, reg, val)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n\tu_int32_t\t\tval;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\tCSR_WRITE_4(sc, SK_WIN_BASE + SK_REG(reg), val);\n\treturn;\n}"
  },
  {
    "function_name": "sk_win_read_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "191-197",
    "snippet": "u_int8_t sk_win_read_1(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg)));\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t sk_win_read_1"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "SK_WIN_BASE + SK_REG(reg)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_REG",
          "args": [
            "reg"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_RAP",
            "SK_WIN(reg)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_WIN",
          "args": [
            "reg"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t sk_win_read_1;\n\nu_int8_t sk_win_read_1(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg)));\n}"
  },
  {
    "function_name": "sk_win_read_2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "183-189",
    "snippet": "u_int16_t sk_win_read_2(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_2(sc, SK_WIN_BASE + SK_REG(reg)));\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int16_t sk_win_read_2"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "SK_WIN_BASE + SK_REG(reg)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_REG",
          "args": [
            "reg"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_RAP",
            "SK_WIN(reg)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_WIN",
          "args": [
            "reg"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t sk_win_read_2;\n\nu_int16_t sk_win_read_2(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_2(sc, SK_WIN_BASE + SK_REG(reg)));\n}"
  },
  {
    "function_name": "sk_win_read_4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_sk.c",
    "lines": "174-180",
    "snippet": "u_int32_t sk_win_read_4(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_4(sc, SK_WIN_BASE + SK_REG(reg)));\n}",
    "includes": [
      "#include <dev/pci/xmaciireg.h>",
      "#include <dev/pci/if_skreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/bus.h>",
      "#include <vm/vm_extern.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "SK_WIN_BASE + SK_REG(reg)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_REG",
          "args": [
            "reg"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "SK_RAP",
            "SK_WIN(reg)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SK_WIN",
          "args": [
            "reg"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/xmaciireg.h>\n#include <dev/pci/if_skreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int32_t sk_win_read_4(sc, reg)\n\tstruct sk_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tCSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));\n\treturn(CSR_READ_4(sc, SK_WIN_BASE + SK_REG(reg)));\n}"
  }
]