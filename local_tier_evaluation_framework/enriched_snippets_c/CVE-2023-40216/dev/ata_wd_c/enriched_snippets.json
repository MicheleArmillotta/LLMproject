[
  {
    "function_name": "wdioctlstrategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1485-1587",
    "snippet": "void\nwdioctlstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct wd_ioctl *wi;\n\tstruct wdc_command wdc_c;\n\tint error = 0;\n\n\twi = wi_find(bp);\n\tif (wi == NULL) {\n\t\tprintf(\"user_strat: No ioctl\\n\");\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\tbzero(&wdc_c, sizeof(wdc_c));\n\n\t/*\n\t * Abort if physio broke up the transfer\n\t */\n\n\tif (bp->b_bcount != wi->wi_atareq.datalen) {\n\t\tprintf(\"physio split wd ioctl request... cannot proceed\\n\");\n\t\terror = EIO;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Abort if we didn't get a buffer size that was a multiple of\n\t * our sector size (or was larger than NBBY)\n\t */\n\n\tif ((bp->b_bcount % wi->wi_softc->sc_dk.dk_label->d_secsize) != 0 ||\n\t    (bp->b_bcount / wi->wi_softc->sc_dk.dk_label->d_secsize) >=\n\t     (1 << NBBY)) {\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Make sure a timeout was supplied in the ioctl request\n\t */\n\n\tif (wi->wi_atareq.timeout == 0) {\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\tif (wi->wi_atareq.flags & ATACMD_READ)\n\t\twdc_c.flags |= AT_READ;\n\telse if (wi->wi_atareq.flags & ATACMD_WRITE)\n\t\twdc_c.flags |= AT_WRITE;\n\n\tif (wi->wi_atareq.flags & ATACMD_READREG)\n\t\twdc_c.flags |= AT_READREG;\n\n\twdc_c.flags |= AT_WAIT;\n\n\twdc_c.timeout = wi->wi_atareq.timeout;\n\twdc_c.r_command = wi->wi_atareq.command;\n\twdc_c.r_head = wi->wi_atareq.head & 0x0f;\n\twdc_c.r_cyl = wi->wi_atareq.cylinder;\n\twdc_c.r_sector = wi->wi_atareq.sec_num;\n\twdc_c.r_count = wi->wi_atareq.sec_count;\n\twdc_c.r_precomp = wi->wi_atareq.features;\n\twdc_c.r_st_bmask = WDCS_DRDY;\n\twdc_c.r_st_pmask = WDCS_DRDY;\n\twdc_c.data = wi->wi_bp.b_data;\n\twdc_c.bcount = wi->wi_bp.b_bcount;\n\n\tif (wdc_exec_command(wi->wi_softc->drvp, &wdc_c) != WDC_COMPLETE) {\n\t\twi->wi_atareq.retsts = ATACMD_ERROR;\n\t\tgoto bad;\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\tif (wdc_c.flags & AT_ERROR) {\n\t\t\twi->wi_atareq.retsts = ATACMD_ERROR;\n\t\t\twi->wi_atareq.error = wdc_c.r_error;\n\t\t} else if (wdc_c.flags & AT_DF)\n\t\t\twi->wi_atareq.retsts = ATACMD_DF;\n\t\telse\n\t\t\twi->wi_atareq.retsts = ATACMD_TIMEOUT;\n\t} else {\n\t\twi->wi_atareq.retsts = ATACMD_OK;\n\t\tif (wi->wi_atareq.flags & ATACMD_READREG) {\n\t\t\twi->wi_atareq.head = wdc_c.r_head ;\n\t\t\twi->wi_atareq.cylinder = wdc_c.r_cyl;\n\t\t\twi->wi_atareq.sec_num = wdc_c.r_sector;\n\t\t\twi->wi_atareq.sec_count = wdc_c.r_count; \n\t\t\twi->wi_atareq.features = wdc_c.r_precomp; \n\t\t\twi->wi_atareq.error = wdc_c.r_error; \n\t\t}\n\t}\n\n\tbp->b_error = 0;\n\tbiodone(bp);\n\treturn;\nbad:\n\tbp->b_flags |= B_ERROR;\n\tbp->b_error = error;\n\tbiodone(bp);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct\twd_ioctl *wi_find",
      "void\twdioctlstrategy",
      "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_exec_command",
          "args": [
            "wi->wi_softc->drvp",
            "&wdc_c"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_exec_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1306-1369",
          "snippet": "int\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  __wdccommand_done",
            "void  __wdccommand_start",
            "int   __wdccommand_intr",
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid  __wdccommand_done;\nvoid  __wdccommand_start;\nint   __wdccommand_intr;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nint\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"physio split wd ioctl request... cannot proceed\\n\""
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&wdc_c",
            "sizeof(wdc_c)"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_find",
          "args": [
            "bp"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nstruct\twd_ioctl *wi_find;\nvoid\twdioctlstrategy;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\nwdioctlstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct wd_ioctl *wi;\n\tstruct wdc_command wdc_c;\n\tint error = 0;\n\n\twi = wi_find(bp);\n\tif (wi == NULL) {\n\t\tprintf(\"user_strat: No ioctl\\n\");\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\tbzero(&wdc_c, sizeof(wdc_c));\n\n\t/*\n\t * Abort if physio broke up the transfer\n\t */\n\n\tif (bp->b_bcount != wi->wi_atareq.datalen) {\n\t\tprintf(\"physio split wd ioctl request... cannot proceed\\n\");\n\t\terror = EIO;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Abort if we didn't get a buffer size that was a multiple of\n\t * our sector size (or was larger than NBBY)\n\t */\n\n\tif ((bp->b_bcount % wi->wi_softc->sc_dk.dk_label->d_secsize) != 0 ||\n\t    (bp->b_bcount / wi->wi_softc->sc_dk.dk_label->d_secsize) >=\n\t     (1 << NBBY)) {\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Make sure a timeout was supplied in the ioctl request\n\t */\n\n\tif (wi->wi_atareq.timeout == 0) {\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\tif (wi->wi_atareq.flags & ATACMD_READ)\n\t\twdc_c.flags |= AT_READ;\n\telse if (wi->wi_atareq.flags & ATACMD_WRITE)\n\t\twdc_c.flags |= AT_WRITE;\n\n\tif (wi->wi_atareq.flags & ATACMD_READREG)\n\t\twdc_c.flags |= AT_READREG;\n\n\twdc_c.flags |= AT_WAIT;\n\n\twdc_c.timeout = wi->wi_atareq.timeout;\n\twdc_c.r_command = wi->wi_atareq.command;\n\twdc_c.r_head = wi->wi_atareq.head & 0x0f;\n\twdc_c.r_cyl = wi->wi_atareq.cylinder;\n\twdc_c.r_sector = wi->wi_atareq.sec_num;\n\twdc_c.r_count = wi->wi_atareq.sec_count;\n\twdc_c.r_precomp = wi->wi_atareq.features;\n\twdc_c.r_st_bmask = WDCS_DRDY;\n\twdc_c.r_st_pmask = WDCS_DRDY;\n\twdc_c.data = wi->wi_bp.b_data;\n\twdc_c.bcount = wi->wi_bp.b_bcount;\n\n\tif (wdc_exec_command(wi->wi_softc->drvp, &wdc_c) != WDC_COMPLETE) {\n\t\twi->wi_atareq.retsts = ATACMD_ERROR;\n\t\tgoto bad;\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\tif (wdc_c.flags & AT_ERROR) {\n\t\t\twi->wi_atareq.retsts = ATACMD_ERROR;\n\t\t\twi->wi_atareq.error = wdc_c.r_error;\n\t\t} else if (wdc_c.flags & AT_DF)\n\t\t\twi->wi_atareq.retsts = ATACMD_DF;\n\t\telse\n\t\t\twi->wi_atareq.retsts = ATACMD_TIMEOUT;\n\t} else {\n\t\twi->wi_atareq.retsts = ATACMD_OK;\n\t\tif (wi->wi_atareq.flags & ATACMD_READREG) {\n\t\t\twi->wi_atareq.head = wdc_c.r_head ;\n\t\t\twi->wi_atareq.cylinder = wdc_c.r_cyl;\n\t\t\twi->wi_atareq.sec_num = wdc_c.r_sector;\n\t\t\twi->wi_atareq.sec_count = wdc_c.r_count; \n\t\t\twi->wi_atareq.features = wdc_c.r_precomp; \n\t\t\twi->wi_atareq.error = wdc_c.r_error; \n\t\t}\n\t}\n\n\tbp->b_error = 0;\n\tbiodone(bp);\n\treturn;\nbad:\n\tbp->b_flags |= B_ERROR;\n\tbp->b_error = error;\n\tbiodone(bp);\n}"
  },
  {
    "function_name": "wi_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1432-1442",
    "snippet": "void\nwi_free(wi)\n\tstruct wd_ioctl *wi;\n{\n\tint s;\n\n\ts = splbio();\n\tLIST_REMOVE(wi, wi_list);\n\tsplx(s);\n\tfree(wi, M_TEMP);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\twi_free"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "wi",
            "M_TEMP"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "wi_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "1432-1442",
          "snippet": "void\nwi_free(wi)\n\tstruct wd_ioctl *wi;\n{\n\tint s;\n\n\ts = splbio();\n\tLIST_REMOVE(wi, wi_list);\n\tsplx(s);\n\tfree(wi, M_TEMP);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "wi",
            "wi_list"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nvoid\twi_free;\n\nvoid\nwi_free(wi)\n\tstruct wd_ioctl *wi;\n{\n\tint s;\n\n\ts = splbio();\n\tLIST_REMOVE(wi, wi_list);\n\tsplx(s);\n\tfree(wi, M_TEMP);\n}"
  },
  {
    "function_name": "wi_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1414-1426",
    "snippet": "struct wd_ioctl *\nwi_get()\n{\n\tstruct wd_ioctl *wi;\n\tint s;\n\n\twi = malloc(sizeof(struct wd_ioctl), M_TEMP, M_WAITOK);\n\tbzero(wi, sizeof (struct wd_ioctl));\n\ts = splbio();\n\tLIST_INSERT_HEAD(&wi_head, wi, wi_list);\n\tsplx(s);\n\treturn (wi);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "LIST_HEAD(, wd_ioctl) wi_head;",
      "struct\twd_ioctl *wi_get"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&wi_head",
            "wi",
            "wi_list"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "wi",
            "sizeof (struct wd_ioctl)"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct wd_ioctl)",
            "M_TEMP",
            "M_WAITOK"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nLIST_HEAD(, wd_ioctl) wi_head;\nstruct\twd_ioctl *wi_get;\n\nstruct wd_ioctl *\nwi_get()\n{\n\tstruct wd_ioctl *wi;\n\tint s;\n\n\twi = malloc(sizeof(struct wd_ioctl), M_TEMP, M_WAITOK);\n\tbzero(wi, sizeof (struct wd_ioctl));\n\ts = splbio();\n\tLIST_INSERT_HEAD(&wi_head, wi, wi_list);\n\tsplx(s);\n\treturn (wi);\n}"
  },
  {
    "function_name": "wd_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1402-1408",
    "snippet": "void\nwd_shutdown(arg)\n\tvoid *arg;\n{\n\tstruct wd_softc *wd = arg;\n\twd_flushcache(wd, ATA_POLL);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void  wd_flushcache",
      "void  wd_shutdown"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wd_flushcache",
          "args": [
            "wd",
            "ATA_POLL"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "wd_flushcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "1368-1400",
          "snippet": "void\nwd_flushcache(wd, flags)\n\tstruct wd_softc *wd;\n\tint flags;\n{\n\tstruct wdc_command wdc_c;\n\n\tif (wd->drvp->ata_vers < 4) /* WDCC_FLUSHCACHE is here since ATA-4 */\n\t\treturn;\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\twdc_c.r_command = WDCC_FLUSHCACHE;\n\twdc_c.r_st_bmask = WDCS_DRDY;\n\twdc_c.r_st_pmask = WDCS_DRDY;\n\twdc_c.flags = flags | AT_WAIT;\n\twdc_c.timeout = 30000; /* 30s timeout */\n\tif (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {\n\t\tprintf(\"%s: flush cache command didn't complete\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_TIMEOU) {\n\t\tprintf(\"%s: flush cache command timeout\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_DF) {\n\t\tprintf(\"%s: flush cache command: drive fault\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\t/*\n\t * Ignore error register, it shouldn't report anything else\n\t * than COMMAND ABORTED, which means the device doesn't support\n\t * flush cache\n\t */\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void  wd_flushcache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nvoid  wd_flushcache;\n\nvoid\nwd_flushcache(wd, flags)\n\tstruct wd_softc *wd;\n\tint flags;\n{\n\tstruct wdc_command wdc_c;\n\n\tif (wd->drvp->ata_vers < 4) /* WDCC_FLUSHCACHE is here since ATA-4 */\n\t\treturn;\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\twdc_c.r_command = WDCC_FLUSHCACHE;\n\twdc_c.r_st_bmask = WDCS_DRDY;\n\twdc_c.r_st_pmask = WDCS_DRDY;\n\twdc_c.flags = flags | AT_WAIT;\n\twdc_c.timeout = 30000; /* 30s timeout */\n\tif (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {\n\t\tprintf(\"%s: flush cache command didn't complete\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_TIMEOU) {\n\t\tprintf(\"%s: flush cache command timeout\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_DF) {\n\t\tprintf(\"%s: flush cache command: drive fault\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\t/*\n\t * Ignore error register, it shouldn't report anything else\n\t * than COMMAND ABORTED, which means the device doesn't support\n\t * flush cache\n\t */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nvoid  wd_flushcache;\nvoid  wd_shutdown;\n\nvoid\nwd_shutdown(arg)\n\tvoid *arg;\n{\n\tstruct wd_softc *wd = arg;\n\twd_flushcache(wd, ATA_POLL);\n}"
  },
  {
    "function_name": "wd_flushcache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1368-1400",
    "snippet": "void\nwd_flushcache(wd, flags)\n\tstruct wd_softc *wd;\n\tint flags;\n{\n\tstruct wdc_command wdc_c;\n\n\tif (wd->drvp->ata_vers < 4) /* WDCC_FLUSHCACHE is here since ATA-4 */\n\t\treturn;\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\twdc_c.r_command = WDCC_FLUSHCACHE;\n\twdc_c.r_st_bmask = WDCS_DRDY;\n\twdc_c.r_st_pmask = WDCS_DRDY;\n\twdc_c.flags = flags | AT_WAIT;\n\twdc_c.timeout = 30000; /* 30s timeout */\n\tif (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {\n\t\tprintf(\"%s: flush cache command didn't complete\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_TIMEOU) {\n\t\tprintf(\"%s: flush cache command timeout\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_DF) {\n\t\tprintf(\"%s: flush cache command: drive fault\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\t/*\n\t * Ignore error register, it shouldn't report anything else\n\t * than COMMAND ABORTED, which means the device doesn't support\n\t * flush cache\n\t */\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void  wd_flushcache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: flush cache command: drive fault\\n\"",
            "wd->sc_dev.dv_xname"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_exec_command",
          "args": [
            "wd->drvp",
            "&wdc_c"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_exec_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1306-1369",
          "snippet": "int\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  __wdccommand_done",
            "void  __wdccommand_start",
            "int   __wdccommand_intr",
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid  __wdccommand_done;\nvoid  __wdccommand_start;\nint   __wdccommand_intr;\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nint\nwdc_exec_command(drvp, wdc_c)\n\tstruct ata_drive_datas *drvp;\n\tstruct wdc_command *wdc_c;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_xfer *xfer;\n\tint s, ret;\n\n\tWDCDEBUG_PRINT((\"wdc_exec_command %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\n\t/* set up an xfer and queue. Wait for completion */\n\txfer = wdc_get_xfer(wdc_c->flags & AT_WAIT ? WDC_CANSLEEP :\n\t    WDC_NOSLEEP);\n\tif (xfer == NULL) {\n\t\treturn WDC_TRY_AGAIN;\n\t }\n\n\tif (wdc_c->flags & AT_POLL)\n\t\txfer->c_flags |= C_POLL;\n\txfer->drive = drvp->drive;\n\txfer->databuf = wdc_c->data;\n\txfer->c_bcount = wdc_c->bcount;\n\txfer->cmd = wdc_c;\n\txfer->c_start = __wdccommand_start;\n\txfer->c_intr = __wdccommand_intr;\n\txfer->c_kill_xfer = __wdccommand_done;\n\n\ts = splbio();\n\twdc_exec_xfer(chp, xfer);\n#ifdef DIAGNOSTIC\n\tif ((wdc_c->flags & AT_POLL) != 0 &&\n\t    (wdc_c->flags & AT_DONE) == 0)\n\t\tpanic(\"wdc_exec_command: polled command not done\\n\");\n#endif\n\tif (wdc_c->flags & AT_DONE) {\n\t\tret = WDC_COMPLETE;\n\t} else {\n\t\tif (wdc_c->flags & AT_WAIT) {\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command sleeping\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\twhile (!(wdc_c->flags & AT_DONE)) {\n\t\t\t\tint error;\n\t\t\t\terror = tsleep(wdc_c, PRIBIO, \"wdccmd\", 0);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tprintf (\"tsleep error: %d\\n\", error);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWDCDEBUG_PRINT((\"wdc_exec_command waking\"),\n\t\t\t\t       DEBUG_FUNCS);\n\n\t\t\tret = WDC_COMPLETE;\n\t\t} else {\n\t\t\tret = WDC_QUEUED;\n\t\t}\n\t}\n\tsplx(s);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&wdc_c",
            "sizeof(struct wdc_command)"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nvoid  wd_flushcache;\n\nvoid\nwd_flushcache(wd, flags)\n\tstruct wd_softc *wd;\n\tint flags;\n{\n\tstruct wdc_command wdc_c;\n\n\tif (wd->drvp->ata_vers < 4) /* WDCC_FLUSHCACHE is here since ATA-4 */\n\t\treturn;\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\twdc_c.r_command = WDCC_FLUSHCACHE;\n\twdc_c.r_st_bmask = WDCS_DRDY;\n\twdc_c.r_st_pmask = WDCS_DRDY;\n\twdc_c.flags = flags | AT_WAIT;\n\twdc_c.timeout = 30000; /* 30s timeout */\n\tif (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {\n\t\tprintf(\"%s: flush cache command didn't complete\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_TIMEOU) {\n\t\tprintf(\"%s: flush cache command timeout\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_DF) {\n\t\tprintf(\"%s: flush cache command: drive fault\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\t/*\n\t * Ignore error register, it shouldn't report anything else\n\t * than COMMAND ABORTED, which means the device doesn't support\n\t * flush cache\n\t */\n}"
  },
  {
    "function_name": "wd_get_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1335-1366",
    "snippet": "int\nwd_get_params(wd, flags, params)\n\tstruct wd_softc *wd;\n\tu_int8_t flags;\n\tstruct ataparams *params;\n{\n\tswitch (ata_get_params(wd->drvp, flags, params)) {\n\tcase CMD_AGAIN:\n\t\treturn 1;\n\tcase CMD_ERR:\n\t\t/*\n\t\t * We `know' there's a drive here; just assume it's old.\n\t\t * This geometry is only used to read the MBR and print a\n\t\t * (false) attach message.\n\t\t */\n\t\tstrncpy(params->atap_model, \"ST506\",\n\t\t    sizeof params->atap_model);\n\t\tparams->atap_config = ATA_CFG_FIXED;\n\t\tparams->atap_cylinders = 1024;\n\t\tparams->atap_heads = 8;\n\t\tparams->atap_sectors = 17;\n\t\tparams->atap_multi = 1;\n\t\tparams->atap_capabilities1 = params->atap_capabilities2 = 0;\n\t\twd->drvp->ata_vers = -1; /* Mark it as pre-ATA */\n\t\treturn 0;\n\tcase CMD_OK:\n\t\treturn 0;\n\tdefault:\n\t\tpanic(\"wd_get_params: bad return code from ata_get_params\");\n\t\t/* NOTREACHED */\n\t}\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int   wd_get_params"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wd_get_params: bad return code from ata_get_params\""
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "params->atap_model",
            "\"ST506\"",
            "sizeof params->atap_model"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata_get_params",
          "args": [
            "wd->drvp",
            "flags",
            "params"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "ata_get_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
          "lines": "59-149",
          "snippet": "int\nata_get_params(drvp, flags, prms)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t flags;\n\tstruct ataparams *prms;\n{\n\tchar tb[ATAPARAMS_SIZE];\n\tstruct wdc_command wdc_c;\n\n\tint i;\n\tu_int16_t *p;\n\n\tWDCDEBUG_PRINT((\"ata_get_parms\\n\"), DEBUG_FUNCS);\n\n\tbzero(tb, sizeof(tb));\n\tbzero(prms, sizeof(struct ataparams));\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\tif (drvp->drive_flags & DRIVE_ATA) {\n\t\twdc_c.r_command = WDCC_IDENTIFY;\n\t\twdc_c.r_st_bmask = WDCS_DRDY;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 1000; /* 1s */\n\t} else if (drvp->drive_flags & DRIVE_ATAPI) {\n\t\twdc_c.r_command = ATAPI_IDENTIFY_DEVICE;\n\t\twdc_c.r_st_bmask = 0;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 10000; /* 10s */\n\t} else {\n\t\treturn CMD_ERR;\n\t}\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.data = tb;\n\twdc_c.bcount = ATAPARAMS_SIZE;\n\n\t{\n\t\tint ret;\n\t\tif ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {\n\t\t\tprintf (\"WDC_EXEC_COMMAND: %d\\n\");\n\t\t\treturn CMD_AGAIN;\n\t\t}\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t} else {\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t/* All the fields in the params structure are 16-bit\n\t\t   integers except for the ID strings which are char\n\t\t   strings.  The 16-bit integers are currently in\n\t\t   memory in little-endian, regardless of architecture.\n\t\t   So, they need to be swapped on big-endian architectures\n\t\t   before they are accessed through the ataparams structure.\n\n\t\t   The swaps below avoid touching the char strings.\n\t\t*/\n\t\t  \n\t\tswap16_multi((u_int16_t *)tb, 10);\n\t\tswap16_multi((u_int16_t *)tb + 20, 3);\n\t\tswap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);\n#endif\n\t\t/* Read in parameter block. */\n\t\tbcopy(tb, prms, sizeof(struct ataparams));\n\n\t\t/*\n\t\t * Shuffle string byte order.\n\t\t * ATAPI Mitsumi and NEC drives don't need this.\n\t\t */\n\t\tif ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==\n\t\t    WDC_CFG_ATAPI &&\n\t\t    ((prms->atap_model[0] == 'N' &&\n\t\t\tprms->atap_model[1] == 'E') ||\n\t\t     (prms->atap_model[0] == 'F' &&\n\t\t\t prms->atap_model[1] == 'X')))\n\t\t\treturn 0;\n\t\tfor (i = 0; i < sizeof(prms->atap_model); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_model + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_serial); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_serial + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_revision); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_revision + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\n\t\treturn CMD_OK;\n\t}\n}",
          "includes": [
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ATAPARAMS_SIZE 512",
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ATAPARAMS_SIZE 512\n#define DEBUG_FUNCS  0x08\n\nint\nata_get_params(drvp, flags, prms)\n\tstruct ata_drive_datas *drvp;\n\tu_int8_t flags;\n\tstruct ataparams *prms;\n{\n\tchar tb[ATAPARAMS_SIZE];\n\tstruct wdc_command wdc_c;\n\n\tint i;\n\tu_int16_t *p;\n\n\tWDCDEBUG_PRINT((\"ata_get_parms\\n\"), DEBUG_FUNCS);\n\n\tbzero(tb, sizeof(tb));\n\tbzero(prms, sizeof(struct ataparams));\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\n\tif (drvp->drive_flags & DRIVE_ATA) {\n\t\twdc_c.r_command = WDCC_IDENTIFY;\n\t\twdc_c.r_st_bmask = WDCS_DRDY;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 1000; /* 1s */\n\t} else if (drvp->drive_flags & DRIVE_ATAPI) {\n\t\twdc_c.r_command = ATAPI_IDENTIFY_DEVICE;\n\t\twdc_c.r_st_bmask = 0;\n\t\twdc_c.r_st_pmask = WDCS_DRQ;\n\t\twdc_c.timeout = 10000; /* 10s */\n\t} else {\n\t\treturn CMD_ERR;\n\t}\n\twdc_c.flags = AT_READ | flags;\n\twdc_c.data = tb;\n\twdc_c.bcount = ATAPARAMS_SIZE;\n\n\t{\n\t\tint ret;\n\t\tif ((ret = wdc_exec_command(drvp, &wdc_c)) != WDC_COMPLETE) {\n\t\t\tprintf (\"WDC_EXEC_COMMAND: %d\\n\");\n\t\t\treturn CMD_AGAIN;\n\t\t}\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\treturn CMD_ERR;\n\t} else {\n#if BYTE_ORDER == BIG_ENDIAN\n\t\t/* All the fields in the params structure are 16-bit\n\t\t   integers except for the ID strings which are char\n\t\t   strings.  The 16-bit integers are currently in\n\t\t   memory in little-endian, regardless of architecture.\n\t\t   So, they need to be swapped on big-endian architectures\n\t\t   before they are accessed through the ataparams structure.\n\n\t\t   The swaps below avoid touching the char strings.\n\t\t*/\n\t\t  \n\t\tswap16_multi((u_int16_t *)tb, 10);\n\t\tswap16_multi((u_int16_t *)tb + 20, 3);\n\t\tswap16_multi((u_int16_t *)tb + 47, ATAPARAMS_SIZE / 2 - 47);\n#endif\n\t\t/* Read in parameter block. */\n\t\tbcopy(tb, prms, sizeof(struct ataparams));\n\n\t\t/*\n\t\t * Shuffle string byte order.\n\t\t * ATAPI Mitsumi and NEC drives don't need this.\n\t\t */\n\t\tif ((prms->atap_config & WDC_CFG_ATAPI_MASK) ==\n\t\t    WDC_CFG_ATAPI &&\n\t\t    ((prms->atap_model[0] == 'N' &&\n\t\t\tprms->atap_model[1] == 'E') ||\n\t\t     (prms->atap_model[0] == 'F' &&\n\t\t\t prms->atap_model[1] == 'X')))\n\t\t\treturn 0;\n\t\tfor (i = 0; i < sizeof(prms->atap_model); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_model + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_serial); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_serial + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\t\tfor (i = 0; i < sizeof(prms->atap_revision); i += 2) {\n\t\t\tp = (u_short *)(prms->atap_revision + i);\n\t\t\t*p = swap16(*p);\n\t\t}\n\n\t\treturn CMD_OK;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nint   wd_get_params;\n\nint\nwd_get_params(wd, flags, params)\n\tstruct wd_softc *wd;\n\tu_int8_t flags;\n\tstruct ataparams *params;\n{\n\tswitch (ata_get_params(wd->drvp, flags, params)) {\n\tcase CMD_AGAIN:\n\t\treturn 1;\n\tcase CMD_ERR:\n\t\t/*\n\t\t * We `know' there's a drive here; just assume it's old.\n\t\t * This geometry is only used to read the MBR and print a\n\t\t * (false) attach message.\n\t\t */\n\t\tstrncpy(params->atap_model, \"ST506\",\n\t\t    sizeof params->atap_model);\n\t\tparams->atap_config = ATA_CFG_FIXED;\n\t\tparams->atap_cylinders = 1024;\n\t\tparams->atap_heads = 8;\n\t\tparams->atap_sectors = 17;\n\t\tparams->atap_multi = 1;\n\t\tparams->atap_capabilities1 = params->atap_capabilities2 = 0;\n\t\twd->drvp->ata_vers = -1; /* Mark it as pre-ATA */\n\t\treturn 0;\n\tcase CMD_OK:\n\t\treturn 0;\n\tdefault:\n\t\tpanic(\"wd_get_params: bad return code from ata_get_params\");\n\t\t/* NOTREACHED */\n\t}\n}"
  },
  {
    "function_name": "bad144intern",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1312-1332",
    "snippet": "void\nbad144intern(wd)\n\tstruct wd_softc *wd;\n{\n\tstruct dkbad *bt = &DKBAD(wd->sc_dk.dk_cpulabel);\n\tstruct disklabel *lp = wd->sc_dk.dk_label;\n\tint i = 0;\n\n\tWDCDEBUG_PRINT((\"bad144intern\\n\"), DEBUG_XFERS);\n\n\tfor (; i < NBT_BAD; i++) {\n\t\tif (bt->bt_bad[i].bt_cyl == 0xffff)\n\t\t\tbreak;\n\t\twd->sc_badsect[i] =\n\t\t    bt->bt_bad[i].bt_cyl * lp->d_secpercyl +\n\t\t    (bt->bt_bad[i].bt_trksec >> 8) * lp->d_nsectors +\n\t\t    (bt->bt_bad[i].bt_trksec & 0xff);\n\t}\n\tfor (; i < NBT_BAD+1; i++)\n\t\twd->sc_badsect[i] = -1;\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define sc_badsect sc_wdc_bio.badsect",
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"bad144intern\\n\")",
            "DEBUG_XFERS"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DKBAD",
          "args": [
            "wd->sc_dk.dk_cpulabel"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_badsect sc_wdc_bio.badsect\n#define DEBUG_XFERS  0x02\n\nvoid\nbad144intern(wd)\n\tstruct wd_softc *wd;\n{\n\tstruct dkbad *bt = &DKBAD(wd->sc_dk.dk_cpulabel);\n\tstruct disklabel *lp = wd->sc_dk.dk_label;\n\tint i = 0;\n\n\tWDCDEBUG_PRINT((\"bad144intern\\n\"), DEBUG_XFERS);\n\n\tfor (; i < NBT_BAD; i++) {\n\t\tif (bt->bt_bad[i].bt_cyl == 0xffff)\n\t\t\tbreak;\n\t\twd->sc_badsect[i] =\n\t\t    bt->bt_bad[i].bt_cyl * lp->d_secpercyl +\n\t\t    (bt->bt_bad[i].bt_trksec >> 8) * lp->d_nsectors +\n\t\t    (bt->bt_bad[i].bt_trksec & 0xff);\n\t}\n\tfor (; i < NBT_BAD+1; i++)\n\t\twd->sc_badsect[i] = -1;\n}"
  },
  {
    "function_name": "wddump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1295-1305",
    "snippet": "int\nwddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nint\nwddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}"
  },
  {
    "function_name": "wddump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1168-1291",
    "snippet": "int\nwddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\tstruct wd_softc *wd;\t/* disk unit to do the I/O */\n\tstruct disklabel *lp;   /* disk's disklabel */\n\tint unit, part;\n\tint nblks;\t/* total number of sectors left to write */\n\tint err;\n\tchar errbuf[256];\n\n\t/* Check if recursive dump; if so, punt. */\n\tif (wddoingadump)\n\t\treturn EFAULT;\n\twddoingadump = 1;\n\n\tunit = WDUNIT(dev);\n\twd = wdlookup(unit);\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\n\tpart = WDPART(dev);\n\n\t/* Make sure it was initialized. */\n\tif (wd->drvp->state < READY)\n\t\treturn ENXIO;\n\n\t/* Convert to disk sectors.  Request must be a multiple of size. */\n\tlp = wd->sc_dk.dk_label;\n\tif ((size % lp->d_secsize) != 0)\n\t\treturn EFAULT;\n\tnblks = size / lp->d_secsize;\n\tblkno = blkno / (lp->d_secsize / DEV_BSIZE);\n\n\t/* Check transfer bounds against partition size. */\n\tif ((blkno < 0) || ((blkno + nblks) > lp->d_partitions[part].p_size))\n\t\treturn EINVAL;  \n\n\t/* Offset block number to start of partition. */\n\tblkno += lp->d_partitions[part].p_offset;\n\n\t/* Recalibrate, if first dump transfer. */\n\tif (wddumprecalibrated == 0) {\n\t\twddumpmulti = wd->sc_multi;\n\t\twddumprecalibrated = 1;\n\t\twd->drvp->state = RECAL;\n\t}\n  \n\twhile (nblks > 0) {\nagain:\n\t\twd->sc_wdc_bio.blkno = blkno;\n\t\twd->sc_wdc_bio.flags = ATA_POLL;\n\t\tif (wddumpmulti == 1)\n\t\t\twd->sc_wdc_bio.flags |= ATA_SINGLE;\n\t\tif (wd->sc_flags & WDF_LBA)\n\t\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\t\twd->sc_wdc_bio.bcount =\n\t\t\tmin(nblks, wddumpmulti) * lp->d_secsize;\n\t\twd->sc_wdc_bio.databuf = va;\n\t\twd->sc_wdc_bio.wd = wd;\n#ifndef WD_DUMP_NOT_TRUSTED\n\t\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\t\tcase WDC_TRY_AGAIN:\n\t\t\tpanic(\"wddump: try again\");\n\t\t\tbreak;\n\t\tcase WDC_QUEUED:\n\t\t\tpanic(\"wddump: polled command has been queued\");\n\t\t\tbreak;\n\t\tcase WDC_COMPLETE:\n\t\t\tbreak;\n\t\t}\n\t\tswitch(wd->sc_wdc_bio.error) {\n\t\tcase TIMEOUT:\n\t\t\tprintf(\"wddump: device timed out\");\n\t\t\terr = EIO;\n\t\t\tbreak;\n\t\tcase ERR_DF:\n\t\t\tprintf(\"wddump: drive fault\");\n\t\t\terr = EIO;\n\t\t\tbreak;\n\t\tcase ERR_DMA:\n\t\t\tprintf(\"wddump: DMA error\");\n\t\t\terr = EIO;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\terrbuf[0] = '\\0';\n\t\t\tata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);\n\t\t\tprintf(\"wddump: %s\", errbuf);\n\t\t\terr = EIO;\n\t\t\tbreak;\n\t\tcase NOERROR: \n\t\t\terr = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"wddump: unknown error type\");\n\t\t}\n\t\tif (err != 0) {\n\t\t\tif (wddumpmulti != 1) {\n\t\t\t\twddumpmulti = 1; /* retry in single-sector */\n\t\t\t\tprintf(\", retrying\\n\");\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\treturn err;\n\t\t}\n#else\t/* WD_DUMP_NOT_TRUSTED */\n\t\t/* Let's just talk about this first... */\n\t\tprintf(\"wd%d: dump addr 0x%x, cylin %d, head %d, sector %d\\n\",\n\t\t    unit, va, cylin, head, sector);\n\t\tdelay(500 * 1000);\t/* half a second */\n#endif\n\n\t\t/* update block count */\n\t\tnblks -= min(nblks, wddumpmulti);\n\t\tblkno += min(nblks, wddumpmulti);\n\t\tva += min(nblks, wddumpmulti) * lp->d_secsize;\n\t}\n\n\twddoingadump = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define sc_multi sc_wdc_bio.multi",
      "#define WDF_LBA\t 0x40 /* using LBA mode */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nblks",
            "wddumpmulti"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "seq_do_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "804-819",
          "snippet": "int\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nint\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "500 * 1000"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wd%d: dump addr 0x%x, cylin %d, head %d, sector %d\\n\"",
            "unit",
            "va",
            "cylin",
            "head",
            "sector"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wddump: unknown error type\""
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata_perror",
          "args": [
            "wd->drvp",
            "wd->sc_wdc_bio.r_error",
            "errbuf"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "ata_perror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
          "lines": "177-210",
          "snippet": "void\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wddump: polled command has been queued\""
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wddump: try again\""
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_ata_bio",
          "args": [
            "wd->drvp",
            "&wd->sc_wdc_bio"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_bio_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "533-568",
          "snippet": "void\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [
            "void  wdc_ata_bio_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid  wdc_ata_bio_done;\n\nvoid\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDPART",
          "args": [
            "dev"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdlookup",
          "args": [
            "unit"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDUNIT",
          "args": [
            "dev"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_multi sc_wdc_bio.multi\n#define WDF_LBA\t 0x40 /* using LBA mode */\n\nint\nwddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\tstruct wd_softc *wd;\t/* disk unit to do the I/O */\n\tstruct disklabel *lp;   /* disk's disklabel */\n\tint unit, part;\n\tint nblks;\t/* total number of sectors left to write */\n\tint err;\n\tchar errbuf[256];\n\n\t/* Check if recursive dump; if so, punt. */\n\tif (wddoingadump)\n\t\treturn EFAULT;\n\twddoingadump = 1;\n\n\tunit = WDUNIT(dev);\n\twd = wdlookup(unit);\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\n\tpart = WDPART(dev);\n\n\t/* Make sure it was initialized. */\n\tif (wd->drvp->state < READY)\n\t\treturn ENXIO;\n\n\t/* Convert to disk sectors.  Request must be a multiple of size. */\n\tlp = wd->sc_dk.dk_label;\n\tif ((size % lp->d_secsize) != 0)\n\t\treturn EFAULT;\n\tnblks = size / lp->d_secsize;\n\tblkno = blkno / (lp->d_secsize / DEV_BSIZE);\n\n\t/* Check transfer bounds against partition size. */\n\tif ((blkno < 0) || ((blkno + nblks) > lp->d_partitions[part].p_size))\n\t\treturn EINVAL;  \n\n\t/* Offset block number to start of partition. */\n\tblkno += lp->d_partitions[part].p_offset;\n\n\t/* Recalibrate, if first dump transfer. */\n\tif (wddumprecalibrated == 0) {\n\t\twddumpmulti = wd->sc_multi;\n\t\twddumprecalibrated = 1;\n\t\twd->drvp->state = RECAL;\n\t}\n  \n\twhile (nblks > 0) {\nagain:\n\t\twd->sc_wdc_bio.blkno = blkno;\n\t\twd->sc_wdc_bio.flags = ATA_POLL;\n\t\tif (wddumpmulti == 1)\n\t\t\twd->sc_wdc_bio.flags |= ATA_SINGLE;\n\t\tif (wd->sc_flags & WDF_LBA)\n\t\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\t\twd->sc_wdc_bio.bcount =\n\t\t\tmin(nblks, wddumpmulti) * lp->d_secsize;\n\t\twd->sc_wdc_bio.databuf = va;\n\t\twd->sc_wdc_bio.wd = wd;\n#ifndef WD_DUMP_NOT_TRUSTED\n\t\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\t\tcase WDC_TRY_AGAIN:\n\t\t\tpanic(\"wddump: try again\");\n\t\t\tbreak;\n\t\tcase WDC_QUEUED:\n\t\t\tpanic(\"wddump: polled command has been queued\");\n\t\t\tbreak;\n\t\tcase WDC_COMPLETE:\n\t\t\tbreak;\n\t\t}\n\t\tswitch(wd->sc_wdc_bio.error) {\n\t\tcase TIMEOUT:\n\t\t\tprintf(\"wddump: device timed out\");\n\t\t\terr = EIO;\n\t\t\tbreak;\n\t\tcase ERR_DF:\n\t\t\tprintf(\"wddump: drive fault\");\n\t\t\terr = EIO;\n\t\t\tbreak;\n\t\tcase ERR_DMA:\n\t\t\tprintf(\"wddump: DMA error\");\n\t\t\terr = EIO;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\terrbuf[0] = '\\0';\n\t\t\tata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);\n\t\t\tprintf(\"wddump: %s\", errbuf);\n\t\t\terr = EIO;\n\t\t\tbreak;\n\t\tcase NOERROR: \n\t\t\terr = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"wddump: unknown error type\");\n\t\t}\n\t\tif (err != 0) {\n\t\t\tif (wddumpmulti != 1) {\n\t\t\t\twddumpmulti = 1; /* retry in single-sector */\n\t\t\t\tprintf(\", retrying\\n\");\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\treturn err;\n\t\t}\n#else\t/* WD_DUMP_NOT_TRUSTED */\n\t\t/* Let's just talk about this first... */\n\t\tprintf(\"wd%d: dump addr 0x%x, cylin %d, head %d, sector %d\\n\",\n\t\t    unit, va, cylin, head, sector);\n\t\tdelay(500 * 1000);\t/* half a second */\n#endif\n\n\t\t/* update block count */\n\t\tnblks -= min(nblks, wddumpmulti);\n\t\tblkno += min(nblks, wddumpmulti);\n\t\tva += min(nblks, wddumpmulti) * lp->d_secsize;\n\t}\n\n\twddoingadump = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "wdsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1124-1157",
    "snippet": "int\nwdsize(dev)\n\tdev_t dev;\n{\n\tstruct wd_softc *wd;\n\tint part, omask;\n\tint size;\n\n\tWDCDEBUG_PRINT((\"wdsize\\n\"), DEBUG_FUNCS);\n\n\twd = wdlookup(WDUNIT(dev));\n\tif (wd == NULL)\n\t\treturn (-1);\n\n\tpart = WDPART(dev);\n\tomask = wd->sc_dk.dk_openmask & (1 << part);\n\n\tif (omask == 0 && wdopen(dev, 0, S_IFBLK, NULL) != 0) {\n\t\tsize = -1;\n\t\tgoto exit;\n\t}\n\n\tif (wd->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)\n\t\tsize = -1;\n\telse\n\t\tsize = wd->sc_dk.dk_label->d_partitions[part].p_size *\n\t\t    (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\tif (omask == 0 && wdclose(dev, 0, S_IFBLK, NULL) != 0)\n\t\tsize = -1;\n\n exit:\n\tdevice_unref(&wd->sc_dev);\n\treturn (size);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_unref",
          "args": [
            "&wd->sc_dev"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdclose",
          "args": [
            "dev",
            "0",
            "S_IFBLK",
            "NULL"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "wdclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "791-833",
          "snippet": "int\nwdclose(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tstruct wd_softc *wd;\n\tint part = WDPART(dev);\n\tint error = 0;\n\n\twd = wdlookup(WDUNIT(dev));\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\t\n\tWDCDEBUG_PRINT((\"wdclose\\n\"), DEBUG_FUNCS);\n\tif ((error = wdlock(wd)) != 0)\n\t\tgoto exit;\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\twd->sc_dk.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\twd->sc_dk.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\twd->sc_dk.dk_openmask =\n\t    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;\n\n\tif (wd->sc_dk.dk_openmask == 0) {\n\t\twd_flushcache(wd,0);\n\t\t/* XXXX Must wait for I/O to complete! */\n#ifndef __OpenBSD__\n\t\twdc_ata_delref(wd->drvp);\n#endif\n\t}\n\n\twdunlock(wd);\n\n exit:\n\tdevice_unref(&wd->sc_dev);\n\treturn (error);\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  wd_flushcache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_FUNCS  0x08\n\nvoid  wd_flushcache;\n\nint\nwdclose(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tstruct wd_softc *wd;\n\tint part = WDPART(dev);\n\tint error = 0;\n\n\twd = wdlookup(WDUNIT(dev));\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\t\n\tWDCDEBUG_PRINT((\"wdclose\\n\"), DEBUG_FUNCS);\n\tif ((error = wdlock(wd)) != 0)\n\t\tgoto exit;\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\twd->sc_dk.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\twd->sc_dk.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\twd->sc_dk.dk_openmask =\n\t    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;\n\n\tif (wd->sc_dk.dk_openmask == 0) {\n\t\twd_flushcache(wd,0);\n\t\t/* XXXX Must wait for I/O to complete! */\n#ifndef __OpenBSD__\n\t\twdc_ata_delref(wd->drvp);\n#endif\n\t}\n\n\twdunlock(wd);\n\n exit:\n\tdevice_unref(&wd->sc_dev);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdopen",
          "args": [
            "dev",
            "0",
            "S_IFBLK",
            "NULL"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "wdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "698-789",
          "snippet": "int\nwdopen(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tstruct wd_softc *wd;\n\tint unit, part;\n\tint error;\n\n\tWDCDEBUG_PRINT((\"wdopen\\n\"), DEBUG_FUNCS);\n\n\tunit = WDUNIT(dev);\n\twd = wdlookup(unit);\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\n\t/*\n\t * If this is the first open of this device, add a reference\n\t * to the adapter.\n\t */\n#ifndef __OpenBSD__\n\tif (wd->sc_dk.dk_openmask == 0 &&\n\t    (error = wdc_ata_addref(wd->drvp)) != 0)\n\t\treturn (error);\n#endif\n\n\tif ((error = wdlock(wd)) != 0)\n\t\tgoto bad4;\n\n\tif (wd->sc_dk.dk_openmask != 0) {\n\t\t/*\n\t\t * If any partition is open, but the disk has been invalidated,\n\t\t * disallow further opens.\n\t\t */\n\t\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\t\terror = EIO;\n\t\t\tgoto bad3;\n\t\t}\n\t} else {\n\t\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\t\twd->sc_flags |= WDF_LOADED;\n\n\t\t\t/* Load the physical device parameters. */\n\t\t\twd_get_params(wd, AT_WAIT, &wd->sc_params);\n\n\t\t\t/* Load the partition info if not already loaded. */\n\t\t\twdgetdisklabel(dev, wd, wd->sc_dk.dk_label,\n\t\t\t\t       wd->sc_dk.dk_cpulabel, 0);\n\t\t}\n\t}\n\n\tpart = WDPART(dev);\n\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART &&\n\t    (part >= wd->sc_dk.dk_label->d_npartitions ||\n\t     wd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {\n\t\terror = ENXIO;\n\t\tgoto bad;\n\t}\n\t\n\t/* Insure only one open at a time. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\twd->sc_dk.dk_copenmask |= (1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\twd->sc_dk.dk_bopenmask |= (1 << part);\n\t\tbreak;\n\t}\n\twd->sc_dk.dk_openmask =\n\t    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;\n\n\twdunlock(wd);\n\tdevice_unref(&wd->sc_dev);\n\treturn 0;\n\nbad:\n\tif (wd->sc_dk.dk_openmask == 0) {\n\t}\n\nbad3:\n\twdunlock(wd);\nbad4:\n#ifndef __OpenBSD__\n\tif (wd->sc_dk.dk_openmask == 0)\n\t\twdc_ata_delref(wd->drvp);\n#endif\n\tdevice_unref(&wd->sc_dev);\n\treturn error;\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define WDF_LOADED\t  0x10 /* parameters loaded */",
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  wdgetdisklabel",
            "int   wd_get_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define WDF_LOADED\t  0x10 /* parameters loaded */\n#define DEBUG_FUNCS  0x08\n\nvoid  wdgetdisklabel;\nint   wd_get_params;\n\nint\nwdopen(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tstruct wd_softc *wd;\n\tint unit, part;\n\tint error;\n\n\tWDCDEBUG_PRINT((\"wdopen\\n\"), DEBUG_FUNCS);\n\n\tunit = WDUNIT(dev);\n\twd = wdlookup(unit);\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\n\t/*\n\t * If this is the first open of this device, add a reference\n\t * to the adapter.\n\t */\n#ifndef __OpenBSD__\n\tif (wd->sc_dk.dk_openmask == 0 &&\n\t    (error = wdc_ata_addref(wd->drvp)) != 0)\n\t\treturn (error);\n#endif\n\n\tif ((error = wdlock(wd)) != 0)\n\t\tgoto bad4;\n\n\tif (wd->sc_dk.dk_openmask != 0) {\n\t\t/*\n\t\t * If any partition is open, but the disk has been invalidated,\n\t\t * disallow further opens.\n\t\t */\n\t\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\t\terror = EIO;\n\t\t\tgoto bad3;\n\t\t}\n\t} else {\n\t\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\t\twd->sc_flags |= WDF_LOADED;\n\n\t\t\t/* Load the physical device parameters. */\n\t\t\twd_get_params(wd, AT_WAIT, &wd->sc_params);\n\n\t\t\t/* Load the partition info if not already loaded. */\n\t\t\twdgetdisklabel(dev, wd, wd->sc_dk.dk_label,\n\t\t\t\t       wd->sc_dk.dk_cpulabel, 0);\n\t\t}\n\t}\n\n\tpart = WDPART(dev);\n\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART &&\n\t    (part >= wd->sc_dk.dk_label->d_npartitions ||\n\t     wd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {\n\t\terror = ENXIO;\n\t\tgoto bad;\n\t}\n\t\n\t/* Insure only one open at a time. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\twd->sc_dk.dk_copenmask |= (1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\twd->sc_dk.dk_bopenmask |= (1 << part);\n\t\tbreak;\n\t}\n\twd->sc_dk.dk_openmask =\n\t    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;\n\n\twdunlock(wd);\n\tdevice_unref(&wd->sc_dev);\n\treturn 0;\n\nbad:\n\tif (wd->sc_dk.dk_openmask == 0) {\n\t}\n\nbad3:\n\twdunlock(wd);\nbad4:\n#ifndef __OpenBSD__\n\tif (wd->sc_dk.dk_openmask == 0)\n\t\twdc_ata_delref(wd->drvp);\n#endif\n\tdevice_unref(&wd->sc_dev);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDPART",
          "args": [
            "dev"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdlookup",
          "args": [
            "WDUNIT(dev)"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDUNIT",
          "args": [
            "dev"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdsize\\n\")",
            "DEBUG_FUNCS"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_FUNCS  0x08\n\nint\nwdsize(dev)\n\tdev_t dev;\n{\n\tstruct wd_softc *wd;\n\tint part, omask;\n\tint size;\n\n\tWDCDEBUG_PRINT((\"wdsize\\n\"), DEBUG_FUNCS);\n\n\twd = wdlookup(WDUNIT(dev));\n\tif (wd == NULL)\n\t\treturn (-1);\n\n\tpart = WDPART(dev);\n\tomask = wd->sc_dk.dk_openmask & (1 << part);\n\n\tif (omask == 0 && wdopen(dev, 0, S_IFBLK, NULL) != 0) {\n\t\tsize = -1;\n\t\tgoto exit;\n\t}\n\n\tif (wd->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)\n\t\tsize = -1;\n\telse\n\t\tsize = wd->sc_dk.dk_label->d_partitions[part].p_size *\n\t\t    (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\tif (omask == 0 && wdclose(dev, 0, S_IFBLK, NULL) != 0)\n\t\tsize = -1;\n\n exit:\n\tdevice_unref(&wd->sc_dev);\n\treturn (size);\n}"
  },
  {
    "function_name": "wdformat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "1115-1121",
    "snippet": "int\nwdformat(struct buf *bp)\n{\n\n\tbp->b_flags |= B_FORMAT;\n\treturn wdstrategy(bp);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void  wdstrategy",
      "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdstrategy",
          "args": [
            "bp"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "wdstrategy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "465-522",
          "snippet": "void\nwdstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct wd_softc *wd;\n\tint s;\n\n\twd = wdlookup(WDUNIT(bp->b_dev));\n\tif (wd == NULL) {\n\t\tbp->b_error = ENXIO;\n\t\tgoto bad;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdstrategy (%s)\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\t\n\t/* Valid request?  */\n\tif (bp->b_blkno < 0 ||\n\t    (bp->b_bcount % wd->sc_dk.dk_label->d_secsize) != 0 ||\n\t    (bp->b_bcount / wd->sc_dk.dk_label->d_secsize) >= (1 << NBBY)) {\n\t\tbp->b_error = EINVAL;\n\t\tgoto bad;\n\t}\n\t\n\t/* If device invalidated (e.g. media change, door open), error. */\n\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\tbp->b_error = EIO;\n\t\tgoto bad;\n\t}\n\n\t/* If it's a null transfer, return immediately. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\n\t/*\n\t * Do bounds checking, adjust transfer. if error, process.\n\t * If end of partition, just return.\n\t */\n\tif (WDPART(bp->b_dev) != RAW_PART &&\n\t    bounds_check_with_label(bp, wd->sc_dk.dk_label, wd->sc_dk.dk_cpulabel,\n\t    (wd->sc_flags & (WDF_WLABEL|WDF_LABELLING)) != 0) <= 0)\n\t\tgoto done;\n\t/* Queue transfer on drive, activate drive and controller if idle. */\n\ts = splbio();\n\tdisksort(&wd->sc_q, bp);\n\twdstart(wd);\n\tsplx(s);\n\tdevice_unref(&wd->sc_dev);\n\treturn;\nbad:\n\tbp->b_flags |= B_ERROR;\ndone:\n\t/* Toss transfer; we're done early. */\n\tbp->b_resid = bp->b_bcount;\n\tbiodone(bp);\n\tif (wd != NULL)\n\t\tdevice_unref(&wd->sc_dev);\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define WDF_LOADED\t  0x10 /* parameters loaded */",
            "#define WDF_LABELLING   0x08 /* writing label */",
            "#define WDF_WLABEL\t  0x04 /* label is writable */",
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [
            "void  wdstrategy",
            "void  wdstart",
            "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define WDF_LOADED\t  0x10 /* parameters loaded */\n#define WDF_LABELLING   0x08 /* writing label */\n#define WDF_WLABEL\t  0x04 /* label is writable */\n#define DEBUG_XFERS  0x02\n\nvoid  wdstrategy;\nvoid  wdstart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\nwdstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct wd_softc *wd;\n\tint s;\n\n\twd = wdlookup(WDUNIT(bp->b_dev));\n\tif (wd == NULL) {\n\t\tbp->b_error = ENXIO;\n\t\tgoto bad;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdstrategy (%s)\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\t\n\t/* Valid request?  */\n\tif (bp->b_blkno < 0 ||\n\t    (bp->b_bcount % wd->sc_dk.dk_label->d_secsize) != 0 ||\n\t    (bp->b_bcount / wd->sc_dk.dk_label->d_secsize) >= (1 << NBBY)) {\n\t\tbp->b_error = EINVAL;\n\t\tgoto bad;\n\t}\n\t\n\t/* If device invalidated (e.g. media change, door open), error. */\n\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\tbp->b_error = EIO;\n\t\tgoto bad;\n\t}\n\n\t/* If it's a null transfer, return immediately. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\n\t/*\n\t * Do bounds checking, adjust transfer. if error, process.\n\t * If end of partition, just return.\n\t */\n\tif (WDPART(bp->b_dev) != RAW_PART &&\n\t    bounds_check_with_label(bp, wd->sc_dk.dk_label, wd->sc_dk.dk_cpulabel,\n\t    (wd->sc_flags & (WDF_WLABEL|WDF_LABELLING)) != 0) <= 0)\n\t\tgoto done;\n\t/* Queue transfer on drive, activate drive and controller if idle. */\n\ts = splbio();\n\tdisksort(&wd->sc_q, bp);\n\twdstart(wd);\n\tsplx(s);\n\tdevice_unref(&wd->sc_dev);\n\treturn;\nbad:\n\tbp->b_flags |= B_ERROR;\ndone:\n\t/* Toss transfer; we're done early. */\n\tbp->b_resid = bp->b_bcount;\n\tbiodone(bp);\n\tif (wd != NULL)\n\t\tdevice_unref(&wd->sc_dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nvoid  wdstrategy;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nint\nwdformat(struct buf *bp)\n{\n\n\tbp->b_flags |= B_FORMAT;\n\treturn wdstrategy(bp);\n}"
  },
  {
    "function_name": "wdioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "923-1112",
    "snippet": "int\nwdioctl(dev, xfer, addr, flag, p)\n\tdev_t dev;\n\tu_long xfer;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wd_softc *wd;\n\tint error = 0;\n\n\tWDCDEBUG_PRINT((\"wdioctl\\n\"), DEBUG_FUNCS);\n\n\twd = wdlookup(WDUNIT(dev));\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\t\n\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\terror = EIO;\n\t\tgoto exit;\n\t}\n\n\tswitch (xfer) {\n#ifdef DKBAD\n\tcase DIOCSBAD:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\tDKBAD(wd->sc_dk.dk_cpulabel) = *(struct dkbad *)addr;\n\t\twd->sc_dk.dk_label->d_flags |= D_BADSECT;\n\t\tbad144intern(wd);\n\t\tgoto exit;\n#endif\n\n\tcase DIOCRLDINFO:\n\t\twdgetdisklabel(dev, wd, wd->sc_dk.dk_label,\n\t\t    wd->sc_dk.dk_cpulabel, 0);\n\t\tgoto exit;\n\tcase DIOCGPDINFO: {\n\t\t\tstruct cpu_disklabel osdep;\n\n\t\t\twdgetdisklabel(dev, wd, (struct disklabel *)addr,\n\t\t\t    &osdep, 1);\n\t\t\tgoto exit;\n\t\t}\n\n\tcase DIOCGDINFO:\n\t\t*(struct disklabel *)addr = *(wd->sc_dk.dk_label);\n\t\tgoto exit;\n\t\n\tcase DIOCGPART:\n\t\t((struct partinfo *)addr)->disklab = wd->sc_dk.dk_label;\n\t\t((struct partinfo *)addr)->part =\n\t\t    &wd->sc_dk.dk_label->d_partitions[WDPART(dev)];\n\t\tgoto exit;\n\t\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((flag & FWRITE) == 0) {\n\t\t\terror = EBADF;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif ((error = wdlock(wd)) != 0)\n\t\t\tgoto exit;\n\t\twd->sc_flags |= WDF_LABELLING;\n\n\t\terror = setdisklabel(wd->sc_dk.dk_label,\n\t\t    (struct disklabel *)addr, /*wd->sc_dk.dk_openmask : */0,\n\t\t    wd->sc_dk.dk_cpulabel);\n\t\tif (error == 0) {\n\t\t\tif (wd->drvp->state > RECAL)\n\t\t\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\t\t\tif (xfer == DIOCWDINFO)\n\t\t\t\terror = writedisklabel(WDLABELDEV(dev),\n\t\t\t\t    wdstrategy, wd->sc_dk.dk_label,\n\t\t\t\t    wd->sc_dk.dk_cpulabel);\n\t\t}\n\n\t\twd->sc_flags &= ~WDF_LABELLING;\n\t\twdunlock(wd);\n\t\tgoto exit;\n\t\n\tcase DIOCWLABEL:\n\t\tif ((flag & FWRITE) == 0) {\n\t\t\terror = EBADF;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (*(int *)addr)\n\t\t\twd->sc_flags |= WDF_WLABEL;\n\t\telse\n\t\t\twd->sc_flags &= ~WDF_WLABEL;\n\t\tgoto exit;\n\n#ifndef __OpenBSD__\n\tcase DIOCGDEFLABEL:\n\t\twdgetdefaultlabel(wd, (struct disklabel *)addr);\n\t\tgoto exit;\n#endif\n\n#ifdef notyet\n\tcase DIOCWFORMAT:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\t{\n\t\tregister struct format_op *fop;\n\t\tstruct iovec aiov;\n\t\tstruct uio auio;\n\t\n\t\tfop = (struct format_op *)addr;\n\t\taiov.iov_base = fop->df_buf;\n\t\taiov.iov_len = fop->df_count;\n\t\tauio.uio_iov = &aiov;\n\t\tauio.uio_iovcnt = 1;\n\t\tauio.uio_resid = fop->df_count;\n\t\tauio.uio_segflg = 0;\n\t\tauio.uio_offset =\n\t\t\tfop->df_startblk * wd->sc_dk.dk_label->d_secsize;\n\t\tauio.uio_procp = p;\n\t\terror = physio(wdformat, NULL, dev, B_WRITE, minphys,\n\t\t    &auio);\n\t\tfop->df_count -= auio.uio_resid;\n\t\tfop->df_reg[0] = wdc->sc_status;\n\t\tfop->df_reg[1] = wdc->sc_error;\n\t\tgoto exit;\n\t\t}\n#endif\n\n\tcase ATAIOCCOMMAND:\n\t\t/*\n\t\t * Make sure this command is (relatively) safe first\n\t\t */\n\t\tif ((((atareq_t *) addr)->flags & ATACMD_READ) == 0 &&\n\t\t    (flag & FWRITE) == 0) {\n\t\t\terror = EBADF;\n\t\t\tgoto exit;\n\t\t}\n\t\t{\n\t\tstruct wd_ioctl *wi;\n\t\tatareq_t *atareq = (atareq_t *) addr;\n\t\tint error;\n\n\t\twi = wi_get();\n\t\twi->wi_softc = wd;\n\t\twi->wi_atareq = *atareq;\n\n\t\tif (atareq->datalen && atareq->flags &\n\t\t    (ATACMD_READ | ATACMD_WRITE)) {\n\t\t\twi->wi_iov.iov_base = atareq->databuf;\n\t\t\twi->wi_iov.iov_len = atareq->datalen;\n\t\t\twi->wi_uio.uio_iov = &wi->wi_iov;\n\t\t\twi->wi_uio.uio_iovcnt = 1;\n\t\t\twi->wi_uio.uio_resid = atareq->datalen;\n\t\t\twi->wi_uio.uio_offset = 0;\n\t\t\twi->wi_uio.uio_segflg = UIO_USERSPACE;\n\t\t\twi->wi_uio.uio_rw =\n\t\t\t    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE;\n\t\t\twi->wi_uio.uio_procp = p;\n\t\t\terror = physio(wdioctlstrategy, &wi->wi_bp, dev,\n\t\t\t    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE,\n\t\t\t    minphys, &wi->wi_uio);\n\t\t} else {\n\t\t\t/* No need to call physio if we don't have any\n\t\t\t   user data */\n\t\t\twi->wi_bp.b_flags = 0;\n\t\t\twi->wi_bp.b_data = 0;\n\t\t\twi->wi_bp.b_bcount = 0;\n\t\t\twi->wi_bp.b_dev = 0;\n\t\t\twi->wi_bp.b_proc = p;\n\t\t\twdioctlstrategy(&wi->wi_bp);\n\t\t\terror = wi->wi_bp.b_error;\n\t\t}\n\t\t*atareq = wi->wi_atareq;\n\t\twi_free(wi);\n\t\tgoto exit;\n\t\t}\n\n\tdefault:\n\t\terror = ENOTTY;\n\t\tgoto exit;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"wdioctl: impossible\");\n#endif\n\n exit:\n\tdevice_unref(&wd->sc_dev);\n\treturn (error);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define WDF_LOADED\t  0x10 /* parameters loaded */",
      "#define WDF_LABELLING   0x08 /* writing label */",
      "#define WDF_WLABEL\t  0x04 /* label is writable */",
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [
      "void\twi_free",
      "struct\twd_ioctl *wi_get",
      "void\twdioctlstrategy",
      "void  wdgetdefaultlabel",
      "void  wdgetdisklabel",
      "void  wdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_unref",
          "args": [
            "&wd->sc_dev"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wdioctl: impossible\""
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_free",
          "args": [
            "wi"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "wi_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "1432-1442",
          "snippet": "void\nwi_free(wi)\n\tstruct wd_ioctl *wi;\n{\n\tint s;\n\n\ts = splbio();\n\tLIST_REMOVE(wi, wi_list);\n\tsplx(s);\n\tfree(wi, M_TEMP);\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\twi_free"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nvoid\twi_free;\n\nvoid\nwi_free(wi)\n\tstruct wd_ioctl *wi;\n{\n\tint s;\n\n\ts = splbio();\n\tLIST_REMOVE(wi, wi_list);\n\tsplx(s);\n\tfree(wi, M_TEMP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdioctlstrategy",
          "args": [
            "&wi->wi_bp"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "wdioctlstrategy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "1485-1587",
          "snippet": "void\nwdioctlstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct wd_ioctl *wi;\n\tstruct wdc_command wdc_c;\n\tint error = 0;\n\n\twi = wi_find(bp);\n\tif (wi == NULL) {\n\t\tprintf(\"user_strat: No ioctl\\n\");\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\tbzero(&wdc_c, sizeof(wdc_c));\n\n\t/*\n\t * Abort if physio broke up the transfer\n\t */\n\n\tif (bp->b_bcount != wi->wi_atareq.datalen) {\n\t\tprintf(\"physio split wd ioctl request... cannot proceed\\n\");\n\t\terror = EIO;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Abort if we didn't get a buffer size that was a multiple of\n\t * our sector size (or was larger than NBBY)\n\t */\n\n\tif ((bp->b_bcount % wi->wi_softc->sc_dk.dk_label->d_secsize) != 0 ||\n\t    (bp->b_bcount / wi->wi_softc->sc_dk.dk_label->d_secsize) >=\n\t     (1 << NBBY)) {\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Make sure a timeout was supplied in the ioctl request\n\t */\n\n\tif (wi->wi_atareq.timeout == 0) {\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\tif (wi->wi_atareq.flags & ATACMD_READ)\n\t\twdc_c.flags |= AT_READ;\n\telse if (wi->wi_atareq.flags & ATACMD_WRITE)\n\t\twdc_c.flags |= AT_WRITE;\n\n\tif (wi->wi_atareq.flags & ATACMD_READREG)\n\t\twdc_c.flags |= AT_READREG;\n\n\twdc_c.flags |= AT_WAIT;\n\n\twdc_c.timeout = wi->wi_atareq.timeout;\n\twdc_c.r_command = wi->wi_atareq.command;\n\twdc_c.r_head = wi->wi_atareq.head & 0x0f;\n\twdc_c.r_cyl = wi->wi_atareq.cylinder;\n\twdc_c.r_sector = wi->wi_atareq.sec_num;\n\twdc_c.r_count = wi->wi_atareq.sec_count;\n\twdc_c.r_precomp = wi->wi_atareq.features;\n\twdc_c.r_st_bmask = WDCS_DRDY;\n\twdc_c.r_st_pmask = WDCS_DRDY;\n\twdc_c.data = wi->wi_bp.b_data;\n\twdc_c.bcount = wi->wi_bp.b_bcount;\n\n\tif (wdc_exec_command(wi->wi_softc->drvp, &wdc_c) != WDC_COMPLETE) {\n\t\twi->wi_atareq.retsts = ATACMD_ERROR;\n\t\tgoto bad;\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\tif (wdc_c.flags & AT_ERROR) {\n\t\t\twi->wi_atareq.retsts = ATACMD_ERROR;\n\t\t\twi->wi_atareq.error = wdc_c.r_error;\n\t\t} else if (wdc_c.flags & AT_DF)\n\t\t\twi->wi_atareq.retsts = ATACMD_DF;\n\t\telse\n\t\t\twi->wi_atareq.retsts = ATACMD_TIMEOUT;\n\t} else {\n\t\twi->wi_atareq.retsts = ATACMD_OK;\n\t\tif (wi->wi_atareq.flags & ATACMD_READREG) {\n\t\t\twi->wi_atareq.head = wdc_c.r_head ;\n\t\t\twi->wi_atareq.cylinder = wdc_c.r_cyl;\n\t\t\twi->wi_atareq.sec_num = wdc_c.r_sector;\n\t\t\twi->wi_atareq.sec_count = wdc_c.r_count; \n\t\t\twi->wi_atareq.features = wdc_c.r_precomp; \n\t\t\twi->wi_atareq.error = wdc_c.r_error; \n\t\t}\n\t}\n\n\tbp->b_error = 0;\n\tbiodone(bp);\n\treturn;\nbad:\n\tbp->b_flags |= B_ERROR;\n\tbp->b_error = error;\n\tbiodone(bp);\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct\twd_ioctl *wi_find",
            "void\twdioctlstrategy",
            "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nstruct\twd_ioctl *wi_find;\nvoid\twdioctlstrategy;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\nwdioctlstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct wd_ioctl *wi;\n\tstruct wdc_command wdc_c;\n\tint error = 0;\n\n\twi = wi_find(bp);\n\tif (wi == NULL) {\n\t\tprintf(\"user_strat: No ioctl\\n\");\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\tbzero(&wdc_c, sizeof(wdc_c));\n\n\t/*\n\t * Abort if physio broke up the transfer\n\t */\n\n\tif (bp->b_bcount != wi->wi_atareq.datalen) {\n\t\tprintf(\"physio split wd ioctl request... cannot proceed\\n\");\n\t\terror = EIO;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Abort if we didn't get a buffer size that was a multiple of\n\t * our sector size (or was larger than NBBY)\n\t */\n\n\tif ((bp->b_bcount % wi->wi_softc->sc_dk.dk_label->d_secsize) != 0 ||\n\t    (bp->b_bcount / wi->wi_softc->sc_dk.dk_label->d_secsize) >=\n\t     (1 << NBBY)) {\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Make sure a timeout was supplied in the ioctl request\n\t */\n\n\tif (wi->wi_atareq.timeout == 0) {\n\t\terror = EINVAL;\n\t\tgoto bad;\n\t}\n\n\tif (wi->wi_atareq.flags & ATACMD_READ)\n\t\twdc_c.flags |= AT_READ;\n\telse if (wi->wi_atareq.flags & ATACMD_WRITE)\n\t\twdc_c.flags |= AT_WRITE;\n\n\tif (wi->wi_atareq.flags & ATACMD_READREG)\n\t\twdc_c.flags |= AT_READREG;\n\n\twdc_c.flags |= AT_WAIT;\n\n\twdc_c.timeout = wi->wi_atareq.timeout;\n\twdc_c.r_command = wi->wi_atareq.command;\n\twdc_c.r_head = wi->wi_atareq.head & 0x0f;\n\twdc_c.r_cyl = wi->wi_atareq.cylinder;\n\twdc_c.r_sector = wi->wi_atareq.sec_num;\n\twdc_c.r_count = wi->wi_atareq.sec_count;\n\twdc_c.r_precomp = wi->wi_atareq.features;\n\twdc_c.r_st_bmask = WDCS_DRDY;\n\twdc_c.r_st_pmask = WDCS_DRDY;\n\twdc_c.data = wi->wi_bp.b_data;\n\twdc_c.bcount = wi->wi_bp.b_bcount;\n\n\tif (wdc_exec_command(wi->wi_softc->drvp, &wdc_c) != WDC_COMPLETE) {\n\t\twi->wi_atareq.retsts = ATACMD_ERROR;\n\t\tgoto bad;\n\t}\n\n\tif (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {\n\t\tif (wdc_c.flags & AT_ERROR) {\n\t\t\twi->wi_atareq.retsts = ATACMD_ERROR;\n\t\t\twi->wi_atareq.error = wdc_c.r_error;\n\t\t} else if (wdc_c.flags & AT_DF)\n\t\t\twi->wi_atareq.retsts = ATACMD_DF;\n\t\telse\n\t\t\twi->wi_atareq.retsts = ATACMD_TIMEOUT;\n\t} else {\n\t\twi->wi_atareq.retsts = ATACMD_OK;\n\t\tif (wi->wi_atareq.flags & ATACMD_READREG) {\n\t\t\twi->wi_atareq.head = wdc_c.r_head ;\n\t\t\twi->wi_atareq.cylinder = wdc_c.r_cyl;\n\t\t\twi->wi_atareq.sec_num = wdc_c.r_sector;\n\t\t\twi->wi_atareq.sec_count = wdc_c.r_count; \n\t\t\twi->wi_atareq.features = wdc_c.r_precomp; \n\t\t\twi->wi_atareq.error = wdc_c.r_error; \n\t\t}\n\t}\n\n\tbp->b_error = 0;\n\tbiodone(bp);\n\treturn;\nbad:\n\tbp->b_flags |= B_ERROR;\n\tbp->b_error = error;\n\tbiodone(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "wdioctlstrategy",
            "&wi->wi_bp",
            "dev",
            "(atareq->flags & ATACMD_READ) ? B_READ : B_WRITE",
            "minphys",
            "&wi->wi_uio"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wi_get",
          "args": [],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "wi_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "1414-1426",
          "snippet": "struct wd_ioctl *\nwi_get()\n{\n\tstruct wd_ioctl *wi;\n\tint s;\n\n\twi = malloc(sizeof(struct wd_ioctl), M_TEMP, M_WAITOK);\n\tbzero(wi, sizeof (struct wd_ioctl));\n\ts = splbio();\n\tLIST_INSERT_HEAD(&wi_head, wi, wi_list);\n\tsplx(s);\n\treturn (wi);\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "LIST_HEAD(, wd_ioctl) wi_head;",
            "struct\twd_ioctl *wi_get"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nLIST_HEAD(, wd_ioctl) wi_head;\nstruct\twd_ioctl *wi_get;\n\nstruct wd_ioctl *\nwi_get()\n{\n\tstruct wd_ioctl *wi;\n\tint s;\n\n\twi = malloc(sizeof(struct wd_ioctl), M_TEMP, M_WAITOK);\n\tbzero(wi, sizeof (struct wd_ioctl));\n\ts = splbio();\n\tLIST_INSERT_HEAD(&wi_head, wi, wi_list);\n\tsplx(s);\n\treturn (wi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "wdformat",
            "NULL",
            "dev",
            "B_WRITE",
            "minphys",
            "&auio"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdgetdefaultlabel",
          "args": [
            "wd",
            "(struct disklabel *)addr"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "wdgetdefaultlabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "835-871",
          "snippet": "void\nwdgetdefaultlabel(wd, lp)\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n{\n\tWDCDEBUG_PRINT((\"wdgetdefaultlabel\\n\"), DEBUG_FUNCS);\n\tbzero(lp, sizeof(struct disklabel));\n\n\tlp->d_secsize = DEV_BSIZE;\n\tlp->d_ntracks = wd->sc_params.atap_heads;\n\tlp->d_nsectors = wd->sc_params.atap_sectors;\n\tlp->d_ncylinders = wd->sc_params.atap_cylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (wd->drvp->ata_vers == -1) {\n\t\tlp->d_type = DTYPE_ST506;\n\t\tstrncpy(lp->d_typename, \"ST506/MFM/RLL\", 16);\n\t} else {\n\t\tlp->d_type = DTYPE_ESDI;\n\t\tstrncpy(lp->d_typename, \"ESDI/IDE disk\", 16);\n\t}\n\t/* XXX - user viscopy() like sd.c */\n\tstrncpy(lp->d_packname, wd->sc_params.atap_model, 16);\n\tlp->d_secperunit = wd->sc_capacity;\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\tlp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  wdgetdefaultlabel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_FUNCS  0x08\n\nvoid  wdgetdefaultlabel;\n\nvoid\nwdgetdefaultlabel(wd, lp)\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n{\n\tWDCDEBUG_PRINT((\"wdgetdefaultlabel\\n\"), DEBUG_FUNCS);\n\tbzero(lp, sizeof(struct disklabel));\n\n\tlp->d_secsize = DEV_BSIZE;\n\tlp->d_ntracks = wd->sc_params.atap_heads;\n\tlp->d_nsectors = wd->sc_params.atap_sectors;\n\tlp->d_ncylinders = wd->sc_params.atap_cylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (wd->drvp->ata_vers == -1) {\n\t\tlp->d_type = DTYPE_ST506;\n\t\tstrncpy(lp->d_typename, \"ST506/MFM/RLL\", 16);\n\t} else {\n\t\tlp->d_type = DTYPE_ESDI;\n\t\tstrncpy(lp->d_typename, \"ESDI/IDE disk\", 16);\n\t}\n\t/* XXX - user viscopy() like sd.c */\n\tstrncpy(lp->d_packname, wd->sc_params.atap_model, 16);\n\tlp->d_secperunit = wd->sc_capacity;\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\tlp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdunlock",
          "args": [
            "wd"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writedisklabel",
          "args": [
            "WDLABELDEV(dev)",
            "wdstrategy",
            "wd->sc_dk.dk_label",
            "wd->sc_dk.dk_cpulabel"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDLABELDEV",
          "args": [
            "dev"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setdisklabel",
          "args": [
            "wd->sc_dk.dk_label",
            "(struct disklabel *)addr",
            "/*wd->sc_dk.dk_openmask : */0",
            "wd->sc_dk.dk_cpulabel"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdlock",
          "args": [
            "wd"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDPART",
          "args": [
            "dev"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdgetdisklabel",
          "args": [
            "dev",
            "wd",
            "(struct disklabel *)addr",
            "&osdep",
            "1"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "wdgetdisklabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "876-921",
          "snippet": "void\nwdgetdisklabel(dev, wd, lp, clp, spoofonly)\n\tdev_t  dev;\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\n\tWDCDEBUG_PRINT((\"wdgetdisklabel\\n\"), DEBUG_FUNCS);\n\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\twdgetdefaultlabel(wd, lp);\n\n\twd->sc_badsect[0] = -1;\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\terrstring = readdisklabel(WDLABELDEV(dev),\n\t    wdstrategy, lp, clp, spoofonly);\n\tif (errstring) {\n\t\t/*\n\t\t * This probably happened because the drive's default\n\t\t * geometry doesn't match the DOS geometry.  We\n\t\t * assume the DOS geometry is now in the label and try\n\t\t * again.  XXX This is a kluge.\n\t\t */\n\t\tif (wd->drvp->state > RECAL)\n\t\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\t\terrstring = readdisklabel(WDLABELDEV(dev),\n\t\t    wdstrategy, lp, clp, spoofonly);\n\t}\n\tif (errstring) {\n\t\tprintf(\"%s: %s\\n\", wd->sc_dev.dv_xname, errstring);\n\t\treturn;\n\t}\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n#ifdef DKBAD\n\tif ((lp->d_flags & D_BADSECT) != 0)\n\t\tbad144intern(wd);\n#endif\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define sc_badsect sc_wdc_bio.badsect",
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  wdgetdefaultlabel",
            "void  wdgetdisklabel",
            "void  wdstrategy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_badsect sc_wdc_bio.badsect\n#define DEBUG_FUNCS  0x08\n\nvoid  wdgetdefaultlabel;\nvoid  wdgetdisklabel;\nvoid  wdstrategy;\n\nvoid\nwdgetdisklabel(dev, wd, lp, clp, spoofonly)\n\tdev_t  dev;\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\n\tWDCDEBUG_PRINT((\"wdgetdisklabel\\n\"), DEBUG_FUNCS);\n\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\twdgetdefaultlabel(wd, lp);\n\n\twd->sc_badsect[0] = -1;\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\terrstring = readdisklabel(WDLABELDEV(dev),\n\t    wdstrategy, lp, clp, spoofonly);\n\tif (errstring) {\n\t\t/*\n\t\t * This probably happened because the drive's default\n\t\t * geometry doesn't match the DOS geometry.  We\n\t\t * assume the DOS geometry is now in the label and try\n\t\t * again.  XXX This is a kluge.\n\t\t */\n\t\tif (wd->drvp->state > RECAL)\n\t\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\t\terrstring = readdisklabel(WDLABELDEV(dev),\n\t\t    wdstrategy, lp, clp, spoofonly);\n\t}\n\tif (errstring) {\n\t\tprintf(\"%s: %s\\n\", wd->sc_dev.dv_xname, errstring);\n\t\treturn;\n\t}\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n#ifdef DKBAD\n\tif ((lp->d_flags & D_BADSECT) != 0)\n\t\tbad144intern(wd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bad144intern",
          "args": [
            "wd"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "bad144intern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "1312-1332",
          "snippet": "void\nbad144intern(wd)\n\tstruct wd_softc *wd;\n{\n\tstruct dkbad *bt = &DKBAD(wd->sc_dk.dk_cpulabel);\n\tstruct disklabel *lp = wd->sc_dk.dk_label;\n\tint i = 0;\n\n\tWDCDEBUG_PRINT((\"bad144intern\\n\"), DEBUG_XFERS);\n\n\tfor (; i < NBT_BAD; i++) {\n\t\tif (bt->bt_bad[i].bt_cyl == 0xffff)\n\t\t\tbreak;\n\t\twd->sc_badsect[i] =\n\t\t    bt->bt_bad[i].bt_cyl * lp->d_secpercyl +\n\t\t    (bt->bt_bad[i].bt_trksec >> 8) * lp->d_nsectors +\n\t\t    (bt->bt_bad[i].bt_trksec & 0xff);\n\t}\n\tfor (; i < NBT_BAD+1; i++)\n\t\twd->sc_badsect[i] = -1;\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define sc_badsect sc_wdc_bio.badsect",
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_badsect sc_wdc_bio.badsect\n#define DEBUG_XFERS  0x02\n\nvoid\nbad144intern(wd)\n\tstruct wd_softc *wd;\n{\n\tstruct dkbad *bt = &DKBAD(wd->sc_dk.dk_cpulabel);\n\tstruct disklabel *lp = wd->sc_dk.dk_label;\n\tint i = 0;\n\n\tWDCDEBUG_PRINT((\"bad144intern\\n\"), DEBUG_XFERS);\n\n\tfor (; i < NBT_BAD; i++) {\n\t\tif (bt->bt_bad[i].bt_cyl == 0xffff)\n\t\t\tbreak;\n\t\twd->sc_badsect[i] =\n\t\t    bt->bt_bad[i].bt_cyl * lp->d_secpercyl +\n\t\t    (bt->bt_bad[i].bt_trksec >> 8) * lp->d_nsectors +\n\t\t    (bt->bt_bad[i].bt_trksec & 0xff);\n\t}\n\tfor (; i < NBT_BAD+1; i++)\n\t\twd->sc_badsect[i] = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DKBAD",
          "args": [
            "wd->sc_dk.dk_cpulabel"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdlookup",
          "args": [
            "WDUNIT(dev)"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDUNIT",
          "args": [
            "dev"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdioctl\\n\")",
            "DEBUG_FUNCS"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define WDF_LOADED\t  0x10 /* parameters loaded */\n#define WDF_LABELLING   0x08 /* writing label */\n#define WDF_WLABEL\t  0x04 /* label is writable */\n#define DEBUG_FUNCS  0x08\n\nvoid\twi_free;\nstruct\twd_ioctl *wi_get;\nvoid\twdioctlstrategy;\nvoid  wdgetdefaultlabel;\nvoid  wdgetdisklabel;\nvoid  wdstrategy;\n\nint\nwdioctl(dev, xfer, addr, flag, p)\n\tdev_t dev;\n\tu_long xfer;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wd_softc *wd;\n\tint error = 0;\n\n\tWDCDEBUG_PRINT((\"wdioctl\\n\"), DEBUG_FUNCS);\n\n\twd = wdlookup(WDUNIT(dev));\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\t\n\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\terror = EIO;\n\t\tgoto exit;\n\t}\n\n\tswitch (xfer) {\n#ifdef DKBAD\n\tcase DIOCSBAD:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\tDKBAD(wd->sc_dk.dk_cpulabel) = *(struct dkbad *)addr;\n\t\twd->sc_dk.dk_label->d_flags |= D_BADSECT;\n\t\tbad144intern(wd);\n\t\tgoto exit;\n#endif\n\n\tcase DIOCRLDINFO:\n\t\twdgetdisklabel(dev, wd, wd->sc_dk.dk_label,\n\t\t    wd->sc_dk.dk_cpulabel, 0);\n\t\tgoto exit;\n\tcase DIOCGPDINFO: {\n\t\t\tstruct cpu_disklabel osdep;\n\n\t\t\twdgetdisklabel(dev, wd, (struct disklabel *)addr,\n\t\t\t    &osdep, 1);\n\t\t\tgoto exit;\n\t\t}\n\n\tcase DIOCGDINFO:\n\t\t*(struct disklabel *)addr = *(wd->sc_dk.dk_label);\n\t\tgoto exit;\n\t\n\tcase DIOCGPART:\n\t\t((struct partinfo *)addr)->disklab = wd->sc_dk.dk_label;\n\t\t((struct partinfo *)addr)->part =\n\t\t    &wd->sc_dk.dk_label->d_partitions[WDPART(dev)];\n\t\tgoto exit;\n\t\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((flag & FWRITE) == 0) {\n\t\t\terror = EBADF;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif ((error = wdlock(wd)) != 0)\n\t\t\tgoto exit;\n\t\twd->sc_flags |= WDF_LABELLING;\n\n\t\terror = setdisklabel(wd->sc_dk.dk_label,\n\t\t    (struct disklabel *)addr, /*wd->sc_dk.dk_openmask : */0,\n\t\t    wd->sc_dk.dk_cpulabel);\n\t\tif (error == 0) {\n\t\t\tif (wd->drvp->state > RECAL)\n\t\t\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\t\t\tif (xfer == DIOCWDINFO)\n\t\t\t\terror = writedisklabel(WDLABELDEV(dev),\n\t\t\t\t    wdstrategy, wd->sc_dk.dk_label,\n\t\t\t\t    wd->sc_dk.dk_cpulabel);\n\t\t}\n\n\t\twd->sc_flags &= ~WDF_LABELLING;\n\t\twdunlock(wd);\n\t\tgoto exit;\n\t\n\tcase DIOCWLABEL:\n\t\tif ((flag & FWRITE) == 0) {\n\t\t\terror = EBADF;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (*(int *)addr)\n\t\t\twd->sc_flags |= WDF_WLABEL;\n\t\telse\n\t\t\twd->sc_flags &= ~WDF_WLABEL;\n\t\tgoto exit;\n\n#ifndef __OpenBSD__\n\tcase DIOCGDEFLABEL:\n\t\twdgetdefaultlabel(wd, (struct disklabel *)addr);\n\t\tgoto exit;\n#endif\n\n#ifdef notyet\n\tcase DIOCWFORMAT:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\t{\n\t\tregister struct format_op *fop;\n\t\tstruct iovec aiov;\n\t\tstruct uio auio;\n\t\n\t\tfop = (struct format_op *)addr;\n\t\taiov.iov_base = fop->df_buf;\n\t\taiov.iov_len = fop->df_count;\n\t\tauio.uio_iov = &aiov;\n\t\tauio.uio_iovcnt = 1;\n\t\tauio.uio_resid = fop->df_count;\n\t\tauio.uio_segflg = 0;\n\t\tauio.uio_offset =\n\t\t\tfop->df_startblk * wd->sc_dk.dk_label->d_secsize;\n\t\tauio.uio_procp = p;\n\t\terror = physio(wdformat, NULL, dev, B_WRITE, minphys,\n\t\t    &auio);\n\t\tfop->df_count -= auio.uio_resid;\n\t\tfop->df_reg[0] = wdc->sc_status;\n\t\tfop->df_reg[1] = wdc->sc_error;\n\t\tgoto exit;\n\t\t}\n#endif\n\n\tcase ATAIOCCOMMAND:\n\t\t/*\n\t\t * Make sure this command is (relatively) safe first\n\t\t */\n\t\tif ((((atareq_t *) addr)->flags & ATACMD_READ) == 0 &&\n\t\t    (flag & FWRITE) == 0) {\n\t\t\terror = EBADF;\n\t\t\tgoto exit;\n\t\t}\n\t\t{\n\t\tstruct wd_ioctl *wi;\n\t\tatareq_t *atareq = (atareq_t *) addr;\n\t\tint error;\n\n\t\twi = wi_get();\n\t\twi->wi_softc = wd;\n\t\twi->wi_atareq = *atareq;\n\n\t\tif (atareq->datalen && atareq->flags &\n\t\t    (ATACMD_READ | ATACMD_WRITE)) {\n\t\t\twi->wi_iov.iov_base = atareq->databuf;\n\t\t\twi->wi_iov.iov_len = atareq->datalen;\n\t\t\twi->wi_uio.uio_iov = &wi->wi_iov;\n\t\t\twi->wi_uio.uio_iovcnt = 1;\n\t\t\twi->wi_uio.uio_resid = atareq->datalen;\n\t\t\twi->wi_uio.uio_offset = 0;\n\t\t\twi->wi_uio.uio_segflg = UIO_USERSPACE;\n\t\t\twi->wi_uio.uio_rw =\n\t\t\t    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE;\n\t\t\twi->wi_uio.uio_procp = p;\n\t\t\terror = physio(wdioctlstrategy, &wi->wi_bp, dev,\n\t\t\t    (atareq->flags & ATACMD_READ) ? B_READ : B_WRITE,\n\t\t\t    minphys, &wi->wi_uio);\n\t\t} else {\n\t\t\t/* No need to call physio if we don't have any\n\t\t\t   user data */\n\t\t\twi->wi_bp.b_flags = 0;\n\t\t\twi->wi_bp.b_data = 0;\n\t\t\twi->wi_bp.b_bcount = 0;\n\t\t\twi->wi_bp.b_dev = 0;\n\t\t\twi->wi_bp.b_proc = p;\n\t\t\twdioctlstrategy(&wi->wi_bp);\n\t\t\terror = wi->wi_bp.b_error;\n\t\t}\n\t\t*atareq = wi->wi_atareq;\n\t\twi_free(wi);\n\t\tgoto exit;\n\t\t}\n\n\tdefault:\n\t\terror = ENOTTY;\n\t\tgoto exit;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"wdioctl: impossible\");\n#endif\n\n exit:\n\tdevice_unref(&wd->sc_dev);\n\treturn (error);\n}"
  },
  {
    "function_name": "wdgetdisklabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "876-921",
    "snippet": "void\nwdgetdisklabel(dev, wd, lp, clp, spoofonly)\n\tdev_t  dev;\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\n\tWDCDEBUG_PRINT((\"wdgetdisklabel\\n\"), DEBUG_FUNCS);\n\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\twdgetdefaultlabel(wd, lp);\n\n\twd->sc_badsect[0] = -1;\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\terrstring = readdisklabel(WDLABELDEV(dev),\n\t    wdstrategy, lp, clp, spoofonly);\n\tif (errstring) {\n\t\t/*\n\t\t * This probably happened because the drive's default\n\t\t * geometry doesn't match the DOS geometry.  We\n\t\t * assume the DOS geometry is now in the label and try\n\t\t * again.  XXX This is a kluge.\n\t\t */\n\t\tif (wd->drvp->state > RECAL)\n\t\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\t\terrstring = readdisklabel(WDLABELDEV(dev),\n\t\t    wdstrategy, lp, clp, spoofonly);\n\t}\n\tif (errstring) {\n\t\tprintf(\"%s: %s\\n\", wd->sc_dev.dv_xname, errstring);\n\t\treturn;\n\t}\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n#ifdef DKBAD\n\tif ((lp->d_flags & D_BADSECT) != 0)\n\t\tbad144intern(wd);\n#endif\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define sc_badsect sc_wdc_bio.badsect",
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [
      "void  wdgetdefaultlabel",
      "void  wdgetdisklabel",
      "void  wdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bad144intern",
          "args": [
            "wd"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "bad144intern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "1312-1332",
          "snippet": "void\nbad144intern(wd)\n\tstruct wd_softc *wd;\n{\n\tstruct dkbad *bt = &DKBAD(wd->sc_dk.dk_cpulabel);\n\tstruct disklabel *lp = wd->sc_dk.dk_label;\n\tint i = 0;\n\n\tWDCDEBUG_PRINT((\"bad144intern\\n\"), DEBUG_XFERS);\n\n\tfor (; i < NBT_BAD; i++) {\n\t\tif (bt->bt_bad[i].bt_cyl == 0xffff)\n\t\t\tbreak;\n\t\twd->sc_badsect[i] =\n\t\t    bt->bt_bad[i].bt_cyl * lp->d_secpercyl +\n\t\t    (bt->bt_bad[i].bt_trksec >> 8) * lp->d_nsectors +\n\t\t    (bt->bt_bad[i].bt_trksec & 0xff);\n\t}\n\tfor (; i < NBT_BAD+1; i++)\n\t\twd->sc_badsect[i] = -1;\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define sc_badsect sc_wdc_bio.badsect",
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_badsect sc_wdc_bio.badsect\n#define DEBUG_XFERS  0x02\n\nvoid\nbad144intern(wd)\n\tstruct wd_softc *wd;\n{\n\tstruct dkbad *bt = &DKBAD(wd->sc_dk.dk_cpulabel);\n\tstruct disklabel *lp = wd->sc_dk.dk_label;\n\tint i = 0;\n\n\tWDCDEBUG_PRINT((\"bad144intern\\n\"), DEBUG_XFERS);\n\n\tfor (; i < NBT_BAD; i++) {\n\t\tif (bt->bt_bad[i].bt_cyl == 0xffff)\n\t\t\tbreak;\n\t\twd->sc_badsect[i] =\n\t\t    bt->bt_bad[i].bt_cyl * lp->d_secpercyl +\n\t\t    (bt->bt_bad[i].bt_trksec >> 8) * lp->d_nsectors +\n\t\t    (bt->bt_bad[i].bt_trksec & 0xff);\n\t}\n\tfor (; i < NBT_BAD+1; i++)\n\t\twd->sc_badsect[i] = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %s\\n\"",
            "wd->sc_dev.dv_xname",
            "errstring"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "readdisklabel",
          "args": [
            "WDLABELDEV(dev)",
            "wdstrategy",
            "lp",
            "clp",
            "spoofonly"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDLABELDEV",
          "args": [
            "dev"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdisklabel",
          "args": [
            "WDLABELDEV(dev)",
            "wdstrategy",
            "lp",
            "clp",
            "spoofonly"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDLABELDEV",
          "args": [
            "dev"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdgetdefaultlabel",
          "args": [
            "wd",
            "lp"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "wdgetdefaultlabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "835-871",
          "snippet": "void\nwdgetdefaultlabel(wd, lp)\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n{\n\tWDCDEBUG_PRINT((\"wdgetdefaultlabel\\n\"), DEBUG_FUNCS);\n\tbzero(lp, sizeof(struct disklabel));\n\n\tlp->d_secsize = DEV_BSIZE;\n\tlp->d_ntracks = wd->sc_params.atap_heads;\n\tlp->d_nsectors = wd->sc_params.atap_sectors;\n\tlp->d_ncylinders = wd->sc_params.atap_cylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (wd->drvp->ata_vers == -1) {\n\t\tlp->d_type = DTYPE_ST506;\n\t\tstrncpy(lp->d_typename, \"ST506/MFM/RLL\", 16);\n\t} else {\n\t\tlp->d_type = DTYPE_ESDI;\n\t\tstrncpy(lp->d_typename, \"ESDI/IDE disk\", 16);\n\t}\n\t/* XXX - user viscopy() like sd.c */\n\tstrncpy(lp->d_packname, wd->sc_params.atap_model, 16);\n\tlp->d_secperunit = wd->sc_capacity;\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\tlp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  wdgetdefaultlabel"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_FUNCS  0x08\n\nvoid  wdgetdefaultlabel;\n\nvoid\nwdgetdefaultlabel(wd, lp)\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n{\n\tWDCDEBUG_PRINT((\"wdgetdefaultlabel\\n\"), DEBUG_FUNCS);\n\tbzero(lp, sizeof(struct disklabel));\n\n\tlp->d_secsize = DEV_BSIZE;\n\tlp->d_ntracks = wd->sc_params.atap_heads;\n\tlp->d_nsectors = wd->sc_params.atap_sectors;\n\tlp->d_ncylinders = wd->sc_params.atap_cylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (wd->drvp->ata_vers == -1) {\n\t\tlp->d_type = DTYPE_ST506;\n\t\tstrncpy(lp->d_typename, \"ST506/MFM/RLL\", 16);\n\t} else {\n\t\tlp->d_type = DTYPE_ESDI;\n\t\tstrncpy(lp->d_typename, \"ESDI/IDE disk\", 16);\n\t}\n\t/* XXX - user viscopy() like sd.c */\n\tstrncpy(lp->d_packname, wd->sc_params.atap_model, 16);\n\tlp->d_secperunit = wd->sc_capacity;\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\tlp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "clp",
            "sizeof(struct cpu_disklabel)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdgetdisklabel\\n\")",
            "DEBUG_FUNCS"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_badsect sc_wdc_bio.badsect\n#define DEBUG_FUNCS  0x08\n\nvoid  wdgetdefaultlabel;\nvoid  wdgetdisklabel;\nvoid  wdstrategy;\n\nvoid\nwdgetdisklabel(dev, wd, lp, clp, spoofonly)\n\tdev_t  dev;\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\n\tWDCDEBUG_PRINT((\"wdgetdisklabel\\n\"), DEBUG_FUNCS);\n\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\twdgetdefaultlabel(wd, lp);\n\n\twd->sc_badsect[0] = -1;\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\terrstring = readdisklabel(WDLABELDEV(dev),\n\t    wdstrategy, lp, clp, spoofonly);\n\tif (errstring) {\n\t\t/*\n\t\t * This probably happened because the drive's default\n\t\t * geometry doesn't match the DOS geometry.  We\n\t\t * assume the DOS geometry is now in the label and try\n\t\t * again.  XXX This is a kluge.\n\t\t */\n\t\tif (wd->drvp->state > RECAL)\n\t\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\t\terrstring = readdisklabel(WDLABELDEV(dev),\n\t\t    wdstrategy, lp, clp, spoofonly);\n\t}\n\tif (errstring) {\n\t\tprintf(\"%s: %s\\n\", wd->sc_dev.dv_xname, errstring);\n\t\treturn;\n\t}\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n#ifdef DKBAD\n\tif ((lp->d_flags & D_BADSECT) != 0)\n\t\tbad144intern(wd);\n#endif\n}"
  },
  {
    "function_name": "wdgetdefaultlabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "835-871",
    "snippet": "void\nwdgetdefaultlabel(wd, lp)\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n{\n\tWDCDEBUG_PRINT((\"wdgetdefaultlabel\\n\"), DEBUG_FUNCS);\n\tbzero(lp, sizeof(struct disklabel));\n\n\tlp->d_secsize = DEV_BSIZE;\n\tlp->d_ntracks = wd->sc_params.atap_heads;\n\tlp->d_nsectors = wd->sc_params.atap_sectors;\n\tlp->d_ncylinders = wd->sc_params.atap_cylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (wd->drvp->ata_vers == -1) {\n\t\tlp->d_type = DTYPE_ST506;\n\t\tstrncpy(lp->d_typename, \"ST506/MFM/RLL\", 16);\n\t} else {\n\t\tlp->d_type = DTYPE_ESDI;\n\t\tstrncpy(lp->d_typename, \"ESDI/IDE disk\", 16);\n\t}\n\t/* XXX - user viscopy() like sd.c */\n\tstrncpy(lp->d_packname, wd->sc_params.atap_model, 16);\n\tlp->d_secperunit = wd->sc_capacity;\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\tlp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [
      "void  wdgetdefaultlabel"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dkcksum",
          "args": [
            "lp"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_packname",
            "wd->sc_params.atap_model",
            "16"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_typename",
            "\"ESDI/IDE disk\"",
            "16"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_typename",
            "\"ST506/MFM/RLL\"",
            "16"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "lp",
            "sizeof(struct disklabel)"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdgetdefaultlabel\\n\")",
            "DEBUG_FUNCS"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_FUNCS  0x08\n\nvoid  wdgetdefaultlabel;\n\nvoid\nwdgetdefaultlabel(wd, lp)\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n{\n\tWDCDEBUG_PRINT((\"wdgetdefaultlabel\\n\"), DEBUG_FUNCS);\n\tbzero(lp, sizeof(struct disklabel));\n\n\tlp->d_secsize = DEV_BSIZE;\n\tlp->d_ntracks = wd->sc_params.atap_heads;\n\tlp->d_nsectors = wd->sc_params.atap_sectors;\n\tlp->d_ncylinders = wd->sc_params.atap_cylinders;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (wd->drvp->ata_vers == -1) {\n\t\tlp->d_type = DTYPE_ST506;\n\t\tstrncpy(lp->d_typename, \"ST506/MFM/RLL\", 16);\n\t} else {\n\t\tlp->d_type = DTYPE_ESDI;\n\t\tstrncpy(lp->d_typename, \"ESDI/IDE disk\", 16);\n\t}\n\t/* XXX - user viscopy() like sd.c */\n\tstrncpy(lp->d_packname, wd->sc_params.atap_model, 16);\n\tlp->d_secperunit = wd->sc_capacity;\n\tlp->d_rpm = 3600;\n\tlp->d_interleave = 1;\n\tlp->d_flags = 0;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\tlp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n}"
  },
  {
    "function_name": "wdclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "791-833",
    "snippet": "int\nwdclose(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tstruct wd_softc *wd;\n\tint part = WDPART(dev);\n\tint error = 0;\n\n\twd = wdlookup(WDUNIT(dev));\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\t\n\tWDCDEBUG_PRINT((\"wdclose\\n\"), DEBUG_FUNCS);\n\tif ((error = wdlock(wd)) != 0)\n\t\tgoto exit;\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\twd->sc_dk.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\twd->sc_dk.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\twd->sc_dk.dk_openmask =\n\t    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;\n\n\tif (wd->sc_dk.dk_openmask == 0) {\n\t\twd_flushcache(wd,0);\n\t\t/* XXXX Must wait for I/O to complete! */\n#ifndef __OpenBSD__\n\t\twdc_ata_delref(wd->drvp);\n#endif\n\t}\n\n\twdunlock(wd);\n\n exit:\n\tdevice_unref(&wd->sc_dev);\n\treturn (error);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [
      "void  wd_flushcache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_unref",
          "args": [
            "&wd->sc_dev"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdunlock",
          "args": [
            "wd"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_ata_delref",
          "args": [
            "wd->drvp"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_delref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "772-779",
          "snippet": "void\nwdc_ata_delref(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\twdc_delref(chp);\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_ata_delref(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\twdc_delref(chp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wd_flushcache",
          "args": [
            "wd",
            "0"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "wd_flushcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "1368-1400",
          "snippet": "void\nwd_flushcache(wd, flags)\n\tstruct wd_softc *wd;\n\tint flags;\n{\n\tstruct wdc_command wdc_c;\n\n\tif (wd->drvp->ata_vers < 4) /* WDCC_FLUSHCACHE is here since ATA-4 */\n\t\treturn;\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\twdc_c.r_command = WDCC_FLUSHCACHE;\n\twdc_c.r_st_bmask = WDCS_DRDY;\n\twdc_c.r_st_pmask = WDCS_DRDY;\n\twdc_c.flags = flags | AT_WAIT;\n\twdc_c.timeout = 30000; /* 30s timeout */\n\tif (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {\n\t\tprintf(\"%s: flush cache command didn't complete\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_TIMEOU) {\n\t\tprintf(\"%s: flush cache command timeout\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_DF) {\n\t\tprintf(\"%s: flush cache command: drive fault\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\t/*\n\t * Ignore error register, it shouldn't report anything else\n\t * than COMMAND ABORTED, which means the device doesn't support\n\t * flush cache\n\t */\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void  wd_flushcache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nvoid  wd_flushcache;\n\nvoid\nwd_flushcache(wd, flags)\n\tstruct wd_softc *wd;\n\tint flags;\n{\n\tstruct wdc_command wdc_c;\n\n\tif (wd->drvp->ata_vers < 4) /* WDCC_FLUSHCACHE is here since ATA-4 */\n\t\treturn;\n\tbzero(&wdc_c, sizeof(struct wdc_command));\n\twdc_c.r_command = WDCC_FLUSHCACHE;\n\twdc_c.r_st_bmask = WDCS_DRDY;\n\twdc_c.r_st_pmask = WDCS_DRDY;\n\twdc_c.flags = flags | AT_WAIT;\n\twdc_c.timeout = 30000; /* 30s timeout */\n\tif (wdc_exec_command(wd->drvp, &wdc_c) != WDC_COMPLETE) {\n\t\tprintf(\"%s: flush cache command didn't complete\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_TIMEOU) {\n\t\tprintf(\"%s: flush cache command timeout\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\tif (wdc_c.flags & AT_DF) {\n\t\tprintf(\"%s: flush cache command: drive fault\\n\",\n\t\t    wd->sc_dev.dv_xname);\n\t}\n\t/*\n\t * Ignore error register, it shouldn't report anything else\n\t * than COMMAND ABORTED, which means the device doesn't support\n\t * flush cache\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdlock",
          "args": [
            "wd"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdclose\\n\")",
            "DEBUG_FUNCS"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdlookup",
          "args": [
            "WDUNIT(dev)"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDUNIT",
          "args": [
            "dev"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDPART",
          "args": [
            "dev"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_FUNCS  0x08\n\nvoid  wd_flushcache;\n\nint\nwdclose(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tstruct wd_softc *wd;\n\tint part = WDPART(dev);\n\tint error = 0;\n\n\twd = wdlookup(WDUNIT(dev));\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\t\n\tWDCDEBUG_PRINT((\"wdclose\\n\"), DEBUG_FUNCS);\n\tif ((error = wdlock(wd)) != 0)\n\t\tgoto exit;\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\twd->sc_dk.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\twd->sc_dk.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\twd->sc_dk.dk_openmask =\n\t    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;\n\n\tif (wd->sc_dk.dk_openmask == 0) {\n\t\twd_flushcache(wd,0);\n\t\t/* XXXX Must wait for I/O to complete! */\n#ifndef __OpenBSD__\n\t\twdc_ata_delref(wd->drvp);\n#endif\n\t}\n\n\twdunlock(wd);\n\n exit:\n\tdevice_unref(&wd->sc_dev);\n\treturn (error);\n}"
  },
  {
    "function_name": "wdopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "698-789",
    "snippet": "int\nwdopen(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tstruct wd_softc *wd;\n\tint unit, part;\n\tint error;\n\n\tWDCDEBUG_PRINT((\"wdopen\\n\"), DEBUG_FUNCS);\n\n\tunit = WDUNIT(dev);\n\twd = wdlookup(unit);\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\n\t/*\n\t * If this is the first open of this device, add a reference\n\t * to the adapter.\n\t */\n#ifndef __OpenBSD__\n\tif (wd->sc_dk.dk_openmask == 0 &&\n\t    (error = wdc_ata_addref(wd->drvp)) != 0)\n\t\treturn (error);\n#endif\n\n\tif ((error = wdlock(wd)) != 0)\n\t\tgoto bad4;\n\n\tif (wd->sc_dk.dk_openmask != 0) {\n\t\t/*\n\t\t * If any partition is open, but the disk has been invalidated,\n\t\t * disallow further opens.\n\t\t */\n\t\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\t\terror = EIO;\n\t\t\tgoto bad3;\n\t\t}\n\t} else {\n\t\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\t\twd->sc_flags |= WDF_LOADED;\n\n\t\t\t/* Load the physical device parameters. */\n\t\t\twd_get_params(wd, AT_WAIT, &wd->sc_params);\n\n\t\t\t/* Load the partition info if not already loaded. */\n\t\t\twdgetdisklabel(dev, wd, wd->sc_dk.dk_label,\n\t\t\t\t       wd->sc_dk.dk_cpulabel, 0);\n\t\t}\n\t}\n\n\tpart = WDPART(dev);\n\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART &&\n\t    (part >= wd->sc_dk.dk_label->d_npartitions ||\n\t     wd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {\n\t\terror = ENXIO;\n\t\tgoto bad;\n\t}\n\t\n\t/* Insure only one open at a time. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\twd->sc_dk.dk_copenmask |= (1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\twd->sc_dk.dk_bopenmask |= (1 << part);\n\t\tbreak;\n\t}\n\twd->sc_dk.dk_openmask =\n\t    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;\n\n\twdunlock(wd);\n\tdevice_unref(&wd->sc_dev);\n\treturn 0;\n\nbad:\n\tif (wd->sc_dk.dk_openmask == 0) {\n\t}\n\nbad3:\n\twdunlock(wd);\nbad4:\n#ifndef __OpenBSD__\n\tif (wd->sc_dk.dk_openmask == 0)\n\t\twdc_ata_delref(wd->drvp);\n#endif\n\tdevice_unref(&wd->sc_dev);\n\treturn error;\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define WDF_LOADED\t  0x10 /* parameters loaded */",
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [
      "void  wdgetdisklabel",
      "int   wd_get_params"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_unref",
          "args": [
            "&wd->sc_dev"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_ata_delref",
          "args": [
            "wd->drvp"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_delref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "772-779",
          "snippet": "void\nwdc_ata_delref(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\twdc_delref(chp);\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_ata_delref(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\twdc_delref(chp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdunlock",
          "args": [
            "wd"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_unref",
          "args": [
            "&wd->sc_dev"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdunlock",
          "args": [
            "wd"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDPART",
          "args": [
            "dev"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdgetdisklabel",
          "args": [
            "dev",
            "wd",
            "wd->sc_dk.dk_label",
            "wd->sc_dk.dk_cpulabel",
            "0"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "wdgetdisklabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "876-921",
          "snippet": "void\nwdgetdisklabel(dev, wd, lp, clp, spoofonly)\n\tdev_t  dev;\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\n\tWDCDEBUG_PRINT((\"wdgetdisklabel\\n\"), DEBUG_FUNCS);\n\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\twdgetdefaultlabel(wd, lp);\n\n\twd->sc_badsect[0] = -1;\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\terrstring = readdisklabel(WDLABELDEV(dev),\n\t    wdstrategy, lp, clp, spoofonly);\n\tif (errstring) {\n\t\t/*\n\t\t * This probably happened because the drive's default\n\t\t * geometry doesn't match the DOS geometry.  We\n\t\t * assume the DOS geometry is now in the label and try\n\t\t * again.  XXX This is a kluge.\n\t\t */\n\t\tif (wd->drvp->state > RECAL)\n\t\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\t\terrstring = readdisklabel(WDLABELDEV(dev),\n\t\t    wdstrategy, lp, clp, spoofonly);\n\t}\n\tif (errstring) {\n\t\tprintf(\"%s: %s\\n\", wd->sc_dev.dv_xname, errstring);\n\t\treturn;\n\t}\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n#ifdef DKBAD\n\tif ((lp->d_flags & D_BADSECT) != 0)\n\t\tbad144intern(wd);\n#endif\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define sc_badsect sc_wdc_bio.badsect",
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  wdgetdefaultlabel",
            "void  wdgetdisklabel",
            "void  wdstrategy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_badsect sc_wdc_bio.badsect\n#define DEBUG_FUNCS  0x08\n\nvoid  wdgetdefaultlabel;\nvoid  wdgetdisklabel;\nvoid  wdstrategy;\n\nvoid\nwdgetdisklabel(dev, wd, lp, clp, spoofonly)\n\tdev_t  dev;\n\tstruct wd_softc *wd;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\n\tWDCDEBUG_PRINT((\"wdgetdisklabel\\n\"), DEBUG_FUNCS);\n\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\twdgetdefaultlabel(wd, lp);\n\n\twd->sc_badsect[0] = -1;\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\terrstring = readdisklabel(WDLABELDEV(dev),\n\t    wdstrategy, lp, clp, spoofonly);\n\tif (errstring) {\n\t\t/*\n\t\t * This probably happened because the drive's default\n\t\t * geometry doesn't match the DOS geometry.  We\n\t\t * assume the DOS geometry is now in the label and try\n\t\t * again.  XXX This is a kluge.\n\t\t */\n\t\tif (wd->drvp->state > RECAL)\n\t\t\twd->drvp->drive_flags |= DRIVE_RESET;\n\t\terrstring = readdisklabel(WDLABELDEV(dev),\n\t\t    wdstrategy, lp, clp, spoofonly);\n\t}\n\tif (errstring) {\n\t\tprintf(\"%s: %s\\n\", wd->sc_dev.dv_xname, errstring);\n\t\treturn;\n\t}\n\n\tif (wd->drvp->state > RECAL)\n\t\twd->drvp->drive_flags |= DRIVE_RESET;\n#ifdef DKBAD\n\tif ((lp->d_flags & D_BADSECT) != 0)\n\t\tbad144intern(wd);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "wd_get_params",
          "args": [
            "wd",
            "AT_WAIT",
            "&wd->sc_params"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "wd_get_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "1335-1366",
          "snippet": "int\nwd_get_params(wd, flags, params)\n\tstruct wd_softc *wd;\n\tu_int8_t flags;\n\tstruct ataparams *params;\n{\n\tswitch (ata_get_params(wd->drvp, flags, params)) {\n\tcase CMD_AGAIN:\n\t\treturn 1;\n\tcase CMD_ERR:\n\t\t/*\n\t\t * We `know' there's a drive here; just assume it's old.\n\t\t * This geometry is only used to read the MBR and print a\n\t\t * (false) attach message.\n\t\t */\n\t\tstrncpy(params->atap_model, \"ST506\",\n\t\t    sizeof params->atap_model);\n\t\tparams->atap_config = ATA_CFG_FIXED;\n\t\tparams->atap_cylinders = 1024;\n\t\tparams->atap_heads = 8;\n\t\tparams->atap_sectors = 17;\n\t\tparams->atap_multi = 1;\n\t\tparams->atap_capabilities1 = params->atap_capabilities2 = 0;\n\t\twd->drvp->ata_vers = -1; /* Mark it as pre-ATA */\n\t\treturn 0;\n\tcase CMD_OK:\n\t\treturn 0;\n\tdefault:\n\t\tpanic(\"wd_get_params: bad return code from ata_get_params\");\n\t\t/* NOTREACHED */\n\t}\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int   wd_get_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nint   wd_get_params;\n\nint\nwd_get_params(wd, flags, params)\n\tstruct wd_softc *wd;\n\tu_int8_t flags;\n\tstruct ataparams *params;\n{\n\tswitch (ata_get_params(wd->drvp, flags, params)) {\n\tcase CMD_AGAIN:\n\t\treturn 1;\n\tcase CMD_ERR:\n\t\t/*\n\t\t * We `know' there's a drive here; just assume it's old.\n\t\t * This geometry is only used to read the MBR and print a\n\t\t * (false) attach message.\n\t\t */\n\t\tstrncpy(params->atap_model, \"ST506\",\n\t\t    sizeof params->atap_model);\n\t\tparams->atap_config = ATA_CFG_FIXED;\n\t\tparams->atap_cylinders = 1024;\n\t\tparams->atap_heads = 8;\n\t\tparams->atap_sectors = 17;\n\t\tparams->atap_multi = 1;\n\t\tparams->atap_capabilities1 = params->atap_capabilities2 = 0;\n\t\twd->drvp->ata_vers = -1; /* Mark it as pre-ATA */\n\t\treturn 0;\n\tcase CMD_OK:\n\t\treturn 0;\n\tdefault:\n\t\tpanic(\"wd_get_params: bad return code from ata_get_params\");\n\t\t/* NOTREACHED */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdlock",
          "args": [
            "wd"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_ata_addref",
          "args": [
            "wd->drvp"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_addref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "763-770",
          "snippet": "int\nwdc_ata_addref(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\treturn (wdc_addref(chp));\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwdc_ata_addref(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\treturn (wdc_addref(chp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdlookup",
          "args": [
            "unit"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDUNIT",
          "args": [
            "dev"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdopen\\n\")",
            "DEBUG_FUNCS"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define WDF_LOADED\t  0x10 /* parameters loaded */\n#define DEBUG_FUNCS  0x08\n\nvoid  wdgetdisklabel;\nint   wd_get_params;\n\nint\nwdopen(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tstruct wd_softc *wd;\n\tint unit, part;\n\tint error;\n\n\tWDCDEBUG_PRINT((\"wdopen\\n\"), DEBUG_FUNCS);\n\n\tunit = WDUNIT(dev);\n\twd = wdlookup(unit);\n\tif (wd == NULL)\n\t\treturn ENXIO;\n\n\t/*\n\t * If this is the first open of this device, add a reference\n\t * to the adapter.\n\t */\n#ifndef __OpenBSD__\n\tif (wd->sc_dk.dk_openmask == 0 &&\n\t    (error = wdc_ata_addref(wd->drvp)) != 0)\n\t\treturn (error);\n#endif\n\n\tif ((error = wdlock(wd)) != 0)\n\t\tgoto bad4;\n\n\tif (wd->sc_dk.dk_openmask != 0) {\n\t\t/*\n\t\t * If any partition is open, but the disk has been invalidated,\n\t\t * disallow further opens.\n\t\t */\n\t\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\t\terror = EIO;\n\t\t\tgoto bad3;\n\t\t}\n\t} else {\n\t\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\t\twd->sc_flags |= WDF_LOADED;\n\n\t\t\t/* Load the physical device parameters. */\n\t\t\twd_get_params(wd, AT_WAIT, &wd->sc_params);\n\n\t\t\t/* Load the partition info if not already loaded. */\n\t\t\twdgetdisklabel(dev, wd, wd->sc_dk.dk_label,\n\t\t\t\t       wd->sc_dk.dk_cpulabel, 0);\n\t\t}\n\t}\n\n\tpart = WDPART(dev);\n\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART &&\n\t    (part >= wd->sc_dk.dk_label->d_npartitions ||\n\t     wd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {\n\t\terror = ENXIO;\n\t\tgoto bad;\n\t}\n\t\n\t/* Insure only one open at a time. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\twd->sc_dk.dk_copenmask |= (1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\twd->sc_dk.dk_bopenmask |= (1 << part);\n\t\tbreak;\n\t}\n\twd->sc_dk.dk_openmask =\n\t    wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;\n\n\twdunlock(wd);\n\tdevice_unref(&wd->sc_dev);\n\treturn 0;\n\nbad:\n\tif (wd->sc_dk.dk_openmask == 0) {\n\t}\n\nbad3:\n\twdunlock(wd);\nbad4:\n#ifndef __OpenBSD__\n\tif (wd->sc_dk.dk_openmask == 0)\n\t\twdc_ata_delref(wd->drvp);\n#endif\n\tdevice_unref(&wd->sc_dev);\n\treturn error;\n}"
  },
  {
    "function_name": "wdwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "687-696",
    "snippet": "int\nwdwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\tWDCDEBUG_PRINT((\"wdwrite\\n\"), DEBUG_XFERS);\n\treturn (physio(wdstrategy, NULL, dev, B_WRITE, minphys, uio));\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void  wdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "wdstrategy",
            "NULL",
            "dev",
            "B_WRITE",
            "minphys",
            "uio"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdwrite\\n\")",
            "DEBUG_XFERS"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_XFERS  0x02\n\nvoid  wdstrategy;\n\nint\nwdwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\tWDCDEBUG_PRINT((\"wdwrite\\n\"), DEBUG_XFERS);\n\treturn (physio(wdstrategy, NULL, dev, B_WRITE, minphys, uio));\n}"
  },
  {
    "function_name": "wdread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "676-685",
    "snippet": "int\nwdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\tWDCDEBUG_PRINT((\"wdread\\n\"), DEBUG_XFERS);\n\treturn (physio(wdstrategy, NULL, dev, B_READ, minphys, uio));\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void  wdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "wdstrategy",
            "NULL",
            "dev",
            "B_READ",
            "minphys",
            "uio"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdread\\n\")",
            "DEBUG_XFERS"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_XFERS  0x02\n\nvoid  wdstrategy;\n\nint\nwdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\tWDCDEBUG_PRINT((\"wdread\\n\"), DEBUG_XFERS);\n\treturn (physio(wdstrategy, NULL, dev, B_READ, minphys, uio));\n}"
  },
  {
    "function_name": "wdrestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "661-674",
    "snippet": "void\nwdrestart(v)\n\tvoid *v;\n{\n\tstruct wd_softc *wd = v;\n\tstruct buf *bp = wd->sc_bp;\n\tint s;\n\tWDCDEBUG_PRINT((\"wdrestart %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\n\ts = splbio();\n\t__wdstart(v, bp);\n\tsplx(s);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void  __wdstart",
      "void  wdrestart",
      "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wdstart",
          "args": [
            "v",
            "bp"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "__wdstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "554-599",
          "snippet": "void\n__wdstart(wd, bp)\n\tstruct wd_softc *wd;\n\tstruct buf *bp;\n{\n\tdaddr_t p_offset;\n\tif (WDPART(bp->b_dev) != RAW_PART)\n\t\tp_offset =\n\t\t    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;\n\telse\n\t\tp_offset = 0;\n\twd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;\n\twd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\twd->sc_wdc_bio.blkdone =0;\n\twd->sc_bp = bp;\n\t/*\n\t * If we're retrying, retry in single-sector mode. This will give us\n\t * the sector number of the problem, and will eventually allow the\n\t * transfer to succeed.\n\t */\n\tif (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)\n\t\twd->sc_wdc_bio.flags = ATA_SINGLE;\n\telse\n\t\twd->sc_wdc_bio.flags = 0;\n\tif (wd->sc_flags & WDF_LBA)\n\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\tif (bp->b_flags & B_READ)\n\t\twd->sc_wdc_bio.flags |= ATA_READ;\n\twd->sc_wdc_bio.bcount = bp->b_bcount;\n\twd->sc_wdc_bio.databuf = bp->b_data;\n\twd->sc_wdc_bio.wd = wd;\n\t/* Instrumentation. */\n\tdisk_busy(&wd->sc_dk);\n\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\tcase WDC_TRY_AGAIN:\n\t\ttimeout(wdrestart, wd, hz);\n\t\tbreak;\n\tcase WDC_QUEUED:\n\t\tbreak;\n\tcase WDC_COMPLETE:\n\t\twddone(wd);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"__wdstart: bad return code from wdc_ata_bio()\");\n\t}\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define sc_multi sc_wdc_bio.multi",
            "#define WDF_LBA\t 0x40 /* using LBA mode */",
            "#define\tWDIORETRIES_SINGLE 4\t/* number of retries before single-sector */"
          ],
          "globals_used": [
            "void  __wdstart",
            "void  wdrestart",
            "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_multi sc_wdc_bio.multi\n#define WDF_LBA\t 0x40 /* using LBA mode */\n#define\tWDIORETRIES_SINGLE 4\t/* number of retries before single-sector */\n\nvoid  __wdstart;\nvoid  wdrestart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\n__wdstart(wd, bp)\n\tstruct wd_softc *wd;\n\tstruct buf *bp;\n{\n\tdaddr_t p_offset;\n\tif (WDPART(bp->b_dev) != RAW_PART)\n\t\tp_offset =\n\t\t    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;\n\telse\n\t\tp_offset = 0;\n\twd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;\n\twd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\twd->sc_wdc_bio.blkdone =0;\n\twd->sc_bp = bp;\n\t/*\n\t * If we're retrying, retry in single-sector mode. This will give us\n\t * the sector number of the problem, and will eventually allow the\n\t * transfer to succeed.\n\t */\n\tif (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)\n\t\twd->sc_wdc_bio.flags = ATA_SINGLE;\n\telse\n\t\twd->sc_wdc_bio.flags = 0;\n\tif (wd->sc_flags & WDF_LBA)\n\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\tif (bp->b_flags & B_READ)\n\t\twd->sc_wdc_bio.flags |= ATA_READ;\n\twd->sc_wdc_bio.bcount = bp->b_bcount;\n\twd->sc_wdc_bio.databuf = bp->b_data;\n\twd->sc_wdc_bio.wd = wd;\n\t/* Instrumentation. */\n\tdisk_busy(&wd->sc_dk);\n\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\tcase WDC_TRY_AGAIN:\n\t\ttimeout(wdrestart, wd, hz);\n\t\tbreak;\n\tcase WDC_QUEUED:\n\t\tbreak;\n\tcase WDC_COMPLETE:\n\t\twddone(wd);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"__wdstart: bad return code from wdc_ata_bio()\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdrestart %s\\n\", wd->sc_dev.dv_xname)",
            "DEBUG_XFERS"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_XFERS  0x02\n\nvoid  __wdstart;\nvoid  wdrestart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\nwdrestart(v)\n\tvoid *v;\n{\n\tstruct wd_softc *wd = v;\n\tstruct buf *bp = wd->sc_bp;\n\tint s;\n\tWDCDEBUG_PRINT((\"wdrestart %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\n\ts = splbio();\n\t__wdstart(v, bp);\n\tsplx(s);\n}"
  },
  {
    "function_name": "wddone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "601-659",
    "snippet": "void\nwddone(v)\n\tvoid *v;\n{\n\tstruct wd_softc *wd = v;\n\tstruct buf *bp = wd->sc_bp;\n\tchar buf[256], *errbuf = buf;\n\tWDCDEBUG_PRINT((\"wddone %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\n\tbp->b_resid = wd->sc_wdc_bio.bcount;\n\terrbuf[0] = '\\0';\n\tswitch (wd->sc_wdc_bio.error) {\n\tcase ERR_NODEV:\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = ENXIO;\n\t\tbreak;\n\tcase ERR_DMA:\n\t\terrbuf = \"DMA error\";\n\t\tgoto retry;\n\tcase ERR_DF:\n\t\terrbuf = \"device fault\";\n\t\tgoto retry;\n\tcase TIMEOUT:\n\t\terrbuf = \"device timeout\";\n\t\tgoto retry;\n\tcase ERROR:\n\t\t/* Don't care about media change bits */\n\t\tif (wd->sc_wdc_bio.r_error != 0 &&\n\t\t    (wd->sc_wdc_bio.r_error & ~(WDCE_MC | WDCE_MCR)) == 0)\n\t\t\tgoto noerror;\n\t\tata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);\nretry:\n\t\t/* Just reset and retry. Can we do more ? */\n\t\twdc_reset_channel(wd->drvp);\n\t\tdiskerr(bp, \"wd\", errbuf, LOG_PRINTF,\n\t\t    wd->sc_wdc_bio.blkdone, wd->sc_dk.dk_label);\n\t\tif (wd->retries++ < WDIORETRIES) {\n\t\t\tprintf(\", retrying\\n\");\n\t\t\ttimeout(wdrestart, wd, RECOVERYTIME);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tbreak;\n\tcase NOERROR:\nnoerror:\tif ((wd->sc_wdc_bio.flags & ATA_CORR) || wd->retries > 0)\n\t\t\tprintf(\"%s: soft error (corrected)\\n\",\n\t\t\t    wd->sc_dev.dv_xname);\n\t}\n\tdisk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));\n#if NRND > 0\n\trnd_add_uint32(&wd->rnd_source, bp->b_blkno);\n#endif\n\tbiodone(bp);\n\twd->openings++;\n\twdstart(wd);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02",
      "#define\tRECOVERYTIME hz/2\t/* time to wait before retrying a cmd */",
      "#define\tWDIORETRIES\t5\t/* number of retries before giving up */"
    ],
    "globals_used": [
      "void  wdstart",
      "void  wdrestart",
      "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdstart",
          "args": [
            "wd"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "__wdstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "554-599",
          "snippet": "void\n__wdstart(wd, bp)\n\tstruct wd_softc *wd;\n\tstruct buf *bp;\n{\n\tdaddr_t p_offset;\n\tif (WDPART(bp->b_dev) != RAW_PART)\n\t\tp_offset =\n\t\t    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;\n\telse\n\t\tp_offset = 0;\n\twd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;\n\twd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\twd->sc_wdc_bio.blkdone =0;\n\twd->sc_bp = bp;\n\t/*\n\t * If we're retrying, retry in single-sector mode. This will give us\n\t * the sector number of the problem, and will eventually allow the\n\t * transfer to succeed.\n\t */\n\tif (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)\n\t\twd->sc_wdc_bio.flags = ATA_SINGLE;\n\telse\n\t\twd->sc_wdc_bio.flags = 0;\n\tif (wd->sc_flags & WDF_LBA)\n\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\tif (bp->b_flags & B_READ)\n\t\twd->sc_wdc_bio.flags |= ATA_READ;\n\twd->sc_wdc_bio.bcount = bp->b_bcount;\n\twd->sc_wdc_bio.databuf = bp->b_data;\n\twd->sc_wdc_bio.wd = wd;\n\t/* Instrumentation. */\n\tdisk_busy(&wd->sc_dk);\n\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\tcase WDC_TRY_AGAIN:\n\t\ttimeout(wdrestart, wd, hz);\n\t\tbreak;\n\tcase WDC_QUEUED:\n\t\tbreak;\n\tcase WDC_COMPLETE:\n\t\twddone(wd);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"__wdstart: bad return code from wdc_ata_bio()\");\n\t}\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define sc_multi sc_wdc_bio.multi",
            "#define WDF_LBA\t 0x40 /* using LBA mode */",
            "#define\tWDIORETRIES_SINGLE 4\t/* number of retries before single-sector */"
          ],
          "globals_used": [
            "void  __wdstart",
            "void  wdrestart",
            "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_multi sc_wdc_bio.multi\n#define WDF_LBA\t 0x40 /* using LBA mode */\n#define\tWDIORETRIES_SINGLE 4\t/* number of retries before single-sector */\n\nvoid  __wdstart;\nvoid  wdrestart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\n__wdstart(wd, bp)\n\tstruct wd_softc *wd;\n\tstruct buf *bp;\n{\n\tdaddr_t p_offset;\n\tif (WDPART(bp->b_dev) != RAW_PART)\n\t\tp_offset =\n\t\t    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;\n\telse\n\t\tp_offset = 0;\n\twd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;\n\twd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\twd->sc_wdc_bio.blkdone =0;\n\twd->sc_bp = bp;\n\t/*\n\t * If we're retrying, retry in single-sector mode. This will give us\n\t * the sector number of the problem, and will eventually allow the\n\t * transfer to succeed.\n\t */\n\tif (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)\n\t\twd->sc_wdc_bio.flags = ATA_SINGLE;\n\telse\n\t\twd->sc_wdc_bio.flags = 0;\n\tif (wd->sc_flags & WDF_LBA)\n\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\tif (bp->b_flags & B_READ)\n\t\twd->sc_wdc_bio.flags |= ATA_READ;\n\twd->sc_wdc_bio.bcount = bp->b_bcount;\n\twd->sc_wdc_bio.databuf = bp->b_data;\n\twd->sc_wdc_bio.wd = wd;\n\t/* Instrumentation. */\n\tdisk_busy(&wd->sc_dk);\n\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\tcase WDC_TRY_AGAIN:\n\t\ttimeout(wdrestart, wd, hz);\n\t\tbreak;\n\tcase WDC_QUEUED:\n\t\tbreak;\n\tcase WDC_COMPLETE:\n\t\twddone(wd);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"__wdstart: bad return code from wdc_ata_bio()\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rnd_add_uint32",
          "args": [
            "&wd->rnd_source",
            "bp->b_blkno"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unbusy",
          "args": [
            "&wd->sc_dk",
            "(bp->b_bcount - bp->b_resid)"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: soft error (corrected)\\n\"",
            "wd->sc_dev.dv_xname"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "wdrestart",
            "wd",
            "RECOVERYTIME"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diskerr",
          "args": [
            "bp",
            "\"wd\"",
            "errbuf",
            "LOG_PRINTF",
            "wd->sc_wdc_bio.blkdone",
            "wd->sc_dk.dk_label"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_reset_channel",
          "args": [
            "wd->drvp"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_reset_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "774-786",
          "snippet": "void wdc_reset_channel(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tint drive;\n\tWDCDEBUG_PRINT((\"ata_reset_channel %s:%d for drive %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\t(void) wdcreset(chp, VERBOSE);\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tchp->ch_drive[drive].state = 0;\n\t}\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid wdc_reset_channel(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tint drive;\n\tWDCDEBUG_PRINT((\"ata_reset_channel %s:%d for drive %d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),\n\t    DEBUG_FUNCS);\n\t(void) wdcreset(chp, VERBOSE);\n\tfor (drive = 0; drive < 2; drive++) {\n\t\tchp->ch_drive[drive].state = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ata_perror",
          "args": [
            "wd->drvp",
            "wd->sc_wdc_bio.r_error",
            "errbuf"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "ata_perror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata.c",
          "lines": "177-210",
          "snippet": "void\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <dev/ic/wdcreg.h>\n#include <sys/syslog.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nata_perror(drvp, errno, buf)\n\tstruct ata_drive_datas *drvp;\n\tint errno;\n\tchar *buf;\n{\n\tstatic char *errstr0_3[] = {\"address mark not found\",\n\t    \"track 0 not found\", \"aborted command\", \"media change requested\",\n\t    \"id not found\", \"media changed\", \"uncorrectable data error\",\n\t    \"bad block detected\"};\n\tstatic char *errstr4_5[] = {\"\",\n\t    \"no media/write protected\", \"aborted command\",\n\t    \"media change requested\", \"id not found\", \"media changed\",\n\t    \"uncorrectable data error\", \"interface CRC error\"};\n\tchar **errstr;\n\tint i;\n\tchar *sep = \"\";\n\n\tif (drvp->ata_vers >= 4)\n\t\terrstr = errstr4_5;\n\telse\n\t\terrstr = errstr0_3;\n\n\tif (errno == 0) {\n\t\tsprintf(buf, \"error not notified\");\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (errno & (1 << i)) {\n\t\t\tbuf += sprintf(buf, \"%s %s\", sep, errstr[i]);\n\t\t\tsep = \",\";\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wddone %s\\n\", wd->sc_dev.dv_xname)",
            "DEBUG_XFERS"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_XFERS  0x02\n#define\tRECOVERYTIME hz/2\t/* time to wait before retrying a cmd */\n#define\tWDIORETRIES\t5\t/* number of retries before giving up */\n\nvoid  wdstart;\nvoid  wdrestart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\nwddone(v)\n\tvoid *v;\n{\n\tstruct wd_softc *wd = v;\n\tstruct buf *bp = wd->sc_bp;\n\tchar buf[256], *errbuf = buf;\n\tWDCDEBUG_PRINT((\"wddone %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\n\tbp->b_resid = wd->sc_wdc_bio.bcount;\n\terrbuf[0] = '\\0';\n\tswitch (wd->sc_wdc_bio.error) {\n\tcase ERR_NODEV:\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = ENXIO;\n\t\tbreak;\n\tcase ERR_DMA:\n\t\terrbuf = \"DMA error\";\n\t\tgoto retry;\n\tcase ERR_DF:\n\t\terrbuf = \"device fault\";\n\t\tgoto retry;\n\tcase TIMEOUT:\n\t\terrbuf = \"device timeout\";\n\t\tgoto retry;\n\tcase ERROR:\n\t\t/* Don't care about media change bits */\n\t\tif (wd->sc_wdc_bio.r_error != 0 &&\n\t\t    (wd->sc_wdc_bio.r_error & ~(WDCE_MC | WDCE_MCR)) == 0)\n\t\t\tgoto noerror;\n\t\tata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);\nretry:\n\t\t/* Just reset and retry. Can we do more ? */\n\t\twdc_reset_channel(wd->drvp);\n\t\tdiskerr(bp, \"wd\", errbuf, LOG_PRINTF,\n\t\t    wd->sc_wdc_bio.blkdone, wd->sc_dk.dk_label);\n\t\tif (wd->retries++ < WDIORETRIES) {\n\t\t\tprintf(\", retrying\\n\");\n\t\t\ttimeout(wdrestart, wd, RECOVERYTIME);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tbreak;\n\tcase NOERROR:\nnoerror:\tif ((wd->sc_wdc_bio.flags & ATA_CORR) || wd->retries > 0)\n\t\t\tprintf(\"%s: soft error (corrected)\\n\",\n\t\t\t    wd->sc_dev.dv_xname);\n\t}\n\tdisk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));\n#if NRND > 0\n\trnd_add_uint32(&wd->rnd_source, bp->b_blkno);\n#endif\n\tbiodone(bp);\n\twd->openings++;\n\twdstart(wd);\n}"
  },
  {
    "function_name": "__wdstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "554-599",
    "snippet": "void\n__wdstart(wd, bp)\n\tstruct wd_softc *wd;\n\tstruct buf *bp;\n{\n\tdaddr_t p_offset;\n\tif (WDPART(bp->b_dev) != RAW_PART)\n\t\tp_offset =\n\t\t    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;\n\telse\n\t\tp_offset = 0;\n\twd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;\n\twd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\twd->sc_wdc_bio.blkdone =0;\n\twd->sc_bp = bp;\n\t/*\n\t * If we're retrying, retry in single-sector mode. This will give us\n\t * the sector number of the problem, and will eventually allow the\n\t * transfer to succeed.\n\t */\n\tif (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)\n\t\twd->sc_wdc_bio.flags = ATA_SINGLE;\n\telse\n\t\twd->sc_wdc_bio.flags = 0;\n\tif (wd->sc_flags & WDF_LBA)\n\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\tif (bp->b_flags & B_READ)\n\t\twd->sc_wdc_bio.flags |= ATA_READ;\n\twd->sc_wdc_bio.bcount = bp->b_bcount;\n\twd->sc_wdc_bio.databuf = bp->b_data;\n\twd->sc_wdc_bio.wd = wd;\n\t/* Instrumentation. */\n\tdisk_busy(&wd->sc_dk);\n\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\tcase WDC_TRY_AGAIN:\n\t\ttimeout(wdrestart, wd, hz);\n\t\tbreak;\n\tcase WDC_QUEUED:\n\t\tbreak;\n\tcase WDC_COMPLETE:\n\t\twddone(wd);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"__wdstart: bad return code from wdc_ata_bio()\");\n\t}\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define sc_multi sc_wdc_bio.multi",
      "#define WDF_LBA\t 0x40 /* using LBA mode */",
      "#define\tWDIORETRIES_SINGLE 4\t/* number of retries before single-sector */"
    ],
    "globals_used": [
      "void  __wdstart",
      "void  wdrestart",
      "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"__wdstart: bad return code from wdc_ata_bio()\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wddone",
          "args": [
            "wd"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "wddone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "601-659",
          "snippet": "void\nwddone(v)\n\tvoid *v;\n{\n\tstruct wd_softc *wd = v;\n\tstruct buf *bp = wd->sc_bp;\n\tchar buf[256], *errbuf = buf;\n\tWDCDEBUG_PRINT((\"wddone %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\n\tbp->b_resid = wd->sc_wdc_bio.bcount;\n\terrbuf[0] = '\\0';\n\tswitch (wd->sc_wdc_bio.error) {\n\tcase ERR_NODEV:\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = ENXIO;\n\t\tbreak;\n\tcase ERR_DMA:\n\t\terrbuf = \"DMA error\";\n\t\tgoto retry;\n\tcase ERR_DF:\n\t\terrbuf = \"device fault\";\n\t\tgoto retry;\n\tcase TIMEOUT:\n\t\terrbuf = \"device timeout\";\n\t\tgoto retry;\n\tcase ERROR:\n\t\t/* Don't care about media change bits */\n\t\tif (wd->sc_wdc_bio.r_error != 0 &&\n\t\t    (wd->sc_wdc_bio.r_error & ~(WDCE_MC | WDCE_MCR)) == 0)\n\t\t\tgoto noerror;\n\t\tata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);\nretry:\n\t\t/* Just reset and retry. Can we do more ? */\n\t\twdc_reset_channel(wd->drvp);\n\t\tdiskerr(bp, \"wd\", errbuf, LOG_PRINTF,\n\t\t    wd->sc_wdc_bio.blkdone, wd->sc_dk.dk_label);\n\t\tif (wd->retries++ < WDIORETRIES) {\n\t\t\tprintf(\", retrying\\n\");\n\t\t\ttimeout(wdrestart, wd, RECOVERYTIME);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tbreak;\n\tcase NOERROR:\nnoerror:\tif ((wd->sc_wdc_bio.flags & ATA_CORR) || wd->retries > 0)\n\t\t\tprintf(\"%s: soft error (corrected)\\n\",\n\t\t\t    wd->sc_dev.dv_xname);\n\t}\n\tdisk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));\n#if NRND > 0\n\trnd_add_uint32(&wd->rnd_source, bp->b_blkno);\n#endif\n\tbiodone(bp);\n\twd->openings++;\n\twdstart(wd);\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02",
            "#define\tRECOVERYTIME hz/2\t/* time to wait before retrying a cmd */",
            "#define\tWDIORETRIES\t5\t/* number of retries before giving up */"
          ],
          "globals_used": [
            "void  wdstart",
            "void  wdrestart",
            "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_XFERS  0x02\n#define\tRECOVERYTIME hz/2\t/* time to wait before retrying a cmd */\n#define\tWDIORETRIES\t5\t/* number of retries before giving up */\n\nvoid  wdstart;\nvoid  wdrestart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\nwddone(v)\n\tvoid *v;\n{\n\tstruct wd_softc *wd = v;\n\tstruct buf *bp = wd->sc_bp;\n\tchar buf[256], *errbuf = buf;\n\tWDCDEBUG_PRINT((\"wddone %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\n\tbp->b_resid = wd->sc_wdc_bio.bcount;\n\terrbuf[0] = '\\0';\n\tswitch (wd->sc_wdc_bio.error) {\n\tcase ERR_NODEV:\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = ENXIO;\n\t\tbreak;\n\tcase ERR_DMA:\n\t\terrbuf = \"DMA error\";\n\t\tgoto retry;\n\tcase ERR_DF:\n\t\terrbuf = \"device fault\";\n\t\tgoto retry;\n\tcase TIMEOUT:\n\t\terrbuf = \"device timeout\";\n\t\tgoto retry;\n\tcase ERROR:\n\t\t/* Don't care about media change bits */\n\t\tif (wd->sc_wdc_bio.r_error != 0 &&\n\t\t    (wd->sc_wdc_bio.r_error & ~(WDCE_MC | WDCE_MCR)) == 0)\n\t\t\tgoto noerror;\n\t\tata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);\nretry:\n\t\t/* Just reset and retry. Can we do more ? */\n\t\twdc_reset_channel(wd->drvp);\n\t\tdiskerr(bp, \"wd\", errbuf, LOG_PRINTF,\n\t\t    wd->sc_wdc_bio.blkdone, wd->sc_dk.dk_label);\n\t\tif (wd->retries++ < WDIORETRIES) {\n\t\t\tprintf(\", retrying\\n\");\n\t\t\ttimeout(wdrestart, wd, RECOVERYTIME);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tbreak;\n\tcase NOERROR:\nnoerror:\tif ((wd->sc_wdc_bio.flags & ATA_CORR) || wd->retries > 0)\n\t\t\tprintf(\"%s: soft error (corrected)\\n\",\n\t\t\t    wd->sc_dev.dv_xname);\n\t}\n\tdisk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));\n#if NRND > 0\n\trnd_add_uint32(&wd->rnd_source, bp->b_blkno);\n#endif\n\tbiodone(bp);\n\twd->openings++;\n\twdstart(wd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "wdrestart",
            "wd",
            "hz"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_ata_bio",
          "args": [
            "wd->drvp",
            "&wd->sc_wdc_bio"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_bio_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "533-568",
          "snippet": "void\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [
            "void  wdc_ata_bio_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid  wdc_ata_bio_done;\n\nvoid\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_busy",
          "args": [
            "&wd->sc_dk"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_multi sc_wdc_bio.multi\n#define WDF_LBA\t 0x40 /* using LBA mode */\n#define\tWDIORETRIES_SINGLE 4\t/* number of retries before single-sector */\n\nvoid  __wdstart;\nvoid  wdrestart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\n__wdstart(wd, bp)\n\tstruct wd_softc *wd;\n\tstruct buf *bp;\n{\n\tdaddr_t p_offset;\n\tif (WDPART(bp->b_dev) != RAW_PART)\n\t\tp_offset =\n\t\t    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;\n\telse\n\t\tp_offset = 0;\n\twd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;\n\twd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\twd->sc_wdc_bio.blkdone =0;\n\twd->sc_bp = bp;\n\t/*\n\t * If we're retrying, retry in single-sector mode. This will give us\n\t * the sector number of the problem, and will eventually allow the\n\t * transfer to succeed.\n\t */\n\tif (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)\n\t\twd->sc_wdc_bio.flags = ATA_SINGLE;\n\telse\n\t\twd->sc_wdc_bio.flags = 0;\n\tif (wd->sc_flags & WDF_LBA)\n\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\tif (bp->b_flags & B_READ)\n\t\twd->sc_wdc_bio.flags |= ATA_READ;\n\twd->sc_wdc_bio.bcount = bp->b_bcount;\n\twd->sc_wdc_bio.databuf = bp->b_data;\n\twd->sc_wdc_bio.wd = wd;\n\t/* Instrumentation. */\n\tdisk_busy(&wd->sc_dk);\n\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\tcase WDC_TRY_AGAIN:\n\t\ttimeout(wdrestart, wd, hz);\n\t\tbreak;\n\tcase WDC_QUEUED:\n\t\tbreak;\n\tcase WDC_COMPLETE:\n\t\twddone(wd);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"__wdstart: bad return code from wdc_ata_bio()\");\n\t}\n}"
  },
  {
    "function_name": "wdstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "527-552",
    "snippet": "void\nwdstart(arg)\n\tvoid *arg;\n{\n\tstruct wd_softc *wd = arg;\n\tstruct buf *dp, *bp=0;\n\n\tWDCDEBUG_PRINT((\"wdstart %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\twhile (wd->openings > 0) {\n\n\t\t/* Is there a buf for us ? */\n\t\tdp = &wd->sc_q;\n\t\tif ((bp = dp->b_actf) == NULL)  /* yes, an assign */\n\t\t\t return;\n\t\tdp->b_actf = bp->b_actf;\n\t\n\t\t/* \n\t\t * Make the command. First lock the device\n\t\t */\n\t\twd->openings--;\n\n\t\twd->retries = 0;\n\t\t__wdstart(wd, bp);\n\t}\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void  wdstart",
      "void  __wdstart",
      "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wdstart",
          "args": [
            "wd",
            "bp"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "__wdstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "554-599",
          "snippet": "void\n__wdstart(wd, bp)\n\tstruct wd_softc *wd;\n\tstruct buf *bp;\n{\n\tdaddr_t p_offset;\n\tif (WDPART(bp->b_dev) != RAW_PART)\n\t\tp_offset =\n\t\t    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;\n\telse\n\t\tp_offset = 0;\n\twd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;\n\twd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\twd->sc_wdc_bio.blkdone =0;\n\twd->sc_bp = bp;\n\t/*\n\t * If we're retrying, retry in single-sector mode. This will give us\n\t * the sector number of the problem, and will eventually allow the\n\t * transfer to succeed.\n\t */\n\tif (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)\n\t\twd->sc_wdc_bio.flags = ATA_SINGLE;\n\telse\n\t\twd->sc_wdc_bio.flags = 0;\n\tif (wd->sc_flags & WDF_LBA)\n\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\tif (bp->b_flags & B_READ)\n\t\twd->sc_wdc_bio.flags |= ATA_READ;\n\twd->sc_wdc_bio.bcount = bp->b_bcount;\n\twd->sc_wdc_bio.databuf = bp->b_data;\n\twd->sc_wdc_bio.wd = wd;\n\t/* Instrumentation. */\n\tdisk_busy(&wd->sc_dk);\n\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\tcase WDC_TRY_AGAIN:\n\t\ttimeout(wdrestart, wd, hz);\n\t\tbreak;\n\tcase WDC_QUEUED:\n\t\tbreak;\n\tcase WDC_COMPLETE:\n\t\twddone(wd);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"__wdstart: bad return code from wdc_ata_bio()\");\n\t}\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define sc_multi sc_wdc_bio.multi",
            "#define WDF_LBA\t 0x40 /* using LBA mode */",
            "#define\tWDIORETRIES_SINGLE 4\t/* number of retries before single-sector */"
          ],
          "globals_used": [
            "void  __wdstart",
            "void  wdrestart",
            "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_multi sc_wdc_bio.multi\n#define WDF_LBA\t 0x40 /* using LBA mode */\n#define\tWDIORETRIES_SINGLE 4\t/* number of retries before single-sector */\n\nvoid  __wdstart;\nvoid  wdrestart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\n__wdstart(wd, bp)\n\tstruct wd_softc *wd;\n\tstruct buf *bp;\n{\n\tdaddr_t p_offset;\n\tif (WDPART(bp->b_dev) != RAW_PART)\n\t\tp_offset =\n\t\t    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;\n\telse\n\t\tp_offset = 0;\n\twd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;\n\twd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\twd->sc_wdc_bio.blkdone =0;\n\twd->sc_bp = bp;\n\t/*\n\t * If we're retrying, retry in single-sector mode. This will give us\n\t * the sector number of the problem, and will eventually allow the\n\t * transfer to succeed.\n\t */\n\tif (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)\n\t\twd->sc_wdc_bio.flags = ATA_SINGLE;\n\telse\n\t\twd->sc_wdc_bio.flags = 0;\n\tif (wd->sc_flags & WDF_LBA)\n\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\tif (bp->b_flags & B_READ)\n\t\twd->sc_wdc_bio.flags |= ATA_READ;\n\twd->sc_wdc_bio.bcount = bp->b_bcount;\n\twd->sc_wdc_bio.databuf = bp->b_data;\n\twd->sc_wdc_bio.wd = wd;\n\t/* Instrumentation. */\n\tdisk_busy(&wd->sc_dk);\n\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\tcase WDC_TRY_AGAIN:\n\t\ttimeout(wdrestart, wd, hz);\n\t\tbreak;\n\tcase WDC_QUEUED:\n\t\tbreak;\n\tcase WDC_COMPLETE:\n\t\twddone(wd);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"__wdstart: bad return code from wdc_ata_bio()\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdstart %s\\n\", wd->sc_dev.dv_xname)",
            "DEBUG_XFERS"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_XFERS  0x02\n\nvoid  wdstart;\nvoid  __wdstart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\nwdstart(arg)\n\tvoid *arg;\n{\n\tstruct wd_softc *wd = arg;\n\tstruct buf *dp, *bp=0;\n\n\tWDCDEBUG_PRINT((\"wdstart %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\twhile (wd->openings > 0) {\n\n\t\t/* Is there a buf for us ? */\n\t\tdp = &wd->sc_q;\n\t\tif ((bp = dp->b_actf) == NULL)  /* yes, an assign */\n\t\t\t return;\n\t\tdp->b_actf = bp->b_actf;\n\t\n\t\t/* \n\t\t * Make the command. First lock the device\n\t\t */\n\t\twd->openings--;\n\n\t\twd->retries = 0;\n\t\t__wdstart(wd, bp);\n\t}\n}"
  },
  {
    "function_name": "wdstrategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "465-522",
    "snippet": "void\nwdstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct wd_softc *wd;\n\tint s;\n\n\twd = wdlookup(WDUNIT(bp->b_dev));\n\tif (wd == NULL) {\n\t\tbp->b_error = ENXIO;\n\t\tgoto bad;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdstrategy (%s)\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\t\n\t/* Valid request?  */\n\tif (bp->b_blkno < 0 ||\n\t    (bp->b_bcount % wd->sc_dk.dk_label->d_secsize) != 0 ||\n\t    (bp->b_bcount / wd->sc_dk.dk_label->d_secsize) >= (1 << NBBY)) {\n\t\tbp->b_error = EINVAL;\n\t\tgoto bad;\n\t}\n\t\n\t/* If device invalidated (e.g. media change, door open), error. */\n\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\tbp->b_error = EIO;\n\t\tgoto bad;\n\t}\n\n\t/* If it's a null transfer, return immediately. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\n\t/*\n\t * Do bounds checking, adjust transfer. if error, process.\n\t * If end of partition, just return.\n\t */\n\tif (WDPART(bp->b_dev) != RAW_PART &&\n\t    bounds_check_with_label(bp, wd->sc_dk.dk_label, wd->sc_dk.dk_cpulabel,\n\t    (wd->sc_flags & (WDF_WLABEL|WDF_LABELLING)) != 0) <= 0)\n\t\tgoto done;\n\t/* Queue transfer on drive, activate drive and controller if idle. */\n\ts = splbio();\n\tdisksort(&wd->sc_q, bp);\n\twdstart(wd);\n\tsplx(s);\n\tdevice_unref(&wd->sc_dev);\n\treturn;\nbad:\n\tbp->b_flags |= B_ERROR;\ndone:\n\t/* Toss transfer; we're done early. */\n\tbp->b_resid = bp->b_bcount;\n\tbiodone(bp);\n\tif (wd != NULL)\n\t\tdevice_unref(&wd->sc_dev);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define WDF_LOADED\t  0x10 /* parameters loaded */",
      "#define WDF_LABELLING   0x08 /* writing label */",
      "#define WDF_WLABEL\t  0x04 /* label is writable */",
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void  wdstrategy",
      "void  wdstart",
      "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_unref",
          "args": [
            "&wd->sc_dev"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_unref",
          "args": [
            "&wd->sc_dev"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdstart",
          "args": [
            "wd"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "__wdstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "554-599",
          "snippet": "void\n__wdstart(wd, bp)\n\tstruct wd_softc *wd;\n\tstruct buf *bp;\n{\n\tdaddr_t p_offset;\n\tif (WDPART(bp->b_dev) != RAW_PART)\n\t\tp_offset =\n\t\t    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;\n\telse\n\t\tp_offset = 0;\n\twd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;\n\twd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\twd->sc_wdc_bio.blkdone =0;\n\twd->sc_bp = bp;\n\t/*\n\t * If we're retrying, retry in single-sector mode. This will give us\n\t * the sector number of the problem, and will eventually allow the\n\t * transfer to succeed.\n\t */\n\tif (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)\n\t\twd->sc_wdc_bio.flags = ATA_SINGLE;\n\telse\n\t\twd->sc_wdc_bio.flags = 0;\n\tif (wd->sc_flags & WDF_LBA)\n\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\tif (bp->b_flags & B_READ)\n\t\twd->sc_wdc_bio.flags |= ATA_READ;\n\twd->sc_wdc_bio.bcount = bp->b_bcount;\n\twd->sc_wdc_bio.databuf = bp->b_data;\n\twd->sc_wdc_bio.wd = wd;\n\t/* Instrumentation. */\n\tdisk_busy(&wd->sc_dk);\n\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\tcase WDC_TRY_AGAIN:\n\t\ttimeout(wdrestart, wd, hz);\n\t\tbreak;\n\tcase WDC_QUEUED:\n\t\tbreak;\n\tcase WDC_COMPLETE:\n\t\twddone(wd);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"__wdstart: bad return code from wdc_ata_bio()\");\n\t}\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define sc_multi sc_wdc_bio.multi",
            "#define WDF_LBA\t 0x40 /* using LBA mode */",
            "#define\tWDIORETRIES_SINGLE 4\t/* number of retries before single-sector */"
          ],
          "globals_used": [
            "void  __wdstart",
            "void  wdrestart",
            "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_multi sc_wdc_bio.multi\n#define WDF_LBA\t 0x40 /* using LBA mode */\n#define\tWDIORETRIES_SINGLE 4\t/* number of retries before single-sector */\n\nvoid  __wdstart;\nvoid  wdrestart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\n__wdstart(wd, bp)\n\tstruct wd_softc *wd;\n\tstruct buf *bp;\n{\n\tdaddr_t p_offset;\n\tif (WDPART(bp->b_dev) != RAW_PART)\n\t\tp_offset =\n\t\t    wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;\n\telse\n\t\tp_offset = 0;\n\twd->sc_wdc_bio.blkno = bp->b_blkno + p_offset;\n\twd->sc_wdc_bio.blkno /= (wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);\n\twd->sc_wdc_bio.blkdone =0;\n\twd->sc_bp = bp;\n\t/*\n\t * If we're retrying, retry in single-sector mode. This will give us\n\t * the sector number of the problem, and will eventually allow the\n\t * transfer to succeed.\n\t */\n\tif (wd->sc_multi == 1 || wd->retries >= WDIORETRIES_SINGLE)\n\t\twd->sc_wdc_bio.flags = ATA_SINGLE;\n\telse\n\t\twd->sc_wdc_bio.flags = 0;\n\tif (wd->sc_flags & WDF_LBA)\n\t\twd->sc_wdc_bio.flags |= ATA_LBA;\n\tif (bp->b_flags & B_READ)\n\t\twd->sc_wdc_bio.flags |= ATA_READ;\n\twd->sc_wdc_bio.bcount = bp->b_bcount;\n\twd->sc_wdc_bio.databuf = bp->b_data;\n\twd->sc_wdc_bio.wd = wd;\n\t/* Instrumentation. */\n\tdisk_busy(&wd->sc_dk);\n\tswitch (wdc_ata_bio(wd->drvp, &wd->sc_wdc_bio)) {\n\tcase WDC_TRY_AGAIN:\n\t\ttimeout(wdrestart, wd, hz);\n\t\tbreak;\n\tcase WDC_QUEUED:\n\t\tbreak;\n\tcase WDC_COMPLETE:\n\t\twddone(wd);\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"__wdstart: bad return code from wdc_ata_bio()\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "disksort",
          "args": [
            "&wd->sc_q",
            "bp"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bounds_check_with_label",
          "args": [
            "bp",
            "wd->sc_dk.dk_label",
            "wd->sc_dk.dk_cpulabel",
            "(wd->sc_flags & (WDF_WLABEL|WDF_LABELLING)) != 0"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdstrategy (%s)\\n\", wd->sc_dev.dv_xname)",
            "DEBUG_XFERS"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdlookup",
          "args": [
            "WDUNIT(bp->b_dev)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDUNIT",
          "args": [
            "bp->b_dev"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define WDF_LOADED\t  0x10 /* parameters loaded */\n#define WDF_LABELLING   0x08 /* writing label */\n#define WDF_WLABEL\t  0x04 /* label is writable */\n#define DEBUG_XFERS  0x02\n\nvoid  wdstrategy;\nvoid  wdstart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\nwdstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct wd_softc *wd;\n\tint s;\n\n\twd = wdlookup(WDUNIT(bp->b_dev));\n\tif (wd == NULL) {\n\t\tbp->b_error = ENXIO;\n\t\tgoto bad;\n\t}\n\n\tWDCDEBUG_PRINT((\"wdstrategy (%s)\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\t\n\t/* Valid request?  */\n\tif (bp->b_blkno < 0 ||\n\t    (bp->b_bcount % wd->sc_dk.dk_label->d_secsize) != 0 ||\n\t    (bp->b_bcount / wd->sc_dk.dk_label->d_secsize) >= (1 << NBBY)) {\n\t\tbp->b_error = EINVAL;\n\t\tgoto bad;\n\t}\n\t\n\t/* If device invalidated (e.g. media change, door open), error. */\n\tif ((wd->sc_flags & WDF_LOADED) == 0) {\n\t\tbp->b_error = EIO;\n\t\tgoto bad;\n\t}\n\n\t/* If it's a null transfer, return immediately. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\n\t/*\n\t * Do bounds checking, adjust transfer. if error, process.\n\t * If end of partition, just return.\n\t */\n\tif (WDPART(bp->b_dev) != RAW_PART &&\n\t    bounds_check_with_label(bp, wd->sc_dk.dk_label, wd->sc_dk.dk_cpulabel,\n\t    (wd->sc_flags & (WDF_WLABEL|WDF_LABELLING)) != 0) <= 0)\n\t\tgoto done;\n\t/* Queue transfer on drive, activate drive and controller if idle. */\n\ts = splbio();\n\tdisksort(&wd->sc_q, bp);\n\twdstart(wd);\n\tsplx(s);\n\tdevice_unref(&wd->sc_dev);\n\treturn;\nbad:\n\tbp->b_flags |= B_ERROR;\ndone:\n\t/* Toss transfer; we're done early. */\n\tbp->b_resid = bp->b_bcount;\n\tbiodone(bp);\n\tif (wd != NULL)\n\t\tdevice_unref(&wd->sc_dev);\n}"
  },
  {
    "function_name": "wdzeroref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "451-459",
    "snippet": "void\nwdzeroref(self)\n        struct device *self;\n{\n        struct wd_softc *sc = (struct wd_softc *)self;\n\n        /* Detach disk. */\n        disk_detach(&sc->sc_dk);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void    wdzeroref"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disk_detach",
          "args": [
            "&sc->sc_dk"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nvoid    wdzeroref;\n\nvoid\nwdzeroref(self)\n        struct device *self;\n{\n        struct wd_softc *sc = (struct wd_softc *)self;\n\n        /* Detach disk. */\n        disk_detach(&sc->sc_dk);\n}"
  },
  {
    "function_name": "wddetach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "409-449",
    "snippet": "int\nwddetach(self, flags)\n        struct device *self;\n        int flags;\n{\n        struct wd_softc *sc = (struct wd_softc *)self;\n        struct buf *dp, *bp;\n        int s, bmaj, cmaj, mn;\n\n\t/* Remove unprocessed buffers from queue */\n\ts = splbio();\n\tfor (dp = &sc->sc_q; (bp = dp->b_actf) != NULL; ) {\n\t\tdp->b_actf = bp->b_actf;\n\t\t\n\t\tbp->b_error = ENXIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t}\n\tsplx(s);\n\n        /* locate the major number */\n        mn = WDMINOR(self->dv_unit, 0);\n\n        for (bmaj = 0; bmaj < nblkdev; bmaj++)\n                if (bdevsw[bmaj].d_open == wdopen)\n\t\t\tvdevgone(bmaj, mn, mn + MAXPARTITIONS - 1, VBLK);\n        for (cmaj = 0; cmaj < nchrdev; cmaj++)\n                if (cdevsw[cmaj].d_open == wdopen)\n\t\t\tvdevgone(cmaj, mn, mn + MAXPARTITIONS - 1, VCHR);\n\n\t/* Get rid of the shutdown hook. */\n\tif (sc->sc_sdhook != NULL)\n\t\tshutdownhook_disestablish(sc->sc_sdhook);\n\n#if NRND > 0\n        /* Unhook the entropy source. */\n        rnd_detach_source(&sc->rnd_source);\n#endif\n\n        return (0);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int     wddetach",
      "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rnd_detach_source",
          "args": [
            "&sc->rnd_source"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_disestablish",
          "args": [
            "sc->sc_sdhook"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vdevgone",
          "args": [
            "cmaj",
            "mn",
            "mn + MAXPARTITIONS - 1",
            "VCHR"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vdevgone",
          "args": [
            "bmaj",
            "mn",
            "mn + MAXPARTITIONS - 1",
            "VBLK"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDMINOR",
          "args": [
            "self->dv_unit",
            "0"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nint     wddetach;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nint\nwddetach(self, flags)\n        struct device *self;\n        int flags;\n{\n        struct wd_softc *sc = (struct wd_softc *)self;\n        struct buf *dp, *bp;\n        int s, bmaj, cmaj, mn;\n\n\t/* Remove unprocessed buffers from queue */\n\ts = splbio();\n\tfor (dp = &sc->sc_q; (bp = dp->b_actf) != NULL; ) {\n\t\tdp->b_actf = bp->b_actf;\n\t\t\n\t\tbp->b_error = ENXIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t}\n\tsplx(s);\n\n        /* locate the major number */\n        mn = WDMINOR(self->dv_unit, 0);\n\n        for (bmaj = 0; bmaj < nblkdev; bmaj++)\n                if (bdevsw[bmaj].d_open == wdopen)\n\t\t\tvdevgone(bmaj, mn, mn + MAXPARTITIONS - 1, VBLK);\n        for (cmaj = 0; cmaj < nchrdev; cmaj++)\n                if (cdevsw[cmaj].d_open == wdopen)\n\t\t\tvdevgone(cmaj, mn, mn + MAXPARTITIONS - 1, VCHR);\n\n\t/* Get rid of the shutdown hook. */\n\tif (sc->sc_sdhook != NULL)\n\t\tshutdownhook_disestablish(sc->sc_sdhook);\n\n#if NRND > 0\n        /* Unhook the entropy source. */\n        rnd_detach_source(&sc->rnd_source);\n#endif\n\n        return (0);\n}"
  },
  {
    "function_name": "wdactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "388-406",
    "snippet": "int\nwdactivate(self, act)\n        struct device *self;\n        enum devact act;\n{\n        int rv = 0;\n\n        switch (act) {\n        case DVACT_ACTIVATE:\n                break;\n\n        case DVACT_DEACTIVATE:\n                /*\n                 * Nothing to do; we key off the device's DVF_ACTIVATE.\n                 */\n                break;\n        }\n        return (rv);\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int     wdactivate"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nint     wdactivate;\n\nint\nwdactivate(self, act)\n        struct device *self;\n        enum devact act;\n{\n        int rv = 0;\n\n        switch (act) {\n        case DVACT_ACTIVATE:\n                break;\n\n        case DVACT_DEACTIVATE:\n                /*\n                 * Nothing to do; we key off the device's DVF_ACTIVATE.\n                 */\n                break;\n        }\n        return (rv);\n}"
  },
  {
    "function_name": "wdattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
    "lines": "283-386",
    "snippet": "void\nwdattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wd_softc *wd = (void *)self;\n\tstruct ata_atapi_attach *aa_link= aux;\n\tint i, blank;\n\tchar buf[41], c, *p, *q;\n\tWDCDEBUG_PRINT((\"wdattach\\n\"), DEBUG_FUNCS | DEBUG_PROBE);\n\n\twd->openings = aa_link->aa_openings;\n\twd->drvp = aa_link->aa_drv_data;\n\n\tstrncpy(wd->drvp->drive_name, wd->sc_dev.dv_xname, \n\t\tsizeof(wd->drvp->drive_name) - 1);\n\twd->drvp->cf_flags = wd->sc_dev.dv_cfdata->cf_flags;\n\n\t/* read our drive info */\n\tif (wd_get_params(wd, at_poll, &wd->sc_params) != 0) {\n\t\tprintf(\"%s: IDENTIFY failed\\n\", wd->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tfor (blank = 0, p = wd->sc_params.atap_model, q = buf, i = 0;\n\t    i < sizeof(wd->sc_params.atap_model); i++) {\n\t\tc = *p++;\n\t\tif (c == '\\0')\n\t\t\tbreak;\n\t\tif (c != ' ') {\n\t\t\tif (blank) {\n\t\t\t\t*q++ = ' ';\n\t\t\t\tblank = 0;\n\t\t\t}\n\t\t\t*q++ = c;\n\t\t} else\n\t\t\tblank = 1;\n\t\t}\n\t*q++ = '\\0';\n\n\tprintf(\": <%s>\\n\", buf);\n\n\twdc_probe_caps(wd->drvp, &wd->sc_params);\n\twdc_print_caps(wd->drvp);\n\n\tif ((wd->sc_params.atap_multi & 0xff) > 1) {\n\t\twd->sc_multi = wd->sc_params.atap_multi & 0xff;\n\t} else {\n\t\twd->sc_multi = 1;\n\t}\n\n\tprintf(\"%s: %d-sector PIO,\", wd->sc_dev.dv_xname, wd->sc_multi);\n\n\t/* Prior to ATA-4, LBA was optional. */\n\tif ((wd->sc_params.atap_capabilities1 & WDC_CAP_LBA) != 0)\n\t\twd->sc_flags |= WDF_LBA;\n#if 0\n\t/* ATA-4 requires LBA. */\n\tif (wd->sc_params.atap_ataversion != 0xffff &&\n\t    wd->sc_params.atap_ataversion >= WDC_VER_ATA4)\n\t\twd->sc_flags |= WDF_LBA;\n#endif\n\n\tif ((wd->sc_flags & WDF_LBA) != 0) {\n\t\twd->sc_capacity =\n\t\t    (wd->sc_params.atap_capacity[1] << 16) |\n\t\t    wd->sc_params.atap_capacity[0];\n\t\tprintf(\" LBA, %dMB, %d cyl, %d head, %d sec, %d sectors\\n\",\n\t\t    wd->sc_capacity / (1048576 / DEV_BSIZE),\n\t\t    wd->sc_params.atap_cylinders,\n\t\t    wd->sc_params.atap_heads,\n\t\t    wd->sc_params.atap_sectors,\n\t\t    wd->sc_capacity);\n\t} else {\n\t\twd->sc_capacity =\n\t\t    wd->sc_params.atap_cylinders *\n\t\t    wd->sc_params.atap_heads *\n\t\t    wd->sc_params.atap_sectors;\n\t\tprintf(\" CHS, %dMB, %d cyl, %d head, %d sec, %d sectors\\n\",\n\t\t    wd->sc_capacity / (1048576 / DEV_BSIZE),\n\t\t    wd->sc_params.atap_cylinders,\n\t\t    wd->sc_params.atap_heads,\n\t\t    wd->sc_params.atap_sectors,\n\t\t    wd->sc_capacity);\n\t}\n\tWDCDEBUG_PRINT((\"%s: atap_dmatiming_mimi=%d, atap_dmatiming_recom=%d\\n\",\n\t    self->dv_xname, wd->sc_params.atap_dmatiming_mimi,\n\t    wd->sc_params.atap_dmatiming_recom), DEBUG_PROBE);\n\t/*\n\t * Initialize and attach the disk structure.\n\t */\n\twd->sc_dk.dk_driver = &wddkdriver;\n\twd->sc_dk.dk_name = wd->sc_dev.dv_xname;\n\tdisk_attach(&wd->sc_dk);\n\twd->sc_wdc_bio.lp = wd->sc_dk.dk_label;\n\twd->sc_sdhook = shutdownhook_establish(wd_shutdown, wd);\n\tif (wd->sc_sdhook == NULL)\n\t\tprintf(\"%s: WARNING: unable to establish shutdown hook\\n\",\n\t\t    wd->sc_dev.dv_xname); \n#if NRND > 0\n\trnd_attach_source(&wd->rnd_source, wd->sc_dev.dv_xname,\n\t\t\t  RND_TYPE_DISK, 0);\n#endif\n}",
    "includes": [
      "#include \"locators.h\"",
      "#include <sys/ataio.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <vm/vm.h>",
      "#include <sys/vnode.h>",
      "#include <sys/rnd.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/uio.h>",
      "#include <sys/buf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"rnd.h\""
    ],
    "macros_used": [
      "#define sc_multi sc_wdc_bio.multi",
      "#define WDF_LBA\t 0x40 /* using LBA mode */",
      "#define DEBUG_PROBE  0x10",
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [
      "void\twdattach",
      "int   wd_get_params",
      "void  wd_shutdown",
      "struct dkdriver wddkdriver = { wdstrategy };",
      "void *aux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rnd_attach_source",
          "args": [
            "&wd->rnd_source",
            "wd->sc_dev.dv_xname",
            "RND_TYPE_DISK",
            "0"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: WARNING: unable to establish shutdown hook\\n\"",
            "wd->sc_dev.dv_xname"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "wd_shutdown",
            "wd"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_attach",
          "args": [
            "&wd->sc_dk"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"%s: atap_dmatiming_mimi=%d, atap_dmatiming_recom=%d\\n\",\n\t    self->dv_xname, wd->sc_params.atap_dmatiming_mimi,\n\t    wd->sc_params.atap_dmatiming_recom)",
            "DEBUG_PROBE"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_print_caps",
          "args": [
            "wd->drvp"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_print_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1224-1246",
          "snippet": "void\nwdc_print_caps(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n \tprintf(\"%s: can use \", drvp->drive_name);\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\tprintf(\"32-bit\");\n\t} else \n\t\tprintf(\"16-bit\");\n\n\tprintf(\", PIO mode %d\", drvp->PIO_cap);\n\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\tprintf(\", DMA mode %d\", drvp->DMA_cap);\n\t}\n\n\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_cap);\n\t}\n\t\t\t\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_print_caps(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n \tprintf(\"%s: can use \", drvp->drive_name);\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\tprintf(\"32-bit\");\n\t} else \n\t\tprintf(\"16-bit\");\n\n\tprintf(\", PIO mode %d\", drvp->PIO_cap);\n\n\tif (drvp->drive_flags & DRIVE_DMA) {\n\t\tprintf(\", DMA mode %d\", drvp->DMA_cap);\n\t}\n\n\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\tprintf(\", Ultra-DMA mode %d\", drvp->UDMA_cap);\n\t}\n\t\t\t\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_probe_caps",
          "args": [
            "wd->drvp",
            "&wd->sc_params"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_probe_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "987-1162",
          "snippet": "void\nwdc_probe_caps(drvp, params)\n\tstruct ata_drive_datas *drvp;\n\tstruct ataparams *params;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint i, printed;\n\tint cf_flags = drvp->cf_flags;\n\n\tif ((wdc->cap & (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) {\n\t\tstruct ataparams params2;\n\n\t\t/*\n\t\t * Controller claims 16 and 32 bit transfers.\n\t\t * Re-do an IDENTIFY with 32-bit transfers,\n\t\t * and compare results.\n\t\t */\n\t\tdrvp->drive_flags |= DRIVE_CAP32;\n\t\tata_get_params(drvp, at_poll, &params2);\n\t\tif (bcmp(params, &params2, sizeof(struct ataparams)) != 0) {\n\t\t\t/* Not good. fall back to 16bits */\n\t\t\tdrvp->drive_flags &= ~DRIVE_CAP32;\n\t\t}\n\t}\n#if 0 /* Some ultra-DMA drives claims to only support ATA-3. sigh */\n\tif (params->atap_ata_major > 0x01 && \n\t    params->atap_ata_major != 0xffff) {\n\t\tfor (i = 14; i > 0; i--) {\n\t\t\tif (params->atap_ata_major & (1 << i)) {\n\t\t\t\tprintf(\"%sATA version %d\\n\", sep, i);\n\t\t\t\tdrvp->ata_vers = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else \n#endif\n\t/* An ATAPI device is at last PIO mode 3 */\n\tif (drvp->drive_flags & DRIVE_ATAPI)\n\t\tdrvp->PIO_mode = 3;\n\n\t/*\n\t * It's not in the specs, but it seems that some drive \n\t * returns 0xffff in atap_extensions when this field is invalid\n\t */\n\tif (params->atap_extensions != 0xffff &&\n\t    (params->atap_extensions & WDC_EXT_MODES)) {\n\t\tprinted = 0;\n\t\t/*\n\t\t * XXX some drives report something wrong here (they claim to\n\t\t * support PIO mode 8 !). As mode is coded on 3 bits in\n\t\t * SET FEATURE, limit it to 7 (so limit i to 4).\n\t\t * If higther mode than 7 is found, abort.\n\t\t */\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_piomode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i > 4) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * See if mode is accepted.\n\t\t\t * If the controller can't set its PIO mode,\n\t\t\t * assume the defaults are good, so don't try\n\t\t\t * to set it\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) != 0)\n\t\t\t\tif (ata_set_mode(drvp, 0x08 | (i + 3),\n\t\t\t\t   at_poll) != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) { \n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If controller's driver can't set its PIO mode,\n\t\t\t * get the highter one for the drive.\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) == 0 ||\n\t\t\t    wdc->PIO_cap >= i + 3) {\n\t\t\t\tdrvp->PIO_mode = i + 3;\n\t\t\t\tdrvp->PIO_cap = i + 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!printed) {\n\t\t\t/* \n\t\t\t * We didn't find a valid PIO mode.\n\t\t\t * Assume the values returned for DMA are buggy too\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t\tprinted = 0;\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_dmamode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_DMA) &&\n\t\t\t    (wdc->cap & WDC_CAPABILITY_MODE))\n\t\t\t\tif (ata_set_mode(drvp, 0x20 | i, at_poll)\n\t\t\t\t    != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) {\n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\tif (wdc->cap & WDC_CAPABILITY_DMA) {\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    wdc->DMA_cap < i)\n\t\t\t\t\tcontinue;\n\t\t\t\tdrvp->DMA_mode = i;\n\t\t\t\tdrvp->DMA_cap = i;\n\t\t\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (params->atap_extensions & WDC_EXT_UDMA_MODES) {\n\t\t\tfor (i = 7; i >= 0; i--) {\n\t\t\t\tif ((params->atap_udmamode_supp & (1 << i))\n\t\t\t\t    == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    (wdc->cap & WDC_CAPABILITY_UDMA))\n\t\t\t\t\tif (ata_set_mode(drvp, 0x40 | i,\n\t\t\t\t\t    at_poll) != CMD_OK)\n\t\t\t\t\t\tcontinue;\n\t\t\t\tif (wdc->cap & WDC_CAPABILITY_UDMA) {\n\t\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t\t    wdc->UDMA_cap < i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdrvp->UDMA_mode = i;\n\t\t\t\t\tdrvp->UDMA_cap = i;\n\t\t\t\t\tdrvp->drive_flags |= DRIVE_UDMA;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Try to guess ATA version here, if it didn't get reported */\n\tif (drvp->ata_vers == 0) {\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tdrvp->ata_vers = 4; /* should be at last ATA-4 */\n\t\telse if (drvp->PIO_cap > 2)\n\t\t\tdrvp->ata_vers = 2; /* should be at last ATA-2 */\n\t}\n\tif (cf_flags & ATA_CONFIG_PIO_SET) {\n\t\tdrvp->PIO_mode =\n\t\t    (cf_flags & ATA_CONFIG_PIO_MODES) >> ATA_CONFIG_PIO_OFF;\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t}\n\tif ((wdc->cap & WDC_CAPABILITY_DMA) == 0) {\n\t\t/* don't care about DMA modes */\n\t\treturn;\n\t}\n\tif (cf_flags & ATA_CONFIG_DMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_DMA_MODES) ==\n\t\t    ATA_CONFIG_DMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t} else {\n\t\t\tdrvp->DMA_mode = (cf_flags & ATA_CONFIG_DMA_MODES) >>\n\t\t\t    ATA_CONFIG_DMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_DMA | DRIVE_MODE;\n\t\t}\n\t}\n\tif (cf_flags & ATA_CONFIG_UDMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_UDMA_MODES) ==\n\t\t    ATA_CONFIG_UDMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t} else {\n\t\t\tdrvp->UDMA_mode = (cf_flags & ATA_CONFIG_UDMA_MODES) >>\n\t\t\t    ATA_CONFIG_UDMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_UDMA | DRIVE_MODE;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int at_poll = AT_POLL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint at_poll = AT_POLL;\n\nvoid\nwdc_probe_caps(drvp, params)\n\tstruct ata_drive_datas *drvp;\n\tstruct ataparams *params;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint i, printed;\n\tint cf_flags = drvp->cf_flags;\n\n\tif ((wdc->cap & (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) {\n\t\tstruct ataparams params2;\n\n\t\t/*\n\t\t * Controller claims 16 and 32 bit transfers.\n\t\t * Re-do an IDENTIFY with 32-bit transfers,\n\t\t * and compare results.\n\t\t */\n\t\tdrvp->drive_flags |= DRIVE_CAP32;\n\t\tata_get_params(drvp, at_poll, &params2);\n\t\tif (bcmp(params, &params2, sizeof(struct ataparams)) != 0) {\n\t\t\t/* Not good. fall back to 16bits */\n\t\t\tdrvp->drive_flags &= ~DRIVE_CAP32;\n\t\t}\n\t}\n#if 0 /* Some ultra-DMA drives claims to only support ATA-3. sigh */\n\tif (params->atap_ata_major > 0x01 && \n\t    params->atap_ata_major != 0xffff) {\n\t\tfor (i = 14; i > 0; i--) {\n\t\t\tif (params->atap_ata_major & (1 << i)) {\n\t\t\t\tprintf(\"%sATA version %d\\n\", sep, i);\n\t\t\t\tdrvp->ata_vers = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else \n#endif\n\t/* An ATAPI device is at last PIO mode 3 */\n\tif (drvp->drive_flags & DRIVE_ATAPI)\n\t\tdrvp->PIO_mode = 3;\n\n\t/*\n\t * It's not in the specs, but it seems that some drive \n\t * returns 0xffff in atap_extensions when this field is invalid\n\t */\n\tif (params->atap_extensions != 0xffff &&\n\t    (params->atap_extensions & WDC_EXT_MODES)) {\n\t\tprinted = 0;\n\t\t/*\n\t\t * XXX some drives report something wrong here (they claim to\n\t\t * support PIO mode 8 !). As mode is coded on 3 bits in\n\t\t * SET FEATURE, limit it to 7 (so limit i to 4).\n\t\t * If higther mode than 7 is found, abort.\n\t\t */\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_piomode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (i > 4) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * See if mode is accepted.\n\t\t\t * If the controller can't set its PIO mode,\n\t\t\t * assume the defaults are good, so don't try\n\t\t\t * to set it\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) != 0)\n\t\t\t\tif (ata_set_mode(drvp, 0x08 | (i + 3),\n\t\t\t\t   at_poll) != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) { \n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If controller's driver can't set its PIO mode,\n\t\t\t * get the highter one for the drive.\n\t\t\t */\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) == 0 ||\n\t\t\t    wdc->PIO_cap >= i + 3) {\n\t\t\t\tdrvp->PIO_mode = i + 3;\n\t\t\t\tdrvp->PIO_cap = i + 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!printed) {\n\t\t\t/* \n\t\t\t * We didn't find a valid PIO mode.\n\t\t\t * Assume the values returned for DMA are buggy too\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t\tprinted = 0;\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tif ((params->atap_dmamode_supp & (1 << i)) == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((wdc->cap & WDC_CAPABILITY_DMA) &&\n\t\t\t    (wdc->cap & WDC_CAPABILITY_MODE))\n\t\t\t\tif (ata_set_mode(drvp, 0x20 | i, at_poll)\n\t\t\t\t    != CMD_OK)\n\t\t\t\t\tcontinue;\n\t\t\tif (!printed) {\n\t\t\t\tprinted = 1;\n\t\t\t}\n\t\t\tif (wdc->cap & WDC_CAPABILITY_DMA) {\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    wdc->DMA_cap < i)\n\t\t\t\t\tcontinue;\n\t\t\t\tdrvp->DMA_mode = i;\n\t\t\t\tdrvp->DMA_cap = i;\n\t\t\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (params->atap_extensions & WDC_EXT_UDMA_MODES) {\n\t\t\tfor (i = 7; i >= 0; i--) {\n\t\t\t\tif ((params->atap_udmamode_supp & (1 << i))\n\t\t\t\t    == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t    (wdc->cap & WDC_CAPABILITY_UDMA))\n\t\t\t\t\tif (ata_set_mode(drvp, 0x40 | i,\n\t\t\t\t\t    at_poll) != CMD_OK)\n\t\t\t\t\t\tcontinue;\n\t\t\t\tif (wdc->cap & WDC_CAPABILITY_UDMA) {\n\t\t\t\t\tif ((wdc->cap & WDC_CAPABILITY_MODE) &&\n\t\t\t\t\t    wdc->UDMA_cap < i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdrvp->UDMA_mode = i;\n\t\t\t\t\tdrvp->UDMA_cap = i;\n\t\t\t\t\tdrvp->drive_flags |= DRIVE_UDMA;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Try to guess ATA version here, if it didn't get reported */\n\tif (drvp->ata_vers == 0) {\n\t\tif (drvp->drive_flags & DRIVE_UDMA)\n\t\t\tdrvp->ata_vers = 4; /* should be at last ATA-4 */\n\t\telse if (drvp->PIO_cap > 2)\n\t\t\tdrvp->ata_vers = 2; /* should be at last ATA-2 */\n\t}\n\tif (cf_flags & ATA_CONFIG_PIO_SET) {\n\t\tdrvp->PIO_mode =\n\t\t    (cf_flags & ATA_CONFIG_PIO_MODES) >> ATA_CONFIG_PIO_OFF;\n\t\tdrvp->drive_flags |= DRIVE_MODE;\n\t}\n\tif ((wdc->cap & WDC_CAPABILITY_DMA) == 0) {\n\t\t/* don't care about DMA modes */\n\t\treturn;\n\t}\n\tif (cf_flags & ATA_CONFIG_DMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_DMA_MODES) ==\n\t\t    ATA_CONFIG_DMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_DMA;\n\t\t} else {\n\t\t\tdrvp->DMA_mode = (cf_flags & ATA_CONFIG_DMA_MODES) >>\n\t\t\t    ATA_CONFIG_DMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_DMA | DRIVE_MODE;\n\t\t}\n\t}\n\tif (cf_flags & ATA_CONFIG_UDMA_SET) {\n\t\tif ((cf_flags & ATA_CONFIG_UDMA_MODES) ==\n\t\t    ATA_CONFIG_UDMA_DISABLE) {\n\t\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\t} else {\n\t\t\tdrvp->UDMA_mode = (cf_flags & ATA_CONFIG_UDMA_MODES) >>\n\t\t\t    ATA_CONFIG_UDMA_OFF;\n\t\t\tdrvp->drive_flags |= DRIVE_UDMA | DRIVE_MODE;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wd_get_params",
          "args": [
            "wd",
            "at_poll",
            "&wd->sc_params"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "wd_get_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "1335-1366",
          "snippet": "int\nwd_get_params(wd, flags, params)\n\tstruct wd_softc *wd;\n\tu_int8_t flags;\n\tstruct ataparams *params;\n{\n\tswitch (ata_get_params(wd->drvp, flags, params)) {\n\tcase CMD_AGAIN:\n\t\treturn 1;\n\tcase CMD_ERR:\n\t\t/*\n\t\t * We `know' there's a drive here; just assume it's old.\n\t\t * This geometry is only used to read the MBR and print a\n\t\t * (false) attach message.\n\t\t */\n\t\tstrncpy(params->atap_model, \"ST506\",\n\t\t    sizeof params->atap_model);\n\t\tparams->atap_config = ATA_CFG_FIXED;\n\t\tparams->atap_cylinders = 1024;\n\t\tparams->atap_heads = 8;\n\t\tparams->atap_sectors = 17;\n\t\tparams->atap_multi = 1;\n\t\tparams->atap_capabilities1 = params->atap_capabilities2 = 0;\n\t\twd->drvp->ata_vers = -1; /* Mark it as pre-ATA */\n\t\treturn 0;\n\tcase CMD_OK:\n\t\treturn 0;\n\tdefault:\n\t\tpanic(\"wd_get_params: bad return code from ata_get_params\");\n\t\t/* NOTREACHED */\n\t}\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int   wd_get_params"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\nint   wd_get_params;\n\nint\nwd_get_params(wd, flags, params)\n\tstruct wd_softc *wd;\n\tu_int8_t flags;\n\tstruct ataparams *params;\n{\n\tswitch (ata_get_params(wd->drvp, flags, params)) {\n\tcase CMD_AGAIN:\n\t\treturn 1;\n\tcase CMD_ERR:\n\t\t/*\n\t\t * We `know' there's a drive here; just assume it's old.\n\t\t * This geometry is only used to read the MBR and print a\n\t\t * (false) attach message.\n\t\t */\n\t\tstrncpy(params->atap_model, \"ST506\",\n\t\t    sizeof params->atap_model);\n\t\tparams->atap_config = ATA_CFG_FIXED;\n\t\tparams->atap_cylinders = 1024;\n\t\tparams->atap_heads = 8;\n\t\tparams->atap_sectors = 17;\n\t\tparams->atap_multi = 1;\n\t\tparams->atap_capabilities1 = params->atap_capabilities2 = 0;\n\t\twd->drvp->ata_vers = -1; /* Mark it as pre-ATA */\n\t\treturn 0;\n\tcase CMD_OK:\n\t\treturn 0;\n\tdefault:\n\t\tpanic(\"wd_get_params: bad return code from ata_get_params\");\n\t\t/* NOTREACHED */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "wd->drvp->drive_name",
            "wd->sc_dev.dv_xname",
            "sizeof(wd->drvp->drive_name) - 1"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdattach\\n\")",
            "DEBUG_FUNCS | DEBUG_PROBE"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define sc_multi sc_wdc_bio.multi\n#define WDF_LBA\t 0x40 /* using LBA mode */\n#define DEBUG_PROBE  0x10\n#define DEBUG_FUNCS  0x08\n\nvoid\twdattach;\nint   wd_get_params;\nvoid  wd_shutdown;\nstruct dkdriver wddkdriver = { wdstrategy };\nvoid *aux;\n\nvoid\nwdattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wd_softc *wd = (void *)self;\n\tstruct ata_atapi_attach *aa_link= aux;\n\tint i, blank;\n\tchar buf[41], c, *p, *q;\n\tWDCDEBUG_PRINT((\"wdattach\\n\"), DEBUG_FUNCS | DEBUG_PROBE);\n\n\twd->openings = aa_link->aa_openings;\n\twd->drvp = aa_link->aa_drv_data;\n\n\tstrncpy(wd->drvp->drive_name, wd->sc_dev.dv_xname, \n\t\tsizeof(wd->drvp->drive_name) - 1);\n\twd->drvp->cf_flags = wd->sc_dev.dv_cfdata->cf_flags;\n\n\t/* read our drive info */\n\tif (wd_get_params(wd, at_poll, &wd->sc_params) != 0) {\n\t\tprintf(\"%s: IDENTIFY failed\\n\", wd->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tfor (blank = 0, p = wd->sc_params.atap_model, q = buf, i = 0;\n\t    i < sizeof(wd->sc_params.atap_model); i++) {\n\t\tc = *p++;\n\t\tif (c == '\\0')\n\t\t\tbreak;\n\t\tif (c != ' ') {\n\t\t\tif (blank) {\n\t\t\t\t*q++ = ' ';\n\t\t\t\tblank = 0;\n\t\t\t}\n\t\t\t*q++ = c;\n\t\t} else\n\t\t\tblank = 1;\n\t\t}\n\t*q++ = '\\0';\n\n\tprintf(\": <%s>\\n\", buf);\n\n\twdc_probe_caps(wd->drvp, &wd->sc_params);\n\twdc_print_caps(wd->drvp);\n\n\tif ((wd->sc_params.atap_multi & 0xff) > 1) {\n\t\twd->sc_multi = wd->sc_params.atap_multi & 0xff;\n\t} else {\n\t\twd->sc_multi = 1;\n\t}\n\n\tprintf(\"%s: %d-sector PIO,\", wd->sc_dev.dv_xname, wd->sc_multi);\n\n\t/* Prior to ATA-4, LBA was optional. */\n\tif ((wd->sc_params.atap_capabilities1 & WDC_CAP_LBA) != 0)\n\t\twd->sc_flags |= WDF_LBA;\n#if 0\n\t/* ATA-4 requires LBA. */\n\tif (wd->sc_params.atap_ataversion != 0xffff &&\n\t    wd->sc_params.atap_ataversion >= WDC_VER_ATA4)\n\t\twd->sc_flags |= WDF_LBA;\n#endif\n\n\tif ((wd->sc_flags & WDF_LBA) != 0) {\n\t\twd->sc_capacity =\n\t\t    (wd->sc_params.atap_capacity[1] << 16) |\n\t\t    wd->sc_params.atap_capacity[0];\n\t\tprintf(\" LBA, %dMB, %d cyl, %d head, %d sec, %d sectors\\n\",\n\t\t    wd->sc_capacity / (1048576 / DEV_BSIZE),\n\t\t    wd->sc_params.atap_cylinders,\n\t\t    wd->sc_params.atap_heads,\n\t\t    wd->sc_params.atap_sectors,\n\t\t    wd->sc_capacity);\n\t} else {\n\t\twd->sc_capacity =\n\t\t    wd->sc_params.atap_cylinders *\n\t\t    wd->sc_params.atap_heads *\n\t\t    wd->sc_params.atap_sectors;\n\t\tprintf(\" CHS, %dMB, %d cyl, %d head, %d sec, %d sectors\\n\",\n\t\t    wd->sc_capacity / (1048576 / DEV_BSIZE),\n\t\t    wd->sc_params.atap_cylinders,\n\t\t    wd->sc_params.atap_heads,\n\t\t    wd->sc_params.atap_sectors,\n\t\t    wd->sc_capacity);\n\t}\n\tWDCDEBUG_PRINT((\"%s: atap_dmatiming_mimi=%d, atap_dmatiming_recom=%d\\n\",\n\t    self->dv_xname, wd->sc_params.atap_dmatiming_mimi,\n\t    wd->sc_params.atap_dmatiming_recom), DEBUG_PROBE);\n\t/*\n\t * Initialize and attach the disk structure.\n\t */\n\twd->sc_dk.dk_driver = &wddkdriver;\n\twd->sc_dk.dk_name = wd->sc_dev.dv_xname;\n\tdisk_attach(&wd->sc_dk);\n\twd->sc_wdc_bio.lp = wd->sc_dk.dk_label;\n\twd->sc_sdhook = shutdownhook_establish(wd_shutdown, wd);\n\tif (wd->sc_sdhook == NULL)\n\t\tprintf(\"%s: WARNING: unable to establish shutdown hook\\n\",\n\t\t    wd->sc_dev.dv_xname); \n#if NRND > 0\n\trnd_attach_source(&wd->rnd_source, wd->sc_dev.dv_xname,\n\t\t\t  RND_TYPE_DISK, 0);\n#endif\n}"
  }
]