[
  {
    "function_name": "hid_is_collection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
    "lines": "455-474",
    "snippet": "int\nhid_is_collection(desc, size, usage)\n\tvoid *desc;\n\tint size;\n\tu_int32_t usage;\n{\n\tstruct hid_data *hd;\n\tstruct hid_item hi;\n\tint err;\n\n\thd = hid_start_parse(desc, size, hid_input);\n\tif (hd == NULL)\n\t\treturn (0);\n\n\terr = hid_get_item(hd, &hi) &&\n\t    hi.kind == hid_collection &&\n\t    hi.usage == usage;\n\thid_end_parse(hd);\n\treturn (err);\n}",
    "includes": [
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "hid_clear_local __P((struct hid_item *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hid_end_parse",
          "args": [
            "hd"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "hid_end_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
          "lines": "111-121",
          "snippet": "void\nhid_end_parse(s)\n\tstruct hid_data *s;\n{\n\twhile (s->cur.next != NULL) {\n\t\tstruct hid_item *hi = s->cur.next->next;\n\t\tfree(s->cur.next, M_TEMP);\n\t\ts->cur.next = hi;\n\t}\n\tfree(s, M_TEMP);\n}",
          "includes": [
            "#include <dev/usb/hid.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "hid_clear_local __P((struct hid_item *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nhid_clear_local __P((struct hid_item *));\n\nvoid\nhid_end_parse(s)\n\tstruct hid_data *s;\n{\n\twhile (s->cur.next != NULL) {\n\t\tstruct hid_item *hi = s->cur.next->next;\n\t\tfree(s->cur.next, M_TEMP);\n\t\ts->cur.next = hi;\n\t}\n\tfree(s, M_TEMP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hid_get_item",
          "args": [
            "hd",
            "&hi"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "hid_get_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
          "lines": "123-372",
          "snippet": "int\nhid_get_item(s, h)\n\tstruct hid_data *s;\n\tstruct hid_item *h;\n{\n\tstruct hid_item *c = &s->cur;\n\tunsigned int bTag, bType, bSize;\n\tu_int32_t oldpos;\n\tu_char *data;\n\tint32_t dval;\n\tu_char *p;\n\tstruct hid_item *hi;\n\tint i;\n\n top:\n\tif (s->multimax != 0) {\n\t\tif (s->multi < s->multimax) {\n\t\t\tc->usage = s->usages[min(s->multi, s->nu-1)];\n\t\t\ts->multi++;\n\t\t\t*h = *c;\n\t\t\tc->loc.pos += c->loc.size;\n\t\t\th->next = 0;\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tc->loc.count = s->multimax;\n\t\t\ts->multimax = 0;\n\t\t\ts->nu = 0;\n\t\t\thid_clear_local(c);\n\t\t}\n\t}\n\tfor (;;) {\n\t\tp = s->p;\n\t\tif (p >= s->end)\n\t\t\treturn (0);\n\n\t\tbSize = *p++;\n\t\tif (bSize == 0xfe) {\n\t\t\t/* long item */\n\t\t\tbSize = *p++;\n\t\t\tbSize |= *p++ << 8;\n\t\t\tbTag = *p++;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t\tbType = 0xff; /* XXX what should it be */\n\t\t} else {\n\t\t\t/* short item */\n\t\t\tbTag = bSize >> 4;\n\t\t\tbType = (bSize >> 2) & 3;\n\t\t\tbSize &= 3;\n\t\t\tif (bSize == 3) bSize = 4;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t}\n\t\ts->p = p;\n\t\tswitch(bSize) {\n\t\tcase 0:\n\t\t\tdval = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdval = (int8_t)*data++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval = (int16_t)dval;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval |= *data++ << 16;\n\t\t\tdval |= *data++ << 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"BAD LENGTH %d\\n\", bSize);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tswitch (bType) {\n\t\tcase 0:\t\t\t/* Main */\n\t\t\tswitch (bTag) {\n\t\t\tcase 8:\t\t/* Input */\n\t\t\t\tif (!(s->kindset & (1 << hid_input)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_input;\n\t\t\t\tc->flags = dval;\n\t\t\tret:\n\t\t\t\tif (c->flags & HIO_VARIABLE) {\n\t\t\t\t\ts->multimax = c->loc.count;\n\t\t\t\t\ts->multi = 0;\n\t\t\t\t\tc->loc.count = 1;\n\t\t\t\t\tif (s->minset) {\n\t\t\t\t\t\tfor (i = c->usage_minimum; \n\t\t\t\t\t\t     i <= c->usage_maximum; \n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\ts->usages[s->nu] = i;\n\t\t\t\t\t\t\tif (s->nu < MAXUSAGE-1)\n\t\t\t\t\t\t\t\ts->nu++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts->minset = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t} else {\n\t\t\t\t\t*h = *c;\n\t\t\t\t\th->next = 0;\n\t\t\t\t\tc->loc.pos += \n\t\t\t\t\t\tc->loc.size * c->loc.count;\n\t\t\t\t\thid_clear_local(c);\n\t\t\t\t\ts->minset = 0;\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\tcase 9:\t\t/* Output */\n\t\t\t\tif (!(s->kindset & (1 << hid_output)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_output;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 10:\t/* Collection */\n\t\t\t\tc->kind = hid_collection;\n\t\t\t\tc->collection = dval;\n\t\t\t\tc->collevel++;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tcase 11:\t/* Feature */\n\t\t\t\tif (!(s->kindset & (1 << hid_feature)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_feature;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 12:\t/* End collection */\n\t\t\t\tc->kind = hid_endcollection;\n\t\t\t\tc->collevel--;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tdefault:\n\t\t\t\tprintf(\"Main bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\t\t/* Global */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tc->_usage_page = dval << 16;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tc->logical_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->logical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->unit_exponent = dval;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tc->unit = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->loc.size = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->report_ID = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->loc.count = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10: /* Push */\n\t\t\t\thi = malloc(sizeof *hi, M_TEMP, M_WAITOK);\n\t\t\t\t*hi = s->cur;\n\t\t\t\tc->next = hi;\n\t\t\t\tbreak;\n\t\t\tcase 11: /* Pop */\n\t\t\t\thi = c->next;\n\t\t\t\toldpos = c->loc.pos;\n\t\t\t\ts->cur = *hi;\n\t\t\t\tc->loc.pos = oldpos;\n\t\t\t\tfree(hi, M_TEMP);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Global bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t\t/* Local */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage = dval;\n\t\t\t\tif (s->nu < MAXUSAGE)\n\t\t\t\t\ts->usages[s->nu++] = dval;\n\t\t\t\t/* else XXX */\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ts->minset = 1;\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->designator_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->designator_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->designator_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->string_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->string_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->string_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tc->set_delimiter = dval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Local bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"default bType=%d\\n\", bType);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/usb/hid.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MAXUSAGE 100"
          ],
          "globals_used": [
            "hid_clear_local __P((struct hid_item *));",
            "struct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;",
            "int kindset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MAXUSAGE 100\n\nhid_clear_local __P((struct hid_item *));\nstruct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;\nint kindset;\n\nint\nhid_get_item(s, h)\n\tstruct hid_data *s;\n\tstruct hid_item *h;\n{\n\tstruct hid_item *c = &s->cur;\n\tunsigned int bTag, bType, bSize;\n\tu_int32_t oldpos;\n\tu_char *data;\n\tint32_t dval;\n\tu_char *p;\n\tstruct hid_item *hi;\n\tint i;\n\n top:\n\tif (s->multimax != 0) {\n\t\tif (s->multi < s->multimax) {\n\t\t\tc->usage = s->usages[min(s->multi, s->nu-1)];\n\t\t\ts->multi++;\n\t\t\t*h = *c;\n\t\t\tc->loc.pos += c->loc.size;\n\t\t\th->next = 0;\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tc->loc.count = s->multimax;\n\t\t\ts->multimax = 0;\n\t\t\ts->nu = 0;\n\t\t\thid_clear_local(c);\n\t\t}\n\t}\n\tfor (;;) {\n\t\tp = s->p;\n\t\tif (p >= s->end)\n\t\t\treturn (0);\n\n\t\tbSize = *p++;\n\t\tif (bSize == 0xfe) {\n\t\t\t/* long item */\n\t\t\tbSize = *p++;\n\t\t\tbSize |= *p++ << 8;\n\t\t\tbTag = *p++;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t\tbType = 0xff; /* XXX what should it be */\n\t\t} else {\n\t\t\t/* short item */\n\t\t\tbTag = bSize >> 4;\n\t\t\tbType = (bSize >> 2) & 3;\n\t\t\tbSize &= 3;\n\t\t\tif (bSize == 3) bSize = 4;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t}\n\t\ts->p = p;\n\t\tswitch(bSize) {\n\t\tcase 0:\n\t\t\tdval = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdval = (int8_t)*data++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval = (int16_t)dval;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval |= *data++ << 16;\n\t\t\tdval |= *data++ << 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"BAD LENGTH %d\\n\", bSize);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tswitch (bType) {\n\t\tcase 0:\t\t\t/* Main */\n\t\t\tswitch (bTag) {\n\t\t\tcase 8:\t\t/* Input */\n\t\t\t\tif (!(s->kindset & (1 << hid_input)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_input;\n\t\t\t\tc->flags = dval;\n\t\t\tret:\n\t\t\t\tif (c->flags & HIO_VARIABLE) {\n\t\t\t\t\ts->multimax = c->loc.count;\n\t\t\t\t\ts->multi = 0;\n\t\t\t\t\tc->loc.count = 1;\n\t\t\t\t\tif (s->minset) {\n\t\t\t\t\t\tfor (i = c->usage_minimum; \n\t\t\t\t\t\t     i <= c->usage_maximum; \n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\ts->usages[s->nu] = i;\n\t\t\t\t\t\t\tif (s->nu < MAXUSAGE-1)\n\t\t\t\t\t\t\t\ts->nu++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts->minset = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t} else {\n\t\t\t\t\t*h = *c;\n\t\t\t\t\th->next = 0;\n\t\t\t\t\tc->loc.pos += \n\t\t\t\t\t\tc->loc.size * c->loc.count;\n\t\t\t\t\thid_clear_local(c);\n\t\t\t\t\ts->minset = 0;\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\tcase 9:\t\t/* Output */\n\t\t\t\tif (!(s->kindset & (1 << hid_output)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_output;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 10:\t/* Collection */\n\t\t\t\tc->kind = hid_collection;\n\t\t\t\tc->collection = dval;\n\t\t\t\tc->collevel++;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tcase 11:\t/* Feature */\n\t\t\t\tif (!(s->kindset & (1 << hid_feature)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_feature;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 12:\t/* End collection */\n\t\t\t\tc->kind = hid_endcollection;\n\t\t\t\tc->collevel--;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tdefault:\n\t\t\t\tprintf(\"Main bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\t\t/* Global */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tc->_usage_page = dval << 16;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tc->logical_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->logical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->unit_exponent = dval;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tc->unit = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->loc.size = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->report_ID = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->loc.count = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10: /* Push */\n\t\t\t\thi = malloc(sizeof *hi, M_TEMP, M_WAITOK);\n\t\t\t\t*hi = s->cur;\n\t\t\t\tc->next = hi;\n\t\t\t\tbreak;\n\t\t\tcase 11: /* Pop */\n\t\t\t\thi = c->next;\n\t\t\t\toldpos = c->loc.pos;\n\t\t\t\ts->cur = *hi;\n\t\t\t\tc->loc.pos = oldpos;\n\t\t\t\tfree(hi, M_TEMP);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Global bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t\t/* Local */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage = dval;\n\t\t\t\tif (s->nu < MAXUSAGE)\n\t\t\t\t\ts->usages[s->nu++] = dval;\n\t\t\t\t/* else XXX */\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ts->minset = 1;\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->designator_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->designator_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->designator_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->string_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->string_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->string_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tc->set_delimiter = dval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Local bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"default bType=%d\\n\", bType);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hid_start_parse",
          "args": [
            "desc",
            "size",
            "hid_input"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nhid_clear_local __P((struct hid_item *));\n\nint\nhid_is_collection(desc, size, usage)\n\tvoid *desc;\n\tint size;\n\tu_int32_t usage;\n{\n\tstruct hid_data *hd;\n\tstruct hid_item hi;\n\tint err;\n\n\thd = hid_start_parse(desc, size, hid_input);\n\tif (hd == NULL)\n\t\treturn (0);\n\n\terr = hid_get_item(hd, &hi) &&\n\t    hi.kind == hid_collection &&\n\t    hi.usage == usage;\n\thid_end_parse(hd);\n\treturn (err);\n}"
  },
  {
    "function_name": "hid_get_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
    "lines": "426-453",
    "snippet": "u_long\nhid_get_data(buf, loc)\n\tu_char *buf;\n\tstruct hid_location *loc;\n{\n\tu_int hpos = loc->pos;\n\tu_int hsize = loc->size;\n\tu_int32_t data;\n\tint i, s;\n\n\tDPRINTFN(10, (\"hid_get_data: loc %d/%d\\n\", hpos, hsize));\n\n\tif (hsize == 0)\n\t\treturn (0);\n\n\tdata = 0;\n\ts = hpos / 8; \n\tfor (i = hpos; i < hpos+hsize; i += 8)\n\t\tdata |= buf[i / 8] << ((i / 8 - s) * 8);\n\tdata >>= hpos % 8;\n\tdata &= (1 << hsize) - 1;\n\thsize = 32 - hsize;\n\t/* Sign extend */\n\tdata = ((int32_t)data << hsize) >> hsize;\n\tDPRINTFN(10,(\"hid_get_data: loc %d/%d = %lu\\n\", \n\t\t    loc->pos, loc->size, (long)data));\n\treturn (data);\n}",
    "includes": [
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"hid_get_data: loc %d/%d = %lu\\n\", \n\t\t    loc->pos, loc->size, (long)data)"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"hid_get_data: loc %d/%d\\n\", hpos, hsize)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;\n\nu_long\nhid_get_data(buf, loc)\n\tu_char *buf;\n\tstruct hid_location *loc;\n{\n\tu_int hpos = loc->pos;\n\tu_int hsize = loc->size;\n\tu_int32_t data;\n\tint i, s;\n\n\tDPRINTFN(10, (\"hid_get_data: loc %d/%d\\n\", hpos, hsize));\n\n\tif (hsize == 0)\n\t\treturn (0);\n\n\tdata = 0;\n\ts = hpos / 8; \n\tfor (i = hpos; i < hpos+hsize; i += 8)\n\t\tdata |= buf[i / 8] << ((i / 8 - s) * 8);\n\tdata >>= hpos % 8;\n\tdata &= (1 << hsize) - 1;\n\thsize = 32 - hsize;\n\t/* Sign extend */\n\tdata = ((int32_t)data << hsize) >> hsize;\n\tDPRINTFN(10,(\"hid_get_data: loc %d/%d = %lu\\n\", \n\t\t    loc->pos, loc->size, (long)data));\n\treturn (data);\n}"
  },
  {
    "function_name": "hid_locate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
    "lines": "399-424",
    "snippet": "int\nhid_locate(desc, size, u, k, loc, flags)\n\tvoid *desc;\n\tint size;\n\tu_int32_t u;\n\tenum hid_kind k;\n\tstruct hid_location *loc;\n\tu_int32_t *flags;\n{\n\tstruct hid_data *d;\n\tstruct hid_item h;\n\n\tfor (d = hid_start_parse(desc, size, 1<<k); hid_get_item(d, &h); ) {\n\t\tif (h.kind == k && !(h.flags & HIO_CONST) && h.usage == u) {\n\t\t\tif (loc != NULL)\n\t\t\t\t*loc = h.loc;\n\t\t\tif (flags != NULL)\n\t\t\t\t*flags = h.flags;\n\t\t\thid_end_parse(d);\n\t\t\treturn (1);\n\t\t}\n\t}\n\thid_end_parse(d);\n\tloc->size = 0;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "hid_clear_local __P((struct hid_item *));",
      "struct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hid_end_parse",
          "args": [
            "d"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "hid_end_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
          "lines": "111-121",
          "snippet": "void\nhid_end_parse(s)\n\tstruct hid_data *s;\n{\n\twhile (s->cur.next != NULL) {\n\t\tstruct hid_item *hi = s->cur.next->next;\n\t\tfree(s->cur.next, M_TEMP);\n\t\ts->cur.next = hi;\n\t}\n\tfree(s, M_TEMP);\n}",
          "includes": [
            "#include <dev/usb/hid.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "hid_clear_local __P((struct hid_item *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nhid_clear_local __P((struct hid_item *));\n\nvoid\nhid_end_parse(s)\n\tstruct hid_data *s;\n{\n\twhile (s->cur.next != NULL) {\n\t\tstruct hid_item *hi = s->cur.next->next;\n\t\tfree(s->cur.next, M_TEMP);\n\t\ts->cur.next = hi;\n\t}\n\tfree(s, M_TEMP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hid_get_item",
          "args": [
            "d",
            "&h"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "hid_get_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
          "lines": "123-372",
          "snippet": "int\nhid_get_item(s, h)\n\tstruct hid_data *s;\n\tstruct hid_item *h;\n{\n\tstruct hid_item *c = &s->cur;\n\tunsigned int bTag, bType, bSize;\n\tu_int32_t oldpos;\n\tu_char *data;\n\tint32_t dval;\n\tu_char *p;\n\tstruct hid_item *hi;\n\tint i;\n\n top:\n\tif (s->multimax != 0) {\n\t\tif (s->multi < s->multimax) {\n\t\t\tc->usage = s->usages[min(s->multi, s->nu-1)];\n\t\t\ts->multi++;\n\t\t\t*h = *c;\n\t\t\tc->loc.pos += c->loc.size;\n\t\t\th->next = 0;\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tc->loc.count = s->multimax;\n\t\t\ts->multimax = 0;\n\t\t\ts->nu = 0;\n\t\t\thid_clear_local(c);\n\t\t}\n\t}\n\tfor (;;) {\n\t\tp = s->p;\n\t\tif (p >= s->end)\n\t\t\treturn (0);\n\n\t\tbSize = *p++;\n\t\tif (bSize == 0xfe) {\n\t\t\t/* long item */\n\t\t\tbSize = *p++;\n\t\t\tbSize |= *p++ << 8;\n\t\t\tbTag = *p++;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t\tbType = 0xff; /* XXX what should it be */\n\t\t} else {\n\t\t\t/* short item */\n\t\t\tbTag = bSize >> 4;\n\t\t\tbType = (bSize >> 2) & 3;\n\t\t\tbSize &= 3;\n\t\t\tif (bSize == 3) bSize = 4;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t}\n\t\ts->p = p;\n\t\tswitch(bSize) {\n\t\tcase 0:\n\t\t\tdval = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdval = (int8_t)*data++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval = (int16_t)dval;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval |= *data++ << 16;\n\t\t\tdval |= *data++ << 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"BAD LENGTH %d\\n\", bSize);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tswitch (bType) {\n\t\tcase 0:\t\t\t/* Main */\n\t\t\tswitch (bTag) {\n\t\t\tcase 8:\t\t/* Input */\n\t\t\t\tif (!(s->kindset & (1 << hid_input)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_input;\n\t\t\t\tc->flags = dval;\n\t\t\tret:\n\t\t\t\tif (c->flags & HIO_VARIABLE) {\n\t\t\t\t\ts->multimax = c->loc.count;\n\t\t\t\t\ts->multi = 0;\n\t\t\t\t\tc->loc.count = 1;\n\t\t\t\t\tif (s->minset) {\n\t\t\t\t\t\tfor (i = c->usage_minimum; \n\t\t\t\t\t\t     i <= c->usage_maximum; \n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\ts->usages[s->nu] = i;\n\t\t\t\t\t\t\tif (s->nu < MAXUSAGE-1)\n\t\t\t\t\t\t\t\ts->nu++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts->minset = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t} else {\n\t\t\t\t\t*h = *c;\n\t\t\t\t\th->next = 0;\n\t\t\t\t\tc->loc.pos += \n\t\t\t\t\t\tc->loc.size * c->loc.count;\n\t\t\t\t\thid_clear_local(c);\n\t\t\t\t\ts->minset = 0;\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\tcase 9:\t\t/* Output */\n\t\t\t\tif (!(s->kindset & (1 << hid_output)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_output;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 10:\t/* Collection */\n\t\t\t\tc->kind = hid_collection;\n\t\t\t\tc->collection = dval;\n\t\t\t\tc->collevel++;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tcase 11:\t/* Feature */\n\t\t\t\tif (!(s->kindset & (1 << hid_feature)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_feature;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 12:\t/* End collection */\n\t\t\t\tc->kind = hid_endcollection;\n\t\t\t\tc->collevel--;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tdefault:\n\t\t\t\tprintf(\"Main bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\t\t/* Global */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tc->_usage_page = dval << 16;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tc->logical_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->logical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->unit_exponent = dval;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tc->unit = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->loc.size = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->report_ID = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->loc.count = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10: /* Push */\n\t\t\t\thi = malloc(sizeof *hi, M_TEMP, M_WAITOK);\n\t\t\t\t*hi = s->cur;\n\t\t\t\tc->next = hi;\n\t\t\t\tbreak;\n\t\t\tcase 11: /* Pop */\n\t\t\t\thi = c->next;\n\t\t\t\toldpos = c->loc.pos;\n\t\t\t\ts->cur = *hi;\n\t\t\t\tc->loc.pos = oldpos;\n\t\t\t\tfree(hi, M_TEMP);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Global bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t\t/* Local */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage = dval;\n\t\t\t\tif (s->nu < MAXUSAGE)\n\t\t\t\t\ts->usages[s->nu++] = dval;\n\t\t\t\t/* else XXX */\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ts->minset = 1;\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->designator_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->designator_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->designator_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->string_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->string_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->string_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tc->set_delimiter = dval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Local bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"default bType=%d\\n\", bType);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/usb/hid.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MAXUSAGE 100"
          ],
          "globals_used": [
            "hid_clear_local __P((struct hid_item *));",
            "struct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;",
            "int kindset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MAXUSAGE 100\n\nhid_clear_local __P((struct hid_item *));\nstruct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;\nint kindset;\n\nint\nhid_get_item(s, h)\n\tstruct hid_data *s;\n\tstruct hid_item *h;\n{\n\tstruct hid_item *c = &s->cur;\n\tunsigned int bTag, bType, bSize;\n\tu_int32_t oldpos;\n\tu_char *data;\n\tint32_t dval;\n\tu_char *p;\n\tstruct hid_item *hi;\n\tint i;\n\n top:\n\tif (s->multimax != 0) {\n\t\tif (s->multi < s->multimax) {\n\t\t\tc->usage = s->usages[min(s->multi, s->nu-1)];\n\t\t\ts->multi++;\n\t\t\t*h = *c;\n\t\t\tc->loc.pos += c->loc.size;\n\t\t\th->next = 0;\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tc->loc.count = s->multimax;\n\t\t\ts->multimax = 0;\n\t\t\ts->nu = 0;\n\t\t\thid_clear_local(c);\n\t\t}\n\t}\n\tfor (;;) {\n\t\tp = s->p;\n\t\tif (p >= s->end)\n\t\t\treturn (0);\n\n\t\tbSize = *p++;\n\t\tif (bSize == 0xfe) {\n\t\t\t/* long item */\n\t\t\tbSize = *p++;\n\t\t\tbSize |= *p++ << 8;\n\t\t\tbTag = *p++;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t\tbType = 0xff; /* XXX what should it be */\n\t\t} else {\n\t\t\t/* short item */\n\t\t\tbTag = bSize >> 4;\n\t\t\tbType = (bSize >> 2) & 3;\n\t\t\tbSize &= 3;\n\t\t\tif (bSize == 3) bSize = 4;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t}\n\t\ts->p = p;\n\t\tswitch(bSize) {\n\t\tcase 0:\n\t\t\tdval = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdval = (int8_t)*data++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval = (int16_t)dval;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval |= *data++ << 16;\n\t\t\tdval |= *data++ << 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"BAD LENGTH %d\\n\", bSize);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tswitch (bType) {\n\t\tcase 0:\t\t\t/* Main */\n\t\t\tswitch (bTag) {\n\t\t\tcase 8:\t\t/* Input */\n\t\t\t\tif (!(s->kindset & (1 << hid_input)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_input;\n\t\t\t\tc->flags = dval;\n\t\t\tret:\n\t\t\t\tif (c->flags & HIO_VARIABLE) {\n\t\t\t\t\ts->multimax = c->loc.count;\n\t\t\t\t\ts->multi = 0;\n\t\t\t\t\tc->loc.count = 1;\n\t\t\t\t\tif (s->minset) {\n\t\t\t\t\t\tfor (i = c->usage_minimum; \n\t\t\t\t\t\t     i <= c->usage_maximum; \n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\ts->usages[s->nu] = i;\n\t\t\t\t\t\t\tif (s->nu < MAXUSAGE-1)\n\t\t\t\t\t\t\t\ts->nu++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts->minset = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t} else {\n\t\t\t\t\t*h = *c;\n\t\t\t\t\th->next = 0;\n\t\t\t\t\tc->loc.pos += \n\t\t\t\t\t\tc->loc.size * c->loc.count;\n\t\t\t\t\thid_clear_local(c);\n\t\t\t\t\ts->minset = 0;\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\tcase 9:\t\t/* Output */\n\t\t\t\tif (!(s->kindset & (1 << hid_output)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_output;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 10:\t/* Collection */\n\t\t\t\tc->kind = hid_collection;\n\t\t\t\tc->collection = dval;\n\t\t\t\tc->collevel++;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tcase 11:\t/* Feature */\n\t\t\t\tif (!(s->kindset & (1 << hid_feature)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_feature;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 12:\t/* End collection */\n\t\t\t\tc->kind = hid_endcollection;\n\t\t\t\tc->collevel--;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tdefault:\n\t\t\t\tprintf(\"Main bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\t\t/* Global */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tc->_usage_page = dval << 16;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tc->logical_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->logical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->unit_exponent = dval;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tc->unit = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->loc.size = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->report_ID = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->loc.count = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10: /* Push */\n\t\t\t\thi = malloc(sizeof *hi, M_TEMP, M_WAITOK);\n\t\t\t\t*hi = s->cur;\n\t\t\t\tc->next = hi;\n\t\t\t\tbreak;\n\t\t\tcase 11: /* Pop */\n\t\t\t\thi = c->next;\n\t\t\t\toldpos = c->loc.pos;\n\t\t\t\ts->cur = *hi;\n\t\t\t\tc->loc.pos = oldpos;\n\t\t\t\tfree(hi, M_TEMP);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Global bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t\t/* Local */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage = dval;\n\t\t\t\tif (s->nu < MAXUSAGE)\n\t\t\t\t\ts->usages[s->nu++] = dval;\n\t\t\t\t/* else XXX */\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ts->minset = 1;\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->designator_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->designator_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->designator_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->string_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->string_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->string_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tc->set_delimiter = dval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Local bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"default bType=%d\\n\", bType);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hid_start_parse",
          "args": [
            "desc",
            "size",
            "1<<k"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nhid_clear_local __P((struct hid_item *));\nstruct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;\n\nint\nhid_locate(desc, size, u, k, loc, flags)\n\tvoid *desc;\n\tint size;\n\tu_int32_t u;\n\tenum hid_kind k;\n\tstruct hid_location *loc;\n\tu_int32_t *flags;\n{\n\tstruct hid_data *d;\n\tstruct hid_item h;\n\n\tfor (d = hid_start_parse(desc, size, 1<<k); hid_get_item(d, &h); ) {\n\t\tif (h.kind == k && !(h.flags & HIO_CONST) && h.usage == u) {\n\t\t\tif (loc != NULL)\n\t\t\t\t*loc = h.loc;\n\t\t\tif (flags != NULL)\n\t\t\t\t*flags = h.flags;\n\t\t\thid_end_parse(d);\n\t\t\treturn (1);\n\t\t}\n\t}\n\thid_end_parse(d);\n\tloc->size = 0;\n\treturn (0);\n}"
  },
  {
    "function_name": "hid_report_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
    "lines": "374-397",
    "snippet": "int\nhid_report_size(buf, len, k, idp)\n\tvoid *buf;\n\tint len;\n\tenum hid_kind k;\n\tu_int8_t *idp;\n{\n\tstruct hid_data *d;\n\tstruct hid_item h;\n\tint size, id;\n\n\tid = 0;\n\tfor (d = hid_start_parse(buf, len, 1<<k); hid_get_item(d, &h); )\n\t\tif (h.report_ID != 0)\n\t\t\tid = h.report_ID;\n\thid_end_parse(d);\n\tsize = h.loc.pos;\n\tif (id != 0) {\n\t\tsize += 8;\n\t\t*idp = id;\t/* XXX wrong */\n\t} else\n\t\t*idp = 0;\n\treturn ((size + 7) / 8);\n}",
    "includes": [
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "hid_clear_local __P((struct hid_item *));",
      "struct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;",
      "int len;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hid_end_parse",
          "args": [
            "d"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "hid_end_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
          "lines": "111-121",
          "snippet": "void\nhid_end_parse(s)\n\tstruct hid_data *s;\n{\n\twhile (s->cur.next != NULL) {\n\t\tstruct hid_item *hi = s->cur.next->next;\n\t\tfree(s->cur.next, M_TEMP);\n\t\ts->cur.next = hi;\n\t}\n\tfree(s, M_TEMP);\n}",
          "includes": [
            "#include <dev/usb/hid.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "hid_clear_local __P((struct hid_item *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nhid_clear_local __P((struct hid_item *));\n\nvoid\nhid_end_parse(s)\n\tstruct hid_data *s;\n{\n\twhile (s->cur.next != NULL) {\n\t\tstruct hid_item *hi = s->cur.next->next;\n\t\tfree(s->cur.next, M_TEMP);\n\t\ts->cur.next = hi;\n\t}\n\tfree(s, M_TEMP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hid_get_item",
          "args": [
            "d",
            "&h"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "hid_get_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
          "lines": "123-372",
          "snippet": "int\nhid_get_item(s, h)\n\tstruct hid_data *s;\n\tstruct hid_item *h;\n{\n\tstruct hid_item *c = &s->cur;\n\tunsigned int bTag, bType, bSize;\n\tu_int32_t oldpos;\n\tu_char *data;\n\tint32_t dval;\n\tu_char *p;\n\tstruct hid_item *hi;\n\tint i;\n\n top:\n\tif (s->multimax != 0) {\n\t\tif (s->multi < s->multimax) {\n\t\t\tc->usage = s->usages[min(s->multi, s->nu-1)];\n\t\t\ts->multi++;\n\t\t\t*h = *c;\n\t\t\tc->loc.pos += c->loc.size;\n\t\t\th->next = 0;\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tc->loc.count = s->multimax;\n\t\t\ts->multimax = 0;\n\t\t\ts->nu = 0;\n\t\t\thid_clear_local(c);\n\t\t}\n\t}\n\tfor (;;) {\n\t\tp = s->p;\n\t\tif (p >= s->end)\n\t\t\treturn (0);\n\n\t\tbSize = *p++;\n\t\tif (bSize == 0xfe) {\n\t\t\t/* long item */\n\t\t\tbSize = *p++;\n\t\t\tbSize |= *p++ << 8;\n\t\t\tbTag = *p++;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t\tbType = 0xff; /* XXX what should it be */\n\t\t} else {\n\t\t\t/* short item */\n\t\t\tbTag = bSize >> 4;\n\t\t\tbType = (bSize >> 2) & 3;\n\t\t\tbSize &= 3;\n\t\t\tif (bSize == 3) bSize = 4;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t}\n\t\ts->p = p;\n\t\tswitch(bSize) {\n\t\tcase 0:\n\t\t\tdval = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdval = (int8_t)*data++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval = (int16_t)dval;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval |= *data++ << 16;\n\t\t\tdval |= *data++ << 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"BAD LENGTH %d\\n\", bSize);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tswitch (bType) {\n\t\tcase 0:\t\t\t/* Main */\n\t\t\tswitch (bTag) {\n\t\t\tcase 8:\t\t/* Input */\n\t\t\t\tif (!(s->kindset & (1 << hid_input)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_input;\n\t\t\t\tc->flags = dval;\n\t\t\tret:\n\t\t\t\tif (c->flags & HIO_VARIABLE) {\n\t\t\t\t\ts->multimax = c->loc.count;\n\t\t\t\t\ts->multi = 0;\n\t\t\t\t\tc->loc.count = 1;\n\t\t\t\t\tif (s->minset) {\n\t\t\t\t\t\tfor (i = c->usage_minimum; \n\t\t\t\t\t\t     i <= c->usage_maximum; \n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\ts->usages[s->nu] = i;\n\t\t\t\t\t\t\tif (s->nu < MAXUSAGE-1)\n\t\t\t\t\t\t\t\ts->nu++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts->minset = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t} else {\n\t\t\t\t\t*h = *c;\n\t\t\t\t\th->next = 0;\n\t\t\t\t\tc->loc.pos += \n\t\t\t\t\t\tc->loc.size * c->loc.count;\n\t\t\t\t\thid_clear_local(c);\n\t\t\t\t\ts->minset = 0;\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\tcase 9:\t\t/* Output */\n\t\t\t\tif (!(s->kindset & (1 << hid_output)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_output;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 10:\t/* Collection */\n\t\t\t\tc->kind = hid_collection;\n\t\t\t\tc->collection = dval;\n\t\t\t\tc->collevel++;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tcase 11:\t/* Feature */\n\t\t\t\tif (!(s->kindset & (1 << hid_feature)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_feature;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 12:\t/* End collection */\n\t\t\t\tc->kind = hid_endcollection;\n\t\t\t\tc->collevel--;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tdefault:\n\t\t\t\tprintf(\"Main bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\t\t/* Global */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tc->_usage_page = dval << 16;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tc->logical_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->logical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->unit_exponent = dval;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tc->unit = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->loc.size = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->report_ID = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->loc.count = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10: /* Push */\n\t\t\t\thi = malloc(sizeof *hi, M_TEMP, M_WAITOK);\n\t\t\t\t*hi = s->cur;\n\t\t\t\tc->next = hi;\n\t\t\t\tbreak;\n\t\t\tcase 11: /* Pop */\n\t\t\t\thi = c->next;\n\t\t\t\toldpos = c->loc.pos;\n\t\t\t\ts->cur = *hi;\n\t\t\t\tc->loc.pos = oldpos;\n\t\t\t\tfree(hi, M_TEMP);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Global bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t\t/* Local */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage = dval;\n\t\t\t\tif (s->nu < MAXUSAGE)\n\t\t\t\t\ts->usages[s->nu++] = dval;\n\t\t\t\t/* else XXX */\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ts->minset = 1;\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->designator_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->designator_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->designator_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->string_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->string_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->string_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tc->set_delimiter = dval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Local bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"default bType=%d\\n\", bType);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/usb/hid.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MAXUSAGE 100"
          ],
          "globals_used": [
            "hid_clear_local __P((struct hid_item *));",
            "struct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;",
            "int kindset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MAXUSAGE 100\n\nhid_clear_local __P((struct hid_item *));\nstruct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;\nint kindset;\n\nint\nhid_get_item(s, h)\n\tstruct hid_data *s;\n\tstruct hid_item *h;\n{\n\tstruct hid_item *c = &s->cur;\n\tunsigned int bTag, bType, bSize;\n\tu_int32_t oldpos;\n\tu_char *data;\n\tint32_t dval;\n\tu_char *p;\n\tstruct hid_item *hi;\n\tint i;\n\n top:\n\tif (s->multimax != 0) {\n\t\tif (s->multi < s->multimax) {\n\t\t\tc->usage = s->usages[min(s->multi, s->nu-1)];\n\t\t\ts->multi++;\n\t\t\t*h = *c;\n\t\t\tc->loc.pos += c->loc.size;\n\t\t\th->next = 0;\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tc->loc.count = s->multimax;\n\t\t\ts->multimax = 0;\n\t\t\ts->nu = 0;\n\t\t\thid_clear_local(c);\n\t\t}\n\t}\n\tfor (;;) {\n\t\tp = s->p;\n\t\tif (p >= s->end)\n\t\t\treturn (0);\n\n\t\tbSize = *p++;\n\t\tif (bSize == 0xfe) {\n\t\t\t/* long item */\n\t\t\tbSize = *p++;\n\t\t\tbSize |= *p++ << 8;\n\t\t\tbTag = *p++;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t\tbType = 0xff; /* XXX what should it be */\n\t\t} else {\n\t\t\t/* short item */\n\t\t\tbTag = bSize >> 4;\n\t\t\tbType = (bSize >> 2) & 3;\n\t\t\tbSize &= 3;\n\t\t\tif (bSize == 3) bSize = 4;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t}\n\t\ts->p = p;\n\t\tswitch(bSize) {\n\t\tcase 0:\n\t\t\tdval = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdval = (int8_t)*data++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval = (int16_t)dval;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval |= *data++ << 16;\n\t\t\tdval |= *data++ << 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"BAD LENGTH %d\\n\", bSize);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tswitch (bType) {\n\t\tcase 0:\t\t\t/* Main */\n\t\t\tswitch (bTag) {\n\t\t\tcase 8:\t\t/* Input */\n\t\t\t\tif (!(s->kindset & (1 << hid_input)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_input;\n\t\t\t\tc->flags = dval;\n\t\t\tret:\n\t\t\t\tif (c->flags & HIO_VARIABLE) {\n\t\t\t\t\ts->multimax = c->loc.count;\n\t\t\t\t\ts->multi = 0;\n\t\t\t\t\tc->loc.count = 1;\n\t\t\t\t\tif (s->minset) {\n\t\t\t\t\t\tfor (i = c->usage_minimum; \n\t\t\t\t\t\t     i <= c->usage_maximum; \n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\ts->usages[s->nu] = i;\n\t\t\t\t\t\t\tif (s->nu < MAXUSAGE-1)\n\t\t\t\t\t\t\t\ts->nu++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts->minset = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t} else {\n\t\t\t\t\t*h = *c;\n\t\t\t\t\th->next = 0;\n\t\t\t\t\tc->loc.pos += \n\t\t\t\t\t\tc->loc.size * c->loc.count;\n\t\t\t\t\thid_clear_local(c);\n\t\t\t\t\ts->minset = 0;\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\tcase 9:\t\t/* Output */\n\t\t\t\tif (!(s->kindset & (1 << hid_output)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_output;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 10:\t/* Collection */\n\t\t\t\tc->kind = hid_collection;\n\t\t\t\tc->collection = dval;\n\t\t\t\tc->collevel++;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tcase 11:\t/* Feature */\n\t\t\t\tif (!(s->kindset & (1 << hid_feature)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_feature;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 12:\t/* End collection */\n\t\t\t\tc->kind = hid_endcollection;\n\t\t\t\tc->collevel--;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tdefault:\n\t\t\t\tprintf(\"Main bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\t\t/* Global */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tc->_usage_page = dval << 16;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tc->logical_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->logical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->unit_exponent = dval;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tc->unit = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->loc.size = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->report_ID = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->loc.count = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10: /* Push */\n\t\t\t\thi = malloc(sizeof *hi, M_TEMP, M_WAITOK);\n\t\t\t\t*hi = s->cur;\n\t\t\t\tc->next = hi;\n\t\t\t\tbreak;\n\t\t\tcase 11: /* Pop */\n\t\t\t\thi = c->next;\n\t\t\t\toldpos = c->loc.pos;\n\t\t\t\ts->cur = *hi;\n\t\t\t\tc->loc.pos = oldpos;\n\t\t\t\tfree(hi, M_TEMP);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Global bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t\t/* Local */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage = dval;\n\t\t\t\tif (s->nu < MAXUSAGE)\n\t\t\t\t\ts->usages[s->nu++] = dval;\n\t\t\t\t/* else XXX */\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ts->minset = 1;\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->designator_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->designator_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->designator_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->string_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->string_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->string_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tc->set_delimiter = dval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Local bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"default bType=%d\\n\", bType);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hid_start_parse",
          "args": [
            "buf",
            "len",
            "1<<k"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nhid_clear_local __P((struct hid_item *));\nstruct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;\nint len;\n\nint\nhid_report_size(buf, len, k, idp)\n\tvoid *buf;\n\tint len;\n\tenum hid_kind k;\n\tu_int8_t *idp;\n{\n\tstruct hid_data *d;\n\tstruct hid_item h;\n\tint size, id;\n\n\tid = 0;\n\tfor (d = hid_start_parse(buf, len, 1<<k); hid_get_item(d, &h); )\n\t\tif (h.report_ID != 0)\n\t\t\tid = h.report_ID;\n\thid_end_parse(d);\n\tsize = h.loc.pos;\n\tif (id != 0) {\n\t\tsize += 8;\n\t\t*idp = id;\t/* XXX wrong */\n\t} else\n\t\t*idp = 0;\n\treturn ((size + 7) / 8);\n}"
  },
  {
    "function_name": "hid_get_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
    "lines": "123-372",
    "snippet": "int\nhid_get_item(s, h)\n\tstruct hid_data *s;\n\tstruct hid_item *h;\n{\n\tstruct hid_item *c = &s->cur;\n\tunsigned int bTag, bType, bSize;\n\tu_int32_t oldpos;\n\tu_char *data;\n\tint32_t dval;\n\tu_char *p;\n\tstruct hid_item *hi;\n\tint i;\n\n top:\n\tif (s->multimax != 0) {\n\t\tif (s->multi < s->multimax) {\n\t\t\tc->usage = s->usages[min(s->multi, s->nu-1)];\n\t\t\ts->multi++;\n\t\t\t*h = *c;\n\t\t\tc->loc.pos += c->loc.size;\n\t\t\th->next = 0;\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tc->loc.count = s->multimax;\n\t\t\ts->multimax = 0;\n\t\t\ts->nu = 0;\n\t\t\thid_clear_local(c);\n\t\t}\n\t}\n\tfor (;;) {\n\t\tp = s->p;\n\t\tif (p >= s->end)\n\t\t\treturn (0);\n\n\t\tbSize = *p++;\n\t\tif (bSize == 0xfe) {\n\t\t\t/* long item */\n\t\t\tbSize = *p++;\n\t\t\tbSize |= *p++ << 8;\n\t\t\tbTag = *p++;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t\tbType = 0xff; /* XXX what should it be */\n\t\t} else {\n\t\t\t/* short item */\n\t\t\tbTag = bSize >> 4;\n\t\t\tbType = (bSize >> 2) & 3;\n\t\t\tbSize &= 3;\n\t\t\tif (bSize == 3) bSize = 4;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t}\n\t\ts->p = p;\n\t\tswitch(bSize) {\n\t\tcase 0:\n\t\t\tdval = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdval = (int8_t)*data++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval = (int16_t)dval;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval |= *data++ << 16;\n\t\t\tdval |= *data++ << 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"BAD LENGTH %d\\n\", bSize);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tswitch (bType) {\n\t\tcase 0:\t\t\t/* Main */\n\t\t\tswitch (bTag) {\n\t\t\tcase 8:\t\t/* Input */\n\t\t\t\tif (!(s->kindset & (1 << hid_input)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_input;\n\t\t\t\tc->flags = dval;\n\t\t\tret:\n\t\t\t\tif (c->flags & HIO_VARIABLE) {\n\t\t\t\t\ts->multimax = c->loc.count;\n\t\t\t\t\ts->multi = 0;\n\t\t\t\t\tc->loc.count = 1;\n\t\t\t\t\tif (s->minset) {\n\t\t\t\t\t\tfor (i = c->usage_minimum; \n\t\t\t\t\t\t     i <= c->usage_maximum; \n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\ts->usages[s->nu] = i;\n\t\t\t\t\t\t\tif (s->nu < MAXUSAGE-1)\n\t\t\t\t\t\t\t\ts->nu++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts->minset = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t} else {\n\t\t\t\t\t*h = *c;\n\t\t\t\t\th->next = 0;\n\t\t\t\t\tc->loc.pos += \n\t\t\t\t\t\tc->loc.size * c->loc.count;\n\t\t\t\t\thid_clear_local(c);\n\t\t\t\t\ts->minset = 0;\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\tcase 9:\t\t/* Output */\n\t\t\t\tif (!(s->kindset & (1 << hid_output)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_output;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 10:\t/* Collection */\n\t\t\t\tc->kind = hid_collection;\n\t\t\t\tc->collection = dval;\n\t\t\t\tc->collevel++;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tcase 11:\t/* Feature */\n\t\t\t\tif (!(s->kindset & (1 << hid_feature)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_feature;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 12:\t/* End collection */\n\t\t\t\tc->kind = hid_endcollection;\n\t\t\t\tc->collevel--;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tdefault:\n\t\t\t\tprintf(\"Main bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\t\t/* Global */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tc->_usage_page = dval << 16;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tc->logical_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->logical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->unit_exponent = dval;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tc->unit = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->loc.size = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->report_ID = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->loc.count = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10: /* Push */\n\t\t\t\thi = malloc(sizeof *hi, M_TEMP, M_WAITOK);\n\t\t\t\t*hi = s->cur;\n\t\t\t\tc->next = hi;\n\t\t\t\tbreak;\n\t\t\tcase 11: /* Pop */\n\t\t\t\thi = c->next;\n\t\t\t\toldpos = c->loc.pos;\n\t\t\t\ts->cur = *hi;\n\t\t\t\tc->loc.pos = oldpos;\n\t\t\t\tfree(hi, M_TEMP);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Global bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t\t/* Local */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage = dval;\n\t\t\t\tif (s->nu < MAXUSAGE)\n\t\t\t\t\ts->usages[s->nu++] = dval;\n\t\t\t\t/* else XXX */\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ts->minset = 1;\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->designator_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->designator_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->designator_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->string_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->string_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->string_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tc->set_delimiter = dval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Local bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"default bType=%d\\n\", bType);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MAXUSAGE 100"
    ],
    "globals_used": [
      "hid_clear_local __P((struct hid_item *));",
      "struct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;",
      "int kindset;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"default bType=%d\\n\"",
            "bType"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "hi",
            "M_TEMP"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *hi",
            "M_TEMP",
            "M_WAITOK"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hid_clear_local",
          "args": [
            "c"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "hid_clear_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
          "lines": "79-93",
          "snippet": "Static void\nhid_clear_local(c)\n\tstruct hid_item *c;\n{\n\tc->usage = 0;\n\tc->usage_minimum = 0;\n\tc->usage_maximum = 0;\n\tc->designator_index = 0;\n\tc->designator_minimum = 0;\n\tc->designator_maximum = 0;\n\tc->string_index = 0;\n\tc->string_minimum = 0;\n\tc->string_maximum = 0;\n\tc->set_delimiter = 0;\n}",
          "includes": [
            "#include <dev/usb/hid.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static void",
            "hid_clear_local __P((struct hid_item *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nhid_clear_local __P((struct hid_item *));\n\nStatic void\nhid_clear_local(c)\n\tstruct hid_item *c;\n{\n\tc->usage = 0;\n\tc->usage_minimum = 0;\n\tc->usage_maximum = 0;\n\tc->designator_index = 0;\n\tc->designator_minimum = 0;\n\tc->designator_maximum = 0;\n\tc->string_index = 0;\n\tc->string_minimum = 0;\n\tc->string_maximum = 0;\n\tc->set_delimiter = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "s->multi",
            "s->nu-1"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MAXUSAGE 100\n\nhid_clear_local __P((struct hid_item *));\nstruct hid_data *\nhid_start_parse(d, len, kindset)\n\tvoid *d;\nint kindset;\n\nint\nhid_get_item(s, h)\n\tstruct hid_data *s;\n\tstruct hid_item *h;\n{\n\tstruct hid_item *c = &s->cur;\n\tunsigned int bTag, bType, bSize;\n\tu_int32_t oldpos;\n\tu_char *data;\n\tint32_t dval;\n\tu_char *p;\n\tstruct hid_item *hi;\n\tint i;\n\n top:\n\tif (s->multimax != 0) {\n\t\tif (s->multi < s->multimax) {\n\t\t\tc->usage = s->usages[min(s->multi, s->nu-1)];\n\t\t\ts->multi++;\n\t\t\t*h = *c;\n\t\t\tc->loc.pos += c->loc.size;\n\t\t\th->next = 0;\n\t\t\treturn (1);\n\t\t} else {\n\t\t\tc->loc.count = s->multimax;\n\t\t\ts->multimax = 0;\n\t\t\ts->nu = 0;\n\t\t\thid_clear_local(c);\n\t\t}\n\t}\n\tfor (;;) {\n\t\tp = s->p;\n\t\tif (p >= s->end)\n\t\t\treturn (0);\n\n\t\tbSize = *p++;\n\t\tif (bSize == 0xfe) {\n\t\t\t/* long item */\n\t\t\tbSize = *p++;\n\t\t\tbSize |= *p++ << 8;\n\t\t\tbTag = *p++;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t\tbType = 0xff; /* XXX what should it be */\n\t\t} else {\n\t\t\t/* short item */\n\t\t\tbTag = bSize >> 4;\n\t\t\tbType = (bSize >> 2) & 3;\n\t\t\tbSize &= 3;\n\t\t\tif (bSize == 3) bSize = 4;\n\t\t\tdata = p;\n\t\t\tp += bSize;\n\t\t}\n\t\ts->p = p;\n\t\tswitch(bSize) {\n\t\tcase 0:\n\t\t\tdval = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdval = (int8_t)*data++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval = (int16_t)dval;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdval = *data++;\n\t\t\tdval |= *data++ << 8;\n\t\t\tdval |= *data++ << 16;\n\t\t\tdval |= *data++ << 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"BAD LENGTH %d\\n\", bSize);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tswitch (bType) {\n\t\tcase 0:\t\t\t/* Main */\n\t\t\tswitch (bTag) {\n\t\t\tcase 8:\t\t/* Input */\n\t\t\t\tif (!(s->kindset & (1 << hid_input)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_input;\n\t\t\t\tc->flags = dval;\n\t\t\tret:\n\t\t\t\tif (c->flags & HIO_VARIABLE) {\n\t\t\t\t\ts->multimax = c->loc.count;\n\t\t\t\t\ts->multi = 0;\n\t\t\t\t\tc->loc.count = 1;\n\t\t\t\t\tif (s->minset) {\n\t\t\t\t\t\tfor (i = c->usage_minimum; \n\t\t\t\t\t\t     i <= c->usage_maximum; \n\t\t\t\t\t\t     i++) {\n\t\t\t\t\t\t\ts->usages[s->nu] = i;\n\t\t\t\t\t\t\tif (s->nu < MAXUSAGE-1)\n\t\t\t\t\t\t\t\ts->nu++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts->minset = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgoto top;\n\t\t\t\t} else {\n\t\t\t\t\t*h = *c;\n\t\t\t\t\th->next = 0;\n\t\t\t\t\tc->loc.pos += \n\t\t\t\t\t\tc->loc.size * c->loc.count;\n\t\t\t\t\thid_clear_local(c);\n\t\t\t\t\ts->minset = 0;\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\tcase 9:\t\t/* Output */\n\t\t\t\tif (!(s->kindset & (1 << hid_output)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_output;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 10:\t/* Collection */\n\t\t\t\tc->kind = hid_collection;\n\t\t\t\tc->collection = dval;\n\t\t\t\tc->collevel++;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tcase 11:\t/* Feature */\n\t\t\t\tif (!(s->kindset & (1 << hid_feature)))\n\t\t\t\t\tcontinue;\n\t\t\t\tc->kind = hid_feature;\n\t\t\t\tc->flags = dval;\n\t\t\t\tgoto ret;\n\t\t\tcase 12:\t/* End collection */\n\t\t\t\tc->kind = hid_endcollection;\n\t\t\t\tc->collevel--;\n\t\t\t\t*h = *c;\n\t\t\t\thid_clear_local(c);\n\t\t\t\ts->nu = 0;\n\t\t\t\treturn (1);\n\t\t\tdefault:\n\t\t\t\tprintf(\"Main bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\t\t/* Global */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tc->_usage_page = dval << 16;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tc->logical_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc->logical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->physical_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->unit_exponent = dval;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tc->unit = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->loc.size = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->report_ID = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->loc.count = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10: /* Push */\n\t\t\t\thi = malloc(sizeof *hi, M_TEMP, M_WAITOK);\n\t\t\t\t*hi = s->cur;\n\t\t\t\tc->next = hi;\n\t\t\t\tbreak;\n\t\t\tcase 11: /* Pop */\n\t\t\t\thi = c->next;\n\t\t\t\toldpos = c->loc.pos;\n\t\t\t\ts->cur = *hi;\n\t\t\t\tc->loc.pos = oldpos;\n\t\t\t\tfree(hi, M_TEMP);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Global bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t\t/* Local */\n\t\t\tswitch (bTag) {\n\t\t\tcase 0:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage = dval;\n\t\t\t\tif (s->nu < MAXUSAGE)\n\t\t\t\t\ts->usages[s->nu++] = dval;\n\t\t\t\t/* else XXX */\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ts->minset = 1;\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (bSize == 1) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xff);\n\t\t\t\telse if (bSize == 2) \n\t\t\t\t\tdval = c->_usage_page | (dval&0xffff);\n\t\t\t\tc->usage_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc->designator_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc->designator_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tc->designator_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tc->string_index = dval;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tc->string_minimum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tc->string_maximum = dval;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tc->set_delimiter = dval;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"Local bTag=%d\\n\", bTag);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"default bType=%d\\n\", bType);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "hid_end_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
    "lines": "111-121",
    "snippet": "void\nhid_end_parse(s)\n\tstruct hid_data *s;\n{\n\twhile (s->cur.next != NULL) {\n\t\tstruct hid_item *hi = s->cur.next->next;\n\t\tfree(s->cur.next, M_TEMP);\n\t\ts->cur.next = hi;\n\t}\n\tfree(s, M_TEMP);\n}",
    "includes": [
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "hid_clear_local __P((struct hid_item *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "s",
            "M_TEMP"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nhid_clear_local __P((struct hid_item *));\n\nvoid\nhid_end_parse(s)\n\tstruct hid_data *s;\n{\n\twhile (s->cur.next != NULL) {\n\t\tstruct hid_item *hi = s->cur.next->next;\n\t\tfree(s->cur.next, M_TEMP);\n\t\ts->cur.next = hi;\n\t}\n\tfree(s, M_TEMP);\n}"
  },
  {
    "function_name": "hid_clear_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/hid.c",
    "lines": "79-93",
    "snippet": "Static void\nhid_clear_local(c)\n\tstruct hid_item *c;\n{\n\tc->usage = 0;\n\tc->usage_minimum = 0;\n\tc->usage_maximum = 0;\n\tc->designator_index = 0;\n\tc->designator_minimum = 0;\n\tc->designator_maximum = 0;\n\tc->string_index = 0;\n\tc->string_minimum = 0;\n\tc->string_maximum = 0;\n\tc->set_delimiter = 0;\n}",
    "includes": [
      "#include <dev/usb/hid.h>",
      "#include <dev/usb/usbhid.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static void",
      "hid_clear_local __P((struct hid_item *));"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/hid.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic void;\nhid_clear_local __P((struct hid_item *));\n\nStatic void\nhid_clear_local(c)\n\tstruct hid_item *c;\n{\n\tc->usage = 0;\n\tc->usage_minimum = 0;\n\tc->usage_maximum = 0;\n\tc->designator_index = 0;\n\tc->designator_minimum = 0;\n\tc->designator_maximum = 0;\n\tc->string_index = 0;\n\tc->string_minimum = 0;\n\tc->string_maximum = 0;\n\tc->set_delimiter = 0;\n}"
  }
]