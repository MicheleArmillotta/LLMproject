[
  {
    "function_name": "isp_handle_ctio2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "1045-1227",
    "snippet": "static void\nisp_handle_ctio2(isp, ct)\n\tstruct ispsoftc *isp;\n\tct2_entry_t *ct;\n{\n\tISP_SCSI_XFER_T *xs;\n\tint pl = 3;\n\tchar *fmsg = NULL;\n\n\tif (ct->ct_reserved) {\n\t\txs = isp_find_xs(isp, ct->ct_reserved);\n\t\tif (xs == NULL)\n\t\t\tpl = 0;\n\t} else {\n\t\tpl = 2;\n\t\txs = NULL;\n\t}\n\n\tswitch(ct->ct_status & ~QLTM_SVALID) {\n\tcase CT_OK:\n\t\t/*\n\t\t * There are generally 2 possibilities as to why we'd get\n\t\t * this condition:\n\t\t * \tWe sent or received data.\n\t\t * \tWe sent status & command complete.\n\t\t */\n\n\t\tbreak;\n\n\tcase CT_BDR_MSG:\n\t\t/*\n\t\t * Bus Device Reset message received or the SCSI Bus has\n\t\t * been Reset; the firmware has gone to Bus Free.\n\t\t *\n\t\t * The firmware generates an async mailbox interupt to\n\t\t * notify us of this and returns outstanding CTIOs with this\n\t\t * status. These CTIOs are handled in that same way as\n\t\t * CT_ABORTED ones, so just fall through here.\n\t\t */\n\t\tfmsg = \"Bus Device Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_RESET:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Bus Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_ABORTED:\n\t\t/*\n\t\t * When an Abort message is received the firmware goes to\n\t\t * Bus Free and returns all outstanding CTIOs with the status\n\t\t * set, then sends us an Immediate Notify entry.\n\t\t */\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"ABORT TASK sent by Initiator\";\n\n\t\tPRINTF(\"%s: CTIO2 destroyed by %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_INVAL:\n\t\t/*\n\t\t * CTIO rejected by the firmware - invalid data direction.\n\t\t */\n\t\tPRINTF(\"%s: CTIO2 had wrong data directiond\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase CT_NOPATH:\n\t\t/*\n\t\t * CTIO rejected by the firmware due \"no path for the\n\t\t * nondisconnecting nexus specified\". This means that\n\t\t * we tried to access the bus while a non-disconnecting\n\t\t * command is in process.\n\t\t */\n\t\tPRINTF(\"%s: Firmware rejected CTIO2 for bad nexus %d->%d\\n\",\n\t\t    isp->isp_name, ct->ct_iid, ct->ct_lun);\n\t\tbreak;\n\n\tcase CT_RSELTMO:\n\t\tfmsg = \"Reselection\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TIMEOUT:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Command\";\n\t\tPRINTF(\"%s: Firmware timed out on %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_ERR:\n\t\tfmsg = \"Completed with Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_PHASE_ERROR:\t/* Bus phase sequence error */\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Phase Sequence Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TERMINATED:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"terminated by TERMINATE TRANSFER\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_LOGOUT:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Port Logout\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_PORTNOTAVAIL:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Port not available\";\n\tcase CT_NOACK:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"unacknowledged Immediate Notify pending\";\n\n\t\tPRINTF(\"%s: CTIO returned by f/w- %s\\n\", isp->isp_name, fmsg);\n#if\t0\n\t\t\tif (status & SENSEVALID) {\n\t\t\t\tbcopy((caddr_t) (cep + CTIO_SENSE_OFFSET),\n\t\t\t\t    (caddr_t) &cdp->cd_sensedata,\n\t\t\t\t    sizeof(scsi_sense_t));\n\t\t\t\tcdp->cd_flags |= CDF_SENSEVALID;\n\t\t\t}\n#endif\n\t\tbreak;\n\n\tcase CT_INVRXID:\n\t\t/*\n\t\t * CTIO rejected by the firmware because an invalid RX_ID.\n\t\t * Just print a message.\n\t\t */\n\t\tPRINTF(\"%s: CTIO2 completed with Invalid RX_ID 0x%x\\n\",\n\t\t    isp->isp_name, ct->ct_rxid);\n\t\tbreak;\n\n\tdefault:\n\t\tIDPRINTF(pl, (\"%s: Unknown CTIO status 0x%x\\n\", isp->isp_name,\n\t\t    ct->ct_status & ~QLTM_SVALID));\n\t\tbreak;\n\t}\n\n\tif (xs == NULL) {\n\t\t/*\n\t\t * There may be more than one CTIO for a data transfer,\n\t\t * or this may be a status CTIO we're not monitoring.\n\t\t *\n\t\t * The assumption is that they'll all be returned in the\n\t\t * order we got them.\n\t\t */\n\t\tif (ct->ct_reserved == 0) {\n\t\t\tif ((ct->ct_flags & CT_SENDSTATUS) == 0) {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: intermediate CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t} else {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: unmonitored CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t}\n\t\t} else {\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: NO xs for CTIO (handle 0x%x) status 0x%x\\n\",\n\t\t\t    isp->isp_name, ct->ct_reserved,\n\t\t\t    ct->ct_status & ~QLTM_SVALID));\n\t\t}\n\t} else {\n\t\tif (ct->ct_flags & CT_SENDSTATUS) {\n\t\t\t/*\n\t\t\t * Sent status and command complete.\n\t\t\t *\n\t\t\t * We're now really done with this command, so we\n\t\t\t * punt to the platform dependent layers because\n\t\t\t * only there can we do the appropriate command\n\t\t\t * complete thread synchronization.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: status CTIO complete\\n\", isp->isp_name));\n\t\t} else {\n\t\t\t/*\n\t\t\t * Final CTIO completed. Release DMA resources and\n\t\t\t * notify platform dependent layers.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: data CTIO complete\\n\", isp->isp_name));\n\t\t\tISP_DMAFREE(isp, xs, ct->ct_reserved);\n\t\t}\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);\n\t\t/*\n\t\t * The platform layer will destroy the handle if appropriate.\n\t\t */\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_TARGET_ACTION",
            "ct"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_DMAFREE",
          "args": [
            "isp",
            "xs",
            "ct->ct_reserved"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: data CTIO complete\\n\", isp->isp_name)"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: status CTIO complete\\n\", isp->isp_name)"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: NO xs for CTIO (handle 0x%x) status 0x%x\\n\",\n\t\t\t    isp->isp_name, ct->ct_reserved,\n\t\t\t    ct->ct_status & ~QLTM_SVALID)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: unmonitored CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name)"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: intermediate CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name)"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: Unknown CTIO status 0x%x\\n\", isp->isp_name,\n\t\t    ct->ct_status & ~QLTM_SVALID)"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: CTIO2 completed with Invalid RX_ID 0x%x\\n\"",
            "isp->isp_name",
            "ct->ct_rxid"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t) (cep + CTIO_SENSE_OFFSET)",
            "(caddr_t) &cdp->cd_sensedata",
            "sizeof(scsi_sense_t)"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cep + CTIO_SENSE_OFFSET"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: CTIO returned by f/w- %s\\n\"",
            "isp->isp_name",
            "fmsg"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Firmware timed out on %s\\n\"",
            "isp->isp_name",
            "fmsg"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Firmware rejected CTIO2 for bad nexus %d->%d\\n\"",
            "isp->isp_name",
            "ct->ct_iid",
            "ct->ct_lun"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: CTIO2 had wrong data directiond\\n\"",
            "isp->isp_name"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: CTIO2 destroyed by %s\\n\"",
            "isp->isp_name",
            "fmsg"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_find_xs",
          "args": [
            "isp",
            "ct->ct_reserved"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "isp_find_xs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "209-219",
          "snippet": "static INLINE ISP_SCSI_XFER_T *\nisp_find_xs(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {\n\t\treturn (NULL);\n\t} else {\n\t\treturn (isp->isp_xflist[handle - 1]);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE ISP_SCSI_XFER_T *\nisp_find_xs(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {\n\t\treturn (NULL);\n\t} else {\n\t\treturn (isp->isp_xflist[handle - 1]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_handle_ctio2(isp, ct)\n\tstruct ispsoftc *isp;\n\tct2_entry_t *ct;\n{\n\tISP_SCSI_XFER_T *xs;\n\tint pl = 3;\n\tchar *fmsg = NULL;\n\n\tif (ct->ct_reserved) {\n\t\txs = isp_find_xs(isp, ct->ct_reserved);\n\t\tif (xs == NULL)\n\t\t\tpl = 0;\n\t} else {\n\t\tpl = 2;\n\t\txs = NULL;\n\t}\n\n\tswitch(ct->ct_status & ~QLTM_SVALID) {\n\tcase CT_OK:\n\t\t/*\n\t\t * There are generally 2 possibilities as to why we'd get\n\t\t * this condition:\n\t\t * \tWe sent or received data.\n\t\t * \tWe sent status & command complete.\n\t\t */\n\n\t\tbreak;\n\n\tcase CT_BDR_MSG:\n\t\t/*\n\t\t * Bus Device Reset message received or the SCSI Bus has\n\t\t * been Reset; the firmware has gone to Bus Free.\n\t\t *\n\t\t * The firmware generates an async mailbox interupt to\n\t\t * notify us of this and returns outstanding CTIOs with this\n\t\t * status. These CTIOs are handled in that same way as\n\t\t * CT_ABORTED ones, so just fall through here.\n\t\t */\n\t\tfmsg = \"Bus Device Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_RESET:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Bus Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_ABORTED:\n\t\t/*\n\t\t * When an Abort message is received the firmware goes to\n\t\t * Bus Free and returns all outstanding CTIOs with the status\n\t\t * set, then sends us an Immediate Notify entry.\n\t\t */\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"ABORT TASK sent by Initiator\";\n\n\t\tPRINTF(\"%s: CTIO2 destroyed by %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_INVAL:\n\t\t/*\n\t\t * CTIO rejected by the firmware - invalid data direction.\n\t\t */\n\t\tPRINTF(\"%s: CTIO2 had wrong data directiond\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase CT_NOPATH:\n\t\t/*\n\t\t * CTIO rejected by the firmware due \"no path for the\n\t\t * nondisconnecting nexus specified\". This means that\n\t\t * we tried to access the bus while a non-disconnecting\n\t\t * command is in process.\n\t\t */\n\t\tPRINTF(\"%s: Firmware rejected CTIO2 for bad nexus %d->%d\\n\",\n\t\t    isp->isp_name, ct->ct_iid, ct->ct_lun);\n\t\tbreak;\n\n\tcase CT_RSELTMO:\n\t\tfmsg = \"Reselection\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TIMEOUT:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Command\";\n\t\tPRINTF(\"%s: Firmware timed out on %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_ERR:\n\t\tfmsg = \"Completed with Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_PHASE_ERROR:\t/* Bus phase sequence error */\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Phase Sequence Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TERMINATED:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"terminated by TERMINATE TRANSFER\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_LOGOUT:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Port Logout\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_PORTNOTAVAIL:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Port not available\";\n\tcase CT_NOACK:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"unacknowledged Immediate Notify pending\";\n\n\t\tPRINTF(\"%s: CTIO returned by f/w- %s\\n\", isp->isp_name, fmsg);\n#if\t0\n\t\t\tif (status & SENSEVALID) {\n\t\t\t\tbcopy((caddr_t) (cep + CTIO_SENSE_OFFSET),\n\t\t\t\t    (caddr_t) &cdp->cd_sensedata,\n\t\t\t\t    sizeof(scsi_sense_t));\n\t\t\t\tcdp->cd_flags |= CDF_SENSEVALID;\n\t\t\t}\n#endif\n\t\tbreak;\n\n\tcase CT_INVRXID:\n\t\t/*\n\t\t * CTIO rejected by the firmware because an invalid RX_ID.\n\t\t * Just print a message.\n\t\t */\n\t\tPRINTF(\"%s: CTIO2 completed with Invalid RX_ID 0x%x\\n\",\n\t\t    isp->isp_name, ct->ct_rxid);\n\t\tbreak;\n\n\tdefault:\n\t\tIDPRINTF(pl, (\"%s: Unknown CTIO status 0x%x\\n\", isp->isp_name,\n\t\t    ct->ct_status & ~QLTM_SVALID));\n\t\tbreak;\n\t}\n\n\tif (xs == NULL) {\n\t\t/*\n\t\t * There may be more than one CTIO for a data transfer,\n\t\t * or this may be a status CTIO we're not monitoring.\n\t\t *\n\t\t * The assumption is that they'll all be returned in the\n\t\t * order we got them.\n\t\t */\n\t\tif (ct->ct_reserved == 0) {\n\t\t\tif ((ct->ct_flags & CT_SENDSTATUS) == 0) {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: intermediate CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t} else {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: unmonitored CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t}\n\t\t} else {\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: NO xs for CTIO (handle 0x%x) status 0x%x\\n\",\n\t\t\t    isp->isp_name, ct->ct_reserved,\n\t\t\t    ct->ct_status & ~QLTM_SVALID));\n\t\t}\n\t} else {\n\t\tif (ct->ct_flags & CT_SENDSTATUS) {\n\t\t\t/*\n\t\t\t * Sent status and command complete.\n\t\t\t *\n\t\t\t * We're now really done with this command, so we\n\t\t\t * punt to the platform dependent layers because\n\t\t\t * only there can we do the appropriate command\n\t\t\t * complete thread synchronization.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: status CTIO complete\\n\", isp->isp_name));\n\t\t} else {\n\t\t\t/*\n\t\t\t * Final CTIO completed. Release DMA resources and\n\t\t\t * notify platform dependent layers.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: data CTIO complete\\n\", isp->isp_name));\n\t\t\tISP_DMAFREE(isp, xs, ct->ct_reserved);\n\t\t}\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);\n\t\t/*\n\t\t * The platform layer will destroy the handle if appropriate.\n\t\t */\n\t}\n}"
  },
  {
    "function_name": "isp_handle_ctio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "867-1043",
    "snippet": "static void\nisp_handle_ctio(isp, ct)\n\tstruct ispsoftc *isp;\n\tct_entry_t *ct;\n{\n\tISP_SCSI_XFER_T *xs;\n\tint pl = 0;\n\tchar *fmsg = NULL;\n\n\tif (ct->ct_reserved) {\n\t\txs = isp_find_xs(isp, ct->ct_reserved);\n\t\tif (xs == NULL)\n\t\t\tpl = 0;\n\t} else {\n\t\tpl = 2;\n\t\txs = NULL;\n\t}\n\n\tswitch(ct->ct_status & ~QLTM_SVALID) {\n\tcase CT_OK:\n\t\t/*\n\t\t * There are generally 3 possibilities as to why we'd get\n\t\t * this condition:\n\t\t * \tWe disconnected after receiving a CDB.\n\t\t * \tWe sent or received data.\n\t\t * \tWe sent status & command complete.\n\t\t */\n\n\t\tif ((ct->ct_flags & CT_DATAMASK) == CT_NO_DATA) {\n\t\t\t/*\n\t\t\t * Nothing to do in this case.\n\t\t\t */\n\t\t\tIDPRINTF(pl, (\"%s: CTIO- initiator disconnected OK\\n\",\n\t\t\t    isp->isp_name));\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase CT_BDR_MSG:\n\t\t/*\n\t\t * Bus Device Reset message received or the SCSI Bus has\n\t\t * been Reset; the firmware has gone to Bus Free.\n\t\t *\n\t\t * The firmware generates an async mailbox interupt to\n\t\t * notify us of this and returns outstanding CTIOs with this\n\t\t * status. These CTIOs are handled in that same way as\n\t\t * CT_ABORTED ones, so just fall through here.\n\t\t */\n\t\tfmsg = \"Bus Device Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_RESET:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Bus Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_ABORTED:\n\t\t/*\n\t\t * When an Abort message is received the firmware goes to\n\t\t * Bus Free and returns all outstanding CTIOs with the status\n\t\t * set, then sends us an Immediate Notify entry.\n\t\t */\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"ABORT TASK sent by Initiator\";\n\n\t\tPRINTF(\"%s: CTIO destroyed by %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_INVAL:\n\t\t/*\n\t\t * CTIO rejected by the firmware due to disabled lun.\n\t\t * \"Cannot Happen\".\n\t\t */\n\t\tPRINTF(\"%s: Firmware rejected CTIO for disabled lun %d\\n\",\n\t\t    isp->isp_name, ct->ct_lun);\n\t\tbreak;\n\n\tcase CT_NOPATH:\n\t\t/*\n\t\t * CTIO rejected by the firmware due \"no path for the\n\t\t * nondisconnecting nexus specified\". This means that\n\t\t * we tried to access the bus while a non-disconnecting\n\t\t * command is in process.\n\t\t */\n\t\tPRINTF(\"%s: Firmware rejected CTIO for bad nexus %d/%d/%d\\n\",\n\t\t    isp->isp_name, ct->ct_iid, ct->ct_tgt, ct->ct_lun);\n\t\tbreak;\n\n\tcase CT_RSELTMO:\n\t\tfmsg = \"Reselection\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TIMEOUT:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Command\";\n\t\tPRINTF(\"%s: Firmware timed out on %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_ERR:\n\t\tfmsg = \"Completed with Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_PHASE_ERROR:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Phase Sequence Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TERMINATED:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"terminated by TERMINATE TRANSFER\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_NOACK:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"unacknowledged Immediate Notify pending\";\n\n\t\tPRINTF(\"%s: CTIO returned by f/w- %s\\n\", isp->isp_name, fmsg);\n#if\t0\n\t\t\tif (status & SENSEVALID) {\n\t\t\t\tbcopy((caddr_t) (cep + CTIO_SENSE_OFFSET),\n\t\t\t\t    (caddr_t) &cdp->cd_sensedata,\n\t\t\t\t    sizeof(scsi_sense_t));\n\t\t\t\tcdp->cd_flags |= CDF_SENSEVALID;\n\t\t\t}\n#endif\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown CTIO status 0x%x\\n\", isp->isp_name,\n\t\t    ct->ct_status & ~QLTM_SVALID);\n\t\tbreak;\n\t}\n\n\tif (xs == NULL) {\n\t\t/*\n\t\t * There may be more than one CTIO for a data transfer,\n\t\t * or this may be a status CTIO we're not monitoring.\n\t\t *\n\t\t * The assumption is that they'll all be returned in the\n\t\t * order we got them.\n\t\t */\n\t\tif (ct->ct_reserved == 0) {\n\t\t\tif ((ct->ct_flags & CT_SENDSTATUS) == 0) {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: intermediate CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t} else {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: unmonitored CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t}\n\t\t} else {\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: NO xs for CTIO (handle 0x%x) status 0x%x\\n\",\n\t\t\t    isp->isp_name, ct->ct_reserved,\n\t\t\t    ct->ct_status & ~QLTM_SVALID));\n\t\t}\n\t} else {\n\t\tif (ct->ct_flags & CT_SENDSTATUS) {\n\t\t\t/*\n\t\t\t * Sent status and command complete.\n\t\t\t *\n\t\t\t * We're now really done with this command, so we\n\t\t\t * punt to the platform dependent layers because\n\t\t\t * only there can we do the appropriate command\n\t\t\t * complete thread synchronization.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: status CTIO complete\\n\", isp->isp_name));\n\t\t} else {\n\t\t\t/*\n\t\t\t * Final CTIO completed. Release DMA resources and\n\t\t\t * notify platform dependent layers.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: data CTIO complete\\n\", isp->isp_name));\n\t\t\tISP_DMAFREE(isp, xs, ct->ct_reserved);\n\t\t}\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);\n\t\t/*\n\t\t * The platform layer will destroy the handle if appropriate.\n\t\t */\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_TARGET_ACTION",
            "ct"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_DMAFREE",
          "args": [
            "isp",
            "xs",
            "ct->ct_reserved"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: data CTIO complete\\n\", isp->isp_name)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: status CTIO complete\\n\", isp->isp_name)"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: NO xs for CTIO (handle 0x%x) status 0x%x\\n\",\n\t\t\t    isp->isp_name, ct->ct_reserved,\n\t\t\t    ct->ct_status & ~QLTM_SVALID)"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: unmonitored CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: intermediate CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name)"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Unknown CTIO status 0x%x\\n\"",
            "isp->isp_name",
            "ct->ct_status & ~QLTM_SVALID"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t) (cep + CTIO_SENSE_OFFSET)",
            "(caddr_t) &cdp->cd_sensedata",
            "sizeof(scsi_sense_t)"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cep + CTIO_SENSE_OFFSET"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: CTIO returned by f/w- %s\\n\"",
            "isp->isp_name",
            "fmsg"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Firmware timed out on %s\\n\"",
            "isp->isp_name",
            "fmsg"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Firmware rejected CTIO for bad nexus %d/%d/%d\\n\"",
            "isp->isp_name",
            "ct->ct_iid",
            "ct->ct_tgt",
            "ct->ct_lun"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Firmware rejected CTIO for disabled lun %d\\n\"",
            "isp->isp_name",
            "ct->ct_lun"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: CTIO destroyed by %s\\n\"",
            "isp->isp_name",
            "fmsg"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IDPRINTF",
          "args": [
            "pl",
            "(\"%s: CTIO- initiator disconnected OK\\n\",\n\t\t\t    isp->isp_name)"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_find_xs",
          "args": [
            "isp",
            "ct->ct_reserved"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "isp_find_xs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "209-219",
          "snippet": "static INLINE ISP_SCSI_XFER_T *\nisp_find_xs(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {\n\t\treturn (NULL);\n\t} else {\n\t\treturn (isp->isp_xflist[handle - 1]);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE ISP_SCSI_XFER_T *\nisp_find_xs(isp, handle)\n\tstruct ispsoftc *isp;\n\tu_int32_t handle;\n{\n\tif (handle < 1 || handle > (u_int32_t) isp->isp_maxcmds) {\n\t\treturn (NULL);\n\t} else {\n\t\treturn (isp->isp_xflist[handle - 1]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_handle_ctio(isp, ct)\n\tstruct ispsoftc *isp;\n\tct_entry_t *ct;\n{\n\tISP_SCSI_XFER_T *xs;\n\tint pl = 0;\n\tchar *fmsg = NULL;\n\n\tif (ct->ct_reserved) {\n\t\txs = isp_find_xs(isp, ct->ct_reserved);\n\t\tif (xs == NULL)\n\t\t\tpl = 0;\n\t} else {\n\t\tpl = 2;\n\t\txs = NULL;\n\t}\n\n\tswitch(ct->ct_status & ~QLTM_SVALID) {\n\tcase CT_OK:\n\t\t/*\n\t\t * There are generally 3 possibilities as to why we'd get\n\t\t * this condition:\n\t\t * \tWe disconnected after receiving a CDB.\n\t\t * \tWe sent or received data.\n\t\t * \tWe sent status & command complete.\n\t\t */\n\n\t\tif ((ct->ct_flags & CT_DATAMASK) == CT_NO_DATA) {\n\t\t\t/*\n\t\t\t * Nothing to do in this case.\n\t\t\t */\n\t\t\tIDPRINTF(pl, (\"%s: CTIO- initiator disconnected OK\\n\",\n\t\t\t    isp->isp_name));\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase CT_BDR_MSG:\n\t\t/*\n\t\t * Bus Device Reset message received or the SCSI Bus has\n\t\t * been Reset; the firmware has gone to Bus Free.\n\t\t *\n\t\t * The firmware generates an async mailbox interupt to\n\t\t * notify us of this and returns outstanding CTIOs with this\n\t\t * status. These CTIOs are handled in that same way as\n\t\t * CT_ABORTED ones, so just fall through here.\n\t\t */\n\t\tfmsg = \"Bus Device Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_RESET:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Bus Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_ABORTED:\n\t\t/*\n\t\t * When an Abort message is received the firmware goes to\n\t\t * Bus Free and returns all outstanding CTIOs with the status\n\t\t * set, then sends us an Immediate Notify entry.\n\t\t */\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"ABORT TASK sent by Initiator\";\n\n\t\tPRINTF(\"%s: CTIO destroyed by %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_INVAL:\n\t\t/*\n\t\t * CTIO rejected by the firmware due to disabled lun.\n\t\t * \"Cannot Happen\".\n\t\t */\n\t\tPRINTF(\"%s: Firmware rejected CTIO for disabled lun %d\\n\",\n\t\t    isp->isp_name, ct->ct_lun);\n\t\tbreak;\n\n\tcase CT_NOPATH:\n\t\t/*\n\t\t * CTIO rejected by the firmware due \"no path for the\n\t\t * nondisconnecting nexus specified\". This means that\n\t\t * we tried to access the bus while a non-disconnecting\n\t\t * command is in process.\n\t\t */\n\t\tPRINTF(\"%s: Firmware rejected CTIO for bad nexus %d/%d/%d\\n\",\n\t\t    isp->isp_name, ct->ct_iid, ct->ct_tgt, ct->ct_lun);\n\t\tbreak;\n\n\tcase CT_RSELTMO:\n\t\tfmsg = \"Reselection\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TIMEOUT:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Command\";\n\t\tPRINTF(\"%s: Firmware timed out on %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_ERR:\n\t\tfmsg = \"Completed with Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_PHASE_ERROR:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Phase Sequence Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TERMINATED:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"terminated by TERMINATE TRANSFER\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_NOACK:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"unacknowledged Immediate Notify pending\";\n\n\t\tPRINTF(\"%s: CTIO returned by f/w- %s\\n\", isp->isp_name, fmsg);\n#if\t0\n\t\t\tif (status & SENSEVALID) {\n\t\t\t\tbcopy((caddr_t) (cep + CTIO_SENSE_OFFSET),\n\t\t\t\t    (caddr_t) &cdp->cd_sensedata,\n\t\t\t\t    sizeof(scsi_sense_t));\n\t\t\t\tcdp->cd_flags |= CDF_SENSEVALID;\n\t\t\t}\n#endif\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown CTIO status 0x%x\\n\", isp->isp_name,\n\t\t    ct->ct_status & ~QLTM_SVALID);\n\t\tbreak;\n\t}\n\n\tif (xs == NULL) {\n\t\t/*\n\t\t * There may be more than one CTIO for a data transfer,\n\t\t * or this may be a status CTIO we're not monitoring.\n\t\t *\n\t\t * The assumption is that they'll all be returned in the\n\t\t * order we got them.\n\t\t */\n\t\tif (ct->ct_reserved == 0) {\n\t\t\tif ((ct->ct_flags & CT_SENDSTATUS) == 0) {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: intermediate CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t} else {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: unmonitored CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t}\n\t\t} else {\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: NO xs for CTIO (handle 0x%x) status 0x%x\\n\",\n\t\t\t    isp->isp_name, ct->ct_reserved,\n\t\t\t    ct->ct_status & ~QLTM_SVALID));\n\t\t}\n\t} else {\n\t\tif (ct->ct_flags & CT_SENDSTATUS) {\n\t\t\t/*\n\t\t\t * Sent status and command complete.\n\t\t\t *\n\t\t\t * We're now really done with this command, so we\n\t\t\t * punt to the platform dependent layers because\n\t\t\t * only there can we do the appropriate command\n\t\t\t * complete thread synchronization.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: status CTIO complete\\n\", isp->isp_name));\n\t\t} else {\n\t\t\t/*\n\t\t\t * Final CTIO completed. Release DMA resources and\n\t\t\t * notify platform dependent layers.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: data CTIO complete\\n\", isp->isp_name));\n\t\t\tISP_DMAFREE(isp, xs, ct->ct_reserved);\n\t\t}\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);\n\t\t/*\n\t\t * The platform layer will destroy the handle if appropriate.\n\t\t */\n\t}\n}"
  },
  {
    "function_name": "isp_handle_atio2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "781-865",
    "snippet": "static void\nisp_handle_atio2(isp, aep)\n\tstruct ispsoftc *isp;\n\tat2_entry_t *aep;\n{\n\tint lun;\n#ifdef\tISP2100_SCCLUN\n\tlun = aep->at_scclun;\n#else\n\tlun = aep->at_lun;\n#endif\n\t/*\n\t * The firmware status (except for the QLTM_SVALID bit) indicates\n\t * why this ATIO was sent to us.\n\t *\n\t * If QLTM_SVALID is set, the firware has recommended Sense Data.\n\t *\n\t * If the DISCONNECTS DISABLED bit is set in the flags field,\n\t * we're still connected on the SCSI bus - i.e. the initiator\n\t * did not set DiscPriv in the identify message. We don't care\n\t * about this so it's ignored.\n\t */\n\n\tswitch(aep->at_status & ~QLTM_SVALID) {\n\tcase AT_PATH_INVALID:\n\t\t/*\n\t\t * ATIO rejected by the firmware due to disabled lun.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO2 for disabled lun %d\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\tcase AT_NOCAP:\n\t\t/*\n\t\t * Requested Capability not available\n\t\t * We sent an ATIO that overflowed the firmware's\n\t\t * command resource count.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO2 for lun %d because of command count\"\n\t\t    \" overflow\\n\", isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_BDR_MSG:\n\t\t/*\n\t\t * If we send an ATIO to the firmware to increment\n\t\t * its command resource count, and the firmware is\n\t\t * recovering from a Bus Device Reset, it returns\n\t\t * the ATIO with this status. We set the command\n\t\t * resource count in the Enable Lun entry and no\n\t\t * not increment it. Therefore we should never get\n\t\t * this status here.\n\t\t */\n\t\tPRINTF(\"%s: ATIO2 returned for lun %d because it was in the \"\n\t\t    \" middle of coping with a Bus Device Reset\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_CDB:\t\t/* Got a CDB */\n\t\t/*\n\t\t * Punt to platform specific layer.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, aep);\n\t\tbreak;\n\n\tcase AT_RESET:\n\t\t/*\n\t\t * A bus reset came along an blew away this command. Why\n\t\t * they do this in addition the async event code stuff,\n\t\t * I dunno.\n\t\t *\n\t\t * Ignore it because the async event will clear things\n\t\t * up for us.\n\t\t */\n\t\tPRINTF(\"%s: ATIO2 returned for lun %d from initiator %d because\"\n\t\t    \" a Bus Reset occurred\\n\", isp->isp_name, lun,\n\t\t    aep->at_iid);\n\t\tbreak;\n\n\n\tdefault:\n\t\tPRINTF(\"%s: Unknown ATIO2 status 0x%x from initiator %d for lun\"\n\t\t    \" %d\\n\", isp->isp_name, aep->at_status, aep->at_iid, lun);\n\t\t(void) isp_target_put_atio(isp, aep->at_iid, 0, lun, 0, 0);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_target_put_atio",
          "args": [
            "isp",
            "aep->at_iid",
            "0",
            "lun",
            "0",
            "0"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "isp_target_put_atio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "365-400",
          "snippet": "int\nisp_target_put_atio(isp, iid, tgt, lun, ttype, tval)\n\tstruct ispsoftc *isp;\n\tint iid;\n\tint tgt;\n\tint lun;\n\tint ttype;\n\tint tval;\n{\n\tunion {\n\t\tat_entry_t _atio;\n\t\tat2_entry_t _atio2;\n\t} atun;\n\n\tMEMZERO(&atun, sizeof atun);\n\tif (IS_FC(isp)) {\n\t\tatun._atio2.at_header.rqs_entry_type = RQSTYPE_ATIO2;\n\t\tatun._atio2.at_header.rqs_entry_count = 1;\n#ifdef ISP2100_SCCLUN\n\t\tatun._atio2.at_scclun = (uint16_t) lun;\n#else\n\t\tatun._atio2.at_lun = (uint8_t) lun;\n#endif\n\t\tatun._atio2.at_status = CT_OK;\n\t} else {\n\t\tatun._atio.at_header.rqs_entry_type = RQSTYPE_ATIO;\n\t\tatun._atio.at_header.rqs_entry_count = 1;\n\t\tatun._atio.at_iid = iid;\n\t\tatun._atio.at_tgt = tgt;\n\t\tatun._atio.at_lun = lun;\n\t\tatun._atio.at_tag_type = ttype;\n\t\tatun._atio.at_tag_val = tval;\n\t\tatun._atio.at_status = CT_OK;\n\t}\n\treturn (isp_target_put_entry(isp, &atun));\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nint\nisp_target_put_atio(isp, iid, tgt, lun, ttype, tval)\n\tstruct ispsoftc *isp;\n\tint iid;\n\tint tgt;\n\tint lun;\n\tint ttype;\n\tint tval;\n{\n\tunion {\n\t\tat_entry_t _atio;\n\t\tat2_entry_t _atio2;\n\t} atun;\n\n\tMEMZERO(&atun, sizeof atun);\n\tif (IS_FC(isp)) {\n\t\tatun._atio2.at_header.rqs_entry_type = RQSTYPE_ATIO2;\n\t\tatun._atio2.at_header.rqs_entry_count = 1;\n#ifdef ISP2100_SCCLUN\n\t\tatun._atio2.at_scclun = (uint16_t) lun;\n#else\n\t\tatun._atio2.at_lun = (uint8_t) lun;\n#endif\n\t\tatun._atio2.at_status = CT_OK;\n\t} else {\n\t\tatun._atio.at_header.rqs_entry_type = RQSTYPE_ATIO;\n\t\tatun._atio.at_header.rqs_entry_count = 1;\n\t\tatun._atio.at_iid = iid;\n\t\tatun._atio.at_tgt = tgt;\n\t\tatun._atio.at_lun = lun;\n\t\tatun._atio.at_tag_type = ttype;\n\t\tatun._atio.at_tag_val = tval;\n\t\tatun._atio.at_status = CT_OK;\n\t}\n\treturn (isp_target_put_entry(isp, &atun));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Unknown ATIO2 status 0x%x from initiator %d for lun\"\n\t\t    \" %d\\n\"",
            "isp->isp_name",
            "aep->at_status",
            "aep->at_iid",
            "lun"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: ATIO2 returned for lun %d from initiator %d because\"\n\t\t    \" a Bus Reset occurred\\n\"",
            "isp->isp_name",
            "lun",
            "aep->at_iid"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_TARGET_ACTION",
            "aep"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: ATIO2 returned for lun %d because it was in the \"\n\t\t    \" middle of coping with a Bus Device Reset\\n\"",
            "isp->isp_name",
            "lun"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: rejected ATIO2 for lun %d because of command count\"\n\t\t    \" overflow\\n\"",
            "isp->isp_name",
            "lun"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: rejected ATIO2 for disabled lun %d\\n\"",
            "isp->isp_name",
            "lun"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_handle_atio2(isp, aep)\n\tstruct ispsoftc *isp;\n\tat2_entry_t *aep;\n{\n\tint lun;\n#ifdef\tISP2100_SCCLUN\n\tlun = aep->at_scclun;\n#else\n\tlun = aep->at_lun;\n#endif\n\t/*\n\t * The firmware status (except for the QLTM_SVALID bit) indicates\n\t * why this ATIO was sent to us.\n\t *\n\t * If QLTM_SVALID is set, the firware has recommended Sense Data.\n\t *\n\t * If the DISCONNECTS DISABLED bit is set in the flags field,\n\t * we're still connected on the SCSI bus - i.e. the initiator\n\t * did not set DiscPriv in the identify message. We don't care\n\t * about this so it's ignored.\n\t */\n\n\tswitch(aep->at_status & ~QLTM_SVALID) {\n\tcase AT_PATH_INVALID:\n\t\t/*\n\t\t * ATIO rejected by the firmware due to disabled lun.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO2 for disabled lun %d\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\tcase AT_NOCAP:\n\t\t/*\n\t\t * Requested Capability not available\n\t\t * We sent an ATIO that overflowed the firmware's\n\t\t * command resource count.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO2 for lun %d because of command count\"\n\t\t    \" overflow\\n\", isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_BDR_MSG:\n\t\t/*\n\t\t * If we send an ATIO to the firmware to increment\n\t\t * its command resource count, and the firmware is\n\t\t * recovering from a Bus Device Reset, it returns\n\t\t * the ATIO with this status. We set the command\n\t\t * resource count in the Enable Lun entry and no\n\t\t * not increment it. Therefore we should never get\n\t\t * this status here.\n\t\t */\n\t\tPRINTF(\"%s: ATIO2 returned for lun %d because it was in the \"\n\t\t    \" middle of coping with a Bus Device Reset\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_CDB:\t\t/* Got a CDB */\n\t\t/*\n\t\t * Punt to platform specific layer.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, aep);\n\t\tbreak;\n\n\tcase AT_RESET:\n\t\t/*\n\t\t * A bus reset came along an blew away this command. Why\n\t\t * they do this in addition the async event code stuff,\n\t\t * I dunno.\n\t\t *\n\t\t * Ignore it because the async event will clear things\n\t\t * up for us.\n\t\t */\n\t\tPRINTF(\"%s: ATIO2 returned for lun %d from initiator %d because\"\n\t\t    \" a Bus Reset occurred\\n\", isp->isp_name, lun,\n\t\t    aep->at_iid);\n\t\tbreak;\n\n\n\tdefault:\n\t\tPRINTF(\"%s: Unknown ATIO2 status 0x%x from initiator %d for lun\"\n\t\t    \" %d\\n\", isp->isp_name, aep->at_status, aep->at_iid, lun);\n\t\t(void) isp_target_put_atio(isp, aep->at_iid, 0, lun, 0, 0);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "isp_handle_atio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "697-779",
    "snippet": "static void\nisp_handle_atio(isp, aep)\n\tstruct ispsoftc *isp;\n\tat_entry_t *aep;\n{\n\tint lun;\n\tlun = aep->at_lun;\n\t/*\n\t * The firmware status (except for the QLTM_SVALID bit) indicates\n\t * why this ATIO was sent to us.\n\t *\n\t * If QLTM_SVALID is set, the firware has recommended Sense Data.\n\t *\n\t * If the DISCONNECTS DISABLED bit is set in the flags field,\n\t * we're still connected on the SCSI bus - i.e. the initiator\n\t * did not set DiscPriv in the identify message. We don't care\n\t * about this so it's ignored.\n\t */\n\n\tswitch(aep->at_status & ~QLTM_SVALID) {\n\tcase AT_PATH_INVALID:\n\t\t/*\n\t\t * ATIO rejected by the firmware due to disabled lun.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO for disabled lun %d\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\tcase AT_NOCAP:\n\t\t/*\n\t\t * Requested Capability not available\n\t\t * We sent an ATIO that overflowed the firmware's\n\t\t * command resource count.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO for lun %d because of command count\"\n\t\t    \" overflow\\n\", isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_BDR_MSG:\n\t\t/*\n\t\t * If we send an ATIO to the firmware to increment\n\t\t * its command resource count, and the firmware is\n\t\t * recovering from a Bus Device Reset, it returns\n\t\t * the ATIO with this status. We set the command\n\t\t * resource count in the Enable Lun entry and no\n\t\t * not increment it. Therefore we should never get\n\t\t * this status here.\n\t\t */\n\t\tPRINTF(\"%s: ATIO returned for lun %d because it was in the \"\n\t\t    \" middle of coping with a Bus Device Reset\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_CDB:\t\t/* Got a CDB */\n\tcase AT_PHASE_ERROR:\t/* Bus Phase Sequence Error */\n\t\t/*\n\t\t * Punt to platform specific layer.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, aep);\n\t\tbreak;\n\n\tcase AT_RESET:\n\t\t/*\n\t\t * A bus reset came along an blew away this command. Why\n\t\t * they do this in addition the async event code stuff,\n\t\t * I dunno.\n\t\t *\n\t\t * Ignore it because the async event will clear things\n\t\t * up for us.\n\t\t */\n\t\tPRINTF(\"%s: ATIO returned for lun %d from initiator %d because\"\n\t\t    \" a Bus Reset occurred\\n\", isp->isp_name, lun,\n\t\t    aep->at_iid);\n\t\tbreak;\n\n\n\tdefault:\n\t\tPRINTF(\"%s: Unknown ATIO status 0x%x from initiator %d for lun\"\n\t\t    \" %d\\n\", isp->isp_name, aep->at_status, aep->at_iid, lun);\n\t\t(void) isp_target_put_atio(isp, aep->at_iid, aep->at_tgt,\n\t\t    lun, aep->at_tag_type, aep->at_tag_val);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_target_put_atio",
          "args": [
            "isp",
            "aep->at_iid",
            "aep->at_tgt",
            "lun",
            "aep->at_tag_type",
            "aep->at_tag_val"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "isp_target_put_atio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "365-400",
          "snippet": "int\nisp_target_put_atio(isp, iid, tgt, lun, ttype, tval)\n\tstruct ispsoftc *isp;\n\tint iid;\n\tint tgt;\n\tint lun;\n\tint ttype;\n\tint tval;\n{\n\tunion {\n\t\tat_entry_t _atio;\n\t\tat2_entry_t _atio2;\n\t} atun;\n\n\tMEMZERO(&atun, sizeof atun);\n\tif (IS_FC(isp)) {\n\t\tatun._atio2.at_header.rqs_entry_type = RQSTYPE_ATIO2;\n\t\tatun._atio2.at_header.rqs_entry_count = 1;\n#ifdef ISP2100_SCCLUN\n\t\tatun._atio2.at_scclun = (uint16_t) lun;\n#else\n\t\tatun._atio2.at_lun = (uint8_t) lun;\n#endif\n\t\tatun._atio2.at_status = CT_OK;\n\t} else {\n\t\tatun._atio.at_header.rqs_entry_type = RQSTYPE_ATIO;\n\t\tatun._atio.at_header.rqs_entry_count = 1;\n\t\tatun._atio.at_iid = iid;\n\t\tatun._atio.at_tgt = tgt;\n\t\tatun._atio.at_lun = lun;\n\t\tatun._atio.at_tag_type = ttype;\n\t\tatun._atio.at_tag_val = tval;\n\t\tatun._atio.at_status = CT_OK;\n\t}\n\treturn (isp_target_put_entry(isp, &atun));\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nint\nisp_target_put_atio(isp, iid, tgt, lun, ttype, tval)\n\tstruct ispsoftc *isp;\n\tint iid;\n\tint tgt;\n\tint lun;\n\tint ttype;\n\tint tval;\n{\n\tunion {\n\t\tat_entry_t _atio;\n\t\tat2_entry_t _atio2;\n\t} atun;\n\n\tMEMZERO(&atun, sizeof atun);\n\tif (IS_FC(isp)) {\n\t\tatun._atio2.at_header.rqs_entry_type = RQSTYPE_ATIO2;\n\t\tatun._atio2.at_header.rqs_entry_count = 1;\n#ifdef ISP2100_SCCLUN\n\t\tatun._atio2.at_scclun = (uint16_t) lun;\n#else\n\t\tatun._atio2.at_lun = (uint8_t) lun;\n#endif\n\t\tatun._atio2.at_status = CT_OK;\n\t} else {\n\t\tatun._atio.at_header.rqs_entry_type = RQSTYPE_ATIO;\n\t\tatun._atio.at_header.rqs_entry_count = 1;\n\t\tatun._atio.at_iid = iid;\n\t\tatun._atio.at_tgt = tgt;\n\t\tatun._atio.at_lun = lun;\n\t\tatun._atio.at_tag_type = ttype;\n\t\tatun._atio.at_tag_val = tval;\n\t\tatun._atio.at_status = CT_OK;\n\t}\n\treturn (isp_target_put_entry(isp, &atun));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Unknown ATIO status 0x%x from initiator %d for lun\"\n\t\t    \" %d\\n\"",
            "isp->isp_name",
            "aep->at_status",
            "aep->at_iid",
            "lun"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: ATIO returned for lun %d from initiator %d because\"\n\t\t    \" a Bus Reset occurred\\n\"",
            "isp->isp_name",
            "lun",
            "aep->at_iid"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_TARGET_ACTION",
            "aep"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: ATIO returned for lun %d because it was in the \"\n\t\t    \" middle of coping with a Bus Device Reset\\n\"",
            "isp->isp_name",
            "lun"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: rejected ATIO for lun %d because of command count\"\n\t\t    \" overflow\\n\"",
            "isp->isp_name",
            "lun"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: rejected ATIO for disabled lun %d\\n\"",
            "isp->isp_name",
            "lun"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_handle_atio(isp, aep)\n\tstruct ispsoftc *isp;\n\tat_entry_t *aep;\n{\n\tint lun;\n\tlun = aep->at_lun;\n\t/*\n\t * The firmware status (except for the QLTM_SVALID bit) indicates\n\t * why this ATIO was sent to us.\n\t *\n\t * If QLTM_SVALID is set, the firware has recommended Sense Data.\n\t *\n\t * If the DISCONNECTS DISABLED bit is set in the flags field,\n\t * we're still connected on the SCSI bus - i.e. the initiator\n\t * did not set DiscPriv in the identify message. We don't care\n\t * about this so it's ignored.\n\t */\n\n\tswitch(aep->at_status & ~QLTM_SVALID) {\n\tcase AT_PATH_INVALID:\n\t\t/*\n\t\t * ATIO rejected by the firmware due to disabled lun.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO for disabled lun %d\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\tcase AT_NOCAP:\n\t\t/*\n\t\t * Requested Capability not available\n\t\t * We sent an ATIO that overflowed the firmware's\n\t\t * command resource count.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO for lun %d because of command count\"\n\t\t    \" overflow\\n\", isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_BDR_MSG:\n\t\t/*\n\t\t * If we send an ATIO to the firmware to increment\n\t\t * its command resource count, and the firmware is\n\t\t * recovering from a Bus Device Reset, it returns\n\t\t * the ATIO with this status. We set the command\n\t\t * resource count in the Enable Lun entry and no\n\t\t * not increment it. Therefore we should never get\n\t\t * this status here.\n\t\t */\n\t\tPRINTF(\"%s: ATIO returned for lun %d because it was in the \"\n\t\t    \" middle of coping with a Bus Device Reset\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_CDB:\t\t/* Got a CDB */\n\tcase AT_PHASE_ERROR:\t/* Bus Phase Sequence Error */\n\t\t/*\n\t\t * Punt to platform specific layer.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, aep);\n\t\tbreak;\n\n\tcase AT_RESET:\n\t\t/*\n\t\t * A bus reset came along an blew away this command. Why\n\t\t * they do this in addition the async event code stuff,\n\t\t * I dunno.\n\t\t *\n\t\t * Ignore it because the async event will clear things\n\t\t * up for us.\n\t\t */\n\t\tPRINTF(\"%s: ATIO returned for lun %d from initiator %d because\"\n\t\t    \" a Bus Reset occurred\\n\", isp->isp_name, lun,\n\t\t    aep->at_iid);\n\t\tbreak;\n\n\n\tdefault:\n\t\tPRINTF(\"%s: Unknown ATIO status 0x%x from initiator %d for lun\"\n\t\t    \" %d\\n\", isp->isp_name, aep->at_status, aep->at_iid, lun);\n\t\t(void) isp_target_put_atio(isp, aep->at_iid, aep->at_tgt,\n\t\t    lun, aep->at_tag_type, aep->at_tag_val);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "isp_notify_ack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "638-695",
    "snippet": "static void\nisp_notify_ack(isp, arg)\n\tstruct ispsoftc *isp;\n\tvoid *arg;\n{\n\tchar storage[QENTRY_LEN];\n\tu_int16_t iptr, optr;\n\tvoid *outp;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow For isp_notify_ack\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\tMEMZERO(storage, QENTRY_LEN);\n\n\tif (IS_FC(isp)) {\n\t\tna_fcentry_t *na = (na_fcentry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_fcentry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n#ifdef\tISP2100_SCCLUN\n\t\t\tna->na_lun = inp->in_scclun;\n#else\n\t\t\tna->na_lun = inp->in_lun;\n#endif\n\t\t\tna->na_task_flags = inp->in_task_flags;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tna->na_flags = NAFC_RCOUNT;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags |= NAFC_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NAFC_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK_FC(isp, outp, na);\n\t} else {\n\t\tna_entry_t *na = (na_entry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_entry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n\t\t\tna->na_lun = inp->in_lun;\n\t\t\tna->na_tgt = inp->in_tgt;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK(isp, outp, na);\n\t}\n\tISP_TDQE(isp, \"isp_notify_ack\", (int) optr, storage);\n\tISP_ADD_REQUEST(isp, iptr);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ISP_ADD_REQUEST",
          "args": [
            "isp",
            "iptr"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_TDQE",
          "args": [
            "isp",
            "\"isp_notify_ack\"",
            "(int) optr",
            "storage"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SWIZ_NOT_ACK",
          "args": [
            "isp",
            "outp",
            "na"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMCPY",
          "args": [
            "storage",
            "arg",
            "sizeof (isphdr_t)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SWIZ_NOT_ACK_FC",
          "args": [
            "isp",
            "outp",
            "na"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMCPY",
          "args": [
            "storage",
            "arg",
            "sizeof (isphdr_t)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "storage",
            "QENTRY_LEN"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Request Queue Overflow For isp_notify_ack\\n\"",
            "isp->isp_name"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_getrqentry",
          "args": [
            "isp",
            "&iptr",
            "&optr",
            "&outp"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "isp_getrqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "258-277",
          "snippet": "static INLINE int\nisp_getrqentry(isp, iptrp, optrp, resultp)\n\tstruct ispsoftc *isp;\n\tu_int16_t *iptrp;\n\tu_int16_t *optrp;\n\tvoid **resultp;\n{\n\tvolatile u_int16_t iptr, optr;\n\n\toptr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\tiptr = isp->isp_reqidx;\n\t*resultp = ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);\n\tiptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);\n\tif (iptr == optr) {\n\t\treturn (1);\n\t}\n\t*optrp = optr;\n\t*iptrp = iptr;\n\treturn (0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE int\nisp_getrqentry(isp, iptrp, optrp, resultp)\n\tstruct ispsoftc *isp;\n\tu_int16_t *iptrp;\n\tu_int16_t *optrp;\n\tvoid **resultp;\n{\n\tvolatile u_int16_t iptr, optr;\n\n\toptr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\tiptr = isp->isp_reqidx;\n\t*resultp = ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);\n\tiptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);\n\tif (iptr == optr) {\n\t\treturn (1);\n\t}\n\t*optrp = optr;\n\t*iptrp = iptr;\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_notify_ack(isp, arg)\n\tstruct ispsoftc *isp;\n\tvoid *arg;\n{\n\tchar storage[QENTRY_LEN];\n\tu_int16_t iptr, optr;\n\tvoid *outp;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow For isp_notify_ack\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\tMEMZERO(storage, QENTRY_LEN);\n\n\tif (IS_FC(isp)) {\n\t\tna_fcentry_t *na = (na_fcentry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_fcentry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n#ifdef\tISP2100_SCCLUN\n\t\t\tna->na_lun = inp->in_scclun;\n#else\n\t\t\tna->na_lun = inp->in_lun;\n#endif\n\t\t\tna->na_task_flags = inp->in_task_flags;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tna->na_flags = NAFC_RCOUNT;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags |= NAFC_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NAFC_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK_FC(isp, outp, na);\n\t} else {\n\t\tna_entry_t *na = (na_entry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_entry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n\t\t\tna->na_lun = inp->in_lun;\n\t\t\tna->na_tgt = inp->in_tgt;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK(isp, outp, na);\n\t}\n\tISP_TDQE(isp, \"isp_notify_ack\", (int) optr, storage);\n\tISP_ADD_REQUEST(isp, iptr);\n}"
  },
  {
    "function_name": "isp_got_msg_fc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "579-636",
    "snippet": "static void\nisp_got_msg_fc(isp, bus, inp)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tin_fcentry_t *inp;\n{\n\tstatic char *f1 = \"%s: %s from iid %d lun %d seq 0x%x\\n\";\n\tstatic char *f2 = \n\t    \"%s: unknown %s 0x%x lun %d iid %d task flags 0x%x seq 0x%x\\n\";\n\n\tif (inp->in_status != IN_MSG_RECEIVED) {\n\t\tPRINTF(f2, isp->isp_name, \"immediate notify status\",\n\t\t    inp->in_status, inp->in_lun, inp->in_iid,\n\t\t    inp->in_task_flags,  inp->in_seqid);\n\t} else {\n\t\ttmd_msg_t msg;\n\n\t\tMEMZERO(&msg, sizeof (msg));\n\t\tmsg.nt_bus = bus;\n\t\tmsg.nt_iid = inp->in_iid;\n#ifdef\tISP2100_SCCLUN\n\t\tmsg.nt_lun = inp->in_scclun;\n#else\n\t\tmsg.nt_lun = inp->in_lun;\n#endif\n\t\tmsg.nt_tagval = inp->in_seqid;\n\n\t\tif (inp->in_task_flags & TASK_FLAGS_ABORT_TASK) {\n\t\t\tPRINTF(f1, isp->isp_name, \"ABORT TASK\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_ABORT_TAG;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_TASK_SET) {\n\t\t\tPRINTF(f1, isp->isp_name, \"CLEAR TASK SET\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_CLEAR_QUEUE;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_TARGET_RESET) {\n\t\t\tPRINTF(f1, isp->isp_name, \"TARGET RESET\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_BUS_DEV_RESET;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_ACA) {\n\t\t\tPRINTF(f1, isp->isp_name, \"CLEAR ACA\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\t/* ???? */\n\t\t\tmsg.nt_msg[0] = MSG_REL_RECOVERY;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_TERMINATE_TASK) {\n\t\t\tPRINTF(f1, isp->isp_name, \"TERMINATE TASK\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_TERM_IO_PROC;\n\t\t} else {\n\t\t\tPRINTF(f2, isp->isp_name, \"task flag\",\n\t\t\t    inp->in_status, inp->in_lun, inp->in_iid,\n\t\t\t    inp->in_task_flags,  inp->in_seqid);\n\t\t}\n\t\tif (msg.nt_msg[0]) {\n\t\t\t(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_TARGET_MESSAGE",
            "&msg"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "f2",
            "isp->isp_name",
            "\"task flag\"",
            "inp->in_status",
            "inp->in_lun",
            "inp->in_iid",
            "inp->in_task_flags",
            "inp->in_seqid"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "f1",
            "isp->isp_name",
            "\"TERMINATE TASK\"",
            "inp->in_iid",
            "inp->in_lun",
            "inp->in_seqid"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "f1",
            "isp->isp_name",
            "\"CLEAR ACA\"",
            "inp->in_iid",
            "inp->in_lun",
            "inp->in_seqid"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "f1",
            "isp->isp_name",
            "\"TARGET RESET\"",
            "inp->in_iid",
            "inp->in_lun",
            "inp->in_seqid"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "f1",
            "isp->isp_name",
            "\"CLEAR TASK SET\"",
            "inp->in_iid",
            "inp->in_lun",
            "inp->in_seqid"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "f1",
            "isp->isp_name",
            "\"ABORT TASK\"",
            "inp->in_iid",
            "inp->in_lun",
            "inp->in_seqid"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "&msg",
            "sizeof (msg)"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "f2",
            "isp->isp_name",
            "\"immediate notify status\"",
            "inp->in_status",
            "inp->in_lun",
            "inp->in_iid",
            "inp->in_task_flags",
            "inp->in_seqid"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_got_msg_fc(isp, bus, inp)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tin_fcentry_t *inp;\n{\n\tstatic char *f1 = \"%s: %s from iid %d lun %d seq 0x%x\\n\";\n\tstatic char *f2 = \n\t    \"%s: unknown %s 0x%x lun %d iid %d task flags 0x%x seq 0x%x\\n\";\n\n\tif (inp->in_status != IN_MSG_RECEIVED) {\n\t\tPRINTF(f2, isp->isp_name, \"immediate notify status\",\n\t\t    inp->in_status, inp->in_lun, inp->in_iid,\n\t\t    inp->in_task_flags,  inp->in_seqid);\n\t} else {\n\t\ttmd_msg_t msg;\n\n\t\tMEMZERO(&msg, sizeof (msg));\n\t\tmsg.nt_bus = bus;\n\t\tmsg.nt_iid = inp->in_iid;\n#ifdef\tISP2100_SCCLUN\n\t\tmsg.nt_lun = inp->in_scclun;\n#else\n\t\tmsg.nt_lun = inp->in_lun;\n#endif\n\t\tmsg.nt_tagval = inp->in_seqid;\n\n\t\tif (inp->in_task_flags & TASK_FLAGS_ABORT_TASK) {\n\t\t\tPRINTF(f1, isp->isp_name, \"ABORT TASK\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_ABORT_TAG;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_TASK_SET) {\n\t\t\tPRINTF(f1, isp->isp_name, \"CLEAR TASK SET\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_CLEAR_QUEUE;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_TARGET_RESET) {\n\t\t\tPRINTF(f1, isp->isp_name, \"TARGET RESET\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_BUS_DEV_RESET;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_ACA) {\n\t\t\tPRINTF(f1, isp->isp_name, \"CLEAR ACA\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\t/* ???? */\n\t\t\tmsg.nt_msg[0] = MSG_REL_RECOVERY;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_TERMINATE_TASK) {\n\t\t\tPRINTF(f1, isp->isp_name, \"TERMINATE TASK\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_TERM_IO_PROC;\n\t\t} else {\n\t\t\tPRINTF(f2, isp->isp_name, \"task flag\",\n\t\t\t    inp->in_status, inp->in_lun, inp->in_iid,\n\t\t\t    inp->in_task_flags,  inp->in_seqid);\n\t\t}\n\t\tif (msg.nt_msg[0]) {\n\t\t\t(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "isp_got_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "550-574",
    "snippet": "static void\nisp_got_msg(isp, bus, inp)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tin_entry_t *inp;\n{\n\tu_int8_t status = inp->in_status & ~QLTM_SVALID;\n\n\tif (status == IN_IDE_RECEIVED || status == IN_MSG_RECEIVED) {\n\t\ttmd_msg_t msg;\n\n\t\tMEMZERO(&msg, sizeof (msg));\n\t\tmsg.nt_bus = bus;\n\t\tmsg.nt_iid = inp->in_iid;\n\t\tmsg.nt_tgt = inp->in_tgt;\n\t\tmsg.nt_lun = inp->in_lun;\n\t\tmsg.nt_tagtype = inp->in_tag_type;\n\t\tmsg.nt_tagval = inp->in_tag_val;\n\t\tMEMCPY(msg.nt_msg, inp->in_msg, IN_MSGLEN);\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);\n\t} else {\n\t\tPRINTF(\"%s: unknown immediate notify status 0x%x\\n\",\n\t\t    isp->isp_name, inp->in_status);\n\t}\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: unknown immediate notify status 0x%x\\n\"",
            "isp->isp_name",
            "inp->in_status"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_TARGET_MESSAGE",
            "&msg"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MEMCPY",
          "args": [
            "msg.nt_msg",
            "inp->in_msg",
            "IN_MSGLEN"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "&msg",
            "sizeof (msg)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_got_msg(isp, bus, inp)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tin_entry_t *inp;\n{\n\tu_int8_t status = inp->in_status & ~QLTM_SVALID;\n\n\tif (status == IN_IDE_RECEIVED || status == IN_MSG_RECEIVED) {\n\t\ttmd_msg_t msg;\n\n\t\tMEMZERO(&msg, sizeof (msg));\n\t\tmsg.nt_bus = bus;\n\t\tmsg.nt_iid = inp->in_iid;\n\t\tmsg.nt_tgt = inp->in_tgt;\n\t\tmsg.nt_lun = inp->in_lun;\n\t\tmsg.nt_tagtype = inp->in_tag_type;\n\t\tmsg.nt_tagval = inp->in_tag_val;\n\t\tMEMCPY(msg.nt_msg, inp->in_msg, IN_MSGLEN);\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);\n\t} else {\n\t\tPRINTF(\"%s: unknown immediate notify status 0x%x\\n\",\n\t\t    isp->isp_name, inp->in_status);\n\t}\n}"
  },
  {
    "function_name": "isp_target_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "483-539",
    "snippet": "void\nisp_target_async(isp, bus, event)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tint event;\n{\n\ttmd_event_t evt;\n\ttmd_msg_t msg;\n\n\tswitch (event) {\n\t/*\n\t * These three we handle here to propagate an effective bus reset\n\t * upstream, but these do not require any immediate notify actions\n\t * so we return when done.\n\t */\n\tcase ASYNC_LIP_OCCURRED:\n\tcase ASYNC_LOOP_UP:\n\tcase ASYNC_LOOP_DOWN:\n\t\tevt.ev_bus = bus;\n\t\tevt.ev_event = event;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_EVENT, &evt);\n\t\treturn;\n\n\tcase ASYNC_LOOP_RESET:\n\tcase ASYNC_BUS_RESET:\n\tcase ASYNC_TIMEOUT_RESET:\n\t\tif (IS_FC(isp)) {\n\t\t\treturn;\t/* we'll be getting an inotify instead */\n\t\t}\n\t\tevt.ev_bus = bus;\n\t\tevt.ev_event = event;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_EVENT, &evt);\n\t\tbreak;\n\tcase ASYNC_DEVICE_RESET:\n\t\t/*\n\t\t * Bus Device Reset resets a specific target, so\n\t\t * we pass this as a synthesized message.\n\t\t */\n\t\tMEMZERO(&msg, sizeof msg);\n\t\tif (IS_FC(isp)) {\n\t\t\tmsg.nt_iid =\n\t\t\t    ((fcparam *)isp->isp_param)->isp_loopid;\n\t\t} else {\n\t\t\tmsg.nt_iid =\n\t\t\t    ((sdparam *)isp->isp_param)->isp_initiator_id;\n\t\t}\n\t\tmsg.nt_bus = bus;\n\t\tmsg.nt_msg[0] = MSG_BUS_DEV_RESET;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: isp_target_async: unknown event 0x%x\\n\",\n\t\t    isp->isp_name, event);\n\t\tbreak;\n\t}\n\tisp_notify_ack(isp, NULL);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_notify_ack",
          "args": [
            "isp",
            "NULL"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "isp_notify_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "638-695",
          "snippet": "static void\nisp_notify_ack(isp, arg)\n\tstruct ispsoftc *isp;\n\tvoid *arg;\n{\n\tchar storage[QENTRY_LEN];\n\tu_int16_t iptr, optr;\n\tvoid *outp;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow For isp_notify_ack\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\tMEMZERO(storage, QENTRY_LEN);\n\n\tif (IS_FC(isp)) {\n\t\tna_fcentry_t *na = (na_fcentry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_fcentry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n#ifdef\tISP2100_SCCLUN\n\t\t\tna->na_lun = inp->in_scclun;\n#else\n\t\t\tna->na_lun = inp->in_lun;\n#endif\n\t\t\tna->na_task_flags = inp->in_task_flags;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tna->na_flags = NAFC_RCOUNT;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags |= NAFC_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NAFC_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK_FC(isp, outp, na);\n\t} else {\n\t\tna_entry_t *na = (na_entry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_entry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n\t\t\tna->na_lun = inp->in_lun;\n\t\t\tna->na_tgt = inp->in_tgt;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK(isp, outp, na);\n\t}\n\tISP_TDQE(isp, \"isp_notify_ack\", (int) optr, storage);\n\tISP_ADD_REQUEST(isp, iptr);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_notify_ack(isp, arg)\n\tstruct ispsoftc *isp;\n\tvoid *arg;\n{\n\tchar storage[QENTRY_LEN];\n\tu_int16_t iptr, optr;\n\tvoid *outp;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow For isp_notify_ack\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\tMEMZERO(storage, QENTRY_LEN);\n\n\tif (IS_FC(isp)) {\n\t\tna_fcentry_t *na = (na_fcentry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_fcentry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n#ifdef\tISP2100_SCCLUN\n\t\t\tna->na_lun = inp->in_scclun;\n#else\n\t\t\tna->na_lun = inp->in_lun;\n#endif\n\t\t\tna->na_task_flags = inp->in_task_flags;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tna->na_flags = NAFC_RCOUNT;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags |= NAFC_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NAFC_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK_FC(isp, outp, na);\n\t} else {\n\t\tna_entry_t *na = (na_entry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_entry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n\t\t\tna->na_lun = inp->in_lun;\n\t\t\tna->na_tgt = inp->in_tgt;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK(isp, outp, na);\n\t}\n\tISP_TDQE(isp, \"isp_notify_ack\", (int) optr, storage);\n\tISP_ADD_REQUEST(isp, iptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: isp_target_async: unknown event 0x%x\\n\"",
            "isp->isp_name",
            "event"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_TARGET_MESSAGE",
            "&msg"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "&msg",
            "sizeof msg"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nvoid\nisp_target_async(isp, bus, event)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tint event;\n{\n\ttmd_event_t evt;\n\ttmd_msg_t msg;\n\n\tswitch (event) {\n\t/*\n\t * These three we handle here to propagate an effective bus reset\n\t * upstream, but these do not require any immediate notify actions\n\t * so we return when done.\n\t */\n\tcase ASYNC_LIP_OCCURRED:\n\tcase ASYNC_LOOP_UP:\n\tcase ASYNC_LOOP_DOWN:\n\t\tevt.ev_bus = bus;\n\t\tevt.ev_event = event;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_EVENT, &evt);\n\t\treturn;\n\n\tcase ASYNC_LOOP_RESET:\n\tcase ASYNC_BUS_RESET:\n\tcase ASYNC_TIMEOUT_RESET:\n\t\tif (IS_FC(isp)) {\n\t\t\treturn;\t/* we'll be getting an inotify instead */\n\t\t}\n\t\tevt.ev_bus = bus;\n\t\tevt.ev_event = event;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_EVENT, &evt);\n\t\tbreak;\n\tcase ASYNC_DEVICE_RESET:\n\t\t/*\n\t\t * Bus Device Reset resets a specific target, so\n\t\t * we pass this as a synthesized message.\n\t\t */\n\t\tMEMZERO(&msg, sizeof msg);\n\t\tif (IS_FC(isp)) {\n\t\t\tmsg.nt_iid =\n\t\t\t    ((fcparam *)isp->isp_param)->isp_loopid;\n\t\t} else {\n\t\t\tmsg.nt_iid =\n\t\t\t    ((sdparam *)isp->isp_param)->isp_initiator_id;\n\t\t}\n\t\tmsg.nt_bus = bus;\n\t\tmsg.nt_msg[0] = MSG_BUS_DEV_RESET;\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: isp_target_async: unknown event 0x%x\\n\",\n\t\t    isp->isp_name, event);\n\t\tbreak;\n\t}\n\tisp_notify_ack(isp, NULL);\n}"
  },
  {
    "function_name": "isp_endcmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "420-481",
    "snippet": "int\nisp_endcmd(struct ispsoftc *isp, void *arg, u_int32_t code, u_int32_t hdl)\n{\n\tint sts;\n\tunion {\n\t\tct_entry_t _ctio;\n\t\tct2_entry_t _ctio2;\n\t} un;\n\n\tMEMZERO(&un, sizeof un);\n\tsts = code & 0xff;\n\n\tif (IS_FC(isp)) {\n\t\tat2_entry_t *aep = arg;\n\t\tct2_entry_t *cto = &un._ctio2;\n\n\t\tcto->ct_header.rqs_entry_type = RQSTYPE_CTIO2;\n\t\tcto->ct_header.rqs_entry_count = 1;\n\t\tcto->ct_iid = aep->at_iid;\n#ifndef\tISP2100_SCCLUN\n\t\tcto->ct_lun = aep->at_lun;\n#endif\n\t\tcto->ct_rxid = aep->at_rxid;\n\t\tcto->rsp.m1.ct_scsi_status = sts & 0xff;\n\t\tcto->ct_flags = CT2_SENDSTATUS | CT2_NO_DATA | CT2_FLAG_MODE1;\n\t\tif (hdl == 0) {\n\t\t\tcto->ct_flags |= CT2_CCINCR;\n\t\t}\n\t\tif (aep->at_datalen) {\n\t\t\tcto->ct_resid = aep->at_datalen;\n\t\t\tcto->ct_flags |= CT2_DATA_UNDER;\n\t\t}\n\t\tif ((sts & 0xff) == SCSI_CHECK && (sts & ECMD_SVALID)) {\n\t\t\tcto->rsp.m1.ct_resp[0] = 0xf0;\n\t\t\tcto->rsp.m1.ct_resp[2] = (code >> 12) & 0xf;\n\t\t\tcto->rsp.m1.ct_resp[7] = 8;\n\t\t\tcto->rsp.m1.ct_resp[12] = (code >> 24) & 0xff;\n\t\t\tcto->rsp.m1.ct_resp[13] = (code >> 16) & 0xff;\n\t\t\tcto->rsp.m1.ct_senselen = 16;\n\t\t\tcto->ct_flags |= CT2_SNSLEN_VALID;\n\t\t}\n\t\tcto->ct_reserved = hdl;\n\t} else {\n\t\tat_entry_t *aep = arg;\n\t\tct_entry_t *cto = &un._ctio;\n\n\t\tcto->ct_header.rqs_entry_type = RQSTYPE_CTIO;\n\t\tcto->ct_header.rqs_entry_count = 1;\n\t\tcto->ct_iid = aep->at_iid;\n\t\tcto->ct_tgt = aep->at_tgt;\n\t\tcto->ct_lun = aep->at_lun;\n\t\tcto->ct_tag_type = aep->at_tag_type;\n\t\tcto->ct_tag_val = aep->at_tag_val;\n\t\tcto->ct_flags = CT_SENDSTATUS | CT_NO_DATA;\n\t\tif (hdl == 0) {\n\t\t\tcto->ct_flags |= CT_CCINCR;\n\t\t}\n\t\tcto->ct_scsi_status = sts;\n\t\tcto->ct_reserved = hdl;\n\t}\n\treturn (isp_target_put_entry(isp, &un));\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_target_put_entry",
          "args": [
            "isp",
            "&un"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "isp_target_put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "326-363",
          "snippet": "int\nisp_target_put_entry(isp, ap)\n\tstruct ispsoftc *isp;\n\tvoid *ap;\n{\n\tvoid *outp;\n\tu_int16_t iptr, optr;\n\tu_int8_t etype = ((isphdr_t *) ap)->rqs_entry_type;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow in isp_target_put_entry \"\n\t\t    \"for type 0x%x\\n\", isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\tswitch (etype) {\n\tcase RQSTYPE_ATIO:\n\t\tISP_SWIZ_ATIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_ATIO2:\n\t\tISP_SWIZ_ATIO2(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO:\n\t\tISP_SWIZ_CTIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO2:\n\t\tISP_SWIZ_CTIO2(isp, outp, ap);\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown type 0x%x in isp_put_entry\\n\",\n\t\t    isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\n\tISP_TDQE(isp, \"isp_target_put_entry\", (int) optr, ap);;\n\n\tISP_ADD_REQUEST(isp, iptr);\n\treturn (0);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nint\nisp_target_put_entry(isp, ap)\n\tstruct ispsoftc *isp;\n\tvoid *ap;\n{\n\tvoid *outp;\n\tu_int16_t iptr, optr;\n\tu_int8_t etype = ((isphdr_t *) ap)->rqs_entry_type;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow in isp_target_put_entry \"\n\t\t    \"for type 0x%x\\n\", isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\tswitch (etype) {\n\tcase RQSTYPE_ATIO:\n\t\tISP_SWIZ_ATIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_ATIO2:\n\t\tISP_SWIZ_ATIO2(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO:\n\t\tISP_SWIZ_CTIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO2:\n\t\tISP_SWIZ_CTIO2(isp, outp, ap);\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown type 0x%x in isp_put_entry\\n\",\n\t\t    isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\n\tISP_TDQE(isp, \"isp_target_put_entry\", (int) optr, ap);;\n\n\tISP_ADD_REQUEST(isp, iptr);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "&un",
            "sizeof un"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nint\nisp_endcmd(struct ispsoftc *isp, void *arg, u_int32_t code, u_int32_t hdl)\n{\n\tint sts;\n\tunion {\n\t\tct_entry_t _ctio;\n\t\tct2_entry_t _ctio2;\n\t} un;\n\n\tMEMZERO(&un, sizeof un);\n\tsts = code & 0xff;\n\n\tif (IS_FC(isp)) {\n\t\tat2_entry_t *aep = arg;\n\t\tct2_entry_t *cto = &un._ctio2;\n\n\t\tcto->ct_header.rqs_entry_type = RQSTYPE_CTIO2;\n\t\tcto->ct_header.rqs_entry_count = 1;\n\t\tcto->ct_iid = aep->at_iid;\n#ifndef\tISP2100_SCCLUN\n\t\tcto->ct_lun = aep->at_lun;\n#endif\n\t\tcto->ct_rxid = aep->at_rxid;\n\t\tcto->rsp.m1.ct_scsi_status = sts & 0xff;\n\t\tcto->ct_flags = CT2_SENDSTATUS | CT2_NO_DATA | CT2_FLAG_MODE1;\n\t\tif (hdl == 0) {\n\t\t\tcto->ct_flags |= CT2_CCINCR;\n\t\t}\n\t\tif (aep->at_datalen) {\n\t\t\tcto->ct_resid = aep->at_datalen;\n\t\t\tcto->ct_flags |= CT2_DATA_UNDER;\n\t\t}\n\t\tif ((sts & 0xff) == SCSI_CHECK && (sts & ECMD_SVALID)) {\n\t\t\tcto->rsp.m1.ct_resp[0] = 0xf0;\n\t\t\tcto->rsp.m1.ct_resp[2] = (code >> 12) & 0xf;\n\t\t\tcto->rsp.m1.ct_resp[7] = 8;\n\t\t\tcto->rsp.m1.ct_resp[12] = (code >> 24) & 0xff;\n\t\t\tcto->rsp.m1.ct_resp[13] = (code >> 16) & 0xff;\n\t\t\tcto->rsp.m1.ct_senselen = 16;\n\t\t\tcto->ct_flags |= CT2_SNSLEN_VALID;\n\t\t}\n\t\tcto->ct_reserved = hdl;\n\t} else {\n\t\tat_entry_t *aep = arg;\n\t\tct_entry_t *cto = &un._ctio;\n\n\t\tcto->ct_header.rqs_entry_type = RQSTYPE_CTIO;\n\t\tcto->ct_header.rqs_entry_count = 1;\n\t\tcto->ct_iid = aep->at_iid;\n\t\tcto->ct_tgt = aep->at_tgt;\n\t\tcto->ct_lun = aep->at_lun;\n\t\tcto->ct_tag_type = aep->at_tag_type;\n\t\tcto->ct_tag_val = aep->at_tag_val;\n\t\tcto->ct_flags = CT_SENDSTATUS | CT_NO_DATA;\n\t\tif (hdl == 0) {\n\t\t\tcto->ct_flags |= CT_CCINCR;\n\t\t}\n\t\tcto->ct_scsi_status = sts;\n\t\tcto->ct_reserved = hdl;\n\t}\n\treturn (isp_target_put_entry(isp, &un));\n}"
  },
  {
    "function_name": "isp_target_put_atio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "365-400",
    "snippet": "int\nisp_target_put_atio(isp, iid, tgt, lun, ttype, tval)\n\tstruct ispsoftc *isp;\n\tint iid;\n\tint tgt;\n\tint lun;\n\tint ttype;\n\tint tval;\n{\n\tunion {\n\t\tat_entry_t _atio;\n\t\tat2_entry_t _atio2;\n\t} atun;\n\n\tMEMZERO(&atun, sizeof atun);\n\tif (IS_FC(isp)) {\n\t\tatun._atio2.at_header.rqs_entry_type = RQSTYPE_ATIO2;\n\t\tatun._atio2.at_header.rqs_entry_count = 1;\n#ifdef ISP2100_SCCLUN\n\t\tatun._atio2.at_scclun = (uint16_t) lun;\n#else\n\t\tatun._atio2.at_lun = (uint8_t) lun;\n#endif\n\t\tatun._atio2.at_status = CT_OK;\n\t} else {\n\t\tatun._atio.at_header.rqs_entry_type = RQSTYPE_ATIO;\n\t\tatun._atio.at_header.rqs_entry_count = 1;\n\t\tatun._atio.at_iid = iid;\n\t\tatun._atio.at_tgt = tgt;\n\t\tatun._atio.at_lun = lun;\n\t\tatun._atio.at_tag_type = ttype;\n\t\tatun._atio.at_tag_val = tval;\n\t\tatun._atio.at_status = CT_OK;\n\t}\n\treturn (isp_target_put_entry(isp, &atun));\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isp_target_put_entry",
          "args": [
            "isp",
            "&atun"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "isp_target_put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "326-363",
          "snippet": "int\nisp_target_put_entry(isp, ap)\n\tstruct ispsoftc *isp;\n\tvoid *ap;\n{\n\tvoid *outp;\n\tu_int16_t iptr, optr;\n\tu_int8_t etype = ((isphdr_t *) ap)->rqs_entry_type;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow in isp_target_put_entry \"\n\t\t    \"for type 0x%x\\n\", isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\tswitch (etype) {\n\tcase RQSTYPE_ATIO:\n\t\tISP_SWIZ_ATIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_ATIO2:\n\t\tISP_SWIZ_ATIO2(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO:\n\t\tISP_SWIZ_CTIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO2:\n\t\tISP_SWIZ_CTIO2(isp, outp, ap);\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown type 0x%x in isp_put_entry\\n\",\n\t\t    isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\n\tISP_TDQE(isp, \"isp_target_put_entry\", (int) optr, ap);;\n\n\tISP_ADD_REQUEST(isp, iptr);\n\treturn (0);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nint\nisp_target_put_entry(isp, ap)\n\tstruct ispsoftc *isp;\n\tvoid *ap;\n{\n\tvoid *outp;\n\tu_int16_t iptr, optr;\n\tu_int8_t etype = ((isphdr_t *) ap)->rqs_entry_type;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow in isp_target_put_entry \"\n\t\t    \"for type 0x%x\\n\", isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\tswitch (etype) {\n\tcase RQSTYPE_ATIO:\n\t\tISP_SWIZ_ATIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_ATIO2:\n\t\tISP_SWIZ_ATIO2(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO:\n\t\tISP_SWIZ_CTIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO2:\n\t\tISP_SWIZ_CTIO2(isp, outp, ap);\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown type 0x%x in isp_put_entry\\n\",\n\t\t    isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\n\tISP_TDQE(isp, \"isp_target_put_entry\", (int) optr, ap);;\n\n\tISP_ADD_REQUEST(isp, iptr);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "&atun",
            "sizeof atun"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nint\nisp_target_put_atio(isp, iid, tgt, lun, ttype, tval)\n\tstruct ispsoftc *isp;\n\tint iid;\n\tint tgt;\n\tint lun;\n\tint ttype;\n\tint tval;\n{\n\tunion {\n\t\tat_entry_t _atio;\n\t\tat2_entry_t _atio2;\n\t} atun;\n\n\tMEMZERO(&atun, sizeof atun);\n\tif (IS_FC(isp)) {\n\t\tatun._atio2.at_header.rqs_entry_type = RQSTYPE_ATIO2;\n\t\tatun._atio2.at_header.rqs_entry_count = 1;\n#ifdef ISP2100_SCCLUN\n\t\tatun._atio2.at_scclun = (uint16_t) lun;\n#else\n\t\tatun._atio2.at_lun = (uint8_t) lun;\n#endif\n\t\tatun._atio2.at_status = CT_OK;\n\t} else {\n\t\tatun._atio.at_header.rqs_entry_type = RQSTYPE_ATIO;\n\t\tatun._atio.at_header.rqs_entry_count = 1;\n\t\tatun._atio.at_iid = iid;\n\t\tatun._atio.at_tgt = tgt;\n\t\tatun._atio.at_lun = lun;\n\t\tatun._atio.at_tag_type = ttype;\n\t\tatun._atio.at_tag_val = tval;\n\t\tatun._atio.at_status = CT_OK;\n\t}\n\treturn (isp_target_put_entry(isp, &atun));\n}"
  },
  {
    "function_name": "isp_target_put_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "326-363",
    "snippet": "int\nisp_target_put_entry(isp, ap)\n\tstruct ispsoftc *isp;\n\tvoid *ap;\n{\n\tvoid *outp;\n\tu_int16_t iptr, optr;\n\tu_int8_t etype = ((isphdr_t *) ap)->rqs_entry_type;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow in isp_target_put_entry \"\n\t\t    \"for type 0x%x\\n\", isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\tswitch (etype) {\n\tcase RQSTYPE_ATIO:\n\t\tISP_SWIZ_ATIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_ATIO2:\n\t\tISP_SWIZ_ATIO2(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO:\n\t\tISP_SWIZ_CTIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO2:\n\t\tISP_SWIZ_CTIO2(isp, outp, ap);\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown type 0x%x in isp_put_entry\\n\",\n\t\t    isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\n\tISP_TDQE(isp, \"isp_target_put_entry\", (int) optr, ap);;\n\n\tISP_ADD_REQUEST(isp, iptr);\n\treturn (0);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ISP_ADD_REQUEST",
          "args": [
            "isp",
            "iptr"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_TDQE",
          "args": [
            "isp",
            "\"isp_target_put_entry\"",
            "(int) optr",
            "ap"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Unknown type 0x%x in isp_put_entry\\n\"",
            "isp->isp_name",
            "etype"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SWIZ_CTIO2",
          "args": [
            "isp",
            "outp",
            "ap"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SWIZ_CTIO",
          "args": [
            "isp",
            "outp",
            "ap"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SWIZ_ATIO2",
          "args": [
            "isp",
            "outp",
            "ap"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SWIZ_ATIO",
          "args": [
            "isp",
            "outp",
            "ap"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Request Queue Overflow in isp_target_put_entry \"\n\t\t    \"for type 0x%x\\n\"",
            "isp->isp_name",
            "etype"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_getrqentry",
          "args": [
            "isp",
            "&iptr",
            "&optr",
            "&outp"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "isp_getrqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "258-277",
          "snippet": "static INLINE int\nisp_getrqentry(isp, iptrp, optrp, resultp)\n\tstruct ispsoftc *isp;\n\tu_int16_t *iptrp;\n\tu_int16_t *optrp;\n\tvoid **resultp;\n{\n\tvolatile u_int16_t iptr, optr;\n\n\toptr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\tiptr = isp->isp_reqidx;\n\t*resultp = ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);\n\tiptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);\n\tif (iptr == optr) {\n\t\treturn (1);\n\t}\n\t*optrp = optr;\n\t*iptrp = iptr;\n\treturn (0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE int\nisp_getrqentry(isp, iptrp, optrp, resultp)\n\tstruct ispsoftc *isp;\n\tu_int16_t *iptrp;\n\tu_int16_t *optrp;\n\tvoid **resultp;\n{\n\tvolatile u_int16_t iptr, optr;\n\n\toptr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\tiptr = isp->isp_reqidx;\n\t*resultp = ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);\n\tiptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);\n\tif (iptr == optr) {\n\t\treturn (1);\n\t}\n\t*optrp = optr;\n\t*iptrp = iptr;\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nint\nisp_target_put_entry(isp, ap)\n\tstruct ispsoftc *isp;\n\tvoid *ap;\n{\n\tvoid *outp;\n\tu_int16_t iptr, optr;\n\tu_int8_t etype = ((isphdr_t *) ap)->rqs_entry_type;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow in isp_target_put_entry \"\n\t\t    \"for type 0x%x\\n\", isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\tswitch (etype) {\n\tcase RQSTYPE_ATIO:\n\t\tISP_SWIZ_ATIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_ATIO2:\n\t\tISP_SWIZ_ATIO2(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO:\n\t\tISP_SWIZ_CTIO(isp, outp, ap);\n\t\tbreak;\n\tcase RQSTYPE_CTIO2:\n\t\tISP_SWIZ_CTIO2(isp, outp, ap);\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown type 0x%x in isp_put_entry\\n\",\n\t\t    isp->isp_name, etype);\n\t\treturn (-1);\n\t}\n\n\tISP_TDQE(isp, \"isp_target_put_entry\", (int) optr, ap);;\n\n\tISP_ADD_REQUEST(isp, iptr);\n\treturn (0);\n}"
  },
  {
    "function_name": "isp_lun_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "266-323",
    "snippet": "int\nisp_lun_cmd(isp, cmd, bus, tgt, lun, opaque)\n\tstruct ispsoftc *isp;\n\tint cmd;\n\tint bus;\n\tint tgt;\n\tint lun;\n\tu_int32_t opaque;\n{\n\tlun_entry_t el;\n\tu_int16_t iptr, optr;\n\tvoid *outp;\n\n\n\tMEMZERO(&el, sizeof (el));\n\tif (IS_DUALBUS(isp)) {\n\t\tel.le_rsvd = (bus & 0x1) << 7;\n\t}\n\tel.le_cmd_count = DFLT_CMD_CNT;\n\tel.le_in_count = DFLT_INOTIFY;\n\tif (cmd == RQSTYPE_ENABLE_LUN) {\n\t\tif (IS_SCSI(isp)) {\n\t\t\tel.le_flags = LUN_TQAE;\n\t\t\tel.le_cdb6len = 12;\n\t\t\tel.le_cdb7len = 12;\n\t\t}\n\t} else if (cmd == -RQSTYPE_ENABLE_LUN) {\n\t\tcmd = RQSTYPE_ENABLE_LUN;\n\t\tel.le_cmd_count = 0;\n\t\tel.le_in_count = 0;\n\t} else if (cmd == -RQSTYPE_MODIFY_LUN) {\n\t\tcmd = RQSTYPE_MODIFY_LUN;\n\t\tel.le_ops = LUN_CCDECR | LUN_INDECR;\n\t} else {\n\t\tel.le_ops = LUN_CCINCR | LUN_ININCR;\n\t}\n\tel.le_header.rqs_entry_type = cmd;\n\tel.le_header.rqs_entry_count = 1;\n\tel.le_reserved = opaque;\n\tif (IS_SCSI(isp)) {\n\t\tel.le_tgt = tgt;\n\t\tel.le_lun = lun;\n#ifndef\tISP2100_SCCLUN\n\t} else {\n\t\tel.le_lun = lun;\n#endif\n\t}\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow in isp_lun_cmd\\n\",\n\t\t    isp->isp_name);\n\t\treturn (-1);\n\t}\n\tISP_SWIZ_ENABLE_LUN(isp, outp, &el);\n\tISP_TDQE(isp, \"isp_lun_cmd\", (int) optr, &el);\n\tISP_ADD_REQUEST(isp, iptr);\n\treturn (0);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ISP_ADD_REQUEST",
          "args": [
            "isp",
            "iptr"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_TDQE",
          "args": [
            "isp",
            "\"isp_lun_cmd\"",
            "(int) optr",
            "&el"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISP_SWIZ_ENABLE_LUN",
          "args": [
            "isp",
            "outp",
            "&el"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Request Queue Overflow in isp_lun_cmd\\n\"",
            "isp->isp_name"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_getrqentry",
          "args": [
            "isp",
            "&iptr",
            "&optr",
            "&outp"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "isp_getrqentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_inline.h",
          "lines": "258-277",
          "snippet": "static INLINE int\nisp_getrqentry(isp, iptrp, optrp, resultp)\n\tstruct ispsoftc *isp;\n\tu_int16_t *iptrp;\n\tu_int16_t *optrp;\n\tvoid **resultp;\n{\n\tvolatile u_int16_t iptr, optr;\n\n\toptr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\tiptr = isp->isp_reqidx;\n\t*resultp = ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);\n\tiptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);\n\tif (iptr == optr) {\n\t\treturn (1);\n\t}\n\t*optrp = optr;\n\t*iptrp = iptr;\n\treturn (0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static INLINE int\nisp_getrqentry(isp, iptrp, optrp, resultp)\n\tstruct ispsoftc *isp;\n\tu_int16_t *iptrp;\n\tu_int16_t *optrp;\n\tvoid **resultp;\n{\n\tvolatile u_int16_t iptr, optr;\n\n\toptr = isp->isp_reqodx = ISP_READ(isp, OUTMAILBOX4);\n\tiptr = isp->isp_reqidx;\n\t*resultp = ISP_QUEUE_ENTRY(isp->isp_rquest, iptr);\n\tiptr = ISP_NXT_QENTRY(iptr, RQUEST_QUEUE_LEN);\n\tif (iptr == optr) {\n\t\treturn (1);\n\t}\n\t*optrp = optr;\n\t*iptrp = iptr;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SCSI",
          "args": [
            "isp"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MEMZERO",
          "args": [
            "&el",
            "sizeof (el)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nint\nisp_lun_cmd(isp, cmd, bus, tgt, lun, opaque)\n\tstruct ispsoftc *isp;\n\tint cmd;\n\tint bus;\n\tint tgt;\n\tint lun;\n\tu_int32_t opaque;\n{\n\tlun_entry_t el;\n\tu_int16_t iptr, optr;\n\tvoid *outp;\n\n\n\tMEMZERO(&el, sizeof (el));\n\tif (IS_DUALBUS(isp)) {\n\t\tel.le_rsvd = (bus & 0x1) << 7;\n\t}\n\tel.le_cmd_count = DFLT_CMD_CNT;\n\tel.le_in_count = DFLT_INOTIFY;\n\tif (cmd == RQSTYPE_ENABLE_LUN) {\n\t\tif (IS_SCSI(isp)) {\n\t\t\tel.le_flags = LUN_TQAE;\n\t\t\tel.le_cdb6len = 12;\n\t\t\tel.le_cdb7len = 12;\n\t\t}\n\t} else if (cmd == -RQSTYPE_ENABLE_LUN) {\n\t\tcmd = RQSTYPE_ENABLE_LUN;\n\t\tel.le_cmd_count = 0;\n\t\tel.le_in_count = 0;\n\t} else if (cmd == -RQSTYPE_MODIFY_LUN) {\n\t\tcmd = RQSTYPE_MODIFY_LUN;\n\t\tel.le_ops = LUN_CCDECR | LUN_INDECR;\n\t} else {\n\t\tel.le_ops = LUN_CCINCR | LUN_ININCR;\n\t}\n\tel.le_header.rqs_entry_type = cmd;\n\tel.le_header.rqs_entry_count = 1;\n\tel.le_reserved = opaque;\n\tif (IS_SCSI(isp)) {\n\t\tel.le_tgt = tgt;\n\t\tel.le_lun = lun;\n#ifndef\tISP2100_SCCLUN\n\t} else {\n\t\tel.le_lun = lun;\n#endif\n\t}\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow in isp_lun_cmd\\n\",\n\t\t    isp->isp_name);\n\t\treturn (-1);\n\t}\n\tISP_SWIZ_ENABLE_LUN(isp, outp, &el);\n\tISP_TDQE(isp, \"isp_lun_cmd\", (int) optr, &el);\n\tISP_ADD_REQUEST(isp, iptr);\n\treturn (0);\n}"
  },
  {
    "function_name": "isp_target_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
    "lines": "108-254",
    "snippet": "int\nisp_target_notify(isp, vptr, optrp)\n\tstruct ispsoftc *isp;\n\tvoid *vptr;\n\tu_int16_t *optrp;\n{\n\tu_int16_t status, seqid;\n\tunion {\n\t\tat_entry_t\t*atiop;\n\t\tat2_entry_t\t*at2iop;\n\t\tct_entry_t\t*ctiop;\n\t\tct2_entry_t\t*ct2iop;\n\t\tlun_entry_t\t*lunenp;\n\t\tin_entry_t\t*inotp;\n\t\tin_fcentry_t\t*inot_fcp;\n\t\tna_entry_t\t*nackp;\n\t\tna_fcentry_t\t*nack_fcp;\n\t\tisphdr_t\t*hp;\n\t\tvoid *\t\t*vp;\n#define\tatiop\t\tunp.atiop\n#define\tat2iop\t\tunp.at2iop\n#define\tctiop\t\tunp.ctiop\n#define\tct2iop\t\tunp.ct2iop\n#define\tlunenp\t\tunp.lunenp\n#define\tinotp\t\tunp.inotp\n#define\tinot_fcp\tunp.inot_fcp\n#define\tnackp\t\tunp.nackp\n#define\tnack_fcp\tunp.nack_fcp\n#define\thdrp\t\tunp.hp\n\t} unp;\n\tint bus, rval = 0;\n\n\tunp.vp = vptr;\n\n\tISP_TDQE(isp, \"isp_target_notify\", (int) *optrp, vptr);\n\n\tswitch(hdrp->rqs_entry_type) {\n\tcase RQSTYPE_ATIO:\n\t\tisp_handle_atio(isp, atiop);\n\t\tbreak;\n\tcase RQSTYPE_CTIO:\n\t\tisp_handle_ctio(isp, ctiop);\n\t\tbreak;\n\tcase RQSTYPE_ATIO2:\n\t\tisp_handle_atio2(isp, at2iop);\n\t\tbreak;\n\tcase RQSTYPE_CTIO2:\n\t\tisp_handle_ctio2(isp, ct2iop);\n\t\tbreak;\n\tcase RQSTYPE_ENABLE_LUN:\n\tcase RQSTYPE_MODIFY_LUN:\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, vptr);\n\t\tbreak;\n\n\tcase RQSTYPE_NOTIFY:\n\t\t/*\n\t\t * Either the ISP received a SCSI message it can't\n\t\t * handle, or it's returning an Immed. Notify entry\n\t\t * we sent. We can send Immed. Notify entries to\n\t\t * increment the firmware's resource count for them\n\t\t * (we set this initially in the Enable Lun entry).\n\t\t */\n\t\tbus = 0;\n\t\tif (IS_FC(isp)) {\n\t\t\tstatus = inot_fcp->in_status;\n\t\t\tseqid = inot_fcp->in_seqid;\n\t\t} else {\n\t\t\tstatus = inotp->in_status & 0xff;\n\t\t\tseqid = inotp->in_seqid;\n\t\t\tif (IS_DUALBUS(isp)) {\n\t\t\t\tbus = (inotp->in_iid & 0x80) >> 7;\n\t\t\t\tinotp->in_iid &= ~0x80;\n\t\t\t}\n\t\t}\n\t\tITDEBUG(2, (\"isp_target_notify: Immediate Notify, \"\n\t\t    \"status=0x%x seqid=0x%x\\n\", status, seqid));\n\t\tswitch (status) {\n\t\tcase IN_RESET:\n\t\t\t(void) isp_async(isp, ISPASYNC_BUS_RESET, &bus);\n\t\t\tbreak;\n\t\tcase IN_MSG_RECEIVED:\n\t\tcase IN_IDE_RECEIVED:\n\t\t\tif (IS_FC(isp)) {\n\t\t\t\tisp_got_msg_fc(isp, bus, vptr);\n\t\t\t} else {\n\t\t\t\tisp_got_msg(isp, bus, vptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IN_RSRC_UNAVAIL:\n\t\t\tPRINTF(\"%s: Firmware out of ATIOs\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\tcase IN_ABORT_TASK:\n\t\t\tPRINTF(\"%s: Abort Task for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_PORT_LOGOUT:\n\t\t\tPRINTF(\"%s: Port Logout for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_PORT_CHANGED:\n\t\t\tPRINTF(\"%s: Port Changed for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_GLOBAL_LOGO:\n\t\t\tPRINTF(\"%s: All ports logged out\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: bad status (0x%x) in isp_target_notify\\n\",\n\t\t\t    isp->isp_name, status);\n\t\t\tbreak;\n\t\t}\n\t\tisp_notify_ack(isp, vptr);\n\t\tbreak;\n\n\tcase RQSTYPE_NOTIFY_ACK:\n\t\t/*\n\t\t * The ISP is acknowledging our acknowledgement of an\n\t\t * Immediate Notify entry for some asynchronous event.\n\t\t */\n\t\tif (IS_FC(isp)) {\n\t\t\tITDEBUG(2, (\"%s: Notify Ack status=0x%x seqid 0x%x\\n\",\n\t\t\t    isp->isp_name, nack_fcp->na_status,\n\t\t\t    nack_fcp->na_seqid));\n\t\t} else {\n\t\t\tITDEBUG(2, (\"%s: Notify Ack event 0x%x status=0x%x \"\n\t\t\t    \"seqid 0x%x\\n\", isp->isp_name, nackp->na_event,\n\t\t\t    nackp->na_status, nackp->na_seqid));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown entry type 0x%x in isp_target_notify\",\n\t\t    isp->isp_name, hdrp->rqs_entry_type);\n\t\trval = -1;\n\t\tbreak;\n\t}\n#undef\tatiop\n#undef\tat2iop\n#undef\tctiop\n#undef\tct2iop\n#undef\tlunenp\n#undef\tinotp\n#undef\tinot_fcp\n#undef\tnackp\n#undef\tnack_fcp\n#undef\thdrp\n\treturn (rval);\n}",
    "includes": [
      "#include \"isp_linux.h\"",
      "#include <dev/ic/isp_openbsd.h>",
      "#include <dev/isp/isp_freebsd.h>",
      "#include <dev/ic/isp_netbsd.h>"
    ],
    "macros_used": [
      "#define\thdrp\t\tunp.hp",
      "#define\tnack_fcp\tunp.nack_fcp",
      "#define\tnackp\t\tunp.nackp",
      "#define\tinot_fcp\tunp.inot_fcp",
      "#define\tinotp\t\tunp.inotp",
      "#define\tlunenp\t\tunp.lunenp",
      "#define\tct2iop\t\tunp.ct2iop",
      "#define\tctiop\t\tunp.ctiop",
      "#define\tat2iop\t\tunp.at2iop",
      "#define\tatiop\t\tunp.atiop"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Unknown entry type 0x%x in isp_target_notify\"",
            "isp->isp_name",
            "hdrp->rqs_entry_type"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ITDEBUG",
          "args": [
            "2",
            "(\"%s: Notify Ack event 0x%x status=0x%x \"\n\t\t\t    \"seqid 0x%x\\n\", isp->isp_name, nackp->na_event,\n\t\t\t    nackp->na_status, nackp->na_seqid)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ITDEBUG",
          "args": [
            "2",
            "(\"%s: Notify Ack status=0x%x seqid 0x%x\\n\",\n\t\t\t    isp->isp_name, nack_fcp->na_status,\n\t\t\t    nack_fcp->na_seqid)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_notify_ack",
          "args": [
            "isp",
            "vptr"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "isp_notify_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "638-695",
          "snippet": "static void\nisp_notify_ack(isp, arg)\n\tstruct ispsoftc *isp;\n\tvoid *arg;\n{\n\tchar storage[QENTRY_LEN];\n\tu_int16_t iptr, optr;\n\tvoid *outp;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow For isp_notify_ack\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\tMEMZERO(storage, QENTRY_LEN);\n\n\tif (IS_FC(isp)) {\n\t\tna_fcentry_t *na = (na_fcentry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_fcentry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n#ifdef\tISP2100_SCCLUN\n\t\t\tna->na_lun = inp->in_scclun;\n#else\n\t\t\tna->na_lun = inp->in_lun;\n#endif\n\t\t\tna->na_task_flags = inp->in_task_flags;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tna->na_flags = NAFC_RCOUNT;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags |= NAFC_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NAFC_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK_FC(isp, outp, na);\n\t} else {\n\t\tna_entry_t *na = (na_entry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_entry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n\t\t\tna->na_lun = inp->in_lun;\n\t\t\tna->na_tgt = inp->in_tgt;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK(isp, outp, na);\n\t}\n\tISP_TDQE(isp, \"isp_notify_ack\", (int) optr, storage);\n\tISP_ADD_REQUEST(isp, iptr);\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_notify_ack(isp, arg)\n\tstruct ispsoftc *isp;\n\tvoid *arg;\n{\n\tchar storage[QENTRY_LEN];\n\tu_int16_t iptr, optr;\n\tvoid *outp;\n\n\tif (isp_getrqentry(isp, &iptr, &optr, &outp)) {\n\t\tPRINTF(\"%s: Request Queue Overflow For isp_notify_ack\\n\",\n\t\t    isp->isp_name);\n\t\treturn;\n\t}\n\n\tMEMZERO(storage, QENTRY_LEN);\n\n\tif (IS_FC(isp)) {\n\t\tna_fcentry_t *na = (na_fcentry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_fcentry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n#ifdef\tISP2100_SCCLUN\n\t\t\tna->na_lun = inp->in_scclun;\n#else\n\t\t\tna->na_lun = inp->in_lun;\n#endif\n\t\t\tna->na_task_flags = inp->in_task_flags;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tna->na_flags = NAFC_RCOUNT;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags |= NAFC_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NAFC_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK_FC(isp, outp, na);\n\t} else {\n\t\tna_entry_t *na = (na_entry_t *) storage;\n\t\tif (arg) {\n\t\t\tin_entry_t *inp = arg;\n\t\t\tMEMCPY(storage, arg, sizeof (isphdr_t));\n\t\t\tna->na_iid = inp->in_iid;\n\t\t\tna->na_lun = inp->in_lun;\n\t\t\tna->na_tgt = inp->in_tgt;\n\t\t\tna->na_seqid = inp->in_seqid;\n\t\t\tif (inp->in_status == IN_RESET) {\n\t\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t\t}\n\t\t} else {\n\t\t\tna->na_flags = NA_RST_CLRD;\n\t\t}\n\t\tISP_SWIZ_NOT_ACK(isp, outp, na);\n\t}\n\tISP_TDQE(isp, \"isp_notify_ack\", (int) optr, storage);\n\tISP_ADD_REQUEST(isp, iptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: bad status (0x%x) in isp_target_notify\\n\"",
            "isp->isp_name",
            "status"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: All ports logged out\\n\"",
            "isp->isp_name"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Port Changed for Initiator %d RX_ID 0x%x\\n\"",
            "isp->isp_name",
            "inot_fcp->in_iid",
            "seqid"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Port Logout for Initiator %d RX_ID 0x%x\\n\"",
            "isp->isp_name",
            "inot_fcp->in_iid",
            "seqid"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Abort Task for Initiator %d RX_ID 0x%x\\n\"",
            "isp->isp_name",
            "inot_fcp->in_iid",
            "seqid"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PRINTF",
          "args": [
            "\"%s: Firmware out of ATIOs\\n\"",
            "isp->isp_name"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_got_msg",
          "args": [
            "isp",
            "bus",
            "vptr"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "isp_got_msg_fc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "579-636",
          "snippet": "static void\nisp_got_msg_fc(isp, bus, inp)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tin_fcentry_t *inp;\n{\n\tstatic char *f1 = \"%s: %s from iid %d lun %d seq 0x%x\\n\";\n\tstatic char *f2 = \n\t    \"%s: unknown %s 0x%x lun %d iid %d task flags 0x%x seq 0x%x\\n\";\n\n\tif (inp->in_status != IN_MSG_RECEIVED) {\n\t\tPRINTF(f2, isp->isp_name, \"immediate notify status\",\n\t\t    inp->in_status, inp->in_lun, inp->in_iid,\n\t\t    inp->in_task_flags,  inp->in_seqid);\n\t} else {\n\t\ttmd_msg_t msg;\n\n\t\tMEMZERO(&msg, sizeof (msg));\n\t\tmsg.nt_bus = bus;\n\t\tmsg.nt_iid = inp->in_iid;\n#ifdef\tISP2100_SCCLUN\n\t\tmsg.nt_lun = inp->in_scclun;\n#else\n\t\tmsg.nt_lun = inp->in_lun;\n#endif\n\t\tmsg.nt_tagval = inp->in_seqid;\n\n\t\tif (inp->in_task_flags & TASK_FLAGS_ABORT_TASK) {\n\t\t\tPRINTF(f1, isp->isp_name, \"ABORT TASK\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_ABORT_TAG;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_TASK_SET) {\n\t\t\tPRINTF(f1, isp->isp_name, \"CLEAR TASK SET\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_CLEAR_QUEUE;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_TARGET_RESET) {\n\t\t\tPRINTF(f1, isp->isp_name, \"TARGET RESET\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_BUS_DEV_RESET;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_ACA) {\n\t\t\tPRINTF(f1, isp->isp_name, \"CLEAR ACA\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\t/* ???? */\n\t\t\tmsg.nt_msg[0] = MSG_REL_RECOVERY;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_TERMINATE_TASK) {\n\t\t\tPRINTF(f1, isp->isp_name, \"TERMINATE TASK\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_TERM_IO_PROC;\n\t\t} else {\n\t\t\tPRINTF(f2, isp->isp_name, \"task flag\",\n\t\t\t    inp->in_status, inp->in_lun, inp->in_iid,\n\t\t\t    inp->in_task_flags,  inp->in_seqid);\n\t\t}\n\t\tif (msg.nt_msg[0]) {\n\t\t\t(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_got_msg_fc(isp, bus, inp)\n\tstruct ispsoftc *isp;\n\tint bus;\n\tin_fcentry_t *inp;\n{\n\tstatic char *f1 = \"%s: %s from iid %d lun %d seq 0x%x\\n\";\n\tstatic char *f2 = \n\t    \"%s: unknown %s 0x%x lun %d iid %d task flags 0x%x seq 0x%x\\n\";\n\n\tif (inp->in_status != IN_MSG_RECEIVED) {\n\t\tPRINTF(f2, isp->isp_name, \"immediate notify status\",\n\t\t    inp->in_status, inp->in_lun, inp->in_iid,\n\t\t    inp->in_task_flags,  inp->in_seqid);\n\t} else {\n\t\ttmd_msg_t msg;\n\n\t\tMEMZERO(&msg, sizeof (msg));\n\t\tmsg.nt_bus = bus;\n\t\tmsg.nt_iid = inp->in_iid;\n#ifdef\tISP2100_SCCLUN\n\t\tmsg.nt_lun = inp->in_scclun;\n#else\n\t\tmsg.nt_lun = inp->in_lun;\n#endif\n\t\tmsg.nt_tagval = inp->in_seqid;\n\n\t\tif (inp->in_task_flags & TASK_FLAGS_ABORT_TASK) {\n\t\t\tPRINTF(f1, isp->isp_name, \"ABORT TASK\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_ABORT_TAG;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_TASK_SET) {\n\t\t\tPRINTF(f1, isp->isp_name, \"CLEAR TASK SET\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_CLEAR_QUEUE;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_TARGET_RESET) {\n\t\t\tPRINTF(f1, isp->isp_name, \"TARGET RESET\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_BUS_DEV_RESET;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_CLEAR_ACA) {\n\t\t\tPRINTF(f1, isp->isp_name, \"CLEAR ACA\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\t/* ???? */\n\t\t\tmsg.nt_msg[0] = MSG_REL_RECOVERY;\n\t\t} else if (inp->in_task_flags & TASK_FLAGS_TERMINATE_TASK) {\n\t\t\tPRINTF(f1, isp->isp_name, \"TERMINATE TASK\",\n\t\t\t    inp->in_iid, inp->in_lun, inp->in_seqid);\n\t\t\tmsg.nt_msg[0] = MSG_TERM_IO_PROC;\n\t\t} else {\n\t\t\tPRINTF(f2, isp->isp_name, \"task flag\",\n\t\t\t    inp->in_status, inp->in_lun, inp->in_iid,\n\t\t\t    inp->in_task_flags,  inp->in_seqid);\n\t\t}\n\t\tif (msg.nt_msg[0]) {\n\t\t\t(void) isp_async(isp, ISPASYNC_TARGET_MESSAGE, &msg);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_async",
          "args": [
            "isp",
            "ISPASYNC_BUS_RESET",
            "&bus"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "isp_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_openbsd.c",
          "lines": "559-785",
          "snippet": "int\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/isp_openbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void isp_internal_restart(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/isp_openbsd.h>\n\nstatic void isp_internal_restart(void *);\n\nint\nisp_async(isp, cmd, arg)\n\tstruct ispsoftc *isp;\n\tispasync_t cmd;\n\tvoid *arg;\n{\n\tint bus, tgt;\n\tint s = splbio();\n\tswitch (cmd) {\n\tcase ISPASYNC_NEW_TGT_PARAMS:\n\tif (IS_SCSI(isp) && isp->isp_dblev) {\n\t\tsdparam *sdp = isp->isp_param;\n\t\tchar *wt;\n\t\tint mhz, flags, period;\n\n\t\ttgt = *((int *) arg);\n\t\tbus = (tgt >> 16) & 0xffff;\n\t\ttgt &= 0xffff;\n\t\tsdp += bus;\n\n\t\tflags = sdp->isp_devparam[tgt].cur_dflags;\n\t\tperiod = sdp->isp_devparam[tgt].cur_period;\n\t\tif ((flags & DPARM_SYNC) && period &&\n\t\t    (sdp->isp_devparam[tgt].cur_offset) != 0) {\n\t\t\tif (sdp->isp_lvdmode || period < 0xc) {\n\t\t\t\tswitch (period) {\n\t\t\t\tcase 0x9:\n\t\t\t\t\tmhz = 80;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xa:\n\t\t\t\t\tmhz = 40;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xb:\n\t\t\t\t\tmhz = 33;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xc:\n\t\t\t\t\tmhz = 25;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmhz = 1000 / (period * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tmhz = 0;\n\t\t}\n\t\tswitch (flags & (DPARM_WIDE|DPARM_TQING)) {\n\t\tcase DPARM_WIDE:\n\t\t\twt = \", 16 bit wide\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_TQING:\n\t\t\twt = \", Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tcase DPARM_WIDE|DPARM_TQING:\n\t\t\twt = \", 16 bit wide, Tagged Queueing Enabled\\n\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twt = \"\\n\";\n\t\t\tbreak;\n\t\t}\n\t\tif (mhz) {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d at %dMHz Max \"\n\t\t\t    \"Offset %d%s\", isp->isp_name, bus, tgt, mhz,\n\t\t\t    sdp->isp_devparam[tgt].cur_offset, wt);\n\t\t} else {\n\t\t\tCFGPRINTF(\"%s: Bus %d Target %d Async Mode%s\",\n\t\t\t    isp->isp_name, bus, tgt, wt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ISPASYNC_BUS_RESET:\n\t\tif (arg)\n\t\t\tbus = *((int *) arg);\n\t\telse\n\t\t\tbus = 0;\n\t\tprintf(\"%s: SCSI bus %d reset detected\\n\", isp->isp_name, bus);\n\t\tbreak;\n\tcase ISPASYNC_LOOP_DOWN:\n\t\t/*\n\t\t * Hopefully we get here in time to minimize the number\n\t\t * of commands we are firing off that are sure to die.\n\t\t */\n\t\tisp->isp_osinfo.blocked = 1;\n\t\tprintf(\"%s: Loop DOWN\\n\", isp->isp_name);\n\t\tbreak;\n        case ISPASYNC_LOOP_UP:\n\t\tisp->isp_osinfo.blocked = 0;\n\t\ttimeout(isp_internal_restart, isp, 1);\n\t\tprintf(\"%s: Loop UP\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_PDB_CHANGED:\n\tif (IS_FC(isp) && isp->isp_dblev) {\n\t\tconst char *fmt = \"%s: Target %d (Loop 0x%x) Port ID 0x%x \"\n\t\t    \"role %s %s\\n Port WWN 0x%08x%08x\\n Node WWN 0x%08x%08x\\n\";\n\t\tconst static char *roles[4] = {\n\t\t    \"No\", \"Target\", \"Initiator\", \"Target/Initiator\"\n\t\t};\n\t\tchar *ptr;\n\t\tfcparam *fcp = isp->isp_param;\n\t\tint tgt = *((int *) arg);\n\t\tstruct lportdb *lp = &fcp->portdb[tgt]; \n\n\t\tif (lp->valid) {\n\t\t\tptr = \"arrived\";\n\t\t} else {\n\t\t\tptr = \"disappeared\";\n\t\t}\n\t\tprintf(fmt, isp->isp_name, tgt, lp->loopid, lp->portid,\n\t\t    roles[lp->roles & 0x3], ptr,\n\t\t    (u_int32_t) (lp->port_wwn >> 32),\n\t\t    (u_int32_t) (lp->port_wwn & 0xffffffffLL),\n\t\t    (u_int32_t) (lp->node_wwn >> 32),\n\t\t    (u_int32_t) (lp->node_wwn & 0xffffffffLL));\n\t\tbreak;\n\t}\n#ifdef\tISP2100_FABRIC\n\tcase ISPASYNC_CHANGE_NOTIFY:\n\t\tprintf(\"%s: Name Server Database Changed\\n\", isp->isp_name);\n\t\tbreak;\n\tcase ISPASYNC_FABRIC_DEV:\n\t{\n\t\tint target;\n\t\tstruct lportdb *lp;\n\t\tchar *pt;\n\t\tsns_ganrsp_t *resp = (sns_ganrsp_t *) arg;\n\t\tu_int32_t portid;\n\t\tu_int64_t wwpn, wwnn;\n\t\tfcparam *fcp = isp->isp_param;\n\n\t\tportid =\n\t\t    (((u_int32_t) resp->snscb_port_id[0]) << 16) |\n\t\t    (((u_int32_t) resp->snscb_port_id[1]) << 8) |\n\t\t    (((u_int32_t) resp->snscb_port_id[2]));\n\n\t\twwpn =\n\t\t    (((u_int64_t)resp->snscb_portname[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_portname[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_portname[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_portname[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_portname[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_portname[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_portname[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_portname[7]));\n\n\t\twwnn =\n\t\t    (((u_int64_t)resp->snscb_nodename[0]) << 56) |\n\t\t    (((u_int64_t)resp->snscb_nodename[1]) << 48) |\n\t\t    (((u_int64_t)resp->snscb_nodename[2]) << 40) |\n\t\t    (((u_int64_t)resp->snscb_nodename[3]) << 32) |\n\t\t    (((u_int64_t)resp->snscb_nodename[4]) << 24) |\n\t\t    (((u_int64_t)resp->snscb_nodename[5]) << 16) |\n\t\t    (((u_int64_t)resp->snscb_nodename[6]) <<  8) |\n\t\t    (((u_int64_t)resp->snscb_nodename[7]));\n\t\tif (portid == 0 || wwpn == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (resp->snscb_port_type) {\n\t\tcase 1:\n\t\t\tpt = \"   N_Port\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpt = \"  NL_Port\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpt = \"F/NL_Port\";\n\t\t\tbreak;\n\t\tcase 0x7f:\n\t\t\tpt = \"  Nx_Port\";\n\t\t\tbreak;\n\t\tcase 0x81:\n\t\t\tpt = \"  F_port\";\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tpt = \"  FL_Port\";\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tpt = \"   E_port\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpt = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\tCFGPRINTF(\"%s: %s @ 0x%x, Node 0x%08x%08x Port %08x%08x\\n\",\n\t\t    isp->isp_name, pt, portid,\n\t\t    ((u_int32_t) (wwnn >> 32)), ((u_int32_t) wwnn),\n\t\t    ((u_int32_t) (wwpn >> 32)), ((u_int32_t) wwpn));\n#if\t0\n\t\tif ((resp->snscb_fc4_types[1] & 0x1) == 0) {\n\t\t\tprintf(\"Types 0..3: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t    resp->snscb_fc4_types[0], resp->snscb_fc4_types[1],\n\t\t\t    resp->snscb_fc4_types[3], resp->snscb_fc4_types[3]);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == wwpn && lp->node_wwn == wwnn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target < MAX_FC_TARG) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (target = FC_SNS_ID+1; target < MAX_FC_TARG; target++) {\n\t\t\tlp = &fcp->portdb[target];\n\t\t\tif (lp->port_wwn == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (target == MAX_FC_TARG) {\n\t\t\tprintf(\"%s: no more space for fabric devices\\n\",\n\t\t\t    isp->isp_name);\n\t\t\tbreak;\n\t\t}\n\t\tlp->node_wwn = wwnn;\n\t\tlp->port_wwn = wwpn;\n\t\tlp->portid = portid;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\t(void) splx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITDEBUG",
          "args": [
            "2",
            "(\"isp_target_notify: Immediate Notify, \"\n\t\t    \"status=0x%x seqid=0x%x\\n\", status, seqid)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DUALBUS",
          "args": [
            "isp"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_FC",
          "args": [
            "isp"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isp_handle_ctio2",
          "args": [
            "isp",
            "ct2iop"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "isp_handle_ctio2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "1045-1227",
          "snippet": "static void\nisp_handle_ctio2(isp, ct)\n\tstruct ispsoftc *isp;\n\tct2_entry_t *ct;\n{\n\tISP_SCSI_XFER_T *xs;\n\tint pl = 3;\n\tchar *fmsg = NULL;\n\n\tif (ct->ct_reserved) {\n\t\txs = isp_find_xs(isp, ct->ct_reserved);\n\t\tif (xs == NULL)\n\t\t\tpl = 0;\n\t} else {\n\t\tpl = 2;\n\t\txs = NULL;\n\t}\n\n\tswitch(ct->ct_status & ~QLTM_SVALID) {\n\tcase CT_OK:\n\t\t/*\n\t\t * There are generally 2 possibilities as to why we'd get\n\t\t * this condition:\n\t\t * \tWe sent or received data.\n\t\t * \tWe sent status & command complete.\n\t\t */\n\n\t\tbreak;\n\n\tcase CT_BDR_MSG:\n\t\t/*\n\t\t * Bus Device Reset message received or the SCSI Bus has\n\t\t * been Reset; the firmware has gone to Bus Free.\n\t\t *\n\t\t * The firmware generates an async mailbox interupt to\n\t\t * notify us of this and returns outstanding CTIOs with this\n\t\t * status. These CTIOs are handled in that same way as\n\t\t * CT_ABORTED ones, so just fall through here.\n\t\t */\n\t\tfmsg = \"Bus Device Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_RESET:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Bus Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_ABORTED:\n\t\t/*\n\t\t * When an Abort message is received the firmware goes to\n\t\t * Bus Free and returns all outstanding CTIOs with the status\n\t\t * set, then sends us an Immediate Notify entry.\n\t\t */\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"ABORT TASK sent by Initiator\";\n\n\t\tPRINTF(\"%s: CTIO2 destroyed by %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_INVAL:\n\t\t/*\n\t\t * CTIO rejected by the firmware - invalid data direction.\n\t\t */\n\t\tPRINTF(\"%s: CTIO2 had wrong data directiond\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase CT_NOPATH:\n\t\t/*\n\t\t * CTIO rejected by the firmware due \"no path for the\n\t\t * nondisconnecting nexus specified\". This means that\n\t\t * we tried to access the bus while a non-disconnecting\n\t\t * command is in process.\n\t\t */\n\t\tPRINTF(\"%s: Firmware rejected CTIO2 for bad nexus %d->%d\\n\",\n\t\t    isp->isp_name, ct->ct_iid, ct->ct_lun);\n\t\tbreak;\n\n\tcase CT_RSELTMO:\n\t\tfmsg = \"Reselection\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TIMEOUT:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Command\";\n\t\tPRINTF(\"%s: Firmware timed out on %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_ERR:\n\t\tfmsg = \"Completed with Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_PHASE_ERROR:\t/* Bus phase sequence error */\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Phase Sequence Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TERMINATED:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"terminated by TERMINATE TRANSFER\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_LOGOUT:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Port Logout\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_PORTNOTAVAIL:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Port not available\";\n\tcase CT_NOACK:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"unacknowledged Immediate Notify pending\";\n\n\t\tPRINTF(\"%s: CTIO returned by f/w- %s\\n\", isp->isp_name, fmsg);\n#if\t0\n\t\t\tif (status & SENSEVALID) {\n\t\t\t\tbcopy((caddr_t) (cep + CTIO_SENSE_OFFSET),\n\t\t\t\t    (caddr_t) &cdp->cd_sensedata,\n\t\t\t\t    sizeof(scsi_sense_t));\n\t\t\t\tcdp->cd_flags |= CDF_SENSEVALID;\n\t\t\t}\n#endif\n\t\tbreak;\n\n\tcase CT_INVRXID:\n\t\t/*\n\t\t * CTIO rejected by the firmware because an invalid RX_ID.\n\t\t * Just print a message.\n\t\t */\n\t\tPRINTF(\"%s: CTIO2 completed with Invalid RX_ID 0x%x\\n\",\n\t\t    isp->isp_name, ct->ct_rxid);\n\t\tbreak;\n\n\tdefault:\n\t\tIDPRINTF(pl, (\"%s: Unknown CTIO status 0x%x\\n\", isp->isp_name,\n\t\t    ct->ct_status & ~QLTM_SVALID));\n\t\tbreak;\n\t}\n\n\tif (xs == NULL) {\n\t\t/*\n\t\t * There may be more than one CTIO for a data transfer,\n\t\t * or this may be a status CTIO we're not monitoring.\n\t\t *\n\t\t * The assumption is that they'll all be returned in the\n\t\t * order we got them.\n\t\t */\n\t\tif (ct->ct_reserved == 0) {\n\t\t\tif ((ct->ct_flags & CT_SENDSTATUS) == 0) {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: intermediate CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t} else {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: unmonitored CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t}\n\t\t} else {\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: NO xs for CTIO (handle 0x%x) status 0x%x\\n\",\n\t\t\t    isp->isp_name, ct->ct_reserved,\n\t\t\t    ct->ct_status & ~QLTM_SVALID));\n\t\t}\n\t} else {\n\t\tif (ct->ct_flags & CT_SENDSTATUS) {\n\t\t\t/*\n\t\t\t * Sent status and command complete.\n\t\t\t *\n\t\t\t * We're now really done with this command, so we\n\t\t\t * punt to the platform dependent layers because\n\t\t\t * only there can we do the appropriate command\n\t\t\t * complete thread synchronization.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: status CTIO complete\\n\", isp->isp_name));\n\t\t} else {\n\t\t\t/*\n\t\t\t * Final CTIO completed. Release DMA resources and\n\t\t\t * notify platform dependent layers.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: data CTIO complete\\n\", isp->isp_name));\n\t\t\tISP_DMAFREE(isp, xs, ct->ct_reserved);\n\t\t}\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);\n\t\t/*\n\t\t * The platform layer will destroy the handle if appropriate.\n\t\t */\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_handle_ctio2(isp, ct)\n\tstruct ispsoftc *isp;\n\tct2_entry_t *ct;\n{\n\tISP_SCSI_XFER_T *xs;\n\tint pl = 3;\n\tchar *fmsg = NULL;\n\n\tif (ct->ct_reserved) {\n\t\txs = isp_find_xs(isp, ct->ct_reserved);\n\t\tif (xs == NULL)\n\t\t\tpl = 0;\n\t} else {\n\t\tpl = 2;\n\t\txs = NULL;\n\t}\n\n\tswitch(ct->ct_status & ~QLTM_SVALID) {\n\tcase CT_OK:\n\t\t/*\n\t\t * There are generally 2 possibilities as to why we'd get\n\t\t * this condition:\n\t\t * \tWe sent or received data.\n\t\t * \tWe sent status & command complete.\n\t\t */\n\n\t\tbreak;\n\n\tcase CT_BDR_MSG:\n\t\t/*\n\t\t * Bus Device Reset message received or the SCSI Bus has\n\t\t * been Reset; the firmware has gone to Bus Free.\n\t\t *\n\t\t * The firmware generates an async mailbox interupt to\n\t\t * notify us of this and returns outstanding CTIOs with this\n\t\t * status. These CTIOs are handled in that same way as\n\t\t * CT_ABORTED ones, so just fall through here.\n\t\t */\n\t\tfmsg = \"Bus Device Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_RESET:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Bus Reset\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_ABORTED:\n\t\t/*\n\t\t * When an Abort message is received the firmware goes to\n\t\t * Bus Free and returns all outstanding CTIOs with the status\n\t\t * set, then sends us an Immediate Notify entry.\n\t\t */\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"ABORT TASK sent by Initiator\";\n\n\t\tPRINTF(\"%s: CTIO2 destroyed by %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_INVAL:\n\t\t/*\n\t\t * CTIO rejected by the firmware - invalid data direction.\n\t\t */\n\t\tPRINTF(\"%s: CTIO2 had wrong data directiond\\n\", isp->isp_name);\n\t\tbreak;\n\n\tcase CT_NOPATH:\n\t\t/*\n\t\t * CTIO rejected by the firmware due \"no path for the\n\t\t * nondisconnecting nexus specified\". This means that\n\t\t * we tried to access the bus while a non-disconnecting\n\t\t * command is in process.\n\t\t */\n\t\tPRINTF(\"%s: Firmware rejected CTIO2 for bad nexus %d->%d\\n\",\n\t\t    isp->isp_name, ct->ct_iid, ct->ct_lun);\n\t\tbreak;\n\n\tcase CT_RSELTMO:\n\t\tfmsg = \"Reselection\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TIMEOUT:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Command\";\n\t\tPRINTF(\"%s: Firmware timed out on %s\\n\", isp->isp_name, fmsg);\n\t\tbreak;\n\n\tcase CT_ERR:\n\t\tfmsg = \"Completed with Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_PHASE_ERROR:\t/* Bus phase sequence error */\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Phase Sequence Error\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_TERMINATED:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"terminated by TERMINATE TRANSFER\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_LOGOUT:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Port Logout\";\n\t\t/*FALLTHROUGH*/\n\tcase CT_PORTNOTAVAIL:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"Port not available\";\n\tcase CT_NOACK:\n\t\tif (fmsg == NULL)\n\t\t\tfmsg = \"unacknowledged Immediate Notify pending\";\n\n\t\tPRINTF(\"%s: CTIO returned by f/w- %s\\n\", isp->isp_name, fmsg);\n#if\t0\n\t\t\tif (status & SENSEVALID) {\n\t\t\t\tbcopy((caddr_t) (cep + CTIO_SENSE_OFFSET),\n\t\t\t\t    (caddr_t) &cdp->cd_sensedata,\n\t\t\t\t    sizeof(scsi_sense_t));\n\t\t\t\tcdp->cd_flags |= CDF_SENSEVALID;\n\t\t\t}\n#endif\n\t\tbreak;\n\n\tcase CT_INVRXID:\n\t\t/*\n\t\t * CTIO rejected by the firmware because an invalid RX_ID.\n\t\t * Just print a message.\n\t\t */\n\t\tPRINTF(\"%s: CTIO2 completed with Invalid RX_ID 0x%x\\n\",\n\t\t    isp->isp_name, ct->ct_rxid);\n\t\tbreak;\n\n\tdefault:\n\t\tIDPRINTF(pl, (\"%s: Unknown CTIO status 0x%x\\n\", isp->isp_name,\n\t\t    ct->ct_status & ~QLTM_SVALID));\n\t\tbreak;\n\t}\n\n\tif (xs == NULL) {\n\t\t/*\n\t\t * There may be more than one CTIO for a data transfer,\n\t\t * or this may be a status CTIO we're not monitoring.\n\t\t *\n\t\t * The assumption is that they'll all be returned in the\n\t\t * order we got them.\n\t\t */\n\t\tif (ct->ct_reserved == 0) {\n\t\t\tif ((ct->ct_flags & CT_SENDSTATUS) == 0) {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: intermediate CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t} else {\n\t\t\t\tIDPRINTF(pl,\n\t\t\t\t    (\"%s: unmonitored CTIO completed ok\\n\",\n\t\t\t\t    isp->isp_name));\n\t\t\t}\n\t\t} else {\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: NO xs for CTIO (handle 0x%x) status 0x%x\\n\",\n\t\t\t    isp->isp_name, ct->ct_reserved,\n\t\t\t    ct->ct_status & ~QLTM_SVALID));\n\t\t}\n\t} else {\n\t\tif (ct->ct_flags & CT_SENDSTATUS) {\n\t\t\t/*\n\t\t\t * Sent status and command complete.\n\t\t\t *\n\t\t\t * We're now really done with this command, so we\n\t\t\t * punt to the platform dependent layers because\n\t\t\t * only there can we do the appropriate command\n\t\t\t * complete thread synchronization.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: status CTIO complete\\n\", isp->isp_name));\n\t\t} else {\n\t\t\t/*\n\t\t\t * Final CTIO completed. Release DMA resources and\n\t\t\t * notify platform dependent layers.\n\t\t\t */\n\t\t\tIDPRINTF(pl,\n\t\t\t    (\"%s: data CTIO complete\\n\", isp->isp_name));\n\t\t\tISP_DMAFREE(isp, xs, ct->ct_reserved);\n\t\t}\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, ct);\n\t\t/*\n\t\t * The platform layer will destroy the handle if appropriate.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isp_handle_atio2",
          "args": [
            "isp",
            "at2iop"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "isp_handle_atio2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/isp_target.c",
          "lines": "781-865",
          "snippet": "static void\nisp_handle_atio2(isp, aep)\n\tstruct ispsoftc *isp;\n\tat2_entry_t *aep;\n{\n\tint lun;\n#ifdef\tISP2100_SCCLUN\n\tlun = aep->at_scclun;\n#else\n\tlun = aep->at_lun;\n#endif\n\t/*\n\t * The firmware status (except for the QLTM_SVALID bit) indicates\n\t * why this ATIO was sent to us.\n\t *\n\t * If QLTM_SVALID is set, the firware has recommended Sense Data.\n\t *\n\t * If the DISCONNECTS DISABLED bit is set in the flags field,\n\t * we're still connected on the SCSI bus - i.e. the initiator\n\t * did not set DiscPriv in the identify message. We don't care\n\t * about this so it's ignored.\n\t */\n\n\tswitch(aep->at_status & ~QLTM_SVALID) {\n\tcase AT_PATH_INVALID:\n\t\t/*\n\t\t * ATIO rejected by the firmware due to disabled lun.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO2 for disabled lun %d\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\tcase AT_NOCAP:\n\t\t/*\n\t\t * Requested Capability not available\n\t\t * We sent an ATIO that overflowed the firmware's\n\t\t * command resource count.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO2 for lun %d because of command count\"\n\t\t    \" overflow\\n\", isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_BDR_MSG:\n\t\t/*\n\t\t * If we send an ATIO to the firmware to increment\n\t\t * its command resource count, and the firmware is\n\t\t * recovering from a Bus Device Reset, it returns\n\t\t * the ATIO with this status. We set the command\n\t\t * resource count in the Enable Lun entry and no\n\t\t * not increment it. Therefore we should never get\n\t\t * this status here.\n\t\t */\n\t\tPRINTF(\"%s: ATIO2 returned for lun %d because it was in the \"\n\t\t    \" middle of coping with a Bus Device Reset\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_CDB:\t\t/* Got a CDB */\n\t\t/*\n\t\t * Punt to platform specific layer.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, aep);\n\t\tbreak;\n\n\tcase AT_RESET:\n\t\t/*\n\t\t * A bus reset came along an blew away this command. Why\n\t\t * they do this in addition the async event code stuff,\n\t\t * I dunno.\n\t\t *\n\t\t * Ignore it because the async event will clear things\n\t\t * up for us.\n\t\t */\n\t\tPRINTF(\"%s: ATIO2 returned for lun %d from initiator %d because\"\n\t\t    \" a Bus Reset occurred\\n\", isp->isp_name, lun,\n\t\t    aep->at_iid);\n\t\tbreak;\n\n\n\tdefault:\n\t\tPRINTF(\"%s: Unknown ATIO2 status 0x%x from initiator %d for lun\"\n\t\t    \" %d\\n\", isp->isp_name, aep->at_status, aep->at_iid, lun);\n\t\t(void) isp_target_put_atio(isp, aep->at_iid, 0, lun, 0, 0);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"isp_linux.h\"",
            "#include <dev/ic/isp_openbsd.h>",
            "#include <dev/isp/isp_freebsd.h>",
            "#include <dev/ic/isp_netbsd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\nstatic void\nisp_handle_atio2(isp, aep)\n\tstruct ispsoftc *isp;\n\tat2_entry_t *aep;\n{\n\tint lun;\n#ifdef\tISP2100_SCCLUN\n\tlun = aep->at_scclun;\n#else\n\tlun = aep->at_lun;\n#endif\n\t/*\n\t * The firmware status (except for the QLTM_SVALID bit) indicates\n\t * why this ATIO was sent to us.\n\t *\n\t * If QLTM_SVALID is set, the firware has recommended Sense Data.\n\t *\n\t * If the DISCONNECTS DISABLED bit is set in the flags field,\n\t * we're still connected on the SCSI bus - i.e. the initiator\n\t * did not set DiscPriv in the identify message. We don't care\n\t * about this so it's ignored.\n\t */\n\n\tswitch(aep->at_status & ~QLTM_SVALID) {\n\tcase AT_PATH_INVALID:\n\t\t/*\n\t\t * ATIO rejected by the firmware due to disabled lun.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO2 for disabled lun %d\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\tcase AT_NOCAP:\n\t\t/*\n\t\t * Requested Capability not available\n\t\t * We sent an ATIO that overflowed the firmware's\n\t\t * command resource count.\n\t\t */\n\t\tPRINTF(\"%s: rejected ATIO2 for lun %d because of command count\"\n\t\t    \" overflow\\n\", isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_BDR_MSG:\n\t\t/*\n\t\t * If we send an ATIO to the firmware to increment\n\t\t * its command resource count, and the firmware is\n\t\t * recovering from a Bus Device Reset, it returns\n\t\t * the ATIO with this status. We set the command\n\t\t * resource count in the Enable Lun entry and no\n\t\t * not increment it. Therefore we should never get\n\t\t * this status here.\n\t\t */\n\t\tPRINTF(\"%s: ATIO2 returned for lun %d because it was in the \"\n\t\t    \" middle of coping with a Bus Device Reset\\n\",\n\t\t    isp->isp_name, lun);\n\t\tbreak;\n\n\tcase AT_CDB:\t\t/* Got a CDB */\n\t\t/*\n\t\t * Punt to platform specific layer.\n\t\t */\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, aep);\n\t\tbreak;\n\n\tcase AT_RESET:\n\t\t/*\n\t\t * A bus reset came along an blew away this command. Why\n\t\t * they do this in addition the async event code stuff,\n\t\t * I dunno.\n\t\t *\n\t\t * Ignore it because the async event will clear things\n\t\t * up for us.\n\t\t */\n\t\tPRINTF(\"%s: ATIO2 returned for lun %d from initiator %d because\"\n\t\t    \" a Bus Reset occurred\\n\", isp->isp_name, lun,\n\t\t    aep->at_iid);\n\t\tbreak;\n\n\n\tdefault:\n\t\tPRINTF(\"%s: Unknown ATIO2 status 0x%x from initiator %d for lun\"\n\t\t    \" %d\\n\", isp->isp_name, aep->at_status, aep->at_iid, lun);\n\t\t(void) isp_target_put_atio(isp, aep->at_iid, 0, lun, 0, 0);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISP_TDQE",
          "args": [
            "isp",
            "\"isp_target_notify\"",
            "(int) *optrp",
            "vptr"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isp_linux.h\"\n#include <dev/ic/isp_openbsd.h>\n#include <dev/isp/isp_freebsd.h>\n#include <dev/ic/isp_netbsd.h>\n\n#define\thdrp\t\tunp.hp\n#define\tnack_fcp\tunp.nack_fcp\n#define\tnackp\t\tunp.nackp\n#define\tinot_fcp\tunp.inot_fcp\n#define\tinotp\t\tunp.inotp\n#define\tlunenp\t\tunp.lunenp\n#define\tct2iop\t\tunp.ct2iop\n#define\tctiop\t\tunp.ctiop\n#define\tat2iop\t\tunp.at2iop\n#define\tatiop\t\tunp.atiop\n\nint\nisp_target_notify(isp, vptr, optrp)\n\tstruct ispsoftc *isp;\n\tvoid *vptr;\n\tu_int16_t *optrp;\n{\n\tu_int16_t status, seqid;\n\tunion {\n\t\tat_entry_t\t*atiop;\n\t\tat2_entry_t\t*at2iop;\n\t\tct_entry_t\t*ctiop;\n\t\tct2_entry_t\t*ct2iop;\n\t\tlun_entry_t\t*lunenp;\n\t\tin_entry_t\t*inotp;\n\t\tin_fcentry_t\t*inot_fcp;\n\t\tna_entry_t\t*nackp;\n\t\tna_fcentry_t\t*nack_fcp;\n\t\tisphdr_t\t*hp;\n\t\tvoid *\t\t*vp;\n#define\tatiop\t\tunp.atiop\n#define\tat2iop\t\tunp.at2iop\n#define\tctiop\t\tunp.ctiop\n#define\tct2iop\t\tunp.ct2iop\n#define\tlunenp\t\tunp.lunenp\n#define\tinotp\t\tunp.inotp\n#define\tinot_fcp\tunp.inot_fcp\n#define\tnackp\t\tunp.nackp\n#define\tnack_fcp\tunp.nack_fcp\n#define\thdrp\t\tunp.hp\n\t} unp;\n\tint bus, rval = 0;\n\n\tunp.vp = vptr;\n\n\tISP_TDQE(isp, \"isp_target_notify\", (int) *optrp, vptr);\n\n\tswitch(hdrp->rqs_entry_type) {\n\tcase RQSTYPE_ATIO:\n\t\tisp_handle_atio(isp, atiop);\n\t\tbreak;\n\tcase RQSTYPE_CTIO:\n\t\tisp_handle_ctio(isp, ctiop);\n\t\tbreak;\n\tcase RQSTYPE_ATIO2:\n\t\tisp_handle_atio2(isp, at2iop);\n\t\tbreak;\n\tcase RQSTYPE_CTIO2:\n\t\tisp_handle_ctio2(isp, ct2iop);\n\t\tbreak;\n\tcase RQSTYPE_ENABLE_LUN:\n\tcase RQSTYPE_MODIFY_LUN:\n\t\t(void) isp_async(isp, ISPASYNC_TARGET_ACTION, vptr);\n\t\tbreak;\n\n\tcase RQSTYPE_NOTIFY:\n\t\t/*\n\t\t * Either the ISP received a SCSI message it can't\n\t\t * handle, or it's returning an Immed. Notify entry\n\t\t * we sent. We can send Immed. Notify entries to\n\t\t * increment the firmware's resource count for them\n\t\t * (we set this initially in the Enable Lun entry).\n\t\t */\n\t\tbus = 0;\n\t\tif (IS_FC(isp)) {\n\t\t\tstatus = inot_fcp->in_status;\n\t\t\tseqid = inot_fcp->in_seqid;\n\t\t} else {\n\t\t\tstatus = inotp->in_status & 0xff;\n\t\t\tseqid = inotp->in_seqid;\n\t\t\tif (IS_DUALBUS(isp)) {\n\t\t\t\tbus = (inotp->in_iid & 0x80) >> 7;\n\t\t\t\tinotp->in_iid &= ~0x80;\n\t\t\t}\n\t\t}\n\t\tITDEBUG(2, (\"isp_target_notify: Immediate Notify, \"\n\t\t    \"status=0x%x seqid=0x%x\\n\", status, seqid));\n\t\tswitch (status) {\n\t\tcase IN_RESET:\n\t\t\t(void) isp_async(isp, ISPASYNC_BUS_RESET, &bus);\n\t\t\tbreak;\n\t\tcase IN_MSG_RECEIVED:\n\t\tcase IN_IDE_RECEIVED:\n\t\t\tif (IS_FC(isp)) {\n\t\t\t\tisp_got_msg_fc(isp, bus, vptr);\n\t\t\t} else {\n\t\t\t\tisp_got_msg(isp, bus, vptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IN_RSRC_UNAVAIL:\n\t\t\tPRINTF(\"%s: Firmware out of ATIOs\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\tcase IN_ABORT_TASK:\n\t\t\tPRINTF(\"%s: Abort Task for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_PORT_LOGOUT:\n\t\t\tPRINTF(\"%s: Port Logout for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_PORT_CHANGED:\n\t\t\tPRINTF(\"%s: Port Changed for Initiator %d RX_ID 0x%x\\n\",\n\t\t\t    isp->isp_name, inot_fcp->in_iid, seqid);\n\t\t\tbreak;\n\t\tcase IN_GLOBAL_LOGO:\n\t\t\tPRINTF(\"%s: All ports logged out\\n\", isp->isp_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTF(\"%s: bad status (0x%x) in isp_target_notify\\n\",\n\t\t\t    isp->isp_name, status);\n\t\t\tbreak;\n\t\t}\n\t\tisp_notify_ack(isp, vptr);\n\t\tbreak;\n\n\tcase RQSTYPE_NOTIFY_ACK:\n\t\t/*\n\t\t * The ISP is acknowledging our acknowledgement of an\n\t\t * Immediate Notify entry for some asynchronous event.\n\t\t */\n\t\tif (IS_FC(isp)) {\n\t\t\tITDEBUG(2, (\"%s: Notify Ack status=0x%x seqid 0x%x\\n\",\n\t\t\t    isp->isp_name, nack_fcp->na_status,\n\t\t\t    nack_fcp->na_seqid));\n\t\t} else {\n\t\t\tITDEBUG(2, (\"%s: Notify Ack event 0x%x status=0x%x \"\n\t\t\t    \"seqid 0x%x\\n\", isp->isp_name, nackp->na_event,\n\t\t\t    nackp->na_status, nackp->na_seqid));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tPRINTF(\"%s: Unknown entry type 0x%x in isp_target_notify\",\n\t\t    isp->isp_name, hdrp->rqs_entry_type);\n\t\trval = -1;\n\t\tbreak;\n\t}\n#undef\tatiop\n#undef\tat2iop\n#undef\tctiop\n#undef\tct2iop\n#undef\tlunenp\n#undef\tinotp\n#undef\tinot_fcp\n#undef\tnackp\n#undef\tnack_fcp\n#undef\thdrp\n\treturn (rval);\n}"
  }
]