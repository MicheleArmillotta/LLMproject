[
  {
    "function_name": "dp8390_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "1242-1251",
    "snippet": "void\ndp8390_disable(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\tif (sc->sc_enabled != 0 && sc->sc_disable != NULL) {\n\t\t(*sc->sc_disable)(sc);\n\t\tsc->sc_enabled = 0;\n\t}\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tdp8390_disable",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tdp8390_disable;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_disable(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\tif (sc->sc_enabled != 0 && sc->sc_disable != NULL) {\n\t\t(*sc->sc_disable)(sc);\n\t\tsc->sc_enabled = 0;\n\t}\n}"
  },
  {
    "function_name": "dp8390_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "1222-1237",
    "snippet": "int\ndp8390_enable(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\tif (sc->sc_enabled == 0 && sc->sc_enable != NULL) {\n\t\tif ((*sc->sc_enable)(sc) != 0) {\n\t\t\tprintf(\"%s: device enable failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tsc->sc_enabled = 1;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tdp8390_enable",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: device enable failed\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tdp8390_enable;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nint\ndp8390_enable(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\tif (sc->sc_enabled == 0 && sc->sc_enable != NULL) {\n\t\tif ((*sc->sc_enable)(sc) != 0) {\n\t\t\tprintf(\"%s: device enable failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tsc->sc_enabled = 1;\n\treturn (0);\n}"
  },
  {
    "function_name": "dp8390_write_mbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "1195-1217",
    "snippet": "static __inline__ int\ndp8390_write_mbuf(sc, m, buf)\n\tstruct dp8390_softc *sc;\n\tstruct mbuf *m;\n\tint buf;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\tu_char *data;\n\tint len, totlen = 0;\n\n\tfor (; m ; m = m->m_next) {\n\t\tdata = mtod(m, u_char *);\n\t\tlen = m->m_len;\n\t\tif (len > 0) {\n\t\t\tbus_space_write_region_1(buft, bufh, buf, data, len);\n\t\t\ttotlen += len;\n\t\t\tbuf += len;\n\t\t}\n\t}\n\n\treturn (totlen);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define __inline__\t/* XXX for debugging porpoises */"
    ],
    "globals_used": [
      "static __inline__ int\tdp8390_write_mbuf",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_region_1",
          "args": [
            "buft",
            "bufh",
            "buf",
            "data",
            "len"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_char*"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define __inline__\t/* XXX for debugging porpoises */\n\nstatic __inline__ int\tdp8390_write_mbuf;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nstatic __inline__ int\ndp8390_write_mbuf(sc, m, buf)\n\tstruct dp8390_softc *sc;\n\tstruct mbuf *m;\n\tint buf;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\tu_char *data;\n\tint len, totlen = 0;\n\n\tfor (; m ; m = m->m_next) {\n\t\tdata = mtod(m, u_char *);\n\t\tlen = m->m_len;\n\t\tif (len > 0) {\n\t\t\tbus_space_write_region_1(buft, bufh, buf, data, len);\n\t\t\ttotlen += len;\n\t\t\tbuf += len;\n\t\t}\n\t}\n\n\treturn (totlen);\n}"
  },
  {
    "function_name": "dp8390_ring_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "1162-1187",
    "snippet": "static __inline__ int\ndp8390_ring_copy(sc, src, dst, amount)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tcaddr_t dst;\n\tu_short amount;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\tu_short tmp_amount;\n\n\t/* Does copy wrap to lower addr in ring buffer? */\n\tif (src + amount > sc->mem_end) {\n\t\ttmp_amount = sc->mem_end - src;\n\n\t\t/* Copy amount up to end of NIC memory. */\n\t\tbus_space_read_region_1(buft, bufh, src, dst, tmp_amount);\n\n\t\tamount -= tmp_amount;\n\t\tsrc = sc->mem_ring;\n\t\tdst += tmp_amount;\n\t}\n\tbus_space_read_region_1(buft, bufh, src, dst, amount);\n\n\treturn (src + amount);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define __inline__\t/* XXX for debugging porpoises */"
    ],
    "globals_used": [
      "static __inline__ int\tdp8390_ring_copy",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;",
      "int src;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_region_1",
          "args": [
            "buft",
            "bufh",
            "src",
            "dst",
            "amount"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_region_1",
          "args": [
            "buft",
            "bufh",
            "src",
            "dst",
            "tmp_amount"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define __inline__\t/* XXX for debugging porpoises */\n\nstatic __inline__ int\tdp8390_ring_copy;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\nint src;\n\nstatic __inline__ int\ndp8390_ring_copy(sc, src, dst, amount)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tcaddr_t dst;\n\tu_short amount;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\tu_short tmp_amount;\n\n\t/* Does copy wrap to lower addr in ring buffer? */\n\tif (src + amount > sc->mem_end) {\n\t\ttmp_amount = sc->mem_end - src;\n\n\t\t/* Copy amount up to end of NIC memory. */\n\t\tbus_space_read_region_1(buft, bufh, src, dst, tmp_amount);\n\n\t\tamount -= tmp_amount;\n\t\tsrc = sc->mem_ring;\n\t\tdst += tmp_amount;\n\t}\n\tbus_space_read_region_1(buft, bufh, src, dst, amount);\n\n\treturn (src + amount);\n}"
  },
  {
    "function_name": "dp8390_read_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "1138-1155",
    "snippet": "static __inline__ void\ndp8390_read_hdr(sc, src, hdrp)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tstruct dp8390_ring *hdrp;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\n\t/*\n\t * The byte count includes a 4 byte header that was added by\n\t * the NIC.\n\t */\n\thdrp->rsr = bus_space_read_1(buft, bufh, src);\n\thdrp->next_packet = bus_space_read_1(buft, bufh, src + 1);\n\thdrp->count = bus_space_read_1(buft, bufh, src + 2) |\n\t    (bus_space_read_1(buft, bufh, src + 3) << 8);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define __inline__\t/* XXX for debugging porpoises */"
    ],
    "globals_used": [
      "static __inline__ void\tdp8390_read_hdr",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;",
      "int src;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "buft",
            "bufh",
            "src + 3"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "buft",
            "bufh",
            "src + 2"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "buft",
            "bufh",
            "src + 1"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "buft",
            "bufh",
            "src"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define __inline__\t/* XXX for debugging porpoises */\n\nstatic __inline__ void\tdp8390_read_hdr;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\nint src;\n\nstatic __inline__ void\ndp8390_read_hdr(sc, src, hdrp)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tstruct dp8390_ring *hdrp;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\n\t/*\n\t * The byte count includes a 4 byte header that was added by\n\t * the NIC.\n\t */\n\thdrp->rsr = bus_space_read_1(buft, bufh, src);\n\thdrp->next_packet = bus_space_read_1(buft, bufh, src + 1);\n\thdrp->count = bus_space_read_1(buft, bufh, src + 2) |\n\t    (bus_space_read_1(buft, bufh, src + 3) << 8);\n}"
  },
  {
    "function_name": "dp8390_test_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "1114-1133",
    "snippet": "static int\ndp8390_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\tint i;\n\n\tbus_space_set_region_1(buft, bufh, sc->mem_start, 0, sc->mem_size);\n\n\tfor (i = 0; i < sc->mem_size; ++i) {\n\t\tif (bus_space_read_1(buft, bufh, sc->mem_start + i)) {\n\t\t\tprintf(\": failed to clear NIC buffer at offset %x - \"\n\t\t\t    \"check configuration\\n\", (sc->mem_start + i));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\tdp8390_test_mem",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": failed to clear NIC buffer at offset %x - \"\n\t\t\t    \"check configuration\\n\"",
            "(sc->mem_start + i)"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "buft",
            "bufh",
            "sc->mem_start + i"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_set_region_1",
          "args": [
            "buft",
            "bufh",
            "sc->mem_start",
            "0",
            "sc->mem_size"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int\t\tdp8390_test_mem;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nstatic int\ndp8390_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\tint i;\n\n\tbus_space_set_region_1(buft, bufh, sc->mem_start, 0, sc->mem_size);\n\n\tfor (i = 0; i < sc->mem_size; ++i) {\n\t\tif (bus_space_read_1(buft, bufh, sc->mem_start + i)) {\n\t\t\tprintf(\": failed to clear NIC buffer at offset %x - \"\n\t\t\t    \"check configuration\\n\", (sc->mem_start + i));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dp8390_getmcaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "966-1033",
    "snippet": "void\ndp8390_getmcaf(ec, af)\n\tstruct arpcom *ec;\n\tu_int8_t *af;\n{\n\tstruct ifnet *ifp = &ec->ac_if;\n\tstruct ether_multi *enm;\n\tu_int8_t *cp, c;\n\tu_int32_t crc;\n\tint i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\taf[i] = 0xff;\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++)\n\t\taf[i] = 0;\n\tETHER_FIRST_MULTI(step, ec, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\taf[i] = 0xff;\n\t\t\treturn;\n\t\t}\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif (((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01)) {\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\t\tcrc ^= 0x04c11db6 | 1;\n\t\t\t\t} else\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 3] |= 1 << (crc & 0x7);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "sizeof(enm->enm_addrlo)"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ec",
            "enm"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ndp8390_getmcaf(ec, af)\n\tstruct arpcom *ec;\n\tu_int8_t *af;\n{\n\tstruct ifnet *ifp = &ec->ac_if;\n\tstruct ether_multi *enm;\n\tu_int8_t *cp, c;\n\tu_int32_t crc;\n\tint i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\taf[i] = 0xff;\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++)\n\t\taf[i] = 0;\n\tETHER_FIRST_MULTI(step, ec, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\taf[i] = 0xff;\n\t\t\treturn;\n\t\t}\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif (((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01)) {\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\t\tcrc ^= 0x04c11db6 | 1;\n\t\t\t\t} else\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 3] |= 1 << (crc & 0x7);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n}"
  },
  {
    "function_name": "dp8390_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "921-955",
    "snippet": "void\ndp8390_read(sc, buf, len)\n\tstruct dp8390_softc *sc;\n\tint buf;\n\tu_short len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\t/* Pull packet off interface. */\n\tm = dp8390_get(sc, buf, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume that the header fits entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to bpf.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* Fix up data start offset in mbuf to point past ether header. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_get",
          "args": [
            "sc",
            "buf",
            "len"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_getmcaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "966-1033",
          "snippet": "void\ndp8390_getmcaf(ec, af)\n\tstruct arpcom *ec;\n\tu_int8_t *af;\n{\n\tstruct ifnet *ifp = &ec->ac_if;\n\tstruct ether_multi *enm;\n\tu_int8_t *cp, c;\n\tu_int32_t crc;\n\tint i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\taf[i] = 0xff;\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++)\n\t\taf[i] = 0;\n\tETHER_FIRST_MULTI(step, ec, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\taf[i] = 0xff;\n\t\t\treturn;\n\t\t}\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif (((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01)) {\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\t\tcrc ^= 0x04c11db6 | 1;\n\t\t\t\t} else\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 3] |= 1 << (crc & 0x7);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ndp8390_getmcaf(ec, af)\n\tstruct arpcom *ec;\n\tu_int8_t *af;\n{\n\tstruct ifnet *ifp = &ec->ac_if;\n\tstruct ether_multi *enm;\n\tu_int8_t *cp, c;\n\tu_int32_t crc;\n\tint i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\taf[i] = 0xff;\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++)\n\t\taf[i] = 0;\n\tETHER_FIRST_MULTI(step, ec, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\taf[i] = 0xff;\n\t\t\treturn;\n\t\t}\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif (((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01)) {\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\t\tcrc ^= 0x04c11db6 | 1;\n\t\t\t\t} else\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 3] |= 1 << (crc & 0x7);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_read(sc, buf, len)\n\tstruct dp8390_softc *sc;\n\tint buf;\n\tu_short len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\t/* Pull packet off interface. */\n\tm = dp8390_get(sc, buf, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume that the header fits entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to bpf.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* Fix up data start offset in mbuf to point past ether header. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}"
  },
  {
    "function_name": "dp8390_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "801-915",
    "snippet": "int\ndp8390_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct ifreq *ifr = (struct ifreq *) data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tif ((error = dp8390_enable(sc)) != 0)\n\t\t\tbreak;\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tdp8390_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\t\t/* XXX - This code is probably wrong. */\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)LLADDR(ifp->if_sadl);\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ETHER_ADDR_LEN);\n\t\t\t/* Set new address. */\n\t\t\tdp8390_init(sc);\n\t\t\tbreak;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tdp8390_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tdp8390_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\tdp8390_disable(sc);\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tif ((error = dp8390_enable(sc)) != 0)\n\t\t\t\tbreak;\n\t\t\tdp8390_init(sc);\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0) {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tdp8390_stop(sc);\n\t\t\tdp8390_init(sc);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tif (sc->sc_enabled == 0) {\n\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Update our multicast list. */\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tdp8390_stop(sc);\t/* XXX for ds_setmcaf? */\n\t\t\tdp8390_init(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_ADDR_LEN\t6"
    ],
    "globals_used": [
      "int\tdp8390_enable",
      "void\tdp8390_disable",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->sc_media",
            "cmd"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_init",
          "args": [
            "sc"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "254-379",
          "snippet": "void\ndp8390_init(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int8_t mcaf[8];\n\tint i;\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->dcr_reg & ED_DCR_LS) {\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, sc->dcr_reg);\n\t} else {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, byte-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(regt, regh, ED_P0_RBCR0, 0);\n\tNIC_PUT(regt, regh, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(regt, regh, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(regt, regh, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(regt, regh, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_ISR, 0xff);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(regt, regh, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\tdp8390_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(regt, regh, ED_P1_MAR0 + i, mcaf[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(regt, regh, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/* Accept broadcast and multicast packets by default. */\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(regt, regh, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, 0);\n\n\t/* Do any card-specific initialization, if applicable. */\n\tif (sc->init_card)\n\t\t(*sc->init_card)(sc);\n\n\t/* Fire up the interface. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tdp8390_start(ifp);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_init(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int8_t mcaf[8];\n\tint i;\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->dcr_reg & ED_DCR_LS) {\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, sc->dcr_reg);\n\t} else {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, byte-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(regt, regh, ED_P0_RBCR0, 0);\n\tNIC_PUT(regt, regh, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(regt, regh, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(regt, regh, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(regt, regh, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_ISR, 0xff);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(regt, regh, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\tdp8390_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(regt, regh, ED_P1_MAR0 + i, mcaf[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(regt, regh, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/* Accept broadcast and multicast packets by default. */\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(regt, regh, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, 0);\n\n\t/* Do any card-specific initialization, if applicable. */\n\tif (sc->init_card)\n\t\t(*sc->init_card)(sc);\n\n\t/* Fire up the interface. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tdp8390_start(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp8390_stop",
          "args": [
            "sc"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "212-232",
          "snippet": "void\ndp8390_stop(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(regt, regh,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n)\n\t\t;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_stop(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(regt, regh,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n)\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_enable",
          "args": [
            "sc"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "1222-1237",
          "snippet": "int\ndp8390_enable(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\tif (sc->sc_enabled == 0 && sc->sc_enable != NULL) {\n\t\tif ((*sc->sc_enable)(sc) != 0) {\n\t\t\tprintf(\"%s: device enable failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tsc->sc_enabled = 1;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\tdp8390_enable",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tdp8390_enable;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nint\ndp8390_enable(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\tif (sc->sc_enabled == 0 && sc->sc_enable != NULL) {\n\t\tif ((*sc->sc_enable)(sc) != 0) {\n\t\t\tprintf(\"%s: device enable failed\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\treturn (EIO);\n\t\t}\n\t}\n\n\tsc->sc_enabled = 1;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp8390_disable",
          "args": [
            "sc"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "1242-1251",
          "snippet": "void\ndp8390_disable(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\tif (sc->sc_enabled != 0 && sc->sc_disable != NULL) {\n\t\t(*sc->sc_disable)(sc);\n\t\tsc->sc_enabled = 0;\n\t}\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\tdp8390_disable",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tdp8390_disable;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_disable(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\tif (sc->sc_enabled != 0 && sc->sc_disable != NULL) {\n\t\t(*sc->sc_disable)(sc);\n\t\tsc->sc_enabled = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "ina->x_host.c_host",
            "LLADDR(ifp->if_sadl)",
            "ETHER_ADDR_LEN"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nint\tdp8390_enable;\nvoid\tdp8390_disable;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nint\ndp8390_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct ifreq *ifr = (struct ifreq *) data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tif ((error = dp8390_enable(sc)) != 0)\n\t\t\tbreak;\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tdp8390_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\t\t/* XXX - This code is probably wrong. */\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)LLADDR(ifp->if_sadl);\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ETHER_ADDR_LEN);\n\t\t\t/* Set new address. */\n\t\t\tdp8390_init(sc);\n\t\t\tbreak;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tdp8390_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tdp8390_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t\tdp8390_disable(sc);\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tif ((error = dp8390_enable(sc)) != 0)\n\t\t\t\tbreak;\n\t\t\tdp8390_init(sc);\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0) {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tdp8390_stop(sc);\n\t\t\tdp8390_init(sc);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tif (sc->sc_enabled == 0) {\n\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Update our multicast list. */\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tdp8390_stop(sc);\t/* XXX for ds_setmcaf? */\n\t\t\tdp8390_init(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "dp8390_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "613-796",
    "snippet": "int\ndp8390_intr(arg)\n\tvoid *arg;\n{\n\tstruct dp8390_softc *sc = (struct dp8390_softc *)arg;\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_char isr;\n\n\tif (sc->sc_enabled == 0)\n\t\treturn (0);\n\n\t/* Set NIC to page 0 registers. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tisr = NIC_GET(regt, regh, ED_P0_ISR);\n\tif (!isr)\n\t\treturn (0);\n\n\t/* Loop until there are no more new interrupts. */\n\tfor (;;) {\n\t\t/*\n\t\t * Reset all the bits that we are 'acknowledging' by writing a\n\t\t * '1' to each bit position that was set.\n\t\t * (Writing a '1' *clears* the bit.)\n\t\t */\n\t\tNIC_PUT(regt, regh, ED_P0_ISR, isr);\n\n\t\t/*\n\t\t * Handle transmitter interrupts.  Handle these first because\n\t\t * the receiver will reset the board under some conditions.\n\t\t *\n\t\t * If the chip was reset while a packet was transmitting, it\n\t\t * may still deliver a TX interrupt.  In this case, just ignore\n\t\t * the interrupt.\n\t\t */\n\t\tif (isr & (ED_ISR_PTX | ED_ISR_TXE) &&\n\t\t    sc->txb_inuse != 0) {\n\t\t\tu_char collisions =\n\t\t\t    NIC_GET(regt, regh, ED_P0_NCR) & 0x0f;\n\n\t\t\t/*\n\t\t\t * Check for transmit error.  If a TX completed with an\n\t\t\t * error, we end up throwing the packet away.  Really\n\t\t\t * the only error that is possible is excessive\n\t\t\t * collisions, and in this case it is best to allow the\n\t\t\t * automatic mechanisms of TCP to backoff the flow.  Of\n\t\t\t * course, with UDP we're screwed, but this is expected\n\t\t\t * when a network is heavily loaded.\n\t\t\t */\n\t\t\tif (isr & ED_ISR_TXE) {\n\t\t\t\t/*\n\t\t\t\t * Excessive collisions (16).\n\t\t\t\t */\n\t\t\t\tif ((NIC_GET(regt, regh, ED_P0_TSR)\n\t\t\t\t    & ED_TSR_ABT) && (collisions == 0)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * When collisions total 16, the P0_NCR\n\t\t\t\t\t * will indicate 0, and the TSR_ABT is\n\t\t\t\t\t * set.\n\t\t\t\t\t */\n\t\t\t\t\tcollisions = 16;\n\t\t\t\t}\n\n\t\t\t\t/* Update output errors counter. */\n\t\t\t\t++ifp->if_oerrors;\n\t\t\t} else {\n\t\t\t\t/* Throw away the non-error status bits. */\n\t\t\t\t(void)NIC_GET(regt, regh, ED_P0_TSR);\n\n\t\t\t\t/*\n\t\t\t\t * Update total number of successfully\n\t\t\t\t * transmitted packets.\n\t\t\t\t */\n\t\t\t\t++ifp->if_opackets;\n\t\t\t}\n\n\t\t\t/* Clear watchdog timer. */\n\t\t\tifp->if_timer = 0;\n\t\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t\t\t/*\n\t\t\t * Add in total number of collisions on last\n\t\t\t * transmission.\n\t\t\t */\n\t\t\tifp->if_collisions += collisions;\n\n\t\t\t/*\n\t\t\t * Decrement buffer in-use count if not zero (can only\n\t\t\t * be zero if a transmitter interrupt occured while not\n\t\t\t * actually transmitting).\n\t\t\t * If data is ready to transmit, start it transmitting,\n\t\t\t * otherwise defer until after handling receiver.\n\t\t\t */\n\t\t\tif (--sc->txb_inuse != 0)\n\t\t\t\tdp8390_xmit(sc);\n\t\t}\n\n\t\t/* Handle receiver interrupts. */\n\t\tif (isr & (ED_ISR_PRX | ED_ISR_RXE | ED_ISR_OVW)) {\n\t\t\t/*\n\t\t\t * Overwrite warning.  In order to make sure that a\n\t\t\t * lockup of the local DMA hasn't occurred, we reset\n\t\t\t * and re-init the NIC.  The NSC manual suggests only a\n\t\t\t * partial reset/re-init is necessary - but some chips\n\t\t\t * seem to want more.  The DMA lockup has been seen\n\t\t\t * only with early rev chips - Methinks this bug was\n\t\t\t * fixed in later revs.  -DG\n\t\t\t */\n\t\t\tif (isr & ED_ISR_OVW) {\n\t\t\t\t++ifp->if_ierrors;\n#ifdef DIAGNOSTIC\n\t\t\t\tlog(LOG_WARNING, \"%s: warning - receiver \"\n\t\t\t\t    \"ring buffer overrun\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\t\t/* Stop/reset/re-init NIC. */\n\t\t\t\tdp8390_reset(sc);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Receiver Error.  One or more of: CRC error,\n\t\t\t\t * frame alignment error FIFO overrun, or\n\t\t\t\t * missed packet.\n\t\t\t\t */\n\t\t\t\tif (isr & ED_ISR_RXE) {\n\t\t\t\t\t++ifp->if_ierrors;\n#ifdef DEBUG\n\t\t\t\t\tif (dp8390_debug) {\n\t\t\t\t\t\tprintf(\"%s: receive error %x\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t\t\t    NIC_GET(regt, regh,\n\t\t\t\t\t\t\tED_P0_RSR));\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Go get the packet(s)\n\t\t\t\t * XXX - Doing this on an error is dubious\n\t\t\t\t * because there shouldn't be any data to get\n\t\t\t\t * (we've configured the interface to not\n\t\t\t\t * accept packets with errors).\n\t\t\t\t */\n\t\t\t\tif (sc->recv_int)\n\t\t\t\t\t(*sc->recv_int)(sc);\n\t\t\t\telse\n\t\t\t\t\tdp8390_rint(sc);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If it looks like the transmitter can take more data, attempt\n\t\t * to start output on the interface.  This is done after\n\t\t * handling the receiver to give the receiver priority.\n\t\t */\n\t\tdp8390_start(ifp);\n\n\t\t/*\n\t\t * Return NIC CR to standard state: page 0, remote DMA\n\t\t * complete, start (toggling the TXP bit off, even if was just\n\t\t * set in the transmit routine, is *okay* - it is 'edge'\n\t\t * triggered from low to high).\n\t\t */\n\t\tNIC_PUT(regt, regh, ED_P0_CR,\n\t\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t\t/*\n\t\t * If the Network Talley Counters overflow, read them to reset\n\t\t * them.  It appears that old 8390's won't clear the ISR flag\n\t\t * otherwise - resulting in an infinite loop.\n\t\t */\n\t\tif (isr & ED_ISR_CNT) {\n\t\t\t(void)NIC_GET(regt, regh, ED_P0_CNTR0);\n\t\t\t(void)NIC_GET(regt, regh, ED_P0_CNTR1);\n\t\t\t(void)NIC_GET(regt, regh, ED_P0_CNTR2);\n\t\t}\n\n\t\tisr = NIC_GET(regt, regh, ED_P0_ISR);\n\t\tif (!isr)\n\t\t\treturn (1);\n\t}\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline__ void\tdp8390_xmit",
      "int\tdp8390_debug = 0;",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P0_ISR"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P0_CNTR2"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P0_CNTR1"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P0_CNTR0"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_start",
          "args": [
            "ifp"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "437-492",
          "snippet": "void\ndp8390_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0;\n\tint buffer;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"dp8390_start: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->write_mbuf)\n\t\tlen = (*sc->write_mbuf)(sc, m0, buffer);\n\telse\n\t\tlen = dp8390_write_mbuf(sc, m0, buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN - ETHER_CRC_LEN);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse++ == 0)\n\t\tdp8390_xmit(sc);\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_MIN_LEN\t64"
          ],
          "globals_used": [
            "static __inline__ void\tdp8390_xmit",
            "static __inline__ int\tdp8390_write_mbuf",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_MIN_LEN\t64\n\nstatic __inline__ void\tdp8390_xmit;\nstatic __inline__ int\tdp8390_write_mbuf;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0;\n\tint buffer;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"dp8390_start: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->write_mbuf)\n\t\tlen = (*sc->write_mbuf)(sc, m0, buffer);\n\telse\n\t\tlen = dp8390_write_mbuf(sc, m0, buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN - ETHER_CRC_LEN);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse++ == 0)\n\t\tdp8390_xmit(sc);\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp8390_rint",
          "args": [
            "sc"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_rint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "497-610",
          "snippet": "void\ndp8390_rint(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct dp8390_ring packet_hdr;\n\tint packet_ptr;\n\tu_short len;\n\tu_char boundary, current;\n\tu_char nlen;\n\nloop:\n\t/* Set NIC to page 1 registers to get 'current' pointer. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);\n\n\t/*\n\t * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.\n\t * it points to where new data has been buffered.  The 'CURR' (current)\n\t * register points to the logical end of the ring-buffer - i.e. it\n\t * points to where additional new data will be added.  We loop here\n\t * until the logical beginning equals the logical end (or in other\n\t * words, until the ring-buffer is empty).\n\t */\n\tcurrent = NIC_GET(regt, regh, ED_P1_CURR);\n\tif (sc->next_packet == current)\n\t\treturn;\n\n\t/* Set NIC to page 0 registers to update boundary register. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tdo {\n\t\t/* Get pointer to this buffer's header structure. */\n\t\tpacket_ptr = sc->mem_ring +\n\t\t    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);\n\n\t\tif (sc->read_hdr)\n\t\t\t(*sc->read_hdr)(sc, packet_ptr, &packet_hdr);\n\t\telse\n\t\t\tdp8390_read_hdr(sc, packet_ptr, &packet_hdr);\n\t\tlen = packet_hdr.count;\n\n\t\t/*\n\t\t * Try do deal with old, buggy chips that sometimes duplicate\n\t\t * the low byte of the length into the high byte.  We do this\n\t\t * by simply ignoring the high byte of the length and always\n\t\t * recalculating it.\n\t\t *\n\t\t * NOTE: sc->next_packet is pointing at the current packet.\n\t\t */\n\t\tif (packet_hdr.next_packet >= sc->next_packet)\n\t\t\tnlen = (packet_hdr.next_packet - sc->next_packet);\n\t\telse\n\t\t\tnlen = ((packet_hdr.next_packet - sc->rec_page_start) +\n\t\t\t    (sc->rec_page_stop - sc->next_packet));\n\t\t--nlen;\n\t\tif ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)\n\t\t\t--nlen;\n\t\tlen = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);\n#ifdef DIAGNOSTIC\n\t\tif (len != packet_hdr.count) {\n\t\t\tprintf(\"%s: length does not match \"\n\t\t\t    \"next packet pointer\\n\", sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: len %04x nlen %04x start %02x \"\n\t\t\t    \"first %02x curr %02x next %02x stop %02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, packet_hdr.count, len,\n\t\t\t    sc->rec_page_start, sc->next_packet, current,\n\t\t\t    packet_hdr.next_packet, sc->rec_page_stop);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Be fairly liberal about what we allow as a \"reasonable\"\n\t\t * length so that a [crufty] packet will make it to BPF (and\n\t\t * can thus be analyzed).  Note that all that is really\n\t\t * important is that we have a length that will fit into one\n\t\t * mbuf cluster or less; the upper layer protocols can then\n\t\t * figure out the length from their own length field(s).\n\t\t */\n\t\tif (len <= MCLBYTES &&\n\t\t    packet_hdr.next_packet >= sc->rec_page_start &&\n\t\t    packet_hdr.next_packet < sc->rec_page_stop) {\n\t\t\t/* Go get packet. */\n\t\t\tdp8390_read(sc,\n\t\t\t    packet_ptr + sizeof(struct dp8390_ring),\n\t\t\t    len - sizeof(struct dp8390_ring));\n\t\t\t++sc->sc_arpcom.ac_if.if_ipackets;\n\t\t} else {\n\t\t\t/* Really BAD.  The ring pointers are corrupted. */\n\t\t\tlog(LOG_ERR, \"%s: NIC memory corrupt - \"\n\t\t\t    \"invalid packet length %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n\t\t\t++sc->sc_arpcom.ac_if.if_ierrors;\n\t\t\tdp8390_reset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update next packet pointer. */\n\t\tsc->next_packet = packet_hdr.next_packet;\n\n\t\t/*\n\t\t * Update NIC boundary pointer - being careful to keep it one\n\t\t * buffer behind (as recommended by NS databook).\n\t\t */\n\t\tboundary = sc->next_packet - 1;\n\t\tif (boundary < sc->rec_page_start)\n\t\t\tboundary = sc->rec_page_stop - 1;\n\t\tNIC_PUT(regt, regh, ED_P0_BNRY, boundary);\n\t} while (sc->next_packet != current);\n\n\tgoto loop;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void\tdp8390_read_hdr",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline__ void\tdp8390_read_hdr;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_rint(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct dp8390_ring packet_hdr;\n\tint packet_ptr;\n\tu_short len;\n\tu_char boundary, current;\n\tu_char nlen;\n\nloop:\n\t/* Set NIC to page 1 registers to get 'current' pointer. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);\n\n\t/*\n\t * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.\n\t * it points to where new data has been buffered.  The 'CURR' (current)\n\t * register points to the logical end of the ring-buffer - i.e. it\n\t * points to where additional new data will be added.  We loop here\n\t * until the logical beginning equals the logical end (or in other\n\t * words, until the ring-buffer is empty).\n\t */\n\tcurrent = NIC_GET(regt, regh, ED_P1_CURR);\n\tif (sc->next_packet == current)\n\t\treturn;\n\n\t/* Set NIC to page 0 registers to update boundary register. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tdo {\n\t\t/* Get pointer to this buffer's header structure. */\n\t\tpacket_ptr = sc->mem_ring +\n\t\t    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);\n\n\t\tif (sc->read_hdr)\n\t\t\t(*sc->read_hdr)(sc, packet_ptr, &packet_hdr);\n\t\telse\n\t\t\tdp8390_read_hdr(sc, packet_ptr, &packet_hdr);\n\t\tlen = packet_hdr.count;\n\n\t\t/*\n\t\t * Try do deal with old, buggy chips that sometimes duplicate\n\t\t * the low byte of the length into the high byte.  We do this\n\t\t * by simply ignoring the high byte of the length and always\n\t\t * recalculating it.\n\t\t *\n\t\t * NOTE: sc->next_packet is pointing at the current packet.\n\t\t */\n\t\tif (packet_hdr.next_packet >= sc->next_packet)\n\t\t\tnlen = (packet_hdr.next_packet - sc->next_packet);\n\t\telse\n\t\t\tnlen = ((packet_hdr.next_packet - sc->rec_page_start) +\n\t\t\t    (sc->rec_page_stop - sc->next_packet));\n\t\t--nlen;\n\t\tif ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)\n\t\t\t--nlen;\n\t\tlen = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);\n#ifdef DIAGNOSTIC\n\t\tif (len != packet_hdr.count) {\n\t\t\tprintf(\"%s: length does not match \"\n\t\t\t    \"next packet pointer\\n\", sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: len %04x nlen %04x start %02x \"\n\t\t\t    \"first %02x curr %02x next %02x stop %02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, packet_hdr.count, len,\n\t\t\t    sc->rec_page_start, sc->next_packet, current,\n\t\t\t    packet_hdr.next_packet, sc->rec_page_stop);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Be fairly liberal about what we allow as a \"reasonable\"\n\t\t * length so that a [crufty] packet will make it to BPF (and\n\t\t * can thus be analyzed).  Note that all that is really\n\t\t * important is that we have a length that will fit into one\n\t\t * mbuf cluster or less; the upper layer protocols can then\n\t\t * figure out the length from their own length field(s).\n\t\t */\n\t\tif (len <= MCLBYTES &&\n\t\t    packet_hdr.next_packet >= sc->rec_page_start &&\n\t\t    packet_hdr.next_packet < sc->rec_page_stop) {\n\t\t\t/* Go get packet. */\n\t\t\tdp8390_read(sc,\n\t\t\t    packet_ptr + sizeof(struct dp8390_ring),\n\t\t\t    len - sizeof(struct dp8390_ring));\n\t\t\t++sc->sc_arpcom.ac_if.if_ipackets;\n\t\t} else {\n\t\t\t/* Really BAD.  The ring pointers are corrupted. */\n\t\t\tlog(LOG_ERR, \"%s: NIC memory corrupt - \"\n\t\t\t    \"invalid packet length %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n\t\t\t++sc->sc_arpcom.ac_if.if_ierrors;\n\t\t\tdp8390_reset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update next packet pointer. */\n\t\tsc->next_packet = packet_hdr.next_packet;\n\n\t\t/*\n\t\t * Update NIC boundary pointer - being careful to keep it one\n\t\t * buffer behind (as recommended by NS databook).\n\t\t */\n\t\tboundary = sc->next_packet - 1;\n\t\tif (boundary < sc->rec_page_start)\n\t\t\tboundary = sc->rec_page_stop - 1;\n\t\tNIC_PUT(regt, regh, ED_P0_BNRY, boundary);\n\t} while (sc->next_packet != current);\n\n\tgoto loop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: receive error %x\\n\"",
            "sc->sc_dev.dv_xname",
            "NIC_GET(regt, regh,\n\t\t\t\t\t\t\tED_P0_RSR)"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P0_RSR"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_reset",
          "args": [
            "sc"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "197-207",
          "snippet": "void\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: warning - receiver \"\n\t\t\t\t    \"ring buffer overrun\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp8390_xmit",
          "args": [
            "sc"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_xmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "384-426",
          "snippet": "static __inline__ void\ndp8390_xmit(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_short len;\n\n#ifdef DIAGNOSTIC\n\tif ((sc->txb_next_tx + sc->txb_inuse) % sc->txb_cnt != sc->txb_new)\n\t\tpanic(\"dp8390_xmit: desync, next_tx=%d inuse=%d cnt=%d new=%d\",\n\t\t    sc->txb_next_tx, sc->txb_inuse, sc->txb_cnt, sc->txb_new);\n\n\tif (sc->txb_inuse == 0)\n\t\tpanic(\"dp8390_xmit: no packets to xmit\\n\");\n#endif\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(regt, regh, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(regt, regh, ED_P0_TBCR0, len);\n\tNIC_PUT(regt, regh, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tif (++sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define __inline__\t/* XXX for debugging porpoises */"
          ],
          "globals_used": [
            "static __inline__ void\tdp8390_xmit",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define __inline__\t/* XXX for debugging porpoises */\n\nstatic __inline__ void\tdp8390_xmit;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nstatic __inline__ void\ndp8390_xmit(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_short len;\n\n#ifdef DIAGNOSTIC\n\tif ((sc->txb_next_tx + sc->txb_inuse) % sc->txb_cnt != sc->txb_new)\n\t\tpanic(\"dp8390_xmit: desync, next_tx=%d inuse=%d cnt=%d new=%d\",\n\t\t    sc->txb_next_tx, sc->txb_inuse, sc->txb_cnt, sc->txb_new);\n\n\tif (sc->txb_inuse == 0)\n\t\tpanic(\"dp8390_xmit: no packets to xmit\\n\");\n#endif\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(regt, regh, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(regt, regh, ED_P0_TBCR0, len);\n\tNIC_PUT(regt, regh, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tif (++sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P0_TSR"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P0_TSR"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P0_NCR"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_ISR",
            "isr"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P0_ISR"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline__ void\tdp8390_xmit;\nint\tdp8390_debug = 0;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nint\ndp8390_intr(arg)\n\tvoid *arg;\n{\n\tstruct dp8390_softc *sc = (struct dp8390_softc *)arg;\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_char isr;\n\n\tif (sc->sc_enabled == 0)\n\t\treturn (0);\n\n\t/* Set NIC to page 0 registers. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tisr = NIC_GET(regt, regh, ED_P0_ISR);\n\tif (!isr)\n\t\treturn (0);\n\n\t/* Loop until there are no more new interrupts. */\n\tfor (;;) {\n\t\t/*\n\t\t * Reset all the bits that we are 'acknowledging' by writing a\n\t\t * '1' to each bit position that was set.\n\t\t * (Writing a '1' *clears* the bit.)\n\t\t */\n\t\tNIC_PUT(regt, regh, ED_P0_ISR, isr);\n\n\t\t/*\n\t\t * Handle transmitter interrupts.  Handle these first because\n\t\t * the receiver will reset the board under some conditions.\n\t\t *\n\t\t * If the chip was reset while a packet was transmitting, it\n\t\t * may still deliver a TX interrupt.  In this case, just ignore\n\t\t * the interrupt.\n\t\t */\n\t\tif (isr & (ED_ISR_PTX | ED_ISR_TXE) &&\n\t\t    sc->txb_inuse != 0) {\n\t\t\tu_char collisions =\n\t\t\t    NIC_GET(regt, regh, ED_P0_NCR) & 0x0f;\n\n\t\t\t/*\n\t\t\t * Check for transmit error.  If a TX completed with an\n\t\t\t * error, we end up throwing the packet away.  Really\n\t\t\t * the only error that is possible is excessive\n\t\t\t * collisions, and in this case it is best to allow the\n\t\t\t * automatic mechanisms of TCP to backoff the flow.  Of\n\t\t\t * course, with UDP we're screwed, but this is expected\n\t\t\t * when a network is heavily loaded.\n\t\t\t */\n\t\t\tif (isr & ED_ISR_TXE) {\n\t\t\t\t/*\n\t\t\t\t * Excessive collisions (16).\n\t\t\t\t */\n\t\t\t\tif ((NIC_GET(regt, regh, ED_P0_TSR)\n\t\t\t\t    & ED_TSR_ABT) && (collisions == 0)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * When collisions total 16, the P0_NCR\n\t\t\t\t\t * will indicate 0, and the TSR_ABT is\n\t\t\t\t\t * set.\n\t\t\t\t\t */\n\t\t\t\t\tcollisions = 16;\n\t\t\t\t}\n\n\t\t\t\t/* Update output errors counter. */\n\t\t\t\t++ifp->if_oerrors;\n\t\t\t} else {\n\t\t\t\t/* Throw away the non-error status bits. */\n\t\t\t\t(void)NIC_GET(regt, regh, ED_P0_TSR);\n\n\t\t\t\t/*\n\t\t\t\t * Update total number of successfully\n\t\t\t\t * transmitted packets.\n\t\t\t\t */\n\t\t\t\t++ifp->if_opackets;\n\t\t\t}\n\n\t\t\t/* Clear watchdog timer. */\n\t\t\tifp->if_timer = 0;\n\t\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t\t\t/*\n\t\t\t * Add in total number of collisions on last\n\t\t\t * transmission.\n\t\t\t */\n\t\t\tifp->if_collisions += collisions;\n\n\t\t\t/*\n\t\t\t * Decrement buffer in-use count if not zero (can only\n\t\t\t * be zero if a transmitter interrupt occured while not\n\t\t\t * actually transmitting).\n\t\t\t * If data is ready to transmit, start it transmitting,\n\t\t\t * otherwise defer until after handling receiver.\n\t\t\t */\n\t\t\tif (--sc->txb_inuse != 0)\n\t\t\t\tdp8390_xmit(sc);\n\t\t}\n\n\t\t/* Handle receiver interrupts. */\n\t\tif (isr & (ED_ISR_PRX | ED_ISR_RXE | ED_ISR_OVW)) {\n\t\t\t/*\n\t\t\t * Overwrite warning.  In order to make sure that a\n\t\t\t * lockup of the local DMA hasn't occurred, we reset\n\t\t\t * and re-init the NIC.  The NSC manual suggests only a\n\t\t\t * partial reset/re-init is necessary - but some chips\n\t\t\t * seem to want more.  The DMA lockup has been seen\n\t\t\t * only with early rev chips - Methinks this bug was\n\t\t\t * fixed in later revs.  -DG\n\t\t\t */\n\t\t\tif (isr & ED_ISR_OVW) {\n\t\t\t\t++ifp->if_ierrors;\n#ifdef DIAGNOSTIC\n\t\t\t\tlog(LOG_WARNING, \"%s: warning - receiver \"\n\t\t\t\t    \"ring buffer overrun\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\t\t/* Stop/reset/re-init NIC. */\n\t\t\t\tdp8390_reset(sc);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Receiver Error.  One or more of: CRC error,\n\t\t\t\t * frame alignment error FIFO overrun, or\n\t\t\t\t * missed packet.\n\t\t\t\t */\n\t\t\t\tif (isr & ED_ISR_RXE) {\n\t\t\t\t\t++ifp->if_ierrors;\n#ifdef DEBUG\n\t\t\t\t\tif (dp8390_debug) {\n\t\t\t\t\t\tprintf(\"%s: receive error %x\\n\",\n\t\t\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t\t\t    NIC_GET(regt, regh,\n\t\t\t\t\t\t\tED_P0_RSR));\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Go get the packet(s)\n\t\t\t\t * XXX - Doing this on an error is dubious\n\t\t\t\t * because there shouldn't be any data to get\n\t\t\t\t * (we've configured the interface to not\n\t\t\t\t * accept packets with errors).\n\t\t\t\t */\n\t\t\t\tif (sc->recv_int)\n\t\t\t\t\t(*sc->recv_int)(sc);\n\t\t\t\telse\n\t\t\t\t\tdp8390_rint(sc);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If it looks like the transmitter can take more data, attempt\n\t\t * to start output on the interface.  This is done after\n\t\t * handling the receiver to give the receiver priority.\n\t\t */\n\t\tdp8390_start(ifp);\n\n\t\t/*\n\t\t * Return NIC CR to standard state: page 0, remote DMA\n\t\t * complete, start (toggling the TXP bit off, even if was just\n\t\t * set in the transmit routine, is *okay* - it is 'edge'\n\t\t * triggered from low to high).\n\t\t */\n\t\tNIC_PUT(regt, regh, ED_P0_CR,\n\t\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t\t/*\n\t\t * If the Network Talley Counters overflow, read them to reset\n\t\t * them.  It appears that old 8390's won't clear the ISR flag\n\t\t * otherwise - resulting in an infinite loop.\n\t\t */\n\t\tif (isr & ED_ISR_CNT) {\n\t\t\t(void)NIC_GET(regt, regh, ED_P0_CNTR0);\n\t\t\t(void)NIC_GET(regt, regh, ED_P0_CNTR1);\n\t\t\t(void)NIC_GET(regt, regh, ED_P0_CNTR2);\n\t\t}\n\n\t\tisr = NIC_GET(regt, regh, ED_P0_ISR);\n\t\tif (!isr)\n\t\t\treturn (1);\n\t}\n}"
  },
  {
    "function_name": "dp8390_rint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "497-610",
    "snippet": "void\ndp8390_rint(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct dp8390_ring packet_hdr;\n\tint packet_ptr;\n\tu_short len;\n\tu_char boundary, current;\n\tu_char nlen;\n\nloop:\n\t/* Set NIC to page 1 registers to get 'current' pointer. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);\n\n\t/*\n\t * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.\n\t * it points to where new data has been buffered.  The 'CURR' (current)\n\t * register points to the logical end of the ring-buffer - i.e. it\n\t * points to where additional new data will be added.  We loop here\n\t * until the logical beginning equals the logical end (or in other\n\t * words, until the ring-buffer is empty).\n\t */\n\tcurrent = NIC_GET(regt, regh, ED_P1_CURR);\n\tif (sc->next_packet == current)\n\t\treturn;\n\n\t/* Set NIC to page 0 registers to update boundary register. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tdo {\n\t\t/* Get pointer to this buffer's header structure. */\n\t\tpacket_ptr = sc->mem_ring +\n\t\t    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);\n\n\t\tif (sc->read_hdr)\n\t\t\t(*sc->read_hdr)(sc, packet_ptr, &packet_hdr);\n\t\telse\n\t\t\tdp8390_read_hdr(sc, packet_ptr, &packet_hdr);\n\t\tlen = packet_hdr.count;\n\n\t\t/*\n\t\t * Try do deal with old, buggy chips that sometimes duplicate\n\t\t * the low byte of the length into the high byte.  We do this\n\t\t * by simply ignoring the high byte of the length and always\n\t\t * recalculating it.\n\t\t *\n\t\t * NOTE: sc->next_packet is pointing at the current packet.\n\t\t */\n\t\tif (packet_hdr.next_packet >= sc->next_packet)\n\t\t\tnlen = (packet_hdr.next_packet - sc->next_packet);\n\t\telse\n\t\t\tnlen = ((packet_hdr.next_packet - sc->rec_page_start) +\n\t\t\t    (sc->rec_page_stop - sc->next_packet));\n\t\t--nlen;\n\t\tif ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)\n\t\t\t--nlen;\n\t\tlen = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);\n#ifdef DIAGNOSTIC\n\t\tif (len != packet_hdr.count) {\n\t\t\tprintf(\"%s: length does not match \"\n\t\t\t    \"next packet pointer\\n\", sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: len %04x nlen %04x start %02x \"\n\t\t\t    \"first %02x curr %02x next %02x stop %02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, packet_hdr.count, len,\n\t\t\t    sc->rec_page_start, sc->next_packet, current,\n\t\t\t    packet_hdr.next_packet, sc->rec_page_stop);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Be fairly liberal about what we allow as a \"reasonable\"\n\t\t * length so that a [crufty] packet will make it to BPF (and\n\t\t * can thus be analyzed).  Note that all that is really\n\t\t * important is that we have a length that will fit into one\n\t\t * mbuf cluster or less; the upper layer protocols can then\n\t\t * figure out the length from their own length field(s).\n\t\t */\n\t\tif (len <= MCLBYTES &&\n\t\t    packet_hdr.next_packet >= sc->rec_page_start &&\n\t\t    packet_hdr.next_packet < sc->rec_page_stop) {\n\t\t\t/* Go get packet. */\n\t\t\tdp8390_read(sc,\n\t\t\t    packet_ptr + sizeof(struct dp8390_ring),\n\t\t\t    len - sizeof(struct dp8390_ring));\n\t\t\t++sc->sc_arpcom.ac_if.if_ipackets;\n\t\t} else {\n\t\t\t/* Really BAD.  The ring pointers are corrupted. */\n\t\t\tlog(LOG_ERR, \"%s: NIC memory corrupt - \"\n\t\t\t    \"invalid packet length %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n\t\t\t++sc->sc_arpcom.ac_if.if_ierrors;\n\t\t\tdp8390_reset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update next packet pointer. */\n\t\tsc->next_packet = packet_hdr.next_packet;\n\n\t\t/*\n\t\t * Update NIC boundary pointer - being careful to keep it one\n\t\t * buffer behind (as recommended by NS databook).\n\t\t */\n\t\tboundary = sc->next_packet - 1;\n\t\tif (boundary < sc->rec_page_start)\n\t\t\tboundary = sc->rec_page_stop - 1;\n\t\tNIC_PUT(regt, regh, ED_P0_BNRY, boundary);\n\t} while (sc->next_packet != current);\n\n\tgoto loop;\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline__ void\tdp8390_read_hdr",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_BNRY",
            "boundary"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_reset",
          "args": [
            "sc"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "197-207",
          "snippet": "void\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: NIC memory corrupt - \"\n\t\t\t    \"invalid packet length %d\\n\"",
            "sc->sc_dev.dv_xname",
            "len"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp8390_read",
          "args": [
            "sc",
            "packet_ptr + sizeof(struct dp8390_ring)",
            "len - sizeof(struct dp8390_ring)"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_read_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "1138-1155",
          "snippet": "static __inline__ void\ndp8390_read_hdr(sc, src, hdrp)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tstruct dp8390_ring *hdrp;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\n\t/*\n\t * The byte count includes a 4 byte header that was added by\n\t * the NIC.\n\t */\n\thdrp->rsr = bus_space_read_1(buft, bufh, src);\n\thdrp->next_packet = bus_space_read_1(buft, bufh, src + 1);\n\thdrp->count = bus_space_read_1(buft, bufh, src + 2) |\n\t    (bus_space_read_1(buft, bufh, src + 3) << 8);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define __inline__\t/* XXX for debugging porpoises */"
          ],
          "globals_used": [
            "static __inline__ void\tdp8390_read_hdr",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;",
            "int src;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define __inline__\t/* XXX for debugging porpoises */\n\nstatic __inline__ void\tdp8390_read_hdr;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\nint src;\n\nstatic __inline__ void\ndp8390_read_hdr(sc, src, hdrp)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tstruct dp8390_ring *hdrp;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\n\t/*\n\t * The byte count includes a 4 byte header that was added by\n\t * the NIC.\n\t */\n\thdrp->rsr = bus_space_read_1(buft, bufh, src);\n\thdrp->next_packet = bus_space_read_1(buft, bufh, src + 1);\n\thdrp->count = bus_space_read_1(buft, bufh, src + 2) |\n\t    (bus_space_read_1(buft, bufh, src + 3) << 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: len %04x nlen %04x start %02x \"\n\t\t\t    \"first %02x curr %02x next %02x stop %02x\\n\"",
            "sc->sc_dev.dv_xname",
            "packet_hdr.count",
            "len",
            "sc->rec_page_start",
            "sc->next_packet",
            "current",
            "packet_hdr.next_packet",
            "sc->rec_page_stop"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "packet_ptr",
            "&packet_hdr"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P1_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P1_CURR"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline__ void\tdp8390_read_hdr;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_rint(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct dp8390_ring packet_hdr;\n\tint packet_ptr;\n\tu_short len;\n\tu_char boundary, current;\n\tu_char nlen;\n\nloop:\n\t/* Set NIC to page 1 registers to get 'current' pointer. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);\n\n\t/*\n\t * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.\n\t * it points to where new data has been buffered.  The 'CURR' (current)\n\t * register points to the logical end of the ring-buffer - i.e. it\n\t * points to where additional new data will be added.  We loop here\n\t * until the logical beginning equals the logical end (or in other\n\t * words, until the ring-buffer is empty).\n\t */\n\tcurrent = NIC_GET(regt, regh, ED_P1_CURR);\n\tif (sc->next_packet == current)\n\t\treturn;\n\n\t/* Set NIC to page 0 registers to update boundary register. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tdo {\n\t\t/* Get pointer to this buffer's header structure. */\n\t\tpacket_ptr = sc->mem_ring +\n\t\t    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);\n\n\t\tif (sc->read_hdr)\n\t\t\t(*sc->read_hdr)(sc, packet_ptr, &packet_hdr);\n\t\telse\n\t\t\tdp8390_read_hdr(sc, packet_ptr, &packet_hdr);\n\t\tlen = packet_hdr.count;\n\n\t\t/*\n\t\t * Try do deal with old, buggy chips that sometimes duplicate\n\t\t * the low byte of the length into the high byte.  We do this\n\t\t * by simply ignoring the high byte of the length and always\n\t\t * recalculating it.\n\t\t *\n\t\t * NOTE: sc->next_packet is pointing at the current packet.\n\t\t */\n\t\tif (packet_hdr.next_packet >= sc->next_packet)\n\t\t\tnlen = (packet_hdr.next_packet - sc->next_packet);\n\t\telse\n\t\t\tnlen = ((packet_hdr.next_packet - sc->rec_page_start) +\n\t\t\t    (sc->rec_page_stop - sc->next_packet));\n\t\t--nlen;\n\t\tif ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)\n\t\t\t--nlen;\n\t\tlen = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);\n#ifdef DIAGNOSTIC\n\t\tif (len != packet_hdr.count) {\n\t\t\tprintf(\"%s: length does not match \"\n\t\t\t    \"next packet pointer\\n\", sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: len %04x nlen %04x start %02x \"\n\t\t\t    \"first %02x curr %02x next %02x stop %02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, packet_hdr.count, len,\n\t\t\t    sc->rec_page_start, sc->next_packet, current,\n\t\t\t    packet_hdr.next_packet, sc->rec_page_stop);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Be fairly liberal about what we allow as a \"reasonable\"\n\t\t * length so that a [crufty] packet will make it to BPF (and\n\t\t * can thus be analyzed).  Note that all that is really\n\t\t * important is that we have a length that will fit into one\n\t\t * mbuf cluster or less; the upper layer protocols can then\n\t\t * figure out the length from their own length field(s).\n\t\t */\n\t\tif (len <= MCLBYTES &&\n\t\t    packet_hdr.next_packet >= sc->rec_page_start &&\n\t\t    packet_hdr.next_packet < sc->rec_page_stop) {\n\t\t\t/* Go get packet. */\n\t\t\tdp8390_read(sc,\n\t\t\t    packet_ptr + sizeof(struct dp8390_ring),\n\t\t\t    len - sizeof(struct dp8390_ring));\n\t\t\t++sc->sc_arpcom.ac_if.if_ipackets;\n\t\t} else {\n\t\t\t/* Really BAD.  The ring pointers are corrupted. */\n\t\t\tlog(LOG_ERR, \"%s: NIC memory corrupt - \"\n\t\t\t    \"invalid packet length %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n\t\t\t++sc->sc_arpcom.ac_if.if_ierrors;\n\t\t\tdp8390_reset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update next packet pointer. */\n\t\tsc->next_packet = packet_hdr.next_packet;\n\n\t\t/*\n\t\t * Update NIC boundary pointer - being careful to keep it one\n\t\t * buffer behind (as recommended by NS databook).\n\t\t */\n\t\tboundary = sc->next_packet - 1;\n\t\tif (boundary < sc->rec_page_start)\n\t\t\tboundary = sc->rec_page_stop - 1;\n\t\tNIC_PUT(regt, regh, ED_P0_BNRY, boundary);\n\t} while (sc->next_packet != current);\n\n\tgoto loop;\n}"
  },
  {
    "function_name": "dp8390_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "437-492",
    "snippet": "void\ndp8390_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0;\n\tint buffer;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"dp8390_start: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->write_mbuf)\n\t\tlen = (*sc->write_mbuf)(sc, m0, buffer);\n\telse\n\t\tlen = dp8390_write_mbuf(sc, m0, buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN - ETHER_CRC_LEN);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse++ == 0)\n\t\tdp8390_xmit(sc);\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_MIN_LEN\t64"
    ],
    "globals_used": [
      "static __inline__ void\tdp8390_xmit",
      "static __inline__ int\tdp8390_write_mbuf",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dp8390_xmit",
          "args": [
            "sc"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_xmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "384-426",
          "snippet": "static __inline__ void\ndp8390_xmit(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_short len;\n\n#ifdef DIAGNOSTIC\n\tif ((sc->txb_next_tx + sc->txb_inuse) % sc->txb_cnt != sc->txb_new)\n\t\tpanic(\"dp8390_xmit: desync, next_tx=%d inuse=%d cnt=%d new=%d\",\n\t\t    sc->txb_next_tx, sc->txb_inuse, sc->txb_cnt, sc->txb_new);\n\n\tif (sc->txb_inuse == 0)\n\t\tpanic(\"dp8390_xmit: no packets to xmit\\n\");\n#endif\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(regt, regh, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(regt, regh, ED_P0_TBCR0, len);\n\tNIC_PUT(regt, regh, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tif (++sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define __inline__\t/* XXX for debugging porpoises */"
          ],
          "globals_used": [
            "static __inline__ void\tdp8390_xmit",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define __inline__\t/* XXX for debugging porpoises */\n\nstatic __inline__ void\tdp8390_xmit;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nstatic __inline__ void\ndp8390_xmit(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_short len;\n\n#ifdef DIAGNOSTIC\n\tif ((sc->txb_next_tx + sc->txb_inuse) % sc->txb_cnt != sc->txb_new)\n\t\tpanic(\"dp8390_xmit: desync, next_tx=%d inuse=%d cnt=%d new=%d\",\n\t\t    sc->txb_next_tx, sc->txb_inuse, sc->txb_cnt, sc->txb_new);\n\n\tif (sc->txb_inuse == 0)\n\t\tpanic(\"dp8390_xmit: no packets to xmit\\n\");\n#endif\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(regt, regh, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(regt, regh, ED_P0_TBCR0, len);\n\tNIC_PUT(regt, regh, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tif (++sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "len",
            "ETHER_MIN_LEN - ETHER_CRC_LEN"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_write_mbuf",
          "args": [
            "sc",
            "m0",
            "buffer"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_write_mbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "1195-1217",
          "snippet": "static __inline__ int\ndp8390_write_mbuf(sc, m, buf)\n\tstruct dp8390_softc *sc;\n\tstruct mbuf *m;\n\tint buf;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\tu_char *data;\n\tint len, totlen = 0;\n\n\tfor (; m ; m = m->m_next) {\n\t\tdata = mtod(m, u_char *);\n\t\tlen = m->m_len;\n\t\tif (len > 0) {\n\t\t\tbus_space_write_region_1(buft, bufh, buf, data, len);\n\t\t\ttotlen += len;\n\t\t\tbuf += len;\n\t\t}\n\t}\n\n\treturn (totlen);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define __inline__\t/* XXX for debugging porpoises */"
          ],
          "globals_used": [
            "static __inline__ int\tdp8390_write_mbuf",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define __inline__\t/* XXX for debugging porpoises */\n\nstatic __inline__ int\tdp8390_write_mbuf;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nstatic __inline__ int\ndp8390_write_mbuf(sc, m, buf)\n\tstruct dp8390_softc *sc;\n\tstruct mbuf *m;\n\tint buf;\n{\n\tbus_space_tag_t buft = sc->sc_buft;\n\tbus_space_handle_t bufh = sc->sc_bufh;\n\tu_char *data;\n\tint len, totlen = 0;\n\n\tfor (; m ; m = m->m_next) {\n\t\tdata = mtod(m, u_char *);\n\t\tlen = m->m_len;\n\t\tif (len > 0) {\n\t\t\tbus_space_write_region_1(buft, bufh, buf, data, len);\n\t\t\ttotlen += len;\n\t\t\tbuf += len;\n\t\t}\n\t}\n\n\treturn (totlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "m0",
            "buffer"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"dp8390_start: no header mbuf\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_MIN_LEN\t64\n\nstatic __inline__ void\tdp8390_xmit;\nstatic __inline__ int\tdp8390_write_mbuf;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0;\n\tint buffer;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"dp8390_start: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->write_mbuf)\n\t\tlen = (*sc->write_mbuf)(sc, m0, buffer);\n\telse\n\t\tlen = dp8390_write_mbuf(sc, m0, buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN - ETHER_CRC_LEN);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse++ == 0)\n\t\tdp8390_xmit(sc);\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}"
  },
  {
    "function_name": "dp8390_xmit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "384-426",
    "snippet": "static __inline__ void\ndp8390_xmit(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_short len;\n\n#ifdef DIAGNOSTIC\n\tif ((sc->txb_next_tx + sc->txb_inuse) % sc->txb_cnt != sc->txb_new)\n\t\tpanic(\"dp8390_xmit: desync, next_tx=%d inuse=%d cnt=%d new=%d\",\n\t\t    sc->txb_next_tx, sc->txb_inuse, sc->txb_cnt, sc->txb_new);\n\n\tif (sc->txb_inuse == 0)\n\t\tpanic(\"dp8390_xmit: no packets to xmit\\n\");\n#endif\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(regt, regh, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(regt, regh, ED_P0_TBCR0, len);\n\tNIC_PUT(regt, regh, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tif (++sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define __inline__\t/* XXX for debugging porpoises */"
    ],
    "globals_used": [
      "static __inline__ void\tdp8390_xmit",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_TBCR1",
            "len >> 8"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_TBCR0",
            "len"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_TPSR",
            "sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"dp8390_xmit: no packets to xmit\\n\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"dp8390_xmit: desync, next_tx=%d inuse=%d cnt=%d new=%d\"",
            "sc->txb_next_tx",
            "sc->txb_inuse",
            "sc->txb_cnt",
            "sc->txb_new"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define __inline__\t/* XXX for debugging porpoises */\n\nstatic __inline__ void\tdp8390_xmit;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nstatic __inline__ void\ndp8390_xmit(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_short len;\n\n#ifdef DIAGNOSTIC\n\tif ((sc->txb_next_tx + sc->txb_inuse) % sc->txb_cnt != sc->txb_new)\n\t\tpanic(\"dp8390_xmit: desync, next_tx=%d inuse=%d cnt=%d new=%d\",\n\t\t    sc->txb_next_tx, sc->txb_inuse, sc->txb_cnt, sc->txb_new);\n\n\tif (sc->txb_inuse == 0)\n\t\tpanic(\"dp8390_xmit: no packets to xmit\\n\");\n#endif\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(regt, regh, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(regt, regh, ED_P0_TBCR0, len);\n\tNIC_PUT(regt, regh, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tif (++sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}"
  },
  {
    "function_name": "dp8390_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "254-379",
    "snippet": "void\ndp8390_init(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int8_t mcaf[8];\n\tint i;\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->dcr_reg & ED_DCR_LS) {\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, sc->dcr_reg);\n\t} else {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, byte-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(regt, regh, ED_P0_RBCR0, 0);\n\tNIC_PUT(regt, regh, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(regt, regh, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(regt, regh, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(regt, regh, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_ISR, 0xff);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(regt, regh, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\tdp8390_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(regt, regh, ED_P1_MAR0 + i, mcaf[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(regt, regh, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/* Accept broadcast and multicast packets by default. */\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(regt, regh, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, 0);\n\n\t/* Do any card-specific initialization, if applicable. */\n\tif (sc->init_card)\n\t\t(*sc->init_card)(sc);\n\n\t/* Fire up the interface. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tdp8390_start(ifp);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_ADDR_LEN\t6"
    ],
    "globals_used": [
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dp8390_start",
          "args": [
            "ifp"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "437-492",
          "snippet": "void\ndp8390_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0;\n\tint buffer;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"dp8390_start: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->write_mbuf)\n\t\tlen = (*sc->write_mbuf)(sc, m0, buffer);\n\telse\n\t\tlen = dp8390_write_mbuf(sc, m0, buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN - ETHER_CRC_LEN);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse++ == 0)\n\t\tdp8390_xmit(sc);\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_MIN_LEN\t64"
          ],
          "globals_used": [
            "static __inline__ void\tdp8390_xmit",
            "static __inline__ int\tdp8390_write_mbuf",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_MIN_LEN\t64\n\nstatic __inline__ void\tdp8390_xmit;\nstatic __inline__ int\tdp8390_write_mbuf;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0;\n\tint buffer;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"dp8390_start: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->write_mbuf)\n\t\tlen = (*sc->write_mbuf)(sc, m0, buffer);\n\telse\n\t\tlen = dp8390_write_mbuf(sc, m0, buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN - ETHER_CRC_LEN);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse++ == 0)\n\t\tdp8390_xmit(sc);\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_TCR",
            "0"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_RCR",
            "i"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P1_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P1_CURR",
            "sc->next_packet"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P1_MAR0 + i",
            "mcaf[i]"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_getmcaf",
          "args": [
            "&sc->sc_arpcom",
            "mcaf"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_getmcaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "966-1033",
          "snippet": "void\ndp8390_getmcaf(ec, af)\n\tstruct arpcom *ec;\n\tu_int8_t *af;\n{\n\tstruct ifnet *ifp = &ec->ac_if;\n\tstruct ether_multi *enm;\n\tu_int8_t *cp, c;\n\tu_int32_t crc;\n\tint i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\taf[i] = 0xff;\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++)\n\t\taf[i] = 0;\n\tETHER_FIRST_MULTI(step, ec, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\taf[i] = 0xff;\n\t\t\treturn;\n\t\t}\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif (((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01)) {\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\t\tcrc ^= 0x04c11db6 | 1;\n\t\t\t\t} else\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 3] |= 1 << (crc & 0x7);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ndp8390_getmcaf(ec, af)\n\tstruct arpcom *ec;\n\tu_int8_t *af;\n{\n\tstruct ifnet *ifp = &ec->ac_if;\n\tstruct ether_multi *enm;\n\tu_int8_t *cp, c;\n\tu_int32_t crc;\n\tint i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\taf[i] = 0xff;\n\t\treturn;\n\t}\n\tfor (i = 0; i < 8; i++)\n\t\taf[i] = 0;\n\tETHER_FIRST_MULTI(step, ec, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\taf[i] = 0xff;\n\t\t\treturn;\n\t\t}\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif (((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01)) {\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\t\tcrc ^= 0x04c11db6 | 1;\n\t\t\t\t} else\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 3] |= 1 << (crc & 0x7);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P1_PAR0 + i",
            "sc->sc_arpcom.ac_enaddr[i]"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_ISR",
            "0xff"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_IMR",
            "ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_PSTOP",
            "sc->rec_page_stop"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_PSTART",
            "sc->rec_page_start"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_BNRY",
            "sc->rec_page_start"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "0x09",
            "0"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_TCR",
            "ED_TCR_LB0"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_RCR",
            "ED_RCR_MON"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_RBCR1",
            "0"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_RBCR0",
            "0"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_DCR",
            "ED_DCR_FT1 | ED_DCR_LS"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_DCR",
            "sc->dcr_reg"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_init(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int8_t mcaf[8];\n\tint i;\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->dcr_reg & ED_DCR_LS) {\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, sc->dcr_reg);\n\t} else {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, byte-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(regt, regh, ED_P0_RBCR0, 0);\n\tNIC_PUT(regt, regh, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(regt, regh, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(regt, regh, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(regt, regh, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_ISR, 0xff);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(regt, regh, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\tdp8390_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(regt, regh, ED_P1_MAR0 + i, mcaf[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(regt, regh, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/* Accept broadcast and multicast packets by default. */\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(regt, regh, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, 0);\n\n\t/* Do any card-specific initialization, if applicable. */\n\tif (sc->init_card)\n\t\t(*sc->init_card)(sc);\n\n\t/* Fire up the interface. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tdp8390_start(ifp);\n}"
  },
  {
    "function_name": "dp8390_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "239-249",
    "snippet": "void\ndp8390_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\tdp8390_reset(sc);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dp8390_reset",
          "args": [
            "sc"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "197-207",
          "snippet": "void\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\tdp8390_reset(sc);\n}"
  },
  {
    "function_name": "dp8390_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "212-232",
    "snippet": "void\ndp8390_stop(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(regt, regh,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n)\n\t\t;\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "regt",
            "regh",
            "ED_P0_ISR"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "regt",
            "regh",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_stop(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(regt, regh,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n)\n\t\t;\n}"
  },
  {
    "function_name": "dp8390_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "197-207",
    "snippet": "void\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_init",
          "args": [
            "sc"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "254-379",
          "snippet": "void\ndp8390_init(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int8_t mcaf[8];\n\tint i;\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->dcr_reg & ED_DCR_LS) {\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, sc->dcr_reg);\n\t} else {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, byte-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(regt, regh, ED_P0_RBCR0, 0);\n\tNIC_PUT(regt, regh, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(regt, regh, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(regt, regh, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(regt, regh, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_ISR, 0xff);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(regt, regh, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\tdp8390_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(regt, regh, ED_P1_MAR0 + i, mcaf[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(regt, regh, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/* Accept broadcast and multicast packets by default. */\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(regt, regh, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, 0);\n\n\t/* Do any card-specific initialization, if applicable. */\n\tif (sc->init_card)\n\t\t(*sc->init_card)(sc);\n\n\t/* Fire up the interface. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tdp8390_start(ifp);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_init(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_int8_t mcaf[8];\n\tint i;\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->dcr_reg & ED_DCR_LS) {\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, sc->dcr_reg);\n\t} else {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, byte-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(regt, regh, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(regt, regh, ED_P0_RBCR0, 0);\n\tNIC_PUT(regt, regh, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(regt, regh, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(regt, regh, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(regt, regh, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(regt, regh, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(regt, regh, ED_P0_ISR, 0xff);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(regt, regh, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\tdp8390_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(regt, regh, ED_P1_MAR0 + i, mcaf[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(regt, regh, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/* Accept broadcast and multicast packets by default. */\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(regt, regh, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(regt, regh, ED_P0_TCR, 0);\n\n\t/* Do any card-specific initialization, if applicable. */\n\tif (sc->init_card)\n\t\t(*sc->init_card)(sc);\n\n\t/* Fire up the interface. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tdp8390_start(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp8390_stop",
          "args": [
            "sc"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "212-232",
          "snippet": "void\ndp8390_stop(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(regt, regh,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n)\n\t\t;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_stop(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(regt, regh,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n)\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "dp8390_mediastatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "177-192",
    "snippet": "void\ndp8390_mediastatus(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\n\tif (sc->sc_enabled == 0) {\n\t\tifmr->ifm_active = IFM_ETHER | IFM_NONE;\n\t\tifmr->ifm_status = 0;\n\t\treturn;\n\t}\n\n\tif (sc->sc_mediastatus)\n\t\t(*sc->sc_mediastatus)(sc, ifmr);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tdp8390_mediastatus",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "ifmr"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tdp8390_mediastatus;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_mediastatus(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\n\tif (sc->sc_enabled == 0) {\n\t\tifmr->ifm_active = IFM_ETHER | IFM_NONE;\n\t\tifmr->ifm_status = 0;\n\t\treturn;\n\t}\n\n\tif (sc->sc_mediastatus)\n\t\t(*sc->sc_mediastatus)(sc, ifmr);\n}"
  },
  {
    "function_name": "dp8390_mediachange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "163-172",
    "snippet": "int\ndp8390_mediachange(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\n\tif (sc->sc_mediachange)\n\t\treturn ((*sc->sc_mediachange)(sc));\n\treturn (EINVAL);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tdp8390_mediachange",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tdp8390_mediachange;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nint\ndp8390_mediachange(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct dp8390_softc *sc = ifp->if_softc;\n\n\tif (sc->sc_mediachange)\n\t\treturn ((*sc->sc_mediachange)(sc));\n\treturn (EINVAL);\n}"
  },
  {
    "function_name": "dp8390_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
    "lines": "86-158",
    "snippet": "int\ndp8390_config(sc, media, nmedia, defmedia)\n\tstruct dp8390_softc *sc;\n\tint *media, nmedia, defmedia;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, rv;\n\n\trv = 1;\n\n\tif (!sc->test_mem)\n\t\tsc->test_mem = dp8390_test_mem;\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((sc->mem_size < 16384) ||\n\t    (sc->sc_flags & DP8390_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse if (sc->mem_size < 8192 * 3)\n\t\tsc->txb_cnt = 2;\n\telse\n\t\tsc->txb_cnt = 3;\n\n\tsc->tx_page_start = sc->mem_start >> ED_PAGE_SHIFT;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_end = sc->mem_start + sc->mem_size;\n\n\t/* Now zero memory and verify that it is clear. */\n\tif ((*sc->test_mem)(sc))\n\t\tgoto out;\n\n\t/* Set interface to stopped condition (reset). */\n\tdp8390_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = dp8390_start;\n\tifp->if_ioctl = dp8390_ioctl;\n\tif (!ifp->if_watchdog)\n\t\tifp->if_watchdog = dp8390_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Initialize media goo. */\n\tifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);\n\tif (media != NULL) {\n\t\tfor (i = 0; i < nmedia; i++)\n\t\t\tifmedia_add(&sc->sc_media, media[i], 0, NULL);\n\t\tifmedia_set(&sc->sc_media, defmedia);\n\t} else {\n\t\tifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);\n\t\tifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);\n\t}\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n\t/* Print additional info when attached. */\n\tprintf(\"%s: address %s\\n\", sc->sc_dev.dv_xname,\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\trv = 0;\nout:\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\tdp8390_test_mem",
      "int\tdp8390_mediachange",
      "void\tdp8390_mediastatus",
      "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: address %s\\n\"",
            "sc->sc_dev.dv_xname",
            "ether_sprintf(sc->sc_arpcom.ac_enaddr)"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->sc_arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_media",
            "IFM_ETHER|IFM_MANUAL"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_media",
            "IFM_ETHER|IFM_MANUAL",
            "0",
            "NULL"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_media",
            "defmedia"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_media",
            "media[i]",
            "0",
            "NULL"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_media",
            "0",
            "dp8390_mediachange",
            "dp8390_mediastatus"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp8390_stop",
          "args": [
            "sc"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "212-232",
          "snippet": "void\ndp8390_stop(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(regt, regh,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n)\n\t\t;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_stop(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(regt, regh,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n)\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int\t\tdp8390_test_mem;\nint\tdp8390_mediachange;\nvoid\tdp8390_mediastatus;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nint\ndp8390_config(sc, media, nmedia, defmedia)\n\tstruct dp8390_softc *sc;\n\tint *media, nmedia, defmedia;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, rv;\n\n\trv = 1;\n\n\tif (!sc->test_mem)\n\t\tsc->test_mem = dp8390_test_mem;\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((sc->mem_size < 16384) ||\n\t    (sc->sc_flags & DP8390_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse if (sc->mem_size < 8192 * 3)\n\t\tsc->txb_cnt = 2;\n\telse\n\t\tsc->txb_cnt = 3;\n\n\tsc->tx_page_start = sc->mem_start >> ED_PAGE_SHIFT;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_end = sc->mem_start + sc->mem_size;\n\n\t/* Now zero memory and verify that it is clear. */\n\tif ((*sc->test_mem)(sc))\n\t\tgoto out;\n\n\t/* Set interface to stopped condition (reset). */\n\tdp8390_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = dp8390_start;\n\tifp->if_ioctl = dp8390_ioctl;\n\tif (!ifp->if_watchdog)\n\t\tifp->if_watchdog = dp8390_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Initialize media goo. */\n\tifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);\n\tif (media != NULL) {\n\t\tfor (i = 0; i < nmedia; i++)\n\t\t\tifmedia_add(&sc->sc_media, media[i], 0, NULL);\n\t\tifmedia_set(&sc->sc_media, defmedia);\n\t} else {\n\t\tifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);\n\t\tifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);\n\t}\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n\t/* Print additional info when attached. */\n\tprintf(\"%s: address %s\\n\", sc->sc_dev.dv_xname,\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\trv = 0;\nout:\n\treturn (rv);\n}"
  }
]