[
  {
    "function_name": "wsevent_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
    "lines": "183-201",
    "snippet": "int\nwsevent_poll(ev, events, p)\n\tstruct wseventvar *ev;\n\tint events;\n\tstruct proc *p;\n{\n\tint revents = 0;\n\tint s = splwsevent();\n\n        if (events & (POLLIN | POLLRDNORM)) {\n\t\tif (ev->get != ev->put)\n\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\telse\n\t\t\tselrecord(p, &ev->sel);\n\t}\n\n\tsplx(s);\n\treturn (revents);\n}",
    "includes": [
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selrecord",
          "args": [
            "p",
            "&ev->sel"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splwsevent",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsevent_poll(ev, events, p)\n\tstruct wseventvar *ev;\n\tint events;\n\tstruct proc *p;\n{\n\tint revents = 0;\n\tint s = splwsevent();\n\n        if (events & (POLLIN | POLLRDNORM)) {\n\t\tif (ev->get != ev->put)\n\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\telse\n\t\t\tselrecord(p, &ev->sel);\n\t}\n\n\tsplx(s);\n\treturn (revents);\n}"
  },
  {
    "function_name": "wsevent_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
    "lines": "125-181",
    "snippet": "int\nwsevent_read(ev, uio, flags)\n\tstruct wseventvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct wscons_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splwsevent();\n\twhile (ev->get == ev->put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PWSEVENT | PCATCH,\n\t\t    \"wsevent_read\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move wscons_event from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->put < ev->get)\n\t\tcnt = WSEVENT_QSIZE - ev->get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->put - ev->get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct wscons_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[ev->get],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->get = (ev->get + cnt) % WSEVENT_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[0],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tev->get = cnt;\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(caddr_t)&ev->q[0]",
            "cnt * sizeof(struct wscons_event)",
            "uio"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "(caddr_t)&ev->q[ev->get]",
            "cnt * sizeof(struct wscons_event)",
            "uio"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "uio->uio_resid",
            "sizeof(struct wscons_event)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)ev",
            "PWSEVENT | PCATCH",
            "\"wsevent_read\"",
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splwsevent",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsevent_read(ev, uio, flags)\n\tstruct wseventvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct wscons_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splwsevent();\n\twhile (ev->get == ev->put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PWSEVENT | PCATCH,\n\t\t    \"wsevent_read\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move wscons_event from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->put < ev->get)\n\t\tcnt = WSEVENT_QSIZE - ev->get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->put - ev->get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct wscons_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[ev->get],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->get = (ev->get + cnt) % WSEVENT_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[0],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tev->get = cnt;\n\treturn (error);\n}"
  },
  {
    "function_name": "wsevent_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
    "lines": "113-119",
    "snippet": "void\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}",
    "includes": [
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ev->q",
            "M_DEVBUF"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_pickfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1057-1070",
          "snippet": "int\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}"
  },
  {
    "function_name": "wsevent_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
    "lines": "99-108",
    "snippet": "void\nwsevent_init(ev)\n\tstruct wseventvar *ev;\n{\n\n\tev->get = ev->put = 0;\n\tev->q = malloc((u_long)WSEVENT_QSIZE * sizeof(struct wscons_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->q, WSEVENT_QSIZE * sizeof(struct wscons_event));\n}",
    "includes": [
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/vnode.h>",
      "#include <sys/systm.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t)ev->q",
            "WSEVENT_QSIZE * sizeof(struct wscons_event)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(u_long)WSEVENT_QSIZE * sizeof(struct wscons_event)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwsevent_init(ev)\n\tstruct wseventvar *ev;\n{\n\n\tev->get = ev->put = 0;\n\tev->q = malloc((u_long)WSEVENT_QSIZE * sizeof(struct wscons_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->q, WSEVENT_QSIZE * sizeof(struct wscons_event));\n}"
  }
]