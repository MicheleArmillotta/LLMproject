[
  {
    "function_name": "ahb_print_active_ecb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "1204-1219",
    "snippet": "void\nahb_print_active_ecb(sc)\n\tstruct ahb_softc *sc;\n{\n\tstruct ahb_ecb *ecb;\n\tint i = 0;\n\n\twhile (i++ < ECB_HASH_SIZE) {\n\t\tecb = sc->ecb_hash_list[i];\n\t\twhile (ecb) {\n\t\t\tif (ecb->flags != ECB_FREE)\n\t\t\t\tahb_print_ecb(ecb);\n\t\t\tecb = ecb->hash_list;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ECB_FREE\t0",
      "#define\tECB_HASH_SIZE\t32\t/* hash table size for phystokv */"
    ],
    "globals_used": [
      "void ahb_print_ecb",
      "void ahb_print_active_ecb",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "int flags;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahb_print_ecb",
          "args": [
            "ecb"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_print_ecb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "1192-1202",
          "snippet": "void\nahb_print_ecb(ecb)\n\tstruct ahb_ecb *ecb;\n{\n\tprintf(\"ecb:%x op:%x cmdlen:%d senlen:%d\\n\",\n\t\tecb, ecb->opcode, ecb->cdblen, ecb->senselen);\n\tprintf(\"\tdatlen:%d hstat:%x tstat:%x flags:%x\\n\",\n\t\tecb->datalen, ecb->ecb_status.host_stat,\n\t\tecb->ecb_status.target_stat, ecb->flags);\n\tshow_scsi_cmd(ecb->xs);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void ahb_print_ecb",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid ahb_print_ecb;\nint flags;\n\nvoid\nahb_print_ecb(ecb)\n\tstruct ahb_ecb *ecb;\n{\n\tprintf(\"ecb:%x op:%x cmdlen:%d senlen:%d\\n\",\n\t\tecb, ecb->opcode, ecb->cdblen, ecb->senselen);\n\tprintf(\"\tdatlen:%d hstat:%x tstat:%x flags:%x\\n\",\n\t\tecb->datalen, ecb->ecb_status.host_stat,\n\t\tecb->ecb_status.target_stat, ecb->flags);\n\tshow_scsi_cmd(ecb->xs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_FREE\t0\n#define\tECB_HASH_SIZE\t32\t/* hash table size for phystokv */\n\nvoid ahb_print_ecb;\nvoid ahb_print_active_ecb;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_print_active_ecb(sc)\n\tstruct ahb_softc *sc;\n{\n\tstruct ahb_ecb *ecb;\n\tint i = 0;\n\n\twhile (i++ < ECB_HASH_SIZE) {\n\t\tecb = sc->ecb_hash_list[i];\n\t\twhile (ecb) {\n\t\t\tif (ecb->flags != ECB_FREE)\n\t\t\t\tahb_print_ecb(ecb);\n\t\t\tecb = ecb->hash_list;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ahb_print_ecb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "1192-1202",
    "snippet": "void\nahb_print_ecb(ecb)\n\tstruct ahb_ecb *ecb;\n{\n\tprintf(\"ecb:%x op:%x cmdlen:%d senlen:%d\\n\",\n\t\tecb, ecb->opcode, ecb->cdblen, ecb->senselen);\n\tprintf(\"\tdatlen:%d hstat:%x tstat:%x flags:%x\\n\",\n\t\tecb->datalen, ecb->ecb_status.host_stat,\n\t\tecb->ecb_status.target_stat, ecb->flags);\n\tshow_scsi_cmd(ecb->xs);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ahb_print_ecb",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_scsi_cmd",
          "args": [
            "ecb->xs"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_show_scsi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "90-113",
          "snippet": "static int\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\tdatlen:%d hstat:%x tstat:%x flags:%x\\n\"",
            "ecb->datalen",
            "ecb->ecb_status.host_stat",
            "ecb->ecb_status.target_stat",
            "ecb->flags"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid ahb_print_ecb;\nint flags;\n\nvoid\nahb_print_ecb(ecb)\n\tstruct ahb_ecb *ecb;\n{\n\tprintf(\"ecb:%x op:%x cmdlen:%d senlen:%d\\n\",\n\t\tecb, ecb->opcode, ecb->cdblen, ecb->senselen);\n\tprintf(\"\tdatlen:%d hstat:%x tstat:%x flags:%x\\n\",\n\t\tecb->datalen, ecb->ecb_status.host_stat,\n\t\tecb->ecb_status.target_stat, ecb->flags);\n\tshow_scsi_cmd(ecb->xs);\n}"
  },
  {
    "function_name": "ahb_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "1143-1189",
    "snippet": "void\nahb_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ahb_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ahb_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_IMMED) {\n\t\tprintf(\"\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tahb_done(sc, ecb);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ecb->flags == ECB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tahb_done(sc, ecb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tecb->xs->error = XS_TIMEOUT;\n\t\tecb->flags = ECB_ABORTED;\n\t\tahb_send_mbox(sc, OP_ABORT_ECB, ecb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(ahb_timeout, ecb, 2 * hz);\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ECB_IMMED_FAIL\t8",
      "#define ECB_IMMED\t4",
      "#define ECB_ABORTED\t2",
      "#define  OP_ABORT_ECB\t\t0x50"
    ],
    "globals_used": [
      "void ahb_send_mbox",
      "void ahb_done",
      "void ahb_timeout",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "int flags;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ahb_timeout",
            "ecb",
            "2 * hz"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "1143-1189",
          "snippet": "void\nahb_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ahb_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ahb_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_IMMED) {\n\t\tprintf(\"\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tahb_done(sc, ecb);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ecb->flags == ECB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tahb_done(sc, ecb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tecb->xs->error = XS_TIMEOUT;\n\t\tecb->flags = ECB_ABORTED;\n\t\tahb_send_mbox(sc, OP_ABORT_ECB, ecb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(ahb_timeout, ecb, 2 * hz);\n\t}\n\n\tsplx(s);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ahb_send_mbox",
          "args": [
            "sc",
            "OP_ABORT_ECB",
            "ecb"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_send_mbox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "335-359",
          "snippet": "void\nahb_send_mbox(sc, opcode, ecb)\n\tstruct ahb_softc *sc;\n\tint opcode;\n\tstruct ahb_ecb *ecb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint wait = 300;\t/* 1ms should be enough */\n\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) &\n\t\t    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif (!wait) {\n\t\tprintf(\"%s: board not responding\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\t/* don't know this will work */\n\tbus_space_write_4(iot, ioh, MBOXOUT0, KVTOPHYS(ecb));\n\tbus_space_write_1(iot, ioh, ATTN, opcode | ecb->xs->sc_link->target);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tG2STAT_MBOX_EMPTY\t0x04",
            "#define\tG2STAT_BUSY\t\t0x01",
            "#define G2STAT\t\t0xCD7",
            "#define\tATTN\t\t0xCD4",
            "#define MBOXOUT0\t0xCD0"
          ],
          "globals_used": [
            "void ahb_send_mbox",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tG2STAT_MBOX_EMPTY\t0x04\n#define\tG2STAT_BUSY\t\t0x01\n#define G2STAT\t\t0xCD7\n#define\tATTN\t\t0xCD4\n#define MBOXOUT0\t0xCD0\n\nvoid ahb_send_mbox;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_send_mbox(sc, opcode, ecb)\n\tstruct ahb_softc *sc;\n\tint opcode;\n\tstruct ahb_ecb *ecb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint wait = 300;\t/* 1ms should be enough */\n\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) &\n\t\t    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif (!wait) {\n\t\tprintf(\"%s: board not responding\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\t/* don't know this will work */\n\tbus_space_write_4(iot, ioh, MBOXOUT0, KVTOPHYS(ecb));\n\tbus_space_write_1(iot, ioh, ATTN, opcode | ecb->xs->sc_link->target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahb_done",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "626-691",
          "snippet": "void\nahb_done(sc, ecb)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n{\n\tstruct ahb_ecb_status *stat = &ecb->ecb_status;\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ecb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahb_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((xs->flags & INUSE) == 0) {\n\t\tprintf(\"%s: exiting but not in use!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\tif (ecb->flags & ECB_IMMED) {\n\t\tif (ecb->flags & ECB_IMMED_FAIL)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (stat->host_stat != HS_OK) {\n\t\t\tswitch (stat->host_stat) {\n\t\t\tcase HS_SCSI_RESET_ADAPTER:\n\t\t\t\tbreak;\n\t\t\tcase HS_SCSI_RESET_INCOMING:\n\t\t\t\tbreak;\n\t\t\tcase HS_CMD_ABORTED_HOST:\n\t\t\tcase HS_CMD_ABORTED_ADAPTER:\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\tcase HS_TIMED_OUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (stat->target_stat != SCSI_OK) {\n\t\t\tswitch (stat->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ecb->ecb_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\ndone:\n\txs->flags |= ITSDONE;\n\tahb_free_ecb(sc, ecb, xs->flags);\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ECB_IMMED_FAIL\t8",
            "#define ECB_IMMED\t4",
            "#define\tHS_SCSI_RESET_INCOMING\t0x23",
            "#define\tHS_SCSI_RESET_ADAPTER\t0x22",
            "#define\tHS_TIMED_OUT\t\t0x11",
            "#define\tHS_CMD_ABORTED_ADAPTER\t0x05",
            "#define\tHS_CMD_ABORTED_HOST\t0x04",
            "#define\tHS_OK\t\t\t0x00"
          ],
          "globals_used": [
            "void ahb_done",
            "void ahb_free_ecb",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "int flags;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_IMMED_FAIL\t8\n#define ECB_IMMED\t4\n#define\tHS_SCSI_RESET_INCOMING\t0x23\n#define\tHS_SCSI_RESET_ADAPTER\t0x22\n#define\tHS_TIMED_OUT\t\t0x11\n#define\tHS_CMD_ABORTED_ADAPTER\t0x05\n#define\tHS_CMD_ABORTED_HOST\t0x04\n#define\tHS_OK\t\t\t0x00\n\nvoid ahb_done;\nvoid ahb_free_ecb;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_done(sc, ecb)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n{\n\tstruct ahb_ecb_status *stat = &ecb->ecb_status;\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ecb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahb_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((xs->flags & INUSE) == 0) {\n\t\tprintf(\"%s: exiting but not in use!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\tif (ecb->flags & ECB_IMMED) {\n\t\tif (ecb->flags & ECB_IMMED_FAIL)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (stat->host_stat != HS_OK) {\n\t\t\tswitch (stat->host_stat) {\n\t\t\tcase HS_SCSI_RESET_ADAPTER:\n\t\t\t\tbreak;\n\t\t\tcase HS_SCSI_RESET_INCOMING:\n\t\t\t\tbreak;\n\t\t\tcase HS_CMD_ABORTED_HOST:\n\t\t\tcase HS_CMD_ABORTED_ADAPTER:\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\tcase HS_TIMED_OUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (stat->target_stat != SCSI_OK) {\n\t\t\tswitch (stat->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ecb->ecb_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\ndone:\n\txs->flags |= ITSDONE;\n\tahb_free_ecb(sc, ecb, xs->flags);\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_IMMED_FAIL\t8\n#define ECB_IMMED\t4\n#define ECB_ABORTED\t2\n#define  OP_ABORT_ECB\t\t0x50\n\nvoid ahb_send_mbox;\nvoid ahb_done;\nvoid ahb_timeout;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ahb_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ahb_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_IMMED) {\n\t\tprintf(\"\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tahb_done(sc, ecb);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ecb->flags == ECB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tahb_done(sc, ecb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tecb->xs->error = XS_TIMEOUT;\n\t\tecb->flags = ECB_ABORTED;\n\t\tahb_send_mbox(sc, OP_ABORT_ECB, ecb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(ahb_timeout, ecb, 2 * hz);\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "ahb_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "938-1141",
    "snippet": "int\nahb_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ahb_softc *sc = sc_link->adapter_softc;\n\tstruct ahb_ecb *ecb;\n\tstruct ahb_dma_seg *sg;\n\tint seg;\t\t/* scatter gather seg being worked on */\n\tu_long thiskv, thisphys, nextphys;\n\tint bytes_this_seg, bytes_this_page, datalen, flags;\n#ifdef TFS\n\tstruct iovec *iovp;\n#endif\n\tint s;\n\n\tSC_DEBUG(sc_link, SDEV_DB2, (\"ahb_scsi_cmd\\n\"));\n\t/*\n\t * get a ecb (mbox-out) to use. If the transfer\n\t * is from a buf (possibly from interrupt time)\n\t * then we can't allow it to sleep\n\t */\n\tflags = xs->flags;\n\tif ((flags & (ITSDONE|INUSE)) != INUSE) {\n\t\tprintf(\"%s: done or not in use?\\n\", sc->sc_dev.dv_xname);\n\t\txs->flags &= ~ITSDONE;\n\t\txs->flags |= INUSE;\n\t}\n\tif ((ecb = ahb_get_ecb(sc, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\tecb->xs = xs;\n\n\t/*\n\t * If it's a reset, we need to do an 'immediate'\n\t * command, and store its ecb for later\n\t * if there is already an immediate waiting,\n\t * then WE must wait\n\t */\n\tif (flags & SCSI_RESET) {\n\t\tecb->flags |= ECB_IMMED;\n\t\tif (sc->immed_ecb)\n\t\t\treturn TRY_AGAIN_LATER;\n\t\tsc->immed_ecb = ecb;\n\n\t\ts = splbio();\n\n\t\tahb_send_immed(sc, sc_link->target, AHB_TARG_RESET);\n\n\t\tif ((flags & SCSI_POLL) == 0) {\n\t\t\ttimeout(ahb_timeout, ecb, (xs->timeout * hz) / 1000);\n\t\t\tsplx(s);\n\t\t\treturn SUCCESSFULLY_QUEUED;\n\t\t}\n\n\t\tsplx(s);\n\n\t\t/*\n\t\t * If we can't use interrupts, poll on completion\n\t\t */\n\t\tif (ahb_poll(sc, xs, xs->timeout))\n\t\t\tahb_timeout(ecb);\n\t\treturn COMPLETE;\n\t}\n\n\t/*\n\t * Put all the arguments for the xfer in the ecb\n\t */\n\tecb->opcode = ECB_SCSI_OP;\n\tecb->opt1 = ECB_SES | ECB_DSB | ECB_ARS;\n\tif (xs->datalen)\n\t\tecb->opt1 |= ECB_S_G;\n\tecb->opt2 = sc_link->lun | ECB_NRB;\n\tecb->scsi_cmd_length = xs->cmdlen;\n\tecb->sense_ptr = KVTOPHYS(&ecb->ecb_sense);\n\tecb->req_sense_length = sizeof(ecb->ecb_sense);\n\tecb->status = KVTOPHYS(&ecb->ecb_status);\n\tecb->ecb_status.host_stat = 0x00;\n\tecb->ecb_status.target_stat = 0x00;\n\n\tif (xs->datalen && (flags & SCSI_RESET) == 0) {\n\t\tecb->data_addr = KVTOPHYS(ecb->ahb_dma);\n\t\tsg = ecb->ahb_dma;\n\t\tseg = 0;\n#ifdef\tTFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\tiovp = ((struct uio *) xs->data)->uio_iov;\n\t\t\tdatalen = ((struct uio *) xs->data)->uio_iovcnt;\n\t\t\txs->datalen = 0;\n\t\t\twhile (datalen && seg < AHB_NSEG) {\n\t\t\t\tsg->seg_addr = (physaddr)iovp->iov_base;\n\t\t\t\tsg->seg_len = iovp->iov_len;\n\t\t\t\txs->datalen += iovp->iov_len;\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base));\n\t\t\t\tsg++;\n\t\t\t\tiovp++;\n\t\t\t\tseg++;\n\t\t\t\tdatalen--;\n\t\t\t}\n\t\t}\n\t\telse\n#endif /*TFS */\n\t\t{\n\t\t\t/*\n\t\t\t * Set up the scatter gather block\n\t\t\t */\n\t\t\tSC_DEBUG(sc_link, SDEV_DB4,\n\t\t\t    (\"%d @0x%x:- \", xs->datalen, xs->data));\n\t\t\tdatalen = xs->datalen;\n\t\t\tthiskv = (long) xs->data;\n\t\t\tthisphys = KVTOPHYS(thiskv);\n\n\t\t\twhile (datalen && seg < AHB_NSEG) {\n\t\t\t\tbytes_this_seg = 0;\n\n\t\t\t\t/* put in the base address */\n\t\t\t\tsg->seg_addr = thisphys;\n\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"0x%x\", thisphys));\n\n\t\t\t\t/* do it at least once */\n\t\t\t\tnextphys = thisphys;\n\t\t\t\twhile (datalen && thisphys == nextphys) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This page is contiguous (physically)\n\t\t\t\t\t * with the the last, just extend the\n\t\t\t\t\t * length\n\t\t\t\t\t */\n\t\t\t\t\t/* how far to the end of the page */\n\t\t\t\t\tnextphys = (thisphys & ~PGOFSET) + NBPG;\n\t\t\t\t\tbytes_this_page = nextphys - thisphys;\n\t\t\t\t\t/**** or the data ****/\n\t\t\t\t\tbytes_this_page = min(bytes_this_page,\n\t\t\t\t\t\t\t      datalen);\n\t\t\t\t\tbytes_this_seg += bytes_this_page;\n\t\t\t\t\tdatalen -= bytes_this_page;\n\n\t\t\t\t\t/* get more ready for the next page */\n\t\t\t\t\tthiskv = (thiskv & ~PGOFSET) + NBPG;\n\t\t\t\t\tif (datalen)\n\t\t\t\t\t\tthisphys = KVTOPHYS(thiskv);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * next page isn't contiguous, finish the seg\n\t\t\t\t */\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4,\n\t\t\t\t    (\"(0x%x)\", bytes_this_seg));\n\t\t\t\tsg->seg_len = bytes_this_seg;\n\t\t\t\tsg++;\n\t\t\t\tseg++;\n\t\t\t}\n\t\t}\n\t\t/*end of iov/kv decision */\n\t\tecb->data_length = seg * sizeof(struct ahb_dma_seg);\n\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"\\n\"));\n\t\tif (datalen) {\n\t\t\t/*\n\t\t\t * there's still data, must have run out of segs!\n\t\t\t */\n\t\t\tprintf(\"%s: ahb_scsi_cmd, more than %d dma segs\\n\",\n\t\t\t    sc->sc_dev.dv_xname, AHB_NSEG);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tahb_free_ecb(sc, ecb, flags);\n\t\t\treturn COMPLETE;\n\t\t}\n\t} else {\t/* No data xfer, use non S/G values */\n\t\tecb->data_addr = (physaddr)0;\n\t\tecb->data_length = 0;\n\t}\n\tecb->link_addr = (physaddr)0;\n\n\t/*\n\t * Put the scsi command in the ecb and start it\n\t */\n\tif ((flags & SCSI_RESET) == 0)\n\t\tbcopy(xs->cmd, &ecb->scsi_cmd, ecb->scsi_cmd_length);\n\n\ts = splbio();\n\n\tahb_send_mbox(sc, OP_START_ECB, ecb);\n\n\t/*\n\t * Usually return SUCCESSFULLY QUEUED\n\t */\n\tif ((flags & SCSI_POLL) == 0) {\n\t\ttimeout(ahb_timeout, ecb, (xs->timeout * hz) / 1000);\n\t\tsplx(s);\n\t\treturn SUCCESSFULLY_QUEUED;\n\t}\n\n\tsplx(s);\n\n\t/*\n\t * If we can't use interrupts, poll on completion\n\t */\n\tif (ahb_poll(sc, xs, xs->timeout)) {\n\t\tahb_timeout(ecb);\n\t\tif (ahb_poll(sc, xs, 2000))\n\t\t\tahb_timeout(ecb);\n\t}\n\treturn COMPLETE;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ECB_IMMED\t4",
      "#define\tECB_NRB\t0x8000",
      "#define\tECB_ARS\t0x8000",
      "#define\tECB_DSB\t0x4000",
      "#define\tECB_S_G\t0x1000",
      "#define\tECB_SES\t0x0400",
      "#define\tECB_SCSI_OP\t0x01",
      "#define  OP_START_ECB\t\t0x40",
      "#define\t  AHB_TARG_RESET\t0x80",
      "#define\tAHB_NSEG\t33\t/* number of dma segments supported */"
    ],
    "globals_used": [
      "void ahb_send_mbox",
      "int ahb_poll",
      "void ahb_send_immed",
      "void ahb_free_ecb",
      "struct ahb_ecb *ahb_get_ecb",
      "int ahb_scsi_cmd",
      "void ahb_timeout",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "int flags;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahb_timeout",
          "args": [
            "ecb"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "1143-1189",
          "snippet": "void\nahb_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ahb_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ahb_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_IMMED) {\n\t\tprintf(\"\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tahb_done(sc, ecb);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ecb->flags == ECB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tahb_done(sc, ecb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tecb->xs->error = XS_TIMEOUT;\n\t\tecb->flags = ECB_ABORTED;\n\t\tahb_send_mbox(sc, OP_ABORT_ECB, ecb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(ahb_timeout, ecb, 2 * hz);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ECB_IMMED_FAIL\t8",
            "#define ECB_IMMED\t4",
            "#define ECB_ABORTED\t2",
            "#define  OP_ABORT_ECB\t\t0x50"
          ],
          "globals_used": [
            "void ahb_send_mbox",
            "void ahb_done",
            "void ahb_timeout",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "int flags;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_IMMED_FAIL\t8\n#define ECB_IMMED\t4\n#define ECB_ABORTED\t2\n#define  OP_ABORT_ECB\t\t0x50\n\nvoid ahb_send_mbox;\nvoid ahb_done;\nvoid ahb_timeout;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ahb_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ahb_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_IMMED) {\n\t\tprintf(\"\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tahb_done(sc, ecb);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ecb->flags == ECB_ABORTED) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\tecb->xs->retries = 0;\t/* I MEAN IT ! */\n\t\tahb_done(sc, ecb);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tecb->xs->error = XS_TIMEOUT;\n\t\tecb->flags = ECB_ABORTED;\n\t\tahb_send_mbox(sc, OP_ABORT_ECB, ecb);\n\t\t/* 2 secs for the abort */\n\t\tif ((xs->flags & SCSI_POLL) == 0)\n\t\t\ttimeout(ahb_timeout, ecb, 2 * hz);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahb_poll",
          "args": [
            "sc",
            "xs",
            "2000"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "364-386",
          "snippet": "int\nahb_poll(sc, xs, count)\n\tstruct ahb_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\t\t\t\t/* in msec  */\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND)\n\t\t\tahbintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tG2STAT_INT_PEND\t\t0x02",
            "#define G2STAT\t\t0xCD7"
          ],
          "globals_used": [
            "int ahb_poll",
            "int ahbintr",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "int flags;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tG2STAT_INT_PEND\t\t0x02\n#define G2STAT\t\t0xCD7\n\nint ahb_poll;\nint ahbintr;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nint\nahb_poll(sc, xs, count)\n\tstruct ahb_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\t\t\t\t/* in msec  */\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND)\n\t\t\tahbintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahb_send_mbox",
          "args": [
            "sc",
            "OP_START_ECB",
            "ecb"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_send_mbox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "335-359",
          "snippet": "void\nahb_send_mbox(sc, opcode, ecb)\n\tstruct ahb_softc *sc;\n\tint opcode;\n\tstruct ahb_ecb *ecb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint wait = 300;\t/* 1ms should be enough */\n\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) &\n\t\t    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif (!wait) {\n\t\tprintf(\"%s: board not responding\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\t/* don't know this will work */\n\tbus_space_write_4(iot, ioh, MBOXOUT0, KVTOPHYS(ecb));\n\tbus_space_write_1(iot, ioh, ATTN, opcode | ecb->xs->sc_link->target);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tG2STAT_MBOX_EMPTY\t0x04",
            "#define\tG2STAT_BUSY\t\t0x01",
            "#define G2STAT\t\t0xCD7",
            "#define\tATTN\t\t0xCD4",
            "#define MBOXOUT0\t0xCD0"
          ],
          "globals_used": [
            "void ahb_send_mbox",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tG2STAT_MBOX_EMPTY\t0x04\n#define\tG2STAT_BUSY\t\t0x01\n#define G2STAT\t\t0xCD7\n#define\tATTN\t\t0xCD4\n#define MBOXOUT0\t0xCD0\n\nvoid ahb_send_mbox;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_send_mbox(sc, opcode, ecb)\n\tstruct ahb_softc *sc;\n\tint opcode;\n\tstruct ahb_ecb *ecb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint wait = 300;\t/* 1ms should be enough */\n\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) &\n\t\t    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif (!wait) {\n\t\tprintf(\"%s: board not responding\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\t/* don't know this will work */\n\tbus_space_write_4(iot, ioh, MBOXOUT0, KVTOPHYS(ecb));\n\tbus_space_write_1(iot, ioh, ATTN, opcode | ecb->xs->sc_link->target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "xs->cmd",
            "&ecb->scsi_cmd",
            "ecb->scsi_cmd_length"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahb_free_ecb",
          "args": [
            "sc",
            "ecb",
            "flags"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_free_ecb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "697-718",
          "snippet": "void\nahb_free_ecb(sc, ecb, flags)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tecb->flags = ECB_FREE;\n\tTAILQ_INSERT_HEAD(&sc->free_ecb, ecb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ecb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_ecb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ECB_FREE\t0"
          ],
          "globals_used": [
            "void ahb_free_ecb",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "int flags;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_FREE\t0\n\nvoid ahb_free_ecb;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_free_ecb(sc, ecb, flags)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tecb->flags = ECB_FREE;\n\tTAILQ_INSERT_HEAD(&sc->free_ecb, ecb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ecb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_ecb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: ahb_scsi_cmd, more than %d dma segs\\n\"",
            "sc->sc_dev.dv_xname",
            "AHB_NSEG"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"\\n\")"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"(0x%x)\", bytes_this_seg)"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "thiskv"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes_this_page",
            "datalen"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "ahbminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "924-932",
          "snippet": "void\nahbminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((AHB_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((AHB_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tAHB_NSEG\t33\t/* number of dma segments supported */"
          ],
          "globals_used": [
            "void ahbminphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAHB_NSEG\t33\t/* number of dma segments supported */\n\nvoid ahbminphys;\n\nvoid\nahbminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((AHB_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((AHB_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"0x%x\", thisphys)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "thiskv"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"%d @0x%x:- \", xs->datalen, xs->data)"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUGN",
          "args": [
            "sc_link",
            "SDEV_DB4",
            "(\"(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base)"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "ecb->ahb_dma"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "&ecb->ecb_status"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "&ecb->ecb_sense"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahb_send_immed",
          "args": [
            "sc",
            "sc_link->target",
            "AHB_TARG_RESET"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_send_immed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "391-416",
          "snippet": "void\nahb_send_immed(sc, target, cmd)\n\tstruct ahb_softc *sc;\n\tint target;\n\tu_long cmd;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint wait = 100;\t/* 1 ms enough? */\n\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) &\n\t\t    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif (!wait) {\n\t\tprintf(\"%s: board not responding\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\t/* don't know this will work */\n\tbus_space_write_4(iot, ioh, MBOXOUT0, cmd);\n\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_SET_HOST_READY);\n\tbus_space_write_1(iot, ioh, ATTN, OP_IMMED | target);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tG2STAT_MBOX_EMPTY\t0x04",
            "#define\tG2STAT_BUSY\t\t0x01",
            "#define\tG2CNTRL_SET_HOST_READY\t0x20",
            "#define  OP_IMMED\t\t0x10",
            "#define G2STAT\t\t0xCD7",
            "#define\tG2CNTRL\t\t0xCD5",
            "#define\tATTN\t\t0xCD4",
            "#define MBOXOUT0\t0xCD0"
          ],
          "globals_used": [
            "void ahb_send_immed",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tG2STAT_MBOX_EMPTY\t0x04\n#define\tG2STAT_BUSY\t\t0x01\n#define\tG2CNTRL_SET_HOST_READY\t0x20\n#define  OP_IMMED\t\t0x10\n#define G2STAT\t\t0xCD7\n#define\tG2CNTRL\t\t0xCD5\n#define\tATTN\t\t0xCD4\n#define MBOXOUT0\t0xCD0\n\nvoid ahb_send_immed;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_send_immed(sc, target, cmd)\n\tstruct ahb_softc *sc;\n\tint target;\n\tu_long cmd;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint wait = 100;\t/* 1 ms enough? */\n\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) &\n\t\t    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif (!wait) {\n\t\tprintf(\"%s: board not responding\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\t/* don't know this will work */\n\tbus_space_write_4(iot, ioh, MBOXOUT0, cmd);\n\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_SET_HOST_READY);\n\tbus_space_write_1(iot, ioh, ATTN, OP_IMMED | target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahb_get_ecb",
          "args": [
            "sc",
            "flags"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "sc_link",
            "SDEV_DB2",
            "(\"ahb_scsi_cmd\\n\")"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_IMMED\t4\n#define\tECB_NRB\t0x8000\n#define\tECB_ARS\t0x8000\n#define\tECB_DSB\t0x4000\n#define\tECB_S_G\t0x1000\n#define\tECB_SES\t0x0400\n#define\tECB_SCSI_OP\t0x01\n#define  OP_START_ECB\t\t0x40\n#define\t  AHB_TARG_RESET\t0x80\n#define\tAHB_NSEG\t33\t/* number of dma segments supported */\n\nvoid ahb_send_mbox;\nint ahb_poll;\nvoid ahb_send_immed;\nvoid ahb_free_ecb;\nstruct ahb_ecb *ahb_get_ecb;\nint ahb_scsi_cmd;\nvoid ahb_timeout;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nint\nahb_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ahb_softc *sc = sc_link->adapter_softc;\n\tstruct ahb_ecb *ecb;\n\tstruct ahb_dma_seg *sg;\n\tint seg;\t\t/* scatter gather seg being worked on */\n\tu_long thiskv, thisphys, nextphys;\n\tint bytes_this_seg, bytes_this_page, datalen, flags;\n#ifdef TFS\n\tstruct iovec *iovp;\n#endif\n\tint s;\n\n\tSC_DEBUG(sc_link, SDEV_DB2, (\"ahb_scsi_cmd\\n\"));\n\t/*\n\t * get a ecb (mbox-out) to use. If the transfer\n\t * is from a buf (possibly from interrupt time)\n\t * then we can't allow it to sleep\n\t */\n\tflags = xs->flags;\n\tif ((flags & (ITSDONE|INUSE)) != INUSE) {\n\t\tprintf(\"%s: done or not in use?\\n\", sc->sc_dev.dv_xname);\n\t\txs->flags &= ~ITSDONE;\n\t\txs->flags |= INUSE;\n\t}\n\tif ((ecb = ahb_get_ecb(sc, flags)) == NULL) {\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\treturn TRY_AGAIN_LATER;\n\t}\n\tecb->xs = xs;\n\n\t/*\n\t * If it's a reset, we need to do an 'immediate'\n\t * command, and store its ecb for later\n\t * if there is already an immediate waiting,\n\t * then WE must wait\n\t */\n\tif (flags & SCSI_RESET) {\n\t\tecb->flags |= ECB_IMMED;\n\t\tif (sc->immed_ecb)\n\t\t\treturn TRY_AGAIN_LATER;\n\t\tsc->immed_ecb = ecb;\n\n\t\ts = splbio();\n\n\t\tahb_send_immed(sc, sc_link->target, AHB_TARG_RESET);\n\n\t\tif ((flags & SCSI_POLL) == 0) {\n\t\t\ttimeout(ahb_timeout, ecb, (xs->timeout * hz) / 1000);\n\t\t\tsplx(s);\n\t\t\treturn SUCCESSFULLY_QUEUED;\n\t\t}\n\n\t\tsplx(s);\n\n\t\t/*\n\t\t * If we can't use interrupts, poll on completion\n\t\t */\n\t\tif (ahb_poll(sc, xs, xs->timeout))\n\t\t\tahb_timeout(ecb);\n\t\treturn COMPLETE;\n\t}\n\n\t/*\n\t * Put all the arguments for the xfer in the ecb\n\t */\n\tecb->opcode = ECB_SCSI_OP;\n\tecb->opt1 = ECB_SES | ECB_DSB | ECB_ARS;\n\tif (xs->datalen)\n\t\tecb->opt1 |= ECB_S_G;\n\tecb->opt2 = sc_link->lun | ECB_NRB;\n\tecb->scsi_cmd_length = xs->cmdlen;\n\tecb->sense_ptr = KVTOPHYS(&ecb->ecb_sense);\n\tecb->req_sense_length = sizeof(ecb->ecb_sense);\n\tecb->status = KVTOPHYS(&ecb->ecb_status);\n\tecb->ecb_status.host_stat = 0x00;\n\tecb->ecb_status.target_stat = 0x00;\n\n\tif (xs->datalen && (flags & SCSI_RESET) == 0) {\n\t\tecb->data_addr = KVTOPHYS(ecb->ahb_dma);\n\t\tsg = ecb->ahb_dma;\n\t\tseg = 0;\n#ifdef\tTFS\n\t\tif (flags & SCSI_DATA_UIO) {\n\t\t\tiovp = ((struct uio *) xs->data)->uio_iov;\n\t\t\tdatalen = ((struct uio *) xs->data)->uio_iovcnt;\n\t\t\txs->datalen = 0;\n\t\t\twhile (datalen && seg < AHB_NSEG) {\n\t\t\t\tsg->seg_addr = (physaddr)iovp->iov_base;\n\t\t\t\tsg->seg_len = iovp->iov_len;\n\t\t\t\txs->datalen += iovp->iov_len;\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"(0x%x@0x%x)\",\n\t\t\t\t    iovp->iov_len, iovp->iov_base));\n\t\t\t\tsg++;\n\t\t\t\tiovp++;\n\t\t\t\tseg++;\n\t\t\t\tdatalen--;\n\t\t\t}\n\t\t}\n\t\telse\n#endif /*TFS */\n\t\t{\n\t\t\t/*\n\t\t\t * Set up the scatter gather block\n\t\t\t */\n\t\t\tSC_DEBUG(sc_link, SDEV_DB4,\n\t\t\t    (\"%d @0x%x:- \", xs->datalen, xs->data));\n\t\t\tdatalen = xs->datalen;\n\t\t\tthiskv = (long) xs->data;\n\t\t\tthisphys = KVTOPHYS(thiskv);\n\n\t\t\twhile (datalen && seg < AHB_NSEG) {\n\t\t\t\tbytes_this_seg = 0;\n\n\t\t\t\t/* put in the base address */\n\t\t\t\tsg->seg_addr = thisphys;\n\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"0x%x\", thisphys));\n\n\t\t\t\t/* do it at least once */\n\t\t\t\tnextphys = thisphys;\n\t\t\t\twhile (datalen && thisphys == nextphys) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This page is contiguous (physically)\n\t\t\t\t\t * with the the last, just extend the\n\t\t\t\t\t * length\n\t\t\t\t\t */\n\t\t\t\t\t/* how far to the end of the page */\n\t\t\t\t\tnextphys = (thisphys & ~PGOFSET) + NBPG;\n\t\t\t\t\tbytes_this_page = nextphys - thisphys;\n\t\t\t\t\t/**** or the data ****/\n\t\t\t\t\tbytes_this_page = min(bytes_this_page,\n\t\t\t\t\t\t\t      datalen);\n\t\t\t\t\tbytes_this_seg += bytes_this_page;\n\t\t\t\t\tdatalen -= bytes_this_page;\n\n\t\t\t\t\t/* get more ready for the next page */\n\t\t\t\t\tthiskv = (thiskv & ~PGOFSET) + NBPG;\n\t\t\t\t\tif (datalen)\n\t\t\t\t\t\tthisphys = KVTOPHYS(thiskv);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * next page isn't contiguous, finish the seg\n\t\t\t\t */\n\t\t\t\tSC_DEBUGN(sc_link, SDEV_DB4,\n\t\t\t\t    (\"(0x%x)\", bytes_this_seg));\n\t\t\t\tsg->seg_len = bytes_this_seg;\n\t\t\t\tsg++;\n\t\t\t\tseg++;\n\t\t\t}\n\t\t}\n\t\t/*end of iov/kv decision */\n\t\tecb->data_length = seg * sizeof(struct ahb_dma_seg);\n\t\tSC_DEBUGN(sc_link, SDEV_DB4, (\"\\n\"));\n\t\tif (datalen) {\n\t\t\t/*\n\t\t\t * there's still data, must have run out of segs!\n\t\t\t */\n\t\t\tprintf(\"%s: ahb_scsi_cmd, more than %d dma segs\\n\",\n\t\t\t    sc->sc_dev.dv_xname, AHB_NSEG);\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tahb_free_ecb(sc, ecb, flags);\n\t\t\treturn COMPLETE;\n\t\t}\n\t} else {\t/* No data xfer, use non S/G values */\n\t\tecb->data_addr = (physaddr)0;\n\t\tecb->data_length = 0;\n\t}\n\tecb->link_addr = (physaddr)0;\n\n\t/*\n\t * Put the scsi command in the ecb and start it\n\t */\n\tif ((flags & SCSI_RESET) == 0)\n\t\tbcopy(xs->cmd, &ecb->scsi_cmd, ecb->scsi_cmd_length);\n\n\ts = splbio();\n\n\tahb_send_mbox(sc, OP_START_ECB, ecb);\n\n\t/*\n\t * Usually return SUCCESSFULLY QUEUED\n\t */\n\tif ((flags & SCSI_POLL) == 0) {\n\t\ttimeout(ahb_timeout, ecb, (xs->timeout * hz) / 1000);\n\t\tsplx(s);\n\t\treturn SUCCESSFULLY_QUEUED;\n\t}\n\n\tsplx(s);\n\n\t/*\n\t * If we can't use interrupts, poll on completion\n\t */\n\tif (ahb_poll(sc, xs, xs->timeout)) {\n\t\tahb_timeout(ecb);\n\t\tif (ahb_poll(sc, xs, 2000))\n\t\t\tahb_timeout(ecb);\n\t}\n\treturn COMPLETE;\n}"
  },
  {
    "function_name": "ahbminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "924-932",
    "snippet": "void\nahbminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((AHB_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((AHB_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tAHB_NSEG\t33\t/* number of dma segments supported */"
    ],
    "globals_used": [
      "void ahbminphys"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "minphys",
          "args": [
            "bp"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "ahbminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "924-932",
          "snippet": "void\nahbminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((AHB_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((AHB_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tAHB_NSEG\t33\t/* number of dma segments supported */\n\nvoid ahbminphys;\n\nvoid\nahbminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((AHB_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((AHB_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
  },
  {
    "function_name": "ahb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "917-922",
    "snippet": "void\nahb_init(sc)\n\tstruct ahb_softc *sc;\n{\n\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ahb_init",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid ahb_init;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_init(sc)\n\tstruct ahb_softc *sc;\n{\n\n}"
  },
  {
    "function_name": "ahb_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "824-915",
    "snippet": "int\nahb_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct ahb_softc *sc;\n{\n\tu_char intdef;\n\tint i, irq, busid;\n\tint wait = 1000;\t/* 1 sec enough? */\n\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n\n#define\tNO_NO 1\n#ifdef NO_NO\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_HARD_RESET);\n\tdelay(1000);\n\tbus_space_write_1(iot, ioh, G2CNTRL, 0);\n\tdelay(10000);\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_BUSY) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!wait) {\n#ifdef AHBDEBUG\n\t\tif (ahb_debug & AHB_SHOWMISC)\n\t\t\tprintf(\"ahb_find: No answer from aha1742 board\\n\");\n#endif /*AHBDEBUG */\n\t\treturn ENXIO;\n\t}\n\ti = bus_space_read_1(iot, ioh, MBOXIN0);\n\tif (i) {\n\t\tprintf(\"self test failed, val = 0x%x\\n\", i);\n\t\treturn EIO;\n\t}\n\n\t/* Set it again, just to be sure. */\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n#endif\n\n\twhile (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) {\n\t\tprintf(\".\");\n\t\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);\n\t\tdelay(10000);\n\t}\n\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (intdef & 0x07) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"illegal int setting %x\\n\", intdef);\n\t\treturn EIO;\n\t}\n\n\t/* make sure we can interrupt */\n\tbus_space_write_1(iot, ioh, INTDEF, (intdef | INTEN));\n\n\t/* who are we on the scsi bus? */\n\tbusid = (bus_space_read_1(iot, ioh, SCSIDEF) & HSCSIID);\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->ahb_scsi_dev = busid;\n\t}\n\n\t/*\n\t * Note that we are going and return (to probe)\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tNO_NO 1",
      "#define AHB_SHOWMISC 0x08",
      "#define\tG2STAT_INT_PEND\t\t0x02",
      "#define\tG2STAT_BUSY\t\t0x01",
      "#define\tG2CNTRL_HARD_RESET\t0x80",
      "#define\tG2CNTRL_CLEAR_EISA_INT\t0x40",
      "#define\tMBOXIN0\t\t0xCD8",
      "#define G2STAT\t\t0xCD7",
      "#define\tG2CNTRL\t\t0xCD5",
      "#define\tHSCSIID\t0x0F\t\t/* our SCSI ID */",
      "#define\tINTEN\t0x10",
      "#define\tINT15\t0x06",
      "#define\tINT14\t0x05",
      "#define\tINT12\t0x03",
      "#define\tINT11\t0x02",
      "#define\tINT10\t0x01",
      "#define\tINT9\t0x00",
      "#define\tSCSIDEF\t\t0xCC3",
      "#define\tINTDEF\t\t0xCC2",
      "#define\t PORTADDR_ENHANCED\t0x80",
      "#define PORTADDR\t0xCC0"
    ],
    "globals_used": [
      "int ahb_find",
      "int     ahb_debug = 0;",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "SCSIDEF"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "INTDEF",
            "(intdef | INTEN)"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"illegal int setting %x\\n\"",
            "intdef"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "INTDEF"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10000"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "G2CNTRL",
            "G2CNTRL_CLEAR_EISA_INT"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "G2STAT"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "PORTADDR",
            "PORTADDR_ENHANCED"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "MBOXIN0"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "G2STAT"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "G2CNTRL",
            "0"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "G2CNTRL",
            "G2CNTRL_HARD_RESET"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "PORTADDR",
            "PORTADDR_ENHANCED"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNO_NO 1\n#define AHB_SHOWMISC 0x08\n#define\tG2STAT_INT_PEND\t\t0x02\n#define\tG2STAT_BUSY\t\t0x01\n#define\tG2CNTRL_HARD_RESET\t0x80\n#define\tG2CNTRL_CLEAR_EISA_INT\t0x40\n#define\tMBOXIN0\t\t0xCD8\n#define G2STAT\t\t0xCD7\n#define\tG2CNTRL\t\t0xCD5\n#define\tHSCSIID\t0x0F\t\t/* our SCSI ID */\n#define\tINTEN\t0x10\n#define\tINT15\t0x06\n#define\tINT14\t0x05\n#define\tINT12\t0x03\n#define\tINT11\t0x02\n#define\tINT10\t0x01\n#define\tINT9\t0x00\n#define\tSCSIDEF\t\t0xCC3\n#define\tINTDEF\t\t0xCC2\n#define\t PORTADDR_ENHANCED\t0x80\n#define PORTADDR\t0xCC0\n\nint ahb_find;\nint     ahb_debug = 0;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nint\nahb_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct ahb_softc *sc;\n{\n\tu_char intdef;\n\tint i, irq, busid;\n\tint wait = 1000;\t/* 1 sec enough? */\n\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n\n#define\tNO_NO 1\n#ifdef NO_NO\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_HARD_RESET);\n\tdelay(1000);\n\tbus_space_write_1(iot, ioh, G2CNTRL, 0);\n\tdelay(10000);\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_BUSY) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!wait) {\n#ifdef AHBDEBUG\n\t\tif (ahb_debug & AHB_SHOWMISC)\n\t\t\tprintf(\"ahb_find: No answer from aha1742 board\\n\");\n#endif /*AHBDEBUG */\n\t\treturn ENXIO;\n\t}\n\ti = bus_space_read_1(iot, ioh, MBOXIN0);\n\tif (i) {\n\t\tprintf(\"self test failed, val = 0x%x\\n\", i);\n\t\treturn EIO;\n\t}\n\n\t/* Set it again, just to be sure. */\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n#endif\n\n\twhile (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) {\n\t\tprintf(\".\");\n\t\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);\n\t\tdelay(10000);\n\t}\n\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (intdef & 0x07) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"illegal int setting %x\\n\", intdef);\n\t\treturn EIO;\n\t}\n\n\t/* make sure we can interrupt */\n\tbus_space_write_1(iot, ioh, INTDEF, (intdef | INTEN));\n\n\t/* who are we on the scsi bus? */\n\tbusid = (bus_space_read_1(iot, ioh, SCSIDEF) & HSCSIID);\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->ahb_scsi_dev = busid;\n\t}\n\n\t/*\n\t * Note that we are going and return (to probe)\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "ahb_reset_ecb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "742-748",
    "snippet": "static inline void\nahb_reset_ecb(sc, ecb)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n{\n\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ahb_reset_ecb",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline void ahb_reset_ecb;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nstatic inline void\nahb_reset_ecb(sc, ecb)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n{\n\n}"
  },
  {
    "function_name": "ahb_init_ecb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "722-738",
    "snippet": "static inline void\nahb_init_ecb(sc, ecb)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n{\n\tint hashnum;\n\n\tbzero(ecb, sizeof(struct ahb_ecb));\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tecb->hashkey = KVTOPHYS(ecb);\n\thashnum = ECB_HASH(ecb->hashkey);\n\tecb->nexthash = sc->ecbhash[hashnum];\n\tsc->ecbhash[hashnum] = ecb;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void ahb_init_ecb",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ECB_HASH",
          "args": [
            "ecb->hashkey"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "ecb"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ecb",
            "sizeof(struct ahb_ecb)"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline void ahb_init_ecb;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nstatic inline void\nahb_init_ecb(sc, ecb)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n{\n\tint hashnum;\n\n\tbzero(ecb, sizeof(struct ahb_ecb));\n\t/*\n\t * put in the phystokv hash table\n\t * Never gets taken out.\n\t */\n\tecb->hashkey = KVTOPHYS(ecb);\n\thashnum = ECB_HASH(ecb->hashkey);\n\tecb->nexthash = sc->ecbhash[hashnum];\n\tsc->ecbhash[hashnum] = ecb;\n}"
  },
  {
    "function_name": "ahb_free_ecb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "697-718",
    "snippet": "void\nahb_free_ecb(sc, ecb, flags)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tecb->flags = ECB_FREE;\n\tTAILQ_INSERT_HEAD(&sc->free_ecb, ecb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ecb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_ecb);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ECB_FREE\t0"
    ],
    "globals_used": [
      "void ahb_free_ecb",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "int flags;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->free_ecb"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->free_ecb",
            "ecb",
            "chain"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_FREE\t0\n\nvoid ahb_free_ecb;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_free_ecb(sc, ecb, flags)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tecb->flags = ECB_FREE;\n\tTAILQ_INSERT_HEAD(&sc->free_ecb, ecb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ecb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_ecb);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "ahb_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "626-691",
    "snippet": "void\nahb_done(sc, ecb)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n{\n\tstruct ahb_ecb_status *stat = &ecb->ecb_status;\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ecb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahb_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((xs->flags & INUSE) == 0) {\n\t\tprintf(\"%s: exiting but not in use!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\tif (ecb->flags & ECB_IMMED) {\n\t\tif (ecb->flags & ECB_IMMED_FAIL)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (stat->host_stat != HS_OK) {\n\t\t\tswitch (stat->host_stat) {\n\t\t\tcase HS_SCSI_RESET_ADAPTER:\n\t\t\t\tbreak;\n\t\t\tcase HS_SCSI_RESET_INCOMING:\n\t\t\t\tbreak;\n\t\t\tcase HS_CMD_ABORTED_HOST:\n\t\t\tcase HS_CMD_ABORTED_ADAPTER:\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\tcase HS_TIMED_OUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (stat->target_stat != SCSI_OK) {\n\t\t\tswitch (stat->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ecb->ecb_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\ndone:\n\txs->flags |= ITSDONE;\n\tahb_free_ecb(sc, ecb, xs->flags);\n\tscsi_done(xs);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ECB_IMMED_FAIL\t8",
      "#define ECB_IMMED\t4",
      "#define\tHS_SCSI_RESET_INCOMING\t0x23",
      "#define\tHS_SCSI_RESET_ADAPTER\t0x22",
      "#define\tHS_TIMED_OUT\t\t0x11",
      "#define\tHS_CMD_ABORTED_ADAPTER\t0x05",
      "#define\tHS_CMD_ABORTED_HOST\t0x04",
      "#define\tHS_OK\t\t\t0x00"
    ],
    "globals_used": [
      "void ahb_done",
      "void ahb_free_ecb",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "int flags;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahb_free_ecb",
          "args": [
            "sc",
            "ecb",
            "xs->flags"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_free_ecb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "697-718",
          "snippet": "void\nahb_free_ecb(sc, ecb, flags)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tecb->flags = ECB_FREE;\n\tTAILQ_INSERT_HEAD(&sc->free_ecb, ecb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ecb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_ecb);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ECB_FREE\t0"
          ],
          "globals_used": [
            "void ahb_free_ecb",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "int flags;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_FREE\t0\n\nvoid ahb_free_ecb;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_free_ecb(sc, ecb, flags)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tecb->flags = ECB_FREE;\n\tTAILQ_INSERT_HEAD(&sc->free_ecb, ecb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ecb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_ecb);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: target_stat %x\\n\"",
            "sc->sc_dev.dv_xname",
            "stat->target_stat"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SC_DEBUG",
          "args": [
            "xs->sc_link",
            "SDEV_DB2",
            "(\"ahb_done\\n\")"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_IMMED_FAIL\t8\n#define ECB_IMMED\t4\n#define\tHS_SCSI_RESET_INCOMING\t0x23\n#define\tHS_SCSI_RESET_ADAPTER\t0x22\n#define\tHS_TIMED_OUT\t\t0x11\n#define\tHS_CMD_ABORTED_ADAPTER\t0x05\n#define\tHS_CMD_ABORTED_HOST\t0x04\n#define\tHS_OK\t\t\t0x00\n\nvoid ahb_done;\nvoid ahb_free_ecb;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_done(sc, ecb)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n{\n\tstruct ahb_ecb_status *stat = &ecb->ecb_status;\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ecb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahb_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((xs->flags & INUSE) == 0) {\n\t\tprintf(\"%s: exiting but not in use!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\tif (ecb->flags & ECB_IMMED) {\n\t\tif (ecb->flags & ECB_IMMED_FAIL)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (stat->host_stat != HS_OK) {\n\t\t\tswitch (stat->host_stat) {\n\t\t\tcase HS_SCSI_RESET_ADAPTER:\n\t\t\t\tbreak;\n\t\t\tcase HS_SCSI_RESET_INCOMING:\n\t\t\t\tbreak;\n\t\t\tcase HS_CMD_ABORTED_HOST:\n\t\t\tcase HS_CMD_ABORTED_ADAPTER:\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\tcase HS_TIMED_OUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (stat->target_stat != SCSI_OK) {\n\t\t\tswitch (stat->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ecb->ecb_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\ndone:\n\txs->flags |= ITSDONE;\n\tahb_free_ecb(sc, ecb, xs->flags);\n\tscsi_done(xs);\n}"
  },
  {
    "function_name": "ahbintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "546-620",
    "snippet": "int\nahbintr(arg)\n\tvoid *arg;\n{\n\tstruct ahb_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ahb_ecb *ecb;\n\tu_char ahbstat;\n\tu_long mboxval;\n\n#ifdef\tAHBDEBUG\n\tprintf(\"%s: ahbintr \", sc->sc_dev.dv_xname);\n#endif /* AHBDEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) == 0)\n\t\treturn 0;\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowlege the interrupt\n\t\t */\n\t\tahbstat = bus_space_read_1(iot, ioh, G2INTST);\n\t\tmboxval = bus_space_read_4(iot, ioh, MBOXIN0);\n\t\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);\n\n#ifdef\tAHBDEBUG\n\t\tprintf(\"status = 0x%x \", ahbstat);\n#endif /*AHBDEBUG */\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tswitch (ahbstat & G2INTST_INT_STAT) {\n\t\tcase AHB_ECB_OK:\n\t\tcase AHB_ECB_RECOVERED:\n\t\tcase AHB_ECB_ERR:\n\t\t\tecb = ahb_ecb_phys_kv(sc, mboxval);\n\t\t\tif (!ecb) {\n\t\t\t\tprintf(\"%s: BAD ECB RETURNED!\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AHB_IMMED_ERR:\n\t\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tcase AHB_IMMED_OK:\n\t\t\tecb = sc->immed_ecb;\n\t\t\tsc->immed_ecb = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: unexpected interrupt %x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ahbstat);\n\t\t\tecb = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ecb) {\n#ifdef\tAHBDEBUG\n\t\t\tif (ahb_debug & AHB_SHOWCMDS)\n\t\t\t\tshow_scsi_cmd(ecb->xs);\n\t\t\tif ((ahb_debug & AHB_SHOWECBS) && ecb)\n\t\t\t\tprintf(\"<int ecb(%x)>\", ecb);\n#endif /*AHBDEBUG */\n\t\t\tuntimeout(ahb_timeout, ecb);\n\t\t\tahb_done(sc, ecb);\n\t\t}\n\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) ==\n\t\t    0)\n\t\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define AHB_SHOWCMDS 0x04",
      "#define AHB_SHOWECBS 0x01",
      "#define ECB_IMMED_FAIL\t8",
      "#define\tG2STAT_INT_PEND\t\t0x02",
      "#define\t AHB_IMMED_ERR\t\t0xE0",
      "#define\t AHB_ECB_ERR\t\t0xC0",
      "#define\t AHB_IMMED_OK\t\t0xA0",
      "#define\t AHB_ECB_RECOVERED\t0x50",
      "#define\t AHB_ECB_OK\t\t0x10",
      "#define\tG2INTST_INT_STAT\t0xF0",
      "#define\tG2CNTRL_CLEAR_EISA_INT\t0x40",
      "#define\tMBOXIN0\t\t0xCD8",
      "#define G2STAT\t\t0xCD7",
      "#define\tG2INTST\t\t0xCD6",
      "#define\tG2CNTRL\t\t0xCD5"
    ],
    "globals_used": [
      "int ahbintr",
      "void ahb_done",
      "struct ahb_ecb *ahb_ecb_phys_kv",
      "void ahb_timeout",
      "int     ahb_debug = 0;",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "int flags;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "G2STAT"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahb_done",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "626-691",
          "snippet": "void\nahb_done(sc, ecb)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n{\n\tstruct ahb_ecb_status *stat = &ecb->ecb_status;\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ecb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahb_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((xs->flags & INUSE) == 0) {\n\t\tprintf(\"%s: exiting but not in use!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\tif (ecb->flags & ECB_IMMED) {\n\t\tif (ecb->flags & ECB_IMMED_FAIL)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (stat->host_stat != HS_OK) {\n\t\t\tswitch (stat->host_stat) {\n\t\t\tcase HS_SCSI_RESET_ADAPTER:\n\t\t\t\tbreak;\n\t\t\tcase HS_SCSI_RESET_INCOMING:\n\t\t\t\tbreak;\n\t\t\tcase HS_CMD_ABORTED_HOST:\n\t\t\tcase HS_CMD_ABORTED_ADAPTER:\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\tcase HS_TIMED_OUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (stat->target_stat != SCSI_OK) {\n\t\t\tswitch (stat->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ecb->ecb_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\ndone:\n\txs->flags |= ITSDONE;\n\tahb_free_ecb(sc, ecb, xs->flags);\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ECB_IMMED_FAIL\t8",
            "#define ECB_IMMED\t4",
            "#define\tHS_SCSI_RESET_INCOMING\t0x23",
            "#define\tHS_SCSI_RESET_ADAPTER\t0x22",
            "#define\tHS_TIMED_OUT\t\t0x11",
            "#define\tHS_CMD_ABORTED_ADAPTER\t0x05",
            "#define\tHS_CMD_ABORTED_HOST\t0x04",
            "#define\tHS_OK\t\t\t0x00"
          ],
          "globals_used": [
            "void ahb_done",
            "void ahb_free_ecb",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "int flags;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ECB_IMMED_FAIL\t8\n#define ECB_IMMED\t4\n#define\tHS_SCSI_RESET_INCOMING\t0x23\n#define\tHS_SCSI_RESET_ADAPTER\t0x22\n#define\tHS_TIMED_OUT\t\t0x11\n#define\tHS_CMD_ABORTED_ADAPTER\t0x05\n#define\tHS_CMD_ABORTED_HOST\t0x04\n#define\tHS_OK\t\t\t0x00\n\nvoid ahb_done;\nvoid ahb_free_ecb;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_done(sc, ecb)\n\tstruct ahb_softc *sc;\n\tstruct ahb_ecb *ecb;\n{\n\tstruct ahb_ecb_status *stat = &ecb->ecb_status;\n\tstruct scsi_sense_data *s1, *s2;\n\tstruct scsi_xfer *xs = ecb->xs;\n\n\tSC_DEBUG(xs->sc_link, SDEV_DB2, (\"ahb_done\\n\"));\n\t/*\n\t * Otherwise, put the results of the operation\n\t * into the xfer and call whoever started it\n\t */\n\tif ((xs->flags & INUSE) == 0) {\n\t\tprintf(\"%s: exiting but not in use!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\tif (ecb->flags & ECB_IMMED) {\n\t\tif (ecb->flags & ECB_IMMED_FAIL)\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tgoto done;\n\t}\n\tif (xs->error == XS_NOERROR) {\n\t\tif (stat->host_stat != HS_OK) {\n\t\t\tswitch (stat->host_stat) {\n\t\t\tcase HS_SCSI_RESET_ADAPTER:\n\t\t\t\tbreak;\n\t\t\tcase HS_SCSI_RESET_INCOMING:\n\t\t\t\tbreak;\n\t\t\tcase HS_CMD_ABORTED_HOST:\n\t\t\tcase HS_CMD_ABORTED_ADAPTER:\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t\tbreak;\n\t\t\tcase HS_TIMED_OUT:\t/* No response */\n\t\t\t\txs->error = XS_SELTIMEOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\t/* Other scsi protocol messes */\n\t\t\t\tprintf(\"%s: host_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->host_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else if (stat->target_stat != SCSI_OK) {\n\t\t\tswitch (stat->target_stat) {\n\t\t\tcase SCSI_CHECK:\n\t\t\t\ts1 = &ecb->ecb_sense;\n\t\t\t\ts2 = &xs->sense;\n\t\t\t\t*s2 = *s1;\n\t\t\t\txs->error = XS_SENSE;\n\t\t\t\tbreak;\n\t\t\tcase SCSI_BUSY:\n\t\t\t\txs->error = XS_BUSY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: target_stat %x\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, stat->target_stat);\n\t\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\t}\n\t\t} else\n\t\t\txs->resid = 0;\n\t}\ndone:\n\txs->flags |= ITSDONE;\n\tahb_free_ecb(sc, ecb, xs->flags);\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ahb_timeout",
            "ecb"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"<int ecb(%x)>\"",
            "ecb"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_scsi_cmd",
          "args": [
            "ecb->xs"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_show_scsi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380.c",
          "lines": "90-113",
          "snippet": "static int\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t\t   xs->sc_link->scsibus,\n\t\t\t   xs->sc_link->target,\n\t\t\t   xs->sc_link->lun);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahb_ecb_phys_kv",
          "args": [
            "sc",
            "mboxval"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "G2CNTRL",
            "G2CNTRL_CLEAR_EISA_INT"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "iot",
            "ioh",
            "MBOXIN0"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "G2INTST"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "G2STAT"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AHB_SHOWCMDS 0x04\n#define AHB_SHOWECBS 0x01\n#define ECB_IMMED_FAIL\t8\n#define\tG2STAT_INT_PEND\t\t0x02\n#define\t AHB_IMMED_ERR\t\t0xE0\n#define\t AHB_ECB_ERR\t\t0xC0\n#define\t AHB_IMMED_OK\t\t0xA0\n#define\t AHB_ECB_RECOVERED\t0x50\n#define\t AHB_ECB_OK\t\t0x10\n#define\tG2INTST_INT_STAT\t0xF0\n#define\tG2CNTRL_CLEAR_EISA_INT\t0x40\n#define\tMBOXIN0\t\t0xCD8\n#define G2STAT\t\t0xCD7\n#define\tG2INTST\t\t0xCD6\n#define\tG2CNTRL\t\t0xCD5\n\nint ahbintr;\nvoid ahb_done;\nstruct ahb_ecb *ahb_ecb_phys_kv;\nvoid ahb_timeout;\nint     ahb_debug = 0;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nint\nahbintr(arg)\n\tvoid *arg;\n{\n\tstruct ahb_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ahb_ecb *ecb;\n\tu_char ahbstat;\n\tu_long mboxval;\n\n#ifdef\tAHBDEBUG\n\tprintf(\"%s: ahbintr \", sc->sc_dev.dv_xname);\n#endif /* AHBDEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) == 0)\n\t\treturn 0;\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowlege the interrupt\n\t\t */\n\t\tahbstat = bus_space_read_1(iot, ioh, G2INTST);\n\t\tmboxval = bus_space_read_4(iot, ioh, MBOXIN0);\n\t\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);\n\n#ifdef\tAHBDEBUG\n\t\tprintf(\"status = 0x%x \", ahbstat);\n#endif /*AHBDEBUG */\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tswitch (ahbstat & G2INTST_INT_STAT) {\n\t\tcase AHB_ECB_OK:\n\t\tcase AHB_ECB_RECOVERED:\n\t\tcase AHB_ECB_ERR:\n\t\t\tecb = ahb_ecb_phys_kv(sc, mboxval);\n\t\t\tif (!ecb) {\n\t\t\t\tprintf(\"%s: BAD ECB RETURNED!\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AHB_IMMED_ERR:\n\t\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tcase AHB_IMMED_OK:\n\t\t\tecb = sc->immed_ecb;\n\t\t\tsc->immed_ecb = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: unexpected interrupt %x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ahbstat);\n\t\t\tecb = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ecb) {\n#ifdef\tAHBDEBUG\n\t\t\tif (ahb_debug & AHB_SHOWCMDS)\n\t\t\t\tshow_scsi_cmd(ecb->xs);\n\t\t\tif ((ahb_debug & AHB_SHOWECBS) && ecb)\n\t\t\t\tprintf(\"<int ecb(%x)>\", ecb);\n#endif /*AHBDEBUG */\n\t\t\tuntimeout(ahb_timeout, ecb);\n\t\t\tahb_done(sc, ecb);\n\t\t}\n\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) ==\n\t\t    0)\n\t\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "ahbattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "471-541",
    "snippet": "void\nahbattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct eisa_attach_args *ea = aux;\n\tstruct ahb_softc *sc = (void *)self;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\teisa_chipset_tag_t ec = ea->ea_ec;\n\teisa_intr_handle_t ih;\n\tconst char *model, *intrstr;\n\n\tsc->sc_iot = iot;\n\tsc->sc_ec = ec;\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE, 0,\n\t    &ioh))\n\t\tpanic(\"ahbattach: could not map I/O addresses\");\n\tsc->sc_ioh = ioh;\n\tif (ahb_find(iot, ioh, sc))\n\t\tpanic(\"ahbattach: ahb_find failed!\");\n\n\tahb_init(sc);\n\tTAILQ_INIT(&sc->free_ecb);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->ahb_scsi_dev;\n\tsc->sc_link.adapter = &ahb_switch;\n\tsc->sc_link.device = &ahb_dev;\n\tsc->sc_link.openings = 2;\n\n\tif (!strcmp(ea->ea_idstring, \"ADP0000\"))\n\t\tmodel = EISA_PRODUCT_ADP0000;\n\telse if (!strcmp(ea->ea_idstring, \"ADP0001\"))\n\t\tmodel = EISA_PRODUCT_ADP0001;\n\telse if (!strcmp(ea->ea_idstring, \"ADP0002\"))\n\t\tmodel = EISA_PRODUCT_ADP0002;\n\telse if (!strcmp(ea->ea_idstring, \"ADP0400\"))\n\t\tmodel = EISA_PRODUCT_ADP0400;\n\telse\n\t\tmodel = \"unknown model!\";\n\tprintf(\": <%s> \", model);\n\n\tif (eisa_intr_map(ec, sc->sc_irq, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_irq);\n\t\treturn;\n\t}\n\tintrstr = eisa_intr_string(ec, ih);\n\tsc->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,\n\t    ahbintr, sc, sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tif (intrstr != NULL)\n\t\tprintf(\"%s\\n\", intrstr);\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tconfig_found(self, &sc->sc_link, ahbprint);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ahbintr",
      "int ahb_find",
      "void ahb_init",
      "int ahbprint",
      "struct scsi_adapter ahb_switch = {\n\tahb_scsi_cmd,\n\tahbminphys,\n\t0,\n\t0,\n};",
      "struct scsi_device ahb_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};",
      "void\tahbattach",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "self",
            "&sc->sc_link",
            "ahbprint"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "intrstr"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eisa_intr_establish",
          "args": [
            "ec",
            "ih",
            "IST_LEVEL",
            "IPL_BIO",
            "ahbintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_string",
          "args": [
            "ec",
            "ih"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eisa_intr_map",
          "args": [
            "ec",
            "sc->sc_irq",
            "&ih"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP0400\""
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP0002\""
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP0001\""
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP0000\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->free_ecb"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahb_init",
          "args": [
            "sc"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "917-922",
          "snippet": "void\nahb_init(sc)\n\tstruct ahb_softc *sc;\n{\n\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void ahb_init",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid ahb_init;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_init(sc)\n\tstruct ahb_softc *sc;\n{\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahbattach: ahb_find failed!\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahb_find",
          "args": [
            "iot",
            "ioh",
            "sc"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "824-915",
          "snippet": "int\nahb_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct ahb_softc *sc;\n{\n\tu_char intdef;\n\tint i, irq, busid;\n\tint wait = 1000;\t/* 1 sec enough? */\n\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n\n#define\tNO_NO 1\n#ifdef NO_NO\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_HARD_RESET);\n\tdelay(1000);\n\tbus_space_write_1(iot, ioh, G2CNTRL, 0);\n\tdelay(10000);\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_BUSY) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!wait) {\n#ifdef AHBDEBUG\n\t\tif (ahb_debug & AHB_SHOWMISC)\n\t\t\tprintf(\"ahb_find: No answer from aha1742 board\\n\");\n#endif /*AHBDEBUG */\n\t\treturn ENXIO;\n\t}\n\ti = bus_space_read_1(iot, ioh, MBOXIN0);\n\tif (i) {\n\t\tprintf(\"self test failed, val = 0x%x\\n\", i);\n\t\treturn EIO;\n\t}\n\n\t/* Set it again, just to be sure. */\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n#endif\n\n\twhile (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) {\n\t\tprintf(\".\");\n\t\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);\n\t\tdelay(10000);\n\t}\n\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (intdef & 0x07) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"illegal int setting %x\\n\", intdef);\n\t\treturn EIO;\n\t}\n\n\t/* make sure we can interrupt */\n\tbus_space_write_1(iot, ioh, INTDEF, (intdef | INTEN));\n\n\t/* who are we on the scsi bus? */\n\tbusid = (bus_space_read_1(iot, ioh, SCSIDEF) & HSCSIID);\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->ahb_scsi_dev = busid;\n\t}\n\n\t/*\n\t * Note that we are going and return (to probe)\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tNO_NO 1",
            "#define AHB_SHOWMISC 0x08",
            "#define\tG2STAT_INT_PEND\t\t0x02",
            "#define\tG2STAT_BUSY\t\t0x01",
            "#define\tG2CNTRL_HARD_RESET\t0x80",
            "#define\tG2CNTRL_CLEAR_EISA_INT\t0x40",
            "#define\tMBOXIN0\t\t0xCD8",
            "#define G2STAT\t\t0xCD7",
            "#define\tG2CNTRL\t\t0xCD5",
            "#define\tHSCSIID\t0x0F\t\t/* our SCSI ID */",
            "#define\tINTEN\t0x10",
            "#define\tINT15\t0x06",
            "#define\tINT14\t0x05",
            "#define\tINT12\t0x03",
            "#define\tINT11\t0x02",
            "#define\tINT10\t0x01",
            "#define\tINT9\t0x00",
            "#define\tSCSIDEF\t\t0xCC3",
            "#define\tINTDEF\t\t0xCC2",
            "#define\t PORTADDR_ENHANCED\t0x80",
            "#define PORTADDR\t0xCC0"
          ],
          "globals_used": [
            "int ahb_find",
            "int     ahb_debug = 0;",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNO_NO 1\n#define AHB_SHOWMISC 0x08\n#define\tG2STAT_INT_PEND\t\t0x02\n#define\tG2STAT_BUSY\t\t0x01\n#define\tG2CNTRL_HARD_RESET\t0x80\n#define\tG2CNTRL_CLEAR_EISA_INT\t0x40\n#define\tMBOXIN0\t\t0xCD8\n#define G2STAT\t\t0xCD7\n#define\tG2CNTRL\t\t0xCD5\n#define\tHSCSIID\t0x0F\t\t/* our SCSI ID */\n#define\tINTEN\t0x10\n#define\tINT15\t0x06\n#define\tINT14\t0x05\n#define\tINT12\t0x03\n#define\tINT11\t0x02\n#define\tINT10\t0x01\n#define\tINT9\t0x00\n#define\tSCSIDEF\t\t0xCC3\n#define\tINTDEF\t\t0xCC2\n#define\t PORTADDR_ENHANCED\t0x80\n#define PORTADDR\t0xCC0\n\nint ahb_find;\nint     ahb_debug = 0;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nint\nahb_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct ahb_softc *sc;\n{\n\tu_char intdef;\n\tint i, irq, busid;\n\tint wait = 1000;\t/* 1 sec enough? */\n\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n\n#define\tNO_NO 1\n#ifdef NO_NO\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_HARD_RESET);\n\tdelay(1000);\n\tbus_space_write_1(iot, ioh, G2CNTRL, 0);\n\tdelay(10000);\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_BUSY) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!wait) {\n#ifdef AHBDEBUG\n\t\tif (ahb_debug & AHB_SHOWMISC)\n\t\t\tprintf(\"ahb_find: No answer from aha1742 board\\n\");\n#endif /*AHBDEBUG */\n\t\treturn ENXIO;\n\t}\n\ti = bus_space_read_1(iot, ioh, MBOXIN0);\n\tif (i) {\n\t\tprintf(\"self test failed, val = 0x%x\\n\", i);\n\t\treturn EIO;\n\t}\n\n\t/* Set it again, just to be sure. */\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n#endif\n\n\twhile (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) {\n\t\tprintf(\".\");\n\t\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);\n\t\tdelay(10000);\n\t}\n\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (intdef & 0x07) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"illegal int setting %x\\n\", intdef);\n\t\treturn EIO;\n\t}\n\n\t/* make sure we can interrupt */\n\tbus_space_write_1(iot, ioh, INTDEF, (intdef | INTEN));\n\n\t/* who are we on the scsi bus? */\n\tbusid = (bus_space_read_1(iot, ioh, SCSIDEF) & HSCSIID);\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->ahb_scsi_dev = busid;\n\t}\n\n\t/*\n\t * Note that we are going and return (to probe)\n\t */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ahbattach: could not map I/O addresses\""
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "EISA_SLOT_ADDR(ea->ea_slot)",
            "EISA_SLOT_SIZE",
            "0",
            "&ioh"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EISA_SLOT_ADDR",
          "args": [
            "ea->ea_slot"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ahbintr;\nint ahb_find;\nvoid ahb_init;\nint ahbprint;\nstruct scsi_adapter ahb_switch = {\n\tahb_scsi_cmd,\n\tahbminphys,\n\t0,\n\t0,\n};\nstruct scsi_device ahb_dev = {\n\tNULL,\t\t\t/* Use default error handler */\n\tNULL,\t\t\t/* have a queue, served by this */\n\tNULL,\t\t\t/* have no async handler */\n\tNULL,\t\t\t/* Use default 'done' routine */\n};\nvoid\tahbattach;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahbattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct eisa_attach_args *ea = aux;\n\tstruct ahb_softc *sc = (void *)self;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\teisa_chipset_tag_t ec = ea->ea_ec;\n\teisa_intr_handle_t ih;\n\tconst char *model, *intrstr;\n\n\tsc->sc_iot = iot;\n\tsc->sc_ec = ec;\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE, 0,\n\t    &ioh))\n\t\tpanic(\"ahbattach: could not map I/O addresses\");\n\tsc->sc_ioh = ioh;\n\tif (ahb_find(iot, ioh, sc))\n\t\tpanic(\"ahbattach: ahb_find failed!\");\n\n\tahb_init(sc);\n\tTAILQ_INIT(&sc->free_ecb);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->ahb_scsi_dev;\n\tsc->sc_link.adapter = &ahb_switch;\n\tsc->sc_link.device = &ahb_dev;\n\tsc->sc_link.openings = 2;\n\n\tif (!strcmp(ea->ea_idstring, \"ADP0000\"))\n\t\tmodel = EISA_PRODUCT_ADP0000;\n\telse if (!strcmp(ea->ea_idstring, \"ADP0001\"))\n\t\tmodel = EISA_PRODUCT_ADP0001;\n\telse if (!strcmp(ea->ea_idstring, \"ADP0002\"))\n\t\tmodel = EISA_PRODUCT_ADP0002;\n\telse if (!strcmp(ea->ea_idstring, \"ADP0400\"))\n\t\tmodel = EISA_PRODUCT_ADP0400;\n\telse\n\t\tmodel = \"unknown model!\";\n\tprintf(\": <%s> \", model);\n\n\tif (eisa_intr_map(ec, sc->sc_irq, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt (%d)\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_irq);\n\t\treturn;\n\t}\n\tintrstr = eisa_intr_string(ec, ih);\n\tsc->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,\n\t    ahbintr, sc, sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tif (intrstr != NULL)\n\t\tprintf(\"%s\\n\", intrstr);\n\n\t/*\n\t * ask the adapter what subunits are present\n\t */\n\tconfig_found(self, &sc->sc_link, ahbprint);\n}"
  },
  {
    "function_name": "ahbprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "460-466",
    "snippet": "int\nahbprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\treturn UNCONF;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ahbprint"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ahbprint;\n\nint\nahbprint(aux, name)\n\tvoid *aux;\n\tconst char *name;\n{\n\treturn UNCONF;\n}"
  },
  {
    "function_name": "ahbmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "423-458",
    "snippet": "int\nahbmatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct eisa_attach_args *ea = aux;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\tint rv;\n\n\t/* must match one of our known ID strings */\n\tif (strcmp(ea->ea_idstring, \"ADP0000\") &&\n\t    strcmp(ea->ea_idstring, \"ADP0001\") &&\n\t    strcmp(ea->ea_idstring, \"ADP0002\") &&\n\t    strcmp(ea->ea_idstring, \"ADP0400\"))\n\t\treturn (0);\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE, 0,\n\t    &ioh))\n\t\treturn (0);\n\n#ifdef notyet\n\t/* This won't compile as-is, anyway. */\n\tbus_space_write_1(iot, ioh, EISA_CONTROL, EISA_ENABLE | EISA_RESET);\n\tdelay(10);\n\tbus_space_write_1(iot, ioh, EISA_CONTROL, EISA_ENABLE);\n\t/* Wait for reset? */\n\tdelay(1000);\n#endif\n\n\trv = !ahb_find(iot, ioh, NULL);\n\n\tbus_space_unmap(ea->ea_iot, ioh, EISA_SLOT_SIZE);\n\n\treturn (rv);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\t EISA_ENABLE\t\t0x01",
      "#define\t EISA_RESET\t\t0x04",
      "#define\tEISA_CONTROL\t\t0x0c84"
    ],
    "globals_used": [
      "int ahb_find",
      "int\tahbmatch"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "ea->ea_iot",
            "ioh",
            "EISA_SLOT_SIZE"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahb_find",
          "args": [
            "iot",
            "ioh",
            "NULL"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ahb_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "824-915",
          "snippet": "int\nahb_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct ahb_softc *sc;\n{\n\tu_char intdef;\n\tint i, irq, busid;\n\tint wait = 1000;\t/* 1 sec enough? */\n\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n\n#define\tNO_NO 1\n#ifdef NO_NO\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_HARD_RESET);\n\tdelay(1000);\n\tbus_space_write_1(iot, ioh, G2CNTRL, 0);\n\tdelay(10000);\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_BUSY) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!wait) {\n#ifdef AHBDEBUG\n\t\tif (ahb_debug & AHB_SHOWMISC)\n\t\t\tprintf(\"ahb_find: No answer from aha1742 board\\n\");\n#endif /*AHBDEBUG */\n\t\treturn ENXIO;\n\t}\n\ti = bus_space_read_1(iot, ioh, MBOXIN0);\n\tif (i) {\n\t\tprintf(\"self test failed, val = 0x%x\\n\", i);\n\t\treturn EIO;\n\t}\n\n\t/* Set it again, just to be sure. */\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n#endif\n\n\twhile (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) {\n\t\tprintf(\".\");\n\t\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);\n\t\tdelay(10000);\n\t}\n\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (intdef & 0x07) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"illegal int setting %x\\n\", intdef);\n\t\treturn EIO;\n\t}\n\n\t/* make sure we can interrupt */\n\tbus_space_write_1(iot, ioh, INTDEF, (intdef | INTEN));\n\n\t/* who are we on the scsi bus? */\n\tbusid = (bus_space_read_1(iot, ioh, SCSIDEF) & HSCSIID);\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->ahb_scsi_dev = busid;\n\t}\n\n\t/*\n\t * Note that we are going and return (to probe)\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tNO_NO 1",
            "#define AHB_SHOWMISC 0x08",
            "#define\tG2STAT_INT_PEND\t\t0x02",
            "#define\tG2STAT_BUSY\t\t0x01",
            "#define\tG2CNTRL_HARD_RESET\t0x80",
            "#define\tG2CNTRL_CLEAR_EISA_INT\t0x40",
            "#define\tMBOXIN0\t\t0xCD8",
            "#define G2STAT\t\t0xCD7",
            "#define\tG2CNTRL\t\t0xCD5",
            "#define\tHSCSIID\t0x0F\t\t/* our SCSI ID */",
            "#define\tINTEN\t0x10",
            "#define\tINT15\t0x06",
            "#define\tINT14\t0x05",
            "#define\tINT12\t0x03",
            "#define\tINT11\t0x02",
            "#define\tINT10\t0x01",
            "#define\tINT9\t0x00",
            "#define\tSCSIDEF\t\t0xCC3",
            "#define\tINTDEF\t\t0xCC2",
            "#define\t PORTADDR_ENHANCED\t0x80",
            "#define PORTADDR\t0xCC0"
          ],
          "globals_used": [
            "int ahb_find",
            "int     ahb_debug = 0;",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNO_NO 1\n#define AHB_SHOWMISC 0x08\n#define\tG2STAT_INT_PEND\t\t0x02\n#define\tG2STAT_BUSY\t\t0x01\n#define\tG2CNTRL_HARD_RESET\t0x80\n#define\tG2CNTRL_CLEAR_EISA_INT\t0x40\n#define\tMBOXIN0\t\t0xCD8\n#define G2STAT\t\t0xCD7\n#define\tG2CNTRL\t\t0xCD5\n#define\tHSCSIID\t0x0F\t\t/* our SCSI ID */\n#define\tINTEN\t0x10\n#define\tINT15\t0x06\n#define\tINT14\t0x05\n#define\tINT12\t0x03\n#define\tINT11\t0x02\n#define\tINT10\t0x01\n#define\tINT9\t0x00\n#define\tSCSIDEF\t\t0xCC3\n#define\tINTDEF\t\t0xCC2\n#define\t PORTADDR_ENHANCED\t0x80\n#define PORTADDR\t0xCC0\n\nint ahb_find;\nint     ahb_debug = 0;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nint\nahb_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct ahb_softc *sc;\n{\n\tu_char intdef;\n\tint i, irq, busid;\n\tint wait = 1000;\t/* 1 sec enough? */\n\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n\n#define\tNO_NO 1\n#ifdef NO_NO\n\t/*\n\t * reset board, If it doesn't respond, assume\n\t * that it's not there.. good for the probe\n\t */\n\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_HARD_RESET);\n\tdelay(1000);\n\tbus_space_write_1(iot, ioh, G2CNTRL, 0);\n\tdelay(10000);\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_BUSY) == 0)\n\t\t\tbreak;\n\t\tdelay(1000);\n\t}\n\tif (!wait) {\n#ifdef AHBDEBUG\n\t\tif (ahb_debug & AHB_SHOWMISC)\n\t\t\tprintf(\"ahb_find: No answer from aha1742 board\\n\");\n#endif /*AHBDEBUG */\n\t\treturn ENXIO;\n\t}\n\ti = bus_space_read_1(iot, ioh, MBOXIN0);\n\tif (i) {\n\t\tprintf(\"self test failed, val = 0x%x\\n\", i);\n\t\treturn EIO;\n\t}\n\n\t/* Set it again, just to be sure. */\n\tbus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);\n#endif\n\n\twhile (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) {\n\t\tprintf(\".\");\n\t\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);\n\t\tdelay(10000);\n\t}\n\n\tintdef = bus_space_read_1(iot, ioh, INTDEF);\n\tswitch (intdef & 0x07) {\n\tcase INT9:\n\t\tirq = 9;\n\t\tbreak;\n\tcase INT10:\n\t\tirq = 10;\n\t\tbreak;\n\tcase INT11:\n\t\tirq = 11;\n\t\tbreak;\n\tcase INT12:\n\t\tirq = 12;\n\t\tbreak;\n\tcase INT14:\n\t\tirq = 14;\n\t\tbreak;\n\tcase INT15:\n\t\tirq = 15;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"illegal int setting %x\\n\", intdef);\n\t\treturn EIO;\n\t}\n\n\t/* make sure we can interrupt */\n\tbus_space_write_1(iot, ioh, INTDEF, (intdef | INTEN));\n\n\t/* who are we on the scsi bus? */\n\tbusid = (bus_space_read_1(iot, ioh, SCSIDEF) & HSCSIID);\n\n\t/* if we want to fill in softc, do so now */\n\tif (sc != NULL) {\n\t\tsc->sc_irq = irq;\n\t\tsc->ahb_scsi_dev = busid;\n\t}\n\n\t/*\n\t * Note that we are going and return (to probe)\n\t */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "EISA_CONTROL",
            "EISA_ENABLE"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "EISA_CONTROL",
            "EISA_ENABLE | EISA_RESET"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "EISA_SLOT_ADDR(ea->ea_slot)",
            "EISA_SLOT_SIZE",
            "0",
            "&ioh"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EISA_SLOT_ADDR",
          "args": [
            "ea->ea_slot"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP0400\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP0002\""
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP0001\""
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ea->ea_idstring",
            "\"ADP0000\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\t EISA_ENABLE\t\t0x01\n#define\t EISA_RESET\t\t0x04\n#define\tEISA_CONTROL\t\t0x0c84\n\nint ahb_find;\nint\tahbmatch;\n\nint\nahbmatch(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct eisa_attach_args *ea = aux;\n\tbus_space_tag_t iot = ea->ea_iot;\n\tbus_space_handle_t ioh;\n\tint rv;\n\n\t/* must match one of our known ID strings */\n\tif (strcmp(ea->ea_idstring, \"ADP0000\") &&\n\t    strcmp(ea->ea_idstring, \"ADP0001\") &&\n\t    strcmp(ea->ea_idstring, \"ADP0002\") &&\n\t    strcmp(ea->ea_idstring, \"ADP0400\"))\n\t\treturn (0);\n\n\tif (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE, 0,\n\t    &ioh))\n\t\treturn (0);\n\n#ifdef notyet\n\t/* This won't compile as-is, anyway. */\n\tbus_space_write_1(iot, ioh, EISA_CONTROL, EISA_ENABLE | EISA_RESET);\n\tdelay(10);\n\tbus_space_write_1(iot, ioh, EISA_CONTROL, EISA_ENABLE);\n\t/* Wait for reset? */\n\tdelay(1000);\n#endif\n\n\trv = !ahb_find(iot, ioh, NULL);\n\n\tbus_space_unmap(ea->ea_iot, ioh, EISA_SLOT_SIZE);\n\n\treturn (rv);\n}"
  },
  {
    "function_name": "ahb_send_immed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "391-416",
    "snippet": "void\nahb_send_immed(sc, target, cmd)\n\tstruct ahb_softc *sc;\n\tint target;\n\tu_long cmd;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint wait = 100;\t/* 1 ms enough? */\n\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) &\n\t\t    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif (!wait) {\n\t\tprintf(\"%s: board not responding\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\t/* don't know this will work */\n\tbus_space_write_4(iot, ioh, MBOXOUT0, cmd);\n\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_SET_HOST_READY);\n\tbus_space_write_1(iot, ioh, ATTN, OP_IMMED | target);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tG2STAT_MBOX_EMPTY\t0x04",
      "#define\tG2STAT_BUSY\t\t0x01",
      "#define\tG2CNTRL_SET_HOST_READY\t0x20",
      "#define  OP_IMMED\t\t0x10",
      "#define G2STAT\t\t0xCD7",
      "#define\tG2CNTRL\t\t0xCD5",
      "#define\tATTN\t\t0xCD4",
      "#define MBOXOUT0\t0xCD0"
    ],
    "globals_used": [
      "void ahb_send_immed",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "ATTN",
            "OP_IMMED | target"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "G2CNTRL",
            "G2CNTRL_SET_HOST_READY"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "iot",
            "ioh",
            "MBOXOUT0",
            "cmd"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: board not responding\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "G2STAT"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tG2STAT_MBOX_EMPTY\t0x04\n#define\tG2STAT_BUSY\t\t0x01\n#define\tG2CNTRL_SET_HOST_READY\t0x20\n#define  OP_IMMED\t\t0x10\n#define G2STAT\t\t0xCD7\n#define\tG2CNTRL\t\t0xCD5\n#define\tATTN\t\t0xCD4\n#define MBOXOUT0\t0xCD0\n\nvoid ahb_send_immed;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_send_immed(sc, target, cmd)\n\tstruct ahb_softc *sc;\n\tint target;\n\tu_long cmd;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint wait = 100;\t/* 1 ms enough? */\n\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) &\n\t\t    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif (!wait) {\n\t\tprintf(\"%s: board not responding\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\t/* don't know this will work */\n\tbus_space_write_4(iot, ioh, MBOXOUT0, cmd);\n\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_SET_HOST_READY);\n\tbus_space_write_1(iot, ioh, ATTN, OP_IMMED | target);\n}"
  },
  {
    "function_name": "ahb_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "364-386",
    "snippet": "int\nahb_poll(sc, xs, count)\n\tstruct ahb_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\t\t\t\t/* in msec  */\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND)\n\t\t\tahbintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tG2STAT_INT_PEND\t\t0x02",
      "#define G2STAT\t\t0xCD7"
    ],
    "globals_used": [
      "int ahb_poll",
      "int ahbintr",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "int flags;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ahbintr",
          "args": [
            "sc"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "ahbintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
          "lines": "546-620",
          "snippet": "int\nahbintr(arg)\n\tvoid *arg;\n{\n\tstruct ahb_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ahb_ecb *ecb;\n\tu_char ahbstat;\n\tu_long mboxval;\n\n#ifdef\tAHBDEBUG\n\tprintf(\"%s: ahbintr \", sc->sc_dev.dv_xname);\n#endif /* AHBDEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) == 0)\n\t\treturn 0;\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowlege the interrupt\n\t\t */\n\t\tahbstat = bus_space_read_1(iot, ioh, G2INTST);\n\t\tmboxval = bus_space_read_4(iot, ioh, MBOXIN0);\n\t\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);\n\n#ifdef\tAHBDEBUG\n\t\tprintf(\"status = 0x%x \", ahbstat);\n#endif /*AHBDEBUG */\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tswitch (ahbstat & G2INTST_INT_STAT) {\n\t\tcase AHB_ECB_OK:\n\t\tcase AHB_ECB_RECOVERED:\n\t\tcase AHB_ECB_ERR:\n\t\t\tecb = ahb_ecb_phys_kv(sc, mboxval);\n\t\t\tif (!ecb) {\n\t\t\t\tprintf(\"%s: BAD ECB RETURNED!\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AHB_IMMED_ERR:\n\t\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tcase AHB_IMMED_OK:\n\t\t\tecb = sc->immed_ecb;\n\t\t\tsc->immed_ecb = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: unexpected interrupt %x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ahbstat);\n\t\t\tecb = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ecb) {\n#ifdef\tAHBDEBUG\n\t\t\tif (ahb_debug & AHB_SHOWCMDS)\n\t\t\t\tshow_scsi_cmd(ecb->xs);\n\t\t\tif ((ahb_debug & AHB_SHOWECBS) && ecb)\n\t\t\t\tprintf(\"<int ecb(%x)>\", ecb);\n#endif /*AHBDEBUG */\n\t\t\tuntimeout(ahb_timeout, ecb);\n\t\t\tahb_done(sc, ecb);\n\t\t}\n\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) ==\n\t\t    0)\n\t\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/eisa/eisadevs.h>",
            "#include <dev/eisa/eisavar.h>",
            "#include <dev/eisa/eisareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define AHB_SHOWCMDS 0x04",
            "#define AHB_SHOWECBS 0x01",
            "#define ECB_IMMED_FAIL\t8",
            "#define\tG2STAT_INT_PEND\t\t0x02",
            "#define\t AHB_IMMED_ERR\t\t0xE0",
            "#define\t AHB_ECB_ERR\t\t0xC0",
            "#define\t AHB_IMMED_OK\t\t0xA0",
            "#define\t AHB_ECB_RECOVERED\t0x50",
            "#define\t AHB_ECB_OK\t\t0x10",
            "#define\tG2INTST_INT_STAT\t0xF0",
            "#define\tG2CNTRL_CLEAR_EISA_INT\t0x40",
            "#define\tMBOXIN0\t\t0xCD8",
            "#define G2STAT\t\t0xCD7",
            "#define\tG2INTST\t\t0xCD6",
            "#define\tG2CNTRL\t\t0xCD5"
          ],
          "globals_used": [
            "int ahbintr",
            "void ahb_done",
            "struct ahb_ecb *ahb_ecb_phys_kv",
            "void ahb_timeout",
            "int     ahb_debug = 0;",
            "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
            "int flags;",
            "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define AHB_SHOWCMDS 0x04\n#define AHB_SHOWECBS 0x01\n#define ECB_IMMED_FAIL\t8\n#define\tG2STAT_INT_PEND\t\t0x02\n#define\t AHB_IMMED_ERR\t\t0xE0\n#define\t AHB_ECB_ERR\t\t0xC0\n#define\t AHB_IMMED_OK\t\t0xA0\n#define\t AHB_ECB_RECOVERED\t0x50\n#define\t AHB_ECB_OK\t\t0x10\n#define\tG2INTST_INT_STAT\t0xF0\n#define\tG2CNTRL_CLEAR_EISA_INT\t0x40\n#define\tMBOXIN0\t\t0xCD8\n#define G2STAT\t\t0xCD7\n#define\tG2INTST\t\t0xCD6\n#define\tG2CNTRL\t\t0xCD5\n\nint ahbintr;\nvoid ahb_done;\nstruct ahb_ecb *ahb_ecb_phys_kv;\nvoid ahb_timeout;\nint     ahb_debug = 0;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nint\nahbintr(arg)\n\tvoid *arg;\n{\n\tstruct ahb_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ahb_ecb *ecb;\n\tu_char ahbstat;\n\tu_long mboxval;\n\n#ifdef\tAHBDEBUG\n\tprintf(\"%s: ahbintr \", sc->sc_dev.dv_xname);\n#endif /* AHBDEBUG */\n\n\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) == 0)\n\t\treturn 0;\n\n\tfor (;;) {\n\t\t/*\n\t\t * First get all the information and then\n\t\t * acknowlege the interrupt\n\t\t */\n\t\tahbstat = bus_space_read_1(iot, ioh, G2INTST);\n\t\tmboxval = bus_space_read_4(iot, ioh, MBOXIN0);\n\t\tbus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);\n\n#ifdef\tAHBDEBUG\n\t\tprintf(\"status = 0x%x \", ahbstat);\n#endif /*AHBDEBUG */\n\n\t\t/*\n\t\t * Process the completed operation\n\t\t */\n\t\tswitch (ahbstat & G2INTST_INT_STAT) {\n\t\tcase AHB_ECB_OK:\n\t\tcase AHB_ECB_RECOVERED:\n\t\tcase AHB_ECB_ERR:\n\t\t\tecb = ahb_ecb_phys_kv(sc, mboxval);\n\t\t\tif (!ecb) {\n\t\t\t\tprintf(\"%s: BAD ECB RETURNED!\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tcontinue;\t/* whatever it was, it'll timeout */\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AHB_IMMED_ERR:\n\t\t\tecb->flags |= ECB_IMMED_FAIL;\n\t\tcase AHB_IMMED_OK:\n\t\t\tecb = sc->immed_ecb;\n\t\t\tsc->immed_ecb = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"%s: unexpected interrupt %x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ahbstat);\n\t\t\tecb = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ecb) {\n#ifdef\tAHBDEBUG\n\t\t\tif (ahb_debug & AHB_SHOWCMDS)\n\t\t\t\tshow_scsi_cmd(ecb->xs);\n\t\t\tif ((ahb_debug & AHB_SHOWECBS) && ecb)\n\t\t\t\tprintf(\"<int ecb(%x)>\", ecb);\n#endif /*AHBDEBUG */\n\t\t\tuntimeout(ahb_timeout, ecb);\n\t\t\tahb_done(sc, ecb);\n\t\t}\n\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) ==\n\t\t    0)\n\t\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "G2STAT"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tG2STAT_INT_PEND\t\t0x02\n#define G2STAT\t\t0xCD7\n\nint ahb_poll;\nint ahbintr;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nint flags;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nint\nahb_poll(sc, xs, count)\n\tstruct ahb_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\t\t\t\t/* in msec  */\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\twhile (count) {\n\t\t/*\n\t\t * If we had interrupts enabled, would we\n\t\t * have got an interrupt?\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND)\n\t\t\tahbintr(sc);\n\t\tif (xs->flags & ITSDONE)\n\t\t\treturn 0;\n\t\tdelay(1000);\n\t\tcount--;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ahb_send_mbox",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/eisa/aha1742.c",
    "lines": "335-359",
    "snippet": "void\nahb_send_mbox(sc, opcode, ecb)\n\tstruct ahb_softc *sc;\n\tint opcode;\n\tstruct ahb_ecb *ecb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint wait = 300;\t/* 1ms should be enough */\n\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) &\n\t\t    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif (!wait) {\n\t\tprintf(\"%s: board not responding\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\t/* don't know this will work */\n\tbus_space_write_4(iot, ioh, MBOXOUT0, KVTOPHYS(ecb));\n\tbus_space_write_1(iot, ioh, ATTN, opcode | ecb->xs->sc_link->target);\n}",
    "includes": [
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <dev/eisa/eisadevs.h>",
      "#include <dev/eisa/eisavar.h>",
      "#include <dev/eisa/eisareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tG2STAT_MBOX_EMPTY\t0x04",
      "#define\tG2STAT_BUSY\t\t0x01",
      "#define G2STAT\t\t0xCD7",
      "#define\tATTN\t\t0xCD4",
      "#define MBOXOUT0\t0xCD0"
    ],
    "globals_used": [
      "void ahb_send_mbox",
      "struct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;",
      "struct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "ATTN",
            "opcode | ecb->xs->sc_link->target"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "iot",
            "ioh",
            "MBOXOUT0",
            "KVTOPHYS(ecb)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVTOPHYS",
          "args": [
            "ecb"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: board not responding\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "G2STAT"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/eisa/eisadevs.h>\n#include <dev/eisa/eisavar.h>\n#include <dev/eisa/eisareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tG2STAT_MBOX_EMPTY\t0x04\n#define\tG2STAT_BUSY\t\t0x01\n#define G2STAT\t\t0xCD7\n#define\tATTN\t\t0xCD4\n#define MBOXOUT0\t0xCD0\n\nvoid ahb_send_mbox;\nstruct ahb_ecb *\nahb_get_ecb(sc, flags)\n\tstruct ahb_softc *sc;\nstruct ahb_ecb *\nahb_ecb_phys_kv(sc, ecb_phys)\n\tstruct ahb_softc *sc;\n\nvoid\nahb_send_mbox(sc, opcode, ecb)\n\tstruct ahb_softc *sc;\n\tint opcode;\n\tstruct ahb_ecb *ecb;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint wait = 300;\t/* 1ms should be enough */\n\n\twhile (--wait) {\n\t\tif ((bus_space_read_1(iot, ioh, G2STAT) &\n\t\t    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\tif (!wait) {\n\t\tprintf(\"%s: board not responding\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n\n\t/* don't know this will work */\n\tbus_space_write_4(iot, ioh, MBOXOUT0, KVTOPHYS(ecb));\n\tbus_space_write_1(iot, ioh, ATTN, opcode | ecb->xs->sc_link->target);\n}"
  }
]