[
  {
    "function_name": "spkrioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
    "lines": "470-513",
    "snippet": "int spkrioctl(dev, cmd, data, flag, p)\n    dev_t dev;\n    u_long cmd;\n    caddr_t data;\n    int\tflag;\n    struct proc *p;\n{\n#ifdef SPKRDEBUG\n    printf(\"spkrioctl: entering with dev = %x, cmd = %lx\\n\", dev, cmd);\n#endif /* SPKRDEBUG */\n\n    if (minor(dev) != 0)\n\treturn(ENXIO);\n    else if (cmd == SPKRTONE)\n    {\n\ttone_t\t*tp = (tone_t *)data;\n\n\tif (tp->frequency == 0)\n\t    rest(tp->duration);\n\telse\n\t    tone(tp->frequency, tp->duration);\n    }\n    else if (cmd == SPKRTUNE)\n    {\n\ttone_t  *tp = (tone_t *)(*(caddr_t *)data);\n\ttone_t ttp;\n\tint error;\n\n\tfor (; ; tp++) {\n\t    error = copyin(tp, &ttp, sizeof(tone_t));\n\t    if (error)\n\t\t    return(error);\n\t    if (ttp.duration == 0)\n\t\t    break;\n\t    if (ttp.frequency == 0)\n\t\trest(ttp.duration);\n\t    else\n\t\ttone(ttp.frequency, ttp.duration);\n\t}\n    }\n    else\n\treturn(EINVAL);\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/spkrio.h>",
      "#include <dev/isa/pcppivar.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tone",
      "static void rest"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tone",
          "args": [
            "ttp.frequency",
            "ttp.duration"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "playtone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
          "lines": "159-190",
          "snippet": "static void\nplaytone(pitch, value, sustain)\n/* play tone of proper duration for current rhythm signature */\n    int\tpitch, value, sustain;\n{\n    register int\tsound, silence, snum = 1, sdenom = 1;\n\n    /* this weirdness avoids floating-point arithmetic */\n    for (; sustain; sustain--)\n    {\n\tsnum *= NUM_MULT;\n\tsdenom *= DENOM_MULT;\n    }\n\n    if (pitch == -1)\n\trest(whole * snum / (value * sdenom));\n    else\n    {\n\tsound = (whole * snum) / (value * sdenom)\n\t\t- (whole * (FILLTIME - fill)) / (value * FILLTIME);\n\tsilence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playtone: pitch %d for %d ticks, rest for %d ticks\\n\",\n\t    pitch, sound, silence);\n#endif /* SPKRDEBUG */\n\n\ttone(pitchtab[pitch], sound);\n\tif (fill != LEGATO)\n\t    rest(silence);\n    }\n}",
          "includes": [
            "#include <dev/isa/spkrio.h>",
            "#include <dev/isa/pcppivar.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DENOM_MULT\t2\t/* denominator of dot multiplier */",
            "#define NUM_MULT\t3\t/* numerator of dot multiplier */",
            "#define LEGATO\t\t8\t/* all of note interval is filled */",
            "#define FILLTIME\t8\t/* for articulation, break note in parts */"
          ],
          "globals_used": [
            "static void tone",
            "static void rest",
            "static void playtone",
            "static int whole;",
            "static int value;",
            "static int fill;",
            "static int pitchtab[] =\n{\n/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/\n/* 0 */   65,   69,   73,   78,   82,   87,   93,   98,  103,  110,  117,  123,\n/* 1 */  131,  139,  147,  156,  165,  175,  185,  196,  208,  220,  233,  247,\n/* 2 */  262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,\n/* 3 */  523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,\n/* 4 */ 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1975,\n/* 5 */ 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,\n/* 6 */ 4186, 4435, 4698, 4978, 5274, 5588, 5920, 6272, 6644, 7040, 7459, 7902,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DENOM_MULT\t2\t/* denominator of dot multiplier */\n#define NUM_MULT\t3\t/* numerator of dot multiplier */\n#define LEGATO\t\t8\t/* all of note interval is filled */\n#define FILLTIME\t8\t/* for articulation, break note in parts */\n\nstatic void tone;\nstatic void rest;\nstatic void playtone;\nstatic int whole;\nstatic int value;\nstatic int fill;\nstatic int pitchtab[] =\n{\n/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/\n/* 0 */   65,   69,   73,   78,   82,   87,   93,   98,  103,  110,  117,  123,\n/* 1 */  131,  139,  147,  156,  165,  175,  185,  196,  208,  220,  233,  247,\n/* 2 */  262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,\n/* 3 */  523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,\n/* 4 */ 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1975,\n/* 5 */ 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,\n/* 6 */ 4186, 4435, 4698, 4978, 5274, 5588, 5920, 6272, 6644, 7040, 7459, 7902,\n};\n\nstatic void\nplaytone(pitch, value, sustain)\n/* play tone of proper duration for current rhythm signature */\n    int\tpitch, value, sustain;\n{\n    register int\tsound, silence, snum = 1, sdenom = 1;\n\n    /* this weirdness avoids floating-point arithmetic */\n    for (; sustain; sustain--)\n    {\n\tsnum *= NUM_MULT;\n\tsdenom *= DENOM_MULT;\n    }\n\n    if (pitch == -1)\n\trest(whole * snum / (value * sdenom));\n    else\n    {\n\tsound = (whole * snum) / (value * sdenom)\n\t\t- (whole * (FILLTIME - fill)) / (value * FILLTIME);\n\tsilence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playtone: pitch %d for %d ticks, rest for %d ticks\\n\",\n\t    pitch, sound, silence);\n#endif /* SPKRDEBUG */\n\n\ttone(pitchtab[pitch], sound);\n\tif (fill != LEGATO)\n\t    rest(silence);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rest",
          "args": [
            "ttp.duration"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "rest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
          "lines": "68-83",
          "snippet": "static void\nrest(ticks)\n/* rest for given number of ticks */\n    int\tticks;\n{\n    /*\n     * Set timeout to endrest function, then give up the timeslice.\n     * This is so other processes can execute while the rest is being\n     * waited out.\n     */\n#ifdef SPKRDEBUG\n    printf(\"rest: %d\\n\", ticks);\n#endif /* SPKRDEBUG */\n    if (ticks > 0)\n\t    tsleep(rest, SPKRPRI | PCATCH, \"rest\", ticks);\n}",
          "includes": [
            "#include <dev/isa/spkrio.h>",
            "#include <dev/isa/pcppivar.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SPKRPRI (PZERO - 1)"
          ],
          "globals_used": [
            "static void rest"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SPKRPRI (PZERO - 1)\n\nstatic void rest;\n\nstatic void\nrest(ticks)\n/* rest for given number of ticks */\n    int\tticks;\n{\n    /*\n     * Set timeout to endrest function, then give up the timeslice.\n     * This is so other processes can execute while the rest is being\n     * waited out.\n     */\n#ifdef SPKRDEBUG\n    printf(\"rest: %d\\n\", ticks);\n#endif /* SPKRDEBUG */\n    if (ticks > 0)\n\t    tsleep(rest, SPKRPRI | PCATCH, \"rest\", ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "tp",
            "&ttp",
            "sizeof(tone_t)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"spkrioctl: entering with dev = %x, cmd = %lx\\n\"",
            "dev",
            "cmd"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tone;\nstatic void rest;\n\nint spkrioctl(dev, cmd, data, flag, p)\n    dev_t dev;\n    u_long cmd;\n    caddr_t data;\n    int\tflag;\n    struct proc *p;\n{\n#ifdef SPKRDEBUG\n    printf(\"spkrioctl: entering with dev = %x, cmd = %lx\\n\", dev, cmd);\n#endif /* SPKRDEBUG */\n\n    if (minor(dev) != 0)\n\treturn(ENXIO);\n    else if (cmd == SPKRTONE)\n    {\n\ttone_t\t*tp = (tone_t *)data;\n\n\tif (tp->frequency == 0)\n\t    rest(tp->duration);\n\telse\n\t    tone(tp->frequency, tp->duration);\n    }\n    else if (cmd == SPKRTUNE)\n    {\n\ttone_t  *tp = (tone_t *)(*(caddr_t *)data);\n\ttone_t ttp;\n\tint error;\n\n\tfor (; ; tp++) {\n\t    error = copyin(tp, &ttp, sizeof(tone_t));\n\t    if (error)\n\t\t    return(error);\n\t    if (ttp.duration == 0)\n\t\t    break;\n\t    if (ttp.frequency == 0)\n\t\trest(ttp.duration);\n\t    else\n\t\ttone(ttp.frequency, ttp.duration);\n\t}\n    }\n    else\n\treturn(EINVAL);\n    return(0);\n}"
  },
  {
    "function_name": "spkrclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
    "lines": "449-468",
    "snippet": "int spkrclose(dev, flags, mode, p)\n    dev_t\tdev;\n    int flags;\n    int mode;\n    struct proc *p;\n{\n#ifdef SPKRDEBUG\n    printf(\"spkrclose: entering with dev = %x\\n\", dev);\n#endif /* SPKRDEBUG */\n\n    if (minor(dev) != 0)\n\treturn(ENXIO);\n    else\n    {\n\ttone(0, 0);\n\tfree(spkr_inbuf, M_DEVBUF);\n\tspkr_active = 0;\n    }\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/spkrio.h>",
      "#include <dev/isa/pcppivar.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tone",
      "static int spkr_active;",
      "static void *spkr_inbuf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "spkr_inbuf",
            "M_DEVBUF"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "sb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/sbdsp.c",
          "lines": "2202-2209",
          "snippet": "void\nsb_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}",
          "includes": [
            "#include <dev/isa/sbdspvar.h>",
            "#include <dev/isa/sbreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nsb_malloc(addr, size, pool, flags)\n\tvoid *addr;",
            "int pool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/sbdspvar.h>\n#include <dev/isa/sbreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"midi.h\"\n\nvoid *\nsb_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint pool;\n\nvoid\nsb_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tisa_free(ptr, pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tone",
          "args": [
            "0",
            "0"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "playtone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
          "lines": "159-190",
          "snippet": "static void\nplaytone(pitch, value, sustain)\n/* play tone of proper duration for current rhythm signature */\n    int\tpitch, value, sustain;\n{\n    register int\tsound, silence, snum = 1, sdenom = 1;\n\n    /* this weirdness avoids floating-point arithmetic */\n    for (; sustain; sustain--)\n    {\n\tsnum *= NUM_MULT;\n\tsdenom *= DENOM_MULT;\n    }\n\n    if (pitch == -1)\n\trest(whole * snum / (value * sdenom));\n    else\n    {\n\tsound = (whole * snum) / (value * sdenom)\n\t\t- (whole * (FILLTIME - fill)) / (value * FILLTIME);\n\tsilence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playtone: pitch %d for %d ticks, rest for %d ticks\\n\",\n\t    pitch, sound, silence);\n#endif /* SPKRDEBUG */\n\n\ttone(pitchtab[pitch], sound);\n\tif (fill != LEGATO)\n\t    rest(silence);\n    }\n}",
          "includes": [
            "#include <dev/isa/spkrio.h>",
            "#include <dev/isa/pcppivar.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DENOM_MULT\t2\t/* denominator of dot multiplier */",
            "#define NUM_MULT\t3\t/* numerator of dot multiplier */",
            "#define LEGATO\t\t8\t/* all of note interval is filled */",
            "#define FILLTIME\t8\t/* for articulation, break note in parts */"
          ],
          "globals_used": [
            "static void tone",
            "static void rest",
            "static void playtone",
            "static int whole;",
            "static int value;",
            "static int fill;",
            "static int pitchtab[] =\n{\n/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/\n/* 0 */   65,   69,   73,   78,   82,   87,   93,   98,  103,  110,  117,  123,\n/* 1 */  131,  139,  147,  156,  165,  175,  185,  196,  208,  220,  233,  247,\n/* 2 */  262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,\n/* 3 */  523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,\n/* 4 */ 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1975,\n/* 5 */ 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,\n/* 6 */ 4186, 4435, 4698, 4978, 5274, 5588, 5920, 6272, 6644, 7040, 7459, 7902,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DENOM_MULT\t2\t/* denominator of dot multiplier */\n#define NUM_MULT\t3\t/* numerator of dot multiplier */\n#define LEGATO\t\t8\t/* all of note interval is filled */\n#define FILLTIME\t8\t/* for articulation, break note in parts */\n\nstatic void tone;\nstatic void rest;\nstatic void playtone;\nstatic int whole;\nstatic int value;\nstatic int fill;\nstatic int pitchtab[] =\n{\n/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/\n/* 0 */   65,   69,   73,   78,   82,   87,   93,   98,  103,  110,  117,  123,\n/* 1 */  131,  139,  147,  156,  165,  175,  185,  196,  208,  220,  233,  247,\n/* 2 */  262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,\n/* 3 */  523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,\n/* 4 */ 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1975,\n/* 5 */ 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,\n/* 6 */ 4186, 4435, 4698, 4978, 5274, 5588, 5920, 6272, 6644, 7040, 7459, 7902,\n};\n\nstatic void\nplaytone(pitch, value, sustain)\n/* play tone of proper duration for current rhythm signature */\n    int\tpitch, value, sustain;\n{\n    register int\tsound, silence, snum = 1, sdenom = 1;\n\n    /* this weirdness avoids floating-point arithmetic */\n    for (; sustain; sustain--)\n    {\n\tsnum *= NUM_MULT;\n\tsdenom *= DENOM_MULT;\n    }\n\n    if (pitch == -1)\n\trest(whole * snum / (value * sdenom));\n    else\n    {\n\tsound = (whole * snum) / (value * sdenom)\n\t\t- (whole * (FILLTIME - fill)) / (value * FILLTIME);\n\tsilence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playtone: pitch %d for %d ticks, rest for %d ticks\\n\",\n\t    pitch, sound, silence);\n#endif /* SPKRDEBUG */\n\n\ttone(pitchtab[pitch], sound);\n\tif (fill != LEGATO)\n\t    rest(silence);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"spkrclose: entering with dev = %x\\n\"",
            "dev"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tone;\nstatic int spkr_active;\nstatic void *spkr_inbuf;\n\nint spkrclose(dev, flags, mode, p)\n    dev_t\tdev;\n    int flags;\n    int mode;\n    struct proc *p;\n{\n#ifdef SPKRDEBUG\n    printf(\"spkrclose: entering with dev = %x\\n\", dev);\n#endif /* SPKRDEBUG */\n\n    if (minor(dev) != 0)\n\treturn(ENXIO);\n    else\n    {\n\ttone(0, 0);\n\tfree(spkr_inbuf, M_DEVBUF);\n\tspkr_active = 0;\n    }\n    return(0);\n}"
  },
  {
    "function_name": "spkrwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
    "lines": "424-447",
    "snippet": "int\nspkrwrite(dev, uio, flags)\n    dev_t dev;\n    struct uio *uio;\n    int flags;\n{\n    register int n;\n    int error;\n#ifdef SPKRDEBUG\n    printf(\"spkrwrite: entering with dev = %x, count = %d\\n\",\n\t\tdev, uio->uio_resid);\n#endif /* SPKRDEBUG */\n\n    if (minor(dev) != 0)\n\treturn(ENXIO);\n    else\n    {\n\tn = min(DEV_BSIZE, uio->uio_resid);\n\terror = uiomove(spkr_inbuf, n, uio);\n\tif (!error)\n\t\tplaystring((char *)spkr_inbuf, n);\n\treturn(error);\n    }\n}",
    "includes": [
      "#include <dev/isa/spkrio.h>",
      "#include <dev/isa/pcppivar.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void playstring",
      "static void *spkr_inbuf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "playstring",
          "args": [
            "(char *)spkr_inbuf",
            "n"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "playstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
          "lines": "192-363",
          "snippet": "static void\nplaystring(cp, slen)\n/* interpret and play an item from a notation string */\n    char\t*cp;\n    int\t\tslen;\n{\n    int\t\tpitch, lastpitch = OCTAVE_NOTES * DFLT_OCTAVE;\n\n#define GETNUM(cp, v)\tfor(v=0; slen > 0 && isdigit(cp[1]); ) \\\n\t\t\t\t{v = v * 10 + (*++cp - '0'); slen--;}\n    for (; slen--; cp++)\n    {\n\tint\t\tsustain, timeval, tempo;\n\tregister char\tc = toupper(*cp);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playstring: %c (%x)\\n\", c, c);\n#endif /* SPKRDEBUG */\n\n\tswitch (c)\n\t{\n\tcase 'A':  case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':\n\n\t    /* compute pitch */\n\t    pitch = notetab[c - 'A'] + octave * OCTAVE_NOTES;\n\n\t    /* this may be followed by an accidental sign */\n\t    if (slen > 0 && (cp[1] == '#' || cp[1] == '+'))\n\t    {\n\t\t++pitch;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && cp[1] == '-')\n\t    {\n\t\t--pitch;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\n\t    /*\n\t     * If octave-tracking mode is on, and there has been no octave-\n\t     * setting prefix, find the version of the current letter note\n\t     * closest to the last regardless of octave.\n\t     */\n\t    if (octtrack && !octprefix)\n\t    {\n\t\tif (abs(pitch-lastpitch) > abs(pitch+OCTAVE_NOTES-lastpitch))\n\t\t{\n\t\t    ++octave;\n\t\t    pitch += OCTAVE_NOTES;\n\t\t}\n\n\t\tif (abs(pitch-lastpitch) > abs((pitch-OCTAVE_NOTES)-lastpitch))\n\t\t{\n\t\t    --octave;\n\t\t    pitch -= OCTAVE_NOTES;\n\t\t}\n\t    }\n\t    octprefix = FALSE;\n\t    lastpitch = pitch;\n\n\t    /* ...which may in turn be followed by an override time value */\n\t    GETNUM(cp, timeval);\n\t    if (timeval <= 0 || timeval > MIN_VALUE)\n\t\ttimeval = value;\n\n\t    /* ...and/or sustain dots */\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\n\t    /* time to emit the actual tone */\n\t    playtone(pitch, timeval, sustain);\n\t    break;\n\n\tcase 'O':\n\t    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))\n\t    {\n\t\toctprefix = octtrack = FALSE;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))\n\t    {\n\t\tocttrack = TRUE;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else\n\t    {\n\t\tGETNUM(cp, octave);\n\t\tif (octave >= NOCTAVES)\n\t\t    octave = DFLT_OCTAVE;\n\t\toctprefix = TRUE;\n\t    }\n\t    break;\n\n\tcase '>':\n\t    if (octave < NOCTAVES - 1)\n\t\toctave++;\n\t    octprefix = TRUE;\n\t    break;\n\n\tcase '<':\n\t    if (octave > 0)\n\t\toctave--;\n\t    octprefix = TRUE;\n\t    break;\n\n\tcase 'N':\n\t    GETNUM(cp, pitch);\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\t    playtone(pitch - 1, value, sustain);\n\t    break;\n\n\tcase 'L':\n\t    GETNUM(cp, value);\n\t    if (value <= 0 || value > MIN_VALUE)\n\t\tvalue = DFLT_VALUE;\n\t    break;\n\n\tcase 'P':\n\tcase '~':\n\t    /* this may be followed by an override time value */\n\t    GETNUM(cp, timeval);\n\t    if (timeval <= 0 || timeval > MIN_VALUE)\n\t\ttimeval = value;\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\t    playtone(-1, timeval, sustain);\n\t    break;\n\n\tcase 'T':\n\t    GETNUM(cp, tempo);\n\t    if (tempo < MIN_TEMPO || tempo > MAX_TEMPO)\n\t\ttempo = DFLT_TEMPO;\n\t    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / tempo;\n\t    break;\n\n\tcase 'M':\n\t    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))\n\t    {\n\t\tfill = NORMAL;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))\n\t    {\n\t\tfill = LEGATO;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'S' || cp[1] == 's'))\n\t    {\n\t\tfill = STACCATO;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    break;\n\t}\n    }\n}",
          "includes": [
            "#include <dev/isa/spkrio.h>",
            "#include <dev/isa/pcppivar.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define NOCTAVES (sizeof(pitchtab) / sizeof(pitchtab[0]) / OCTAVE_NOTES)",
            "#define OCTAVE_NOTES\t12\t/* semitones per octave */",
            "#define MAX_TEMPO\t255\t/* max tempo */",
            "#define DFLT_TEMPO\t120\t/* default tempo */",
            "#define MIN_TEMPO\t32\t/* minimum tempo */",
            "#define DFLT_OCTAVE\t4\t/* default octave */",
            "#define LEGATO\t\t8\t/* all of note interval is filled */",
            "#define NORMAL\t\t7\t/* 7/8ths of note interval is filled */",
            "#define STACCATO\t6\t/* 6/8 = 3/4 of note is filled */",
            "#define DFLT_VALUE\t4\t/* default value (quarter-note) */",
            "#define MIN_VALUE\t64\t/* the most we can divide a note by */",
            "#define WHOLE_NOTE\t4\t/* quarter notes per whole note */",
            "#define SECS_PER_MIN\t60\t/* seconds per minute */",
            "#define FALSE\t0",
            "#define TRUE\t1"
          ],
          "globals_used": [
            "static void tone",
            "static void playtone",
            "static void playstring",
            "static int octave;",
            "static int whole;",
            "static int value;",
            "static int fill;",
            "static bool octtrack;",
            "static bool octprefix;",
            "static int notetab[8] = {9, 11, 0, 2, 4, 5, 7};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NOCTAVES (sizeof(pitchtab) / sizeof(pitchtab[0]) / OCTAVE_NOTES)\n#define OCTAVE_NOTES\t12\t/* semitones per octave */\n#define MAX_TEMPO\t255\t/* max tempo */\n#define DFLT_TEMPO\t120\t/* default tempo */\n#define MIN_TEMPO\t32\t/* minimum tempo */\n#define DFLT_OCTAVE\t4\t/* default octave */\n#define LEGATO\t\t8\t/* all of note interval is filled */\n#define NORMAL\t\t7\t/* 7/8ths of note interval is filled */\n#define STACCATO\t6\t/* 6/8 = 3/4 of note is filled */\n#define DFLT_VALUE\t4\t/* default value (quarter-note) */\n#define MIN_VALUE\t64\t/* the most we can divide a note by */\n#define WHOLE_NOTE\t4\t/* quarter notes per whole note */\n#define SECS_PER_MIN\t60\t/* seconds per minute */\n#define FALSE\t0\n#define TRUE\t1\n\nstatic void tone;\nstatic void playtone;\nstatic void playstring;\nstatic int octave;\nstatic int whole;\nstatic int value;\nstatic int fill;\nstatic bool octtrack;\nstatic bool octprefix;\nstatic int notetab[8] = {9, 11, 0, 2, 4, 5, 7};\n\nstatic void\nplaystring(cp, slen)\n/* interpret and play an item from a notation string */\n    char\t*cp;\n    int\t\tslen;\n{\n    int\t\tpitch, lastpitch = OCTAVE_NOTES * DFLT_OCTAVE;\n\n#define GETNUM(cp, v)\tfor(v=0; slen > 0 && isdigit(cp[1]); ) \\\n\t\t\t\t{v = v * 10 + (*++cp - '0'); slen--;}\n    for (; slen--; cp++)\n    {\n\tint\t\tsustain, timeval, tempo;\n\tregister char\tc = toupper(*cp);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playstring: %c (%x)\\n\", c, c);\n#endif /* SPKRDEBUG */\n\n\tswitch (c)\n\t{\n\tcase 'A':  case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':\n\n\t    /* compute pitch */\n\t    pitch = notetab[c - 'A'] + octave * OCTAVE_NOTES;\n\n\t    /* this may be followed by an accidental sign */\n\t    if (slen > 0 && (cp[1] == '#' || cp[1] == '+'))\n\t    {\n\t\t++pitch;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && cp[1] == '-')\n\t    {\n\t\t--pitch;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\n\t    /*\n\t     * If octave-tracking mode is on, and there has been no octave-\n\t     * setting prefix, find the version of the current letter note\n\t     * closest to the last regardless of octave.\n\t     */\n\t    if (octtrack && !octprefix)\n\t    {\n\t\tif (abs(pitch-lastpitch) > abs(pitch+OCTAVE_NOTES-lastpitch))\n\t\t{\n\t\t    ++octave;\n\t\t    pitch += OCTAVE_NOTES;\n\t\t}\n\n\t\tif (abs(pitch-lastpitch) > abs((pitch-OCTAVE_NOTES)-lastpitch))\n\t\t{\n\t\t    --octave;\n\t\t    pitch -= OCTAVE_NOTES;\n\t\t}\n\t    }\n\t    octprefix = FALSE;\n\t    lastpitch = pitch;\n\n\t    /* ...which may in turn be followed by an override time value */\n\t    GETNUM(cp, timeval);\n\t    if (timeval <= 0 || timeval > MIN_VALUE)\n\t\ttimeval = value;\n\n\t    /* ...and/or sustain dots */\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\n\t    /* time to emit the actual tone */\n\t    playtone(pitch, timeval, sustain);\n\t    break;\n\n\tcase 'O':\n\t    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))\n\t    {\n\t\toctprefix = octtrack = FALSE;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))\n\t    {\n\t\tocttrack = TRUE;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else\n\t    {\n\t\tGETNUM(cp, octave);\n\t\tif (octave >= NOCTAVES)\n\t\t    octave = DFLT_OCTAVE;\n\t\toctprefix = TRUE;\n\t    }\n\t    break;\n\n\tcase '>':\n\t    if (octave < NOCTAVES - 1)\n\t\toctave++;\n\t    octprefix = TRUE;\n\t    break;\n\n\tcase '<':\n\t    if (octave > 0)\n\t\toctave--;\n\t    octprefix = TRUE;\n\t    break;\n\n\tcase 'N':\n\t    GETNUM(cp, pitch);\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\t    playtone(pitch - 1, value, sustain);\n\t    break;\n\n\tcase 'L':\n\t    GETNUM(cp, value);\n\t    if (value <= 0 || value > MIN_VALUE)\n\t\tvalue = DFLT_VALUE;\n\t    break;\n\n\tcase 'P':\n\tcase '~':\n\t    /* this may be followed by an override time value */\n\t    GETNUM(cp, timeval);\n\t    if (timeval <= 0 || timeval > MIN_VALUE)\n\t\ttimeval = value;\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\t    playtone(-1, timeval, sustain);\n\t    break;\n\n\tcase 'T':\n\t    GETNUM(cp, tempo);\n\t    if (tempo < MIN_TEMPO || tempo > MAX_TEMPO)\n\t\ttempo = DFLT_TEMPO;\n\t    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / tempo;\n\t    break;\n\n\tcase 'M':\n\t    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))\n\t    {\n\t\tfill = NORMAL;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))\n\t    {\n\t\tfill = LEGATO;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'S' || cp[1] == 's'))\n\t    {\n\t\tfill = STACCATO;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    break;\n\t}\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "spkr_inbuf",
            "n",
            "uio"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "DEV_BSIZE",
            "uio->uio_resid"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "btminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1088-1096",
          "snippet": "void\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void btminphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid btminphys;\n\nvoid\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"spkrwrite: entering with dev = %x, count = %d\\n\"",
            "dev",
            "uio->uio_resid"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void playstring;\nstatic void *spkr_inbuf;\n\nint\nspkrwrite(dev, uio, flags)\n    dev_t dev;\n    struct uio *uio;\n    int flags;\n{\n    register int n;\n    int error;\n#ifdef SPKRDEBUG\n    printf(\"spkrwrite: entering with dev = %x, count = %d\\n\",\n\t\tdev, uio->uio_resid);\n#endif /* SPKRDEBUG */\n\n    if (minor(dev) != 0)\n\treturn(ENXIO);\n    else\n    {\n\tn = min(DEV_BSIZE, uio->uio_resid);\n\terror = uiomove(spkr_inbuf, n, uio);\n\tif (!error)\n\t\tplaystring((char *)spkr_inbuf, n);\n\treturn(error);\n    }\n}"
  },
  {
    "function_name": "spkropen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
    "lines": "400-422",
    "snippet": "int\nspkropen(dev, flags, mode, p)\n    dev_t dev;\n    int\tflags;\n    int mode;\n    struct proc *p;\n{\n#ifdef SPKRDEBUG\n    printf(\"spkropen: entering with dev = %x\\n\", dev);\n#endif /* SPKRDEBUG */\n\n    if (minor(dev) != 0 || !spkr_attached)\n\treturn(ENXIO);\n    else if (spkr_active)\n\treturn(EBUSY);\n    else\n    {\n\tplayinit();\n\tspkr_inbuf = malloc(DEV_BSIZE, M_DEVBUF, M_WAITOK);\n\tspkr_active = 1;\n    }\n    return(0);\n}",
    "includes": [
      "#include <dev/isa/spkrio.h>",
      "#include <dev/isa/pcppivar.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void playinit",
      "static int spkr_active;",
      "static void *spkr_inbuf;",
      "static int spkr_attached = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "DEV_BSIZE",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "playinit",
          "args": [],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "playinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
          "lines": "148-157",
          "snippet": "static void\nplayinit()\n{\n    octave = DFLT_OCTAVE;\n    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / DFLT_TEMPO;\n    fill = NORMAL;\n    value = DFLT_VALUE;\n    octtrack = FALSE;\n    octprefix = TRUE;\t/* act as though there was an initial O(n) */\n}",
          "includes": [
            "#include <dev/isa/spkrio.h>",
            "#include <dev/isa/pcppivar.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DFLT_TEMPO\t120\t/* default tempo */",
            "#define DFLT_OCTAVE\t4\t/* default octave */",
            "#define NORMAL\t\t7\t/* 7/8ths of note interval is filled */",
            "#define DFLT_VALUE\t4\t/* default value (quarter-note) */",
            "#define WHOLE_NOTE\t4\t/* quarter notes per whole note */",
            "#define SECS_PER_MIN\t60\t/* seconds per minute */",
            "#define FALSE\t0",
            "#define TRUE\t1"
          ],
          "globals_used": [
            "static void playinit",
            "static int octave;",
            "static int whole;",
            "static int value;",
            "static int fill;",
            "static bool octtrack;",
            "static bool octprefix;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DFLT_TEMPO\t120\t/* default tempo */\n#define DFLT_OCTAVE\t4\t/* default octave */\n#define NORMAL\t\t7\t/* 7/8ths of note interval is filled */\n#define DFLT_VALUE\t4\t/* default value (quarter-note) */\n#define WHOLE_NOTE\t4\t/* quarter notes per whole note */\n#define SECS_PER_MIN\t60\t/* seconds per minute */\n#define FALSE\t0\n#define TRUE\t1\n\nstatic void playinit;\nstatic int octave;\nstatic int whole;\nstatic int value;\nstatic int fill;\nstatic bool octtrack;\nstatic bool octprefix;\n\nstatic void\nplayinit()\n{\n    octave = DFLT_OCTAVE;\n    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / DFLT_TEMPO;\n    fill = NORMAL;\n    value = DFLT_VALUE;\n    octtrack = FALSE;\n    octprefix = TRUE;\t/* act as though there was an initial O(n) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"spkropen: entering with dev = %x\\n\"",
            "dev"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void playinit;\nstatic int spkr_active;\nstatic void *spkr_inbuf;\nstatic int spkr_attached = 0;\n\nint\nspkropen(dev, flags, mode, p)\n    dev_t dev;\n    int\tflags;\n    int mode;\n    struct proc *p;\n{\n#ifdef SPKRDEBUG\n    printf(\"spkropen: entering with dev = %x\\n\", dev);\n#endif /* SPKRDEBUG */\n\n    if (minor(dev) != 0 || !spkr_attached)\n\treturn(ENXIO);\n    else if (spkr_active)\n\treturn(EBUSY);\n    else\n    {\n\tplayinit();\n\tspkr_inbuf = malloc(DEV_BSIZE, M_DEVBUF, M_WAITOK);\n\tspkr_active = 1;\n    }\n    return(0);\n}"
  },
  {
    "function_name": "spkrattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
    "lines": "389-398",
    "snippet": "void\nspkrattach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tprintf(\"\\n\");\n\tppicookie = ((struct pcppi_attach_args *)aux)->pa_cookie;\n\tspkr_attached = 1;\n}",
    "includes": [
      "#include <dev/isa/spkrio.h>",
      "#include <dev/isa/pcppivar.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void spkrattach",
      "static pcppi_tag_t ppicookie;",
      "static int spkr_attached = 0;",
      "void *aux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid spkrattach;\nstatic pcppi_tag_t ppicookie;\nstatic int spkr_attached = 0;\nvoid *aux;\n\nvoid\nspkrattach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tprintf(\"\\n\");\n\tppicookie = ((struct pcppi_attach_args *)aux)->pa_cookie;\n\tspkr_attached = 1;\n}"
  },
  {
    "function_name": "playstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
    "lines": "192-363",
    "snippet": "static void\nplaystring(cp, slen)\n/* interpret and play an item from a notation string */\n    char\t*cp;\n    int\t\tslen;\n{\n    int\t\tpitch, lastpitch = OCTAVE_NOTES * DFLT_OCTAVE;\n\n#define GETNUM(cp, v)\tfor(v=0; slen > 0 && isdigit(cp[1]); ) \\\n\t\t\t\t{v = v * 10 + (*++cp - '0'); slen--;}\n    for (; slen--; cp++)\n    {\n\tint\t\tsustain, timeval, tempo;\n\tregister char\tc = toupper(*cp);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playstring: %c (%x)\\n\", c, c);\n#endif /* SPKRDEBUG */\n\n\tswitch (c)\n\t{\n\tcase 'A':  case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':\n\n\t    /* compute pitch */\n\t    pitch = notetab[c - 'A'] + octave * OCTAVE_NOTES;\n\n\t    /* this may be followed by an accidental sign */\n\t    if (slen > 0 && (cp[1] == '#' || cp[1] == '+'))\n\t    {\n\t\t++pitch;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && cp[1] == '-')\n\t    {\n\t\t--pitch;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\n\t    /*\n\t     * If octave-tracking mode is on, and there has been no octave-\n\t     * setting prefix, find the version of the current letter note\n\t     * closest to the last regardless of octave.\n\t     */\n\t    if (octtrack && !octprefix)\n\t    {\n\t\tif (abs(pitch-lastpitch) > abs(pitch+OCTAVE_NOTES-lastpitch))\n\t\t{\n\t\t    ++octave;\n\t\t    pitch += OCTAVE_NOTES;\n\t\t}\n\n\t\tif (abs(pitch-lastpitch) > abs((pitch-OCTAVE_NOTES)-lastpitch))\n\t\t{\n\t\t    --octave;\n\t\t    pitch -= OCTAVE_NOTES;\n\t\t}\n\t    }\n\t    octprefix = FALSE;\n\t    lastpitch = pitch;\n\n\t    /* ...which may in turn be followed by an override time value */\n\t    GETNUM(cp, timeval);\n\t    if (timeval <= 0 || timeval > MIN_VALUE)\n\t\ttimeval = value;\n\n\t    /* ...and/or sustain dots */\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\n\t    /* time to emit the actual tone */\n\t    playtone(pitch, timeval, sustain);\n\t    break;\n\n\tcase 'O':\n\t    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))\n\t    {\n\t\toctprefix = octtrack = FALSE;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))\n\t    {\n\t\tocttrack = TRUE;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else\n\t    {\n\t\tGETNUM(cp, octave);\n\t\tif (octave >= NOCTAVES)\n\t\t    octave = DFLT_OCTAVE;\n\t\toctprefix = TRUE;\n\t    }\n\t    break;\n\n\tcase '>':\n\t    if (octave < NOCTAVES - 1)\n\t\toctave++;\n\t    octprefix = TRUE;\n\t    break;\n\n\tcase '<':\n\t    if (octave > 0)\n\t\toctave--;\n\t    octprefix = TRUE;\n\t    break;\n\n\tcase 'N':\n\t    GETNUM(cp, pitch);\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\t    playtone(pitch - 1, value, sustain);\n\t    break;\n\n\tcase 'L':\n\t    GETNUM(cp, value);\n\t    if (value <= 0 || value > MIN_VALUE)\n\t\tvalue = DFLT_VALUE;\n\t    break;\n\n\tcase 'P':\n\tcase '~':\n\t    /* this may be followed by an override time value */\n\t    GETNUM(cp, timeval);\n\t    if (timeval <= 0 || timeval > MIN_VALUE)\n\t\ttimeval = value;\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\t    playtone(-1, timeval, sustain);\n\t    break;\n\n\tcase 'T':\n\t    GETNUM(cp, tempo);\n\t    if (tempo < MIN_TEMPO || tempo > MAX_TEMPO)\n\t\ttempo = DFLT_TEMPO;\n\t    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / tempo;\n\t    break;\n\n\tcase 'M':\n\t    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))\n\t    {\n\t\tfill = NORMAL;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))\n\t    {\n\t\tfill = LEGATO;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'S' || cp[1] == 's'))\n\t    {\n\t\tfill = STACCATO;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    break;\n\t}\n    }\n}",
    "includes": [
      "#include <dev/isa/spkrio.h>",
      "#include <dev/isa/pcppivar.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define NOCTAVES (sizeof(pitchtab) / sizeof(pitchtab[0]) / OCTAVE_NOTES)",
      "#define OCTAVE_NOTES\t12\t/* semitones per octave */",
      "#define MAX_TEMPO\t255\t/* max tempo */",
      "#define DFLT_TEMPO\t120\t/* default tempo */",
      "#define MIN_TEMPO\t32\t/* minimum tempo */",
      "#define DFLT_OCTAVE\t4\t/* default octave */",
      "#define LEGATO\t\t8\t/* all of note interval is filled */",
      "#define NORMAL\t\t7\t/* 7/8ths of note interval is filled */",
      "#define STACCATO\t6\t/* 6/8 = 3/4 of note is filled */",
      "#define DFLT_VALUE\t4\t/* default value (quarter-note) */",
      "#define MIN_VALUE\t64\t/* the most we can divide a note by */",
      "#define WHOLE_NOTE\t4\t/* quarter notes per whole note */",
      "#define SECS_PER_MIN\t60\t/* seconds per minute */",
      "#define FALSE\t0",
      "#define TRUE\t1"
    ],
    "globals_used": [
      "static void tone",
      "static void playtone",
      "static void playstring",
      "static int octave;",
      "static int whole;",
      "static int value;",
      "static int fill;",
      "static bool octtrack;",
      "static bool octprefix;",
      "static int notetab[8] = {9, 11, 0, 2, 4, 5, 7};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GETNUM",
          "args": [
            "cp",
            "tempo"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "playtone",
          "args": [
            "-1",
            "timeval",
            "sustain"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "playtone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
          "lines": "159-190",
          "snippet": "static void\nplaytone(pitch, value, sustain)\n/* play tone of proper duration for current rhythm signature */\n    int\tpitch, value, sustain;\n{\n    register int\tsound, silence, snum = 1, sdenom = 1;\n\n    /* this weirdness avoids floating-point arithmetic */\n    for (; sustain; sustain--)\n    {\n\tsnum *= NUM_MULT;\n\tsdenom *= DENOM_MULT;\n    }\n\n    if (pitch == -1)\n\trest(whole * snum / (value * sdenom));\n    else\n    {\n\tsound = (whole * snum) / (value * sdenom)\n\t\t- (whole * (FILLTIME - fill)) / (value * FILLTIME);\n\tsilence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playtone: pitch %d for %d ticks, rest for %d ticks\\n\",\n\t    pitch, sound, silence);\n#endif /* SPKRDEBUG */\n\n\ttone(pitchtab[pitch], sound);\n\tif (fill != LEGATO)\n\t    rest(silence);\n    }\n}",
          "includes": [
            "#include <dev/isa/spkrio.h>",
            "#include <dev/isa/pcppivar.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DENOM_MULT\t2\t/* denominator of dot multiplier */",
            "#define NUM_MULT\t3\t/* numerator of dot multiplier */",
            "#define LEGATO\t\t8\t/* all of note interval is filled */",
            "#define FILLTIME\t8\t/* for articulation, break note in parts */"
          ],
          "globals_used": [
            "static void tone",
            "static void rest",
            "static void playtone",
            "static int whole;",
            "static int value;",
            "static int fill;",
            "static int pitchtab[] =\n{\n/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/\n/* 0 */   65,   69,   73,   78,   82,   87,   93,   98,  103,  110,  117,  123,\n/* 1 */  131,  139,  147,  156,  165,  175,  185,  196,  208,  220,  233,  247,\n/* 2 */  262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,\n/* 3 */  523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,\n/* 4 */ 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1975,\n/* 5 */ 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,\n/* 6 */ 4186, 4435, 4698, 4978, 5274, 5588, 5920, 6272, 6644, 7040, 7459, 7902,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DENOM_MULT\t2\t/* denominator of dot multiplier */\n#define NUM_MULT\t3\t/* numerator of dot multiplier */\n#define LEGATO\t\t8\t/* all of note interval is filled */\n#define FILLTIME\t8\t/* for articulation, break note in parts */\n\nstatic void tone;\nstatic void rest;\nstatic void playtone;\nstatic int whole;\nstatic int value;\nstatic int fill;\nstatic int pitchtab[] =\n{\n/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/\n/* 0 */   65,   69,   73,   78,   82,   87,   93,   98,  103,  110,  117,  123,\n/* 1 */  131,  139,  147,  156,  165,  175,  185,  196,  208,  220,  233,  247,\n/* 2 */  262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,\n/* 3 */  523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,\n/* 4 */ 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1975,\n/* 5 */ 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,\n/* 6 */ 4186, 4435, 4698, 4978, 5274, 5588, 5920, 6272, 6644, 7040, 7459, 7902,\n};\n\nstatic void\nplaytone(pitch, value, sustain)\n/* play tone of proper duration for current rhythm signature */\n    int\tpitch, value, sustain;\n{\n    register int\tsound, silence, snum = 1, sdenom = 1;\n\n    /* this weirdness avoids floating-point arithmetic */\n    for (; sustain; sustain--)\n    {\n\tsnum *= NUM_MULT;\n\tsdenom *= DENOM_MULT;\n    }\n\n    if (pitch == -1)\n\trest(whole * snum / (value * sdenom));\n    else\n    {\n\tsound = (whole * snum) / (value * sdenom)\n\t\t- (whole * (FILLTIME - fill)) / (value * FILLTIME);\n\tsilence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playtone: pitch %d for %d ticks, rest for %d ticks\\n\",\n\t    pitch, sound, silence);\n#endif /* SPKRDEBUG */\n\n\ttone(pitchtab[pitch], sound);\n\tif (fill != LEGATO)\n\t    rest(silence);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETNUM",
          "args": [
            "cp",
            "timeval"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETNUM",
          "args": [
            "cp",
            "value"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETNUM",
          "args": [
            "cp",
            "pitch"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETNUM",
          "args": [
            "cp",
            "octave"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETNUM",
          "args": [
            "cp",
            "timeval"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "(pitch-OCTAVE_NOTES)-lastpitch"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "pitch-lastpitch"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "pitch+OCTAVE_NOTES-lastpitch"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "pitch-lastpitch"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"playstring: %c (%x)\\n\"",
            "c",
            "c"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "*cp"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NOCTAVES (sizeof(pitchtab) / sizeof(pitchtab[0]) / OCTAVE_NOTES)\n#define OCTAVE_NOTES\t12\t/* semitones per octave */\n#define MAX_TEMPO\t255\t/* max tempo */\n#define DFLT_TEMPO\t120\t/* default tempo */\n#define MIN_TEMPO\t32\t/* minimum tempo */\n#define DFLT_OCTAVE\t4\t/* default octave */\n#define LEGATO\t\t8\t/* all of note interval is filled */\n#define NORMAL\t\t7\t/* 7/8ths of note interval is filled */\n#define STACCATO\t6\t/* 6/8 = 3/4 of note is filled */\n#define DFLT_VALUE\t4\t/* default value (quarter-note) */\n#define MIN_VALUE\t64\t/* the most we can divide a note by */\n#define WHOLE_NOTE\t4\t/* quarter notes per whole note */\n#define SECS_PER_MIN\t60\t/* seconds per minute */\n#define FALSE\t0\n#define TRUE\t1\n\nstatic void tone;\nstatic void playtone;\nstatic void playstring;\nstatic int octave;\nstatic int whole;\nstatic int value;\nstatic int fill;\nstatic bool octtrack;\nstatic bool octprefix;\nstatic int notetab[8] = {9, 11, 0, 2, 4, 5, 7};\n\nstatic void\nplaystring(cp, slen)\n/* interpret and play an item from a notation string */\n    char\t*cp;\n    int\t\tslen;\n{\n    int\t\tpitch, lastpitch = OCTAVE_NOTES * DFLT_OCTAVE;\n\n#define GETNUM(cp, v)\tfor(v=0; slen > 0 && isdigit(cp[1]); ) \\\n\t\t\t\t{v = v * 10 + (*++cp - '0'); slen--;}\n    for (; slen--; cp++)\n    {\n\tint\t\tsustain, timeval, tempo;\n\tregister char\tc = toupper(*cp);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playstring: %c (%x)\\n\", c, c);\n#endif /* SPKRDEBUG */\n\n\tswitch (c)\n\t{\n\tcase 'A':  case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':\n\n\t    /* compute pitch */\n\t    pitch = notetab[c - 'A'] + octave * OCTAVE_NOTES;\n\n\t    /* this may be followed by an accidental sign */\n\t    if (slen > 0 && (cp[1] == '#' || cp[1] == '+'))\n\t    {\n\t\t++pitch;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && cp[1] == '-')\n\t    {\n\t\t--pitch;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\n\t    /*\n\t     * If octave-tracking mode is on, and there has been no octave-\n\t     * setting prefix, find the version of the current letter note\n\t     * closest to the last regardless of octave.\n\t     */\n\t    if (octtrack && !octprefix)\n\t    {\n\t\tif (abs(pitch-lastpitch) > abs(pitch+OCTAVE_NOTES-lastpitch))\n\t\t{\n\t\t    ++octave;\n\t\t    pitch += OCTAVE_NOTES;\n\t\t}\n\n\t\tif (abs(pitch-lastpitch) > abs((pitch-OCTAVE_NOTES)-lastpitch))\n\t\t{\n\t\t    --octave;\n\t\t    pitch -= OCTAVE_NOTES;\n\t\t}\n\t    }\n\t    octprefix = FALSE;\n\t    lastpitch = pitch;\n\n\t    /* ...which may in turn be followed by an override time value */\n\t    GETNUM(cp, timeval);\n\t    if (timeval <= 0 || timeval > MIN_VALUE)\n\t\ttimeval = value;\n\n\t    /* ...and/or sustain dots */\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\n\t    /* time to emit the actual tone */\n\t    playtone(pitch, timeval, sustain);\n\t    break;\n\n\tcase 'O':\n\t    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))\n\t    {\n\t\toctprefix = octtrack = FALSE;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))\n\t    {\n\t\tocttrack = TRUE;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else\n\t    {\n\t\tGETNUM(cp, octave);\n\t\tif (octave >= NOCTAVES)\n\t\t    octave = DFLT_OCTAVE;\n\t\toctprefix = TRUE;\n\t    }\n\t    break;\n\n\tcase '>':\n\t    if (octave < NOCTAVES - 1)\n\t\toctave++;\n\t    octprefix = TRUE;\n\t    break;\n\n\tcase '<':\n\t    if (octave > 0)\n\t\toctave--;\n\t    octprefix = TRUE;\n\t    break;\n\n\tcase 'N':\n\t    GETNUM(cp, pitch);\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\t    playtone(pitch - 1, value, sustain);\n\t    break;\n\n\tcase 'L':\n\t    GETNUM(cp, value);\n\t    if (value <= 0 || value > MIN_VALUE)\n\t\tvalue = DFLT_VALUE;\n\t    break;\n\n\tcase 'P':\n\tcase '~':\n\t    /* this may be followed by an override time value */\n\t    GETNUM(cp, timeval);\n\t    if (timeval <= 0 || timeval > MIN_VALUE)\n\t\ttimeval = value;\n\t    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)\n\t    {\n\t\tslen--;\n\t\tsustain++;\n\t    }\n\t    playtone(-1, timeval, sustain);\n\t    break;\n\n\tcase 'T':\n\t    GETNUM(cp, tempo);\n\t    if (tempo < MIN_TEMPO || tempo > MAX_TEMPO)\n\t\ttempo = DFLT_TEMPO;\n\t    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / tempo;\n\t    break;\n\n\tcase 'M':\n\t    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))\n\t    {\n\t\tfill = NORMAL;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))\n\t    {\n\t\tfill = LEGATO;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    else if (slen > 0 && (cp[1] == 'S' || cp[1] == 's'))\n\t    {\n\t\tfill = STACCATO;\n\t\t++cp;\n\t\tslen--;\n\t    }\n\t    break;\n\t}\n    }\n}"
  },
  {
    "function_name": "playtone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
    "lines": "159-190",
    "snippet": "static void\nplaytone(pitch, value, sustain)\n/* play tone of proper duration for current rhythm signature */\n    int\tpitch, value, sustain;\n{\n    register int\tsound, silence, snum = 1, sdenom = 1;\n\n    /* this weirdness avoids floating-point arithmetic */\n    for (; sustain; sustain--)\n    {\n\tsnum *= NUM_MULT;\n\tsdenom *= DENOM_MULT;\n    }\n\n    if (pitch == -1)\n\trest(whole * snum / (value * sdenom));\n    else\n    {\n\tsound = (whole * snum) / (value * sdenom)\n\t\t- (whole * (FILLTIME - fill)) / (value * FILLTIME);\n\tsilence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playtone: pitch %d for %d ticks, rest for %d ticks\\n\",\n\t    pitch, sound, silence);\n#endif /* SPKRDEBUG */\n\n\ttone(pitchtab[pitch], sound);\n\tif (fill != LEGATO)\n\t    rest(silence);\n    }\n}",
    "includes": [
      "#include <dev/isa/spkrio.h>",
      "#include <dev/isa/pcppivar.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DENOM_MULT\t2\t/* denominator of dot multiplier */",
      "#define NUM_MULT\t3\t/* numerator of dot multiplier */",
      "#define LEGATO\t\t8\t/* all of note interval is filled */",
      "#define FILLTIME\t8\t/* for articulation, break note in parts */"
    ],
    "globals_used": [
      "static void tone",
      "static void rest",
      "static void playtone",
      "static int whole;",
      "static int value;",
      "static int fill;",
      "static int pitchtab[] =\n{\n/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/\n/* 0 */   65,   69,   73,   78,   82,   87,   93,   98,  103,  110,  117,  123,\n/* 1 */  131,  139,  147,  156,  165,  175,  185,  196,  208,  220,  233,  247,\n/* 2 */  262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,\n/* 3 */  523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,\n/* 4 */ 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1975,\n/* 5 */ 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,\n/* 6 */ 4186, 4435, 4698, 4978, 5274, 5588, 5920, 6272, 6644, 7040, 7459, 7902,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rest",
          "args": [
            "silence"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "rest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
          "lines": "68-83",
          "snippet": "static void\nrest(ticks)\n/* rest for given number of ticks */\n    int\tticks;\n{\n    /*\n     * Set timeout to endrest function, then give up the timeslice.\n     * This is so other processes can execute while the rest is being\n     * waited out.\n     */\n#ifdef SPKRDEBUG\n    printf(\"rest: %d\\n\", ticks);\n#endif /* SPKRDEBUG */\n    if (ticks > 0)\n\t    tsleep(rest, SPKRPRI | PCATCH, \"rest\", ticks);\n}",
          "includes": [
            "#include <dev/isa/spkrio.h>",
            "#include <dev/isa/pcppivar.h>",
            "#include <sys/conf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/proc.h>",
            "#include <sys/uio.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SPKRPRI (PZERO - 1)"
          ],
          "globals_used": [
            "static void rest"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SPKRPRI (PZERO - 1)\n\nstatic void rest;\n\nstatic void\nrest(ticks)\n/* rest for given number of ticks */\n    int\tticks;\n{\n    /*\n     * Set timeout to endrest function, then give up the timeslice.\n     * This is so other processes can execute while the rest is being\n     * waited out.\n     */\n#ifdef SPKRDEBUG\n    printf(\"rest: %d\\n\", ticks);\n#endif /* SPKRDEBUG */\n    if (ticks > 0)\n\t    tsleep(rest, SPKRPRI | PCATCH, \"rest\", ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tone",
          "args": [
            "pitchtab[pitch]",
            "sound"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "playtone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
          "lines": "159-190",
          "snippet": "static void\nplaytone(pitch, value, sustain)\n/* play tone of proper duration for current rhythm signature */\n    int\tpitch, value, sustain;\n{\n    register int\tsound, silence, snum = 1, sdenom = 1;\n\n    /* this weirdness avoids floating-point arithmetic */\n    for (; sustain; sustain--)\n    {\n\tsnum *= NUM_MULT;\n\tsdenom *= DENOM_MULT;\n    }\n\n    if (pitch == -1)\n\trest(whole * snum / (value * sdenom));\n    else\n    {\n\tsound = (whole * snum) / (value * sdenom)\n\t\t- (whole * (FILLTIME - fill)) / (value * FILLTIME);\n\tsilence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playtone: pitch %d for %d ticks, rest for %d ticks\\n\",\n\t    pitch, sound, silence);\n#endif /* SPKRDEBUG */\n\n\ttone(pitchtab[pitch], sound);\n\tif (fill != LEGATO)\n\t    rest(silence);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"playtone: pitch %d for %d ticks, rest for %d ticks\\n\"",
            "pitch",
            "sound",
            "silence"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DENOM_MULT\t2\t/* denominator of dot multiplier */\n#define NUM_MULT\t3\t/* numerator of dot multiplier */\n#define LEGATO\t\t8\t/* all of note interval is filled */\n#define FILLTIME\t8\t/* for articulation, break note in parts */\n\nstatic void tone;\nstatic void rest;\nstatic void playtone;\nstatic int whole;\nstatic int value;\nstatic int fill;\nstatic int pitchtab[] =\n{\n/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/\n/* 0 */   65,   69,   73,   78,   82,   87,   93,   98,  103,  110,  117,  123,\n/* 1 */  131,  139,  147,  156,  165,  175,  185,  196,  208,  220,  233,  247,\n/* 2 */  262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,\n/* 3 */  523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,\n/* 4 */ 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1975,\n/* 5 */ 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,\n/* 6 */ 4186, 4435, 4698, 4978, 5274, 5588, 5920, 6272, 6644, 7040, 7459, 7902,\n};\n\nstatic void\nplaytone(pitch, value, sustain)\n/* play tone of proper duration for current rhythm signature */\n    int\tpitch, value, sustain;\n{\n    register int\tsound, silence, snum = 1, sdenom = 1;\n\n    /* this weirdness avoids floating-point arithmetic */\n    for (; sustain; sustain--)\n    {\n\tsnum *= NUM_MULT;\n\tsdenom *= DENOM_MULT;\n    }\n\n    if (pitch == -1)\n\trest(whole * snum / (value * sdenom));\n    else\n    {\n\tsound = (whole * snum) / (value * sdenom)\n\t\t- (whole * (FILLTIME - fill)) / (value * FILLTIME);\n\tsilence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);\n\n#ifdef SPKRDEBUG\n\tprintf(\"playtone: pitch %d for %d ticks, rest for %d ticks\\n\",\n\t    pitch, sound, silence);\n#endif /* SPKRDEBUG */\n\n\ttone(pitchtab[pitch], sound);\n\tif (fill != LEGATO)\n\t    rest(silence);\n    }\n}"
  },
  {
    "function_name": "playinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
    "lines": "148-157",
    "snippet": "static void\nplayinit()\n{\n    octave = DFLT_OCTAVE;\n    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / DFLT_TEMPO;\n    fill = NORMAL;\n    value = DFLT_VALUE;\n    octtrack = FALSE;\n    octprefix = TRUE;\t/* act as though there was an initial O(n) */\n}",
    "includes": [
      "#include <dev/isa/spkrio.h>",
      "#include <dev/isa/pcppivar.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DFLT_TEMPO\t120\t/* default tempo */",
      "#define DFLT_OCTAVE\t4\t/* default octave */",
      "#define NORMAL\t\t7\t/* 7/8ths of note interval is filled */",
      "#define DFLT_VALUE\t4\t/* default value (quarter-note) */",
      "#define WHOLE_NOTE\t4\t/* quarter notes per whole note */",
      "#define SECS_PER_MIN\t60\t/* seconds per minute */",
      "#define FALSE\t0",
      "#define TRUE\t1"
    ],
    "globals_used": [
      "static void playinit",
      "static int octave;",
      "static int whole;",
      "static int value;",
      "static int fill;",
      "static bool octtrack;",
      "static bool octprefix;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DFLT_TEMPO\t120\t/* default tempo */\n#define DFLT_OCTAVE\t4\t/* default octave */\n#define NORMAL\t\t7\t/* 7/8ths of note interval is filled */\n#define DFLT_VALUE\t4\t/* default value (quarter-note) */\n#define WHOLE_NOTE\t4\t/* quarter notes per whole note */\n#define SECS_PER_MIN\t60\t/* seconds per minute */\n#define FALSE\t0\n#define TRUE\t1\n\nstatic void playinit;\nstatic int octave;\nstatic int whole;\nstatic int value;\nstatic int fill;\nstatic bool octtrack;\nstatic bool octprefix;\n\nstatic void\nplayinit()\n{\n    octave = DFLT_OCTAVE;\n    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / DFLT_TEMPO;\n    fill = NORMAL;\n    value = DFLT_VALUE;\n    octtrack = FALSE;\n    octprefix = TRUE;\t/* act as though there was an initial O(n) */\n}"
  },
  {
    "function_name": "rest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
    "lines": "68-83",
    "snippet": "static void\nrest(ticks)\n/* rest for given number of ticks */\n    int\tticks;\n{\n    /*\n     * Set timeout to endrest function, then give up the timeslice.\n     * This is so other processes can execute while the rest is being\n     * waited out.\n     */\n#ifdef SPKRDEBUG\n    printf(\"rest: %d\\n\", ticks);\n#endif /* SPKRDEBUG */\n    if (ticks > 0)\n\t    tsleep(rest, SPKRPRI | PCATCH, \"rest\", ticks);\n}",
    "includes": [
      "#include <dev/isa/spkrio.h>",
      "#include <dev/isa/pcppivar.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SPKRPRI (PZERO - 1)"
    ],
    "globals_used": [
      "static void rest"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "rest",
            "SPKRPRI | PCATCH",
            "\"rest\"",
            "ticks"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"rest: %d\\n\"",
            "ticks"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SPKRPRI (PZERO - 1)\n\nstatic void rest;\n\nstatic void\nrest(ticks)\n/* rest for given number of ticks */\n    int\tticks;\n{\n    /*\n     * Set timeout to endrest function, then give up the timeslice.\n     * This is so other processes can execute while the rest is being\n     * waited out.\n     */\n#ifdef SPKRDEBUG\n    printf(\"rest: %d\\n\", ticks);\n#endif /* SPKRDEBUG */\n    if (ticks > 0)\n\t    tsleep(rest, SPKRPRI | PCATCH, \"rest\", ticks);\n}"
  },
  {
    "function_name": "tone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/spkr.c",
    "lines": "60-66",
    "snippet": "static\nvoid tone(hz, ticks)\n/* emit tone of frequency hz for given number of ticks */\n    u_int hz, ticks;\n{\n\tpcppi_bell(ppicookie, hz, ticks, 1);\n}",
    "includes": [
      "#include <dev/isa/spkrio.h>",
      "#include <dev/isa/pcppivar.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/proc.h>",
      "#include <sys/uio.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static pcppi_tag_t ppicookie;",
      "static void tone"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcppi_bell",
          "args": [
            "ppicookie",
            "hz",
            "ticks",
            "1"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "pcppi_bell_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/pcppi.c",
          "lines": "219-235",
          "snippet": "static void\npcppi_bell_stop(arg)\n\tvoid *arg;\n{\n\tstruct pcppi_softc *sc = arg;\n\tint s;\n\n\ts = spltty(); /* ??? */\n\t/* disable bell */\n\tbus_space_write_1(sc->sc_iot, sc->sc_ppi_ioh, 0,\n\t\t\t  bus_space_read_1(sc->sc_iot, sc->sc_ppi_ioh, 0)\n\t\t\t  & ~PIT_SPKR);\n\tsc->sc_bellactive = 0;\n\tif (sc->sc_slp)\n\t\twakeup(pcppi_bell_stop);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/i8253reg.h>",
            "#include <dev/isa/pcppivar.h>",
            "#include <dev/isa/pcppireg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pcppi_bell_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i8253reg.h>\n#include <dev/isa/pcppivar.h>\n#include <dev/isa/pcppireg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void pcppi_bell_stop;\n\nstatic void\npcppi_bell_stop(arg)\n\tvoid *arg;\n{\n\tstruct pcppi_softc *sc = arg;\n\tint s;\n\n\ts = spltty(); /* ??? */\n\t/* disable bell */\n\tbus_space_write_1(sc->sc_iot, sc->sc_ppi_ioh, 0,\n\t\t\t  bus_space_read_1(sc->sc_iot, sc->sc_ppi_ioh, 0)\n\t\t\t  & ~PIT_SPKR);\n\tsc->sc_bellactive = 0;\n\tif (sc->sc_slp)\n\t\twakeup(pcppi_bell_stop);\n\tsplx(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/spkrio.h>\n#include <dev/isa/pcppivar.h>\n#include <sys/conf.h>\n#include <sys/ioctl.h>\n#include <sys/proc.h>\n#include <sys/uio.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic pcppi_tag_t ppicookie;\nstatic void tone;\n\nstatic\nvoid tone(hz, ticks)\n/* emit tone of frequency hz for given number of ticks */\n    u_int hz, ticks;\n{\n\tpcppi_bell(ppicookie, hz, ticks, 1);\n}"
  }
]