[
  {
    "function_name": "wdc_ata_delref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
    "lines": "772-779",
    "snippet": "void\nwdc_ata_delref(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\twdc_delref(chp);\n}",
    "includes": [
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_delref",
          "args": [
            "chp"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_delref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1700-1713",
          "snippet": "void\nwdc_delref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt-- == 1 &&\n\t    adapter->scsipi_enable != NULL)\n\t\t(void) (*adapter->scsipi_enable)(wdc, 0);\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_delref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt-- == 1 &&\n\t    adapter->scsipi_enable != NULL)\n\t\t(void) (*adapter->scsipi_enable)(wdc, 0);\n\tsplx(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_ata_delref(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\twdc_delref(chp);\n}"
  },
  {
    "function_name": "wdc_ata_addref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
    "lines": "763-770",
    "snippet": "int\nwdc_ata_addref(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\treturn (wdc_addref(chp));\n}",
    "includes": [
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_addref",
          "args": [
            "chp"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_addref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1681-1698",
          "snippet": "int\nwdc_addref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc; \n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s, error = 0;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt++ == 0 &&\n\t    adapter->scsipi_enable != NULL) {\n\t\terror = (*adapter->scsipi_enable)(wdc, 1);\n\t\tif (error)\n\t\t\tadapter->scsipi_refcnt--;\n\t}\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwdc_addref(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_softc *wdc = chp->wdc; \n\tstruct scsipi_adapter *adapter = &wdc->sc_atapi_adapter;\n\tint s, error = 0;\n\n\ts = splbio();\n\tif (adapter->scsipi_refcnt++ == 0 &&\n\t    adapter->scsipi_enable != NULL) {\n\t\terror = (*adapter->scsipi_enable)(wdc, 1);\n\t\tif (error)\n\t\t\tadapter->scsipi_refcnt--;\n\t}\n\tsplx(s);\n\treturn (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwdc_ata_addref(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\treturn (wdc_addref(chp));\n}"
  },
  {
    "function_name": "wdc_ata_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
    "lines": "723-760",
    "snippet": "int\nwdc_ata_err(drvp, ata_bio)\n\tstruct ata_drive_datas *drvp;\n\tstruct ata_bio *ata_bio;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tata_bio->error = 0;\n\tif (chp->ch_status & WDCS_BSY) {\n\t\tata_bio->error = TIMEOUT;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_DWF) {\n\t\tata_bio->error = ERR_DF;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_ERR) {\n\t\tata_bio->error = ERROR;\n\t\tata_bio->r_error = chp->ch_error;\n\t\tif (drvp->drive_flags & DRIVE_UDMA &&\n\t\t    (ata_bio->r_error & WDCE_CRC)) {\n\t\t\t/*\n\t\t\t * Record the CRC error, to avoid downgrading to\n\t\t\t * multiword DMA\n\t\t\t */\n\t\t\tdrvp->drive_flags |= DRIVE_DMAERR;\n\t\t}\n\t\tif (ata_bio->r_error & (WDCE_BBK | WDCE_UNC | WDCE_IDNF |\n\t\t    WDCE_ABRT | WDCE_TK0NF | WDCE_AMNF))\n\t\t\treturn WDC_ATA_ERR;\n\t\treturn WDC_ATA_NOERR;\n\t}\n\n\tif (chp->ch_status & WDCS_CORR)\n\t\tata_bio->flags |= ATA_CORR;\n\treturn WDC_ATA_NOERR;\n}",
    "includes": [
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define WDC_ATA_ERR   0x02 /* Drive reports an error */",
      "#define WDC_ATA_NOERR 0x00 /* Drive doesn't report an error */"
    ],
    "globals_used": [
      "int   wdc_ata_err"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_ATA_ERR   0x02 /* Drive reports an error */\n#define WDC_ATA_NOERR 0x00 /* Drive doesn't report an error */\n\nint   wdc_ata_err;\n\nint\nwdc_ata_err(drvp, ata_bio)\n\tstruct ata_drive_datas *drvp;\n\tstruct ata_bio *ata_bio;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tata_bio->error = 0;\n\tif (chp->ch_status & WDCS_BSY) {\n\t\tata_bio->error = TIMEOUT;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_DWF) {\n\t\tata_bio->error = ERR_DF;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_ERR) {\n\t\tata_bio->error = ERROR;\n\t\tata_bio->r_error = chp->ch_error;\n\t\tif (drvp->drive_flags & DRIVE_UDMA &&\n\t\t    (ata_bio->r_error & WDCE_CRC)) {\n\t\t\t/*\n\t\t\t * Record the CRC error, to avoid downgrading to\n\t\t\t * multiword DMA\n\t\t\t */\n\t\t\tdrvp->drive_flags |= DRIVE_DMAERR;\n\t\t}\n\t\tif (ata_bio->r_error & (WDCE_BBK | WDCE_UNC | WDCE_IDNF |\n\t\t    WDCE_ABRT | WDCE_TK0NF | WDCE_AMNF))\n\t\t\treturn WDC_ATA_ERR;\n\t\treturn WDC_ATA_NOERR;\n\t}\n\n\tif (chp->ch_status & WDCS_CORR)\n\t\tata_bio->flags |= ATA_CORR;\n\treturn WDC_ATA_NOERR;\n}"
  },
  {
    "function_name": "wdc_ata_ctrl_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
    "lines": "573-721",
    "snippet": "int\nwdc_ata_ctrl_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tchar *errstring = NULL;\n\tint delay = (irq == 0) ? ATA_DELAY : 0;\n\n\tWDCDEBUG_PRINT((\"wdc_ata_ctrl_intr: state %d\\n\", drvp->state),\n\t    DEBUG_FUNCS);\n\nagain:\n\tswitch (drvp->state) {\n\tcase RECAL:    /* Should not be in this state here */\n\t\tpanic(\"wdc_ata_ctrl_intr: state==RECAL\");\n\t\tbreak;\n\n\tcase RECAL_WAIT:\n\t\terrstring = \"recal\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase PIOMODE:\n\t\t/* Don't try to set modes if controller can't be adjusted */\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\t\tgoto geometry;\n\t\t/* Also don't try if the drive didn't report its mode */\n\t\tif ((drvp->drive_flags & DRIVE_MODE) == 0)\n\t\t\tgoto geometry;\n\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t    0x08 | drvp->PIO_mode, WDSF_SET_MODE);\n\t\tdrvp->state = PIOMODE_WAIT;\n\t\tbreak;\n\n\tcase PIOMODE_WAIT:\n\t\terrstring = \"piomode\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase DMAMODE:\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x40 | drvp->UDMA_mode, WDSF_SET_MODE);\n\t\t} else if (drvp->drive_flags & DRIVE_DMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x20 | drvp->DMA_mode, WDSF_SET_MODE);\n\t\t} else {\n\t\t\tgoto geometry;\n\t\t}\t\n\t\tdrvp->state = DMAMODE_WAIT;\n\t\tbreak;\n\tcase DMAMODE_WAIT:\n\t\terrstring = \"dmamode\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase GEOMETRY:\n\tgeometry:\n\t\tif (ata_bio->flags & ATA_LBA)\n\t\t\tgoto multimode;\n\t\twdccommand(chp, xfer->drive, WDCC_IDP,\n\t\t    ata_bio->lp->d_ncylinders,\n\t\t    ata_bio->lp->d_ntracks - 1, 0, ata_bio->lp->d_nsectors,\n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t\tata_bio->lp->d_precompcyl / 4 : 0);\n\t\tdrvp->state = GEOMETRY_WAIT;\n\t\tbreak;\n\n\tcase GEOMETRY_WAIT:\n\t\terrstring = \"geometry\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t\t/* fall through */\n\n\tcase MULTIMODE:\n\tmultimode:\n\t\tif (ata_bio->multi == 1)\n\t\t\tgoto ready;\n\t\twdccommand(chp, xfer->drive, WDCC_SETMULTI, 0, 0, 0,\n\t\t    ata_bio->multi, 0);\n\t\tdrvp->state = MULTIMODE_WAIT;\n\t\tbreak;\n\n\tcase MULTIMODE_WAIT:\n\t\terrstring = \"setmulti\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t\t/* fall through */\n\n\tcase READY:\n\tready:\n\t\tdrvp->state = READY;\n\t\t/*\n\t\t * The drive is usable now\n\t\t */\n\t\txfer->c_intr = wdc_ata_bio_intr;\n\t\t_wdc_ata_bio_start(chp, xfer); \n\t\treturn 1;\n\t}\n\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\tgoto again;\n\t}\n\treturn 1;\n\ntimeout:\n\tif (irq && (xfer->c_flags & C_TIMEOU) == 0) {\n\t\treturn 0; /* IRQ was not for us */\n\t}\n\tprintf(\"%s:%d:%d: %s timed out\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, errstring);\n\tata_bio->error = TIMEOUT;\n\tdrvp->state = 0;\n\twdc_ata_bio_done(chp, xfer);\n\treturn 0;\nerror:\n\tprintf(\"%s:%d:%d: %s \",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    errstring);\n\tif (chp->ch_status & WDCS_DWF) {\n\t\tprintf(\"drive fault\\n\");\n\t\tata_bio->error = ERR_DF;\n\t} else {\n\t\tprintf(\"error (%x)\\n\", chp->ch_error);\n\t\tata_bio->r_error = chp->ch_error;\n\t\tata_bio->error = ERROR;\n\t}\n\tdrvp->state = 0;\n\twdc_ata_bio_done(chp, xfer);\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define ATA_DELAY 10000 /* 10s for a drive I/O */",
      "#define DEBUG_FUNCS  0x08"
    ],
    "globals_used": [
      "void  _wdc_ata_bio_start",
      "int   wdc_ata_bio_intr",
      "void  wdc_ata_bio_done",
      "int   wdc_ata_ctrl_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_ata_bio_done",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_bio_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "533-568",
          "snippet": "void\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [
            "void  wdc_ata_bio_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid  wdc_ata_bio_done;\n\nvoid\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"error (%x)\\n\"",
            "chp->ch_error"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_wdc_ata_bio_start",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "_wdc_ata_bio_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "174-371",
          "snippet": "void\n_wdc_ata_bio_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tu_int16_t cyl;\n\tu_int8_t head, sect, cmd = 0;\n\tint nblks;\n\tint ata_delay;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"_wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\t/* Do control operations specially. */\n\tif (drvp->state < READY) {\n\t\t/*\n\t\t * Actually, we want to be careful not to mess with the control\n\t\t * state if the device is currently busy, but we can assume\n\t\t * that we never get to this point if that's the case.\n\t\t */\n\t\t/* at this point, we should only be in RECAL state */\n\t\tif (drvp->state != RECAL) {\n\t\t\tprintf(\"%s:%d:%d: bad state %d in _wdc_ata_bio_start\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, drvp->state);\n\t\t\tpanic(\"_wdc_ata_bio_start: bad state\");\n\t\t}\n\t\txfer->c_intr = wdc_ata_ctrl_intr;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, ATA_DELAY) != 0)\n\t\t\tgoto timeout;\n\t\twdccommandshort(chp, xfer->drive, WDCC_RECAL);\n\t\tdrvp->state = RECAL_WAIT;\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t} else {\n\t\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\t\tDELAY(1);\n\t\t\twdc_ata_ctrl_intr(chp, xfer, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\tif (ata_bio->flags & ATA_SINGLE)\n\t\tata_delay = ATA_DELAY;\n\telse\n\t\tata_delay = ATA_DELAY;\n again:\n\t/*\n\t *\n\t * When starting a multi-sector transfer, or doing single-sector\n\t * transfers...\n\t */\n\tif (xfer->c_skip == 0 || (ata_bio->flags & ATA_SINGLE) != 0) {\n\t\tif (ata_bio->flags & ATA_SINGLE)\n\t\t\tnblks = 1;\n\t\telse \n\t\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\t/* Check for bad sectors and adjust transfer, if necessary. */\n\t\tif ((ata_bio->lp->d_flags & D_BADSECT) != 0) {\n\t\t\tlong blkdiff;\n\t\t\tint i;\n\t\t\tfor (i = 0; (blkdiff = ata_bio->badsect[i]) != -1;\n\t\t\t     i++) {\n\t\t\t\tblkdiff -= ata_bio->blkno;\n\t\t\t\tif (blkdiff < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (blkdiff == 0) {\n\t\t\t\t\t/* Replace current block of transfer. */\n\t\t\t\t\tata_bio->blkno =\n\t\t\t\t\t    ata_bio->lp->d_secperunit -\n\t\t\t\t\t    ata_bio->lp->d_nsectors - i - 1;\n\t\t\t\t}\n\t\t\t\tif (blkdiff < nblks) {\n\t\t\t\t\t/* Bad block inside transfer. */\n\t\t\t\t\tata_bio->flags |= ATA_SINGLE;\n\t\t\t\t\tnblks = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Transfer is okay now. */\n\t\t}\n\t\tif (ata_bio->flags & ATA_LBA) {\n\t\t\tsect = (ata_bio->blkno >> 0) & 0xff;\n\t\t\tcyl = (ata_bio->blkno >> 8) & 0xffff;\n\t\t\thead = (ata_bio->blkno >> 24) & 0x0f;\n\t\t\thead |= WDSD_LBA;\n\t\t} else {\n\t\t\tint blkno = ata_bio->blkno;\n\t\t\tsect = blkno % ata_bio->lp->d_nsectors;\n\t\t\tsect++;    /* Sectors begin with 1, not 0. */\n\t\t\tblkno /= ata_bio->lp->d_nsectors;\n\t\t\thead = blkno % ata_bio->lp->d_ntracks;\n\t\t\tblkno /= ata_bio->lp->d_ntracks;\n\t\t\tcyl = blkno;\n\t\t\thead |= WDSD_CHS;\n\t\t}\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READDMA : WDCC_WRITEDMA;\n\t\t\tnblks = ata_bio->nblks;\n\t    \t\t/* Init the DMA channel. */\n\t\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip, \n\t\t\t    ata_bio->nbytes, dma_flags) != 0) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tata_bio->r_error = 0;\n\t\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Initiate command */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, \n\t\t\t    WDSD_IBM | (xfer->drive << 4));\n\t\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\t\tgoto timeout;\n\t\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t\t    head, sect, nblks, 0);\n\t\t\t/* start the DMA channel */\n\t\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\t/* wait for irq */\n\t\t\tgoto intr;\n\t\t} /* else not DMA */\n\t\tata_bio->nblks = min(nblks, ata_bio->multi);\n\t\tata_bio->nbytes = ata_bio->nblks * ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > 1 && (ata_bio->flags & ATA_SINGLE) == 0) {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READMULTI : WDCC_WRITEMULTI;\n\t\t} else {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READ : WDCC_WRITE;\n\t\t}\n\t\t/* Initiate command! */\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\tgoto timeout;\n\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t    head, sect, nblks, \n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t    ata_bio->lp->d_precompcyl / 4 : 0);\n\t} else if (ata_bio->nblks > 1) {\n\t\t/* The number of blocks in the last stretch may be smaller. */\n\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > nblks) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t}\n\t}\n\t/* If this was a write and not using DMA, push the data. */\n\tif ((ata_bio->flags & ATA_READ) == 0) {\n\t\tif (wait_for_drq(chp, ata_delay) != 0) {\n\t\t\tprintf(\"%s:%d:%d: timeout waiting for DRQ, \"\n\t\t\t    \"st=0x%02x, err=0x%02x\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, chp->ch_status, chp->ch_error);\n\t\t\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\tif (wdc_ata_err(drvp, ata_bio) == WDC_ATA_ERR) {\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\twdc_output_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\n\n intr:\t/* Wait for IRQ (either real or polled) */\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\tdelay(1);\n\t\twdc_ata_bio_intr(chp, xfer, 0);\n\t\tif ((ata_bio->flags & ATA_ITSDONE) == 0)\n\t\t\tgoto again;\n\t}\n\treturn;\n timeout:\n\tprintf(\"%s:%d:%d: not ready, st=0x%02x, err=0x%02x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    chp->ch_status, chp->ch_error);\n\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\tata_bio->error = TIMEOUT;\n\twdc_ata_bio_done(chp, xfer);\n\treturn;\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WDC_ATA_ERR   0x02 /* Drive reports an error */",
            "#define ATA_DELAY 10000 /* 10s for a drive I/O */",
            "#define DEBUG_XFERS  0x02",
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [
            "void  _wdc_ata_bio_start",
            "int   wdc_ata_bio_intr",
            "void  wdc_ata_bio_done",
            "int   wdc_ata_ctrl_intr",
            "int   wdc_ata_err"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_ATA_ERR   0x02 /* Drive reports an error */\n#define ATA_DELAY 10000 /* 10s for a drive I/O */\n#define DEBUG_XFERS  0x02\n#define DEBUG_INTR   0x01\n\nvoid  _wdc_ata_bio_start;\nint   wdc_ata_bio_intr;\nvoid  wdc_ata_bio_done;\nint   wdc_ata_ctrl_intr;\nint   wdc_ata_err;\n\nvoid\n_wdc_ata_bio_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tu_int16_t cyl;\n\tu_int8_t head, sect, cmd = 0;\n\tint nblks;\n\tint ata_delay;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"_wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\t/* Do control operations specially. */\n\tif (drvp->state < READY) {\n\t\t/*\n\t\t * Actually, we want to be careful not to mess with the control\n\t\t * state if the device is currently busy, but we can assume\n\t\t * that we never get to this point if that's the case.\n\t\t */\n\t\t/* at this point, we should only be in RECAL state */\n\t\tif (drvp->state != RECAL) {\n\t\t\tprintf(\"%s:%d:%d: bad state %d in _wdc_ata_bio_start\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, drvp->state);\n\t\t\tpanic(\"_wdc_ata_bio_start: bad state\");\n\t\t}\n\t\txfer->c_intr = wdc_ata_ctrl_intr;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, ATA_DELAY) != 0)\n\t\t\tgoto timeout;\n\t\twdccommandshort(chp, xfer->drive, WDCC_RECAL);\n\t\tdrvp->state = RECAL_WAIT;\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t} else {\n\t\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\t\tDELAY(1);\n\t\t\twdc_ata_ctrl_intr(chp, xfer, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\tif (ata_bio->flags & ATA_SINGLE)\n\t\tata_delay = ATA_DELAY;\n\telse\n\t\tata_delay = ATA_DELAY;\n again:\n\t/*\n\t *\n\t * When starting a multi-sector transfer, or doing single-sector\n\t * transfers...\n\t */\n\tif (xfer->c_skip == 0 || (ata_bio->flags & ATA_SINGLE) != 0) {\n\t\tif (ata_bio->flags & ATA_SINGLE)\n\t\t\tnblks = 1;\n\t\telse \n\t\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\t/* Check for bad sectors and adjust transfer, if necessary. */\n\t\tif ((ata_bio->lp->d_flags & D_BADSECT) != 0) {\n\t\t\tlong blkdiff;\n\t\t\tint i;\n\t\t\tfor (i = 0; (blkdiff = ata_bio->badsect[i]) != -1;\n\t\t\t     i++) {\n\t\t\t\tblkdiff -= ata_bio->blkno;\n\t\t\t\tif (blkdiff < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (blkdiff == 0) {\n\t\t\t\t\t/* Replace current block of transfer. */\n\t\t\t\t\tata_bio->blkno =\n\t\t\t\t\t    ata_bio->lp->d_secperunit -\n\t\t\t\t\t    ata_bio->lp->d_nsectors - i - 1;\n\t\t\t\t}\n\t\t\t\tif (blkdiff < nblks) {\n\t\t\t\t\t/* Bad block inside transfer. */\n\t\t\t\t\tata_bio->flags |= ATA_SINGLE;\n\t\t\t\t\tnblks = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Transfer is okay now. */\n\t\t}\n\t\tif (ata_bio->flags & ATA_LBA) {\n\t\t\tsect = (ata_bio->blkno >> 0) & 0xff;\n\t\t\tcyl = (ata_bio->blkno >> 8) & 0xffff;\n\t\t\thead = (ata_bio->blkno >> 24) & 0x0f;\n\t\t\thead |= WDSD_LBA;\n\t\t} else {\n\t\t\tint blkno = ata_bio->blkno;\n\t\t\tsect = blkno % ata_bio->lp->d_nsectors;\n\t\t\tsect++;    /* Sectors begin with 1, not 0. */\n\t\t\tblkno /= ata_bio->lp->d_nsectors;\n\t\t\thead = blkno % ata_bio->lp->d_ntracks;\n\t\t\tblkno /= ata_bio->lp->d_ntracks;\n\t\t\tcyl = blkno;\n\t\t\thead |= WDSD_CHS;\n\t\t}\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READDMA : WDCC_WRITEDMA;\n\t\t\tnblks = ata_bio->nblks;\n\t    \t\t/* Init the DMA channel. */\n\t\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip, \n\t\t\t    ata_bio->nbytes, dma_flags) != 0) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tata_bio->r_error = 0;\n\t\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Initiate command */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, \n\t\t\t    WDSD_IBM | (xfer->drive << 4));\n\t\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\t\tgoto timeout;\n\t\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t\t    head, sect, nblks, 0);\n\t\t\t/* start the DMA channel */\n\t\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\t/* wait for irq */\n\t\t\tgoto intr;\n\t\t} /* else not DMA */\n\t\tata_bio->nblks = min(nblks, ata_bio->multi);\n\t\tata_bio->nbytes = ata_bio->nblks * ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > 1 && (ata_bio->flags & ATA_SINGLE) == 0) {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READMULTI : WDCC_WRITEMULTI;\n\t\t} else {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READ : WDCC_WRITE;\n\t\t}\n\t\t/* Initiate command! */\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\tgoto timeout;\n\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t    head, sect, nblks, \n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t    ata_bio->lp->d_precompcyl / 4 : 0);\n\t} else if (ata_bio->nblks > 1) {\n\t\t/* The number of blocks in the last stretch may be smaller. */\n\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > nblks) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t}\n\t}\n\t/* If this was a write and not using DMA, push the data. */\n\tif ((ata_bio->flags & ATA_READ) == 0) {\n\t\tif (wait_for_drq(chp, ata_delay) != 0) {\n\t\t\tprintf(\"%s:%d:%d: timeout waiting for DRQ, \"\n\t\t\t    \"st=0x%02x, err=0x%02x\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, chp->ch_status, chp->ch_error);\n\t\t\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\tif (wdc_ata_err(drvp, ata_bio) == WDC_ATA_ERR) {\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\twdc_output_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\n\n intr:\t/* Wait for IRQ (either real or polled) */\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\tdelay(1);\n\t\twdc_ata_bio_intr(chp, xfer, 0);\n\t\tif ((ata_bio->flags & ATA_ITSDONE) == 0)\n\t\t\tgoto again;\n\t}\n\treturn;\n timeout:\n\tprintf(\"%s:%d:%d: not ready, st=0x%02x, err=0x%02x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    chp->ch_status, chp->ch_error);\n\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\tata_bio->error = TIMEOUT;\n\twdc_ata_bio_done(chp, xfer);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdcwait",
          "args": [
            "chp",
            "WDCS_DRDY",
            "WDCS_DRDY",
            "delay"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "wdcwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "879-950",
          "snippet": "int\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_STATUSX 0x20",
            "#define DEBUG_STATUS 0x04",
            "#define WDCNDELAY_DEBUG\t50",
            "#define WDCDELAY  100 /* 100 microseconds */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_STATUSX 0x20\n#define DEBUG_STATUS 0x04\n#define WDCNDELAY_DEBUG\t50\n#define WDCDELAY  100 /* 100 microseconds */\n\nint\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdccommand",
          "args": [
            "chp",
            "xfer->drive",
            "WDCC_SETMULTI",
            "0",
            "0",
            "0",
            "ata_bio->multi",
            "0"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "wdccommandshort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1534-1548",
          "snippet": "void\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wdc_ata_ctrl_intr: state==RECAL\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_ata_ctrl_intr: state %d\\n\", drvp->state)",
            "DEBUG_FUNCS"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ATA_DELAY 10000 /* 10s for a drive I/O */\n#define DEBUG_FUNCS  0x08\n\nvoid  _wdc_ata_bio_start;\nint   wdc_ata_bio_intr;\nvoid  wdc_ata_bio_done;\nint   wdc_ata_ctrl_intr;\n\nint\nwdc_ata_ctrl_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tchar *errstring = NULL;\n\tint delay = (irq == 0) ? ATA_DELAY : 0;\n\n\tWDCDEBUG_PRINT((\"wdc_ata_ctrl_intr: state %d\\n\", drvp->state),\n\t    DEBUG_FUNCS);\n\nagain:\n\tswitch (drvp->state) {\n\tcase RECAL:    /* Should not be in this state here */\n\t\tpanic(\"wdc_ata_ctrl_intr: state==RECAL\");\n\t\tbreak;\n\n\tcase RECAL_WAIT:\n\t\terrstring = \"recal\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase PIOMODE:\n\t\t/* Don't try to set modes if controller can't be adjusted */\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\t\tgoto geometry;\n\t\t/* Also don't try if the drive didn't report its mode */\n\t\tif ((drvp->drive_flags & DRIVE_MODE) == 0)\n\t\t\tgoto geometry;\n\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t    0x08 | drvp->PIO_mode, WDSF_SET_MODE);\n\t\tdrvp->state = PIOMODE_WAIT;\n\t\tbreak;\n\n\tcase PIOMODE_WAIT:\n\t\terrstring = \"piomode\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase DMAMODE:\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x40 | drvp->UDMA_mode, WDSF_SET_MODE);\n\t\t} else if (drvp->drive_flags & DRIVE_DMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x20 | drvp->DMA_mode, WDSF_SET_MODE);\n\t\t} else {\n\t\t\tgoto geometry;\n\t\t}\t\n\t\tdrvp->state = DMAMODE_WAIT;\n\t\tbreak;\n\tcase DMAMODE_WAIT:\n\t\terrstring = \"dmamode\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase GEOMETRY:\n\tgeometry:\n\t\tif (ata_bio->flags & ATA_LBA)\n\t\t\tgoto multimode;\n\t\twdccommand(chp, xfer->drive, WDCC_IDP,\n\t\t    ata_bio->lp->d_ncylinders,\n\t\t    ata_bio->lp->d_ntracks - 1, 0, ata_bio->lp->d_nsectors,\n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t\tata_bio->lp->d_precompcyl / 4 : 0);\n\t\tdrvp->state = GEOMETRY_WAIT;\n\t\tbreak;\n\n\tcase GEOMETRY_WAIT:\n\t\terrstring = \"geometry\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t\t/* fall through */\n\n\tcase MULTIMODE:\n\tmultimode:\n\t\tif (ata_bio->multi == 1)\n\t\t\tgoto ready;\n\t\twdccommand(chp, xfer->drive, WDCC_SETMULTI, 0, 0, 0,\n\t\t    ata_bio->multi, 0);\n\t\tdrvp->state = MULTIMODE_WAIT;\n\t\tbreak;\n\n\tcase MULTIMODE_WAIT:\n\t\terrstring = \"setmulti\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t\t/* fall through */\n\n\tcase READY:\n\tready:\n\t\tdrvp->state = READY;\n\t\t/*\n\t\t * The drive is usable now\n\t\t */\n\t\txfer->c_intr = wdc_ata_bio_intr;\n\t\t_wdc_ata_bio_start(chp, xfer); \n\t\treturn 1;\n\t}\n\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\tgoto again;\n\t}\n\treturn 1;\n\ntimeout:\n\tif (irq && (xfer->c_flags & C_TIMEOU) == 0) {\n\t\treturn 0; /* IRQ was not for us */\n\t}\n\tprintf(\"%s:%d:%d: %s timed out\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, errstring);\n\tata_bio->error = TIMEOUT;\n\tdrvp->state = 0;\n\twdc_ata_bio_done(chp, xfer);\n\treturn 0;\nerror:\n\tprintf(\"%s:%d:%d: %s \",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    errstring);\n\tif (chp->ch_status & WDCS_DWF) {\n\t\tprintf(\"drive fault\\n\");\n\t\tata_bio->error = ERR_DF;\n\t} else {\n\t\tprintf(\"error (%x)\\n\", chp->ch_error);\n\t\tata_bio->r_error = chp->ch_error;\n\t\tata_bio->error = ERROR;\n\t}\n\tdrvp->state = 0;\n\twdc_ata_bio_done(chp, xfer);\n\treturn 1;\n}"
  },
  {
    "function_name": "wdc_ata_bio_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
    "lines": "533-568",
    "snippet": "void\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}",
    "includes": [
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void  wdc_ata_bio_done"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdcstart",
          "args": [
            "chp"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "wdcstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "664-710",
          "snippet": "void\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid\nwdcstart(chp)\n\tstruct channel_softc *chp;\n{\n\tstruct wdc_xfer *xfer;\n\n#ifdef WDC_DIAGNOSTIC\n\tint spl1, spl2;\n\n\tspl1 = splbio();\n\tspl2 = splbio();\n\tif (spl2 != spl1) {\n\t\tprintf(\"wdcstart: not at splbio()\\n\");\n\t\tpanic(\"wdcstart\");\n\t}\n\tsplx(spl2);\n\tsplx(spl1);\n#endif /* WDC_DIAGNOSTIC */\n\n\t/* is there a xfer ? */\n\tif ((xfer = chp->ch_queue->sc_xfer.tqh_first) == NULL) {\n\t\treturn;\n\t}\n\n\t/* adjust chp, in case we have a shared queue */\n\tchp = xfer->chp;\n\n\tif ((chp->ch_flags & WDCF_ACTIVE) != 0 ) {\n\t\treturn; /* channel already active */\n\t}\n#ifdef DIAGNOSTIC\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0)\n\t\tpanic(\"wdcstart: channel waiting for irq\\n\");\n#endif\n\tif (chp->wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\tif (!(chp->wdc->claim_hw)(chp, 0))\n\t\t\treturn;\n\n\tWDCDEBUG_PRINT((\"wdcstart: xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\tchp->ch_flags |= WDCF_ACTIVE;\n\tif (chp->ch_drive[xfer->drive].drive_flags & DRIVE_RESET) {\n\t\tchp->ch_drive[xfer->drive].drive_flags &= ~DRIVE_RESET;\n\t\tchp->ch_drive[xfer->drive].state = 0;\n\t}\n\txfer->c_start(chp, xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags)",
            "DEBUG_XFERS"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wddone",
          "args": [
            "ata_bio->wd"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "wddone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "601-659",
          "snippet": "void\nwddone(v)\n\tvoid *v;\n{\n\tstruct wd_softc *wd = v;\n\tstruct buf *bp = wd->sc_bp;\n\tchar buf[256], *errbuf = buf;\n\tWDCDEBUG_PRINT((\"wddone %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\n\tbp->b_resid = wd->sc_wdc_bio.bcount;\n\terrbuf[0] = '\\0';\n\tswitch (wd->sc_wdc_bio.error) {\n\tcase ERR_NODEV:\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = ENXIO;\n\t\tbreak;\n\tcase ERR_DMA:\n\t\terrbuf = \"DMA error\";\n\t\tgoto retry;\n\tcase ERR_DF:\n\t\terrbuf = \"device fault\";\n\t\tgoto retry;\n\tcase TIMEOUT:\n\t\terrbuf = \"device timeout\";\n\t\tgoto retry;\n\tcase ERROR:\n\t\t/* Don't care about media change bits */\n\t\tif (wd->sc_wdc_bio.r_error != 0 &&\n\t\t    (wd->sc_wdc_bio.r_error & ~(WDCE_MC | WDCE_MCR)) == 0)\n\t\t\tgoto noerror;\n\t\tata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);\nretry:\n\t\t/* Just reset and retry. Can we do more ? */\n\t\twdc_reset_channel(wd->drvp);\n\t\tdiskerr(bp, \"wd\", errbuf, LOG_PRINTF,\n\t\t    wd->sc_wdc_bio.blkdone, wd->sc_dk.dk_label);\n\t\tif (wd->retries++ < WDIORETRIES) {\n\t\t\tprintf(\", retrying\\n\");\n\t\t\ttimeout(wdrestart, wd, RECOVERYTIME);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tbreak;\n\tcase NOERROR:\nnoerror:\tif ((wd->sc_wdc_bio.flags & ATA_CORR) || wd->retries > 0)\n\t\t\tprintf(\"%s: soft error (corrected)\\n\",\n\t\t\t    wd->sc_dev.dv_xname);\n\t}\n\tdisk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));\n#if NRND > 0\n\trnd_add_uint32(&wd->rnd_source, bp->b_blkno);\n#endif\n\tbiodone(bp);\n\twd->openings++;\n\twdstart(wd);\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02",
            "#define\tRECOVERYTIME hz/2\t/* time to wait before retrying a cmd */",
            "#define\tWDIORETRIES\t5\t/* number of retries before giving up */"
          ],
          "globals_used": [
            "void  wdstart",
            "void  wdrestart",
            "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_XFERS  0x02\n#define\tRECOVERYTIME hz/2\t/* time to wait before retrying a cmd */\n#define\tWDIORETRIES\t5\t/* number of retries before giving up */\n\nvoid  wdstart;\nvoid  wdrestart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\nwddone(v)\n\tvoid *v;\n{\n\tstruct wd_softc *wd = v;\n\tstruct buf *bp = wd->sc_bp;\n\tchar buf[256], *errbuf = buf;\n\tWDCDEBUG_PRINT((\"wddone %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\n\tbp->b_resid = wd->sc_wdc_bio.bcount;\n\terrbuf[0] = '\\0';\n\tswitch (wd->sc_wdc_bio.error) {\n\tcase ERR_NODEV:\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = ENXIO;\n\t\tbreak;\n\tcase ERR_DMA:\n\t\terrbuf = \"DMA error\";\n\t\tgoto retry;\n\tcase ERR_DF:\n\t\terrbuf = \"device fault\";\n\t\tgoto retry;\n\tcase TIMEOUT:\n\t\terrbuf = \"device timeout\";\n\t\tgoto retry;\n\tcase ERROR:\n\t\t/* Don't care about media change bits */\n\t\tif (wd->sc_wdc_bio.r_error != 0 &&\n\t\t    (wd->sc_wdc_bio.r_error & ~(WDCE_MC | WDCE_MCR)) == 0)\n\t\t\tgoto noerror;\n\t\tata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);\nretry:\n\t\t/* Just reset and retry. Can we do more ? */\n\t\twdc_reset_channel(wd->drvp);\n\t\tdiskerr(bp, \"wd\", errbuf, LOG_PRINTF,\n\t\t    wd->sc_wdc_bio.blkdone, wd->sc_dk.dk_label);\n\t\tif (wd->retries++ < WDIORETRIES) {\n\t\t\tprintf(\", retrying\\n\");\n\t\t\ttimeout(wdrestart, wd, RECOVERYTIME);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tbreak;\n\tcase NOERROR:\nnoerror:\tif ((wd->sc_wdc_bio.flags & ATA_CORR) || wd->retries > 0)\n\t\t\tprintf(\"%s: soft error (corrected)\\n\",\n\t\t\t    wd->sc_dev.dv_xname);\n\t}\n\tdisk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));\n#if NRND > 0\n\trnd_add_uint32(&wd->rnd_source, bp->b_blkno);\n#endif\n\tbiodone(bp);\n\twd->openings++;\n\twdstart(wd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_ata_done: wddone\\n\")",
            "DEBUG_XFERS"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_free_xfer",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1617-1633",
          "snippet": "void\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_downgrade_mode",
          "args": [
            "drvp"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_downgrade_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1252-1304",
          "snippet": "int\nwdc_downgrade_mode(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint cf_flags = drvp->cf_flags;\n\n\t/* if drive or controller don't know its mode, we can't do much */\n\tif ((drvp->drive_flags & DRIVE_MODE) == 0 ||\n\t    (wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\treturn 0;\n\t/* current drive mode was set by a config flag, let it this way */\n\tif ((cf_flags & ATA_CONFIG_PIO_SET) ||\n\t    (cf_flags & ATA_CONFIG_DMA_SET) ||\n\t    (cf_flags & ATA_CONFIG_UDMA_SET))\n\t\treturn 0;\n\n\t/*\n\t * If we were using Ultra-DMA mode > 2, downgrade to mode 2 first.\n\t * Maybe we didn't properly notice the cable type\n\t */\n\tif ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode >= 2) {\n\t\tdrvp->UDMA_mode = (drvp->UDMA_mode == 2) ? 1 : 2;\n\t\tprintf(\"%s: transfer error, downgrading to Ultra-DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->UDMA_mode);\n\t} else \tif ((drvp->drive_flags & DRIVE_UDMA) &&\n\t    (drvp->drive_flags & DRIVE_DMAERR) == 0) {\n\t\t/* \n\t\t * If we were using ultra-DMA, don't downgrade to\n\t\t * multiword DMA if we noticed a CRC error. It has\n\t\t * been noticed that CRC errors in ultra-DMA lead to\n\t\t * silent data corruption in multiword DMA.  Data\n\t\t * corruption is less likely to occur in PIO mode.  \n\t\t */\n\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\tdrvp->DMA_mode = drvp->DMA_cap;\n\t\tprintf(\"%s: transfer error, downgrading to DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->DMA_mode);\n\t} else if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) {\n\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\tdrvp->PIO_mode = drvp->PIO_cap;\n\t\tprintf(\"%s: transfer error, downgrading to PIO mode %d\\n\",\n\t\t    drvp->drive_name, drvp->PIO_mode);\n\t} else /* already using PIO, can't downgrade */\n\t\treturn 0;\n\n\twdc->set_modes(chp);\n\t/* reset the channel, which will schedule all drives for setup */\n\twdc_reset_channel(drvp);\n\treturn 1;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nwdc_downgrade_mode(drvp)\n\tstruct ata_drive_datas *drvp;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint cf_flags = drvp->cf_flags;\n\n\t/* if drive or controller don't know its mode, we can't do much */\n\tif ((drvp->drive_flags & DRIVE_MODE) == 0 ||\n\t    (wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\treturn 0;\n\t/* current drive mode was set by a config flag, let it this way */\n\tif ((cf_flags & ATA_CONFIG_PIO_SET) ||\n\t    (cf_flags & ATA_CONFIG_DMA_SET) ||\n\t    (cf_flags & ATA_CONFIG_UDMA_SET))\n\t\treturn 0;\n\n\t/*\n\t * If we were using Ultra-DMA mode > 2, downgrade to mode 2 first.\n\t * Maybe we didn't properly notice the cable type\n\t */\n\tif ((drvp->drive_flags & DRIVE_UDMA) && drvp->UDMA_mode >= 2) {\n\t\tdrvp->UDMA_mode = (drvp->UDMA_mode == 2) ? 1 : 2;\n\t\tprintf(\"%s: transfer error, downgrading to Ultra-DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->UDMA_mode);\n\t} else \tif ((drvp->drive_flags & DRIVE_UDMA) &&\n\t    (drvp->drive_flags & DRIVE_DMAERR) == 0) {\n\t\t/* \n\t\t * If we were using ultra-DMA, don't downgrade to\n\t\t * multiword DMA if we noticed a CRC error. It has\n\t\t * been noticed that CRC errors in ultra-DMA lead to\n\t\t * silent data corruption in multiword DMA.  Data\n\t\t * corruption is less likely to occur in PIO mode.  \n\t\t */\n\t\tdrvp->drive_flags &= ~DRIVE_UDMA;\n\t\tdrvp->drive_flags |= DRIVE_DMA;\n\t\tdrvp->DMA_mode = drvp->DMA_cap;\n\t\tprintf(\"%s: transfer error, downgrading to DMA mode %d\\n\",\n\t\t    drvp->drive_name, drvp->DMA_mode);\n\t} else if (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) {\n\t\tdrvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);\n\t\tdrvp->PIO_mode = drvp->PIO_cap;\n\t\tprintf(\"%s: transfer error, downgrading to PIO mode %d\\n\",\n\t\t    drvp->drive_name, drvp->PIO_mode);\n\t} else /* already using PIO, can't downgrade */\n\t\treturn 0;\n\n\twdc->set_modes(chp);\n\t/* reset the channel, which will schedule all drives for setup */\n\twdc_reset_channel(drvp);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "wdctimeout",
            "chp"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags)",
            "DEBUG_XFERS"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid  wdc_ata_bio_done;\n\nvoid\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}"
  },
  {
    "function_name": "wdc_ata_bio_kill_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
    "lines": "513-531",
    "snippet": "void\nwdc_ata_bio_kill_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\n\tuntimeout(wdctimeout, chp);\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tata_bio->error = ERR_NODEV;\n\tata_bio->r_error = WDCE_ABRT;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n}",
    "includes": [
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void  wdc_ata_bio_kill_xfer"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wddone",
          "args": [
            "ata_bio->wd"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "wddone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/wd.c",
          "lines": "601-659",
          "snippet": "void\nwddone(v)\n\tvoid *v;\n{\n\tstruct wd_softc *wd = v;\n\tstruct buf *bp = wd->sc_bp;\n\tchar buf[256], *errbuf = buf;\n\tWDCDEBUG_PRINT((\"wddone %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\n\tbp->b_resid = wd->sc_wdc_bio.bcount;\n\terrbuf[0] = '\\0';\n\tswitch (wd->sc_wdc_bio.error) {\n\tcase ERR_NODEV:\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = ENXIO;\n\t\tbreak;\n\tcase ERR_DMA:\n\t\terrbuf = \"DMA error\";\n\t\tgoto retry;\n\tcase ERR_DF:\n\t\terrbuf = \"device fault\";\n\t\tgoto retry;\n\tcase TIMEOUT:\n\t\terrbuf = \"device timeout\";\n\t\tgoto retry;\n\tcase ERROR:\n\t\t/* Don't care about media change bits */\n\t\tif (wd->sc_wdc_bio.r_error != 0 &&\n\t\t    (wd->sc_wdc_bio.r_error & ~(WDCE_MC | WDCE_MCR)) == 0)\n\t\t\tgoto noerror;\n\t\tata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);\nretry:\n\t\t/* Just reset and retry. Can we do more ? */\n\t\twdc_reset_channel(wd->drvp);\n\t\tdiskerr(bp, \"wd\", errbuf, LOG_PRINTF,\n\t\t    wd->sc_wdc_bio.blkdone, wd->sc_dk.dk_label);\n\t\tif (wd->retries++ < WDIORETRIES) {\n\t\t\tprintf(\", retrying\\n\");\n\t\t\ttimeout(wdrestart, wd, RECOVERYTIME);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tbreak;\n\tcase NOERROR:\nnoerror:\tif ((wd->sc_wdc_bio.flags & ATA_CORR) || wd->retries > 0)\n\t\t\tprintf(\"%s: soft error (corrected)\\n\",\n\t\t\t    wd->sc_dev.dv_xname);\n\t}\n\tdisk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));\n#if NRND > 0\n\trnd_add_uint32(&wd->rnd_source, bp->b_blkno);\n#endif\n\tbiodone(bp);\n\twd->openings++;\n\twdstart(wd);\n}",
          "includes": [
            "#include \"locators.h\"",
            "#include <sys/ataio.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/vnode.h>",
            "#include <sys/rnd.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/uio.h>",
            "#include <sys/buf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"rnd.h\""
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02",
            "#define\tRECOVERYTIME hz/2\t/* time to wait before retrying a cmd */",
            "#define\tWDIORETRIES\t5\t/* number of retries before giving up */"
          ],
          "globals_used": [
            "void  wdstart",
            "void  wdrestart",
            "struct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locators.h\"\n#include <sys/ataio.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/wdvar.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/vnode.h>\n#include <sys/rnd.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/uio.h>\n#include <sys/buf.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"rnd.h\"\n\n#define DEBUG_XFERS  0x02\n#define\tRECOVERYTIME hz/2\t/* time to wait before retrying a cmd */\n#define\tWDIORETRIES\t5\t/* number of retries before giving up */\n\nvoid  wdstart;\nvoid  wdrestart;\nstruct wd_ioctl *\nwi_find(bp)\n\tstruct buf *bp;\n\nvoid\nwddone(v)\n\tvoid *v;\n{\n\tstruct wd_softc *wd = v;\n\tstruct buf *bp = wd->sc_bp;\n\tchar buf[256], *errbuf = buf;\n\tWDCDEBUG_PRINT((\"wddone %s\\n\", wd->sc_dev.dv_xname),\n\t    DEBUG_XFERS);\n\n\tbp->b_resid = wd->sc_wdc_bio.bcount;\n\terrbuf[0] = '\\0';\n\tswitch (wd->sc_wdc_bio.error) {\n\tcase ERR_NODEV:\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = ENXIO;\n\t\tbreak;\n\tcase ERR_DMA:\n\t\terrbuf = \"DMA error\";\n\t\tgoto retry;\n\tcase ERR_DF:\n\t\terrbuf = \"device fault\";\n\t\tgoto retry;\n\tcase TIMEOUT:\n\t\terrbuf = \"device timeout\";\n\t\tgoto retry;\n\tcase ERROR:\n\t\t/* Don't care about media change bits */\n\t\tif (wd->sc_wdc_bio.r_error != 0 &&\n\t\t    (wd->sc_wdc_bio.r_error & ~(WDCE_MC | WDCE_MCR)) == 0)\n\t\t\tgoto noerror;\n\t\tata_perror(wd->drvp, wd->sc_wdc_bio.r_error, errbuf);\nretry:\n\t\t/* Just reset and retry. Can we do more ? */\n\t\twdc_reset_channel(wd->drvp);\n\t\tdiskerr(bp, \"wd\", errbuf, LOG_PRINTF,\n\t\t    wd->sc_wdc_bio.blkdone, wd->sc_dk.dk_label);\n\t\tif (wd->retries++ < WDIORETRIES) {\n\t\t\tprintf(\", retrying\\n\");\n\t\t\ttimeout(wdrestart, wd, RECOVERYTIME);\n\t\t\treturn;\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_error = EIO;\n\t\tbreak;\n\tcase NOERROR:\nnoerror:\tif ((wd->sc_wdc_bio.flags & ATA_CORR) || wd->retries > 0)\n\t\t\tprintf(\"%s: soft error (corrected)\\n\",\n\t\t\t    wd->sc_dev.dv_xname);\n\t}\n\tdisk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));\n#if NRND > 0\n\trnd_add_uint32(&wd->rnd_source, bp->b_blkno);\n#endif\n\tbiodone(bp);\n\twd->openings++;\n\twdstart(wd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_ata_done: wddone\\n\")",
            "DEBUG_XFERS"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_free_xfer",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1617-1633",
          "snippet": "void\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "wdctimeout",
            "chp"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid  wdc_ata_bio_kill_xfer;\n\nvoid\nwdc_ata_bio_kill_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\n\tuntimeout(wdctimeout, chp);\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tata_bio->error = ERR_NODEV;\n\tata_bio->r_error = WDCE_ABRT;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n}"
  },
  {
    "function_name": "wdc_ata_bio_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
    "lines": "373-510",
    "snippet": "int\nwdc_ata_bio_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tint drv_err;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_intr %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\n\n\t/* Is it not a transfer, but a control operation? */\n\tif (drvp->state < READY) {\n\t\tprintf(\"%s:%d:%d: bad state %d in wdc_ata_bio_intr\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t\t    drvp->state);\n\t\tpanic(\"wdc_ata_bio_intr: bad state\\n\");\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\n\t/*\n\t * if we missed an interrupt in a PIO transfer, reset and restart.\n\t * Don't try to continue transfer, we may have missed cycles.\n\t */\n\tif ((xfer->c_flags & (C_TIMEOU | C_DMA)) == C_TIMEOU) {\n\t\tata_bio->error = TIMEOUT;\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\n\t/* Ack interrupt done by wait_for_unbusy */\n\tif (wait_for_unbusy(chp,\n\t    (irq == 0) ? ATA_DELAY : 0) < 0) {\n\t\tif (irq && (xfer->c_flags & C_TIMEOU) == 0)\n\t\t\treturn 0; /* IRQ was not for us */\n\t\tprintf(\"%s:%d:%d: device timeout, c_bcount=%d, c_skip%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t\t    xfer->c_bcount, xfer->c_skip);\n\t\t/* if we were using DMA, turn off DMA channel */\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\t(*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\tdrvp->n_dmaerrs++;\n\t\t}\n\t\tata_bio->error = TIMEOUT;\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\t\n\tdrv_err = wdc_ata_err(drvp, ata_bio);\n\n\t/* If we were using DMA, Turn off the DMA channel and check for error */\n\tif (xfer->c_flags & C_DMA) {\n\t\tif (ata_bio->flags & ATA_POLL) {\n\t\t\t/*\n\t\t\t * IDE drives deassert WDCS_BSY before transfer is\n\t\t\t * complete when using DMA. Polling for DRQ to deassert\n\t\t\t * is not enouth DRQ is not required to be\n\t\t\t * asserted for DMA transfers, so poll for DRDY.\n\t\t\t */\n\t\t\tif (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY,\n\t\t\t    ATA_DELAY) < 0) {\n\t\t\t\tprintf(\"%s:%d:%d: polled transfer timed out \"\n\t\t\t\t    \"(st=0x%x)\\n\", chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, xfer->drive, chp->ch_status);\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif ((*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, dma_flags) != 0) {\n\t\t\tif (drv_err != WDC_ATA_ERR) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif (chp->ch_status & WDCS_DRQ) {\n\t\t\tif (drv_err != WDC_ATA_ERR) {\n\t\t\t\tprintf(\"%s:%d:%d: intr with DRQ (st=0x%x)\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t\t    xfer->drive, chp->ch_status);\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif (drv_err != WDC_ATA_ERR)\n\t\t\tgoto end;\n\t\tdrvp->n_dmaerrs++;\n\t}\n\n\t/* if we had an error, end */\n\tif (drv_err == WDC_ATA_ERR) {\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\n\t/* If this was a read and not using DMA, fetch the data. */\n\tif ((ata_bio->flags & ATA_READ) != 0) {\n\t\tif ((chp->ch_status & WDCS_DRQ) != WDCS_DRQ) {\n\t\t\tprintf(\"%s:%d:%d: read intr before drq\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive);\n\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn 1;\n\t\t}\n\t\twdc_input_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\nend:\n\tata_bio->blkno += ata_bio->nblks;\n\tata_bio->blkdone += ata_bio->nblks;\n\txfer->c_skip += ata_bio->nbytes;\n\txfer->c_bcount -= ata_bio->nbytes;\n\t/* See if this transfer is complete. */\n\tif (xfer->c_bcount > 0) {\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\t/* Start the next operation */\n\t\t\t_wdc_ata_bio_start(chp, xfer);\n\t\t} else {\n\t\t\t/* Let _wdc_ata_bio_start do the loop */\n\t\t\treturn 1;\n\t\t}\n\t} else { /* Done with this transfer */\n\t\tata_bio->error = NOERROR;\n\t\twdc_ata_bio_done(chp, xfer);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define WDC_ATA_ERR   0x02 /* Drive reports an error */",
      "#define ATA_DELAY 10000 /* 10s for a drive I/O */",
      "#define DEBUG_XFERS  0x02",
      "#define DEBUG_INTR   0x01"
    ],
    "globals_used": [
      "void  _wdc_ata_bio_start",
      "int   wdc_ata_bio_intr",
      "void  wdc_ata_bio_done",
      "int   wdc_ata_err"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_ata_bio_done",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_bio_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "533-568",
          "snippet": "void\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [
            "void  wdc_ata_bio_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid  wdc_ata_bio_done;\n\nvoid\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_wdc_ata_bio_start",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "_wdc_ata_bio_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "174-371",
          "snippet": "void\n_wdc_ata_bio_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tu_int16_t cyl;\n\tu_int8_t head, sect, cmd = 0;\n\tint nblks;\n\tint ata_delay;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"_wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\t/* Do control operations specially. */\n\tif (drvp->state < READY) {\n\t\t/*\n\t\t * Actually, we want to be careful not to mess with the control\n\t\t * state if the device is currently busy, but we can assume\n\t\t * that we never get to this point if that's the case.\n\t\t */\n\t\t/* at this point, we should only be in RECAL state */\n\t\tif (drvp->state != RECAL) {\n\t\t\tprintf(\"%s:%d:%d: bad state %d in _wdc_ata_bio_start\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, drvp->state);\n\t\t\tpanic(\"_wdc_ata_bio_start: bad state\");\n\t\t}\n\t\txfer->c_intr = wdc_ata_ctrl_intr;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, ATA_DELAY) != 0)\n\t\t\tgoto timeout;\n\t\twdccommandshort(chp, xfer->drive, WDCC_RECAL);\n\t\tdrvp->state = RECAL_WAIT;\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t} else {\n\t\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\t\tDELAY(1);\n\t\t\twdc_ata_ctrl_intr(chp, xfer, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\tif (ata_bio->flags & ATA_SINGLE)\n\t\tata_delay = ATA_DELAY;\n\telse\n\t\tata_delay = ATA_DELAY;\n again:\n\t/*\n\t *\n\t * When starting a multi-sector transfer, or doing single-sector\n\t * transfers...\n\t */\n\tif (xfer->c_skip == 0 || (ata_bio->flags & ATA_SINGLE) != 0) {\n\t\tif (ata_bio->flags & ATA_SINGLE)\n\t\t\tnblks = 1;\n\t\telse \n\t\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\t/* Check for bad sectors and adjust transfer, if necessary. */\n\t\tif ((ata_bio->lp->d_flags & D_BADSECT) != 0) {\n\t\t\tlong blkdiff;\n\t\t\tint i;\n\t\t\tfor (i = 0; (blkdiff = ata_bio->badsect[i]) != -1;\n\t\t\t     i++) {\n\t\t\t\tblkdiff -= ata_bio->blkno;\n\t\t\t\tif (blkdiff < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (blkdiff == 0) {\n\t\t\t\t\t/* Replace current block of transfer. */\n\t\t\t\t\tata_bio->blkno =\n\t\t\t\t\t    ata_bio->lp->d_secperunit -\n\t\t\t\t\t    ata_bio->lp->d_nsectors - i - 1;\n\t\t\t\t}\n\t\t\t\tif (blkdiff < nblks) {\n\t\t\t\t\t/* Bad block inside transfer. */\n\t\t\t\t\tata_bio->flags |= ATA_SINGLE;\n\t\t\t\t\tnblks = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Transfer is okay now. */\n\t\t}\n\t\tif (ata_bio->flags & ATA_LBA) {\n\t\t\tsect = (ata_bio->blkno >> 0) & 0xff;\n\t\t\tcyl = (ata_bio->blkno >> 8) & 0xffff;\n\t\t\thead = (ata_bio->blkno >> 24) & 0x0f;\n\t\t\thead |= WDSD_LBA;\n\t\t} else {\n\t\t\tint blkno = ata_bio->blkno;\n\t\t\tsect = blkno % ata_bio->lp->d_nsectors;\n\t\t\tsect++;    /* Sectors begin with 1, not 0. */\n\t\t\tblkno /= ata_bio->lp->d_nsectors;\n\t\t\thead = blkno % ata_bio->lp->d_ntracks;\n\t\t\tblkno /= ata_bio->lp->d_ntracks;\n\t\t\tcyl = blkno;\n\t\t\thead |= WDSD_CHS;\n\t\t}\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READDMA : WDCC_WRITEDMA;\n\t\t\tnblks = ata_bio->nblks;\n\t    \t\t/* Init the DMA channel. */\n\t\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip, \n\t\t\t    ata_bio->nbytes, dma_flags) != 0) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tata_bio->r_error = 0;\n\t\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Initiate command */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, \n\t\t\t    WDSD_IBM | (xfer->drive << 4));\n\t\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\t\tgoto timeout;\n\t\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t\t    head, sect, nblks, 0);\n\t\t\t/* start the DMA channel */\n\t\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\t/* wait for irq */\n\t\t\tgoto intr;\n\t\t} /* else not DMA */\n\t\tata_bio->nblks = min(nblks, ata_bio->multi);\n\t\tata_bio->nbytes = ata_bio->nblks * ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > 1 && (ata_bio->flags & ATA_SINGLE) == 0) {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READMULTI : WDCC_WRITEMULTI;\n\t\t} else {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READ : WDCC_WRITE;\n\t\t}\n\t\t/* Initiate command! */\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\tgoto timeout;\n\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t    head, sect, nblks, \n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t    ata_bio->lp->d_precompcyl / 4 : 0);\n\t} else if (ata_bio->nblks > 1) {\n\t\t/* The number of blocks in the last stretch may be smaller. */\n\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > nblks) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t}\n\t}\n\t/* If this was a write and not using DMA, push the data. */\n\tif ((ata_bio->flags & ATA_READ) == 0) {\n\t\tif (wait_for_drq(chp, ata_delay) != 0) {\n\t\t\tprintf(\"%s:%d:%d: timeout waiting for DRQ, \"\n\t\t\t    \"st=0x%02x, err=0x%02x\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, chp->ch_status, chp->ch_error);\n\t\t\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\tif (wdc_ata_err(drvp, ata_bio) == WDC_ATA_ERR) {\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\twdc_output_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\n\n intr:\t/* Wait for IRQ (either real or polled) */\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\tdelay(1);\n\t\twdc_ata_bio_intr(chp, xfer, 0);\n\t\tif ((ata_bio->flags & ATA_ITSDONE) == 0)\n\t\t\tgoto again;\n\t}\n\treturn;\n timeout:\n\tprintf(\"%s:%d:%d: not ready, st=0x%02x, err=0x%02x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    chp->ch_status, chp->ch_error);\n\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\tata_bio->error = TIMEOUT;\n\twdc_ata_bio_done(chp, xfer);\n\treturn;\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WDC_ATA_ERR   0x02 /* Drive reports an error */",
            "#define ATA_DELAY 10000 /* 10s for a drive I/O */",
            "#define DEBUG_XFERS  0x02",
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [
            "void  _wdc_ata_bio_start",
            "int   wdc_ata_bio_intr",
            "void  wdc_ata_bio_done",
            "int   wdc_ata_ctrl_intr",
            "int   wdc_ata_err"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_ATA_ERR   0x02 /* Drive reports an error */\n#define ATA_DELAY 10000 /* 10s for a drive I/O */\n#define DEBUG_XFERS  0x02\n#define DEBUG_INTR   0x01\n\nvoid  _wdc_ata_bio_start;\nint   wdc_ata_bio_intr;\nvoid  wdc_ata_bio_done;\nint   wdc_ata_ctrl_intr;\nint   wdc_ata_err;\n\nvoid\n_wdc_ata_bio_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tu_int16_t cyl;\n\tu_int8_t head, sect, cmd = 0;\n\tint nblks;\n\tint ata_delay;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"_wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\t/* Do control operations specially. */\n\tif (drvp->state < READY) {\n\t\t/*\n\t\t * Actually, we want to be careful not to mess with the control\n\t\t * state if the device is currently busy, but we can assume\n\t\t * that we never get to this point if that's the case.\n\t\t */\n\t\t/* at this point, we should only be in RECAL state */\n\t\tif (drvp->state != RECAL) {\n\t\t\tprintf(\"%s:%d:%d: bad state %d in _wdc_ata_bio_start\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, drvp->state);\n\t\t\tpanic(\"_wdc_ata_bio_start: bad state\");\n\t\t}\n\t\txfer->c_intr = wdc_ata_ctrl_intr;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, ATA_DELAY) != 0)\n\t\t\tgoto timeout;\n\t\twdccommandshort(chp, xfer->drive, WDCC_RECAL);\n\t\tdrvp->state = RECAL_WAIT;\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t} else {\n\t\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\t\tDELAY(1);\n\t\t\twdc_ata_ctrl_intr(chp, xfer, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\tif (ata_bio->flags & ATA_SINGLE)\n\t\tata_delay = ATA_DELAY;\n\telse\n\t\tata_delay = ATA_DELAY;\n again:\n\t/*\n\t *\n\t * When starting a multi-sector transfer, or doing single-sector\n\t * transfers...\n\t */\n\tif (xfer->c_skip == 0 || (ata_bio->flags & ATA_SINGLE) != 0) {\n\t\tif (ata_bio->flags & ATA_SINGLE)\n\t\t\tnblks = 1;\n\t\telse \n\t\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\t/* Check for bad sectors and adjust transfer, if necessary. */\n\t\tif ((ata_bio->lp->d_flags & D_BADSECT) != 0) {\n\t\t\tlong blkdiff;\n\t\t\tint i;\n\t\t\tfor (i = 0; (blkdiff = ata_bio->badsect[i]) != -1;\n\t\t\t     i++) {\n\t\t\t\tblkdiff -= ata_bio->blkno;\n\t\t\t\tif (blkdiff < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (blkdiff == 0) {\n\t\t\t\t\t/* Replace current block of transfer. */\n\t\t\t\t\tata_bio->blkno =\n\t\t\t\t\t    ata_bio->lp->d_secperunit -\n\t\t\t\t\t    ata_bio->lp->d_nsectors - i - 1;\n\t\t\t\t}\n\t\t\t\tif (blkdiff < nblks) {\n\t\t\t\t\t/* Bad block inside transfer. */\n\t\t\t\t\tata_bio->flags |= ATA_SINGLE;\n\t\t\t\t\tnblks = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Transfer is okay now. */\n\t\t}\n\t\tif (ata_bio->flags & ATA_LBA) {\n\t\t\tsect = (ata_bio->blkno >> 0) & 0xff;\n\t\t\tcyl = (ata_bio->blkno >> 8) & 0xffff;\n\t\t\thead = (ata_bio->blkno >> 24) & 0x0f;\n\t\t\thead |= WDSD_LBA;\n\t\t} else {\n\t\t\tint blkno = ata_bio->blkno;\n\t\t\tsect = blkno % ata_bio->lp->d_nsectors;\n\t\t\tsect++;    /* Sectors begin with 1, not 0. */\n\t\t\tblkno /= ata_bio->lp->d_nsectors;\n\t\t\thead = blkno % ata_bio->lp->d_ntracks;\n\t\t\tblkno /= ata_bio->lp->d_ntracks;\n\t\t\tcyl = blkno;\n\t\t\thead |= WDSD_CHS;\n\t\t}\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READDMA : WDCC_WRITEDMA;\n\t\t\tnblks = ata_bio->nblks;\n\t    \t\t/* Init the DMA channel. */\n\t\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip, \n\t\t\t    ata_bio->nbytes, dma_flags) != 0) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tata_bio->r_error = 0;\n\t\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Initiate command */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, \n\t\t\t    WDSD_IBM | (xfer->drive << 4));\n\t\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\t\tgoto timeout;\n\t\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t\t    head, sect, nblks, 0);\n\t\t\t/* start the DMA channel */\n\t\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\t/* wait for irq */\n\t\t\tgoto intr;\n\t\t} /* else not DMA */\n\t\tata_bio->nblks = min(nblks, ata_bio->multi);\n\t\tata_bio->nbytes = ata_bio->nblks * ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > 1 && (ata_bio->flags & ATA_SINGLE) == 0) {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READMULTI : WDCC_WRITEMULTI;\n\t\t} else {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READ : WDCC_WRITE;\n\t\t}\n\t\t/* Initiate command! */\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\tgoto timeout;\n\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t    head, sect, nblks, \n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t    ata_bio->lp->d_precompcyl / 4 : 0);\n\t} else if (ata_bio->nblks > 1) {\n\t\t/* The number of blocks in the last stretch may be smaller. */\n\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > nblks) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t}\n\t}\n\t/* If this was a write and not using DMA, push the data. */\n\tif ((ata_bio->flags & ATA_READ) == 0) {\n\t\tif (wait_for_drq(chp, ata_delay) != 0) {\n\t\t\tprintf(\"%s:%d:%d: timeout waiting for DRQ, \"\n\t\t\t    \"st=0x%02x, err=0x%02x\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, chp->ch_status, chp->ch_error);\n\t\t\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\tif (wdc_ata_err(drvp, ata_bio) == WDC_ATA_ERR) {\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\twdc_output_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\n\n intr:\t/* Wait for IRQ (either real or polled) */\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\tdelay(1);\n\t\twdc_ata_bio_intr(chp, xfer, 0);\n\t\tif ((ata_bio->flags & ATA_ITSDONE) == 0)\n\t\t\tgoto again;\n\t}\n\treturn;\n timeout:\n\tprintf(\"%s:%d:%d: not ready, st=0x%02x, err=0x%02x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    chp->ch_status, chp->ch_error);\n\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\tata_bio->error = TIMEOUT;\n\twdc_ata_bio_done(chp, xfer);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_input_bytes",
          "args": [
            "drvp",
            "(char *)xfer->databuf + xfer->c_skip",
            "ata_bio->nbytes"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_input_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1194-1222",
          "snippet": "void\nwdc_input_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_READ_RAW_MULTI_4(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t\tCHP_READ_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_input_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_READ_RAW_MULTI_4(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t\tCHP_READ_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d:%d: read intr before drq\\n\"",
            "chp->wdc->sc_dev.dv_xname",
            "chp->channel",
            "xfer->drive"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp->wdc->dma_arg",
            "chp->channel",
            "xfer->drive",
            "dma_flags"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdcwait",
          "args": [
            "chp",
            "WDCS_DRDY | WDCS_DRQ",
            "WDCS_DRDY",
            "ATA_DELAY"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "wdcwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "879-950",
          "snippet": "int\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_STATUSX 0x20",
            "#define DEBUG_STATUS 0x04",
            "#define WDCNDELAY_DEBUG\t50",
            "#define WDCDELAY  100 /* 100 microseconds */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_STATUSX 0x20\n#define DEBUG_STATUS 0x04\n#define WDCNDELAY_DEBUG\t50\n#define WDCDELAY  100 /* 100 microseconds */\n\nint\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_ata_err",
          "args": [
            "drvp",
            "ata_bio"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "723-760",
          "snippet": "int\nwdc_ata_err(drvp, ata_bio)\n\tstruct ata_drive_datas *drvp;\n\tstruct ata_bio *ata_bio;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tata_bio->error = 0;\n\tif (chp->ch_status & WDCS_BSY) {\n\t\tata_bio->error = TIMEOUT;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_DWF) {\n\t\tata_bio->error = ERR_DF;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_ERR) {\n\t\tata_bio->error = ERROR;\n\t\tata_bio->r_error = chp->ch_error;\n\t\tif (drvp->drive_flags & DRIVE_UDMA &&\n\t\t    (ata_bio->r_error & WDCE_CRC)) {\n\t\t\t/*\n\t\t\t * Record the CRC error, to avoid downgrading to\n\t\t\t * multiword DMA\n\t\t\t */\n\t\t\tdrvp->drive_flags |= DRIVE_DMAERR;\n\t\t}\n\t\tif (ata_bio->r_error & (WDCE_BBK | WDCE_UNC | WDCE_IDNF |\n\t\t    WDCE_ABRT | WDCE_TK0NF | WDCE_AMNF))\n\t\t\treturn WDC_ATA_ERR;\n\t\treturn WDC_ATA_NOERR;\n\t}\n\n\tif (chp->ch_status & WDCS_CORR)\n\t\tata_bio->flags |= ATA_CORR;\n\treturn WDC_ATA_NOERR;\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WDC_ATA_ERR   0x02 /* Drive reports an error */",
            "#define WDC_ATA_NOERR 0x00 /* Drive doesn't report an error */"
          ],
          "globals_used": [
            "int   wdc_ata_err"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_ATA_ERR   0x02 /* Drive reports an error */\n#define WDC_ATA_NOERR 0x00 /* Drive doesn't report an error */\n\nint   wdc_ata_err;\n\nint\nwdc_ata_err(drvp, ata_bio)\n\tstruct ata_drive_datas *drvp;\n\tstruct ata_bio *ata_bio;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tata_bio->error = 0;\n\tif (chp->ch_status & WDCS_BSY) {\n\t\tata_bio->error = TIMEOUT;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_DWF) {\n\t\tata_bio->error = ERR_DF;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_ERR) {\n\t\tata_bio->error = ERROR;\n\t\tata_bio->r_error = chp->ch_error;\n\t\tif (drvp->drive_flags & DRIVE_UDMA &&\n\t\t    (ata_bio->r_error & WDCE_CRC)) {\n\t\t\t/*\n\t\t\t * Record the CRC error, to avoid downgrading to\n\t\t\t * multiword DMA\n\t\t\t */\n\t\t\tdrvp->drive_flags |= DRIVE_DMAERR;\n\t\t}\n\t\tif (ata_bio->r_error & (WDCE_BBK | WDCE_UNC | WDCE_IDNF |\n\t\t    WDCE_ABRT | WDCE_TK0NF | WDCE_AMNF))\n\t\t\treturn WDC_ATA_ERR;\n\t\treturn WDC_ATA_NOERR;\n\t}\n\n\tif (chp->ch_status & WDCS_CORR)\n\t\tata_bio->flags |= ATA_CORR;\n\treturn WDC_ATA_NOERR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp->wdc->dma_arg",
            "chp->channel",
            "xfer->drive",
            "dma_flags"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_unbusy",
          "args": [
            "chp",
            "(irq == 0) ? ATA_DELAY : 0"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wdc_ata_bio_intr: bad state\\n\""
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_ata_bio_intr %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive)",
            "DEBUG_INTR | DEBUG_XFERS"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_ATA_ERR   0x02 /* Drive reports an error */\n#define ATA_DELAY 10000 /* 10s for a drive I/O */\n#define DEBUG_XFERS  0x02\n#define DEBUG_INTR   0x01\n\nvoid  _wdc_ata_bio_start;\nint   wdc_ata_bio_intr;\nvoid  wdc_ata_bio_done;\nint   wdc_ata_err;\n\nint\nwdc_ata_bio_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tint drv_err;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_intr %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\n\n\t/* Is it not a transfer, but a control operation? */\n\tif (drvp->state < READY) {\n\t\tprintf(\"%s:%d:%d: bad state %d in wdc_ata_bio_intr\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t\t    drvp->state);\n\t\tpanic(\"wdc_ata_bio_intr: bad state\\n\");\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\n\t/*\n\t * if we missed an interrupt in a PIO transfer, reset and restart.\n\t * Don't try to continue transfer, we may have missed cycles.\n\t */\n\tif ((xfer->c_flags & (C_TIMEOU | C_DMA)) == C_TIMEOU) {\n\t\tata_bio->error = TIMEOUT;\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\n\t/* Ack interrupt done by wait_for_unbusy */\n\tif (wait_for_unbusy(chp,\n\t    (irq == 0) ? ATA_DELAY : 0) < 0) {\n\t\tif (irq && (xfer->c_flags & C_TIMEOU) == 0)\n\t\t\treturn 0; /* IRQ was not for us */\n\t\tprintf(\"%s:%d:%d: device timeout, c_bcount=%d, c_skip%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t\t    xfer->c_bcount, xfer->c_skip);\n\t\t/* if we were using DMA, turn off DMA channel */\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\t(*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\tdrvp->n_dmaerrs++;\n\t\t}\n\t\tata_bio->error = TIMEOUT;\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\t\n\tdrv_err = wdc_ata_err(drvp, ata_bio);\n\n\t/* If we were using DMA, Turn off the DMA channel and check for error */\n\tif (xfer->c_flags & C_DMA) {\n\t\tif (ata_bio->flags & ATA_POLL) {\n\t\t\t/*\n\t\t\t * IDE drives deassert WDCS_BSY before transfer is\n\t\t\t * complete when using DMA. Polling for DRQ to deassert\n\t\t\t * is not enouth DRQ is not required to be\n\t\t\t * asserted for DMA transfers, so poll for DRDY.\n\t\t\t */\n\t\t\tif (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY,\n\t\t\t    ATA_DELAY) < 0) {\n\t\t\t\tprintf(\"%s:%d:%d: polled transfer timed out \"\n\t\t\t\t    \"(st=0x%x)\\n\", chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, xfer->drive, chp->ch_status);\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif ((*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, dma_flags) != 0) {\n\t\t\tif (drv_err != WDC_ATA_ERR) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif (chp->ch_status & WDCS_DRQ) {\n\t\t\tif (drv_err != WDC_ATA_ERR) {\n\t\t\t\tprintf(\"%s:%d:%d: intr with DRQ (st=0x%x)\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t\t    xfer->drive, chp->ch_status);\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif (drv_err != WDC_ATA_ERR)\n\t\t\tgoto end;\n\t\tdrvp->n_dmaerrs++;\n\t}\n\n\t/* if we had an error, end */\n\tif (drv_err == WDC_ATA_ERR) {\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\n\t/* If this was a read and not using DMA, fetch the data. */\n\tif ((ata_bio->flags & ATA_READ) != 0) {\n\t\tif ((chp->ch_status & WDCS_DRQ) != WDCS_DRQ) {\n\t\t\tprintf(\"%s:%d:%d: read intr before drq\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive);\n\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn 1;\n\t\t}\n\t\twdc_input_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\nend:\n\tata_bio->blkno += ata_bio->nblks;\n\tata_bio->blkdone += ata_bio->nblks;\n\txfer->c_skip += ata_bio->nbytes;\n\txfer->c_bcount -= ata_bio->nbytes;\n\t/* See if this transfer is complete. */\n\tif (xfer->c_bcount > 0) {\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\t/* Start the next operation */\n\t\t\t_wdc_ata_bio_start(chp, xfer);\n\t\t} else {\n\t\t\t/* Let _wdc_ata_bio_start do the loop */\n\t\t\treturn 1;\n\t\t}\n\t} else { /* Done with this transfer */\n\t\tata_bio->error = NOERROR;\n\t\twdc_ata_bio_done(chp, xfer);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "_wdc_ata_bio_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
    "lines": "174-371",
    "snippet": "void\n_wdc_ata_bio_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tu_int16_t cyl;\n\tu_int8_t head, sect, cmd = 0;\n\tint nblks;\n\tint ata_delay;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"_wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\t/* Do control operations specially. */\n\tif (drvp->state < READY) {\n\t\t/*\n\t\t * Actually, we want to be careful not to mess with the control\n\t\t * state if the device is currently busy, but we can assume\n\t\t * that we never get to this point if that's the case.\n\t\t */\n\t\t/* at this point, we should only be in RECAL state */\n\t\tif (drvp->state != RECAL) {\n\t\t\tprintf(\"%s:%d:%d: bad state %d in _wdc_ata_bio_start\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, drvp->state);\n\t\t\tpanic(\"_wdc_ata_bio_start: bad state\");\n\t\t}\n\t\txfer->c_intr = wdc_ata_ctrl_intr;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, ATA_DELAY) != 0)\n\t\t\tgoto timeout;\n\t\twdccommandshort(chp, xfer->drive, WDCC_RECAL);\n\t\tdrvp->state = RECAL_WAIT;\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t} else {\n\t\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\t\tDELAY(1);\n\t\t\twdc_ata_ctrl_intr(chp, xfer, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\tif (ata_bio->flags & ATA_SINGLE)\n\t\tata_delay = ATA_DELAY;\n\telse\n\t\tata_delay = ATA_DELAY;\n again:\n\t/*\n\t *\n\t * When starting a multi-sector transfer, or doing single-sector\n\t * transfers...\n\t */\n\tif (xfer->c_skip == 0 || (ata_bio->flags & ATA_SINGLE) != 0) {\n\t\tif (ata_bio->flags & ATA_SINGLE)\n\t\t\tnblks = 1;\n\t\telse \n\t\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\t/* Check for bad sectors and adjust transfer, if necessary. */\n\t\tif ((ata_bio->lp->d_flags & D_BADSECT) != 0) {\n\t\t\tlong blkdiff;\n\t\t\tint i;\n\t\t\tfor (i = 0; (blkdiff = ata_bio->badsect[i]) != -1;\n\t\t\t     i++) {\n\t\t\t\tblkdiff -= ata_bio->blkno;\n\t\t\t\tif (blkdiff < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (blkdiff == 0) {\n\t\t\t\t\t/* Replace current block of transfer. */\n\t\t\t\t\tata_bio->blkno =\n\t\t\t\t\t    ata_bio->lp->d_secperunit -\n\t\t\t\t\t    ata_bio->lp->d_nsectors - i - 1;\n\t\t\t\t}\n\t\t\t\tif (blkdiff < nblks) {\n\t\t\t\t\t/* Bad block inside transfer. */\n\t\t\t\t\tata_bio->flags |= ATA_SINGLE;\n\t\t\t\t\tnblks = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Transfer is okay now. */\n\t\t}\n\t\tif (ata_bio->flags & ATA_LBA) {\n\t\t\tsect = (ata_bio->blkno >> 0) & 0xff;\n\t\t\tcyl = (ata_bio->blkno >> 8) & 0xffff;\n\t\t\thead = (ata_bio->blkno >> 24) & 0x0f;\n\t\t\thead |= WDSD_LBA;\n\t\t} else {\n\t\t\tint blkno = ata_bio->blkno;\n\t\t\tsect = blkno % ata_bio->lp->d_nsectors;\n\t\t\tsect++;    /* Sectors begin with 1, not 0. */\n\t\t\tblkno /= ata_bio->lp->d_nsectors;\n\t\t\thead = blkno % ata_bio->lp->d_ntracks;\n\t\t\tblkno /= ata_bio->lp->d_ntracks;\n\t\t\tcyl = blkno;\n\t\t\thead |= WDSD_CHS;\n\t\t}\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READDMA : WDCC_WRITEDMA;\n\t\t\tnblks = ata_bio->nblks;\n\t    \t\t/* Init the DMA channel. */\n\t\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip, \n\t\t\t    ata_bio->nbytes, dma_flags) != 0) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tata_bio->r_error = 0;\n\t\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Initiate command */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, \n\t\t\t    WDSD_IBM | (xfer->drive << 4));\n\t\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\t\tgoto timeout;\n\t\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t\t    head, sect, nblks, 0);\n\t\t\t/* start the DMA channel */\n\t\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\t/* wait for irq */\n\t\t\tgoto intr;\n\t\t} /* else not DMA */\n\t\tata_bio->nblks = min(nblks, ata_bio->multi);\n\t\tata_bio->nbytes = ata_bio->nblks * ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > 1 && (ata_bio->flags & ATA_SINGLE) == 0) {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READMULTI : WDCC_WRITEMULTI;\n\t\t} else {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READ : WDCC_WRITE;\n\t\t}\n\t\t/* Initiate command! */\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\tgoto timeout;\n\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t    head, sect, nblks, \n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t    ata_bio->lp->d_precompcyl / 4 : 0);\n\t} else if (ata_bio->nblks > 1) {\n\t\t/* The number of blocks in the last stretch may be smaller. */\n\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > nblks) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t}\n\t}\n\t/* If this was a write and not using DMA, push the data. */\n\tif ((ata_bio->flags & ATA_READ) == 0) {\n\t\tif (wait_for_drq(chp, ata_delay) != 0) {\n\t\t\tprintf(\"%s:%d:%d: timeout waiting for DRQ, \"\n\t\t\t    \"st=0x%02x, err=0x%02x\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, chp->ch_status, chp->ch_error);\n\t\t\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\tif (wdc_ata_err(drvp, ata_bio) == WDC_ATA_ERR) {\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\twdc_output_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\n\n intr:\t/* Wait for IRQ (either real or polled) */\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\tdelay(1);\n\t\twdc_ata_bio_intr(chp, xfer, 0);\n\t\tif ((ata_bio->flags & ATA_ITSDONE) == 0)\n\t\t\tgoto again;\n\t}\n\treturn;\n timeout:\n\tprintf(\"%s:%d:%d: not ready, st=0x%02x, err=0x%02x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    chp->ch_status, chp->ch_error);\n\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\tata_bio->error = TIMEOUT;\n\twdc_ata_bio_done(chp, xfer);\n\treturn;\n}",
    "includes": [
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define WDC_ATA_ERR   0x02 /* Drive reports an error */",
      "#define ATA_DELAY 10000 /* 10s for a drive I/O */",
      "#define DEBUG_XFERS  0x02",
      "#define DEBUG_INTR   0x01"
    ],
    "globals_used": [
      "void  _wdc_ata_bio_start",
      "int   wdc_ata_bio_intr",
      "void  wdc_ata_bio_done",
      "int   wdc_ata_ctrl_intr",
      "int   wdc_ata_err"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_ata_bio_done",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_bio_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "533-568",
          "snippet": "void\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [
            "void  wdc_ata_bio_done"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nvoid  wdc_ata_bio_done;\n\nvoid\nwdc_ata_bio_done(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tint drive = xfer->drive;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[drive];\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_done %s:%d:%d: flags 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, \n\t    (u_int)xfer->c_flags),\n\t    DEBUG_XFERS);\n\n\tuntimeout(wdctimeout, chp);\n\tif (ata_bio->error == NOERROR)\n\t\tdrvp->n_dmaerrs = 0;\n\telse if (drvp->n_dmaerrs >= NERRS_MAX) {\n\t\twdc_downgrade_mode(drvp);\n\t}\n\n\t/* feed back residual bcount to our caller */\n\tata_bio->bcount = xfer->c_bcount;\n\n\t/* remove this command from xfer queue */\n\twdc_free_xfer(chp, xfer);\n\n\tata_bio->flags |= ATA_ITSDONE;\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tWDCDEBUG_PRINT((\"wdc_ata_done: wddone\\n\"), DEBUG_XFERS);\n\t\twddone(ata_bio->wd);\n\t}\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_ata_done, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_ata_err",
          "args": [
            "drvp",
            "ata_bio"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "723-760",
          "snippet": "int\nwdc_ata_err(drvp, ata_bio)\n\tstruct ata_drive_datas *drvp;\n\tstruct ata_bio *ata_bio;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tata_bio->error = 0;\n\tif (chp->ch_status & WDCS_BSY) {\n\t\tata_bio->error = TIMEOUT;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_DWF) {\n\t\tata_bio->error = ERR_DF;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_ERR) {\n\t\tata_bio->error = ERROR;\n\t\tata_bio->r_error = chp->ch_error;\n\t\tif (drvp->drive_flags & DRIVE_UDMA &&\n\t\t    (ata_bio->r_error & WDCE_CRC)) {\n\t\t\t/*\n\t\t\t * Record the CRC error, to avoid downgrading to\n\t\t\t * multiword DMA\n\t\t\t */\n\t\t\tdrvp->drive_flags |= DRIVE_DMAERR;\n\t\t}\n\t\tif (ata_bio->r_error & (WDCE_BBK | WDCE_UNC | WDCE_IDNF |\n\t\t    WDCE_ABRT | WDCE_TK0NF | WDCE_AMNF))\n\t\t\treturn WDC_ATA_ERR;\n\t\treturn WDC_ATA_NOERR;\n\t}\n\n\tif (chp->ch_status & WDCS_CORR)\n\t\tata_bio->flags |= ATA_CORR;\n\treturn WDC_ATA_NOERR;\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WDC_ATA_ERR   0x02 /* Drive reports an error */",
            "#define WDC_ATA_NOERR 0x00 /* Drive doesn't report an error */"
          ],
          "globals_used": [
            "int   wdc_ata_err"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_ATA_ERR   0x02 /* Drive reports an error */\n#define WDC_ATA_NOERR 0x00 /* Drive doesn't report an error */\n\nint   wdc_ata_err;\n\nint\nwdc_ata_err(drvp, ata_bio)\n\tstruct ata_drive_datas *drvp;\n\tstruct ata_bio *ata_bio;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tata_bio->error = 0;\n\tif (chp->ch_status & WDCS_BSY) {\n\t\tata_bio->error = TIMEOUT;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_DWF) {\n\t\tata_bio->error = ERR_DF;\n\t\treturn WDC_ATA_ERR;\n\t}\n\n\tif (chp->ch_status & WDCS_ERR) {\n\t\tata_bio->error = ERROR;\n\t\tata_bio->r_error = chp->ch_error;\n\t\tif (drvp->drive_flags & DRIVE_UDMA &&\n\t\t    (ata_bio->r_error & WDCE_CRC)) {\n\t\t\t/*\n\t\t\t * Record the CRC error, to avoid downgrading to\n\t\t\t * multiword DMA\n\t\t\t */\n\t\t\tdrvp->drive_flags |= DRIVE_DMAERR;\n\t\t}\n\t\tif (ata_bio->r_error & (WDCE_BBK | WDCE_UNC | WDCE_IDNF |\n\t\t    WDCE_ABRT | WDCE_TK0NF | WDCE_AMNF))\n\t\t\treturn WDC_ATA_ERR;\n\t\treturn WDC_ATA_NOERR;\n\t}\n\n\tif (chp->ch_status & WDCS_CORR)\n\t\tata_bio->flags |= ATA_CORR;\n\treturn WDC_ATA_NOERR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:%d:%d: not ready, st=0x%02x, err=0x%02x\\n\"",
            "chp->wdc->sc_dev.dv_xname",
            "chp->channel",
            "xfer->drive",
            "chp->ch_status",
            "chp->ch_error"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_ata_bio_intr",
          "args": [
            "chp",
            "xfer",
            "0"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_bio_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "373-510",
          "snippet": "int\nwdc_ata_bio_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tint drv_err;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_intr %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\n\n\t/* Is it not a transfer, but a control operation? */\n\tif (drvp->state < READY) {\n\t\tprintf(\"%s:%d:%d: bad state %d in wdc_ata_bio_intr\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t\t    drvp->state);\n\t\tpanic(\"wdc_ata_bio_intr: bad state\\n\");\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\n\t/*\n\t * if we missed an interrupt in a PIO transfer, reset and restart.\n\t * Don't try to continue transfer, we may have missed cycles.\n\t */\n\tif ((xfer->c_flags & (C_TIMEOU | C_DMA)) == C_TIMEOU) {\n\t\tata_bio->error = TIMEOUT;\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\n\t/* Ack interrupt done by wait_for_unbusy */\n\tif (wait_for_unbusy(chp,\n\t    (irq == 0) ? ATA_DELAY : 0) < 0) {\n\t\tif (irq && (xfer->c_flags & C_TIMEOU) == 0)\n\t\t\treturn 0; /* IRQ was not for us */\n\t\tprintf(\"%s:%d:%d: device timeout, c_bcount=%d, c_skip%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t\t    xfer->c_bcount, xfer->c_skip);\n\t\t/* if we were using DMA, turn off DMA channel */\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\t(*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\tdrvp->n_dmaerrs++;\n\t\t}\n\t\tata_bio->error = TIMEOUT;\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\t\n\tdrv_err = wdc_ata_err(drvp, ata_bio);\n\n\t/* If we were using DMA, Turn off the DMA channel and check for error */\n\tif (xfer->c_flags & C_DMA) {\n\t\tif (ata_bio->flags & ATA_POLL) {\n\t\t\t/*\n\t\t\t * IDE drives deassert WDCS_BSY before transfer is\n\t\t\t * complete when using DMA. Polling for DRQ to deassert\n\t\t\t * is not enouth DRQ is not required to be\n\t\t\t * asserted for DMA transfers, so poll for DRDY.\n\t\t\t */\n\t\t\tif (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY,\n\t\t\t    ATA_DELAY) < 0) {\n\t\t\t\tprintf(\"%s:%d:%d: polled transfer timed out \"\n\t\t\t\t    \"(st=0x%x)\\n\", chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, xfer->drive, chp->ch_status);\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif ((*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, dma_flags) != 0) {\n\t\t\tif (drv_err != WDC_ATA_ERR) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif (chp->ch_status & WDCS_DRQ) {\n\t\t\tif (drv_err != WDC_ATA_ERR) {\n\t\t\t\tprintf(\"%s:%d:%d: intr with DRQ (st=0x%x)\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t\t    xfer->drive, chp->ch_status);\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif (drv_err != WDC_ATA_ERR)\n\t\t\tgoto end;\n\t\tdrvp->n_dmaerrs++;\n\t}\n\n\t/* if we had an error, end */\n\tif (drv_err == WDC_ATA_ERR) {\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\n\t/* If this was a read and not using DMA, fetch the data. */\n\tif ((ata_bio->flags & ATA_READ) != 0) {\n\t\tif ((chp->ch_status & WDCS_DRQ) != WDCS_DRQ) {\n\t\t\tprintf(\"%s:%d:%d: read intr before drq\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive);\n\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn 1;\n\t\t}\n\t\twdc_input_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\nend:\n\tata_bio->blkno += ata_bio->nblks;\n\tata_bio->blkdone += ata_bio->nblks;\n\txfer->c_skip += ata_bio->nbytes;\n\txfer->c_bcount -= ata_bio->nbytes;\n\t/* See if this transfer is complete. */\n\tif (xfer->c_bcount > 0) {\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\t/* Start the next operation */\n\t\t\t_wdc_ata_bio_start(chp, xfer);\n\t\t} else {\n\t\t\t/* Let _wdc_ata_bio_start do the loop */\n\t\t\treturn 1;\n\t\t}\n\t} else { /* Done with this transfer */\n\t\tata_bio->error = NOERROR;\n\t\twdc_ata_bio_done(chp, xfer);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WDC_ATA_ERR   0x02 /* Drive reports an error */",
            "#define ATA_DELAY 10000 /* 10s for a drive I/O */",
            "#define DEBUG_XFERS  0x02",
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [
            "void  _wdc_ata_bio_start",
            "int   wdc_ata_bio_intr",
            "void  wdc_ata_bio_done",
            "int   wdc_ata_err"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_ATA_ERR   0x02 /* Drive reports an error */\n#define ATA_DELAY 10000 /* 10s for a drive I/O */\n#define DEBUG_XFERS  0x02\n#define DEBUG_INTR   0x01\n\nvoid  _wdc_ata_bio_start;\nint   wdc_ata_bio_intr;\nvoid  wdc_ata_bio_done;\nint   wdc_ata_err;\n\nint\nwdc_ata_bio_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tint drv_err;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_intr %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\n\n\t/* Is it not a transfer, but a control operation? */\n\tif (drvp->state < READY) {\n\t\tprintf(\"%s:%d:%d: bad state %d in wdc_ata_bio_intr\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t\t    drvp->state);\n\t\tpanic(\"wdc_ata_bio_intr: bad state\\n\");\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\n\t/*\n\t * if we missed an interrupt in a PIO transfer, reset and restart.\n\t * Don't try to continue transfer, we may have missed cycles.\n\t */\n\tif ((xfer->c_flags & (C_TIMEOU | C_DMA)) == C_TIMEOU) {\n\t\tata_bio->error = TIMEOUT;\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\n\t/* Ack interrupt done by wait_for_unbusy */\n\tif (wait_for_unbusy(chp,\n\t    (irq == 0) ? ATA_DELAY : 0) < 0) {\n\t\tif (irq && (xfer->c_flags & C_TIMEOU) == 0)\n\t\t\treturn 0; /* IRQ was not for us */\n\t\tprintf(\"%s:%d:%d: device timeout, c_bcount=%d, c_skip%d\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t\t    xfer->c_bcount, xfer->c_skip);\n\t\t/* if we were using DMA, turn off DMA channel */\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\t(*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\tdrvp->n_dmaerrs++;\n\t\t}\n\t\tata_bio->error = TIMEOUT;\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\t\n\tdrv_err = wdc_ata_err(drvp, ata_bio);\n\n\t/* If we were using DMA, Turn off the DMA channel and check for error */\n\tif (xfer->c_flags & C_DMA) {\n\t\tif (ata_bio->flags & ATA_POLL) {\n\t\t\t/*\n\t\t\t * IDE drives deassert WDCS_BSY before transfer is\n\t\t\t * complete when using DMA. Polling for DRQ to deassert\n\t\t\t * is not enouth DRQ is not required to be\n\t\t\t * asserted for DMA transfers, so poll for DRDY.\n\t\t\t */\n\t\t\tif (wdcwait(chp, WDCS_DRDY | WDCS_DRQ, WDCS_DRDY,\n\t\t\t    ATA_DELAY) < 0) {\n\t\t\t\tprintf(\"%s:%d:%d: polled transfer timed out \"\n\t\t\t\t    \"(st=0x%x)\\n\", chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, xfer->drive, chp->ch_status);\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif ((*chp->wdc->dma_finish)(chp->wdc->dma_arg,\n\t\t    chp->channel, xfer->drive, dma_flags) != 0) {\n\t\t\tif (drv_err != WDC_ATA_ERR) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif (chp->ch_status & WDCS_DRQ) {\n\t\t\tif (drv_err != WDC_ATA_ERR) {\n\t\t\t\tprintf(\"%s:%d:%d: intr with DRQ (st=0x%x)\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t\t    xfer->drive, chp->ch_status);\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\t\tdrv_err = WDC_ATA_ERR;\n\t\t\t}\n\t\t}\n\t\tif (drv_err != WDC_ATA_ERR)\n\t\t\tgoto end;\n\t\tdrvp->n_dmaerrs++;\n\t}\n\n\t/* if we had an error, end */\n\tif (drv_err == WDC_ATA_ERR) {\n\t\twdc_ata_bio_done(chp, xfer);\n\t\treturn 1;\n\t}\n\n\t/* If this was a read and not using DMA, fetch the data. */\n\tif ((ata_bio->flags & ATA_READ) != 0) {\n\t\tif ((chp->ch_status & WDCS_DRQ) != WDCS_DRQ) {\n\t\t\tprintf(\"%s:%d:%d: read intr before drq\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive);\n\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn 1;\n\t\t}\n\t\twdc_input_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\nend:\n\tata_bio->blkno += ata_bio->nblks;\n\tata_bio->blkdone += ata_bio->nblks;\n\txfer->c_skip += ata_bio->nbytes;\n\txfer->c_bcount -= ata_bio->nbytes;\n\t/* See if this transfer is complete. */\n\tif (xfer->c_bcount > 0) {\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\t/* Start the next operation */\n\t\t\t_wdc_ata_bio_start(chp, xfer);\n\t\t} else {\n\t\t\t/* Let _wdc_ata_bio_start do the loop */\n\t\t\treturn 1;\n\t\t}\n\t} else { /* Done with this transfer */\n\t\tata_bio->error = NOERROR;\n\t\twdc_ata_bio_done(chp, xfer);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_output_bytes",
          "args": [
            "drvp",
            "(char *)xfer->databuf + xfer->c_skip",
            "ata_bio->nbytes"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_output_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1164-1192",
          "snippet": "void\nwdc_output_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\t\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_WRITE_RAW_MULTI_4(chp, \n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t        CHP_WRITE_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_output_bytes(drvp, bytes, buflen)\n\tstruct ata_drive_datas *drvp;\n\tvoid *bytes;\n\tunsigned int buflen;\n{\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\tunsigned int off = 0;\n\tunsigned int len = buflen, roundlen;\t\n\n\tif (drvp->drive_flags & DRIVE_CAP32) {\n\t\troundlen = len & ~3;\n\n\t\tCHP_WRITE_RAW_MULTI_4(chp, \n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\n\t\toff += roundlen;\n\t\tlen -= roundlen;\n\t}\n\n\tif (len > 0) {\n\t\troundlen = (len + 1) & ~0x1;\n\n\t        CHP_WRITE_RAW_MULTI_2(chp,\n\t\t    (void *)((u_int8_t *)bytes + off), roundlen);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_drq",
          "args": [
            "chp",
            "ata_delay"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdccommand",
          "args": [
            "chp",
            "xfer->drive",
            "cmd",
            "cyl",
            "head",
            "sect",
            "nblks",
            "(ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t    ata_bio->lp->d_precompcyl / 4 : 0"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "wdccommandshort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1534-1548",
          "snippet": "void\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nvoid\nwdccommandshort(chp, drive, command)\n\tstruct channel_softc *chp;\n\tint drive;\n\tint command;\n{\n\n\tWDCDEBUG_PRINT((\"wdccommandshort %s:%d:%d command 0x%x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, drive, command),\n\t    DEBUG_FUNCS);\n\n\t/* Select drive. */\n\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drive << 4));\n\tCHP_WRITE_REG(chp, wdr_command, command);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_ready",
          "args": [
            "chp",
            "ata_delay"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (xfer->drive << 4)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nblks",
            "ata_bio->multi"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "seq_do_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "804-819",
          "snippet": "int\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nint\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp->wdc->dma_arg",
            "chp->channel",
            "xfer->drive",
            "dma_flags"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_ready",
          "args": [
            "chp",
            "ata_delay"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (xfer->drive << 4)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "chp->wdc->dma_arg",
            "chp->channel",
            "xfer->drive",
            "(char *)xfer->databuf + xfer->c_skip",
            "ata_bio->nbytes",
            "dma_flags"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdc_ata_ctrl_intr",
          "args": [
            "chp",
            "xfer",
            "0"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_ata_ctrl_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "573-721",
          "snippet": "int\nwdc_ata_ctrl_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tchar *errstring = NULL;\n\tint delay = (irq == 0) ? ATA_DELAY : 0;\n\n\tWDCDEBUG_PRINT((\"wdc_ata_ctrl_intr: state %d\\n\", drvp->state),\n\t    DEBUG_FUNCS);\n\nagain:\n\tswitch (drvp->state) {\n\tcase RECAL:    /* Should not be in this state here */\n\t\tpanic(\"wdc_ata_ctrl_intr: state==RECAL\");\n\t\tbreak;\n\n\tcase RECAL_WAIT:\n\t\terrstring = \"recal\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase PIOMODE:\n\t\t/* Don't try to set modes if controller can't be adjusted */\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\t\tgoto geometry;\n\t\t/* Also don't try if the drive didn't report its mode */\n\t\tif ((drvp->drive_flags & DRIVE_MODE) == 0)\n\t\t\tgoto geometry;\n\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t    0x08 | drvp->PIO_mode, WDSF_SET_MODE);\n\t\tdrvp->state = PIOMODE_WAIT;\n\t\tbreak;\n\n\tcase PIOMODE_WAIT:\n\t\terrstring = \"piomode\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase DMAMODE:\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x40 | drvp->UDMA_mode, WDSF_SET_MODE);\n\t\t} else if (drvp->drive_flags & DRIVE_DMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x20 | drvp->DMA_mode, WDSF_SET_MODE);\n\t\t} else {\n\t\t\tgoto geometry;\n\t\t}\t\n\t\tdrvp->state = DMAMODE_WAIT;\n\t\tbreak;\n\tcase DMAMODE_WAIT:\n\t\terrstring = \"dmamode\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase GEOMETRY:\n\tgeometry:\n\t\tif (ata_bio->flags & ATA_LBA)\n\t\t\tgoto multimode;\n\t\twdccommand(chp, xfer->drive, WDCC_IDP,\n\t\t    ata_bio->lp->d_ncylinders,\n\t\t    ata_bio->lp->d_ntracks - 1, 0, ata_bio->lp->d_nsectors,\n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t\tata_bio->lp->d_precompcyl / 4 : 0);\n\t\tdrvp->state = GEOMETRY_WAIT;\n\t\tbreak;\n\n\tcase GEOMETRY_WAIT:\n\t\terrstring = \"geometry\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t\t/* fall through */\n\n\tcase MULTIMODE:\n\tmultimode:\n\t\tif (ata_bio->multi == 1)\n\t\t\tgoto ready;\n\t\twdccommand(chp, xfer->drive, WDCC_SETMULTI, 0, 0, 0,\n\t\t    ata_bio->multi, 0);\n\t\tdrvp->state = MULTIMODE_WAIT;\n\t\tbreak;\n\n\tcase MULTIMODE_WAIT:\n\t\terrstring = \"setmulti\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t\t/* fall through */\n\n\tcase READY:\n\tready:\n\t\tdrvp->state = READY;\n\t\t/*\n\t\t * The drive is usable now\n\t\t */\n\t\txfer->c_intr = wdc_ata_bio_intr;\n\t\t_wdc_ata_bio_start(chp, xfer); \n\t\treturn 1;\n\t}\n\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\tgoto again;\n\t}\n\treturn 1;\n\ntimeout:\n\tif (irq && (xfer->c_flags & C_TIMEOU) == 0) {\n\t\treturn 0; /* IRQ was not for us */\n\t}\n\tprintf(\"%s:%d:%d: %s timed out\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, errstring);\n\tata_bio->error = TIMEOUT;\n\tdrvp->state = 0;\n\twdc_ata_bio_done(chp, xfer);\n\treturn 0;\nerror:\n\tprintf(\"%s:%d:%d: %s \",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    errstring);\n\tif (chp->ch_status & WDCS_DWF) {\n\t\tprintf(\"drive fault\\n\");\n\t\tata_bio->error = ERR_DF;\n\t} else {\n\t\tprintf(\"error (%x)\\n\", chp->ch_error);\n\t\tata_bio->r_error = chp->ch_error;\n\t\tata_bio->error = ERROR;\n\t}\n\tdrvp->state = 0;\n\twdc_ata_bio_done(chp, xfer);\n\treturn 1;\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ATA_DELAY 10000 /* 10s for a drive I/O */",
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "void  _wdc_ata_bio_start",
            "int   wdc_ata_bio_intr",
            "void  wdc_ata_bio_done",
            "int   wdc_ata_ctrl_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ATA_DELAY 10000 /* 10s for a drive I/O */\n#define DEBUG_FUNCS  0x08\n\nvoid  _wdc_ata_bio_start;\nint   wdc_ata_bio_intr;\nvoid  wdc_ata_bio_done;\nint   wdc_ata_ctrl_intr;\n\nint\nwdc_ata_ctrl_intr(chp, xfer, irq)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n\tint irq;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tchar *errstring = NULL;\n\tint delay = (irq == 0) ? ATA_DELAY : 0;\n\n\tWDCDEBUG_PRINT((\"wdc_ata_ctrl_intr: state %d\\n\", drvp->state),\n\t    DEBUG_FUNCS);\n\nagain:\n\tswitch (drvp->state) {\n\tcase RECAL:    /* Should not be in this state here */\n\t\tpanic(\"wdc_ata_ctrl_intr: state==RECAL\");\n\t\tbreak;\n\n\tcase RECAL_WAIT:\n\t\terrstring = \"recal\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase PIOMODE:\n\t\t/* Don't try to set modes if controller can't be adjusted */\n\t\tif ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0)\n\t\t\tgoto geometry;\n\t\t/* Also don't try if the drive didn't report its mode */\n\t\tif ((drvp->drive_flags & DRIVE_MODE) == 0)\n\t\t\tgoto geometry;\n\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t    0x08 | drvp->PIO_mode, WDSF_SET_MODE);\n\t\tdrvp->state = PIOMODE_WAIT;\n\t\tbreak;\n\n\tcase PIOMODE_WAIT:\n\t\terrstring = \"piomode\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase DMAMODE:\n\t\tif (drvp->drive_flags & DRIVE_UDMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x40 | drvp->UDMA_mode, WDSF_SET_MODE);\n\t\t} else if (drvp->drive_flags & DRIVE_DMA) {\n\t\t\twdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,\n\t\t\t    0x20 | drvp->DMA_mode, WDSF_SET_MODE);\n\t\t} else {\n\t\t\tgoto geometry;\n\t\t}\t\n\t\tdrvp->state = DMAMODE_WAIT;\n\t\tbreak;\n\tcase DMAMODE_WAIT:\n\t\terrstring = \"dmamode\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t/* fall through */\n\n\tcase GEOMETRY:\n\tgeometry:\n\t\tif (ata_bio->flags & ATA_LBA)\n\t\t\tgoto multimode;\n\t\twdccommand(chp, xfer->drive, WDCC_IDP,\n\t\t    ata_bio->lp->d_ncylinders,\n\t\t    ata_bio->lp->d_ntracks - 1, 0, ata_bio->lp->d_nsectors,\n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t\tata_bio->lp->d_precompcyl / 4 : 0);\n\t\tdrvp->state = GEOMETRY_WAIT;\n\t\tbreak;\n\n\tcase GEOMETRY_WAIT:\n\t\terrstring = \"geometry\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t\t/* fall through */\n\n\tcase MULTIMODE:\n\tmultimode:\n\t\tif (ata_bio->multi == 1)\n\t\t\tgoto ready;\n\t\twdccommand(chp, xfer->drive, WDCC_SETMULTI, 0, 0, 0,\n\t\t    ata_bio->multi, 0);\n\t\tdrvp->state = MULTIMODE_WAIT;\n\t\tbreak;\n\n\tcase MULTIMODE_WAIT:\n\t\terrstring = \"setmulti\";\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, delay))\n\t\t\tgoto timeout;\n\t\tif (chp->ch_status & (WDCS_ERR | WDCS_DWF))\n\t\t\tgoto error;\n\t\t/* fall through */\n\n\tcase READY:\n\tready:\n\t\tdrvp->state = READY;\n\t\t/*\n\t\t * The drive is usable now\n\t\t */\n\t\txfer->c_intr = wdc_ata_bio_intr;\n\t\t_wdc_ata_bio_start(chp, xfer); \n\t\treturn 1;\n\t}\n\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\tgoto again;\n\t}\n\treturn 1;\n\ntimeout:\n\tif (irq && (xfer->c_flags & C_TIMEOU) == 0) {\n\t\treturn 0; /* IRQ was not for us */\n\t}\n\tprintf(\"%s:%d:%d: %s timed out\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, errstring);\n\tata_bio->error = TIMEOUT;\n\tdrvp->state = 0;\n\twdc_ata_bio_done(chp, xfer);\n\treturn 0;\nerror:\n\tprintf(\"%s:%d:%d: %s \",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    errstring);\n\tif (chp->ch_status & WDCS_DWF) {\n\t\tprintf(\"drive fault\\n\");\n\t\tata_bio->error = ERR_DF;\n\t} else {\n\t\tprintf(\"error (%x)\\n\", chp->ch_error);\n\t\tata_bio->r_error = chp->ch_error;\n\t\tata_bio->error = ERROR;\n\t}\n\tdrvp->state = 0;\n\twdc_ata_bio_done(chp, xfer);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wdcwait",
          "args": [
            "chp",
            "WDCS_DRDY",
            "WDCS_DRDY",
            "ATA_DELAY"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "wdcwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "879-950",
          "snippet": "int\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_STATUSX 0x20",
            "#define DEBUG_STATUS 0x04",
            "#define WDCNDELAY_DEBUG\t50",
            "#define WDCDELAY  100 /* 100 microseconds */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_STATUSX 0x20\n#define DEBUG_STATUS 0x04\n#define WDCNDELAY_DEBUG\t50\n#define WDCDELAY  100 /* 100 microseconds */\n\nint\nwdcwait(chp, mask, bits, timeout)\n\tstruct channel_softc *chp;\n\tint mask, bits, timeout;\n{\n\tu_char status;\n\tint time = 0;\n\n#ifdef WDCNDELAY_DEBUG\n\textern int cold;\n#endif\n\n\tWDCDEBUG_PRINT((\"wdcwait %s:%d\\n\", chp->wdc ?chp->wdc->sc_dev.dv_xname\n\t    :\"none\", chp->channel), DEBUG_STATUS);\n\tchp->ch_error = 0;\n\n\ttimeout = timeout * 1000 / WDCDELAY; /* delay uses microseconds */\n\n\tfor (;;) {\n#ifdef TEST_ALTSTS\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\tchp->ch_status = status = CHP_READ_REG(chp, wdr_status);\n#endif\n\t\tif (status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);\n#ifdef TEST_ALTSTS\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_altsts);\n#else\n\t\t\tchp->ch_status = status = \n\t\t\t    CHP_READ_REG(chp, wdr_status);\n#endif\n\t\t}\n\t\tif ((status & WDCS_BSY) == 0 && (status & mask) == bits) \n\t\t\tbreak;\n\t\tif (++time > timeout) {\n\t\t\tWDCDEBUG_PRINT((\"wdcwait: timeout, status %x \"\n\t\t\t    \"error %x\\n\", status,\n\t\t\t    CHP_READ_REG(chp, wdr_error)),\n\t\t\t    DEBUG_STATUSX | DEBUG_STATUS); \n\t\t\treturn -1;\n\t\t}\n\t\tdelay(WDCDELAY);\n\t}\n#ifdef TEST_ALTSTS\n\t/* Acknowledge any pending interrupts */\n\tCHP_READ_REG(chp, wdr_status);\n#endif\n\tif (status & WDCS_ERR) {\n\t\tchp->ch_error = CHP_READ_REG(chp, wdr_error);\n\t\tWDCDEBUG_PRINT((\"wdcwait: error %x\\n\", chp->ch_error),\n\t\t\t       DEBUG_STATUSX | DEBUG_STATUS);\n\t}\n\n#ifdef WDCNDELAY_DEBUG\n\t/* After autoconfig, there should be no long delays. */\n\tif (!cold && time > WDCNDELAY_DEBUG) {\n\t\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\t\tif (xfer == NULL)\n\t\t\tprintf(\"%s channel %d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    WDCDELAY * time);\n\t\telse \n\t\t\tprintf(\"%s:%d:%d: warning: busy-wait took %dus\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive,\n\t\t\t    WDCDELAY * time);\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHP_WRITE_REG",
          "args": [
            "chp",
            "wdr_sdh",
            "WDSD_IBM | (xfer->drive << 4)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"_wdc_ata_bio_start: bad state\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"_wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive)",
            "DEBUG_INTR | DEBUG_XFERS"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_ATA_ERR   0x02 /* Drive reports an error */\n#define ATA_DELAY 10000 /* 10s for a drive I/O */\n#define DEBUG_XFERS  0x02\n#define DEBUG_INTR   0x01\n\nvoid  _wdc_ata_bio_start;\nint   wdc_ata_bio_intr;\nvoid  wdc_ata_bio_done;\nint   wdc_ata_ctrl_intr;\nint   wdc_ata_err;\n\nvoid\n_wdc_ata_bio_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tu_int16_t cyl;\n\tu_int8_t head, sect, cmd = 0;\n\tint nblks;\n\tint ata_delay;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"_wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\t/* Do control operations specially. */\n\tif (drvp->state < READY) {\n\t\t/*\n\t\t * Actually, we want to be careful not to mess with the control\n\t\t * state if the device is currently busy, but we can assume\n\t\t * that we never get to this point if that's the case.\n\t\t */\n\t\t/* at this point, we should only be in RECAL state */\n\t\tif (drvp->state != RECAL) {\n\t\t\tprintf(\"%s:%d:%d: bad state %d in _wdc_ata_bio_start\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, drvp->state);\n\t\t\tpanic(\"_wdc_ata_bio_start: bad state\");\n\t\t}\n\t\txfer->c_intr = wdc_ata_ctrl_intr;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, ATA_DELAY) != 0)\n\t\t\tgoto timeout;\n\t\twdccommandshort(chp, xfer->drive, WDCC_RECAL);\n\t\tdrvp->state = RECAL_WAIT;\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t} else {\n\t\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\t\tDELAY(1);\n\t\t\twdc_ata_ctrl_intr(chp, xfer, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\tif (ata_bio->flags & ATA_SINGLE)\n\t\tata_delay = ATA_DELAY;\n\telse\n\t\tata_delay = ATA_DELAY;\n again:\n\t/*\n\t *\n\t * When starting a multi-sector transfer, or doing single-sector\n\t * transfers...\n\t */\n\tif (xfer->c_skip == 0 || (ata_bio->flags & ATA_SINGLE) != 0) {\n\t\tif (ata_bio->flags & ATA_SINGLE)\n\t\t\tnblks = 1;\n\t\telse \n\t\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\t/* Check for bad sectors and adjust transfer, if necessary. */\n\t\tif ((ata_bio->lp->d_flags & D_BADSECT) != 0) {\n\t\t\tlong blkdiff;\n\t\t\tint i;\n\t\t\tfor (i = 0; (blkdiff = ata_bio->badsect[i]) != -1;\n\t\t\t     i++) {\n\t\t\t\tblkdiff -= ata_bio->blkno;\n\t\t\t\tif (blkdiff < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (blkdiff == 0) {\n\t\t\t\t\t/* Replace current block of transfer. */\n\t\t\t\t\tata_bio->blkno =\n\t\t\t\t\t    ata_bio->lp->d_secperunit -\n\t\t\t\t\t    ata_bio->lp->d_nsectors - i - 1;\n\t\t\t\t}\n\t\t\t\tif (blkdiff < nblks) {\n\t\t\t\t\t/* Bad block inside transfer. */\n\t\t\t\t\tata_bio->flags |= ATA_SINGLE;\n\t\t\t\t\tnblks = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Transfer is okay now. */\n\t\t}\n\t\tif (ata_bio->flags & ATA_LBA) {\n\t\t\tsect = (ata_bio->blkno >> 0) & 0xff;\n\t\t\tcyl = (ata_bio->blkno >> 8) & 0xffff;\n\t\t\thead = (ata_bio->blkno >> 24) & 0x0f;\n\t\t\thead |= WDSD_LBA;\n\t\t} else {\n\t\t\tint blkno = ata_bio->blkno;\n\t\t\tsect = blkno % ata_bio->lp->d_nsectors;\n\t\t\tsect++;    /* Sectors begin with 1, not 0. */\n\t\t\tblkno /= ata_bio->lp->d_nsectors;\n\t\t\thead = blkno % ata_bio->lp->d_ntracks;\n\t\t\tblkno /= ata_bio->lp->d_ntracks;\n\t\t\tcyl = blkno;\n\t\t\thead |= WDSD_CHS;\n\t\t}\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READDMA : WDCC_WRITEDMA;\n\t\t\tnblks = ata_bio->nblks;\n\t    \t\t/* Init the DMA channel. */\n\t\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip, \n\t\t\t    ata_bio->nbytes, dma_flags) != 0) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tata_bio->r_error = 0;\n\t\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Initiate command */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, \n\t\t\t    WDSD_IBM | (xfer->drive << 4));\n\t\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\t\tgoto timeout;\n\t\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t\t    head, sect, nblks, 0);\n\t\t\t/* start the DMA channel */\n\t\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\t/* wait for irq */\n\t\t\tgoto intr;\n\t\t} /* else not DMA */\n\t\tata_bio->nblks = min(nblks, ata_bio->multi);\n\t\tata_bio->nbytes = ata_bio->nblks * ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > 1 && (ata_bio->flags & ATA_SINGLE) == 0) {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READMULTI : WDCC_WRITEMULTI;\n\t\t} else {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READ : WDCC_WRITE;\n\t\t}\n\t\t/* Initiate command! */\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\tgoto timeout;\n\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t    head, sect, nblks, \n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t    ata_bio->lp->d_precompcyl / 4 : 0);\n\t} else if (ata_bio->nblks > 1) {\n\t\t/* The number of blocks in the last stretch may be smaller. */\n\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > nblks) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t}\n\t}\n\t/* If this was a write and not using DMA, push the data. */\n\tif ((ata_bio->flags & ATA_READ) == 0) {\n\t\tif (wait_for_drq(chp, ata_delay) != 0) {\n\t\t\tprintf(\"%s:%d:%d: timeout waiting for DRQ, \"\n\t\t\t    \"st=0x%02x, err=0x%02x\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, chp->ch_status, chp->ch_error);\n\t\t\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\tif (wdc_ata_err(drvp, ata_bio) == WDC_ATA_ERR) {\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\twdc_output_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\n\n intr:\t/* Wait for IRQ (either real or polled) */\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\tdelay(1);\n\t\twdc_ata_bio_intr(chp, xfer, 0);\n\t\tif ((ata_bio->flags & ATA_ITSDONE) == 0)\n\t\t\tgoto again;\n\t}\n\treturn;\n timeout:\n\tprintf(\"%s:%d:%d: not ready, st=0x%02x, err=0x%02x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    chp->ch_status, chp->ch_error);\n\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\tata_bio->error = TIMEOUT;\n\twdc_ata_bio_done(chp, xfer);\n\treturn;\n}"
  },
  {
    "function_name": "wdc_ata_bio_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
    "lines": "158-172",
    "snippet": "void\nwdc_ata_bio_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_XFERS);\n\n\t/* start timeout machinery */\n\tif ((ata_bio->flags & ATA_POLL) == 0)\n\t\ttimeout(wdctimeout, chp, ATA_DELAY / 1000 * hz);\n\t_wdc_ata_bio_start(chp, xfer);\n}",
    "includes": [
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define ATA_DELAY 10000 /* 10s for a drive I/O */",
      "#define DEBUG_XFERS  0x02"
    ],
    "globals_used": [
      "void  wdc_ata_bio_start",
      "void  _wdc_ata_bio_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_wdc_ata_bio_start",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "_wdc_ata_bio_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
          "lines": "174-371",
          "snippet": "void\n_wdc_ata_bio_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tu_int16_t cyl;\n\tu_int8_t head, sect, cmd = 0;\n\tint nblks;\n\tint ata_delay;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"_wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\t/* Do control operations specially. */\n\tif (drvp->state < READY) {\n\t\t/*\n\t\t * Actually, we want to be careful not to mess with the control\n\t\t * state if the device is currently busy, but we can assume\n\t\t * that we never get to this point if that's the case.\n\t\t */\n\t\t/* at this point, we should only be in RECAL state */\n\t\tif (drvp->state != RECAL) {\n\t\t\tprintf(\"%s:%d:%d: bad state %d in _wdc_ata_bio_start\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, drvp->state);\n\t\t\tpanic(\"_wdc_ata_bio_start: bad state\");\n\t\t}\n\t\txfer->c_intr = wdc_ata_ctrl_intr;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, ATA_DELAY) != 0)\n\t\t\tgoto timeout;\n\t\twdccommandshort(chp, xfer->drive, WDCC_RECAL);\n\t\tdrvp->state = RECAL_WAIT;\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t} else {\n\t\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\t\tDELAY(1);\n\t\t\twdc_ata_ctrl_intr(chp, xfer, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\tif (ata_bio->flags & ATA_SINGLE)\n\t\tata_delay = ATA_DELAY;\n\telse\n\t\tata_delay = ATA_DELAY;\n again:\n\t/*\n\t *\n\t * When starting a multi-sector transfer, or doing single-sector\n\t * transfers...\n\t */\n\tif (xfer->c_skip == 0 || (ata_bio->flags & ATA_SINGLE) != 0) {\n\t\tif (ata_bio->flags & ATA_SINGLE)\n\t\t\tnblks = 1;\n\t\telse \n\t\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\t/* Check for bad sectors and adjust transfer, if necessary. */\n\t\tif ((ata_bio->lp->d_flags & D_BADSECT) != 0) {\n\t\t\tlong blkdiff;\n\t\t\tint i;\n\t\t\tfor (i = 0; (blkdiff = ata_bio->badsect[i]) != -1;\n\t\t\t     i++) {\n\t\t\t\tblkdiff -= ata_bio->blkno;\n\t\t\t\tif (blkdiff < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (blkdiff == 0) {\n\t\t\t\t\t/* Replace current block of transfer. */\n\t\t\t\t\tata_bio->blkno =\n\t\t\t\t\t    ata_bio->lp->d_secperunit -\n\t\t\t\t\t    ata_bio->lp->d_nsectors - i - 1;\n\t\t\t\t}\n\t\t\t\tif (blkdiff < nblks) {\n\t\t\t\t\t/* Bad block inside transfer. */\n\t\t\t\t\tata_bio->flags |= ATA_SINGLE;\n\t\t\t\t\tnblks = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Transfer is okay now. */\n\t\t}\n\t\tif (ata_bio->flags & ATA_LBA) {\n\t\t\tsect = (ata_bio->blkno >> 0) & 0xff;\n\t\t\tcyl = (ata_bio->blkno >> 8) & 0xffff;\n\t\t\thead = (ata_bio->blkno >> 24) & 0x0f;\n\t\t\thead |= WDSD_LBA;\n\t\t} else {\n\t\t\tint blkno = ata_bio->blkno;\n\t\t\tsect = blkno % ata_bio->lp->d_nsectors;\n\t\t\tsect++;    /* Sectors begin with 1, not 0. */\n\t\t\tblkno /= ata_bio->lp->d_nsectors;\n\t\t\thead = blkno % ata_bio->lp->d_ntracks;\n\t\t\tblkno /= ata_bio->lp->d_ntracks;\n\t\t\tcyl = blkno;\n\t\t\thead |= WDSD_CHS;\n\t\t}\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READDMA : WDCC_WRITEDMA;\n\t\t\tnblks = ata_bio->nblks;\n\t    \t\t/* Init the DMA channel. */\n\t\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip, \n\t\t\t    ata_bio->nbytes, dma_flags) != 0) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tata_bio->r_error = 0;\n\t\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Initiate command */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, \n\t\t\t    WDSD_IBM | (xfer->drive << 4));\n\t\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\t\tgoto timeout;\n\t\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t\t    head, sect, nblks, 0);\n\t\t\t/* start the DMA channel */\n\t\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\t/* wait for irq */\n\t\t\tgoto intr;\n\t\t} /* else not DMA */\n\t\tata_bio->nblks = min(nblks, ata_bio->multi);\n\t\tata_bio->nbytes = ata_bio->nblks * ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > 1 && (ata_bio->flags & ATA_SINGLE) == 0) {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READMULTI : WDCC_WRITEMULTI;\n\t\t} else {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READ : WDCC_WRITE;\n\t\t}\n\t\t/* Initiate command! */\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\tgoto timeout;\n\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t    head, sect, nblks, \n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t    ata_bio->lp->d_precompcyl / 4 : 0);\n\t} else if (ata_bio->nblks > 1) {\n\t\t/* The number of blocks in the last stretch may be smaller. */\n\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > nblks) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t}\n\t}\n\t/* If this was a write and not using DMA, push the data. */\n\tif ((ata_bio->flags & ATA_READ) == 0) {\n\t\tif (wait_for_drq(chp, ata_delay) != 0) {\n\t\t\tprintf(\"%s:%d:%d: timeout waiting for DRQ, \"\n\t\t\t    \"st=0x%02x, err=0x%02x\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, chp->ch_status, chp->ch_error);\n\t\t\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\tif (wdc_ata_err(drvp, ata_bio) == WDC_ATA_ERR) {\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\twdc_output_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\n\n intr:\t/* Wait for IRQ (either real or polled) */\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\tdelay(1);\n\t\twdc_ata_bio_intr(chp, xfer, 0);\n\t\tif ((ata_bio->flags & ATA_ITSDONE) == 0)\n\t\t\tgoto again;\n\t}\n\treturn;\n timeout:\n\tprintf(\"%s:%d:%d: not ready, st=0x%02x, err=0x%02x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    chp->ch_status, chp->ch_error);\n\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\tata_bio->error = TIMEOUT;\n\twdc_ata_bio_done(chp, xfer);\n\treturn;\n}",
          "includes": [
            "#include <dev/ata/wdvar.h>",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/ata/atareg.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define WDC_ATA_ERR   0x02 /* Drive reports an error */",
            "#define ATA_DELAY 10000 /* 10s for a drive I/O */",
            "#define DEBUG_XFERS  0x02",
            "#define DEBUG_INTR   0x01"
          ],
          "globals_used": [
            "void  _wdc_ata_bio_start",
            "int   wdc_ata_bio_intr",
            "void  wdc_ata_bio_done",
            "int   wdc_ata_ctrl_intr",
            "int   wdc_ata_err"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define WDC_ATA_ERR   0x02 /* Drive reports an error */\n#define ATA_DELAY 10000 /* 10s for a drive I/O */\n#define DEBUG_XFERS  0x02\n#define DEBUG_INTR   0x01\n\nvoid  _wdc_ata_bio_start;\nint   wdc_ata_bio_intr;\nvoid  wdc_ata_bio_done;\nint   wdc_ata_ctrl_intr;\nint   wdc_ata_err;\n\nvoid\n_wdc_ata_bio_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tstruct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];\n\tu_int16_t cyl;\n\tu_int8_t head, sect, cmd = 0;\n\tint nblks;\n\tint ata_delay;\n\tint dma_flags = 0;\n\n\tWDCDEBUG_PRINT((\"_wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_INTR | DEBUG_XFERS);\n\t/* Do control operations specially. */\n\tif (drvp->state < READY) {\n\t\t/*\n\t\t * Actually, we want to be careful not to mess with the control\n\t\t * state if the device is currently busy, but we can assume\n\t\t * that we never get to this point if that's the case.\n\t\t */\n\t\t/* at this point, we should only be in RECAL state */\n\t\tif (drvp->state != RECAL) {\n\t\t\tprintf(\"%s:%d:%d: bad state %d in _wdc_ata_bio_start\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, drvp->state);\n\t\t\tpanic(\"_wdc_ata_bio_start: bad state\");\n\t\t}\n\t\txfer->c_intr = wdc_ata_ctrl_intr;\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wdcwait(chp, WDCS_DRDY, WDCS_DRDY, ATA_DELAY) != 0)\n\t\t\tgoto timeout;\n\t\twdccommandshort(chp, xfer->drive, WDCC_RECAL);\n\t\tdrvp->state = RECAL_WAIT;\n\t\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t\t} else {\n\t\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\t\tDELAY(1);\n\t\t\twdc_ata_ctrl_intr(chp, xfer, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (xfer->c_flags & C_DMA) {\n\t\tdma_flags = (ata_bio->flags & ATA_READ) ?  WDC_DMA_READ : 0;\n\t\tdma_flags |= (ata_bio->flags & ATA_POLL) ?  WDC_DMA_POLL : 0;\n\t}\n\tif (ata_bio->flags & ATA_SINGLE)\n\t\tata_delay = ATA_DELAY;\n\telse\n\t\tata_delay = ATA_DELAY;\n again:\n\t/*\n\t *\n\t * When starting a multi-sector transfer, or doing single-sector\n\t * transfers...\n\t */\n\tif (xfer->c_skip == 0 || (ata_bio->flags & ATA_SINGLE) != 0) {\n\t\tif (ata_bio->flags & ATA_SINGLE)\n\t\t\tnblks = 1;\n\t\telse \n\t\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\t/* Check for bad sectors and adjust transfer, if necessary. */\n\t\tif ((ata_bio->lp->d_flags & D_BADSECT) != 0) {\n\t\t\tlong blkdiff;\n\t\t\tint i;\n\t\t\tfor (i = 0; (blkdiff = ata_bio->badsect[i]) != -1;\n\t\t\t     i++) {\n\t\t\t\tblkdiff -= ata_bio->blkno;\n\t\t\t\tif (blkdiff < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (blkdiff == 0) {\n\t\t\t\t\t/* Replace current block of transfer. */\n\t\t\t\t\tata_bio->blkno =\n\t\t\t\t\t    ata_bio->lp->d_secperunit -\n\t\t\t\t\t    ata_bio->lp->d_nsectors - i - 1;\n\t\t\t\t}\n\t\t\t\tif (blkdiff < nblks) {\n\t\t\t\t\t/* Bad block inside transfer. */\n\t\t\t\t\tata_bio->flags |= ATA_SINGLE;\n\t\t\t\t\tnblks = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Transfer is okay now. */\n\t\t}\n\t\tif (ata_bio->flags & ATA_LBA) {\n\t\t\tsect = (ata_bio->blkno >> 0) & 0xff;\n\t\t\tcyl = (ata_bio->blkno >> 8) & 0xffff;\n\t\t\thead = (ata_bio->blkno >> 24) & 0x0f;\n\t\t\thead |= WDSD_LBA;\n\t\t} else {\n\t\t\tint blkno = ata_bio->blkno;\n\t\t\tsect = blkno % ata_bio->lp->d_nsectors;\n\t\t\tsect++;    /* Sectors begin with 1, not 0. */\n\t\t\tblkno /= ata_bio->lp->d_nsectors;\n\t\t\thead = blkno % ata_bio->lp->d_ntracks;\n\t\t\tblkno /= ata_bio->lp->d_ntracks;\n\t\t\tcyl = blkno;\n\t\t\thead |= WDSD_CHS;\n\t\t}\n\t\tif (xfer->c_flags & C_DMA) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READDMA : WDCC_WRITEDMA;\n\t\t\tnblks = ata_bio->nblks;\n\t    \t\t/* Init the DMA channel. */\n\t\t\tif ((*chp->wdc->dma_init)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive,\n\t\t\t    (char *)xfer->databuf + xfer->c_skip, \n\t\t\t    ata_bio->nbytes, dma_flags) != 0) {\n\t\t\t\tata_bio->error = ERR_DMA;\n\t\t\t\tata_bio->r_error = 0;\n\t\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* Initiate command */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, \n\t\t\t    WDSD_IBM | (xfer->drive << 4));\n\t\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\t\tgoto timeout;\n\t\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t\t    head, sect, nblks, 0);\n\t\t\t/* start the DMA channel */\n\t\t\t(*chp->wdc->dma_start)(chp->wdc->dma_arg,\n\t\t\t    chp->channel, xfer->drive, dma_flags);\n\t\t\t/* wait for irq */\n\t\t\tgoto intr;\n\t\t} /* else not DMA */\n\t\tata_bio->nblks = min(nblks, ata_bio->multi);\n\t\tata_bio->nbytes = ata_bio->nblks * ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > 1 && (ata_bio->flags & ATA_SINGLE) == 0) {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READMULTI : WDCC_WRITEMULTI;\n\t\t} else {\n\t\t\tcmd = (ata_bio->flags & ATA_READ) ?\n\t\t\t    WDCC_READ : WDCC_WRITE;\n\t\t}\n\t\t/* Initiate command! */\n\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));\n\t\tif (wait_for_ready(chp, ata_delay) < 0)\n\t\t\tgoto timeout;\n\t\twdccommand(chp, xfer->drive, cmd, cyl,\n\t\t    head, sect, nblks, \n\t\t    (ata_bio->lp->d_type == DTYPE_ST506) ?\n\t\t    ata_bio->lp->d_precompcyl / 4 : 0);\n\t} else if (ata_bio->nblks > 1) {\n\t\t/* The number of blocks in the last stretch may be smaller. */\n\t\tnblks = xfer->c_bcount / ata_bio->lp->d_secsize;\n\t\tif (ata_bio->nblks > nblks) {\n\t\t\tata_bio->nblks = nblks;\n\t\t\tata_bio->nbytes = xfer->c_bcount;\n\t\t}\n\t}\n\t/* If this was a write and not using DMA, push the data. */\n\tif ((ata_bio->flags & ATA_READ) == 0) {\n\t\tif (wait_for_drq(chp, ata_delay) != 0) {\n\t\t\tprintf(\"%s:%d:%d: timeout waiting for DRQ, \"\n\t\t\t    \"st=0x%02x, err=0x%02x\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname, chp->channel,\n\t\t\t    xfer->drive, chp->ch_status, chp->ch_error);\n\t\t\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\t\t\tata_bio->error = TIMEOUT;\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\tif (wdc_ata_err(drvp, ata_bio) == WDC_ATA_ERR) {\n\t\t\twdc_ata_bio_done(chp, xfer);\n\t\t\treturn;\n\t\t}\n\t\twdc_output_bytes(drvp, (char *)xfer->databuf + xfer->c_skip,\n\t\t    ata_bio->nbytes);\n\t}\n\n intr:\t/* Wait for IRQ (either real or polled) */\n\tif ((ata_bio->flags & ATA_POLL) == 0) {\n\t\tchp->ch_flags |= WDCF_IRQ_WAIT;\n\t} else {\n\t\t/* Wait for at last 400ns for status bit to be valid */\n\t\tdelay(1);\n\t\twdc_ata_bio_intr(chp, xfer, 0);\n\t\tif ((ata_bio->flags & ATA_ITSDONE) == 0)\n\t\t\tgoto again;\n\t}\n\treturn;\n timeout:\n\tprintf(\"%s:%d:%d: not ready, st=0x%02x, err=0x%02x\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,\n\t    chp->ch_status, chp->ch_error);\n\tif (wdc_ata_err(drvp, ata_bio) != WDC_ATA_ERR)\n\t\tata_bio->error = TIMEOUT;\n\twdc_ata_bio_done(chp, xfer);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "wdctimeout",
            "chp",
            "ATA_DELAY / 1000 * hz"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WDCDEBUG_PRINT",
          "args": [
            "(\"wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive)",
            "DEBUG_XFERS"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ATA_DELAY 10000 /* 10s for a drive I/O */\n#define DEBUG_XFERS  0x02\n\nvoid  wdc_ata_bio_start;\nvoid  _wdc_ata_bio_start;\n\nvoid\nwdc_ata_bio_start(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct ata_bio *ata_bio = xfer->cmd;\n\tWDCDEBUG_PRINT((\"wdc_ata_bio_start %s:%d:%d\\n\",\n\t    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive),\n\t    DEBUG_XFERS);\n\n\t/* start timeout machinery */\n\tif ((ata_bio->flags & ATA_POLL) == 0)\n\t\ttimeout(wdctimeout, chp, ATA_DELAY / 1000 * hz);\n\t_wdc_ata_bio_start(chp, xfer);\n}"
  },
  {
    "function_name": "wdc_ata_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ata/ata_wdc.c",
    "lines": "131-156",
    "snippet": "int\nwdc_ata_bio(drvp, ata_bio)\n\tstruct ata_drive_datas *drvp;\n\tstruct ata_bio *ata_bio;\n{\n\tstruct wdc_xfer *xfer;\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\txfer = wdc_get_xfer(WDC_NOSLEEP);\n\tif (xfer == NULL)\n\t\treturn WDC_TRY_AGAIN;\n\tif (ata_bio->flags & ATA_POLL)\n\t\txfer->c_flags |= C_POLL;\n\tif ((drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) &&\n\t    (ata_bio->flags & ATA_SINGLE) == 0)\n\t\txfer->c_flags |= C_DMA;\n\txfer->drive = drvp->drive;\n\txfer->cmd = ata_bio;\n\txfer->databuf = ata_bio->databuf;\n\txfer->c_bcount = ata_bio->bcount;\n\txfer->c_start = wdc_ata_bio_start;\n\txfer->c_intr = wdc_ata_bio_intr;\n\txfer->c_kill_xfer = wdc_ata_bio_kill_xfer;\n\twdc_exec_xfer(chp, xfer);\n\treturn (ata_bio->flags & ATA_ITSDONE) ? WDC_COMPLETE : WDC_QUEUED;\n}",
    "includes": [
      "#include <dev/ata/wdvar.h>",
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/ata/atareg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <sys/proc.h>",
      "#include <sys/syslog.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/stat.h>",
      "#include <sys/file.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void  wdc_ata_bio_start",
      "int   wdc_ata_bio_intr",
      "void  wdc_ata_bio_kill_xfer"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdc_exec_xfer",
          "args": [
            "chp",
            "xfer"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_exec_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1552-1577",
          "snippet": "void\nwdc_exec_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tWDCDEBUG_PRINT((\"wdc_exec_xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\n\t/* complete xfer setup */\n\txfer->chp = chp;\n\n\t/*\n\t * If we are a polled command, and the list is not empty,\n\t * we are doing a dump. Drop the list to allow the polled command\n\t * to complete, we're going to reboot soon anyway.\n\t */\n\tif ((xfer->c_flags & C_POLL) != 0 &&\n\t    chp->ch_queue->sc_xfer.tqh_first != NULL) {\n\t\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t}\n\t/* insert at the end of command list */\n\tTAILQ_INSERT_TAIL(&chp->ch_queue->sc_xfer,xfer , c_xferchain);\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_exec_xfer, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_XFERS  0x02"
          ],
          "globals_used": [
            "struct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_XFERS  0x02\n\nstruct wdc_xfer *\nwdc_get_xfer(flags)\n\tint flags;\n\nvoid\nwdc_exec_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tWDCDEBUG_PRINT((\"wdc_exec_xfer %p channel %d drive %d\\n\", xfer,\n\t    chp->channel, xfer->drive), DEBUG_XFERS);\n\n\t/* complete xfer setup */\n\txfer->chp = chp;\n\n\t/*\n\t * If we are a polled command, and the list is not empty,\n\t * we are doing a dump. Drop the list to allow the polled command\n\t * to complete, we're going to reboot soon anyway.\n\t */\n\tif ((xfer->c_flags & C_POLL) != 0 &&\n\t    chp->ch_queue->sc_xfer.tqh_first != NULL) {\n\t\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t}\n\t/* insert at the end of command list */\n\tTAILQ_INSERT_TAIL(&chp->ch_queue->sc_xfer,xfer , c_xferchain);\n\tWDCDEBUG_PRINT((\"wdcstart from wdc_exec_xfer, flags 0x%x\\n\",\n\t    chp->ch_flags), DEBUG_XFERS);\n\twdcstart(chp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_get_xfer",
          "args": [
            "WDC_NOSLEEP"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ata/wdvar.h>\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/ata/atareg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid  wdc_ata_bio_start;\nint   wdc_ata_bio_intr;\nvoid  wdc_ata_bio_kill_xfer;\n\nint\nwdc_ata_bio(drvp, ata_bio)\n\tstruct ata_drive_datas *drvp;\n\tstruct ata_bio *ata_bio;\n{\n\tstruct wdc_xfer *xfer;\n\tstruct channel_softc *chp = drvp->chnl_softc;\n\n\txfer = wdc_get_xfer(WDC_NOSLEEP);\n\tif (xfer == NULL)\n\t\treturn WDC_TRY_AGAIN;\n\tif (ata_bio->flags & ATA_POLL)\n\t\txfer->c_flags |= C_POLL;\n\tif ((drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) &&\n\t    (ata_bio->flags & ATA_SINGLE) == 0)\n\t\txfer->c_flags |= C_DMA;\n\txfer->drive = drvp->drive;\n\txfer->cmd = ata_bio;\n\txfer->databuf = ata_bio->databuf;\n\txfer->c_bcount = ata_bio->bcount;\n\txfer->c_start = wdc_ata_bio_start;\n\txfer->c_intr = wdc_ata_bio_intr;\n\txfer->c_kill_xfer = wdc_ata_bio_kill_xfer;\n\twdc_exec_xfer(chp, xfer);\n\treturn (ata_bio->flags & ATA_ITSDONE) ? WDC_COMPLETE : WDC_QUEUED;\n}"
  }
]