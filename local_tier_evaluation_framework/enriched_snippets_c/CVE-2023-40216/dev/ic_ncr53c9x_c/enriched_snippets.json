[
  {
    "function_name": "ncr53c9x_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "2102-2152",
    "snippet": "void\nncr53c9x_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ncr53c9x_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_softc *sc = sc_link->adapter_softc;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], \"\n\t       \"<state %d, nexus %p, phase(l %x, c %x, p %x), resid %lx, \"\n\t       \"msg(q %x,o %x) %s>\",\n\t\tsc->sc_dev.dv_xname,\n\t\tecb, ecb->flags, ecb->dleft, ecb->stat,\n\t\tsc->sc_state, sc->sc_nexus,\n\t\tNCR_READ_REG(sc, NCR_STAT),\n\t\tsc->sc_phase, sc->sc_prevphase,\n\t\t(long)sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,\n\t\tNCRDMA_ISACTIVE(sc) ? \"DMA active\" : \"\");\n#if NCR53C9X_DEBUG > 1\n\tprintf(\"TRACE: %s.\", ecb->trace);\n#endif\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\n\t\tncr53c9x_init(sc, 1);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tncr53c9x_abort(sc, ecb);\n\n\t\t/* Disable sync mode if stuck in a data phase */\n\t\tif (ecb == sc->sc_nexus &&\n\t\t    (ti->flags & T_SYNCMODE) != 0 &&\n\t\t    (sc->sc_phase & (MSGI|CDI)) == 0) {\n\t\t\tsc_print_addr(sc_link);\n\t\t\tprintf(\"sync negotiation disabled\\n\");\n\t\t\tsc->sc_cfflags |= (1<<(sc_link->target+8));\n\t\t}\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tncr53c9x_init",
      "void\tncr53c9x_timeout",
      "void\tncr53c9x_abort",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sync negotiation disabled\\n\""
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_abort",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "2060-2100",
          "snippet": "void\nncr53c9x_abort(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\n\t/* 2 secs for the abort */\n\tecb->timeout = NCR_ABORT_TIMEOUT;\n\tecb->flags |= ECB_ABORT;\n\n\tif (ecb == sc->sc_nexus) {\n\t\t/*\n\t\t * If we're still selecting, the message will be scheduled\n\t\t * after selection is complete.\n\t\t */\n\t\tif (sc->sc_state == NCR_CONNECTED)\n\t\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\n\t\t/*\n\t\t * Reschedule timeout. First, cancel a queued timeout (if any)\n\t\t * in case someone decides to call ncr53c9x_abort() from\n\t\t * elsewhere.\n\t\t */\n\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\ttimeout(ncr53c9x_timeout, ecb, (ecb->timeout * hz) / 1000);\n\t} else {\n\t\t/* The command should be on the nexus list */\n\t\tif ((ecb->flags & ECB_NEXUS) == 0) {\n\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\tprintf(\"ncr53c9x_abort: not NEXUS\\n\");\n\t\t\tncr53c9x_init(sc, 1);\n\t\t}\n\t\t/*\n\t\t * Just leave the command on the nexus list.\n\t\t * XXX - what choice do we have but to reset the SCSI\n\t\t *\t eventually?\n\t\t */\n\t\tif (sc->sc_state == NCR_IDLE)\n\t\t\tncr53c9x_sched(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_init",
            "void\tncr53c9x_sched",
            "void\tncr53c9x_timeout",
            "void\tncr53c9x_abort",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_timeout;\nvoid\tncr53c9x_abort;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_abort(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\n\t/* 2 secs for the abort */\n\tecb->timeout = NCR_ABORT_TIMEOUT;\n\tecb->flags |= ECB_ABORT;\n\n\tif (ecb == sc->sc_nexus) {\n\t\t/*\n\t\t * If we're still selecting, the message will be scheduled\n\t\t * after selection is complete.\n\t\t */\n\t\tif (sc->sc_state == NCR_CONNECTED)\n\t\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\n\t\t/*\n\t\t * Reschedule timeout. First, cancel a queued timeout (if any)\n\t\t * in case someone decides to call ncr53c9x_abort() from\n\t\t * elsewhere.\n\t\t */\n\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\ttimeout(ncr53c9x_timeout, ecb, (ecb->timeout * hz) / 1000);\n\t} else {\n\t\t/* The command should be on the nexus list */\n\t\tif ((ecb->flags & ECB_NEXUS) == 0) {\n\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\tprintf(\"ncr53c9x_abort: not NEXUS\\n\");\n\t\t\tncr53c9x_init(sc, 1);\n\t\t}\n\t\t/*\n\t\t * Just leave the command on the nexus list.\n\t\t * XXX - what choice do we have but to reset the SCSI\n\t\t *\t eventually?\n\t\t */\n\t\tif (sc->sc_state == NCR_IDLE)\n\t\t\tncr53c9x_sched(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_init",
          "args": [
            "sc",
            "1"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "301-362",
          "snippet": "void\nncr53c9x_init(sc, doreset)\n\tstruct ncr53c9x_softc *sc;\n\tint doreset;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tint r;\n\n\tNCR_TRACE((\"[NCR_INIT(%d)] \", doreset));\n\n\tif (sc->sc_state == 0) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tecb = sc->sc_ecb;\n\t\tbzero(ecb, sizeof(sc->sc_ecb));\n\t\tfor (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);\n\t\t\tecb++;\n\t\t}\n\t\tbzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = NCR_CLEANING;\n\t\tif ((ecb = sc->sc_nexus) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t\twhile ((ecb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t}\n\n\t/*\n\t * reset the chip to a known state\n\t */\n\tncr53c9x_reset(sc);\n\n\tsc->sc_phase = sc->sc_prevphase = INVALID_PHASE;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];\n/* XXX - config flags per target: low bits: no reselect; high bits: no synch */\n\n\t\tti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))\n\t\t\t\t? T_NEGOTIATE : 0) |\n\t\t\t\t((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |\n\t\t\t\tT_NEED_TO_RESET;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = 0;\n\t}\n\n\tif (doreset) {\n\t\tsc->sc_state = NCR_SBR;\n\t\tNCRCMD(sc, NCRCMD_RSTSCSI);\n\t} else {\n\t\tsc->sc_state = NCR_IDLE;\n\t\tncr53c9x_sched(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_init",
            "void\tncr53c9x_sched",
            "void\tncr53c9x_done",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_done;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_init(sc, doreset)\n\tstruct ncr53c9x_softc *sc;\n\tint doreset;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tint r;\n\n\tNCR_TRACE((\"[NCR_INIT(%d)] \", doreset));\n\n\tif (sc->sc_state == 0) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tecb = sc->sc_ecb;\n\t\tbzero(ecb, sizeof(sc->sc_ecb));\n\t\tfor (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);\n\t\t\tecb++;\n\t\t}\n\t\tbzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = NCR_CLEANING;\n\t\tif ((ecb = sc->sc_nexus) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t\twhile ((ecb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t}\n\n\t/*\n\t * reset the chip to a known state\n\t */\n\tncr53c9x_reset(sc);\n\n\tsc->sc_phase = sc->sc_prevphase = INVALID_PHASE;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];\n/* XXX - config flags per target: low bits: no reselect; high bits: no synch */\n\n\t\tti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))\n\t\t\t\t? T_NEGOTIATE : 0) |\n\t\t\t\t((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |\n\t\t\t\tT_NEED_TO_RESET;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = 0;\n\t}\n\n\tif (doreset) {\n\t\tsc->sc_state = NCR_SBR;\n\t\tNCRCMD(sc, NCRCMD_RSTSCSI);\n\t} else {\n\t\tsc->sc_state = NCR_IDLE;\n\t\tncr53c9x_sched(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_ISACTIVE",
          "args": [
            "sc"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_STAT"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "sc_link"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_timeout;\nvoid\tncr53c9x_abort;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ncr53c9x_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_softc *sc = sc_link->adapter_softc;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], \"\n\t       \"<state %d, nexus %p, phase(l %x, c %x, p %x), resid %lx, \"\n\t       \"msg(q %x,o %x) %s>\",\n\t\tsc->sc_dev.dv_xname,\n\t\tecb, ecb->flags, ecb->dleft, ecb->stat,\n\t\tsc->sc_state, sc->sc_nexus,\n\t\tNCR_READ_REG(sc, NCR_STAT),\n\t\tsc->sc_phase, sc->sc_prevphase,\n\t\t(long)sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,\n\t\tNCRDMA_ISACTIVE(sc) ? \"DMA active\" : \"\");\n#if NCR53C9X_DEBUG > 1\n\tprintf(\"TRACE: %s.\", ecb->trace);\n#endif\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\n\t\tncr53c9x_init(sc, 1);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tncr53c9x_abort(sc, ecb);\n\n\t\t/* Disable sync mode if stuck in a data phase */\n\t\tif (ecb == sc->sc_nexus &&\n\t\t    (ti->flags & T_SYNCMODE) != 0 &&\n\t\t    (sc->sc_phase & (MSGI|CDI)) == 0) {\n\t\t\tsc_print_addr(sc_link);\n\t\t\tprintf(\"sync negotiation disabled\\n\");\n\t\t\tsc->sc_cfflags |= (1<<(sc_link->target+8));\n\t\t}\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "ncr53c9x_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "2060-2100",
    "snippet": "void\nncr53c9x_abort(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\n\t/* 2 secs for the abort */\n\tecb->timeout = NCR_ABORT_TIMEOUT;\n\tecb->flags |= ECB_ABORT;\n\n\tif (ecb == sc->sc_nexus) {\n\t\t/*\n\t\t * If we're still selecting, the message will be scheduled\n\t\t * after selection is complete.\n\t\t */\n\t\tif (sc->sc_state == NCR_CONNECTED)\n\t\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\n\t\t/*\n\t\t * Reschedule timeout. First, cancel a queued timeout (if any)\n\t\t * in case someone decides to call ncr53c9x_abort() from\n\t\t * elsewhere.\n\t\t */\n\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\ttimeout(ncr53c9x_timeout, ecb, (ecb->timeout * hz) / 1000);\n\t} else {\n\t\t/* The command should be on the nexus list */\n\t\tif ((ecb->flags & ECB_NEXUS) == 0) {\n\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\tprintf(\"ncr53c9x_abort: not NEXUS\\n\");\n\t\t\tncr53c9x_init(sc, 1);\n\t\t}\n\t\t/*\n\t\t * Just leave the command on the nexus list.\n\t\t * XXX - what choice do we have but to reset the SCSI\n\t\t *\t eventually?\n\t\t */\n\t\tif (sc->sc_state == NCR_IDLE)\n\t\t\tncr53c9x_sched(sc);\n\t}\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tncr53c9x_init",
      "void\tncr53c9x_sched",
      "void\tncr53c9x_timeout",
      "void\tncr53c9x_abort",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr53c9x_sched",
          "args": [
            "sc"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "687-716",
          "snippet": "void\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_sched",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_init",
          "args": [
            "sc",
            "1"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "301-362",
          "snippet": "void\nncr53c9x_init(sc, doreset)\n\tstruct ncr53c9x_softc *sc;\n\tint doreset;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tint r;\n\n\tNCR_TRACE((\"[NCR_INIT(%d)] \", doreset));\n\n\tif (sc->sc_state == 0) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tecb = sc->sc_ecb;\n\t\tbzero(ecb, sizeof(sc->sc_ecb));\n\t\tfor (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);\n\t\t\tecb++;\n\t\t}\n\t\tbzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = NCR_CLEANING;\n\t\tif ((ecb = sc->sc_nexus) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t\twhile ((ecb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t}\n\n\t/*\n\t * reset the chip to a known state\n\t */\n\tncr53c9x_reset(sc);\n\n\tsc->sc_phase = sc->sc_prevphase = INVALID_PHASE;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];\n/* XXX - config flags per target: low bits: no reselect; high bits: no synch */\n\n\t\tti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))\n\t\t\t\t? T_NEGOTIATE : 0) |\n\t\t\t\t((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |\n\t\t\t\tT_NEED_TO_RESET;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = 0;\n\t}\n\n\tif (doreset) {\n\t\tsc->sc_state = NCR_SBR;\n\t\tNCRCMD(sc, NCRCMD_RSTSCSI);\n\t} else {\n\t\tsc->sc_state = NCR_IDLE;\n\t\tncr53c9x_sched(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_init",
            "void\tncr53c9x_sched",
            "void\tncr53c9x_done",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_done;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_init(sc, doreset)\n\tstruct ncr53c9x_softc *sc;\n\tint doreset;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tint r;\n\n\tNCR_TRACE((\"[NCR_INIT(%d)] \", doreset));\n\n\tif (sc->sc_state == 0) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tecb = sc->sc_ecb;\n\t\tbzero(ecb, sizeof(sc->sc_ecb));\n\t\tfor (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);\n\t\t\tecb++;\n\t\t}\n\t\tbzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = NCR_CLEANING;\n\t\tif ((ecb = sc->sc_nexus) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t\twhile ((ecb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t}\n\n\t/*\n\t * reset the chip to a known state\n\t */\n\tncr53c9x_reset(sc);\n\n\tsc->sc_phase = sc->sc_prevphase = INVALID_PHASE;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];\n/* XXX - config flags per target: low bits: no reselect; high bits: no synch */\n\n\t\tti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))\n\t\t\t\t? T_NEGOTIATE : 0) |\n\t\t\t\t((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |\n\t\t\t\tT_NEED_TO_RESET;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = 0;\n\t}\n\n\tif (doreset) {\n\t\tsc->sc_state = NCR_SBR;\n\t\tNCRCMD(sc, NCRCMD_RSTSCSI);\n\t} else {\n\t\tsc->sc_state = NCR_IDLE;\n\t\tncr53c9x_sched(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ncr53c9x_abort: not NEXUS\\n\""
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "ecb->xs->sc_link"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ncr53c9x_timeout",
            "ecb",
            "(ecb->timeout * hz) / 1000"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "2102-2152",
          "snippet": "void\nncr53c9x_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ncr53c9x_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_softc *sc = sc_link->adapter_softc;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], \"\n\t       \"<state %d, nexus %p, phase(l %x, c %x, p %x), resid %lx, \"\n\t       \"msg(q %x,o %x) %s>\",\n\t\tsc->sc_dev.dv_xname,\n\t\tecb, ecb->flags, ecb->dleft, ecb->stat,\n\t\tsc->sc_state, sc->sc_nexus,\n\t\tNCR_READ_REG(sc, NCR_STAT),\n\t\tsc->sc_phase, sc->sc_prevphase,\n\t\t(long)sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,\n\t\tNCRDMA_ISACTIVE(sc) ? \"DMA active\" : \"\");\n#if NCR53C9X_DEBUG > 1\n\tprintf(\"TRACE: %s.\", ecb->trace);\n#endif\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\n\t\tncr53c9x_init(sc, 1);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tncr53c9x_abort(sc, ecb);\n\n\t\t/* Disable sync mode if stuck in a data phase */\n\t\tif (ecb == sc->sc_nexus &&\n\t\t    (ti->flags & T_SYNCMODE) != 0 &&\n\t\t    (sc->sc_phase & (MSGI|CDI)) == 0) {\n\t\t\tsc_print_addr(sc_link);\n\t\t\tprintf(\"sync negotiation disabled\\n\");\n\t\t\tsc->sc_cfflags |= (1<<(sc_link->target+8));\n\t\t}\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_init",
            "void\tncr53c9x_timeout",
            "void\tncr53c9x_abort",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_timeout;\nvoid\tncr53c9x_abort;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ncr53c9x_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_softc *sc = sc_link->adapter_softc;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], \"\n\t       \"<state %d, nexus %p, phase(l %x, c %x, p %x), resid %lx, \"\n\t       \"msg(q %x,o %x) %s>\",\n\t\tsc->sc_dev.dv_xname,\n\t\tecb, ecb->flags, ecb->dleft, ecb->stat,\n\t\tsc->sc_state, sc->sc_nexus,\n\t\tNCR_READ_REG(sc, NCR_STAT),\n\t\tsc->sc_phase, sc->sc_prevphase,\n\t\t(long)sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,\n\t\tNCRDMA_ISACTIVE(sc) ? \"DMA active\" : \"\");\n#if NCR53C9X_DEBUG > 1\n\tprintf(\"TRACE: %s.\", ecb->trace);\n#endif\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\n\t\tncr53c9x_init(sc, 1);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tncr53c9x_abort(sc, ecb);\n\n\t\t/* Disable sync mode if stuck in a data phase */\n\t\tif (ecb == sc->sc_nexus &&\n\t\t    (ti->flags & T_SYNCMODE) != 0 &&\n\t\t    (sc->sc_phase & (MSGI|CDI)) == 0) {\n\t\t\tsc_print_addr(sc_link);\n\t\t\tprintf(\"sync negotiation disabled\\n\");\n\t\t\tsc->sc_cfflags |= (1<<(sc_link->target+8));\n\t\t}\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ncr53c9x_timeout",
            "ecb"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_ABORT"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_timeout;\nvoid\tncr53c9x_abort;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_abort(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\n\t/* 2 secs for the abort */\n\tecb->timeout = NCR_ABORT_TIMEOUT;\n\tecb->flags |= ECB_ABORT;\n\n\tif (ecb == sc->sc_nexus) {\n\t\t/*\n\t\t * If we're still selecting, the message will be scheduled\n\t\t * after selection is complete.\n\t\t */\n\t\tif (sc->sc_state == NCR_CONNECTED)\n\t\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\n\t\t/*\n\t\t * Reschedule timeout. First, cancel a queued timeout (if any)\n\t\t * in case someone decides to call ncr53c9x_abort() from\n\t\t * elsewhere.\n\t\t */\n\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\ttimeout(ncr53c9x_timeout, ecb, (ecb->timeout * hz) / 1000);\n\t} else {\n\t\t/* The command should be on the nexus list */\n\t\tif ((ecb->flags & ECB_NEXUS) == 0) {\n\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\tprintf(\"ncr53c9x_abort: not NEXUS\\n\");\n\t\t\tncr53c9x_init(sc, 1);\n\t\t}\n\t\t/*\n\t\t * Just leave the command on the nexus list.\n\t\t * XXX - what choice do we have but to reset the SCSI\n\t\t *\t eventually?\n\t\t */\n\t\tif (sc->sc_state == NCR_IDLE)\n\t\t\tncr53c9x_sched(sc);\n\t}\n}"
  },
  {
    "function_name": "ncr53c9x_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "1345-2058",
    "snippet": "int\nncr53c9x_intr(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tregister struct ncr53c9x_ecb *ecb;\n\tregister struct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\tsize_t size;\n\tint nfifo;\n\n\tNCR_TRACE((\"[ncr53c9x_intr] \"));\n\n\tif (!NCRDMA_ISINTR(sc))\n\t\treturn (0);\n\nagain:\n\t/* and what do the registers day... */\n\tncr53c9x_readregs(sc);\n\n\tsc->sc_intrcnt.ev_count++;\n\n\t/*\n\t * Command are classed as errors. A disconnect is a\n\t * valid condition, and we let the code check is the\n\t * \"NCR_BUSFREE_OK\" flag was set before declaring it\n\t * and error.\n\t * \n\t * Also, the status register tells us about \"Gross\n\t * Errors\" and \"Parity errors\". Only the Gross Error\n\t * is really bad, and the parity errors are dealt   \n\t * with later\n\t * \n\t * TODO\n\t *      If there are too many parity error, go to slow\n\t *      cable mode ?\n\t */\n\n\t/* SCSI Reset */\n\tif (sc->sc_espintr & NCRINTR_SBR) {\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\tif (sc->sc_state != NCR_SBR) {\n\t\t\tprintf(\"%s: SCSI bus reset\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 0); /* Restart everything */\n\t\t\treturn (1);\n\t\t}\n#if 0\n/*XXX*/\t\tprintf(\"<expected bus reset: \"\n\t\t\t\"[intr %x, stat %x, step %d]>\\n\",\n\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\tsc->sc_espstep);\n#endif\n\t\tif (sc->sc_nexus)\n\t\t\tpanic(\"%s: nexus in reset state\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tgoto sched;\n\t}\n\n\tecb = sc->sc_nexus;\n\n#define NCRINTR_ERR (NCRINTR_SBR|NCRINTR_ILL)\n\tif (sc->sc_espintr & NCRINTR_ERR ||\n\t    sc->sc_espstat & NCRSTAT_GE) {\n\n\t\tif (sc->sc_espstat & NCRSTAT_GE) {\n\t\t\t/* Gross Error; no target ? */\n\t\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tDELAY(1);\n\t\t\t}\n\t\t\tif (sc->sc_state == NCR_CONNECTED ||\n\t\t\t    sc->sc_state == NCR_SELECTING) {\n\t\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\t\tncr53c9x_done(sc, ecb);\n\t\t\t}\n\t\t\t\treturn (1);\n\t\t}\n\n\t\tif (sc->sc_espintr & NCRINTR_ILL) {\n\t\t\tif (sc->sc_flags & NCR_EXPECT_ILLCMD) {\n\t\t\t\t/*\n\t\t\t\t * Eat away \"Illegal command\" interrupt\n\t\t\t\t * on a ESP100 caused by a re-selection\n\t\t\t\t * while we were trying to select\n\t\t\t\t * another target.\n\t\t\t\t */\n#ifdef DEBUG\n\t\t\t\tprintf(\"%s: ESP100 work-around activated\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n#endif\n\t\t\t\tsc->sc_flags &= ~NCR_EXPECT_ILLCMD;\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\t/* illegal command, out of sync ? */\n\t\t\tprintf(\"%s: illegal command: 0x%x \"\n\t\t\t    \"(state %d, phase %x, prevphase %x)\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, sc->sc_lastcmd,\n\t\t\t\tsc->sc_state, sc->sc_phase,\n\t\t\t\tsc->sc_prevphase);\n\t\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tDELAY(1);\n\t\t\t}\n\t\t\tncr53c9x_init(sc, 1); /* Restart everything */\n\t\t\treturn (1);\n\t\t}\n\t}\n\tsc->sc_flags &= ~NCR_EXPECT_ILLCMD;\n\n\t/*\n\t * Call if DMA is active.\n\t *\n\t * If DMA_INTR returns true, then maybe go 'round the loop\n\t * again in case there is no more DMA queued, but a phase\n\t * change is expected.\n\t */\n\tif (NCRDMA_ISACTIVE(sc)) {\n\t\tint r = NCRDMA_INTR(sc);\n\t\tif (r == -1) {\n\t\t\tprintf(\"%s: DMA error; resetting\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t}\n\t\t/* If DMA active here, then go back to work... */\n\t\tif (NCRDMA_ISACTIVE(sc))\n\t\t\treturn (1);\n\n\t\tif ((sc->sc_espstat & NCRSTAT_TC) == 0) {\n\t\t\t/*\n\t\t\t * DMA not completed.  If we can not find a\n\t\t\t * acceptable explanation, print a diagnostic.\n\t\t\t */\n\t\t\tif (sc->sc_state == NCR_SELECTING)\n\t\t\t\t/*\n\t\t\t\t * This can happen if we are reselected\n\t\t\t\t * while using DMA to select a target.\n\t\t\t\t */\n\t\t\t\t/*void*/;\n\t\t\telse if (sc->sc_prevphase == MESSAGE_OUT_PHASE){\n\t\t\t\t/*\n\t\t\t\t * Our (multi-byte) message (eg SDTR)\n\t\t\t\t * was interrupted by the target to\n\t\t\t\t * send a MSG REJECT.\n\t\t\t\t * Print diagnostic if current phase\n\t\t\t\t * is not MESSAGE IN.\n\t\t\t\t */\n\t\t\t\tif (sc->sc_phase != MESSAGE_IN_PHASE)\n\t\t\t\t    printf(\"%s: !TC on MSG OUT\"\n\t\t\t\t       \" [intr %x, stat %x, step %d]\"\n\t\t\t\t       \" prevphase %x, resid %x\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase,\n\t\t\t\t\tsc->sc_omlen);\n\t\t\t} else if (sc->sc_dleft == 0) {\n\t\t\t\t/*\n\t\t\t\t * The DMA operation was started for\n\t\t\t\t * a DATA transfer. Print a diagnostic\n\t\t\t\t * if the DMA counter and TC bit\n\t\t\t\t * appear to be out of sync.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: !TC on DATA XFER\"\n\t\t\t\t       \" [intr %x, stat %x, step %d]\"\n\t\t\t\t       \" prevphase %x, resid %x\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase,\n\t\t\t\t\tecb?ecb->dleft:-1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * check for less serious errors\n\t */\n\tif (sc->sc_espstat & NCRSTAT_PE) {\n\t\tprintf(\"%s: SCSI bus parity error\\n\", sc->sc_dev.dv_xname);\n\t\tif (sc->sc_prevphase == MESSAGE_IN_PHASE)\n\t\t\tncr53c9x_sched_msgout(SEND_PARITY_ERROR);\n\t\telse\n\t\t\tncr53c9x_sched_msgout(SEND_INIT_DET_ERR);\n\t}\n\n\tif (sc->sc_espintr & NCRINTR_DIS) {\n\t\tNCR_MISC((\"<DISC [intr %x, stat %x, step %d]>\",\n\t\t\tsc->sc_espintr,sc->sc_espstat,sc->sc_espstep));\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\t/*\n\t\t * This command must (apparently) be issued within\n\t\t * 250mS of a disconnect. So here you are...\n\t\t */\n\t\tNCRCMD(sc, NCRCMD_ENSEL);\n\n\t\tswitch (sc->sc_state) {\n\t\tcase NCR_RESELECTED:\n\t\t\tgoto sched;\n\n\t\tcase NCR_SELECTING:\n\t\t\tecb->xs->error = XS_SELTIMEOUT;\n\t\t\tgoto finish;\n\n\t\tcase NCR_CONNECTED:\n\t\t\tif ((sc->sc_flags & NCR_SYNCHNEGO)) {\n#ifdef NCR53C9X_DEBUG\n\t\t\t\tif (ecb)\n\t\t\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\t\tprintf(\"sync nego not completed!\\n\");\n#endif\n\t\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);\n\t\t\t}\n\n\t\t\t/* it may be OK to disconnect */\n\t\t\tif ((sc->sc_flags & NCR_ABORTING) == 0) {\n\t\t\t\t/*  \n\t\t\t\t * Section 5.1.1 of the SCSI 2 spec\n\t\t\t\t * suggests issuing a REQUEST SENSE\n\t\t\t\t * following an unexpected disconnect.\n\t\t\t\t * Some devices go into a contingent\n\t\t\t\t * allegiance condition when\n\t\t\t\t * disconnecting, and this is necessary\n\t\t\t\t * to clean up their state.\n\t\t\t\t */     \n\t\t\t\tprintf(\"%s: unexpected disconnect; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tif (ecb->flags & ECB_SENSE) {\n\t\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\tprintf(\"sending REQUEST SENSE\\n\");\n\t\t\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\t\t\tncr53c9x_sense(sc, ecb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tgoto finish;\n\n\t\tcase NCR_DISCONNECT:\n\t\t\tTAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);\n\t\t\tsc->sc_nexus = NULL;\n\t\t\tgoto sched;\n\n\t\tcase NCR_CMDCOMPLETE:\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\tswitch (sc->sc_state) {\n\n\tcase NCR_SBR:\n\t\tprintf(\"%s: waiting for SCSI Bus Reset to happen\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n\t\t\treturn (1);\n\n\tcase NCR_RESELECTED:\n\t\t/*\n\t\t * we must be continuing a message ?\n\t\t */\n\t\tif (sc->sc_phase != MESSAGE_IN_PHASE) {\n\t\t\tprintf(\"%s: target didn't identify\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t\treturn (1);\n\t\t}\nprintf(\"<<RESELECT CONT'd>>\");\n#if XXXX\n\t\tncr53c9x_msgin(sc);\n\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t/* IDENTIFY fail?! */\n\t\t\tprintf(\"%s: identify failed\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t\treturn (1);\n\t\t}\n#endif\n\t\tbreak;\n\n\tcase NCR_IDLE:\n\tcase NCR_SELECTING:\n\t\tsc->sc_msgpriq = sc->sc_msgout = sc->sc_msgoutq = 0;\n\t\tsc->sc_flags = 0;\n\t\tecb = sc->sc_nexus;\n\t\tif (ecb != NULL && (ecb->flags & ECB_NEXUS)) {\n\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\tprintf(\"ECB_NEXUS while in state %x\\n\", sc->sc_state);\n\t\t}\n\n\t\tif (sc->sc_espintr & NCRINTR_RESEL) {\n\t\t\t/*\n\t\t\t * If we're trying to select a\n\t\t\t * target ourselves, push our command\n\t\t\t * back into the ready list.\n\t\t\t */\n\t\t\tif (sc->sc_state == NCR_SELECTING) {\n\t\t\t\tNCR_MISC((\"backoff selector \"));\n\t\t\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\t\t\tsc_link = ecb->xs->sc_link;\n\t\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\t\t\tTAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);\n\t\t\t\tecb = sc->sc_nexus = NULL;\n\t\t\t}\n\t\t\tsc->sc_state = NCR_RESELECTED;\n\t\t\tif (sc->sc_phase != MESSAGE_IN_PHASE) {\n\t\t\t\t/*\n\t\t\t\t * Things are seriously fucked up.\n\t\t\t\t * Pull the brakes, i.e. reset\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: target didn't identify\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\t/*\n\t\t\t * The C90 only inhibits FIFO writes until\n\t\t\t * reselection is complete, instead of\n\t\t\t * waiting until the interrupt status register\n\t\t\t * has been read. So, if the reselect happens\n\t\t\t * while we were entering a command bytes (for\n\t\t\t * another target) some of those bytes can\n\t\t\t * appear in the FIFO here, after the\n\t\t\t * interrupt is taken.\n\t\t\t */\n\t\t\tnfifo = NCR_READ_REG(sc,NCR_FFLAG) & NCRFIFO_FF;\n\t\t\tif (nfifo < 2 ||\n\t\t\t    (nfifo > 2 &&\n\t\t\t     sc->sc_rev != NCR_VARIANT_ESP100)) {\n\t\t\t\tprintf(\"%s: RESELECT: \"\n\t\t\t\t    \"%d bytes in FIFO! \"\n\t\t\t\t    \"[intr %x, stat %x, step %d, prevphase %x]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tnfifo,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase);\n\t\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tsc->sc_selid = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tNCR_MISC((\"selid=0x%2x \", sc->sc_selid));\n\n\t\t\t/* Handle identify message */\n\t\t\tncr53c9x_msgin(sc);\n\t\t\tif (nfifo != 2) {\n\t\t\t\t/*\n\t\t\t\t * Note: this should not happen\n\t\t\t\t * with `dmaselect' on.\n\t\t\t\t */\n\t\t\t\tsc->sc_flags |= NCR_EXPECT_ILLCMD;\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t} else if (ncr53c9x_dmaselect &&\n\t\t\t\t   sc->sc_rev == NCR_VARIANT_ESP100) {\n\t\t\t\tsc->sc_flags |= NCR_EXPECT_ILLCMD;\n\t\t\t}\n\n\t\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t\t/* IDENTIFY fail?! */\n\t\t\t\tprintf(\"%s: identify failed\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tgoto shortcut; /* ie. next phase expected soon */\n\t\t}\n\n#define\tNCRINTR_DONE\t(NCRINTR_FC|NCRINTR_BS)\n\t\tif ((sc->sc_espintr & NCRINTR_DONE) == NCRINTR_DONE) {\n\t\t\t/*\n\t\t\t * Arbitration won; examine the `step' register\n\t\t\t * to determine how far the selection could progress.\n\t\t\t */\n\t\t\tecb = sc->sc_nexus;\n\t\t\tif (!ecb)\n\t\t\t\tpanic(\"esp: no nexus\");\n\n\t\t\tsc_link = ecb->xs->sc_link;\n\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\n\t\t\tswitch (sc->sc_espstep) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * The target did not respond with a\n\t\t\t\t * message out phase - probably an old\n\t\t\t\t * device that doesn't recognize ATN.\n\t\t\t\t * Clear ATN and just continue, the\n\t\t\t\t * target should be in the command\n\t\t\t\t * phase.\n\t\t\t\t * XXXX check for command phase?\n\t\t\t\t */\n\t\t\t\tNCRCMD(sc, NCRCMD_RSTATN);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif ((ti->flags & T_NEGOTIATE) == 0) {\n\t\t\t\t\tprintf(\"%s: step 1 & !NEG\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\tif (sc->sc_phase != MESSAGE_OUT_PHASE) {\n\t\t\t\t\tprintf(\"%s: !MSGOUT\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\t/* Start negotiating */\n\t\t\t\tti->period = sc->sc_minsync;\n\t\t\t\tti->offset = 15;\n\t\t\t\tsc->sc_flags |= NCR_SYNCHNEGO;\n\t\t\t\tncr53c9x_sched_msgout(SEND_SDTR);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t/*\n\t\t\t\t * Grr, this is supposed to mean\n\t\t\t\t * \"target left command phase  prematurely\".\n\t\t\t\t * It seems to happen regularly when\n\t\t\t\t * sync mode is on.\n\t\t\t\t * Look at FIFO to see if command went out.\n\t\t\t\t * (Timing problems?)\n\t\t\t\t */\n\t\t\t\tif (ncr53c9x_dmaselect) {\n\t\t\t\t\tif (sc->sc_cmdlen == 0)\n\t\t\t\t\t\t/* Hope for the best.. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if ((NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t    & NCRFIFO_FF) == 0) {\n\t\t\t\t\t\t/* Hope for the best.. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"(%s:%d:%d): selection failed;\"\n\t\t\t\t\t\" %d left in FIFO \"\n\t\t\t\t\t\"[intr %x, stat %x, step %d]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc_link->target,\n\t\t\t\t\tsc_link->lun,\n\t\t\t\t\tNCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t & NCRFIFO_FF,\n\t\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep);\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\t\t\t\treturn (1);\n\t\t\tcase 2:\n\t\t\t\t/* Select stuck at Command Phase */\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tcase 4:\n\t\t\t\tif (ncr53c9x_dmaselect &&\n\t\t\t\t    sc->sc_cmdlen != 0)\n\t\t\t\t\tprintf(\"(%s:%d:%d): select; \"\n\t\t\t\t\t       \"%d left in DMA buffer \"\n\t\t\t\t\t\"[intr %x, stat %x, step %d]\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tsc_link->target,\n\t\t\t\t\t\tsc_link->lun,\n\t\t\t\t\t\tsc->sc_cmdlen,\n\t\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\t\tsc->sc_espstep);\n\t\t\t\t/* So far, everything went fine */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tecb->flags |= ECB_NEXUS;\n\t\t\tti->lubusy |= (1 << sc_link->lun);\n\n\t\t\tsc->sc_prevphase = INVALID_PHASE; /* ?? */\n\t\t\t/* Do an implicit RESTORE POINTERS. */\n\t\t\tsc->sc_dp = ecb->daddr;\n\t\t\tsc->sc_dleft = ecb->dleft;\n\t\t\tsc->sc_state = NCR_CONNECTED;\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\tprintf(\"%s: unexpected status after select\"\n\t\t\t\t\": [intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t\tgoto reset;\n\t\t}\n\t\tif (sc->sc_state == NCR_IDLE) {\n\t\t\tprintf(\"%s: stray interrupt\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\n\tcase NCR_CONNECTED:\n\t\tif (sc->sc_flags & NCR_ICCS) {\n\t\t\t/* \"Initiate Command Complete Steps\" in progress */\n\t\t\tu_char msg;\n\n\t\t\tsc->sc_flags &= ~NCR_ICCS;\n\n\t\t\tif (!(sc->sc_espintr & NCRINTR_DONE)) {\n\t\t\t\tprintf(\"%s: ICCS: \"\n\t\t\t\t      \": [intr %x, stat %x, step %x]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep);\n\t\t\t}\n\t\t\tif ((NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t    & NCRFIFO_FF) != 2) {\n\t\t\t\tint i = (NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t    & NCRFIFO_FF) - 2;\n\t\t\t\twhile (i--)\n\t\t\t\t\t(void) NCR_READ_REG(sc, NCR_FIFO);\n\t\t\t}\n\t\t\tecb->stat = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tmsg = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tNCR_PHASE((\"<stat:(%x,%x)>\", ecb->stat, msg));\n\t\t\tif (msg == MSG_CMDCOMPLETE) {\n\t\t\t\tecb->dleft = (ecb->flags & ECB_TENTATIVE_DONE)\n\t\t\t\t\t? 0\n\t\t\t\t\t: sc->sc_dleft;\n\t\t\t\tif ((ecb->flags & ECB_SENSE) == 0)\n\t\t\t\t\tecb->xs->resid = ecb->dleft;\n\t\t\t\tsc->sc_state = NCR_CMDCOMPLETE;\n\t\t\t} else\n\t\t\t\tprintf(\"%s: STATUS_PHASE: msg %d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname, msg);\n\t\t\tNCRCMD(sc, NCRCMD_MSGOK);\n\t\t\tgoto shortcut; /* ie. wait for disconnect */\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"%s: invalid state: %d\",\n\t\t      sc->sc_dev.dv_xname,\n\t\t      sc->sc_state);\n\t}\n\n\t/*\n\t * Driver is now in state NCR_CONNECTED, i.e. we\n\t * have a current command working the SCSI bus.\n\t */\n\tif (sc->sc_state != NCR_CONNECTED || ecb == NULL) {\n\t\tpanic(\"esp no nexus\");\n\t}\n\n\tswitch (sc->sc_phase) {\n\tcase MESSAGE_OUT_PHASE:\n\t\tNCR_PHASE((\"MESSAGE_OUT_PHASE \"));\n\t\tncr53c9x_msgout(sc);\n\t\tsc->sc_prevphase = MESSAGE_OUT_PHASE;\n\t\tbreak;\n\tcase MESSAGE_IN_PHASE:\n\t\tNCR_PHASE((\"MESSAGE_IN_PHASE \"));\n\t\tsc->sc_prevphase = MESSAGE_IN_PHASE;\n\t\tif (sc->sc_espintr & NCRINTR_BS) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tsc->sc_flags |= NCR_WAITI;\n\t\t\tNCRCMD(sc, NCRCMD_TRANS);\n\t\t} else if (sc->sc_espintr & NCRINTR_FC) {\n\t\t\tif ((sc->sc_flags & NCR_WAITI) == 0) {\n\t\t\t\tprintf(\"%s: MSGIN: unexpected FC bit: \"\n\t\t\t\t\t\"[intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t\t}\n\t\t\tsc->sc_flags &= ~NCR_WAITI;\n\t\t\tncr53c9x_msgin(sc);\n\t\t} else {\n\t\t\tprintf(\"%s: MSGIN: weird bits: \"\n\t\t\t\t\"[intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t}\n\t\tgoto shortcut;\t/* i.e. expect data to be ready */\n\t\tbreak;\n\tcase COMMAND_PHASE:\n\t\t/*\n\t\t * Send the command block. Normally we don't see this\n\t\t * phase because the SEL_ATN command takes care of\n\t\t * all this. However, we end up here if either the\n\t\t * target or we wanted to exchange some more messages\n\t\t * first (e.g. to start negotiations).\n\t\t */\n\n\t\tNCR_PHASE((\"COMMAND_PHASE 0x%02x (%d) \",\n\t\t\tecb->cmd.cmd.opcode, ecb->clen));\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\tif (ncr53c9x_dmaselect) {\n\t\t\tsize_t size;\n\t\t\t/* setup DMA transfer for command */\n\t\t\tsize = ecb->clen;\n\t\t\tsc->sc_cmdlen = size;\n\t\t\tsc->sc_cmdp = (caddr_t)&ecb->cmd.cmd;\n\t\t\tNCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen,\n\t\t\t\t     0, &size);\n\t\t\t/* Program the SCSI counter */\n\t\t\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\t\t\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\t\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t\t\t}\n\n\t\t\t/* load the count in */\n\t\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t\t/* start the command transfer */\n\t\t\tNCRCMD(sc, NCRCMD_TRANS | NCRCMD_DMA);\n\t\t\tNCRDMA_GO(sc);\n\t\t} else {\n\t\t\tu_char *cmd = (u_char *)&ecb->cmd.cmd;\n\t\t\tint i;\n\t\t\t/* Now the command into the FIFO */\n\t\t\tfor (i = 0; i < ecb->clen; i++)\n\t\t\t\tNCR_WRITE_REG(sc, NCR_FIFO, *cmd++);\n\t\t\tNCRCMD(sc, NCRCMD_TRANS);\n\t\t}\n\t\tsc->sc_prevphase = COMMAND_PHASE;\n\t\tbreak;\n\tcase DATA_OUT_PHASE:\n\t\tNCR_PHASE((\"DATA_OUT_PHASE [%ld] \",(long)sc->sc_dleft));\n\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\tsize = min(sc->sc_dleft, sc->sc_maxxfer);\n\t\tNCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,\n\t\t\t  0, &size);\n\t\tsc->sc_prevphase = DATA_OUT_PHASE;\n\t\tgoto setup_xfer;\n\tcase DATA_IN_PHASE:\n\t\tNCR_PHASE((\"DATA_IN_PHASE \"));\n\t\tif (sc->sc_rev == NCR_VARIANT_ESP100)\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\tsize = min(sc->sc_dleft, sc->sc_maxxfer);\n\t\tNCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,\n\t\t\t  1, &size);\n\t\tsc->sc_prevphase = DATA_IN_PHASE;\n\tsetup_xfer:\n\t\t/* Target returned to data phase: wipe \"done\" memory */\n\t\tecb->flags &= ~ECB_TENTATIVE_DONE;\n\n\t\t/* Program the SCSI counter */\n\t\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\t\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t\t}\n\t\t/* load the count in */\n\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t/*\n\t\t * Note that if `size' is 0, we've already transceived\n\t\t * all the bytes we want but we're still in DATA PHASE.\n\t\t * Apparently, the device needs padding. Also, a\n\t\t * transfer size of 0 means \"maximum\" to the chip\n\t\t * DMA logic.\n\t\t */\n\t\tNCRCMD(sc,\n\t\t       (size==0?NCRCMD_TRPAD:NCRCMD_TRANS)|NCRCMD_DMA);\n\t\tNCRDMA_GO(sc);\n\t\treturn (1);\n\tcase STATUS_PHASE:\n\t\tNCR_PHASE((\"STATUS_PHASE \"));\n\t\tsc->sc_flags |= NCR_ICCS;\n\t\tNCRCMD(sc, NCRCMD_ICCS);\n\t\tsc->sc_prevphase = STATUS_PHASE;\n\t\tbreak;\n\tcase INVALID_PHASE:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unexpected bus phase; resetting\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto reset;\n\t}\n\nout:\n\treturn (1);\n\nreset:\n\tncr53c9x_init(sc, 1);\n\tgoto out;\n\nfinish:\n\tncr53c9x_done(sc, ecb);\n\tgoto out;\n\nsched:\n\tsc->sc_state = NCR_IDLE;\n\tncr53c9x_sched(sc);\n\tgoto out;\n\nshortcut:\n\t/*\n\t * The idea is that many of the SCSI operations take very little\n\t * time, and going away and getting interrupted is too high an\n\t * overhead to pay. For example, selecting, sending a message\n\t * and command and then doing some work can be done in one \"pass\".\n\t *\n\t * The delay is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1\n\t * at 40Mhz. This needs testing.\n\t */\n\tDELAY(50/sc->sc_freq);\n\tif (NCRDMA_ISINTR(sc))\n\t\tgoto again;\n\tgoto out;\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tNCRINTR_DONE\t(NCRINTR_FC|NCRINTR_BS)",
      "#define NCRINTR_ERR (NCRINTR_SBR|NCRINTR_ILL)"
    ],
    "globals_used": [
      "void\tncr53c9x_readregs",
      "void\tncr53c9x_init",
      "void\tncr53c9x_sched",
      "void\tncr53c9x_done",
      "void\tncr53c9x_msgin",
      "void\tncr53c9x_msgout",
      "void\tncr53c9x_timeout",
      "void ncr53c9x_sense",
      "int ncr53c9x_dmaselect = 0;",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCRDMA_ISINTR",
          "args": [
            "sc"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50/sc->sc_freq"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched",
          "args": [
            "sc"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "687-716",
          "snippet": "void\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_sched",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_done",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "756-823",
          "snippet": "void\nncr53c9x_done(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tNCR_TRACE((\"[ncr53c9x_done(error:%x)] \", xs->error));\n\n\tuntimeout(ncr53c9x_timeout, ecb);\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\txs->status = ecb->stat;\n\t\tif ((ecb->flags & ECB_ABORT) != 0) {\n\t\t\txs->error = XS_TIMEOUT;\n\t\t} else if ((ecb->flags & ECB_SENSE) != 0) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = ecb->dleft;\n\t\t\tncr53c9x_sense(sc, ecb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = ecb->dleft;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#ifdef NCR53C9X_DEBUG\n\tif (ncr53c9x_debug & NCR_SHOWMISC) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ECB from whatever queue it's on.\n\t */\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tif (sc->sc_state != NCR_CLEANING) {\n\t\t\tsc->sc_state = NCR_IDLE;\n\t\t\tncr53c9x_sched(sc);\n\t\t}\n\t} else\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\t\n\tncr53c9x_free_ecb(sc, ecb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr53c9x_debug = 0;",
            "void\tncr53c9x_sched",
            "void\tncr53c9x_done",
            "void\tncr53c9x_timeout",
            "void ncr53c9x_dequeue",
            "void ncr53c9x_sense",
            "void ncr53c9x_free_ecb",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr53c9x_debug = 0;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_done;\nvoid\tncr53c9x_timeout;\nvoid ncr53c9x_dequeue;\nvoid ncr53c9x_sense;\nvoid ncr53c9x_free_ecb;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_done(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tNCR_TRACE((\"[ncr53c9x_done(error:%x)] \", xs->error));\n\n\tuntimeout(ncr53c9x_timeout, ecb);\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\txs->status = ecb->stat;\n\t\tif ((ecb->flags & ECB_ABORT) != 0) {\n\t\t\txs->error = XS_TIMEOUT;\n\t\t} else if ((ecb->flags & ECB_SENSE) != 0) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = ecb->dleft;\n\t\t\tncr53c9x_sense(sc, ecb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = ecb->dleft;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#ifdef NCR53C9X_DEBUG\n\tif (ncr53c9x_debug & NCR_SHOWMISC) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ECB from whatever queue it's on.\n\t */\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tif (sc->sc_state != NCR_CLEANING) {\n\t\t\tsc->sc_state = NCR_IDLE;\n\t\t\tncr53c9x_sched(sc);\n\t\t}\n\t} else\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\t\n\tncr53c9x_free_ecb(sc, ecb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_init",
          "args": [
            "sc",
            "1"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "301-362",
          "snippet": "void\nncr53c9x_init(sc, doreset)\n\tstruct ncr53c9x_softc *sc;\n\tint doreset;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tint r;\n\n\tNCR_TRACE((\"[NCR_INIT(%d)] \", doreset));\n\n\tif (sc->sc_state == 0) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tecb = sc->sc_ecb;\n\t\tbzero(ecb, sizeof(sc->sc_ecb));\n\t\tfor (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);\n\t\t\tecb++;\n\t\t}\n\t\tbzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = NCR_CLEANING;\n\t\tif ((ecb = sc->sc_nexus) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t\twhile ((ecb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t}\n\n\t/*\n\t * reset the chip to a known state\n\t */\n\tncr53c9x_reset(sc);\n\n\tsc->sc_phase = sc->sc_prevphase = INVALID_PHASE;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];\n/* XXX - config flags per target: low bits: no reselect; high bits: no synch */\n\n\t\tti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))\n\t\t\t\t? T_NEGOTIATE : 0) |\n\t\t\t\t((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |\n\t\t\t\tT_NEED_TO_RESET;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = 0;\n\t}\n\n\tif (doreset) {\n\t\tsc->sc_state = NCR_SBR;\n\t\tNCRCMD(sc, NCRCMD_RSTSCSI);\n\t} else {\n\t\tsc->sc_state = NCR_IDLE;\n\t\tncr53c9x_sched(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_init",
            "void\tncr53c9x_sched",
            "void\tncr53c9x_done",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_done;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_init(sc, doreset)\n\tstruct ncr53c9x_softc *sc;\n\tint doreset;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tint r;\n\n\tNCR_TRACE((\"[NCR_INIT(%d)] \", doreset));\n\n\tif (sc->sc_state == 0) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tecb = sc->sc_ecb;\n\t\tbzero(ecb, sizeof(sc->sc_ecb));\n\t\tfor (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);\n\t\t\tecb++;\n\t\t}\n\t\tbzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = NCR_CLEANING;\n\t\tif ((ecb = sc->sc_nexus) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t\twhile ((ecb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t}\n\n\t/*\n\t * reset the chip to a known state\n\t */\n\tncr53c9x_reset(sc);\n\n\tsc->sc_phase = sc->sc_prevphase = INVALID_PHASE;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];\n/* XXX - config flags per target: low bits: no reselect; high bits: no synch */\n\n\t\tti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))\n\t\t\t\t? T_NEGOTIATE : 0) |\n\t\t\t\t((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |\n\t\t\t\tT_NEED_TO_RESET;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = 0;\n\t}\n\n\tif (doreset) {\n\t\tsc->sc_state = NCR_SBR;\n\t\tNCRCMD(sc, NCRCMD_RSTSCSI);\n\t} else {\n\t\tsc->sc_state = NCR_IDLE;\n\t\tncr53c9x_sched(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unexpected bus phase; resetting\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_ICCS"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_PHASE",
          "args": [
            "(\"STATUS_PHASE \")"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_GO",
          "args": [
            "sc"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "(size==0?NCRCMD_TRPAD:NCRCMD_TRANS)|NCRCMD_DMA"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_NOP|NCRCMD_DMA"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCH",
            "size >> 16"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCM",
            "size >> 8"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCL",
            "size"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_SETUP",
          "args": [
            "sc",
            "&sc->sc_dp",
            "&sc->sc_dleft",
            "1",
            "&size"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sc->sc_dleft",
            "sc->sc_maxxfer"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_PHASE",
          "args": [
            "(\"DATA_IN_PHASE \")"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_SETUP",
          "args": [
            "sc",
            "&sc->sc_dp",
            "&sc->sc_dleft",
            "0",
            "&size"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_PHASE",
          "args": [
            "(\"DATA_OUT_PHASE [%ld] \",(long)sc->sc_dleft)"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_TRANS"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_FIFO",
            "*cmd++"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_GO",
          "args": [
            "sc"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_TRANS | NCRCMD_DMA"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_NOP|NCRCMD_DMA"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCH",
            "size >> 16"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCM",
            "size >> 8"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCL",
            "size"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_SETUP",
          "args": [
            "sc",
            "&sc->sc_cmdp",
            "&sc->sc_cmdlen",
            "0",
            "&size"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_PHASE",
          "args": [
            "(\"COMMAND_PHASE 0x%02x (%d) \",\n\t\t\tecb->cmd.cmd.opcode, ecb->clen)"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_msgin",
          "args": [
            "sc"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_msgin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "943-1206",
          "snippet": "void\nncr53c9x_msgin(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tregister int v;\n\n\tNCR_TRACE((\"[ncr53c9x_msgin(curmsglen:%ld)] \", (long)sc->sc_imlen));\n\n\tif ((NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) == 0) {\n\t\tprintf(\"%s: msgin: no msg byte available\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * Prepare for a new message.  A message should (according\n\t * to the SCSI standard) be transmitted in one single\n\t * MESSAGE_IN_PHASE. If we have been in some other phase,\n\t * then this is a new message.\n\t */\n\tif (sc->sc_prevphase != MESSAGE_IN_PHASE) {\n\t\tsc->sc_flags &= ~NCR_DROP_MSGI;\n\t\tsc->sc_imlen = 0;\n\t}\n\n\tv = NCR_READ_REG(sc, NCR_FIFO);\n\tNCR_MISC((\"<msgbyte:0x%02x>\", v));\n\n#if 0\n\tif (sc->sc_state == NCR_RESELECTED && sc->sc_imlen == 0) {\n\t\t/*\n\t\t * Which target is reselecting us? (The ID bit really)\n\t\t */\n\t\tsc->sc_selid = v;\n\t\tNCR_MISC((\"selid=0x%2x \", sc->sc_selid));\n\t\treturn;\n\t}\n#endif\n\n\tsc->sc_imess[sc->sc_imlen] = v;\n\n\t/*\n\t * If we're going to reject the message, don't bother storing\n\t * the incoming bytes.  But still, we need to ACK them.\n\t */\n\n\tif ((sc->sc_flags & NCR_DROP_MSGI)) {\n\t\tNCRCMD(sc, NCRCMD_MSGOK);\n\t\tprintf(\"<dropping msg byte %x>\",\n\t\t\tsc->sc_imess[sc->sc_imlen]);\n\t\treturn;\n\t}\n\n\tif (sc->sc_imlen >= NCR_MAX_MSG_LEN) {\n\t\tncr53c9x_sched_msgout(SEND_REJECT);\n\t\tsc->sc_flags |= NCR_DROP_MSGI;\n\t} else {\n\t\tsc->sc_imlen++;\n\t\t/*\n\t\t * This testing is suboptimal, but most\n\t\t * messages will be of the one byte variety, so\n\t\t * it should not effect performance\n\t\t * significantly.\n\t\t */\n\t\tif (sc->sc_imlen == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\tgoto gotit;\n\t\tif (sc->sc_imlen == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\tgoto gotit;\n\t\tif (sc->sc_imlen >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t    sc->sc_imlen == sc->sc_imess[1] + 2)\n\t\t\tgoto gotit;\n\t}\n\t/* Ack what we have so far */\n\tNCRCMD(sc, NCRCMD_MSGOK);\n\treturn;\n\ngotit:\n\tNCR_MSGS((\"gotmsg(%x)\", sc->sc_imess[0]));\n\t/*\n\t * Now we should have a complete message (1 byte, 2 byte\n\t * and moderately long extended messages).  We only handle\n\t * extended messages which total length is shorter than\n\t * NCR_MAX_MSG_LEN.  Longer messages will be amputated.\n\t */\n\tswitch (sc->sc_state) {\n\t\tstruct ncr53c9x_ecb *ecb;\n\t\tstruct ncr53c9x_tinfo *ti;\n\n\tcase NCR_CONNECTED:\n\t\tecb = sc->sc_nexus;\n\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\n\t\tswitch (sc->sc_imess[0]) {\n\t\tcase MSG_CMDCOMPLETE:\n\t\t\tNCR_MSGS((\"cmdcomplete \"));\n\t\t\tif (sc->sc_dleft < 0) {\n\t\t\t\tstruct scsi_link *sc_link = ecb->xs->sc_link;\n\t\t\t\tprintf(\"%s: %ld extra bytes from %d:%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, -(long)sc->sc_dleft,\n\t\t\t\t    sc_link->target, sc_link->lun);\n\t\t\t\tsc->sc_dleft = 0;\n\t\t\t}\n\t\t\tecb->dleft = (ecb->flags & ECB_TENTATIVE_DONE)\n\t\t\t\t? 0\n\t\t\t\t: sc->sc_dleft;\n\t\t\tif ((ecb->flags & ECB_SENSE) == 0)\n\t\t\t\tecb->xs->resid = ecb->dleft;\n\t\t\tsc->sc_state = NCR_CMDCOMPLETE;\n\t\t\tbreak;\n\n\t\tcase MSG_MESSAGE_REJECT:\n\t\t\tNCR_MSGS((\"msg reject (msgout=%x) \", sc->sc_msgout));\n\t\t\tswitch (sc->sc_msgout) {\n\t\t\tcase SEND_SDTR:\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t\tbreak;\n\t\t\tcase SEND_INIT_DET_ERR:\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MSG_NOOP:\n\t\t\tNCR_MSGS((\"noop \"));\n\t\t\tbreak;\n\n\t\tcase MSG_DISCONNECT:\n\t\t\tNCR_MSGS((\"disconnect \"));\n\t\t\tti->dconns++;\n\t\t\tsc->sc_state = NCR_DISCONNECT;\n\n\t\t\t/*\n\t\t\t * Mark the fact that all bytes have moved. The\n\t\t\t * target may not bother to do a SAVE POINTERS\n\t\t\t * at this stage. This flag will set the residual\n\t\t\t * count to zero on MSG COMPLETE.\n\t\t\t */\n\t\t\tif (sc->sc_dleft == 0)\n\t\t\t\tecb->flags |= ECB_TENTATIVE_DONE;\n\n\t\t\tbreak;\n\n\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tNCR_MSGS((\"save datapointer \"));\n\t\t\tecb->daddr = sc->sc_dp;\n\t\t\tecb->dleft = sc->sc_dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_RESTOREPOINTERS:\n\t\t\tNCR_MSGS((\"restore datapointer \"));\n\t\t\tsc->sc_dp = ecb->daddr;\n\t\t\tsc->sc_dleft = ecb->dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_EXTENDED:\n\t\t\tNCR_MSGS((\"extended(%x) \", sc->sc_imess[2]));\n\t\t\tswitch (sc->sc_imess[2]) {\n\t\t\tcase MSG_EXT_SDTR:\n\t\t\t\tNCR_MSGS((\"SDTR period %d, offset %d \",\n\t\t\t\t\tsc->sc_imess[3], sc->sc_imess[4]));\n\t\t\t\tif (sc->sc_imess[1] != 3)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->period = sc->sc_imess[3];\n\t\t\t\tti->offset = sc->sc_imess[4];\n\t\t\t\tti->flags &= ~T_NEGOTIATE;\n\t\t\t\tif (sc->sc_minsync == 0 ||\n\t\t\t\t    ti->offset == 0 ||\n\t\t\t\t    ti->period > 124) {\n\t\t\t\t\tprintf(\"%s:%d: async\\n\", \"esp\",\n\t\t\t\t\t\tecb->xs->sc_link->target);\n\t\t\t\t\tif ((sc->sc_flags&NCR_SYNCHNEGO)\n\t\t\t\t\t    == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * target initiated negotiation\n\t\t\t\t\t\t */\n\t\t\t\t\t\tti->offset = 0;\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t\tncr53c9x_sched_msgout(\n\t\t\t\t\t\t    SEND_SDTR);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* we are async */\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint r = 250/ti->period;\n\t\t\t\t\tint s = (100*250)/ti->period - 100*r;\n\t\t\t\t\tint p;\n\n\t\t\t\t\tp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\t\t\t\tti->period = ncr53c9x_cpb2stp(sc, p);\n#ifdef NCR53C9X_DEBUG\n\t\t\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\t\t\tprintf(\"max sync rate %d.%02dMb/s\\n\",\n\t\t\t\t\t\tr, s);\n#endif\n\t\t\t\t\tif ((sc->sc_flags&NCR_SYNCHNEGO) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * target initiated negotiation\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (ti->period <\n\t\t\t\t\t\t    sc->sc_minsync)\n\t\t\t\t\t\t\tti->period =\n\t\t\t\t\t\t\t    sc->sc_minsync;\n\t\t\t\t\t\tif (ti->offset > 15)\n\t\t\t\t\t\t\tti->offset = 15;\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t\tncr53c9x_sched_msgout(\n\t\t\t\t\t\t    SEND_SDTR);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* we are sync */\n\t\t\t\t\t\tti->flags |= T_SYNCMODE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED;\"\n\t\t\t\t    \" sending REJECT\\n\", sc->sc_dev.dv_xname);\n\t\t\t\tgoto reject;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tNCR_MSGS((\"ident \"));\n\t\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\treject:\n\t\t\tncr53c9x_sched_msgout(SEND_REJECT);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase NCR_RESELECTED:\n\t\tif (!MSG_ISIDENTIFY(sc->sc_imess[0])) {\n\t\t\tprintf(\"%s: reselect without IDENTIFY;\"\n\t\t\t    \" sending DEVICE RESET\\n\", sc->sc_dev.dv_xname);\n\t\t\tgoto reset;\n\t\t}\n\n\t\t(void) ncr53c9x_reselect(sc, sc->sc_imess[0]);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE IN; sending DEVICE RESET\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\treset:\n\t\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\t\tbreak;\n\n\tabort:\n\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\t\tbreak;\n\t}\n\n\t/* Ack last message byte */\n\tNCRCMD(sc, NCRCMD_MSGOK);\n\n\t/* Done, reset message pointer. */\n\tsc->sc_flags &= ~NCR_DROP_MSGI;\n\tsc->sc_imlen = 0;\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr53c9x_reselect",
            "void\tncr53c9x_msgin",
            "static inline int ncr53c9x_stp2cpb",
            "static inline void ncr53c9x_setsync",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr53c9x_reselect;\nvoid\tncr53c9x_msgin;\nstatic inline int ncr53c9x_stp2cpb;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_msgin(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tregister int v;\n\n\tNCR_TRACE((\"[ncr53c9x_msgin(curmsglen:%ld)] \", (long)sc->sc_imlen));\n\n\tif ((NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) == 0) {\n\t\tprintf(\"%s: msgin: no msg byte available\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * Prepare for a new message.  A message should (according\n\t * to the SCSI standard) be transmitted in one single\n\t * MESSAGE_IN_PHASE. If we have been in some other phase,\n\t * then this is a new message.\n\t */\n\tif (sc->sc_prevphase != MESSAGE_IN_PHASE) {\n\t\tsc->sc_flags &= ~NCR_DROP_MSGI;\n\t\tsc->sc_imlen = 0;\n\t}\n\n\tv = NCR_READ_REG(sc, NCR_FIFO);\n\tNCR_MISC((\"<msgbyte:0x%02x>\", v));\n\n#if 0\n\tif (sc->sc_state == NCR_RESELECTED && sc->sc_imlen == 0) {\n\t\t/*\n\t\t * Which target is reselecting us? (The ID bit really)\n\t\t */\n\t\tsc->sc_selid = v;\n\t\tNCR_MISC((\"selid=0x%2x \", sc->sc_selid));\n\t\treturn;\n\t}\n#endif\n\n\tsc->sc_imess[sc->sc_imlen] = v;\n\n\t/*\n\t * If we're going to reject the message, don't bother storing\n\t * the incoming bytes.  But still, we need to ACK them.\n\t */\n\n\tif ((sc->sc_flags & NCR_DROP_MSGI)) {\n\t\tNCRCMD(sc, NCRCMD_MSGOK);\n\t\tprintf(\"<dropping msg byte %x>\",\n\t\t\tsc->sc_imess[sc->sc_imlen]);\n\t\treturn;\n\t}\n\n\tif (sc->sc_imlen >= NCR_MAX_MSG_LEN) {\n\t\tncr53c9x_sched_msgout(SEND_REJECT);\n\t\tsc->sc_flags |= NCR_DROP_MSGI;\n\t} else {\n\t\tsc->sc_imlen++;\n\t\t/*\n\t\t * This testing is suboptimal, but most\n\t\t * messages will be of the one byte variety, so\n\t\t * it should not effect performance\n\t\t * significantly.\n\t\t */\n\t\tif (sc->sc_imlen == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\tgoto gotit;\n\t\tif (sc->sc_imlen == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\tgoto gotit;\n\t\tif (sc->sc_imlen >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t    sc->sc_imlen == sc->sc_imess[1] + 2)\n\t\t\tgoto gotit;\n\t}\n\t/* Ack what we have so far */\n\tNCRCMD(sc, NCRCMD_MSGOK);\n\treturn;\n\ngotit:\n\tNCR_MSGS((\"gotmsg(%x)\", sc->sc_imess[0]));\n\t/*\n\t * Now we should have a complete message (1 byte, 2 byte\n\t * and moderately long extended messages).  We only handle\n\t * extended messages which total length is shorter than\n\t * NCR_MAX_MSG_LEN.  Longer messages will be amputated.\n\t */\n\tswitch (sc->sc_state) {\n\t\tstruct ncr53c9x_ecb *ecb;\n\t\tstruct ncr53c9x_tinfo *ti;\n\n\tcase NCR_CONNECTED:\n\t\tecb = sc->sc_nexus;\n\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\n\t\tswitch (sc->sc_imess[0]) {\n\t\tcase MSG_CMDCOMPLETE:\n\t\t\tNCR_MSGS((\"cmdcomplete \"));\n\t\t\tif (sc->sc_dleft < 0) {\n\t\t\t\tstruct scsi_link *sc_link = ecb->xs->sc_link;\n\t\t\t\tprintf(\"%s: %ld extra bytes from %d:%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, -(long)sc->sc_dleft,\n\t\t\t\t    sc_link->target, sc_link->lun);\n\t\t\t\tsc->sc_dleft = 0;\n\t\t\t}\n\t\t\tecb->dleft = (ecb->flags & ECB_TENTATIVE_DONE)\n\t\t\t\t? 0\n\t\t\t\t: sc->sc_dleft;\n\t\t\tif ((ecb->flags & ECB_SENSE) == 0)\n\t\t\t\tecb->xs->resid = ecb->dleft;\n\t\t\tsc->sc_state = NCR_CMDCOMPLETE;\n\t\t\tbreak;\n\n\t\tcase MSG_MESSAGE_REJECT:\n\t\t\tNCR_MSGS((\"msg reject (msgout=%x) \", sc->sc_msgout));\n\t\t\tswitch (sc->sc_msgout) {\n\t\t\tcase SEND_SDTR:\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t\tbreak;\n\t\t\tcase SEND_INIT_DET_ERR:\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MSG_NOOP:\n\t\t\tNCR_MSGS((\"noop \"));\n\t\t\tbreak;\n\n\t\tcase MSG_DISCONNECT:\n\t\t\tNCR_MSGS((\"disconnect \"));\n\t\t\tti->dconns++;\n\t\t\tsc->sc_state = NCR_DISCONNECT;\n\n\t\t\t/*\n\t\t\t * Mark the fact that all bytes have moved. The\n\t\t\t * target may not bother to do a SAVE POINTERS\n\t\t\t * at this stage. This flag will set the residual\n\t\t\t * count to zero on MSG COMPLETE.\n\t\t\t */\n\t\t\tif (sc->sc_dleft == 0)\n\t\t\t\tecb->flags |= ECB_TENTATIVE_DONE;\n\n\t\t\tbreak;\n\n\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tNCR_MSGS((\"save datapointer \"));\n\t\t\tecb->daddr = sc->sc_dp;\n\t\t\tecb->dleft = sc->sc_dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_RESTOREPOINTERS:\n\t\t\tNCR_MSGS((\"restore datapointer \"));\n\t\t\tsc->sc_dp = ecb->daddr;\n\t\t\tsc->sc_dleft = ecb->dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_EXTENDED:\n\t\t\tNCR_MSGS((\"extended(%x) \", sc->sc_imess[2]));\n\t\t\tswitch (sc->sc_imess[2]) {\n\t\t\tcase MSG_EXT_SDTR:\n\t\t\t\tNCR_MSGS((\"SDTR period %d, offset %d \",\n\t\t\t\t\tsc->sc_imess[3], sc->sc_imess[4]));\n\t\t\t\tif (sc->sc_imess[1] != 3)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->period = sc->sc_imess[3];\n\t\t\t\tti->offset = sc->sc_imess[4];\n\t\t\t\tti->flags &= ~T_NEGOTIATE;\n\t\t\t\tif (sc->sc_minsync == 0 ||\n\t\t\t\t    ti->offset == 0 ||\n\t\t\t\t    ti->period > 124) {\n\t\t\t\t\tprintf(\"%s:%d: async\\n\", \"esp\",\n\t\t\t\t\t\tecb->xs->sc_link->target);\n\t\t\t\t\tif ((sc->sc_flags&NCR_SYNCHNEGO)\n\t\t\t\t\t    == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * target initiated negotiation\n\t\t\t\t\t\t */\n\t\t\t\t\t\tti->offset = 0;\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t\tncr53c9x_sched_msgout(\n\t\t\t\t\t\t    SEND_SDTR);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* we are async */\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint r = 250/ti->period;\n\t\t\t\t\tint s = (100*250)/ti->period - 100*r;\n\t\t\t\t\tint p;\n\n\t\t\t\t\tp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\t\t\t\tti->period = ncr53c9x_cpb2stp(sc, p);\n#ifdef NCR53C9X_DEBUG\n\t\t\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\t\t\tprintf(\"max sync rate %d.%02dMb/s\\n\",\n\t\t\t\t\t\tr, s);\n#endif\n\t\t\t\t\tif ((sc->sc_flags&NCR_SYNCHNEGO) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * target initiated negotiation\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (ti->period <\n\t\t\t\t\t\t    sc->sc_minsync)\n\t\t\t\t\t\t\tti->period =\n\t\t\t\t\t\t\t    sc->sc_minsync;\n\t\t\t\t\t\tif (ti->offset > 15)\n\t\t\t\t\t\t\tti->offset = 15;\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t\tncr53c9x_sched_msgout(\n\t\t\t\t\t\t    SEND_SDTR);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* we are sync */\n\t\t\t\t\t\tti->flags |= T_SYNCMODE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED;\"\n\t\t\t\t    \" sending REJECT\\n\", sc->sc_dev.dv_xname);\n\t\t\t\tgoto reject;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tNCR_MSGS((\"ident \"));\n\t\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\treject:\n\t\t\tncr53c9x_sched_msgout(SEND_REJECT);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase NCR_RESELECTED:\n\t\tif (!MSG_ISIDENTIFY(sc->sc_imess[0])) {\n\t\t\tprintf(\"%s: reselect without IDENTIFY;\"\n\t\t\t    \" sending DEVICE RESET\\n\", sc->sc_dev.dv_xname);\n\t\t\tgoto reset;\n\t\t}\n\n\t\t(void) ncr53c9x_reselect(sc, sc->sc_imess[0]);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE IN; sending DEVICE RESET\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\treset:\n\t\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\t\tbreak;\n\n\tabort:\n\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\t\tbreak;\n\t}\n\n\t/* Ack last message byte */\n\tNCRCMD(sc, NCRCMD_MSGOK);\n\n\t/* Done, reset message pointer. */\n\tsc->sc_flags &= ~NCR_DROP_MSGI;\n\tsc->sc_imlen = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_TRANS"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_PHASE",
          "args": [
            "(\"MESSAGE_IN_PHASE \")"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_msgout",
          "args": [
            "sc"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "1212-1333",
          "snippet": "void\nncr53c9x_msgout(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_tinfo *ti;\n\tstruct ncr53c9x_ecb *ecb;\n\tsize_t size;\n\n\tNCR_TRACE((\"[ncr53c9x_msgout(priq:%x, prevphase:%x)]\",\n\t    sc->sc_msgpriq, sc->sc_prevphase));\n\n\t/*\n\t * XXX - the NCR_ATN flag is not in sync with the actual ATN\n\t *\t condition on the SCSI bus. The 53c9x chip\n\t *\t automatically turns off ATN before sending the\n\t *\t message byte.  (see also the comment below in the\n\t *\t default case when picking out a message to send)\n\t */\n\tif (sc->sc_flags & NCR_ATN) {\n\t\tif (sc->sc_prevphase != MESSAGE_OUT_PHASE) {\n\t\tnew:\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t\tsc->sc_msgoutq = 0;\n\t\t\tsc->sc_omlen = 0;\n\t\t}\n\t} else {\n\t\tif (sc->sc_prevphase == MESSAGE_OUT_PHASE) {\n\t\t\tncr53c9x_sched_msgout(sc->sc_msgoutq);\n\t\t\tgoto new;\n\t\t} else {\n\t\t\tprintf(\"%s at line %d: unexpected MESSAGE OUT phase\\n\",\n\t\t\t    sc->sc_dev.dv_xname, __LINE__);\n\t\t}\n\t}\n\t\t\t\n\tif (sc->sc_omlen == 0) {\n\t\t/* Pick up highest priority message */\n\t\tsc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;\n\t\tsc->sc_msgoutq |= sc->sc_msgout;\n\t\tsc->sc_msgpriq &= ~sc->sc_msgout;\n\t\tsc->sc_omlen = 1;\t\t/* \"Default\" message len */\n\t\tswitch (sc->sc_msgout) {\n\t\tcase SEND_SDTR:\n\t\t\tecb = sc->sc_nexus;\n\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\tsc->sc_omess[0] = MSG_EXTENDED;\n\t\t\tsc->sc_omess[1] = 3;\n\t\t\tsc->sc_omess[2] = MSG_EXT_SDTR;\n\t\t\tsc->sc_omess[3] = ti->period;\n\t\t\tsc->sc_omess[4] = ti->offset;\n\t\t\tsc->sc_omlen = 5;\n\t\t\tif ((sc->sc_flags & NCR_SYNCHNEGO) == 0) {\n\t\t\t\tti->flags |= T_SYNCMODE;\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEND_IDENTIFY:\n\t\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t\tprintf(\"%s at line %d: no nexus\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, __LINE__);\n\t\t\t}\n\t\t\tecb = sc->sc_nexus;\n\t\t\tsc->sc_omess[0] =\n\t\t\t    MSG_IDENTIFY(ecb->xs->sc_link->lun, 0);\n\t\t\tbreak;\n\t\tcase SEND_DEV_RESET:\n\t\t\tsc->sc_flags |= NCR_ABORTING;\n\t\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\t\tecb = sc->sc_nexus;\n\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\tti->flags |= T_NEGOTIATE;\n\t\t\tbreak;\n\t\tcase SEND_PARITY_ERROR:\n\t\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\t\tbreak;\n\t\tcase SEND_ABORT:\n\t\t\tsc->sc_flags |= NCR_ABORTING;\n\t\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\t\tbreak;\n\t\tcase SEND_INIT_DET_ERR:\n\t\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\t\tbreak;\n\t\tcase SEND_REJECT:\n\t\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * We normally do not get here, since the chip\n\t\t\t * automatically turns off ATN before the last\n\t\t\t * byte of a message is sent to the target.\n\t\t\t * However, if the target rejects our (multi-byte)\n\t\t\t * message early by switching to MSG IN phase\n\t\t\t * ATN remains on, so the target may return to\n\t\t\t * MSG OUT phase. If there are no scheduled messages\n\t\t\t * left we send a NO-OP.\n\t\t\t *\n\t\t\t * XXX - Note that this leaves no useful purpose for\n\t\t\t * the NCR_ATN flag.\n\t\t\t */\n\t\t\tsc->sc_flags &= ~NCR_ATN;\n\t\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\t\tbreak;\n\t\t}\n\t\tsc->sc_omp = sc->sc_omess;\n\t}\n\n\t/* (re)send the message */\n\tsize = min(sc->sc_omlen, sc->sc_maxxfer);\n\tNCRDMA_SETUP(sc, &sc->sc_omp, &sc->sc_omlen, 0, &size);\n\t/* Program the SCSI counter */\n\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t}\n\t/* Load the count in and start the message-out transfer */\n\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\tNCRCMD(sc, NCRCMD_TRANS|NCRCMD_DMA);\n\tNCRDMA_GO(sc);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_msgout",
            "static inline void ncr53c9x_setsync",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_msgout;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_msgout(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_tinfo *ti;\n\tstruct ncr53c9x_ecb *ecb;\n\tsize_t size;\n\n\tNCR_TRACE((\"[ncr53c9x_msgout(priq:%x, prevphase:%x)]\",\n\t    sc->sc_msgpriq, sc->sc_prevphase));\n\n\t/*\n\t * XXX - the NCR_ATN flag is not in sync with the actual ATN\n\t *\t condition on the SCSI bus. The 53c9x chip\n\t *\t automatically turns off ATN before sending the\n\t *\t message byte.  (see also the comment below in the\n\t *\t default case when picking out a message to send)\n\t */\n\tif (sc->sc_flags & NCR_ATN) {\n\t\tif (sc->sc_prevphase != MESSAGE_OUT_PHASE) {\n\t\tnew:\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t\tsc->sc_msgoutq = 0;\n\t\t\tsc->sc_omlen = 0;\n\t\t}\n\t} else {\n\t\tif (sc->sc_prevphase == MESSAGE_OUT_PHASE) {\n\t\t\tncr53c9x_sched_msgout(sc->sc_msgoutq);\n\t\t\tgoto new;\n\t\t} else {\n\t\t\tprintf(\"%s at line %d: unexpected MESSAGE OUT phase\\n\",\n\t\t\t    sc->sc_dev.dv_xname, __LINE__);\n\t\t}\n\t}\n\t\t\t\n\tif (sc->sc_omlen == 0) {\n\t\t/* Pick up highest priority message */\n\t\tsc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;\n\t\tsc->sc_msgoutq |= sc->sc_msgout;\n\t\tsc->sc_msgpriq &= ~sc->sc_msgout;\n\t\tsc->sc_omlen = 1;\t\t/* \"Default\" message len */\n\t\tswitch (sc->sc_msgout) {\n\t\tcase SEND_SDTR:\n\t\t\tecb = sc->sc_nexus;\n\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\tsc->sc_omess[0] = MSG_EXTENDED;\n\t\t\tsc->sc_omess[1] = 3;\n\t\t\tsc->sc_omess[2] = MSG_EXT_SDTR;\n\t\t\tsc->sc_omess[3] = ti->period;\n\t\t\tsc->sc_omess[4] = ti->offset;\n\t\t\tsc->sc_omlen = 5;\n\t\t\tif ((sc->sc_flags & NCR_SYNCHNEGO) == 0) {\n\t\t\t\tti->flags |= T_SYNCMODE;\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEND_IDENTIFY:\n\t\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t\tprintf(\"%s at line %d: no nexus\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, __LINE__);\n\t\t\t}\n\t\t\tecb = sc->sc_nexus;\n\t\t\tsc->sc_omess[0] =\n\t\t\t    MSG_IDENTIFY(ecb->xs->sc_link->lun, 0);\n\t\t\tbreak;\n\t\tcase SEND_DEV_RESET:\n\t\t\tsc->sc_flags |= NCR_ABORTING;\n\t\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\t\tecb = sc->sc_nexus;\n\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\tti->flags |= T_NEGOTIATE;\n\t\t\tbreak;\n\t\tcase SEND_PARITY_ERROR:\n\t\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\t\tbreak;\n\t\tcase SEND_ABORT:\n\t\t\tsc->sc_flags |= NCR_ABORTING;\n\t\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\t\tbreak;\n\t\tcase SEND_INIT_DET_ERR:\n\t\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\t\tbreak;\n\t\tcase SEND_REJECT:\n\t\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * We normally do not get here, since the chip\n\t\t\t * automatically turns off ATN before the last\n\t\t\t * byte of a message is sent to the target.\n\t\t\t * However, if the target rejects our (multi-byte)\n\t\t\t * message early by switching to MSG IN phase\n\t\t\t * ATN remains on, so the target may return to\n\t\t\t * MSG OUT phase. If there are no scheduled messages\n\t\t\t * left we send a NO-OP.\n\t\t\t *\n\t\t\t * XXX - Note that this leaves no useful purpose for\n\t\t\t * the NCR_ATN flag.\n\t\t\t */\n\t\t\tsc->sc_flags &= ~NCR_ATN;\n\t\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\t\tbreak;\n\t\t}\n\t\tsc->sc_omp = sc->sc_omess;\n\t}\n\n\t/* (re)send the message */\n\tsize = min(sc->sc_omlen, sc->sc_maxxfer);\n\tNCRDMA_SETUP(sc, &sc->sc_omp, &sc->sc_omlen, 0, &size);\n\t/* Program the SCSI counter */\n\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t}\n\t/* Load the count in and start the message-out transfer */\n\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\tNCRCMD(sc, NCRCMD_TRANS|NCRCMD_DMA);\n\tNCRDMA_GO(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_PHASE",
          "args": [
            "(\"MESSAGE_OUT_PHASE \")"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"esp no nexus\""
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: invalid state: %d\"",
            "sc->sc_dev.dv_xname",
            "sc->sc_state"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_MSGOK"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_PHASE",
          "args": [
            "(\"<stat:(%x,%x)>\", ecb->stat, msg)"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FIFO"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FIFO"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FIFO"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_ABORT"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_SDTR"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_RSTATN"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"esp: no nexus\""
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MISC",
          "args": [
            "(\"selid=0x%2x \", sc->sc_selid)"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FIFO"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->ready_list",
            "ecb",
            "chain"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ncr53c9x_timeout",
            "ecb"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MISC",
          "args": [
            "(\"backoff selector \")"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "ecb->xs->sc_link"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->nexus_list",
            "ecb",
            "chain"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sense",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_sense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "718-751",
          "snippet": "void\nncr53c9x_sense(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&ecb->cmd.cmd;\n\n\tNCR_MISC((\"requesting sense \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tecb->clen = sizeof(*ss);\n\tecb->daddr = (char *)&xs->sense;\n\tecb->dleft = sizeof(struct scsi_sense_data);\n\tecb->flags |= ECB_SENSE;\n\tecb->timeout = NCR_SENSE_TIMEOUT;\n\tti->senses++;\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tecb->flags &= ~ECB_NEXUS;\n\t\tncr53c9x_select(sc, ecb);\n\t} else {\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);\n\t\tif (sc->sc_state == NCR_IDLE)\n\t\t\tncr53c9x_sched(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_sched",
            "void ncr53c9x_dequeue",
            "void ncr53c9x_sense",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nvoid ncr53c9x_dequeue;\nvoid ncr53c9x_sense;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_sense(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&ecb->cmd.cmd;\n\n\tNCR_MISC((\"requesting sense \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tecb->clen = sizeof(*ss);\n\tecb->daddr = (char *)&xs->sense;\n\tecb->dleft = sizeof(struct scsi_sense_data);\n\tecb->flags |= ECB_SENSE;\n\tecb->timeout = NCR_SENSE_TIMEOUT;\n\tti->senses++;\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tecb->flags &= ~ECB_NEXUS;\n\t\tncr53c9x_select(sc, ecb);\n\t} else {\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);\n\t\tif (sc->sc_state == NCR_IDLE)\n\t\t\tncr53c9x_sched(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ncr53c9x_timeout",
            "ecb"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "ecb->xs->sc_link"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_ENSEL"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MISC",
          "args": [
            "(\"<DISC [intr %x, stat %x, step %d]>\",\n\t\t\tsc->sc_espintr,sc->sc_espstat,sc->sc_espstep)"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_INIT_DET_ERR"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_PARITY_ERROR"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_ISACTIVE",
          "args": [
            "sc"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_INTR",
          "args": [
            "sc"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_ISACTIVE",
          "args": [
            "sc"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: nexus in reset state\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_readregs",
          "args": [
            "sc"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_readregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "373-397",
          "snippet": "__inline__ void\nncr53c9x_readregs(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\n\tsc->sc_espstat = NCR_READ_REG(sc, NCR_STAT);\n\t/* Only the stepo bits are of interest */\n\tsc->sc_espstep = NCR_READ_REG(sc, NCR_STEP) & NCRSTEP_MASK;\n\tsc->sc_espintr = NCR_READ_REG(sc, NCR_INTR);\n\n\tif (sc->sc_glue->gl_clear_latched_intr != NULL)\n\t\t(*sc->sc_glue->gl_clear_latched_intr)(sc);\n\n\t/*\n\t * Determine the SCSI bus phase, return either a real SCSI bus phase\n\t * or some pseudo phase we use to detect certain exceptions.\n\t */\n\n\tsc->sc_phase = (sc->sc_espintr & NCRINTR_DIS)\n\t\t\t? /* Disconnected */ BUSFREE_PHASE\n\t\t\t: sc->sc_espstat & NCRSTAT_PHASE;\n\n\tNCR_MISC((\"regs[intr=%02x,stat=%02x,step=%02x] \",\n\t\tsc->sc_espintr, sc->sc_espstat, sc->sc_espstep));\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_readregs",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_readregs;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\n__inline__ void\nncr53c9x_readregs(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\n\tsc->sc_espstat = NCR_READ_REG(sc, NCR_STAT);\n\t/* Only the stepo bits are of interest */\n\tsc->sc_espstep = NCR_READ_REG(sc, NCR_STEP) & NCRSTEP_MASK;\n\tsc->sc_espintr = NCR_READ_REG(sc, NCR_INTR);\n\n\tif (sc->sc_glue->gl_clear_latched_intr != NULL)\n\t\t(*sc->sc_glue->gl_clear_latched_intr)(sc);\n\n\t/*\n\t * Determine the SCSI bus phase, return either a real SCSI bus phase\n\t * or some pseudo phase we use to detect certain exceptions.\n\t */\n\n\tsc->sc_phase = (sc->sc_espintr & NCRINTR_DIS)\n\t\t\t? /* Disconnected */ BUSFREE_PHASE\n\t\t\t: sc->sc_espstat & NCRSTAT_PHASE;\n\n\tNCR_MISC((\"regs[intr=%02x,stat=%02x,step=%02x] \",\n\t\tsc->sc_espintr, sc->sc_espstat, sc->sc_espstep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCRDMA_ISINTR",
          "args": [
            "sc"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "(\"[ncr53c9x_intr] \")"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNCRINTR_DONE\t(NCRINTR_FC|NCRINTR_BS)\n#define NCRINTR_ERR (NCRINTR_SBR|NCRINTR_ILL)\n\nvoid\tncr53c9x_readregs;\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_done;\nvoid\tncr53c9x_msgin;\nvoid\tncr53c9x_msgout;\nvoid\tncr53c9x_timeout;\nvoid ncr53c9x_sense;\nint ncr53c9x_dmaselect = 0;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nint\nncr53c9x_intr(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tregister struct ncr53c9x_ecb *ecb;\n\tregister struct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\tsize_t size;\n\tint nfifo;\n\n\tNCR_TRACE((\"[ncr53c9x_intr] \"));\n\n\tif (!NCRDMA_ISINTR(sc))\n\t\treturn (0);\n\nagain:\n\t/* and what do the registers day... */\n\tncr53c9x_readregs(sc);\n\n\tsc->sc_intrcnt.ev_count++;\n\n\t/*\n\t * Command are classed as errors. A disconnect is a\n\t * valid condition, and we let the code check is the\n\t * \"NCR_BUSFREE_OK\" flag was set before declaring it\n\t * and error.\n\t * \n\t * Also, the status register tells us about \"Gross\n\t * Errors\" and \"Parity errors\". Only the Gross Error\n\t * is really bad, and the parity errors are dealt   \n\t * with later\n\t * \n\t * TODO\n\t *      If there are too many parity error, go to slow\n\t *      cable mode ?\n\t */\n\n\t/* SCSI Reset */\n\tif (sc->sc_espintr & NCRINTR_SBR) {\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\tif (sc->sc_state != NCR_SBR) {\n\t\t\tprintf(\"%s: SCSI bus reset\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 0); /* Restart everything */\n\t\t\treturn (1);\n\t\t}\n#if 0\n/*XXX*/\t\tprintf(\"<expected bus reset: \"\n\t\t\t\"[intr %x, stat %x, step %d]>\\n\",\n\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\tsc->sc_espstep);\n#endif\n\t\tif (sc->sc_nexus)\n\t\t\tpanic(\"%s: nexus in reset state\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tgoto sched;\n\t}\n\n\tecb = sc->sc_nexus;\n\n#define NCRINTR_ERR (NCRINTR_SBR|NCRINTR_ILL)\n\tif (sc->sc_espintr & NCRINTR_ERR ||\n\t    sc->sc_espstat & NCRSTAT_GE) {\n\n\t\tif (sc->sc_espstat & NCRSTAT_GE) {\n\t\t\t/* Gross Error; no target ? */\n\t\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tDELAY(1);\n\t\t\t}\n\t\t\tif (sc->sc_state == NCR_CONNECTED ||\n\t\t\t    sc->sc_state == NCR_SELECTING) {\n\t\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\t\tncr53c9x_done(sc, ecb);\n\t\t\t}\n\t\t\t\treturn (1);\n\t\t}\n\n\t\tif (sc->sc_espintr & NCRINTR_ILL) {\n\t\t\tif (sc->sc_flags & NCR_EXPECT_ILLCMD) {\n\t\t\t\t/*\n\t\t\t\t * Eat away \"Illegal command\" interrupt\n\t\t\t\t * on a ESP100 caused by a re-selection\n\t\t\t\t * while we were trying to select\n\t\t\t\t * another target.\n\t\t\t\t */\n#ifdef DEBUG\n\t\t\t\tprintf(\"%s: ESP100 work-around activated\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n#endif\n\t\t\t\tsc->sc_flags &= ~NCR_EXPECT_ILLCMD;\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\t/* illegal command, out of sync ? */\n\t\t\tprintf(\"%s: illegal command: 0x%x \"\n\t\t\t    \"(state %d, phase %x, prevphase %x)\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, sc->sc_lastcmd,\n\t\t\t\tsc->sc_state, sc->sc_phase,\n\t\t\t\tsc->sc_prevphase);\n\t\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tDELAY(1);\n\t\t\t}\n\t\t\tncr53c9x_init(sc, 1); /* Restart everything */\n\t\t\treturn (1);\n\t\t}\n\t}\n\tsc->sc_flags &= ~NCR_EXPECT_ILLCMD;\n\n\t/*\n\t * Call if DMA is active.\n\t *\n\t * If DMA_INTR returns true, then maybe go 'round the loop\n\t * again in case there is no more DMA queued, but a phase\n\t * change is expected.\n\t */\n\tif (NCRDMA_ISACTIVE(sc)) {\n\t\tint r = NCRDMA_INTR(sc);\n\t\tif (r == -1) {\n\t\t\tprintf(\"%s: DMA error; resetting\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t}\n\t\t/* If DMA active here, then go back to work... */\n\t\tif (NCRDMA_ISACTIVE(sc))\n\t\t\treturn (1);\n\n\t\tif ((sc->sc_espstat & NCRSTAT_TC) == 0) {\n\t\t\t/*\n\t\t\t * DMA not completed.  If we can not find a\n\t\t\t * acceptable explanation, print a diagnostic.\n\t\t\t */\n\t\t\tif (sc->sc_state == NCR_SELECTING)\n\t\t\t\t/*\n\t\t\t\t * This can happen if we are reselected\n\t\t\t\t * while using DMA to select a target.\n\t\t\t\t */\n\t\t\t\t/*void*/;\n\t\t\telse if (sc->sc_prevphase == MESSAGE_OUT_PHASE){\n\t\t\t\t/*\n\t\t\t\t * Our (multi-byte) message (eg SDTR)\n\t\t\t\t * was interrupted by the target to\n\t\t\t\t * send a MSG REJECT.\n\t\t\t\t * Print diagnostic if current phase\n\t\t\t\t * is not MESSAGE IN.\n\t\t\t\t */\n\t\t\t\tif (sc->sc_phase != MESSAGE_IN_PHASE)\n\t\t\t\t    printf(\"%s: !TC on MSG OUT\"\n\t\t\t\t       \" [intr %x, stat %x, step %d]\"\n\t\t\t\t       \" prevphase %x, resid %x\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase,\n\t\t\t\t\tsc->sc_omlen);\n\t\t\t} else if (sc->sc_dleft == 0) {\n\t\t\t\t/*\n\t\t\t\t * The DMA operation was started for\n\t\t\t\t * a DATA transfer. Print a diagnostic\n\t\t\t\t * if the DMA counter and TC bit\n\t\t\t\t * appear to be out of sync.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: !TC on DATA XFER\"\n\t\t\t\t       \" [intr %x, stat %x, step %d]\"\n\t\t\t\t       \" prevphase %x, resid %x\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase,\n\t\t\t\t\tecb?ecb->dleft:-1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * check for less serious errors\n\t */\n\tif (sc->sc_espstat & NCRSTAT_PE) {\n\t\tprintf(\"%s: SCSI bus parity error\\n\", sc->sc_dev.dv_xname);\n\t\tif (sc->sc_prevphase == MESSAGE_IN_PHASE)\n\t\t\tncr53c9x_sched_msgout(SEND_PARITY_ERROR);\n\t\telse\n\t\t\tncr53c9x_sched_msgout(SEND_INIT_DET_ERR);\n\t}\n\n\tif (sc->sc_espintr & NCRINTR_DIS) {\n\t\tNCR_MISC((\"<DISC [intr %x, stat %x, step %d]>\",\n\t\t\tsc->sc_espintr,sc->sc_espstat,sc->sc_espstep));\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\t/*\n\t\t * This command must (apparently) be issued within\n\t\t * 250mS of a disconnect. So here you are...\n\t\t */\n\t\tNCRCMD(sc, NCRCMD_ENSEL);\n\n\t\tswitch (sc->sc_state) {\n\t\tcase NCR_RESELECTED:\n\t\t\tgoto sched;\n\n\t\tcase NCR_SELECTING:\n\t\t\tecb->xs->error = XS_SELTIMEOUT;\n\t\t\tgoto finish;\n\n\t\tcase NCR_CONNECTED:\n\t\t\tif ((sc->sc_flags & NCR_SYNCHNEGO)) {\n#ifdef NCR53C9X_DEBUG\n\t\t\t\tif (ecb)\n\t\t\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\t\tprintf(\"sync nego not completed!\\n\");\n#endif\n\t\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);\n\t\t\t}\n\n\t\t\t/* it may be OK to disconnect */\n\t\t\tif ((sc->sc_flags & NCR_ABORTING) == 0) {\n\t\t\t\t/*  \n\t\t\t\t * Section 5.1.1 of the SCSI 2 spec\n\t\t\t\t * suggests issuing a REQUEST SENSE\n\t\t\t\t * following an unexpected disconnect.\n\t\t\t\t * Some devices go into a contingent\n\t\t\t\t * allegiance condition when\n\t\t\t\t * disconnecting, and this is necessary\n\t\t\t\t * to clean up their state.\n\t\t\t\t */     \n\t\t\t\tprintf(\"%s: unexpected disconnect; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tif (ecb->flags & ECB_SENSE) {\n\t\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\tprintf(\"sending REQUEST SENSE\\n\");\n\t\t\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\t\t\tncr53c9x_sense(sc, ecb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tgoto finish;\n\n\t\tcase NCR_DISCONNECT:\n\t\t\tTAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);\n\t\t\tsc->sc_nexus = NULL;\n\t\t\tgoto sched;\n\n\t\tcase NCR_CMDCOMPLETE:\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\tswitch (sc->sc_state) {\n\n\tcase NCR_SBR:\n\t\tprintf(\"%s: waiting for SCSI Bus Reset to happen\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n\t\t\treturn (1);\n\n\tcase NCR_RESELECTED:\n\t\t/*\n\t\t * we must be continuing a message ?\n\t\t */\n\t\tif (sc->sc_phase != MESSAGE_IN_PHASE) {\n\t\t\tprintf(\"%s: target didn't identify\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t\treturn (1);\n\t\t}\nprintf(\"<<RESELECT CONT'd>>\");\n#if XXXX\n\t\tncr53c9x_msgin(sc);\n\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t/* IDENTIFY fail?! */\n\t\t\tprintf(\"%s: identify failed\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t\treturn (1);\n\t\t}\n#endif\n\t\tbreak;\n\n\tcase NCR_IDLE:\n\tcase NCR_SELECTING:\n\t\tsc->sc_msgpriq = sc->sc_msgout = sc->sc_msgoutq = 0;\n\t\tsc->sc_flags = 0;\n\t\tecb = sc->sc_nexus;\n\t\tif (ecb != NULL && (ecb->flags & ECB_NEXUS)) {\n\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\tprintf(\"ECB_NEXUS while in state %x\\n\", sc->sc_state);\n\t\t}\n\n\t\tif (sc->sc_espintr & NCRINTR_RESEL) {\n\t\t\t/*\n\t\t\t * If we're trying to select a\n\t\t\t * target ourselves, push our command\n\t\t\t * back into the ready list.\n\t\t\t */\n\t\t\tif (sc->sc_state == NCR_SELECTING) {\n\t\t\t\tNCR_MISC((\"backoff selector \"));\n\t\t\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\t\t\tsc_link = ecb->xs->sc_link;\n\t\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\t\t\tTAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);\n\t\t\t\tecb = sc->sc_nexus = NULL;\n\t\t\t}\n\t\t\tsc->sc_state = NCR_RESELECTED;\n\t\t\tif (sc->sc_phase != MESSAGE_IN_PHASE) {\n\t\t\t\t/*\n\t\t\t\t * Things are seriously fucked up.\n\t\t\t\t * Pull the brakes, i.e. reset\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: target didn't identify\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\t/*\n\t\t\t * The C90 only inhibits FIFO writes until\n\t\t\t * reselection is complete, instead of\n\t\t\t * waiting until the interrupt status register\n\t\t\t * has been read. So, if the reselect happens\n\t\t\t * while we were entering a command bytes (for\n\t\t\t * another target) some of those bytes can\n\t\t\t * appear in the FIFO here, after the\n\t\t\t * interrupt is taken.\n\t\t\t */\n\t\t\tnfifo = NCR_READ_REG(sc,NCR_FFLAG) & NCRFIFO_FF;\n\t\t\tif (nfifo < 2 ||\n\t\t\t    (nfifo > 2 &&\n\t\t\t     sc->sc_rev != NCR_VARIANT_ESP100)) {\n\t\t\t\tprintf(\"%s: RESELECT: \"\n\t\t\t\t    \"%d bytes in FIFO! \"\n\t\t\t\t    \"[intr %x, stat %x, step %d, prevphase %x]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tnfifo,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase);\n\t\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tsc->sc_selid = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tNCR_MISC((\"selid=0x%2x \", sc->sc_selid));\n\n\t\t\t/* Handle identify message */\n\t\t\tncr53c9x_msgin(sc);\n\t\t\tif (nfifo != 2) {\n\t\t\t\t/*\n\t\t\t\t * Note: this should not happen\n\t\t\t\t * with `dmaselect' on.\n\t\t\t\t */\n\t\t\t\tsc->sc_flags |= NCR_EXPECT_ILLCMD;\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t} else if (ncr53c9x_dmaselect &&\n\t\t\t\t   sc->sc_rev == NCR_VARIANT_ESP100) {\n\t\t\t\tsc->sc_flags |= NCR_EXPECT_ILLCMD;\n\t\t\t}\n\n\t\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t\t/* IDENTIFY fail?! */\n\t\t\t\tprintf(\"%s: identify failed\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tgoto shortcut; /* ie. next phase expected soon */\n\t\t}\n\n#define\tNCRINTR_DONE\t(NCRINTR_FC|NCRINTR_BS)\n\t\tif ((sc->sc_espintr & NCRINTR_DONE) == NCRINTR_DONE) {\n\t\t\t/*\n\t\t\t * Arbitration won; examine the `step' register\n\t\t\t * to determine how far the selection could progress.\n\t\t\t */\n\t\t\tecb = sc->sc_nexus;\n\t\t\tif (!ecb)\n\t\t\t\tpanic(\"esp: no nexus\");\n\n\t\t\tsc_link = ecb->xs->sc_link;\n\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\n\t\t\tswitch (sc->sc_espstep) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * The target did not respond with a\n\t\t\t\t * message out phase - probably an old\n\t\t\t\t * device that doesn't recognize ATN.\n\t\t\t\t * Clear ATN and just continue, the\n\t\t\t\t * target should be in the command\n\t\t\t\t * phase.\n\t\t\t\t * XXXX check for command phase?\n\t\t\t\t */\n\t\t\t\tNCRCMD(sc, NCRCMD_RSTATN);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif ((ti->flags & T_NEGOTIATE) == 0) {\n\t\t\t\t\tprintf(\"%s: step 1 & !NEG\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\tif (sc->sc_phase != MESSAGE_OUT_PHASE) {\n\t\t\t\t\tprintf(\"%s: !MSGOUT\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\t/* Start negotiating */\n\t\t\t\tti->period = sc->sc_minsync;\n\t\t\t\tti->offset = 15;\n\t\t\t\tsc->sc_flags |= NCR_SYNCHNEGO;\n\t\t\t\tncr53c9x_sched_msgout(SEND_SDTR);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t/*\n\t\t\t\t * Grr, this is supposed to mean\n\t\t\t\t * \"target left command phase  prematurely\".\n\t\t\t\t * It seems to happen regularly when\n\t\t\t\t * sync mode is on.\n\t\t\t\t * Look at FIFO to see if command went out.\n\t\t\t\t * (Timing problems?)\n\t\t\t\t */\n\t\t\t\tif (ncr53c9x_dmaselect) {\n\t\t\t\t\tif (sc->sc_cmdlen == 0)\n\t\t\t\t\t\t/* Hope for the best.. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if ((NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t    & NCRFIFO_FF) == 0) {\n\t\t\t\t\t\t/* Hope for the best.. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"(%s:%d:%d): selection failed;\"\n\t\t\t\t\t\" %d left in FIFO \"\n\t\t\t\t\t\"[intr %x, stat %x, step %d]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc_link->target,\n\t\t\t\t\tsc_link->lun,\n\t\t\t\t\tNCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t & NCRFIFO_FF,\n\t\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep);\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\t\t\t\treturn (1);\n\t\t\tcase 2:\n\t\t\t\t/* Select stuck at Command Phase */\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tcase 4:\n\t\t\t\tif (ncr53c9x_dmaselect &&\n\t\t\t\t    sc->sc_cmdlen != 0)\n\t\t\t\t\tprintf(\"(%s:%d:%d): select; \"\n\t\t\t\t\t       \"%d left in DMA buffer \"\n\t\t\t\t\t\"[intr %x, stat %x, step %d]\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tsc_link->target,\n\t\t\t\t\t\tsc_link->lun,\n\t\t\t\t\t\tsc->sc_cmdlen,\n\t\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\t\tsc->sc_espstep);\n\t\t\t\t/* So far, everything went fine */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tecb->flags |= ECB_NEXUS;\n\t\t\tti->lubusy |= (1 << sc_link->lun);\n\n\t\t\tsc->sc_prevphase = INVALID_PHASE; /* ?? */\n\t\t\t/* Do an implicit RESTORE POINTERS. */\n\t\t\tsc->sc_dp = ecb->daddr;\n\t\t\tsc->sc_dleft = ecb->dleft;\n\t\t\tsc->sc_state = NCR_CONNECTED;\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\tprintf(\"%s: unexpected status after select\"\n\t\t\t\t\": [intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t\tgoto reset;\n\t\t}\n\t\tif (sc->sc_state == NCR_IDLE) {\n\t\t\tprintf(\"%s: stray interrupt\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\n\tcase NCR_CONNECTED:\n\t\tif (sc->sc_flags & NCR_ICCS) {\n\t\t\t/* \"Initiate Command Complete Steps\" in progress */\n\t\t\tu_char msg;\n\n\t\t\tsc->sc_flags &= ~NCR_ICCS;\n\n\t\t\tif (!(sc->sc_espintr & NCRINTR_DONE)) {\n\t\t\t\tprintf(\"%s: ICCS: \"\n\t\t\t\t      \": [intr %x, stat %x, step %x]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep);\n\t\t\t}\n\t\t\tif ((NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t    & NCRFIFO_FF) != 2) {\n\t\t\t\tint i = (NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t    & NCRFIFO_FF) - 2;\n\t\t\t\twhile (i--)\n\t\t\t\t\t(void) NCR_READ_REG(sc, NCR_FIFO);\n\t\t\t}\n\t\t\tecb->stat = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tmsg = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tNCR_PHASE((\"<stat:(%x,%x)>\", ecb->stat, msg));\n\t\t\tif (msg == MSG_CMDCOMPLETE) {\n\t\t\t\tecb->dleft = (ecb->flags & ECB_TENTATIVE_DONE)\n\t\t\t\t\t? 0\n\t\t\t\t\t: sc->sc_dleft;\n\t\t\t\tif ((ecb->flags & ECB_SENSE) == 0)\n\t\t\t\t\tecb->xs->resid = ecb->dleft;\n\t\t\t\tsc->sc_state = NCR_CMDCOMPLETE;\n\t\t\t} else\n\t\t\t\tprintf(\"%s: STATUS_PHASE: msg %d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname, msg);\n\t\t\tNCRCMD(sc, NCRCMD_MSGOK);\n\t\t\tgoto shortcut; /* ie. wait for disconnect */\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"%s: invalid state: %d\",\n\t\t      sc->sc_dev.dv_xname,\n\t\t      sc->sc_state);\n\t}\n\n\t/*\n\t * Driver is now in state NCR_CONNECTED, i.e. we\n\t * have a current command working the SCSI bus.\n\t */\n\tif (sc->sc_state != NCR_CONNECTED || ecb == NULL) {\n\t\tpanic(\"esp no nexus\");\n\t}\n\n\tswitch (sc->sc_phase) {\n\tcase MESSAGE_OUT_PHASE:\n\t\tNCR_PHASE((\"MESSAGE_OUT_PHASE \"));\n\t\tncr53c9x_msgout(sc);\n\t\tsc->sc_prevphase = MESSAGE_OUT_PHASE;\n\t\tbreak;\n\tcase MESSAGE_IN_PHASE:\n\t\tNCR_PHASE((\"MESSAGE_IN_PHASE \"));\n\t\tsc->sc_prevphase = MESSAGE_IN_PHASE;\n\t\tif (sc->sc_espintr & NCRINTR_BS) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tsc->sc_flags |= NCR_WAITI;\n\t\t\tNCRCMD(sc, NCRCMD_TRANS);\n\t\t} else if (sc->sc_espintr & NCRINTR_FC) {\n\t\t\tif ((sc->sc_flags & NCR_WAITI) == 0) {\n\t\t\t\tprintf(\"%s: MSGIN: unexpected FC bit: \"\n\t\t\t\t\t\"[intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t\t}\n\t\t\tsc->sc_flags &= ~NCR_WAITI;\n\t\t\tncr53c9x_msgin(sc);\n\t\t} else {\n\t\t\tprintf(\"%s: MSGIN: weird bits: \"\n\t\t\t\t\"[intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t}\n\t\tgoto shortcut;\t/* i.e. expect data to be ready */\n\t\tbreak;\n\tcase COMMAND_PHASE:\n\t\t/*\n\t\t * Send the command block. Normally we don't see this\n\t\t * phase because the SEL_ATN command takes care of\n\t\t * all this. However, we end up here if either the\n\t\t * target or we wanted to exchange some more messages\n\t\t * first (e.g. to start negotiations).\n\t\t */\n\n\t\tNCR_PHASE((\"COMMAND_PHASE 0x%02x (%d) \",\n\t\t\tecb->cmd.cmd.opcode, ecb->clen));\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\tif (ncr53c9x_dmaselect) {\n\t\t\tsize_t size;\n\t\t\t/* setup DMA transfer for command */\n\t\t\tsize = ecb->clen;\n\t\t\tsc->sc_cmdlen = size;\n\t\t\tsc->sc_cmdp = (caddr_t)&ecb->cmd.cmd;\n\t\t\tNCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen,\n\t\t\t\t     0, &size);\n\t\t\t/* Program the SCSI counter */\n\t\t\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\t\t\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\t\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t\t\t}\n\n\t\t\t/* load the count in */\n\t\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t\t/* start the command transfer */\n\t\t\tNCRCMD(sc, NCRCMD_TRANS | NCRCMD_DMA);\n\t\t\tNCRDMA_GO(sc);\n\t\t} else {\n\t\t\tu_char *cmd = (u_char *)&ecb->cmd.cmd;\n\t\t\tint i;\n\t\t\t/* Now the command into the FIFO */\n\t\t\tfor (i = 0; i < ecb->clen; i++)\n\t\t\t\tNCR_WRITE_REG(sc, NCR_FIFO, *cmd++);\n\t\t\tNCRCMD(sc, NCRCMD_TRANS);\n\t\t}\n\t\tsc->sc_prevphase = COMMAND_PHASE;\n\t\tbreak;\n\tcase DATA_OUT_PHASE:\n\t\tNCR_PHASE((\"DATA_OUT_PHASE [%ld] \",(long)sc->sc_dleft));\n\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\tsize = min(sc->sc_dleft, sc->sc_maxxfer);\n\t\tNCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,\n\t\t\t  0, &size);\n\t\tsc->sc_prevphase = DATA_OUT_PHASE;\n\t\tgoto setup_xfer;\n\tcase DATA_IN_PHASE:\n\t\tNCR_PHASE((\"DATA_IN_PHASE \"));\n\t\tif (sc->sc_rev == NCR_VARIANT_ESP100)\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\tsize = min(sc->sc_dleft, sc->sc_maxxfer);\n\t\tNCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,\n\t\t\t  1, &size);\n\t\tsc->sc_prevphase = DATA_IN_PHASE;\n\tsetup_xfer:\n\t\t/* Target returned to data phase: wipe \"done\" memory */\n\t\tecb->flags &= ~ECB_TENTATIVE_DONE;\n\n\t\t/* Program the SCSI counter */\n\t\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\t\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t\t}\n\t\t/* load the count in */\n\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t/*\n\t\t * Note that if `size' is 0, we've already transceived\n\t\t * all the bytes we want but we're still in DATA PHASE.\n\t\t * Apparently, the device needs padding. Also, a\n\t\t * transfer size of 0 means \"maximum\" to the chip\n\t\t * DMA logic.\n\t\t */\n\t\tNCRCMD(sc,\n\t\t       (size==0?NCRCMD_TRPAD:NCRCMD_TRANS)|NCRCMD_DMA);\n\t\tNCRDMA_GO(sc);\n\t\treturn (1);\n\tcase STATUS_PHASE:\n\t\tNCR_PHASE((\"STATUS_PHASE \"));\n\t\tsc->sc_flags |= NCR_ICCS;\n\t\tNCRCMD(sc, NCRCMD_ICCS);\n\t\tsc->sc_prevphase = STATUS_PHASE;\n\t\tbreak;\n\tcase INVALID_PHASE:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unexpected bus phase; resetting\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto reset;\n\t}\n\nout:\n\treturn (1);\n\nreset:\n\tncr53c9x_init(sc, 1);\n\tgoto out;\n\nfinish:\n\tncr53c9x_done(sc, ecb);\n\tgoto out;\n\nsched:\n\tsc->sc_state = NCR_IDLE;\n\tncr53c9x_sched(sc);\n\tgoto out;\n\nshortcut:\n\t/*\n\t * The idea is that many of the SCSI operations take very little\n\t * time, and going away and getting interrupted is too high an\n\t * overhead to pay. For example, selecting, sending a message\n\t * and command and then doing some work can be done in one \"pass\".\n\t *\n\t * The delay is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1\n\t * at 40Mhz. This needs testing.\n\t */\n\tDELAY(50/sc->sc_freq);\n\tif (NCRDMA_ISINTR(sc))\n\t\tgoto again;\n\tgoto out;\n}"
  },
  {
    "function_name": "ncr53c9x_msgout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "1212-1333",
    "snippet": "void\nncr53c9x_msgout(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_tinfo *ti;\n\tstruct ncr53c9x_ecb *ecb;\n\tsize_t size;\n\n\tNCR_TRACE((\"[ncr53c9x_msgout(priq:%x, prevphase:%x)]\",\n\t    sc->sc_msgpriq, sc->sc_prevphase));\n\n\t/*\n\t * XXX - the NCR_ATN flag is not in sync with the actual ATN\n\t *\t condition on the SCSI bus. The 53c9x chip\n\t *\t automatically turns off ATN before sending the\n\t *\t message byte.  (see also the comment below in the\n\t *\t default case when picking out a message to send)\n\t */\n\tif (sc->sc_flags & NCR_ATN) {\n\t\tif (sc->sc_prevphase != MESSAGE_OUT_PHASE) {\n\t\tnew:\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t\tsc->sc_msgoutq = 0;\n\t\t\tsc->sc_omlen = 0;\n\t\t}\n\t} else {\n\t\tif (sc->sc_prevphase == MESSAGE_OUT_PHASE) {\n\t\t\tncr53c9x_sched_msgout(sc->sc_msgoutq);\n\t\t\tgoto new;\n\t\t} else {\n\t\t\tprintf(\"%s at line %d: unexpected MESSAGE OUT phase\\n\",\n\t\t\t    sc->sc_dev.dv_xname, __LINE__);\n\t\t}\n\t}\n\t\t\t\n\tif (sc->sc_omlen == 0) {\n\t\t/* Pick up highest priority message */\n\t\tsc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;\n\t\tsc->sc_msgoutq |= sc->sc_msgout;\n\t\tsc->sc_msgpriq &= ~sc->sc_msgout;\n\t\tsc->sc_omlen = 1;\t\t/* \"Default\" message len */\n\t\tswitch (sc->sc_msgout) {\n\t\tcase SEND_SDTR:\n\t\t\tecb = sc->sc_nexus;\n\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\tsc->sc_omess[0] = MSG_EXTENDED;\n\t\t\tsc->sc_omess[1] = 3;\n\t\t\tsc->sc_omess[2] = MSG_EXT_SDTR;\n\t\t\tsc->sc_omess[3] = ti->period;\n\t\t\tsc->sc_omess[4] = ti->offset;\n\t\t\tsc->sc_omlen = 5;\n\t\t\tif ((sc->sc_flags & NCR_SYNCHNEGO) == 0) {\n\t\t\t\tti->flags |= T_SYNCMODE;\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEND_IDENTIFY:\n\t\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t\tprintf(\"%s at line %d: no nexus\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, __LINE__);\n\t\t\t}\n\t\t\tecb = sc->sc_nexus;\n\t\t\tsc->sc_omess[0] =\n\t\t\t    MSG_IDENTIFY(ecb->xs->sc_link->lun, 0);\n\t\t\tbreak;\n\t\tcase SEND_DEV_RESET:\n\t\t\tsc->sc_flags |= NCR_ABORTING;\n\t\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\t\tecb = sc->sc_nexus;\n\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\tti->flags |= T_NEGOTIATE;\n\t\t\tbreak;\n\t\tcase SEND_PARITY_ERROR:\n\t\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\t\tbreak;\n\t\tcase SEND_ABORT:\n\t\t\tsc->sc_flags |= NCR_ABORTING;\n\t\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\t\tbreak;\n\t\tcase SEND_INIT_DET_ERR:\n\t\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\t\tbreak;\n\t\tcase SEND_REJECT:\n\t\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * We normally do not get here, since the chip\n\t\t\t * automatically turns off ATN before the last\n\t\t\t * byte of a message is sent to the target.\n\t\t\t * However, if the target rejects our (multi-byte)\n\t\t\t * message early by switching to MSG IN phase\n\t\t\t * ATN remains on, so the target may return to\n\t\t\t * MSG OUT phase. If there are no scheduled messages\n\t\t\t * left we send a NO-OP.\n\t\t\t *\n\t\t\t * XXX - Note that this leaves no useful purpose for\n\t\t\t * the NCR_ATN flag.\n\t\t\t */\n\t\t\tsc->sc_flags &= ~NCR_ATN;\n\t\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\t\tbreak;\n\t\t}\n\t\tsc->sc_omp = sc->sc_omess;\n\t}\n\n\t/* (re)send the message */\n\tsize = min(sc->sc_omlen, sc->sc_maxxfer);\n\tNCRDMA_SETUP(sc, &sc->sc_omp, &sc->sc_omlen, 0, &size);\n\t/* Program the SCSI counter */\n\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t}\n\t/* Load the count in and start the message-out transfer */\n\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\tNCRCMD(sc, NCRCMD_TRANS|NCRCMD_DMA);\n\tNCRDMA_GO(sc);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tncr53c9x_msgout",
      "static inline void ncr53c9x_setsync",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCRDMA_GO",
          "args": [
            "sc"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_TRANS|NCRCMD_DMA"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_NOP|NCRCMD_DMA"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCH",
            "size >> 16"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCM",
            "size >> 8"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCL",
            "size"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_SETUP",
          "args": [
            "sc",
            "&sc->sc_omp",
            "&sc->sc_omlen",
            "0",
            "&size"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "sc->sc_omlen",
            "sc->sc_maxxfer"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSG_IDENTIFY",
          "args": [
            "ecb->xs->sc_link->lun",
            "0"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s at line %d: no nexus\\n\"",
            "sc->sc_dev.dv_xname",
            "__LINE__"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_setsync",
          "args": [
            "sc",
            "ti"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_setsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "415-443",
          "snippet": "static inline void\nncr53c9x_setsync(sc, ti)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_tinfo *ti;\n{\n\tu_char syncoff, synctp, cfg3 = sc->sc_cfg3;\n\n\tif (ti->flags & T_SYNCMODE) {\n\t\tsyncoff = ti->offset;\n\t\tsynctp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\tif (sc->sc_features & NCR_F_FASTSCSI) {\n\t\t\t/*\n\t\t\t * If the period is 200ns or less (ti->period <= 50),\n\t\t\t * put the chip in Fast SCSI mode.\n\t\t\t */\n\t\t\tif (ti->period <= 50)\n\t\t\t\tcfg3 |= NCRCFG3_FSCSI;\n\t\t}\n\t} else {\n\t\tsyncoff = 0;\n\t\tsynctp = 0;\n\t}\n\n\tif (sc->sc_features & NCR_F_HASCFG3)\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, cfg3);\n\n\tNCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);\n\tNCR_WRITE_REG(sc, NCR_SYNCTP, synctp);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline int ncr53c9x_stp2cpb",
            "static inline void ncr53c9x_setsync",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline int ncr53c9x_stp2cpb;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nstatic inline void\nncr53c9x_setsync(sc, ti)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_tinfo *ti;\n{\n\tu_char syncoff, synctp, cfg3 = sc->sc_cfg3;\n\n\tif (ti->flags & T_SYNCMODE) {\n\t\tsyncoff = ti->offset;\n\t\tsynctp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\tif (sc->sc_features & NCR_F_FASTSCSI) {\n\t\t\t/*\n\t\t\t * If the period is 200ns or less (ti->period <= 50),\n\t\t\t * put the chip in Fast SCSI mode.\n\t\t\t */\n\t\t\tif (ti->period <= 50)\n\t\t\t\tcfg3 |= NCRCFG3_FSCSI;\n\t\t}\n\t} else {\n\t\tsyncoff = 0;\n\t\tsynctp = 0;\n\t}\n\n\tif (sc->sc_features & NCR_F_HASCFG3)\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, cfg3);\n\n\tNCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);\n\tNCR_WRITE_REG(sc, NCR_SYNCTP, synctp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "sc->sc_msgoutq"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_FLUSH"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "(\"[ncr53c9x_msgout(priq:%x, prevphase:%x)]\",\n\t    sc->sc_msgpriq, sc->sc_prevphase)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_msgout;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_msgout(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_tinfo *ti;\n\tstruct ncr53c9x_ecb *ecb;\n\tsize_t size;\n\n\tNCR_TRACE((\"[ncr53c9x_msgout(priq:%x, prevphase:%x)]\",\n\t    sc->sc_msgpriq, sc->sc_prevphase));\n\n\t/*\n\t * XXX - the NCR_ATN flag is not in sync with the actual ATN\n\t *\t condition on the SCSI bus. The 53c9x chip\n\t *\t automatically turns off ATN before sending the\n\t *\t message byte.  (see also the comment below in the\n\t *\t default case when picking out a message to send)\n\t */\n\tif (sc->sc_flags & NCR_ATN) {\n\t\tif (sc->sc_prevphase != MESSAGE_OUT_PHASE) {\n\t\tnew:\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t\tsc->sc_msgoutq = 0;\n\t\t\tsc->sc_omlen = 0;\n\t\t}\n\t} else {\n\t\tif (sc->sc_prevphase == MESSAGE_OUT_PHASE) {\n\t\t\tncr53c9x_sched_msgout(sc->sc_msgoutq);\n\t\t\tgoto new;\n\t\t} else {\n\t\t\tprintf(\"%s at line %d: unexpected MESSAGE OUT phase\\n\",\n\t\t\t    sc->sc_dev.dv_xname, __LINE__);\n\t\t}\n\t}\n\t\t\t\n\tif (sc->sc_omlen == 0) {\n\t\t/* Pick up highest priority message */\n\t\tsc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;\n\t\tsc->sc_msgoutq |= sc->sc_msgout;\n\t\tsc->sc_msgpriq &= ~sc->sc_msgout;\n\t\tsc->sc_omlen = 1;\t\t/* \"Default\" message len */\n\t\tswitch (sc->sc_msgout) {\n\t\tcase SEND_SDTR:\n\t\t\tecb = sc->sc_nexus;\n\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\tsc->sc_omess[0] = MSG_EXTENDED;\n\t\t\tsc->sc_omess[1] = 3;\n\t\t\tsc->sc_omess[2] = MSG_EXT_SDTR;\n\t\t\tsc->sc_omess[3] = ti->period;\n\t\t\tsc->sc_omess[4] = ti->offset;\n\t\t\tsc->sc_omlen = 5;\n\t\t\tif ((sc->sc_flags & NCR_SYNCHNEGO) == 0) {\n\t\t\t\tti->flags |= T_SYNCMODE;\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEND_IDENTIFY:\n\t\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t\tprintf(\"%s at line %d: no nexus\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, __LINE__);\n\t\t\t}\n\t\t\tecb = sc->sc_nexus;\n\t\t\tsc->sc_omess[0] =\n\t\t\t    MSG_IDENTIFY(ecb->xs->sc_link->lun, 0);\n\t\t\tbreak;\n\t\tcase SEND_DEV_RESET:\n\t\t\tsc->sc_flags |= NCR_ABORTING;\n\t\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\t\tecb = sc->sc_nexus;\n\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\tti->flags |= T_NEGOTIATE;\n\t\t\tbreak;\n\t\tcase SEND_PARITY_ERROR:\n\t\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\t\tbreak;\n\t\tcase SEND_ABORT:\n\t\t\tsc->sc_flags |= NCR_ABORTING;\n\t\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\t\tbreak;\n\t\tcase SEND_INIT_DET_ERR:\n\t\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\t\tbreak;\n\t\tcase SEND_REJECT:\n\t\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * We normally do not get here, since the chip\n\t\t\t * automatically turns off ATN before the last\n\t\t\t * byte of a message is sent to the target.\n\t\t\t * However, if the target rejects our (multi-byte)\n\t\t\t * message early by switching to MSG IN phase\n\t\t\t * ATN remains on, so the target may return to\n\t\t\t * MSG OUT phase. If there are no scheduled messages\n\t\t\t * left we send a NO-OP.\n\t\t\t *\n\t\t\t * XXX - Note that this leaves no useful purpose for\n\t\t\t * the NCR_ATN flag.\n\t\t\t */\n\t\t\tsc->sc_flags &= ~NCR_ATN;\n\t\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\t\tbreak;\n\t\t}\n\t\tsc->sc_omp = sc->sc_omess;\n\t}\n\n\t/* (re)send the message */\n\tsize = min(sc->sc_omlen, sc->sc_maxxfer);\n\tNCRDMA_SETUP(sc, &sc->sc_omp, &sc->sc_omlen, 0, &size);\n\t/* Program the SCSI counter */\n\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t}\n\t/* Load the count in and start the message-out transfer */\n\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\tNCRCMD(sc, NCRCMD_TRANS|NCRCMD_DMA);\n\tNCRDMA_GO(sc);\n}"
  },
  {
    "function_name": "ncr53c9x_msgin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "943-1206",
    "snippet": "void\nncr53c9x_msgin(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tregister int v;\n\n\tNCR_TRACE((\"[ncr53c9x_msgin(curmsglen:%ld)] \", (long)sc->sc_imlen));\n\n\tif ((NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) == 0) {\n\t\tprintf(\"%s: msgin: no msg byte available\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * Prepare for a new message.  A message should (according\n\t * to the SCSI standard) be transmitted in one single\n\t * MESSAGE_IN_PHASE. If we have been in some other phase,\n\t * then this is a new message.\n\t */\n\tif (sc->sc_prevphase != MESSAGE_IN_PHASE) {\n\t\tsc->sc_flags &= ~NCR_DROP_MSGI;\n\t\tsc->sc_imlen = 0;\n\t}\n\n\tv = NCR_READ_REG(sc, NCR_FIFO);\n\tNCR_MISC((\"<msgbyte:0x%02x>\", v));\n\n#if 0\n\tif (sc->sc_state == NCR_RESELECTED && sc->sc_imlen == 0) {\n\t\t/*\n\t\t * Which target is reselecting us? (The ID bit really)\n\t\t */\n\t\tsc->sc_selid = v;\n\t\tNCR_MISC((\"selid=0x%2x \", sc->sc_selid));\n\t\treturn;\n\t}\n#endif\n\n\tsc->sc_imess[sc->sc_imlen] = v;\n\n\t/*\n\t * If we're going to reject the message, don't bother storing\n\t * the incoming bytes.  But still, we need to ACK them.\n\t */\n\n\tif ((sc->sc_flags & NCR_DROP_MSGI)) {\n\t\tNCRCMD(sc, NCRCMD_MSGOK);\n\t\tprintf(\"<dropping msg byte %x>\",\n\t\t\tsc->sc_imess[sc->sc_imlen]);\n\t\treturn;\n\t}\n\n\tif (sc->sc_imlen >= NCR_MAX_MSG_LEN) {\n\t\tncr53c9x_sched_msgout(SEND_REJECT);\n\t\tsc->sc_flags |= NCR_DROP_MSGI;\n\t} else {\n\t\tsc->sc_imlen++;\n\t\t/*\n\t\t * This testing is suboptimal, but most\n\t\t * messages will be of the one byte variety, so\n\t\t * it should not effect performance\n\t\t * significantly.\n\t\t */\n\t\tif (sc->sc_imlen == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\tgoto gotit;\n\t\tif (sc->sc_imlen == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\tgoto gotit;\n\t\tif (sc->sc_imlen >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t    sc->sc_imlen == sc->sc_imess[1] + 2)\n\t\t\tgoto gotit;\n\t}\n\t/* Ack what we have so far */\n\tNCRCMD(sc, NCRCMD_MSGOK);\n\treturn;\n\ngotit:\n\tNCR_MSGS((\"gotmsg(%x)\", sc->sc_imess[0]));\n\t/*\n\t * Now we should have a complete message (1 byte, 2 byte\n\t * and moderately long extended messages).  We only handle\n\t * extended messages which total length is shorter than\n\t * NCR_MAX_MSG_LEN.  Longer messages will be amputated.\n\t */\n\tswitch (sc->sc_state) {\n\t\tstruct ncr53c9x_ecb *ecb;\n\t\tstruct ncr53c9x_tinfo *ti;\n\n\tcase NCR_CONNECTED:\n\t\tecb = sc->sc_nexus;\n\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\n\t\tswitch (sc->sc_imess[0]) {\n\t\tcase MSG_CMDCOMPLETE:\n\t\t\tNCR_MSGS((\"cmdcomplete \"));\n\t\t\tif (sc->sc_dleft < 0) {\n\t\t\t\tstruct scsi_link *sc_link = ecb->xs->sc_link;\n\t\t\t\tprintf(\"%s: %ld extra bytes from %d:%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, -(long)sc->sc_dleft,\n\t\t\t\t    sc_link->target, sc_link->lun);\n\t\t\t\tsc->sc_dleft = 0;\n\t\t\t}\n\t\t\tecb->dleft = (ecb->flags & ECB_TENTATIVE_DONE)\n\t\t\t\t? 0\n\t\t\t\t: sc->sc_dleft;\n\t\t\tif ((ecb->flags & ECB_SENSE) == 0)\n\t\t\t\tecb->xs->resid = ecb->dleft;\n\t\t\tsc->sc_state = NCR_CMDCOMPLETE;\n\t\t\tbreak;\n\n\t\tcase MSG_MESSAGE_REJECT:\n\t\t\tNCR_MSGS((\"msg reject (msgout=%x) \", sc->sc_msgout));\n\t\t\tswitch (sc->sc_msgout) {\n\t\t\tcase SEND_SDTR:\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t\tbreak;\n\t\t\tcase SEND_INIT_DET_ERR:\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MSG_NOOP:\n\t\t\tNCR_MSGS((\"noop \"));\n\t\t\tbreak;\n\n\t\tcase MSG_DISCONNECT:\n\t\t\tNCR_MSGS((\"disconnect \"));\n\t\t\tti->dconns++;\n\t\t\tsc->sc_state = NCR_DISCONNECT;\n\n\t\t\t/*\n\t\t\t * Mark the fact that all bytes have moved. The\n\t\t\t * target may not bother to do a SAVE POINTERS\n\t\t\t * at this stage. This flag will set the residual\n\t\t\t * count to zero on MSG COMPLETE.\n\t\t\t */\n\t\t\tif (sc->sc_dleft == 0)\n\t\t\t\tecb->flags |= ECB_TENTATIVE_DONE;\n\n\t\t\tbreak;\n\n\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tNCR_MSGS((\"save datapointer \"));\n\t\t\tecb->daddr = sc->sc_dp;\n\t\t\tecb->dleft = sc->sc_dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_RESTOREPOINTERS:\n\t\t\tNCR_MSGS((\"restore datapointer \"));\n\t\t\tsc->sc_dp = ecb->daddr;\n\t\t\tsc->sc_dleft = ecb->dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_EXTENDED:\n\t\t\tNCR_MSGS((\"extended(%x) \", sc->sc_imess[2]));\n\t\t\tswitch (sc->sc_imess[2]) {\n\t\t\tcase MSG_EXT_SDTR:\n\t\t\t\tNCR_MSGS((\"SDTR period %d, offset %d \",\n\t\t\t\t\tsc->sc_imess[3], sc->sc_imess[4]));\n\t\t\t\tif (sc->sc_imess[1] != 3)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->period = sc->sc_imess[3];\n\t\t\t\tti->offset = sc->sc_imess[4];\n\t\t\t\tti->flags &= ~T_NEGOTIATE;\n\t\t\t\tif (sc->sc_minsync == 0 ||\n\t\t\t\t    ti->offset == 0 ||\n\t\t\t\t    ti->period > 124) {\n\t\t\t\t\tprintf(\"%s:%d: async\\n\", \"esp\",\n\t\t\t\t\t\tecb->xs->sc_link->target);\n\t\t\t\t\tif ((sc->sc_flags&NCR_SYNCHNEGO)\n\t\t\t\t\t    == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * target initiated negotiation\n\t\t\t\t\t\t */\n\t\t\t\t\t\tti->offset = 0;\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t\tncr53c9x_sched_msgout(\n\t\t\t\t\t\t    SEND_SDTR);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* we are async */\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint r = 250/ti->period;\n\t\t\t\t\tint s = (100*250)/ti->period - 100*r;\n\t\t\t\t\tint p;\n\n\t\t\t\t\tp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\t\t\t\tti->period = ncr53c9x_cpb2stp(sc, p);\n#ifdef NCR53C9X_DEBUG\n\t\t\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\t\t\tprintf(\"max sync rate %d.%02dMb/s\\n\",\n\t\t\t\t\t\tr, s);\n#endif\n\t\t\t\t\tif ((sc->sc_flags&NCR_SYNCHNEGO) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * target initiated negotiation\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (ti->period <\n\t\t\t\t\t\t    sc->sc_minsync)\n\t\t\t\t\t\t\tti->period =\n\t\t\t\t\t\t\t    sc->sc_minsync;\n\t\t\t\t\t\tif (ti->offset > 15)\n\t\t\t\t\t\t\tti->offset = 15;\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t\tncr53c9x_sched_msgout(\n\t\t\t\t\t\t    SEND_SDTR);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* we are sync */\n\t\t\t\t\t\tti->flags |= T_SYNCMODE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED;\"\n\t\t\t\t    \" sending REJECT\\n\", sc->sc_dev.dv_xname);\n\t\t\t\tgoto reject;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tNCR_MSGS((\"ident \"));\n\t\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\treject:\n\t\t\tncr53c9x_sched_msgout(SEND_REJECT);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase NCR_RESELECTED:\n\t\tif (!MSG_ISIDENTIFY(sc->sc_imess[0])) {\n\t\t\tprintf(\"%s: reselect without IDENTIFY;\"\n\t\t\t    \" sending DEVICE RESET\\n\", sc->sc_dev.dv_xname);\n\t\t\tgoto reset;\n\t\t}\n\n\t\t(void) ncr53c9x_reselect(sc, sc->sc_imess[0]);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE IN; sending DEVICE RESET\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\treset:\n\t\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\t\tbreak;\n\n\tabort:\n\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\t\tbreak;\n\t}\n\n\t/* Ack last message byte */\n\tNCRCMD(sc, NCRCMD_MSGOK);\n\n\t/* Done, reset message pointer. */\n\tsc->sc_flags &= ~NCR_DROP_MSGI;\n\tsc->sc_imlen = 0;\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ncr53c9x_reselect",
      "void\tncr53c9x_msgin",
      "static inline int ncr53c9x_stp2cpb",
      "static inline void ncr53c9x_setsync",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_MSGOK"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_ABORT"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_DEV_RESET"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unexpected MESSAGE IN; sending DEVICE RESET\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_reselect",
          "args": [
            "sc",
            "sc->sc_imess[0]"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_reselect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "856-931",
          "snippet": "int\nncr53c9x_reselect(sc, message)\n\tstruct ncr53c9x_softc *sc;\n\tint message;\n{\n\tu_char selid, target, lun;\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\t/*\n\t * The SCSI chip made a snapshot of the data bus while the reselection\n\t * was being negotiated.  This enables us to determine which target did\n\t * the reselect.\n\t */\n\tselid = sc->sc_selid & ~(1 << sc->sc_id);\n\tif (selid & (selid - 1)) {\n\t\tprintf(\"%s: reselect with invalid selid %02x;\"\n\t\t    \" sending DEVICE RESET\\n\", sc->sc_dev.dv_xname, selid);\n\t\tgoto reset;\n\t}\n\n\t/*\n\t * Search wait queue for disconnected cmd\n\t * The list should be short, so I haven't bothered with\n\t * any more sophisticated structures than a simple\n\t * singly linked list.\n\t */\n\ttarget = ffs(selid) - 1;\n\tlun = message & 0x07;\n\tfor (ecb = sc->nexus_list.tqh_first; ecb != NULL;\n\t     ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tif (sc_link->target == target &&\n\t\t    sc_link->lun == lun)\n\t\t\tbreak;\n\t}\n\tif (ecb == NULL) {\n\t\tprintf(\"%s: reselect from target %d lun %d with no nexus;\"\n\t\t    \" sending ABORT\\n\", sc->sc_dev.dv_xname, target, lun);\n\t\tgoto abort;\n\t}\n\n\t/* Make this nexus active again. */\n\tTAILQ_REMOVE(&sc->nexus_list, ecb, chain);\n\tsc->sc_state = NCR_CONNECTED;\n\tsc->sc_nexus = ecb;\n\tti = &sc->sc_tinfo[target];\n#ifdef NCR53C9X_DEBUG\n\tif ((ti->lubusy & (1 << lun)) == 0) {\n\t\tprintf(\"%s: reselect: target %d, lun %d: should be busy\\n\",\n\t\t\tsc->sc_dev.dv_xname, target, lun);\n\t\tti->lubusy |= (1 << lun);\n\t}\n#endif\n\tncr53c9x_setsync(sc, ti);\n\n\tif (ecb->flags & ECB_RESET)\n\t\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\telse if (ecb->flags & ECB_ABORT)\n\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\n\t/* Do an implicit RESTORE POINTERS. */\n\tsc->sc_dp = ecb->daddr;\n\tsc->sc_dleft = ecb->dleft;\n\n\treturn (0);\n\nreset:\n\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\treturn (1);\n\nabort:\n\tncr53c9x_sched_msgout(SEND_ABORT);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr53c9x_reselect",
            "static inline void ncr53c9x_setsync",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr53c9x_reselect;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nint\nncr53c9x_reselect(sc, message)\n\tstruct ncr53c9x_softc *sc;\n\tint message;\n{\n\tu_char selid, target, lun;\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\t/*\n\t * The SCSI chip made a snapshot of the data bus while the reselection\n\t * was being negotiated.  This enables us to determine which target did\n\t * the reselect.\n\t */\n\tselid = sc->sc_selid & ~(1 << sc->sc_id);\n\tif (selid & (selid - 1)) {\n\t\tprintf(\"%s: reselect with invalid selid %02x;\"\n\t\t    \" sending DEVICE RESET\\n\", sc->sc_dev.dv_xname, selid);\n\t\tgoto reset;\n\t}\n\n\t/*\n\t * Search wait queue for disconnected cmd\n\t * The list should be short, so I haven't bothered with\n\t * any more sophisticated structures than a simple\n\t * singly linked list.\n\t */\n\ttarget = ffs(selid) - 1;\n\tlun = message & 0x07;\n\tfor (ecb = sc->nexus_list.tqh_first; ecb != NULL;\n\t     ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tif (sc_link->target == target &&\n\t\t    sc_link->lun == lun)\n\t\t\tbreak;\n\t}\n\tif (ecb == NULL) {\n\t\tprintf(\"%s: reselect from target %d lun %d with no nexus;\"\n\t\t    \" sending ABORT\\n\", sc->sc_dev.dv_xname, target, lun);\n\t\tgoto abort;\n\t}\n\n\t/* Make this nexus active again. */\n\tTAILQ_REMOVE(&sc->nexus_list, ecb, chain);\n\tsc->sc_state = NCR_CONNECTED;\n\tsc->sc_nexus = ecb;\n\tti = &sc->sc_tinfo[target];\n#ifdef NCR53C9X_DEBUG\n\tif ((ti->lubusy & (1 << lun)) == 0) {\n\t\tprintf(\"%s: reselect: target %d, lun %d: should be busy\\n\",\n\t\t\tsc->sc_dev.dv_xname, target, lun);\n\t\tti->lubusy |= (1 << lun);\n\t}\n#endif\n\tncr53c9x_setsync(sc, ti);\n\n\tif (ecb->flags & ECB_RESET)\n\t\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\telse if (ecb->flags & ECB_ABORT)\n\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\n\t/* Do an implicit RESTORE POINTERS. */\n\tsc->sc_dp = ecb->daddr;\n\tsc->sc_dleft = ecb->dleft;\n\n\treturn (0);\n\nreset:\n\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\treturn (1);\n\nabort:\n\tncr53c9x_sched_msgout(SEND_ABORT);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSG_ISIDENTIFY",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_REJECT"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MSGS",
          "args": [
            "(\"ident \")"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_setsync",
          "args": [
            "sc",
            "ti"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_setsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "415-443",
          "snippet": "static inline void\nncr53c9x_setsync(sc, ti)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_tinfo *ti;\n{\n\tu_char syncoff, synctp, cfg3 = sc->sc_cfg3;\n\n\tif (ti->flags & T_SYNCMODE) {\n\t\tsyncoff = ti->offset;\n\t\tsynctp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\tif (sc->sc_features & NCR_F_FASTSCSI) {\n\t\t\t/*\n\t\t\t * If the period is 200ns or less (ti->period <= 50),\n\t\t\t * put the chip in Fast SCSI mode.\n\t\t\t */\n\t\t\tif (ti->period <= 50)\n\t\t\t\tcfg3 |= NCRCFG3_FSCSI;\n\t\t}\n\t} else {\n\t\tsyncoff = 0;\n\t\tsynctp = 0;\n\t}\n\n\tif (sc->sc_features & NCR_F_HASCFG3)\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, cfg3);\n\n\tNCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);\n\tNCR_WRITE_REG(sc, NCR_SYNCTP, synctp);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline int ncr53c9x_stp2cpb",
            "static inline void ncr53c9x_setsync",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline int ncr53c9x_stp2cpb;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nstatic inline void\nncr53c9x_setsync(sc, ti)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_tinfo *ti;\n{\n\tu_char syncoff, synctp, cfg3 = sc->sc_cfg3;\n\n\tif (ti->flags & T_SYNCMODE) {\n\t\tsyncoff = ti->offset;\n\t\tsynctp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\tif (sc->sc_features & NCR_F_FASTSCSI) {\n\t\t\t/*\n\t\t\t * If the period is 200ns or less (ti->period <= 50),\n\t\t\t * put the chip in Fast SCSI mode.\n\t\t\t */\n\t\t\tif (ti->period <= 50)\n\t\t\t\tcfg3 |= NCRCFG3_FSCSI;\n\t\t}\n\t} else {\n\t\tsyncoff = 0;\n\t\tsynctp = 0;\n\t}\n\n\tif (sc->sc_features & NCR_F_HASCFG3)\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, cfg3);\n\n\tNCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);\n\tNCR_WRITE_REG(sc, NCR_SYNCTP, synctp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_SDTR"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc_print_addr",
          "args": [
            "ecb->xs->sc_link"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_cpb2stp",
          "args": [
            "sc",
            "p"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_stp2cpb",
          "args": [
            "sc",
            "ti->period"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_stp2cpb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "402-413",
          "snippet": "static inline int\nncr53c9x_stp2cpb(sc, period)\n\tstruct ncr53c9x_softc *sc;\n\tint period;\n{\n\tint v;\n\tv = (sc->sc_freq * period) / 250;\n\tif (ncr53c9x_cpb2stp(sc, v) < period)\n\t\t/* Correct round-down error */\n\t\tv++;\n\treturn (v);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline int ncr53c9x_stp2cpb",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline int ncr53c9x_stp2cpb;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nstatic inline int\nncr53c9x_stp2cpb(sc, period)\n\tstruct ncr53c9x_softc *sc;\n\tint period;\n{\n\tint v;\n\tv = (sc->sc_freq * period) / 250;\n\tif (ncr53c9x_cpb2stp(sc, v) < period)\n\t\t/* Correct round-down error */\n\t\tv++;\n\treturn (v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_SDTR"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MSGS",
          "args": [
            "(\"SDTR period %d, offset %d \",\n\t\t\t\t\tsc->sc_imess[3], sc->sc_imess[4])"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MSGS",
          "args": [
            "(\"extended(%x) \", sc->sc_imess[2])"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MSGS",
          "args": [
            "(\"restore datapointer \")"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MSGS",
          "args": [
            "(\"save datapointer \")"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MSGS",
          "args": [
            "(\"disconnect \")"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MSGS",
          "args": [
            "(\"noop \")"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MSGS",
          "args": [
            "(\"msg reject (msgout=%x) \", sc->sc_msgout)"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MSGS",
          "args": [
            "(\"cmdcomplete \")"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MSGS",
          "args": [
            "(\"gotmsg(%x)\", sc->sc_imess[0])"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_MSGOK"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISEXTMSG",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS2BYTEMSG",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS1BYTEMSG",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_REJECT"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_MSGOK"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MISC",
          "args": [
            "(\"selid=0x%2x \", sc->sc_selid)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MISC",
          "args": [
            "(\"<msgbyte:0x%02x>\", v)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FIFO"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_FFLAG"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "(\"[ncr53c9x_msgin(curmsglen:%ld)] \", (long)sc->sc_imlen)"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr53c9x_reselect;\nvoid\tncr53c9x_msgin;\nstatic inline int ncr53c9x_stp2cpb;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_msgin(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tregister int v;\n\n\tNCR_TRACE((\"[ncr53c9x_msgin(curmsglen:%ld)] \", (long)sc->sc_imlen));\n\n\tif ((NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) == 0) {\n\t\tprintf(\"%s: msgin: no msg byte available\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * Prepare for a new message.  A message should (according\n\t * to the SCSI standard) be transmitted in one single\n\t * MESSAGE_IN_PHASE. If we have been in some other phase,\n\t * then this is a new message.\n\t */\n\tif (sc->sc_prevphase != MESSAGE_IN_PHASE) {\n\t\tsc->sc_flags &= ~NCR_DROP_MSGI;\n\t\tsc->sc_imlen = 0;\n\t}\n\n\tv = NCR_READ_REG(sc, NCR_FIFO);\n\tNCR_MISC((\"<msgbyte:0x%02x>\", v));\n\n#if 0\n\tif (sc->sc_state == NCR_RESELECTED && sc->sc_imlen == 0) {\n\t\t/*\n\t\t * Which target is reselecting us? (The ID bit really)\n\t\t */\n\t\tsc->sc_selid = v;\n\t\tNCR_MISC((\"selid=0x%2x \", sc->sc_selid));\n\t\treturn;\n\t}\n#endif\n\n\tsc->sc_imess[sc->sc_imlen] = v;\n\n\t/*\n\t * If we're going to reject the message, don't bother storing\n\t * the incoming bytes.  But still, we need to ACK them.\n\t */\n\n\tif ((sc->sc_flags & NCR_DROP_MSGI)) {\n\t\tNCRCMD(sc, NCRCMD_MSGOK);\n\t\tprintf(\"<dropping msg byte %x>\",\n\t\t\tsc->sc_imess[sc->sc_imlen]);\n\t\treturn;\n\t}\n\n\tif (sc->sc_imlen >= NCR_MAX_MSG_LEN) {\n\t\tncr53c9x_sched_msgout(SEND_REJECT);\n\t\tsc->sc_flags |= NCR_DROP_MSGI;\n\t} else {\n\t\tsc->sc_imlen++;\n\t\t/*\n\t\t * This testing is suboptimal, but most\n\t\t * messages will be of the one byte variety, so\n\t\t * it should not effect performance\n\t\t * significantly.\n\t\t */\n\t\tif (sc->sc_imlen == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\tgoto gotit;\n\t\tif (sc->sc_imlen == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\tgoto gotit;\n\t\tif (sc->sc_imlen >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t    sc->sc_imlen == sc->sc_imess[1] + 2)\n\t\t\tgoto gotit;\n\t}\n\t/* Ack what we have so far */\n\tNCRCMD(sc, NCRCMD_MSGOK);\n\treturn;\n\ngotit:\n\tNCR_MSGS((\"gotmsg(%x)\", sc->sc_imess[0]));\n\t/*\n\t * Now we should have a complete message (1 byte, 2 byte\n\t * and moderately long extended messages).  We only handle\n\t * extended messages which total length is shorter than\n\t * NCR_MAX_MSG_LEN.  Longer messages will be amputated.\n\t */\n\tswitch (sc->sc_state) {\n\t\tstruct ncr53c9x_ecb *ecb;\n\t\tstruct ncr53c9x_tinfo *ti;\n\n\tcase NCR_CONNECTED:\n\t\tecb = sc->sc_nexus;\n\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\n\t\tswitch (sc->sc_imess[0]) {\n\t\tcase MSG_CMDCOMPLETE:\n\t\t\tNCR_MSGS((\"cmdcomplete \"));\n\t\t\tif (sc->sc_dleft < 0) {\n\t\t\t\tstruct scsi_link *sc_link = ecb->xs->sc_link;\n\t\t\t\tprintf(\"%s: %ld extra bytes from %d:%d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, -(long)sc->sc_dleft,\n\t\t\t\t    sc_link->target, sc_link->lun);\n\t\t\t\tsc->sc_dleft = 0;\n\t\t\t}\n\t\t\tecb->dleft = (ecb->flags & ECB_TENTATIVE_DONE)\n\t\t\t\t? 0\n\t\t\t\t: sc->sc_dleft;\n\t\t\tif ((ecb->flags & ECB_SENSE) == 0)\n\t\t\t\tecb->xs->resid = ecb->dleft;\n\t\t\tsc->sc_state = NCR_CMDCOMPLETE;\n\t\t\tbreak;\n\n\t\tcase MSG_MESSAGE_REJECT:\n\t\t\tNCR_MSGS((\"msg reject (msgout=%x) \", sc->sc_msgout));\n\t\t\tswitch (sc->sc_msgout) {\n\t\t\tcase SEND_SDTR:\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t\tbreak;\n\t\t\tcase SEND_INIT_DET_ERR:\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MSG_NOOP:\n\t\t\tNCR_MSGS((\"noop \"));\n\t\t\tbreak;\n\n\t\tcase MSG_DISCONNECT:\n\t\t\tNCR_MSGS((\"disconnect \"));\n\t\t\tti->dconns++;\n\t\t\tsc->sc_state = NCR_DISCONNECT;\n\n\t\t\t/*\n\t\t\t * Mark the fact that all bytes have moved. The\n\t\t\t * target may not bother to do a SAVE POINTERS\n\t\t\t * at this stage. This flag will set the residual\n\t\t\t * count to zero on MSG COMPLETE.\n\t\t\t */\n\t\t\tif (sc->sc_dleft == 0)\n\t\t\t\tecb->flags |= ECB_TENTATIVE_DONE;\n\n\t\t\tbreak;\n\n\t\tcase MSG_SAVEDATAPOINTER:\n\t\t\tNCR_MSGS((\"save datapointer \"));\n\t\t\tecb->daddr = sc->sc_dp;\n\t\t\tecb->dleft = sc->sc_dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_RESTOREPOINTERS:\n\t\t\tNCR_MSGS((\"restore datapointer \"));\n\t\t\tsc->sc_dp = ecb->daddr;\n\t\t\tsc->sc_dleft = ecb->dleft;\n\t\t\tbreak;\n\n\t\tcase MSG_EXTENDED:\n\t\t\tNCR_MSGS((\"extended(%x) \", sc->sc_imess[2]));\n\t\t\tswitch (sc->sc_imess[2]) {\n\t\t\tcase MSG_EXT_SDTR:\n\t\t\t\tNCR_MSGS((\"SDTR period %d, offset %d \",\n\t\t\t\t\tsc->sc_imess[3], sc->sc_imess[4]));\n\t\t\t\tif (sc->sc_imess[1] != 3)\n\t\t\t\t\tgoto reject;\n\t\t\t\tti->period = sc->sc_imess[3];\n\t\t\t\tti->offset = sc->sc_imess[4];\n\t\t\t\tti->flags &= ~T_NEGOTIATE;\n\t\t\t\tif (sc->sc_minsync == 0 ||\n\t\t\t\t    ti->offset == 0 ||\n\t\t\t\t    ti->period > 124) {\n\t\t\t\t\tprintf(\"%s:%d: async\\n\", \"esp\",\n\t\t\t\t\t\tecb->xs->sc_link->target);\n\t\t\t\t\tif ((sc->sc_flags&NCR_SYNCHNEGO)\n\t\t\t\t\t    == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * target initiated negotiation\n\t\t\t\t\t\t */\n\t\t\t\t\t\tti->offset = 0;\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t\tncr53c9x_sched_msgout(\n\t\t\t\t\t\t    SEND_SDTR);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* we are async */\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint r = 250/ti->period;\n\t\t\t\t\tint s = (100*250)/ti->period - 100*r;\n\t\t\t\t\tint p;\n\n\t\t\t\t\tp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\t\t\t\tti->period = ncr53c9x_cpb2stp(sc, p);\n#ifdef NCR53C9X_DEBUG\n\t\t\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\t\t\tprintf(\"max sync rate %d.%02dMb/s\\n\",\n\t\t\t\t\t\tr, s);\n#endif\n\t\t\t\t\tif ((sc->sc_flags&NCR_SYNCHNEGO) == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * target initiated negotiation\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (ti->period <\n\t\t\t\t\t\t    sc->sc_minsync)\n\t\t\t\t\t\t\tti->period =\n\t\t\t\t\t\t\t    sc->sc_minsync;\n\t\t\t\t\t\tif (ti->offset > 15)\n\t\t\t\t\t\t\tti->offset = 15;\n\t\t\t\t\t\tti->flags &= ~T_SYNCMODE;\n\t\t\t\t\t\tncr53c9x_sched_msgout(\n\t\t\t\t\t\t    SEND_SDTR);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* we are sync */\n\t\t\t\t\t\tti->flags |= T_SYNCMODE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tncr53c9x_setsync(sc, ti);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED;\"\n\t\t\t\t    \" sending REJECT\\n\", sc->sc_dev.dv_xname);\n\t\t\t\tgoto reject;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tNCR_MSGS((\"ident \"));\n\t\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\treject:\n\t\t\tncr53c9x_sched_msgout(SEND_REJECT);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase NCR_RESELECTED:\n\t\tif (!MSG_ISIDENTIFY(sc->sc_imess[0])) {\n\t\t\tprintf(\"%s: reselect without IDENTIFY;\"\n\t\t\t    \" sending DEVICE RESET\\n\", sc->sc_dev.dv_xname);\n\t\t\tgoto reset;\n\t\t}\n\n\t\t(void) ncr53c9x_reselect(sc, sc->sc_imess[0]);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: unexpected MESSAGE IN; sending DEVICE RESET\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\treset:\n\t\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\t\tbreak;\n\n\tabort:\n\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\t\tbreak;\n\t}\n\n\t/* Ack last message byte */\n\tNCRCMD(sc, NCRCMD_MSGOK);\n\n\t/* Done, reset message pointer. */\n\tsc->sc_flags &= ~NCR_DROP_MSGI;\n\tsc->sc_imlen = 0;\n}"
  },
  {
    "function_name": "ncr53c9x_reselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "856-931",
    "snippet": "int\nncr53c9x_reselect(sc, message)\n\tstruct ncr53c9x_softc *sc;\n\tint message;\n{\n\tu_char selid, target, lun;\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\t/*\n\t * The SCSI chip made a snapshot of the data bus while the reselection\n\t * was being negotiated.  This enables us to determine which target did\n\t * the reselect.\n\t */\n\tselid = sc->sc_selid & ~(1 << sc->sc_id);\n\tif (selid & (selid - 1)) {\n\t\tprintf(\"%s: reselect with invalid selid %02x;\"\n\t\t    \" sending DEVICE RESET\\n\", sc->sc_dev.dv_xname, selid);\n\t\tgoto reset;\n\t}\n\n\t/*\n\t * Search wait queue for disconnected cmd\n\t * The list should be short, so I haven't bothered with\n\t * any more sophisticated structures than a simple\n\t * singly linked list.\n\t */\n\ttarget = ffs(selid) - 1;\n\tlun = message & 0x07;\n\tfor (ecb = sc->nexus_list.tqh_first; ecb != NULL;\n\t     ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tif (sc_link->target == target &&\n\t\t    sc_link->lun == lun)\n\t\t\tbreak;\n\t}\n\tif (ecb == NULL) {\n\t\tprintf(\"%s: reselect from target %d lun %d with no nexus;\"\n\t\t    \" sending ABORT\\n\", sc->sc_dev.dv_xname, target, lun);\n\t\tgoto abort;\n\t}\n\n\t/* Make this nexus active again. */\n\tTAILQ_REMOVE(&sc->nexus_list, ecb, chain);\n\tsc->sc_state = NCR_CONNECTED;\n\tsc->sc_nexus = ecb;\n\tti = &sc->sc_tinfo[target];\n#ifdef NCR53C9X_DEBUG\n\tif ((ti->lubusy & (1 << lun)) == 0) {\n\t\tprintf(\"%s: reselect: target %d, lun %d: should be busy\\n\",\n\t\t\tsc->sc_dev.dv_xname, target, lun);\n\t\tti->lubusy |= (1 << lun);\n\t}\n#endif\n\tncr53c9x_setsync(sc, ti);\n\n\tif (ecb->flags & ECB_RESET)\n\t\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\telse if (ecb->flags & ECB_ABORT)\n\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\n\t/* Do an implicit RESTORE POINTERS. */\n\tsc->sc_dp = ecb->daddr;\n\tsc->sc_dleft = ecb->dleft;\n\n\treturn (0);\n\nreset:\n\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\treturn (1);\n\nabort:\n\tncr53c9x_sched_msgout(SEND_ABORT);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ncr53c9x_reselect",
      "static inline void ncr53c9x_setsync",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_ABORT"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_DEV_RESET"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_ABORT"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched_msgout",
          "args": [
            "SEND_DEV_RESET"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_setsync",
          "args": [
            "sc",
            "ti"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_setsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "415-443",
          "snippet": "static inline void\nncr53c9x_setsync(sc, ti)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_tinfo *ti;\n{\n\tu_char syncoff, synctp, cfg3 = sc->sc_cfg3;\n\n\tif (ti->flags & T_SYNCMODE) {\n\t\tsyncoff = ti->offset;\n\t\tsynctp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\tif (sc->sc_features & NCR_F_FASTSCSI) {\n\t\t\t/*\n\t\t\t * If the period is 200ns or less (ti->period <= 50),\n\t\t\t * put the chip in Fast SCSI mode.\n\t\t\t */\n\t\t\tif (ti->period <= 50)\n\t\t\t\tcfg3 |= NCRCFG3_FSCSI;\n\t\t}\n\t} else {\n\t\tsyncoff = 0;\n\t\tsynctp = 0;\n\t}\n\n\tif (sc->sc_features & NCR_F_HASCFG3)\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, cfg3);\n\n\tNCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);\n\tNCR_WRITE_REG(sc, NCR_SYNCTP, synctp);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline int ncr53c9x_stp2cpb",
            "static inline void ncr53c9x_setsync",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline int ncr53c9x_stp2cpb;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nstatic inline void\nncr53c9x_setsync(sc, ti)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_tinfo *ti;\n{\n\tu_char syncoff, synctp, cfg3 = sc->sc_cfg3;\n\n\tif (ti->flags & T_SYNCMODE) {\n\t\tsyncoff = ti->offset;\n\t\tsynctp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\tif (sc->sc_features & NCR_F_FASTSCSI) {\n\t\t\t/*\n\t\t\t * If the period is 200ns or less (ti->period <= 50),\n\t\t\t * put the chip in Fast SCSI mode.\n\t\t\t */\n\t\t\tif (ti->period <= 50)\n\t\t\t\tcfg3 |= NCRCFG3_FSCSI;\n\t\t}\n\t} else {\n\t\tsyncoff = 0;\n\t\tsynctp = 0;\n\t}\n\n\tif (sc->sc_features & NCR_F_HASCFG3)\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, cfg3);\n\n\tNCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);\n\tNCR_WRITE_REG(sc, NCR_SYNCTP, synctp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reselect: target %d, lun %d: should be busy\\n\"",
            "sc->sc_dev.dv_xname",
            "target",
            "lun"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->nexus_list",
            "ecb",
            "chain"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "selid"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_validate_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1227-1248",
          "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr53c9x_reselect;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nint\nncr53c9x_reselect(sc, message)\n\tstruct ncr53c9x_softc *sc;\n\tint message;\n{\n\tu_char selid, target, lun;\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\t/*\n\t * The SCSI chip made a snapshot of the data bus while the reselection\n\t * was being negotiated.  This enables us to determine which target did\n\t * the reselect.\n\t */\n\tselid = sc->sc_selid & ~(1 << sc->sc_id);\n\tif (selid & (selid - 1)) {\n\t\tprintf(\"%s: reselect with invalid selid %02x;\"\n\t\t    \" sending DEVICE RESET\\n\", sc->sc_dev.dv_xname, selid);\n\t\tgoto reset;\n\t}\n\n\t/*\n\t * Search wait queue for disconnected cmd\n\t * The list should be short, so I haven't bothered with\n\t * any more sophisticated structures than a simple\n\t * singly linked list.\n\t */\n\ttarget = ffs(selid) - 1;\n\tlun = message & 0x07;\n\tfor (ecb = sc->nexus_list.tqh_first; ecb != NULL;\n\t     ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tif (sc_link->target == target &&\n\t\t    sc_link->lun == lun)\n\t\t\tbreak;\n\t}\n\tif (ecb == NULL) {\n\t\tprintf(\"%s: reselect from target %d lun %d with no nexus;\"\n\t\t    \" sending ABORT\\n\", sc->sc_dev.dv_xname, target, lun);\n\t\tgoto abort;\n\t}\n\n\t/* Make this nexus active again. */\n\tTAILQ_REMOVE(&sc->nexus_list, ecb, chain);\n\tsc->sc_state = NCR_CONNECTED;\n\tsc->sc_nexus = ecb;\n\tti = &sc->sc_tinfo[target];\n#ifdef NCR53C9X_DEBUG\n\tif ((ti->lubusy & (1 << lun)) == 0) {\n\t\tprintf(\"%s: reselect: target %d, lun %d: should be busy\\n\",\n\t\t\tsc->sc_dev.dv_xname, target, lun);\n\t\tti->lubusy |= (1 << lun);\n\t}\n#endif\n\tncr53c9x_setsync(sc, ti);\n\n\tif (ecb->flags & ECB_RESET)\n\t\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\telse if (ecb->flags & ECB_ABORT)\n\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\n\t/* Do an implicit RESTORE POINTERS. */\n\tsc->sc_dp = ecb->daddr;\n\tsc->sc_dleft = ecb->dleft;\n\n\treturn (0);\n\nreset:\n\tncr53c9x_sched_msgout(SEND_DEV_RESET);\n\treturn (1);\n\nabort:\n\tncr53c9x_sched_msgout(SEND_ABORT);\n\treturn (1);\n}"
  },
  {
    "function_name": "ncr53c9x_dequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "825-837",
    "snippet": "void\nncr53c9x_dequeue(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\n\tif (ecb->flags & ECB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, ecb, chain);\n\t\tecb->flags &= ~ECB_NEXUS;\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t}\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ncr53c9x_dequeue",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->ready_list",
            "ecb",
            "chain"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->nexus_list",
            "ecb",
            "chain"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid ncr53c9x_dequeue;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_dequeue(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\n\tif (ecb->flags & ECB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, ecb, chain);\n\t\tecb->flags &= ~ECB_NEXUS;\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t}\n}"
  },
  {
    "function_name": "ncr53c9x_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "756-823",
    "snippet": "void\nncr53c9x_done(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tNCR_TRACE((\"[ncr53c9x_done(error:%x)] \", xs->error));\n\n\tuntimeout(ncr53c9x_timeout, ecb);\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\txs->status = ecb->stat;\n\t\tif ((ecb->flags & ECB_ABORT) != 0) {\n\t\t\txs->error = XS_TIMEOUT;\n\t\t} else if ((ecb->flags & ECB_SENSE) != 0) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = ecb->dleft;\n\t\t\tncr53c9x_sense(sc, ecb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = ecb->dleft;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#ifdef NCR53C9X_DEBUG\n\tif (ncr53c9x_debug & NCR_SHOWMISC) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ECB from whatever queue it's on.\n\t */\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tif (sc->sc_state != NCR_CLEANING) {\n\t\t\tsc->sc_state = NCR_IDLE;\n\t\t\tncr53c9x_sched(sc);\n\t\t}\n\t} else\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\t\n\tncr53c9x_free_ecb(sc, ecb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ncr53c9x_debug = 0;",
      "void\tncr53c9x_sched",
      "void\tncr53c9x_done",
      "void\tncr53c9x_timeout",
      "void ncr53c9x_dequeue",
      "void ncr53c9x_sense",
      "void ncr53c9x_free_ecb",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_free_ecb",
          "args": [
            "sc",
            "ecb",
            "xs->flags"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_free_ecb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "538-559",
          "snippet": "void\nncr53c9x_free_ecb(sc, ecb, flags)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tecb->flags = 0;\n\tTAILQ_INSERT_HEAD(&sc->free_list, ecb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ecb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_list);\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void ncr53c9x_free_ecb",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid ncr53c9x_free_ecb;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_free_ecb(sc, ecb, flags)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tecb->flags = 0;\n\tTAILQ_INSERT_HEAD(&sc->free_list, ecb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ecb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_list);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_dequeue",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "825-837",
          "snippet": "void\nncr53c9x_dequeue(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\n\tif (ecb->flags & ECB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, ecb, chain);\n\t\tecb->flags &= ~ECB_NEXUS;\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void ncr53c9x_dequeue",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid ncr53c9x_dequeue;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_dequeue(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\n\tif (ecb->flags & ECB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, ecb, chain);\n\t\tecb->flags &= ~ECB_NEXUS;\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched",
          "args": [
            "sc"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "687-716",
          "snippet": "void\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_sched",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"error=%d\\n\"",
            "xs->error"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sense",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_sense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "718-751",
          "snippet": "void\nncr53c9x_sense(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&ecb->cmd.cmd;\n\n\tNCR_MISC((\"requesting sense \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tecb->clen = sizeof(*ss);\n\tecb->daddr = (char *)&xs->sense;\n\tecb->dleft = sizeof(struct scsi_sense_data);\n\tecb->flags |= ECB_SENSE;\n\tecb->timeout = NCR_SENSE_TIMEOUT;\n\tti->senses++;\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tecb->flags &= ~ECB_NEXUS;\n\t\tncr53c9x_select(sc, ecb);\n\t} else {\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);\n\t\tif (sc->sc_state == NCR_IDLE)\n\t\t\tncr53c9x_sched(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_sched",
            "void ncr53c9x_dequeue",
            "void ncr53c9x_sense",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nvoid ncr53c9x_dequeue;\nvoid ncr53c9x_sense;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_sense(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&ecb->cmd.cmd;\n\n\tNCR_MISC((\"requesting sense \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tecb->clen = sizeof(*ss);\n\tecb->daddr = (char *)&xs->sense;\n\tecb->dleft = sizeof(struct scsi_sense_data);\n\tecb->flags |= ECB_SENSE;\n\tecb->timeout = NCR_SENSE_TIMEOUT;\n\tti->senses++;\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tecb->flags &= ~ECB_NEXUS;\n\t\tncr53c9x_select(sc, ecb);\n\t} else {\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);\n\t\tif (sc->sc_state == NCR_IDLE)\n\t\t\tncr53c9x_sched(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ncr53c9x_timeout",
            "ecb"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "(\"[ncr53c9x_done(error:%x)] \", xs->error)"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr53c9x_debug = 0;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_done;\nvoid\tncr53c9x_timeout;\nvoid ncr53c9x_dequeue;\nvoid ncr53c9x_sense;\nvoid ncr53c9x_free_ecb;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_done(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tNCR_TRACE((\"[ncr53c9x_done(error:%x)] \", xs->error));\n\n\tuntimeout(ncr53c9x_timeout, ecb);\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\txs->status = ecb->stat;\n\t\tif ((ecb->flags & ECB_ABORT) != 0) {\n\t\t\txs->error = XS_TIMEOUT;\n\t\t} else if ((ecb->flags & ECB_SENSE) != 0) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = ecb->dleft;\n\t\t\tncr53c9x_sense(sc, ecb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = ecb->dleft;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#ifdef NCR53C9X_DEBUG\n\tif (ncr53c9x_debug & NCR_SHOWMISC) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ECB from whatever queue it's on.\n\t */\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tif (sc->sc_state != NCR_CLEANING) {\n\t\t\tsc->sc_state = NCR_IDLE;\n\t\t\tncr53c9x_sched(sc);\n\t\t}\n\t} else\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\t\n\tncr53c9x_free_ecb(sc, ecb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}"
  },
  {
    "function_name": "ncr53c9x_sense",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "718-751",
    "snippet": "void\nncr53c9x_sense(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&ecb->cmd.cmd;\n\n\tNCR_MISC((\"requesting sense \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tecb->clen = sizeof(*ss);\n\tecb->daddr = (char *)&xs->sense;\n\tecb->dleft = sizeof(struct scsi_sense_data);\n\tecb->flags |= ECB_SENSE;\n\tecb->timeout = NCR_SENSE_TIMEOUT;\n\tti->senses++;\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tecb->flags &= ~ECB_NEXUS;\n\t\tncr53c9x_select(sc, ecb);\n\t} else {\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);\n\t\tif (sc->sc_state == NCR_IDLE)\n\t\t\tncr53c9x_sched(sc);\n\t}\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tncr53c9x_select",
      "void\tncr53c9x_sched",
      "void ncr53c9x_dequeue",
      "void ncr53c9x_sense",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr53c9x_sched",
          "args": [
            "sc"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "687-716",
          "snippet": "void\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_sched",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->ready_list",
            "ecb",
            "chain"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_dequeue",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "825-837",
          "snippet": "void\nncr53c9x_dequeue(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\n\tif (ecb->flags & ECB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, ecb, chain);\n\t\tecb->flags &= ~ECB_NEXUS;\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void ncr53c9x_dequeue",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid ncr53c9x_dequeue;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_dequeue(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\n\tif (ecb->flags & ECB_NEXUS) {\n\t\tTAILQ_REMOVE(&sc->nexus_list, ecb, chain);\n\t\tecb->flags &= ~ECB_NEXUS;\n\t} else {\n\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_select",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "453-536",
          "snippet": "void\nncr53c9x_select(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_link *sc_link = ecb->xs->sc_link;\n\tint target = sc_link->target;\n\tint lun = sc_link->lun;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[target];\n\tint tiflags = ti->flags;\n\tu_char *cmd;\n\tint clen;\n\n\tNCR_TRACE((\"[ncr53c9x_select(t%d,l%d,cmd:%x)] \",\n\t\t   target, lun, ecb->cmd.cmd.opcode));\n\n\tsc->sc_state = NCR_SELECTING;\n\n\t/*\n\t * Schedule the timeout now, the first time we will go away\n\t * expecting to come back due to an interrupt, because it is\n\t * always possible that the interrupt may never happen.\n\t */\n\tif ((ecb->xs->flags & SCSI_POLL) == 0)\n\t\ttimeout(ncr53c9x_timeout, ecb,\n\t\t    (ecb->timeout * hz) / 1000);\n\n\t/*\n\t * The docs say the target register is never reset, and I\n\t * can't think of a better place to set it\n\t */\n\tNCR_WRITE_REG(sc, NCR_SELID, target);\n\tncr53c9x_setsync(sc, ti);\n\n\tif (ncr53c9x_dmaselect && (tiflags & T_NEGOTIATE) == 0) {\n\t\tsize_t dmasize;\n\n\t\tecb->cmd.id = \n\t\t    MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1);\n\n\t\t/* setup DMA transfer for command */\n\t\tdmasize = clen = ecb->clen + 1;\n\t\tsc->sc_cmdlen = clen;\n\t\tsc->sc_cmdp = (caddr_t)&ecb->cmd;\n\t\tNCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);\n\n\t\t/* Program the SCSI counter */\n\t\tNCR_WRITE_REG(sc, NCR_TCL, dmasize);\n\t\tNCR_WRITE_REG(sc, NCR_TCM, dmasize >> 8);\n\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\tNCR_WRITE_REG(sc, NCR_TCH, dmasize >> 16);\n\t\t}\n\n\t\t/* load the count in */\n\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t/* And get the targets attention */\n\t\tNCRCMD(sc, NCRCMD_SELATN | NCRCMD_DMA);\n\t\tNCRDMA_GO(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * Who am I. This is where we tell the target that we are\n\t * happy for it to disconnect etc.\n\t */\n\tNCR_WRITE_REG(sc, NCR_FIFO,\n\t\t\tMSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1));\n\n\tif (ti->flags & T_NEGOTIATE) {\n\t\t/* Arbitrate, select and stop after IDENTIFY message */\n\t\tNCRCMD(sc, NCRCMD_SELATNS);\n\t\treturn;\n\t}\n\n\t/* Now the command into the FIFO */\n\tcmd = (u_char *)&ecb->cmd.cmd;\n\tclen = ecb->clen;\n\twhile (clen--)\n\t\tNCR_WRITE_REG(sc, NCR_FIFO, *cmd++);\n\n\t/* And get the targets attention */\n\tNCRCMD(sc, NCRCMD_SELATN);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_timeout",
            "static inline void ncr53c9x_setsync",
            "int ncr53c9x_dmaselect = 0;",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_timeout;\nstatic inline void ncr53c9x_setsync;\nint ncr53c9x_dmaselect = 0;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_select(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_link *sc_link = ecb->xs->sc_link;\n\tint target = sc_link->target;\n\tint lun = sc_link->lun;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[target];\n\tint tiflags = ti->flags;\n\tu_char *cmd;\n\tint clen;\n\n\tNCR_TRACE((\"[ncr53c9x_select(t%d,l%d,cmd:%x)] \",\n\t\t   target, lun, ecb->cmd.cmd.opcode));\n\n\tsc->sc_state = NCR_SELECTING;\n\n\t/*\n\t * Schedule the timeout now, the first time we will go away\n\t * expecting to come back due to an interrupt, because it is\n\t * always possible that the interrupt may never happen.\n\t */\n\tif ((ecb->xs->flags & SCSI_POLL) == 0)\n\t\ttimeout(ncr53c9x_timeout, ecb,\n\t\t    (ecb->timeout * hz) / 1000);\n\n\t/*\n\t * The docs say the target register is never reset, and I\n\t * can't think of a better place to set it\n\t */\n\tNCR_WRITE_REG(sc, NCR_SELID, target);\n\tncr53c9x_setsync(sc, ti);\n\n\tif (ncr53c9x_dmaselect && (tiflags & T_NEGOTIATE) == 0) {\n\t\tsize_t dmasize;\n\n\t\tecb->cmd.id = \n\t\t    MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1);\n\n\t\t/* setup DMA transfer for command */\n\t\tdmasize = clen = ecb->clen + 1;\n\t\tsc->sc_cmdlen = clen;\n\t\tsc->sc_cmdp = (caddr_t)&ecb->cmd;\n\t\tNCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);\n\n\t\t/* Program the SCSI counter */\n\t\tNCR_WRITE_REG(sc, NCR_TCL, dmasize);\n\t\tNCR_WRITE_REG(sc, NCR_TCM, dmasize >> 8);\n\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\tNCR_WRITE_REG(sc, NCR_TCH, dmasize >> 16);\n\t\t}\n\n\t\t/* load the count in */\n\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t/* And get the targets attention */\n\t\tNCRCMD(sc, NCRCMD_SELATN | NCRCMD_DMA);\n\t\tNCRDMA_GO(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * Who am I. This is where we tell the target that we are\n\t * happy for it to disconnect etc.\n\t */\n\tNCR_WRITE_REG(sc, NCR_FIFO,\n\t\t\tMSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1));\n\n\tif (ti->flags & T_NEGOTIATE) {\n\t\t/* Arbitrate, select and stop after IDENTIFY message */\n\t\tNCRCMD(sc, NCRCMD_SELATNS);\n\t\treturn;\n\t}\n\n\t/* Now the command into the FIFO */\n\tcmd = (u_char *)&ecb->cmd.cmd;\n\tclen = ecb->clen;\n\twhile (clen--)\n\t\tNCR_WRITE_REG(sc, NCR_FIFO, *cmd++);\n\n\t/* And get the targets attention */\n\tNCRCMD(sc, NCRCMD_SELATN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ss",
            "sizeof(*ss)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_MISC",
          "args": [
            "(\"requesting sense \")"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nvoid ncr53c9x_dequeue;\nvoid ncr53c9x_sense;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_sense(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tstruct scsi_sense *ss = (void *)&ecb->cmd.cmd;\n\n\tNCR_MISC((\"requesting sense \"));\n\t/* Next, setup a request sense command block */\n\tbzero(ss, sizeof(*ss));\n\tss->opcode = REQUEST_SENSE;\n\tss->byte2 = sc_link->lun << 5;\n\tss->length = sizeof(struct scsi_sense_data);\n\tecb->clen = sizeof(*ss);\n\tecb->daddr = (char *)&xs->sense;\n\tecb->dleft = sizeof(struct scsi_sense_data);\n\tecb->flags |= ECB_SENSE;\n\tecb->timeout = NCR_SENSE_TIMEOUT;\n\tti->senses++;\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tecb->flags &= ~ECB_NEXUS;\n\t\tncr53c9x_select(sc, ecb);\n\t} else {\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\tTAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);\n\t\tif (sc->sc_state == NCR_IDLE)\n\t\t\tncr53c9x_sched(sc);\n\t}\n}"
  },
  {
    "function_name": "ncr53c9x_sched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "687-716",
    "snippet": "void\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tncr53c9x_select",
      "void\tncr53c9x_sched",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_MISC",
          "args": [
            "(\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_select",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "453-536",
          "snippet": "void\nncr53c9x_select(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_link *sc_link = ecb->xs->sc_link;\n\tint target = sc_link->target;\n\tint lun = sc_link->lun;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[target];\n\tint tiflags = ti->flags;\n\tu_char *cmd;\n\tint clen;\n\n\tNCR_TRACE((\"[ncr53c9x_select(t%d,l%d,cmd:%x)] \",\n\t\t   target, lun, ecb->cmd.cmd.opcode));\n\n\tsc->sc_state = NCR_SELECTING;\n\n\t/*\n\t * Schedule the timeout now, the first time we will go away\n\t * expecting to come back due to an interrupt, because it is\n\t * always possible that the interrupt may never happen.\n\t */\n\tif ((ecb->xs->flags & SCSI_POLL) == 0)\n\t\ttimeout(ncr53c9x_timeout, ecb,\n\t\t    (ecb->timeout * hz) / 1000);\n\n\t/*\n\t * The docs say the target register is never reset, and I\n\t * can't think of a better place to set it\n\t */\n\tNCR_WRITE_REG(sc, NCR_SELID, target);\n\tncr53c9x_setsync(sc, ti);\n\n\tif (ncr53c9x_dmaselect && (tiflags & T_NEGOTIATE) == 0) {\n\t\tsize_t dmasize;\n\n\t\tecb->cmd.id = \n\t\t    MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1);\n\n\t\t/* setup DMA transfer for command */\n\t\tdmasize = clen = ecb->clen + 1;\n\t\tsc->sc_cmdlen = clen;\n\t\tsc->sc_cmdp = (caddr_t)&ecb->cmd;\n\t\tNCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);\n\n\t\t/* Program the SCSI counter */\n\t\tNCR_WRITE_REG(sc, NCR_TCL, dmasize);\n\t\tNCR_WRITE_REG(sc, NCR_TCM, dmasize >> 8);\n\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\tNCR_WRITE_REG(sc, NCR_TCH, dmasize >> 16);\n\t\t}\n\n\t\t/* load the count in */\n\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t/* And get the targets attention */\n\t\tNCRCMD(sc, NCRCMD_SELATN | NCRCMD_DMA);\n\t\tNCRDMA_GO(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * Who am I. This is where we tell the target that we are\n\t * happy for it to disconnect etc.\n\t */\n\tNCR_WRITE_REG(sc, NCR_FIFO,\n\t\t\tMSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1));\n\n\tif (ti->flags & T_NEGOTIATE) {\n\t\t/* Arbitrate, select and stop after IDENTIFY message */\n\t\tNCRCMD(sc, NCRCMD_SELATNS);\n\t\treturn;\n\t}\n\n\t/* Now the command into the FIFO */\n\tcmd = (u_char *)&ecb->cmd.cmd;\n\tclen = ecb->clen;\n\twhile (clen--)\n\t\tNCR_WRITE_REG(sc, NCR_FIFO, *cmd++);\n\n\t/* And get the targets attention */\n\tNCRCMD(sc, NCRCMD_SELATN);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_timeout",
            "static inline void ncr53c9x_setsync",
            "int ncr53c9x_dmaselect = 0;",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_timeout;\nstatic inline void ncr53c9x_setsync;\nint ncr53c9x_dmaselect = 0;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_select(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_link *sc_link = ecb->xs->sc_link;\n\tint target = sc_link->target;\n\tint lun = sc_link->lun;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[target];\n\tint tiflags = ti->flags;\n\tu_char *cmd;\n\tint clen;\n\n\tNCR_TRACE((\"[ncr53c9x_select(t%d,l%d,cmd:%x)] \",\n\t\t   target, lun, ecb->cmd.cmd.opcode));\n\n\tsc->sc_state = NCR_SELECTING;\n\n\t/*\n\t * Schedule the timeout now, the first time we will go away\n\t * expecting to come back due to an interrupt, because it is\n\t * always possible that the interrupt may never happen.\n\t */\n\tif ((ecb->xs->flags & SCSI_POLL) == 0)\n\t\ttimeout(ncr53c9x_timeout, ecb,\n\t\t    (ecb->timeout * hz) / 1000);\n\n\t/*\n\t * The docs say the target register is never reset, and I\n\t * can't think of a better place to set it\n\t */\n\tNCR_WRITE_REG(sc, NCR_SELID, target);\n\tncr53c9x_setsync(sc, ti);\n\n\tif (ncr53c9x_dmaselect && (tiflags & T_NEGOTIATE) == 0) {\n\t\tsize_t dmasize;\n\n\t\tecb->cmd.id = \n\t\t    MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1);\n\n\t\t/* setup DMA transfer for command */\n\t\tdmasize = clen = ecb->clen + 1;\n\t\tsc->sc_cmdlen = clen;\n\t\tsc->sc_cmdp = (caddr_t)&ecb->cmd;\n\t\tNCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);\n\n\t\t/* Program the SCSI counter */\n\t\tNCR_WRITE_REG(sc, NCR_TCL, dmasize);\n\t\tNCR_WRITE_REG(sc, NCR_TCM, dmasize >> 8);\n\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\tNCR_WRITE_REG(sc, NCR_TCH, dmasize >> 16);\n\t\t}\n\n\t\t/* load the count in */\n\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t/* And get the targets attention */\n\t\tNCRCMD(sc, NCRCMD_SELATN | NCRCMD_DMA);\n\t\tNCRDMA_GO(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * Who am I. This is where we tell the target that we are\n\t * happy for it to disconnect etc.\n\t */\n\tNCR_WRITE_REG(sc, NCR_FIFO,\n\t\t\tMSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1));\n\n\tif (ti->flags & T_NEGOTIATE) {\n\t\t/* Arbitrate, select and stop after IDENTIFY message */\n\t\tNCRCMD(sc, NCRCMD_SELATNS);\n\t\treturn;\n\t}\n\n\t/* Now the command into the FIFO */\n\tcmd = (u_char *)&ecb->cmd.cmd;\n\tclen = ecb->clen;\n\twhile (clen--)\n\t\tNCR_WRITE_REG(sc, NCR_FIFO, *cmd++);\n\n\t/* And get the targets attention */\n\tNCRCMD(sc, NCRCMD_SELATN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_REMOVE",
          "args": [
            "&sc->ready_list",
            "ecb",
            "chain"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr53c9x_sched: not IDLE (state=%d)\"",
            "sc->sc_state"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "(\"[ncr53c9x_sched] \")"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}"
  },
  {
    "function_name": "ncr53c9x_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "648-674",
    "snippet": "int\nncr53c9x_poll(sc, xs, count)\n\tstruct ncr53c9x_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\n\tNCR_TRACE((\"[ncr53c9x_poll] \"));\n\twhile (count) {\n\t\tif (NCRDMA_ISINTR(sc)) {\n\t\t\tncr53c9x_intr(sc);\n\t\t}\n#if alternatively\n\t\tif (NCR_READ_REG(sc, NCR_STAT) & NCRSTAT_INT)\n\t\t\tncr53c9x_intr(sc);\n#endif\n\t\tif ((xs->flags & ITSDONE) != 0)\n\t\t\treturn (0);\n\t\tif (sc->sc_state == NCR_IDLE) {\n\t\t\tNCR_TRACE((\"[ncr53c9x_poll: rescheduling] \"));\n\t\t\tncr53c9x_sched(sc);\n\t\t}\n\t\tDELAY(1000);\n\t\tcount--;\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tncr53c9x_poll",
      "void\tncr53c9x_sched",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched",
          "args": [
            "sc"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "687-716",
          "snippet": "void\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_sched",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "(\"[ncr53c9x_poll: rescheduling] \")"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_intr",
          "args": [
            "sc"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "1345-2058",
          "snippet": "int\nncr53c9x_intr(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tregister struct ncr53c9x_ecb *ecb;\n\tregister struct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\tsize_t size;\n\tint nfifo;\n\n\tNCR_TRACE((\"[ncr53c9x_intr] \"));\n\n\tif (!NCRDMA_ISINTR(sc))\n\t\treturn (0);\n\nagain:\n\t/* and what do the registers day... */\n\tncr53c9x_readregs(sc);\n\n\tsc->sc_intrcnt.ev_count++;\n\n\t/*\n\t * Command are classed as errors. A disconnect is a\n\t * valid condition, and we let the code check is the\n\t * \"NCR_BUSFREE_OK\" flag was set before declaring it\n\t * and error.\n\t * \n\t * Also, the status register tells us about \"Gross\n\t * Errors\" and \"Parity errors\". Only the Gross Error\n\t * is really bad, and the parity errors are dealt   \n\t * with later\n\t * \n\t * TODO\n\t *      If there are too many parity error, go to slow\n\t *      cable mode ?\n\t */\n\n\t/* SCSI Reset */\n\tif (sc->sc_espintr & NCRINTR_SBR) {\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\tif (sc->sc_state != NCR_SBR) {\n\t\t\tprintf(\"%s: SCSI bus reset\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 0); /* Restart everything */\n\t\t\treturn (1);\n\t\t}\n#if 0\n/*XXX*/\t\tprintf(\"<expected bus reset: \"\n\t\t\t\"[intr %x, stat %x, step %d]>\\n\",\n\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\tsc->sc_espstep);\n#endif\n\t\tif (sc->sc_nexus)\n\t\t\tpanic(\"%s: nexus in reset state\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tgoto sched;\n\t}\n\n\tecb = sc->sc_nexus;\n\n#define NCRINTR_ERR (NCRINTR_SBR|NCRINTR_ILL)\n\tif (sc->sc_espintr & NCRINTR_ERR ||\n\t    sc->sc_espstat & NCRSTAT_GE) {\n\n\t\tif (sc->sc_espstat & NCRSTAT_GE) {\n\t\t\t/* Gross Error; no target ? */\n\t\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tDELAY(1);\n\t\t\t}\n\t\t\tif (sc->sc_state == NCR_CONNECTED ||\n\t\t\t    sc->sc_state == NCR_SELECTING) {\n\t\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\t\tncr53c9x_done(sc, ecb);\n\t\t\t}\n\t\t\t\treturn (1);\n\t\t}\n\n\t\tif (sc->sc_espintr & NCRINTR_ILL) {\n\t\t\tif (sc->sc_flags & NCR_EXPECT_ILLCMD) {\n\t\t\t\t/*\n\t\t\t\t * Eat away \"Illegal command\" interrupt\n\t\t\t\t * on a ESP100 caused by a re-selection\n\t\t\t\t * while we were trying to select\n\t\t\t\t * another target.\n\t\t\t\t */\n#ifdef DEBUG\n\t\t\t\tprintf(\"%s: ESP100 work-around activated\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n#endif\n\t\t\t\tsc->sc_flags &= ~NCR_EXPECT_ILLCMD;\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\t/* illegal command, out of sync ? */\n\t\t\tprintf(\"%s: illegal command: 0x%x \"\n\t\t\t    \"(state %d, phase %x, prevphase %x)\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, sc->sc_lastcmd,\n\t\t\t\tsc->sc_state, sc->sc_phase,\n\t\t\t\tsc->sc_prevphase);\n\t\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tDELAY(1);\n\t\t\t}\n\t\t\tncr53c9x_init(sc, 1); /* Restart everything */\n\t\t\treturn (1);\n\t\t}\n\t}\n\tsc->sc_flags &= ~NCR_EXPECT_ILLCMD;\n\n\t/*\n\t * Call if DMA is active.\n\t *\n\t * If DMA_INTR returns true, then maybe go 'round the loop\n\t * again in case there is no more DMA queued, but a phase\n\t * change is expected.\n\t */\n\tif (NCRDMA_ISACTIVE(sc)) {\n\t\tint r = NCRDMA_INTR(sc);\n\t\tif (r == -1) {\n\t\t\tprintf(\"%s: DMA error; resetting\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t}\n\t\t/* If DMA active here, then go back to work... */\n\t\tif (NCRDMA_ISACTIVE(sc))\n\t\t\treturn (1);\n\n\t\tif ((sc->sc_espstat & NCRSTAT_TC) == 0) {\n\t\t\t/*\n\t\t\t * DMA not completed.  If we can not find a\n\t\t\t * acceptable explanation, print a diagnostic.\n\t\t\t */\n\t\t\tif (sc->sc_state == NCR_SELECTING)\n\t\t\t\t/*\n\t\t\t\t * This can happen if we are reselected\n\t\t\t\t * while using DMA to select a target.\n\t\t\t\t */\n\t\t\t\t/*void*/;\n\t\t\telse if (sc->sc_prevphase == MESSAGE_OUT_PHASE){\n\t\t\t\t/*\n\t\t\t\t * Our (multi-byte) message (eg SDTR)\n\t\t\t\t * was interrupted by the target to\n\t\t\t\t * send a MSG REJECT.\n\t\t\t\t * Print diagnostic if current phase\n\t\t\t\t * is not MESSAGE IN.\n\t\t\t\t */\n\t\t\t\tif (sc->sc_phase != MESSAGE_IN_PHASE)\n\t\t\t\t    printf(\"%s: !TC on MSG OUT\"\n\t\t\t\t       \" [intr %x, stat %x, step %d]\"\n\t\t\t\t       \" prevphase %x, resid %x\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase,\n\t\t\t\t\tsc->sc_omlen);\n\t\t\t} else if (sc->sc_dleft == 0) {\n\t\t\t\t/*\n\t\t\t\t * The DMA operation was started for\n\t\t\t\t * a DATA transfer. Print a diagnostic\n\t\t\t\t * if the DMA counter and TC bit\n\t\t\t\t * appear to be out of sync.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: !TC on DATA XFER\"\n\t\t\t\t       \" [intr %x, stat %x, step %d]\"\n\t\t\t\t       \" prevphase %x, resid %x\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase,\n\t\t\t\t\tecb?ecb->dleft:-1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * check for less serious errors\n\t */\n\tif (sc->sc_espstat & NCRSTAT_PE) {\n\t\tprintf(\"%s: SCSI bus parity error\\n\", sc->sc_dev.dv_xname);\n\t\tif (sc->sc_prevphase == MESSAGE_IN_PHASE)\n\t\t\tncr53c9x_sched_msgout(SEND_PARITY_ERROR);\n\t\telse\n\t\t\tncr53c9x_sched_msgout(SEND_INIT_DET_ERR);\n\t}\n\n\tif (sc->sc_espintr & NCRINTR_DIS) {\n\t\tNCR_MISC((\"<DISC [intr %x, stat %x, step %d]>\",\n\t\t\tsc->sc_espintr,sc->sc_espstat,sc->sc_espstep));\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\t/*\n\t\t * This command must (apparently) be issued within\n\t\t * 250mS of a disconnect. So here you are...\n\t\t */\n\t\tNCRCMD(sc, NCRCMD_ENSEL);\n\n\t\tswitch (sc->sc_state) {\n\t\tcase NCR_RESELECTED:\n\t\t\tgoto sched;\n\n\t\tcase NCR_SELECTING:\n\t\t\tecb->xs->error = XS_SELTIMEOUT;\n\t\t\tgoto finish;\n\n\t\tcase NCR_CONNECTED:\n\t\t\tif ((sc->sc_flags & NCR_SYNCHNEGO)) {\n#ifdef NCR53C9X_DEBUG\n\t\t\t\tif (ecb)\n\t\t\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\t\tprintf(\"sync nego not completed!\\n\");\n#endif\n\t\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);\n\t\t\t}\n\n\t\t\t/* it may be OK to disconnect */\n\t\t\tif ((sc->sc_flags & NCR_ABORTING) == 0) {\n\t\t\t\t/*  \n\t\t\t\t * Section 5.1.1 of the SCSI 2 spec\n\t\t\t\t * suggests issuing a REQUEST SENSE\n\t\t\t\t * following an unexpected disconnect.\n\t\t\t\t * Some devices go into a contingent\n\t\t\t\t * allegiance condition when\n\t\t\t\t * disconnecting, and this is necessary\n\t\t\t\t * to clean up their state.\n\t\t\t\t */     \n\t\t\t\tprintf(\"%s: unexpected disconnect; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tif (ecb->flags & ECB_SENSE) {\n\t\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\tprintf(\"sending REQUEST SENSE\\n\");\n\t\t\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\t\t\tncr53c9x_sense(sc, ecb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tgoto finish;\n\n\t\tcase NCR_DISCONNECT:\n\t\t\tTAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);\n\t\t\tsc->sc_nexus = NULL;\n\t\t\tgoto sched;\n\n\t\tcase NCR_CMDCOMPLETE:\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\tswitch (sc->sc_state) {\n\n\tcase NCR_SBR:\n\t\tprintf(\"%s: waiting for SCSI Bus Reset to happen\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n\t\t\treturn (1);\n\n\tcase NCR_RESELECTED:\n\t\t/*\n\t\t * we must be continuing a message ?\n\t\t */\n\t\tif (sc->sc_phase != MESSAGE_IN_PHASE) {\n\t\t\tprintf(\"%s: target didn't identify\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t\treturn (1);\n\t\t}\nprintf(\"<<RESELECT CONT'd>>\");\n#if XXXX\n\t\tncr53c9x_msgin(sc);\n\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t/* IDENTIFY fail?! */\n\t\t\tprintf(\"%s: identify failed\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t\treturn (1);\n\t\t}\n#endif\n\t\tbreak;\n\n\tcase NCR_IDLE:\n\tcase NCR_SELECTING:\n\t\tsc->sc_msgpriq = sc->sc_msgout = sc->sc_msgoutq = 0;\n\t\tsc->sc_flags = 0;\n\t\tecb = sc->sc_nexus;\n\t\tif (ecb != NULL && (ecb->flags & ECB_NEXUS)) {\n\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\tprintf(\"ECB_NEXUS while in state %x\\n\", sc->sc_state);\n\t\t}\n\n\t\tif (sc->sc_espintr & NCRINTR_RESEL) {\n\t\t\t/*\n\t\t\t * If we're trying to select a\n\t\t\t * target ourselves, push our command\n\t\t\t * back into the ready list.\n\t\t\t */\n\t\t\tif (sc->sc_state == NCR_SELECTING) {\n\t\t\t\tNCR_MISC((\"backoff selector \"));\n\t\t\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\t\t\tsc_link = ecb->xs->sc_link;\n\t\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\t\t\tTAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);\n\t\t\t\tecb = sc->sc_nexus = NULL;\n\t\t\t}\n\t\t\tsc->sc_state = NCR_RESELECTED;\n\t\t\tif (sc->sc_phase != MESSAGE_IN_PHASE) {\n\t\t\t\t/*\n\t\t\t\t * Things are seriously fucked up.\n\t\t\t\t * Pull the brakes, i.e. reset\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: target didn't identify\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\t/*\n\t\t\t * The C90 only inhibits FIFO writes until\n\t\t\t * reselection is complete, instead of\n\t\t\t * waiting until the interrupt status register\n\t\t\t * has been read. So, if the reselect happens\n\t\t\t * while we were entering a command bytes (for\n\t\t\t * another target) some of those bytes can\n\t\t\t * appear in the FIFO here, after the\n\t\t\t * interrupt is taken.\n\t\t\t */\n\t\t\tnfifo = NCR_READ_REG(sc,NCR_FFLAG) & NCRFIFO_FF;\n\t\t\tif (nfifo < 2 ||\n\t\t\t    (nfifo > 2 &&\n\t\t\t     sc->sc_rev != NCR_VARIANT_ESP100)) {\n\t\t\t\tprintf(\"%s: RESELECT: \"\n\t\t\t\t    \"%d bytes in FIFO! \"\n\t\t\t\t    \"[intr %x, stat %x, step %d, prevphase %x]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tnfifo,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase);\n\t\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tsc->sc_selid = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tNCR_MISC((\"selid=0x%2x \", sc->sc_selid));\n\n\t\t\t/* Handle identify message */\n\t\t\tncr53c9x_msgin(sc);\n\t\t\tif (nfifo != 2) {\n\t\t\t\t/*\n\t\t\t\t * Note: this should not happen\n\t\t\t\t * with `dmaselect' on.\n\t\t\t\t */\n\t\t\t\tsc->sc_flags |= NCR_EXPECT_ILLCMD;\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t} else if (ncr53c9x_dmaselect &&\n\t\t\t\t   sc->sc_rev == NCR_VARIANT_ESP100) {\n\t\t\t\tsc->sc_flags |= NCR_EXPECT_ILLCMD;\n\t\t\t}\n\n\t\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t\t/* IDENTIFY fail?! */\n\t\t\t\tprintf(\"%s: identify failed\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tgoto shortcut; /* ie. next phase expected soon */\n\t\t}\n\n#define\tNCRINTR_DONE\t(NCRINTR_FC|NCRINTR_BS)\n\t\tif ((sc->sc_espintr & NCRINTR_DONE) == NCRINTR_DONE) {\n\t\t\t/*\n\t\t\t * Arbitration won; examine the `step' register\n\t\t\t * to determine how far the selection could progress.\n\t\t\t */\n\t\t\tecb = sc->sc_nexus;\n\t\t\tif (!ecb)\n\t\t\t\tpanic(\"esp: no nexus\");\n\n\t\t\tsc_link = ecb->xs->sc_link;\n\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\n\t\t\tswitch (sc->sc_espstep) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * The target did not respond with a\n\t\t\t\t * message out phase - probably an old\n\t\t\t\t * device that doesn't recognize ATN.\n\t\t\t\t * Clear ATN and just continue, the\n\t\t\t\t * target should be in the command\n\t\t\t\t * phase.\n\t\t\t\t * XXXX check for command phase?\n\t\t\t\t */\n\t\t\t\tNCRCMD(sc, NCRCMD_RSTATN);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif ((ti->flags & T_NEGOTIATE) == 0) {\n\t\t\t\t\tprintf(\"%s: step 1 & !NEG\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\tif (sc->sc_phase != MESSAGE_OUT_PHASE) {\n\t\t\t\t\tprintf(\"%s: !MSGOUT\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\t/* Start negotiating */\n\t\t\t\tti->period = sc->sc_minsync;\n\t\t\t\tti->offset = 15;\n\t\t\t\tsc->sc_flags |= NCR_SYNCHNEGO;\n\t\t\t\tncr53c9x_sched_msgout(SEND_SDTR);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t/*\n\t\t\t\t * Grr, this is supposed to mean\n\t\t\t\t * \"target left command phase  prematurely\".\n\t\t\t\t * It seems to happen regularly when\n\t\t\t\t * sync mode is on.\n\t\t\t\t * Look at FIFO to see if command went out.\n\t\t\t\t * (Timing problems?)\n\t\t\t\t */\n\t\t\t\tif (ncr53c9x_dmaselect) {\n\t\t\t\t\tif (sc->sc_cmdlen == 0)\n\t\t\t\t\t\t/* Hope for the best.. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if ((NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t    & NCRFIFO_FF) == 0) {\n\t\t\t\t\t\t/* Hope for the best.. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"(%s:%d:%d): selection failed;\"\n\t\t\t\t\t\" %d left in FIFO \"\n\t\t\t\t\t\"[intr %x, stat %x, step %d]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc_link->target,\n\t\t\t\t\tsc_link->lun,\n\t\t\t\t\tNCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t & NCRFIFO_FF,\n\t\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep);\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\t\t\t\treturn (1);\n\t\t\tcase 2:\n\t\t\t\t/* Select stuck at Command Phase */\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tcase 4:\n\t\t\t\tif (ncr53c9x_dmaselect &&\n\t\t\t\t    sc->sc_cmdlen != 0)\n\t\t\t\t\tprintf(\"(%s:%d:%d): select; \"\n\t\t\t\t\t       \"%d left in DMA buffer \"\n\t\t\t\t\t\"[intr %x, stat %x, step %d]\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tsc_link->target,\n\t\t\t\t\t\tsc_link->lun,\n\t\t\t\t\t\tsc->sc_cmdlen,\n\t\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\t\tsc->sc_espstep);\n\t\t\t\t/* So far, everything went fine */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tecb->flags |= ECB_NEXUS;\n\t\t\tti->lubusy |= (1 << sc_link->lun);\n\n\t\t\tsc->sc_prevphase = INVALID_PHASE; /* ?? */\n\t\t\t/* Do an implicit RESTORE POINTERS. */\n\t\t\tsc->sc_dp = ecb->daddr;\n\t\t\tsc->sc_dleft = ecb->dleft;\n\t\t\tsc->sc_state = NCR_CONNECTED;\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\tprintf(\"%s: unexpected status after select\"\n\t\t\t\t\": [intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t\tgoto reset;\n\t\t}\n\t\tif (sc->sc_state == NCR_IDLE) {\n\t\t\tprintf(\"%s: stray interrupt\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\n\tcase NCR_CONNECTED:\n\t\tif (sc->sc_flags & NCR_ICCS) {\n\t\t\t/* \"Initiate Command Complete Steps\" in progress */\n\t\t\tu_char msg;\n\n\t\t\tsc->sc_flags &= ~NCR_ICCS;\n\n\t\t\tif (!(sc->sc_espintr & NCRINTR_DONE)) {\n\t\t\t\tprintf(\"%s: ICCS: \"\n\t\t\t\t      \": [intr %x, stat %x, step %x]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep);\n\t\t\t}\n\t\t\tif ((NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t    & NCRFIFO_FF) != 2) {\n\t\t\t\tint i = (NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t    & NCRFIFO_FF) - 2;\n\t\t\t\twhile (i--)\n\t\t\t\t\t(void) NCR_READ_REG(sc, NCR_FIFO);\n\t\t\t}\n\t\t\tecb->stat = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tmsg = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tNCR_PHASE((\"<stat:(%x,%x)>\", ecb->stat, msg));\n\t\t\tif (msg == MSG_CMDCOMPLETE) {\n\t\t\t\tecb->dleft = (ecb->flags & ECB_TENTATIVE_DONE)\n\t\t\t\t\t? 0\n\t\t\t\t\t: sc->sc_dleft;\n\t\t\t\tif ((ecb->flags & ECB_SENSE) == 0)\n\t\t\t\t\tecb->xs->resid = ecb->dleft;\n\t\t\t\tsc->sc_state = NCR_CMDCOMPLETE;\n\t\t\t} else\n\t\t\t\tprintf(\"%s: STATUS_PHASE: msg %d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname, msg);\n\t\t\tNCRCMD(sc, NCRCMD_MSGOK);\n\t\t\tgoto shortcut; /* ie. wait for disconnect */\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"%s: invalid state: %d\",\n\t\t      sc->sc_dev.dv_xname,\n\t\t      sc->sc_state);\n\t}\n\n\t/*\n\t * Driver is now in state NCR_CONNECTED, i.e. we\n\t * have a current command working the SCSI bus.\n\t */\n\tif (sc->sc_state != NCR_CONNECTED || ecb == NULL) {\n\t\tpanic(\"esp no nexus\");\n\t}\n\n\tswitch (sc->sc_phase) {\n\tcase MESSAGE_OUT_PHASE:\n\t\tNCR_PHASE((\"MESSAGE_OUT_PHASE \"));\n\t\tncr53c9x_msgout(sc);\n\t\tsc->sc_prevphase = MESSAGE_OUT_PHASE;\n\t\tbreak;\n\tcase MESSAGE_IN_PHASE:\n\t\tNCR_PHASE((\"MESSAGE_IN_PHASE \"));\n\t\tsc->sc_prevphase = MESSAGE_IN_PHASE;\n\t\tif (sc->sc_espintr & NCRINTR_BS) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tsc->sc_flags |= NCR_WAITI;\n\t\t\tNCRCMD(sc, NCRCMD_TRANS);\n\t\t} else if (sc->sc_espintr & NCRINTR_FC) {\n\t\t\tif ((sc->sc_flags & NCR_WAITI) == 0) {\n\t\t\t\tprintf(\"%s: MSGIN: unexpected FC bit: \"\n\t\t\t\t\t\"[intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t\t}\n\t\t\tsc->sc_flags &= ~NCR_WAITI;\n\t\t\tncr53c9x_msgin(sc);\n\t\t} else {\n\t\t\tprintf(\"%s: MSGIN: weird bits: \"\n\t\t\t\t\"[intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t}\n\t\tgoto shortcut;\t/* i.e. expect data to be ready */\n\t\tbreak;\n\tcase COMMAND_PHASE:\n\t\t/*\n\t\t * Send the command block. Normally we don't see this\n\t\t * phase because the SEL_ATN command takes care of\n\t\t * all this. However, we end up here if either the\n\t\t * target or we wanted to exchange some more messages\n\t\t * first (e.g. to start negotiations).\n\t\t */\n\n\t\tNCR_PHASE((\"COMMAND_PHASE 0x%02x (%d) \",\n\t\t\tecb->cmd.cmd.opcode, ecb->clen));\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\tif (ncr53c9x_dmaselect) {\n\t\t\tsize_t size;\n\t\t\t/* setup DMA transfer for command */\n\t\t\tsize = ecb->clen;\n\t\t\tsc->sc_cmdlen = size;\n\t\t\tsc->sc_cmdp = (caddr_t)&ecb->cmd.cmd;\n\t\t\tNCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen,\n\t\t\t\t     0, &size);\n\t\t\t/* Program the SCSI counter */\n\t\t\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\t\t\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\t\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t\t\t}\n\n\t\t\t/* load the count in */\n\t\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t\t/* start the command transfer */\n\t\t\tNCRCMD(sc, NCRCMD_TRANS | NCRCMD_DMA);\n\t\t\tNCRDMA_GO(sc);\n\t\t} else {\n\t\t\tu_char *cmd = (u_char *)&ecb->cmd.cmd;\n\t\t\tint i;\n\t\t\t/* Now the command into the FIFO */\n\t\t\tfor (i = 0; i < ecb->clen; i++)\n\t\t\t\tNCR_WRITE_REG(sc, NCR_FIFO, *cmd++);\n\t\t\tNCRCMD(sc, NCRCMD_TRANS);\n\t\t}\n\t\tsc->sc_prevphase = COMMAND_PHASE;\n\t\tbreak;\n\tcase DATA_OUT_PHASE:\n\t\tNCR_PHASE((\"DATA_OUT_PHASE [%ld] \",(long)sc->sc_dleft));\n\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\tsize = min(sc->sc_dleft, sc->sc_maxxfer);\n\t\tNCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,\n\t\t\t  0, &size);\n\t\tsc->sc_prevphase = DATA_OUT_PHASE;\n\t\tgoto setup_xfer;\n\tcase DATA_IN_PHASE:\n\t\tNCR_PHASE((\"DATA_IN_PHASE \"));\n\t\tif (sc->sc_rev == NCR_VARIANT_ESP100)\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\tsize = min(sc->sc_dleft, sc->sc_maxxfer);\n\t\tNCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,\n\t\t\t  1, &size);\n\t\tsc->sc_prevphase = DATA_IN_PHASE;\n\tsetup_xfer:\n\t\t/* Target returned to data phase: wipe \"done\" memory */\n\t\tecb->flags &= ~ECB_TENTATIVE_DONE;\n\n\t\t/* Program the SCSI counter */\n\t\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\t\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t\t}\n\t\t/* load the count in */\n\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t/*\n\t\t * Note that if `size' is 0, we've already transceived\n\t\t * all the bytes we want but we're still in DATA PHASE.\n\t\t * Apparently, the device needs padding. Also, a\n\t\t * transfer size of 0 means \"maximum\" to the chip\n\t\t * DMA logic.\n\t\t */\n\t\tNCRCMD(sc,\n\t\t       (size==0?NCRCMD_TRPAD:NCRCMD_TRANS)|NCRCMD_DMA);\n\t\tNCRDMA_GO(sc);\n\t\treturn (1);\n\tcase STATUS_PHASE:\n\t\tNCR_PHASE((\"STATUS_PHASE \"));\n\t\tsc->sc_flags |= NCR_ICCS;\n\t\tNCRCMD(sc, NCRCMD_ICCS);\n\t\tsc->sc_prevphase = STATUS_PHASE;\n\t\tbreak;\n\tcase INVALID_PHASE:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unexpected bus phase; resetting\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto reset;\n\t}\n\nout:\n\treturn (1);\n\nreset:\n\tncr53c9x_init(sc, 1);\n\tgoto out;\n\nfinish:\n\tncr53c9x_done(sc, ecb);\n\tgoto out;\n\nsched:\n\tsc->sc_state = NCR_IDLE;\n\tncr53c9x_sched(sc);\n\tgoto out;\n\nshortcut:\n\t/*\n\t * The idea is that many of the SCSI operations take very little\n\t * time, and going away and getting interrupted is too high an\n\t * overhead to pay. For example, selecting, sending a message\n\t * and command and then doing some work can be done in one \"pass\".\n\t *\n\t * The delay is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1\n\t * at 40Mhz. This needs testing.\n\t */\n\tDELAY(50/sc->sc_freq);\n\tif (NCRDMA_ISINTR(sc))\n\t\tgoto again;\n\tgoto out;\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tNCRINTR_DONE\t(NCRINTR_FC|NCRINTR_BS)",
            "#define NCRINTR_ERR (NCRINTR_SBR|NCRINTR_ILL)"
          ],
          "globals_used": [
            "void\tncr53c9x_readregs",
            "void\tncr53c9x_init",
            "void\tncr53c9x_sched",
            "void\tncr53c9x_done",
            "void\tncr53c9x_msgin",
            "void\tncr53c9x_msgout",
            "void\tncr53c9x_timeout",
            "void ncr53c9x_sense",
            "int ncr53c9x_dmaselect = 0;",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNCRINTR_DONE\t(NCRINTR_FC|NCRINTR_BS)\n#define NCRINTR_ERR (NCRINTR_SBR|NCRINTR_ILL)\n\nvoid\tncr53c9x_readregs;\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_done;\nvoid\tncr53c9x_msgin;\nvoid\tncr53c9x_msgout;\nvoid\tncr53c9x_timeout;\nvoid ncr53c9x_sense;\nint ncr53c9x_dmaselect = 0;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nint\nncr53c9x_intr(sc)\n\tregister struct ncr53c9x_softc *sc;\n{\n\tregister struct ncr53c9x_ecb *ecb;\n\tregister struct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\tsize_t size;\n\tint nfifo;\n\n\tNCR_TRACE((\"[ncr53c9x_intr] \"));\n\n\tif (!NCRDMA_ISINTR(sc))\n\t\treturn (0);\n\nagain:\n\t/* and what do the registers day... */\n\tncr53c9x_readregs(sc);\n\n\tsc->sc_intrcnt.ev_count++;\n\n\t/*\n\t * Command are classed as errors. A disconnect is a\n\t * valid condition, and we let the code check is the\n\t * \"NCR_BUSFREE_OK\" flag was set before declaring it\n\t * and error.\n\t * \n\t * Also, the status register tells us about \"Gross\n\t * Errors\" and \"Parity errors\". Only the Gross Error\n\t * is really bad, and the parity errors are dealt   \n\t * with later\n\t * \n\t * TODO\n\t *      If there are too many parity error, go to slow\n\t *      cable mode ?\n\t */\n\n\t/* SCSI Reset */\n\tif (sc->sc_espintr & NCRINTR_SBR) {\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\tif (sc->sc_state != NCR_SBR) {\n\t\t\tprintf(\"%s: SCSI bus reset\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 0); /* Restart everything */\n\t\t\treturn (1);\n\t\t}\n#if 0\n/*XXX*/\t\tprintf(\"<expected bus reset: \"\n\t\t\t\"[intr %x, stat %x, step %d]>\\n\",\n\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\tsc->sc_espstep);\n#endif\n\t\tif (sc->sc_nexus)\n\t\t\tpanic(\"%s: nexus in reset state\",\n\t\t      sc->sc_dev.dv_xname);\n\t\tgoto sched;\n\t}\n\n\tecb = sc->sc_nexus;\n\n#define NCRINTR_ERR (NCRINTR_SBR|NCRINTR_ILL)\n\tif (sc->sc_espintr & NCRINTR_ERR ||\n\t    sc->sc_espstat & NCRSTAT_GE) {\n\n\t\tif (sc->sc_espstat & NCRSTAT_GE) {\n\t\t\t/* Gross Error; no target ? */\n\t\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tDELAY(1);\n\t\t\t}\n\t\t\tif (sc->sc_state == NCR_CONNECTED ||\n\t\t\t    sc->sc_state == NCR_SELECTING) {\n\t\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\t\tncr53c9x_done(sc, ecb);\n\t\t\t}\n\t\t\t\treturn (1);\n\t\t}\n\n\t\tif (sc->sc_espintr & NCRINTR_ILL) {\n\t\t\tif (sc->sc_flags & NCR_EXPECT_ILLCMD) {\n\t\t\t\t/*\n\t\t\t\t * Eat away \"Illegal command\" interrupt\n\t\t\t\t * on a ESP100 caused by a re-selection\n\t\t\t\t * while we were trying to select\n\t\t\t\t * another target.\n\t\t\t\t */\n#ifdef DEBUG\n\t\t\t\tprintf(\"%s: ESP100 work-around activated\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n#endif\n\t\t\t\tsc->sc_flags &= ~NCR_EXPECT_ILLCMD;\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\t/* illegal command, out of sync ? */\n\t\t\tprintf(\"%s: illegal command: 0x%x \"\n\t\t\t    \"(state %d, phase %x, prevphase %x)\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, sc->sc_lastcmd,\n\t\t\t\tsc->sc_state, sc->sc_phase,\n\t\t\t\tsc->sc_prevphase);\n\t\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tDELAY(1);\n\t\t\t}\n\t\t\tncr53c9x_init(sc, 1); /* Restart everything */\n\t\t\treturn (1);\n\t\t}\n\t}\n\tsc->sc_flags &= ~NCR_EXPECT_ILLCMD;\n\n\t/*\n\t * Call if DMA is active.\n\t *\n\t * If DMA_INTR returns true, then maybe go 'round the loop\n\t * again in case there is no more DMA queued, but a phase\n\t * change is expected.\n\t */\n\tif (NCRDMA_ISACTIVE(sc)) {\n\t\tint r = NCRDMA_INTR(sc);\n\t\tif (r == -1) {\n\t\t\tprintf(\"%s: DMA error; resetting\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t}\n\t\t/* If DMA active here, then go back to work... */\n\t\tif (NCRDMA_ISACTIVE(sc))\n\t\t\treturn (1);\n\n\t\tif ((sc->sc_espstat & NCRSTAT_TC) == 0) {\n\t\t\t/*\n\t\t\t * DMA not completed.  If we can not find a\n\t\t\t * acceptable explanation, print a diagnostic.\n\t\t\t */\n\t\t\tif (sc->sc_state == NCR_SELECTING)\n\t\t\t\t/*\n\t\t\t\t * This can happen if we are reselected\n\t\t\t\t * while using DMA to select a target.\n\t\t\t\t */\n\t\t\t\t/*void*/;\n\t\t\telse if (sc->sc_prevphase == MESSAGE_OUT_PHASE){\n\t\t\t\t/*\n\t\t\t\t * Our (multi-byte) message (eg SDTR)\n\t\t\t\t * was interrupted by the target to\n\t\t\t\t * send a MSG REJECT.\n\t\t\t\t * Print diagnostic if current phase\n\t\t\t\t * is not MESSAGE IN.\n\t\t\t\t */\n\t\t\t\tif (sc->sc_phase != MESSAGE_IN_PHASE)\n\t\t\t\t    printf(\"%s: !TC on MSG OUT\"\n\t\t\t\t       \" [intr %x, stat %x, step %d]\"\n\t\t\t\t       \" prevphase %x, resid %x\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase,\n\t\t\t\t\tsc->sc_omlen);\n\t\t\t} else if (sc->sc_dleft == 0) {\n\t\t\t\t/*\n\t\t\t\t * The DMA operation was started for\n\t\t\t\t * a DATA transfer. Print a diagnostic\n\t\t\t\t * if the DMA counter and TC bit\n\t\t\t\t * appear to be out of sync.\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: !TC on DATA XFER\"\n\t\t\t\t       \" [intr %x, stat %x, step %d]\"\n\t\t\t\t       \" prevphase %x, resid %x\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase,\n\t\t\t\t\tecb?ecb->dleft:-1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * check for less serious errors\n\t */\n\tif (sc->sc_espstat & NCRSTAT_PE) {\n\t\tprintf(\"%s: SCSI bus parity error\\n\", sc->sc_dev.dv_xname);\n\t\tif (sc->sc_prevphase == MESSAGE_IN_PHASE)\n\t\t\tncr53c9x_sched_msgout(SEND_PARITY_ERROR);\n\t\telse\n\t\t\tncr53c9x_sched_msgout(SEND_INIT_DET_ERR);\n\t}\n\n\tif (sc->sc_espintr & NCRINTR_DIS) {\n\t\tNCR_MISC((\"<DISC [intr %x, stat %x, step %d]>\",\n\t\t\tsc->sc_espintr,sc->sc_espstat,sc->sc_espstep));\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\t/*\n\t\t * This command must (apparently) be issued within\n\t\t * 250mS of a disconnect. So here you are...\n\t\t */\n\t\tNCRCMD(sc, NCRCMD_ENSEL);\n\n\t\tswitch (sc->sc_state) {\n\t\tcase NCR_RESELECTED:\n\t\t\tgoto sched;\n\n\t\tcase NCR_SELECTING:\n\t\t\tecb->xs->error = XS_SELTIMEOUT;\n\t\t\tgoto finish;\n\n\t\tcase NCR_CONNECTED:\n\t\t\tif ((sc->sc_flags & NCR_SYNCHNEGO)) {\n#ifdef NCR53C9X_DEBUG\n\t\t\t\tif (ecb)\n\t\t\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\t\tprintf(\"sync nego not completed!\\n\");\n#endif\n\t\t\t\tti = &sc->sc_tinfo[ecb->xs->sc_link->target];\n\t\t\t\tsc->sc_flags &= ~NCR_SYNCHNEGO;\n\t\t\t\tti->flags &= ~(T_NEGOTIATE | T_SYNCMODE);\n\t\t\t}\n\n\t\t\t/* it may be OK to disconnect */\n\t\t\tif ((sc->sc_flags & NCR_ABORTING) == 0) {\n\t\t\t\t/*  \n\t\t\t\t * Section 5.1.1 of the SCSI 2 spec\n\t\t\t\t * suggests issuing a REQUEST SENSE\n\t\t\t\t * following an unexpected disconnect.\n\t\t\t\t * Some devices go into a contingent\n\t\t\t\t * allegiance condition when\n\t\t\t\t * disconnecting, and this is necessary\n\t\t\t\t * to clean up their state.\n\t\t\t\t */     \n\t\t\t\tprintf(\"%s: unexpected disconnect; \",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tif (ecb->flags & ECB_SENSE) {\n\t\t\t\t\tprintf(\"resetting\\n\");\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\tprintf(\"sending REQUEST SENSE\\n\");\n\t\t\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\t\t\tncr53c9x_sense(sc, ecb);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tgoto finish;\n\n\t\tcase NCR_DISCONNECT:\n\t\t\tTAILQ_INSERT_HEAD(&sc->nexus_list, ecb, chain);\n\t\t\tsc->sc_nexus = NULL;\n\t\t\tgoto sched;\n\n\t\tcase NCR_CMDCOMPLETE:\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\tswitch (sc->sc_state) {\n\n\tcase NCR_SBR:\n\t\tprintf(\"%s: waiting for SCSI Bus Reset to happen\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n\t\t\treturn (1);\n\n\tcase NCR_RESELECTED:\n\t\t/*\n\t\t * we must be continuing a message ?\n\t\t */\n\t\tif (sc->sc_phase != MESSAGE_IN_PHASE) {\n\t\t\tprintf(\"%s: target didn't identify\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t\treturn (1);\n\t\t}\nprintf(\"<<RESELECT CONT'd>>\");\n#if XXXX\n\t\tncr53c9x_msgin(sc);\n\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t/* IDENTIFY fail?! */\n\t\t\tprintf(\"%s: identify failed\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tncr53c9x_init(sc, 1);\n\t\t\treturn (1);\n\t\t}\n#endif\n\t\tbreak;\n\n\tcase NCR_IDLE:\n\tcase NCR_SELECTING:\n\t\tsc->sc_msgpriq = sc->sc_msgout = sc->sc_msgoutq = 0;\n\t\tsc->sc_flags = 0;\n\t\tecb = sc->sc_nexus;\n\t\tif (ecb != NULL && (ecb->flags & ECB_NEXUS)) {\n\t\t\tsc_print_addr(ecb->xs->sc_link);\n\t\t\tprintf(\"ECB_NEXUS while in state %x\\n\", sc->sc_state);\n\t\t}\n\n\t\tif (sc->sc_espintr & NCRINTR_RESEL) {\n\t\t\t/*\n\t\t\t * If we're trying to select a\n\t\t\t * target ourselves, push our command\n\t\t\t * back into the ready list.\n\t\t\t */\n\t\t\tif (sc->sc_state == NCR_SELECTING) {\n\t\t\t\tNCR_MISC((\"backoff selector \"));\n\t\t\t\tuntimeout(ncr53c9x_timeout, ecb);\n\t\t\t\tsc_link = ecb->xs->sc_link;\n\t\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\t\t\tTAILQ_INSERT_HEAD(&sc->ready_list, ecb, chain);\n\t\t\t\tecb = sc->sc_nexus = NULL;\n\t\t\t}\n\t\t\tsc->sc_state = NCR_RESELECTED;\n\t\t\tif (sc->sc_phase != MESSAGE_IN_PHASE) {\n\t\t\t\t/*\n\t\t\t\t * Things are seriously fucked up.\n\t\t\t\t * Pull the brakes, i.e. reset\n\t\t\t\t */\n\t\t\t\tprintf(\"%s: target didn't identify\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\t/*\n\t\t\t * The C90 only inhibits FIFO writes until\n\t\t\t * reselection is complete, instead of\n\t\t\t * waiting until the interrupt status register\n\t\t\t * has been read. So, if the reselect happens\n\t\t\t * while we were entering a command bytes (for\n\t\t\t * another target) some of those bytes can\n\t\t\t * appear in the FIFO here, after the\n\t\t\t * interrupt is taken.\n\t\t\t */\n\t\t\tnfifo = NCR_READ_REG(sc,NCR_FFLAG) & NCRFIFO_FF;\n\t\t\tif (nfifo < 2 ||\n\t\t\t    (nfifo > 2 &&\n\t\t\t     sc->sc_rev != NCR_VARIANT_ESP100)) {\n\t\t\t\tprintf(\"%s: RESELECT: \"\n\t\t\t\t    \"%d bytes in FIFO! \"\n\t\t\t\t    \"[intr %x, stat %x, step %d, prevphase %x]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tnfifo,\n\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep,\n\t\t\t\t\tsc->sc_prevphase);\n\t\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tsc->sc_selid = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tNCR_MISC((\"selid=0x%2x \", sc->sc_selid));\n\n\t\t\t/* Handle identify message */\n\t\t\tncr53c9x_msgin(sc);\n\t\t\tif (nfifo != 2) {\n\t\t\t\t/*\n\t\t\t\t * Note: this should not happen\n\t\t\t\t * with `dmaselect' on.\n\t\t\t\t */\n\t\t\t\tsc->sc_flags |= NCR_EXPECT_ILLCMD;\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t} else if (ncr53c9x_dmaselect &&\n\t\t\t\t   sc->sc_rev == NCR_VARIANT_ESP100) {\n\t\t\t\tsc->sc_flags |= NCR_EXPECT_ILLCMD;\n\t\t\t}\n\n\t\t\tif (sc->sc_state != NCR_CONNECTED) {\n\t\t\t\t/* IDENTIFY fail?! */\n\t\t\t\tprintf(\"%s: identify failed\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\tncr53c9x_init(sc, 1);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tgoto shortcut; /* ie. next phase expected soon */\n\t\t}\n\n#define\tNCRINTR_DONE\t(NCRINTR_FC|NCRINTR_BS)\n\t\tif ((sc->sc_espintr & NCRINTR_DONE) == NCRINTR_DONE) {\n\t\t\t/*\n\t\t\t * Arbitration won; examine the `step' register\n\t\t\t * to determine how far the selection could progress.\n\t\t\t */\n\t\t\tecb = sc->sc_nexus;\n\t\t\tif (!ecb)\n\t\t\t\tpanic(\"esp: no nexus\");\n\n\t\t\tsc_link = ecb->xs->sc_link;\n\t\t\tti = &sc->sc_tinfo[sc_link->target];\n\n\t\t\tswitch (sc->sc_espstep) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * The target did not respond with a\n\t\t\t\t * message out phase - probably an old\n\t\t\t\t * device that doesn't recognize ATN.\n\t\t\t\t * Clear ATN and just continue, the\n\t\t\t\t * target should be in the command\n\t\t\t\t * phase.\n\t\t\t\t * XXXX check for command phase?\n\t\t\t\t */\n\t\t\t\tNCRCMD(sc, NCRCMD_RSTATN);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif ((ti->flags & T_NEGOTIATE) == 0) {\n\t\t\t\t\tprintf(\"%s: step 1 & !NEG\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\tif (sc->sc_phase != MESSAGE_OUT_PHASE) {\n\t\t\t\t\tprintf(\"%s: !MSGOUT\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\t\tgoto reset;\n\t\t\t\t}\n\t\t\t\t/* Start negotiating */\n\t\t\t\tti->period = sc->sc_minsync;\n\t\t\t\tti->offset = 15;\n\t\t\t\tsc->sc_flags |= NCR_SYNCHNEGO;\n\t\t\t\tncr53c9x_sched_msgout(SEND_SDTR);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t/*\n\t\t\t\t * Grr, this is supposed to mean\n\t\t\t\t * \"target left command phase  prematurely\".\n\t\t\t\t * It seems to happen regularly when\n\t\t\t\t * sync mode is on.\n\t\t\t\t * Look at FIFO to see if command went out.\n\t\t\t\t * (Timing problems?)\n\t\t\t\t */\n\t\t\t\tif (ncr53c9x_dmaselect) {\n\t\t\t\t\tif (sc->sc_cmdlen == 0)\n\t\t\t\t\t\t/* Hope for the best.. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if ((NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t    & NCRFIFO_FF) == 0) {\n\t\t\t\t\t\t/* Hope for the best.. */\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"(%s:%d:%d): selection failed;\"\n\t\t\t\t\t\" %d left in FIFO \"\n\t\t\t\t\t\"[intr %x, stat %x, step %d]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc_link->target,\n\t\t\t\t\tsc_link->lun,\n\t\t\t\t\tNCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t & NCRFIFO_FF,\n\t\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep);\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\t\tncr53c9x_sched_msgout(SEND_ABORT);\n\t\t\t\treturn (1);\n\t\t\tcase 2:\n\t\t\t\t/* Select stuck at Command Phase */\n\t\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tcase 4:\n\t\t\t\tif (ncr53c9x_dmaselect &&\n\t\t\t\t    sc->sc_cmdlen != 0)\n\t\t\t\t\tprintf(\"(%s:%d:%d): select; \"\n\t\t\t\t\t       \"%d left in DMA buffer \"\n\t\t\t\t\t\"[intr %x, stat %x, step %d]\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tsc_link->target,\n\t\t\t\t\t\tsc_link->lun,\n\t\t\t\t\t\tsc->sc_cmdlen,\n\t\t\t\t\t\tsc->sc_espintr,\n\t\t\t\t\t\tsc->sc_espstat,\n\t\t\t\t\t\tsc->sc_espstep);\n\t\t\t\t/* So far, everything went fine */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tecb->flags |= ECB_NEXUS;\n\t\t\tti->lubusy |= (1 << sc_link->lun);\n\n\t\t\tsc->sc_prevphase = INVALID_PHASE; /* ?? */\n\t\t\t/* Do an implicit RESTORE POINTERS. */\n\t\t\tsc->sc_dp = ecb->daddr;\n\t\t\tsc->sc_dleft = ecb->dleft;\n\t\t\tsc->sc_state = NCR_CONNECTED;\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\tprintf(\"%s: unexpected status after select\"\n\t\t\t\t\": [intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t\tgoto reset;\n\t\t}\n\t\tif (sc->sc_state == NCR_IDLE) {\n\t\t\tprintf(\"%s: stray interrupt\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\n\tcase NCR_CONNECTED:\n\t\tif (sc->sc_flags & NCR_ICCS) {\n\t\t\t/* \"Initiate Command Complete Steps\" in progress */\n\t\t\tu_char msg;\n\n\t\t\tsc->sc_flags &= ~NCR_ICCS;\n\n\t\t\tif (!(sc->sc_espintr & NCRINTR_DONE)) {\n\t\t\t\tprintf(\"%s: ICCS: \"\n\t\t\t\t      \": [intr %x, stat %x, step %x]\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\t\tsc->sc_espstep);\n\t\t\t}\n\t\t\tif ((NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t    & NCRFIFO_FF) != 2) {\n\t\t\t\tint i = (NCR_READ_REG(sc, NCR_FFLAG)\n\t\t\t\t\t    & NCRFIFO_FF) - 2;\n\t\t\t\twhile (i--)\n\t\t\t\t\t(void) NCR_READ_REG(sc, NCR_FIFO);\n\t\t\t}\n\t\t\tecb->stat = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tmsg = NCR_READ_REG(sc, NCR_FIFO);\n\t\t\tNCR_PHASE((\"<stat:(%x,%x)>\", ecb->stat, msg));\n\t\t\tif (msg == MSG_CMDCOMPLETE) {\n\t\t\t\tecb->dleft = (ecb->flags & ECB_TENTATIVE_DONE)\n\t\t\t\t\t? 0\n\t\t\t\t\t: sc->sc_dleft;\n\t\t\t\tif ((ecb->flags & ECB_SENSE) == 0)\n\t\t\t\t\tecb->xs->resid = ecb->dleft;\n\t\t\t\tsc->sc_state = NCR_CMDCOMPLETE;\n\t\t\t} else\n\t\t\t\tprintf(\"%s: STATUS_PHASE: msg %d\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname, msg);\n\t\t\tNCRCMD(sc, NCRCMD_MSGOK);\n\t\t\tgoto shortcut; /* ie. wait for disconnect */\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpanic(\"%s: invalid state: %d\",\n\t\t      sc->sc_dev.dv_xname,\n\t\t      sc->sc_state);\n\t}\n\n\t/*\n\t * Driver is now in state NCR_CONNECTED, i.e. we\n\t * have a current command working the SCSI bus.\n\t */\n\tif (sc->sc_state != NCR_CONNECTED || ecb == NULL) {\n\t\tpanic(\"esp no nexus\");\n\t}\n\n\tswitch (sc->sc_phase) {\n\tcase MESSAGE_OUT_PHASE:\n\t\tNCR_PHASE((\"MESSAGE_OUT_PHASE \"));\n\t\tncr53c9x_msgout(sc);\n\t\tsc->sc_prevphase = MESSAGE_OUT_PHASE;\n\t\tbreak;\n\tcase MESSAGE_IN_PHASE:\n\t\tNCR_PHASE((\"MESSAGE_IN_PHASE \"));\n\t\tsc->sc_prevphase = MESSAGE_IN_PHASE;\n\t\tif (sc->sc_espintr & NCRINTR_BS) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tsc->sc_flags |= NCR_WAITI;\n\t\t\tNCRCMD(sc, NCRCMD_TRANS);\n\t\t} else if (sc->sc_espintr & NCRINTR_FC) {\n\t\t\tif ((sc->sc_flags & NCR_WAITI) == 0) {\n\t\t\t\tprintf(\"%s: MSGIN: unexpected FC bit: \"\n\t\t\t\t\t\"[intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t\t}\n\t\t\tsc->sc_flags &= ~NCR_WAITI;\n\t\t\tncr53c9x_msgin(sc);\n\t\t} else {\n\t\t\tprintf(\"%s: MSGIN: weird bits: \"\n\t\t\t\t\"[intr %x, stat %x, step %x]\\n\",\n\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\tsc->sc_espintr, sc->sc_espstat,\n\t\t\t\tsc->sc_espstep);\n\t\t}\n\t\tgoto shortcut;\t/* i.e. expect data to be ready */\n\t\tbreak;\n\tcase COMMAND_PHASE:\n\t\t/*\n\t\t * Send the command block. Normally we don't see this\n\t\t * phase because the SEL_ATN command takes care of\n\t\t * all this. However, we end up here if either the\n\t\t * target or we wanted to exchange some more messages\n\t\t * first (e.g. to start negotiations).\n\t\t */\n\n\t\tNCR_PHASE((\"COMMAND_PHASE 0x%02x (%d) \",\n\t\t\tecb->cmd.cmd.opcode, ecb->clen));\n\t\tif (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF) {\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\t\tDELAY(1);\n\t\t}\n\t\tif (ncr53c9x_dmaselect) {\n\t\t\tsize_t size;\n\t\t\t/* setup DMA transfer for command */\n\t\t\tsize = ecb->clen;\n\t\t\tsc->sc_cmdlen = size;\n\t\t\tsc->sc_cmdp = (caddr_t)&ecb->cmd.cmd;\n\t\t\tNCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen,\n\t\t\t\t     0, &size);\n\t\t\t/* Program the SCSI counter */\n\t\t\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\t\t\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\t\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t\t\t}\n\n\t\t\t/* load the count in */\n\t\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t\t/* start the command transfer */\n\t\t\tNCRCMD(sc, NCRCMD_TRANS | NCRCMD_DMA);\n\t\t\tNCRDMA_GO(sc);\n\t\t} else {\n\t\t\tu_char *cmd = (u_char *)&ecb->cmd.cmd;\n\t\t\tint i;\n\t\t\t/* Now the command into the FIFO */\n\t\t\tfor (i = 0; i < ecb->clen; i++)\n\t\t\t\tNCR_WRITE_REG(sc, NCR_FIFO, *cmd++);\n\t\t\tNCRCMD(sc, NCRCMD_TRANS);\n\t\t}\n\t\tsc->sc_prevphase = COMMAND_PHASE;\n\t\tbreak;\n\tcase DATA_OUT_PHASE:\n\t\tNCR_PHASE((\"DATA_OUT_PHASE [%ld] \",(long)sc->sc_dleft));\n\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\tsize = min(sc->sc_dleft, sc->sc_maxxfer);\n\t\tNCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,\n\t\t\t  0, &size);\n\t\tsc->sc_prevphase = DATA_OUT_PHASE;\n\t\tgoto setup_xfer;\n\tcase DATA_IN_PHASE:\n\t\tNCR_PHASE((\"DATA_IN_PHASE \"));\n\t\tif (sc->sc_rev == NCR_VARIANT_ESP100)\n\t\t\tNCRCMD(sc, NCRCMD_FLUSH);\n\t\tsize = min(sc->sc_dleft, sc->sc_maxxfer);\n\t\tNCRDMA_SETUP(sc, &sc->sc_dp, &sc->sc_dleft,\n\t\t\t  1, &size);\n\t\tsc->sc_prevphase = DATA_IN_PHASE;\n\tsetup_xfer:\n\t\t/* Target returned to data phase: wipe \"done\" memory */\n\t\tecb->flags &= ~ECB_TENTATIVE_DONE;\n\n\t\t/* Program the SCSI counter */\n\t\tNCR_WRITE_REG(sc, NCR_TCL, size);\n\t\tNCR_WRITE_REG(sc, NCR_TCM, size >> 8);\n\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\tNCR_WRITE_REG(sc, NCR_TCH, size >> 16);\n\t\t}\n\t\t/* load the count in */\n\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t/*\n\t\t * Note that if `size' is 0, we've already transceived\n\t\t * all the bytes we want but we're still in DATA PHASE.\n\t\t * Apparently, the device needs padding. Also, a\n\t\t * transfer size of 0 means \"maximum\" to the chip\n\t\t * DMA logic.\n\t\t */\n\t\tNCRCMD(sc,\n\t\t       (size==0?NCRCMD_TRPAD:NCRCMD_TRANS)|NCRCMD_DMA);\n\t\tNCRDMA_GO(sc);\n\t\treturn (1);\n\tcase STATUS_PHASE:\n\t\tNCR_PHASE((\"STATUS_PHASE \"));\n\t\tsc->sc_flags |= NCR_ICCS;\n\t\tNCRCMD(sc, NCRCMD_ICCS);\n\t\tsc->sc_prevphase = STATUS_PHASE;\n\t\tbreak;\n\tcase INVALID_PHASE:\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unexpected bus phase; resetting\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tgoto reset;\n\t}\n\nout:\n\treturn (1);\n\nreset:\n\tncr53c9x_init(sc, 1);\n\tgoto out;\n\nfinish:\n\tncr53c9x_done(sc, ecb);\n\tgoto out;\n\nsched:\n\tsc->sc_state = NCR_IDLE;\n\tncr53c9x_sched(sc);\n\tgoto out;\n\nshortcut:\n\t/*\n\t * The idea is that many of the SCSI operations take very little\n\t * time, and going away and getting interrupted is too high an\n\t * overhead to pay. For example, selecting, sending a message\n\t * and command and then doing some work can be done in one \"pass\".\n\t *\n\t * The delay is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1\n\t * at 40Mhz. This needs testing.\n\t */\n\tDELAY(50/sc->sc_freq);\n\tif (NCRDMA_ISINTR(sc))\n\t\tgoto again;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_STAT"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_ISINTR",
          "args": [
            "sc"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "(\"[ncr53c9x_poll] \")"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tncr53c9x_poll;\nvoid\tncr53c9x_sched;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nint\nncr53c9x_poll(sc, xs, count)\n\tstruct ncr53c9x_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\n\tNCR_TRACE((\"[ncr53c9x_poll] \"));\n\twhile (count) {\n\t\tif (NCRDMA_ISINTR(sc)) {\n\t\t\tncr53c9x_intr(sc);\n\t\t}\n#if alternatively\n\t\tif (NCR_READ_REG(sc, NCR_STAT) & NCRSTAT_INT)\n\t\t\tncr53c9x_intr(sc);\n#endif\n\t\tif ((xs->flags & ITSDONE) != 0)\n\t\t\treturn (0);\n\t\tif (sc->sc_state == NCR_IDLE) {\n\t\t\tNCR_TRACE((\"[ncr53c9x_poll: rescheduling] \"));\n\t\t\tncr53c9x_sched(sc);\n\t\t}\n\t\tDELAY(1000);\n\t\tcount--;\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "ncr53c9x_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "592-643",
    "snippet": "int\nncr53c9x_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_softc *sc = sc_link->adapter_softc;\n\tstruct ncr53c9x_ecb *ecb;\n\tint s, flags;\n\n\tNCR_TRACE((\"[ncr53c9x_scsi_cmd] \"));\n\tNCR_CMDS((\"[0x%x, %d]->%d \", (int)xs->cmd->opcode, xs->cmdlen,\n\t    sc_link->target));\n\n\tflags = xs->flags;\n\tif ((ecb = ncr53c9x_get_ecb(sc, flags)) == NULL)\n\t\treturn (TRY_AGAIN_LATER);\n\n\t/* Initialize ecb */\n\tecb->xs = xs;\n\tecb->timeout = xs->timeout;\n\n\tif (flags & SCSI_RESET) {\n\t\tecb->flags |= ECB_RESET;\n\t\tecb->clen = 0;\n\t\tecb->dleft = 0;\n\t} else {\n\t\tbcopy(xs->cmd, &ecb->cmd.cmd, xs->cmdlen);\n\t\tecb->clen = xs->cmdlen;\n\t\tecb->daddr = xs->data;\n\t\tecb->dleft = xs->datalen;\n\t}\n\tecb->stat = 0;\n\n\ts = splbio();\n\n\tTAILQ_INSERT_TAIL(&sc->ready_list, ecb, chain);\n\tif (sc->sc_state == NCR_IDLE)\n\t\tncr53c9x_sched(sc);\n\n\tsplx(s);\n\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t/* Not allowed to use interrupts, use polling instead */\n\tif (ncr53c9x_poll(sc, xs, ecb->timeout)) {\n\t\tncr53c9x_timeout(ecb);\n\t\tif (ncr53c9x_poll(sc, xs, ecb->timeout))\n\t\t\tncr53c9x_timeout(ecb);\n\t}\n\treturn (COMPLETE);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tncr53c9x_poll",
      "void\tncr53c9x_sched",
      "void\tncr53c9x_timeout",
      "struct ncr53c9x_ecb *ncr53c9x_get_ecb",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr53c9x_timeout",
          "args": [
            "ecb"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "2102-2152",
          "snippet": "void\nncr53c9x_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ncr53c9x_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_softc *sc = sc_link->adapter_softc;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], \"\n\t       \"<state %d, nexus %p, phase(l %x, c %x, p %x), resid %lx, \"\n\t       \"msg(q %x,o %x) %s>\",\n\t\tsc->sc_dev.dv_xname,\n\t\tecb, ecb->flags, ecb->dleft, ecb->stat,\n\t\tsc->sc_state, sc->sc_nexus,\n\t\tNCR_READ_REG(sc, NCR_STAT),\n\t\tsc->sc_phase, sc->sc_prevphase,\n\t\t(long)sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,\n\t\tNCRDMA_ISACTIVE(sc) ? \"DMA active\" : \"\");\n#if NCR53C9X_DEBUG > 1\n\tprintf(\"TRACE: %s.\", ecb->trace);\n#endif\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\n\t\tncr53c9x_init(sc, 1);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tncr53c9x_abort(sc, ecb);\n\n\t\t/* Disable sync mode if stuck in a data phase */\n\t\tif (ecb == sc->sc_nexus &&\n\t\t    (ti->flags & T_SYNCMODE) != 0 &&\n\t\t    (sc->sc_phase & (MSGI|CDI)) == 0) {\n\t\t\tsc_print_addr(sc_link);\n\t\t\tprintf(\"sync negotiation disabled\\n\");\n\t\t\tsc->sc_cfflags |= (1<<(sc_link->target+8));\n\t\t}\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_init",
            "void\tncr53c9x_timeout",
            "void\tncr53c9x_abort",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_timeout;\nvoid\tncr53c9x_abort;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ncr53c9x_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_softc *sc = sc_link->adapter_softc;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], \"\n\t       \"<state %d, nexus %p, phase(l %x, c %x, p %x), resid %lx, \"\n\t       \"msg(q %x,o %x) %s>\",\n\t\tsc->sc_dev.dv_xname,\n\t\tecb, ecb->flags, ecb->dleft, ecb->stat,\n\t\tsc->sc_state, sc->sc_nexus,\n\t\tNCR_READ_REG(sc, NCR_STAT),\n\t\tsc->sc_phase, sc->sc_prevphase,\n\t\t(long)sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,\n\t\tNCRDMA_ISACTIVE(sc) ? \"DMA active\" : \"\");\n#if NCR53C9X_DEBUG > 1\n\tprintf(\"TRACE: %s.\", ecb->trace);\n#endif\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\n\t\tncr53c9x_init(sc, 1);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tncr53c9x_abort(sc, ecb);\n\n\t\t/* Disable sync mode if stuck in a data phase */\n\t\tif (ecb == sc->sc_nexus &&\n\t\t    (ti->flags & T_SYNCMODE) != 0 &&\n\t\t    (sc->sc_phase & (MSGI|CDI)) == 0) {\n\t\t\tsc_print_addr(sc_link);\n\t\t\tprintf(\"sync negotiation disabled\\n\");\n\t\t\tsc->sc_cfflags |= (1<<(sc_link->target+8));\n\t\t}\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_poll",
          "args": [
            "sc",
            "xs",
            "ecb->timeout"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "648-674",
          "snippet": "int\nncr53c9x_poll(sc, xs, count)\n\tstruct ncr53c9x_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\n\tNCR_TRACE((\"[ncr53c9x_poll] \"));\n\twhile (count) {\n\t\tif (NCRDMA_ISINTR(sc)) {\n\t\t\tncr53c9x_intr(sc);\n\t\t}\n#if alternatively\n\t\tif (NCR_READ_REG(sc, NCR_STAT) & NCRSTAT_INT)\n\t\t\tncr53c9x_intr(sc);\n#endif\n\t\tif ((xs->flags & ITSDONE) != 0)\n\t\t\treturn (0);\n\t\tif (sc->sc_state == NCR_IDLE) {\n\t\t\tNCR_TRACE((\"[ncr53c9x_poll: rescheduling] \"));\n\t\t\tncr53c9x_sched(sc);\n\t\t}\n\t\tDELAY(1000);\n\t\tcount--;\n\t}\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tncr53c9x_poll",
            "void\tncr53c9x_sched",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tncr53c9x_poll;\nvoid\tncr53c9x_sched;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nint\nncr53c9x_poll(sc, xs, count)\n\tstruct ncr53c9x_softc *sc;\n\tstruct scsi_xfer *xs;\n\tint count;\n{\n\n\tNCR_TRACE((\"[ncr53c9x_poll] \"));\n\twhile (count) {\n\t\tif (NCRDMA_ISINTR(sc)) {\n\t\t\tncr53c9x_intr(sc);\n\t\t}\n#if alternatively\n\t\tif (NCR_READ_REG(sc, NCR_STAT) & NCRSTAT_INT)\n\t\t\tncr53c9x_intr(sc);\n#endif\n\t\tif ((xs->flags & ITSDONE) != 0)\n\t\t\treturn (0);\n\t\tif (sc->sc_state == NCR_IDLE) {\n\t\t\tNCR_TRACE((\"[ncr53c9x_poll: rescheduling] \"));\n\t\t\tncr53c9x_sched(sc);\n\t\t}\n\t\tDELAY(1000);\n\t\tcount--;\n\t}\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_sched",
          "args": [
            "sc"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "687-716",
          "snippet": "void\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_sched",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->ready_list",
            "ecb",
            "chain"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "xs->cmd",
            "&ecb->cmd.cmd",
            "xs->cmdlen"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_get_ecb",
          "args": [
            "sc",
            "flags"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_CMDS",
          "args": [
            "(\"[0x%x, %d]->%d \", (int)xs->cmd->opcode, xs->cmdlen,\n\t    sc_link->target)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "(\"[ncr53c9x_scsi_cmd] \")"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tncr53c9x_poll;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_timeout;\nstruct ncr53c9x_ecb *ncr53c9x_get_ecb;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nint\nncr53c9x_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_softc *sc = sc_link->adapter_softc;\n\tstruct ncr53c9x_ecb *ecb;\n\tint s, flags;\n\n\tNCR_TRACE((\"[ncr53c9x_scsi_cmd] \"));\n\tNCR_CMDS((\"[0x%x, %d]->%d \", (int)xs->cmd->opcode, xs->cmdlen,\n\t    sc_link->target));\n\n\tflags = xs->flags;\n\tif ((ecb = ncr53c9x_get_ecb(sc, flags)) == NULL)\n\t\treturn (TRY_AGAIN_LATER);\n\n\t/* Initialize ecb */\n\tecb->xs = xs;\n\tecb->timeout = xs->timeout;\n\n\tif (flags & SCSI_RESET) {\n\t\tecb->flags |= ECB_RESET;\n\t\tecb->clen = 0;\n\t\tecb->dleft = 0;\n\t} else {\n\t\tbcopy(xs->cmd, &ecb->cmd.cmd, xs->cmdlen);\n\t\tecb->clen = xs->cmdlen;\n\t\tecb->daddr = xs->data;\n\t\tecb->dleft = xs->datalen;\n\t}\n\tecb->stat = 0;\n\n\ts = splbio();\n\n\tTAILQ_INSERT_TAIL(&sc->ready_list, ecb, chain);\n\tif (sc->sc_state == NCR_IDLE)\n\t\tncr53c9x_sched(sc);\n\n\tsplx(s);\n\n\tif ((flags & SCSI_POLL) == 0)\n\t\treturn (SUCCESSFULLY_QUEUED);\n\n\t/* Not allowed to use interrupts, use polling instead */\n\tif (ncr53c9x_poll(sc, xs, ecb->timeout)) {\n\t\tncr53c9x_timeout(ecb);\n\t\tif (ncr53c9x_poll(sc, xs, ecb->timeout))\n\t\t\tncr53c9x_timeout(ecb);\n\t}\n\treturn (COMPLETE);\n}"
  },
  {
    "function_name": "ncr53c9x_free_ecb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "538-559",
    "snippet": "void\nncr53c9x_free_ecb(sc, ecb, flags)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tecb->flags = 0;\n\tTAILQ_INSERT_HEAD(&sc->free_list, ecb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ecb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_list);\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ncr53c9x_free_ecb",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "&sc->free_list"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "rln_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "171-214",
          "snippet": "u_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_int8_t\nrln_wakeup(sc, wnew)\n\tstruct rln_softc *\tsc;\n\tu_int8_t\t\twnew;\n{\n\tu_int8_t\t\twold, s;\n\tint\t\t\ti;\n\n\t/* Save what the last-written values were. */\n\twold = (sc->sc_status & RLN_STATUS_WAKEUP) |\n\t    (sc->sc_control & RLN_CONTROL_RESET);\n\n\tif (wnew == RLN_WAKEUP_SET) {\n\t\t/* SetWakeupBit() */\n\t\tdprintf(\" Ws[\");\n\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\tif (0/*LLDInactivityTimeOut &&\n\t\t    (sc->sc_cardtype & RLN_CTYPE_OEM)*/) {\n\t\t\tdprintf (\" 167ms\");\n\t\t\tDELAY(167000);\n\t\t} else {\n\t\t\tdprintf (\" .1ms\");\n\t\t\tDELAY(100);\n\t\t}\n\t\ts = rln_status_read(sc);\n\t\trln_control_set(sc, RLN_CONTROL_RESET);\n\t\tif ((s & RLN_STATUS_WAKEUP) != 0)\n\t\t\tfor (i = 0; i < 9; i++) {\n\t\t\t\tdprintf(\" 2ms\");\n\t\t\t\tDELAY(2000);\n\t\t\t\trln_status_set(sc, RLN_STATUS_WAKEUP);\n\t\t\t}\n\t\tdprintf(\"]\");\n\t} else {\n\t\t/* ClearWakeupBit() */\n\t\tdprintf(\" Wc[\");\n\t\tif ((wnew & RLN_STATUS_WAKEUP) == 0)\n\t\t\trln_status_clear(sc, RLN_STATUS_WAKEUP);\n\t\tif ((wnew & RLN_CONTROL_RESET) == 0)\n\t\t\trln_control_clear(sc, RLN_CONTROL_RESET);\n\t\tdprintf(\"]\");\n\t}\n\treturn (wold);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_HEAD",
          "args": [
            "&sc->free_list",
            "ecb",
            "chain"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid ncr53c9x_free_ecb;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_free_ecb(sc, ecb, flags)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n\tint flags;\n{\n\tint s;\n\n\ts = splbio();\n\n\tecb->flags = 0;\n\tTAILQ_INSERT_HEAD(&sc->free_list, ecb, chain);\n\n\t/*\n\t * If there were none, wake anybody waiting for one to come free,\n\t * starting with queued entries.\n\t */\n\tif (ecb->chain.tqe_next == 0)\n\t\twakeup(&sc->free_list);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "ncr53c9x_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "453-536",
    "snippet": "void\nncr53c9x_select(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_link *sc_link = ecb->xs->sc_link;\n\tint target = sc_link->target;\n\tint lun = sc_link->lun;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[target];\n\tint tiflags = ti->flags;\n\tu_char *cmd;\n\tint clen;\n\n\tNCR_TRACE((\"[ncr53c9x_select(t%d,l%d,cmd:%x)] \",\n\t\t   target, lun, ecb->cmd.cmd.opcode));\n\n\tsc->sc_state = NCR_SELECTING;\n\n\t/*\n\t * Schedule the timeout now, the first time we will go away\n\t * expecting to come back due to an interrupt, because it is\n\t * always possible that the interrupt may never happen.\n\t */\n\tif ((ecb->xs->flags & SCSI_POLL) == 0)\n\t\ttimeout(ncr53c9x_timeout, ecb,\n\t\t    (ecb->timeout * hz) / 1000);\n\n\t/*\n\t * The docs say the target register is never reset, and I\n\t * can't think of a better place to set it\n\t */\n\tNCR_WRITE_REG(sc, NCR_SELID, target);\n\tncr53c9x_setsync(sc, ti);\n\n\tif (ncr53c9x_dmaselect && (tiflags & T_NEGOTIATE) == 0) {\n\t\tsize_t dmasize;\n\n\t\tecb->cmd.id = \n\t\t    MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1);\n\n\t\t/* setup DMA transfer for command */\n\t\tdmasize = clen = ecb->clen + 1;\n\t\tsc->sc_cmdlen = clen;\n\t\tsc->sc_cmdp = (caddr_t)&ecb->cmd;\n\t\tNCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);\n\n\t\t/* Program the SCSI counter */\n\t\tNCR_WRITE_REG(sc, NCR_TCL, dmasize);\n\t\tNCR_WRITE_REG(sc, NCR_TCM, dmasize >> 8);\n\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\tNCR_WRITE_REG(sc, NCR_TCH, dmasize >> 16);\n\t\t}\n\n\t\t/* load the count in */\n\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t/* And get the targets attention */\n\t\tNCRCMD(sc, NCRCMD_SELATN | NCRCMD_DMA);\n\t\tNCRDMA_GO(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * Who am I. This is where we tell the target that we are\n\t * happy for it to disconnect etc.\n\t */\n\tNCR_WRITE_REG(sc, NCR_FIFO,\n\t\t\tMSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1));\n\n\tif (ti->flags & T_NEGOTIATE) {\n\t\t/* Arbitrate, select and stop after IDENTIFY message */\n\t\tNCRCMD(sc, NCRCMD_SELATNS);\n\t\treturn;\n\t}\n\n\t/* Now the command into the FIFO */\n\tcmd = (u_char *)&ecb->cmd.cmd;\n\tclen = ecb->clen;\n\twhile (clen--)\n\t\tNCR_WRITE_REG(sc, NCR_FIFO, *cmd++);\n\n\t/* And get the targets attention */\n\tNCRCMD(sc, NCRCMD_SELATN);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tncr53c9x_select",
      "void\tncr53c9x_timeout",
      "static inline void ncr53c9x_setsync",
      "int ncr53c9x_dmaselect = 0;",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_SELATN"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_FIFO",
            "*cmd++"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_SELATNS"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_FIFO",
            "MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSG_IDENTIFY",
          "args": [
            "lun",
            "(tiflags & T_RSELECTOFF)?0:1"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_GO",
          "args": [
            "sc"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_SELATN | NCRCMD_DMA"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_NOP|NCRCMD_DMA"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCH",
            "dmasize >> 16"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCM",
            "dmasize >> 8"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TCL",
            "dmasize"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_SETUP",
          "args": [
            "sc",
            "&sc->sc_cmdp",
            "&sc->sc_cmdlen",
            "0",
            "&dmasize"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSG_IDENTIFY",
          "args": [
            "lun",
            "(tiflags & T_RSELECTOFF)?0:1"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_setsync",
          "args": [
            "sc",
            "ti"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_setsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "415-443",
          "snippet": "static inline void\nncr53c9x_setsync(sc, ti)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_tinfo *ti;\n{\n\tu_char syncoff, synctp, cfg3 = sc->sc_cfg3;\n\n\tif (ti->flags & T_SYNCMODE) {\n\t\tsyncoff = ti->offset;\n\t\tsynctp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\tif (sc->sc_features & NCR_F_FASTSCSI) {\n\t\t\t/*\n\t\t\t * If the period is 200ns or less (ti->period <= 50),\n\t\t\t * put the chip in Fast SCSI mode.\n\t\t\t */\n\t\t\tif (ti->period <= 50)\n\t\t\t\tcfg3 |= NCRCFG3_FSCSI;\n\t\t}\n\t} else {\n\t\tsyncoff = 0;\n\t\tsynctp = 0;\n\t}\n\n\tif (sc->sc_features & NCR_F_HASCFG3)\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, cfg3);\n\n\tNCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);\n\tNCR_WRITE_REG(sc, NCR_SYNCTP, synctp);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline int ncr53c9x_stp2cpb",
            "static inline void ncr53c9x_setsync",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline int ncr53c9x_stp2cpb;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nstatic inline void\nncr53c9x_setsync(sc, ti)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_tinfo *ti;\n{\n\tu_char syncoff, synctp, cfg3 = sc->sc_cfg3;\n\n\tif (ti->flags & T_SYNCMODE) {\n\t\tsyncoff = ti->offset;\n\t\tsynctp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\tif (sc->sc_features & NCR_F_FASTSCSI) {\n\t\t\t/*\n\t\t\t * If the period is 200ns or less (ti->period <= 50),\n\t\t\t * put the chip in Fast SCSI mode.\n\t\t\t */\n\t\t\tif (ti->period <= 50)\n\t\t\t\tcfg3 |= NCRCFG3_FSCSI;\n\t\t}\n\t} else {\n\t\tsyncoff = 0;\n\t\tsynctp = 0;\n\t}\n\n\tif (sc->sc_features & NCR_F_HASCFG3)\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, cfg3);\n\n\tNCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);\n\tNCR_WRITE_REG(sc, NCR_SYNCTP, synctp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_SELID",
            "target"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ncr53c9x_timeout",
            "ecb",
            "(ecb->timeout * hz) / 1000"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "2102-2152",
          "snippet": "void\nncr53c9x_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ncr53c9x_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_softc *sc = sc_link->adapter_softc;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], \"\n\t       \"<state %d, nexus %p, phase(l %x, c %x, p %x), resid %lx, \"\n\t       \"msg(q %x,o %x) %s>\",\n\t\tsc->sc_dev.dv_xname,\n\t\tecb, ecb->flags, ecb->dleft, ecb->stat,\n\t\tsc->sc_state, sc->sc_nexus,\n\t\tNCR_READ_REG(sc, NCR_STAT),\n\t\tsc->sc_phase, sc->sc_prevphase,\n\t\t(long)sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,\n\t\tNCRDMA_ISACTIVE(sc) ? \"DMA active\" : \"\");\n#if NCR53C9X_DEBUG > 1\n\tprintf(\"TRACE: %s.\", ecb->trace);\n#endif\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\n\t\tncr53c9x_init(sc, 1);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tncr53c9x_abort(sc, ecb);\n\n\t\t/* Disable sync mode if stuck in a data phase */\n\t\tif (ecb == sc->sc_nexus &&\n\t\t    (ti->flags & T_SYNCMODE) != 0 &&\n\t\t    (sc->sc_phase & (MSGI|CDI)) == 0) {\n\t\t\tsc_print_addr(sc_link);\n\t\t\tprintf(\"sync negotiation disabled\\n\");\n\t\t\tsc->sc_cfflags |= (1<<(sc_link->target+8));\n\t\t}\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_init",
            "void\tncr53c9x_timeout",
            "void\tncr53c9x_abort",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_timeout;\nvoid\tncr53c9x_abort;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_timeout(arg)\n\tvoid *arg;\n{\n\tstruct ncr53c9x_ecb *ecb = arg;\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_softc *sc = sc_link->adapter_softc;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], \"\n\t       \"<state %d, nexus %p, phase(l %x, c %x, p %x), resid %lx, \"\n\t       \"msg(q %x,o %x) %s>\",\n\t\tsc->sc_dev.dv_xname,\n\t\tecb, ecb->flags, ecb->dleft, ecb->stat,\n\t\tsc->sc_state, sc->sc_nexus,\n\t\tNCR_READ_REG(sc, NCR_STAT),\n\t\tsc->sc_phase, sc->sc_prevphase,\n\t\t(long)sc->sc_dleft, sc->sc_msgpriq, sc->sc_msgout,\n\t\tNCRDMA_ISACTIVE(sc) ? \"DMA active\" : \"\");\n#if NCR53C9X_DEBUG > 1\n\tprintf(\"TRACE: %s.\", ecb->trace);\n#endif\n\n\ts = splbio();\n\n\tif (ecb->flags & ECB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\n\t\tncr53c9x_init(sc, 1);\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\txs->error = XS_TIMEOUT;\n\t\tncr53c9x_abort(sc, ecb);\n\n\t\t/* Disable sync mode if stuck in a data phase */\n\t\tif (ecb == sc->sc_nexus &&\n\t\t    (ti->flags & T_SYNCMODE) != 0 &&\n\t\t    (sc->sc_phase & (MSGI|CDI)) == 0) {\n\t\t\tsc_print_addr(sc_link);\n\t\t\tprintf(\"sync negotiation disabled\\n\");\n\t\t\tsc->sc_cfflags |= (1<<(sc_link->target+8));\n\t\t}\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "(\"[ncr53c9x_select(t%d,l%d,cmd:%x)] \",\n\t\t   target, lun, ecb->cmd.cmd.opcode)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_timeout;\nstatic inline void ncr53c9x_setsync;\nint ncr53c9x_dmaselect = 0;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_select(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_link *sc_link = ecb->xs->sc_link;\n\tint target = sc_link->target;\n\tint lun = sc_link->lun;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[target];\n\tint tiflags = ti->flags;\n\tu_char *cmd;\n\tint clen;\n\n\tNCR_TRACE((\"[ncr53c9x_select(t%d,l%d,cmd:%x)] \",\n\t\t   target, lun, ecb->cmd.cmd.opcode));\n\n\tsc->sc_state = NCR_SELECTING;\n\n\t/*\n\t * Schedule the timeout now, the first time we will go away\n\t * expecting to come back due to an interrupt, because it is\n\t * always possible that the interrupt may never happen.\n\t */\n\tif ((ecb->xs->flags & SCSI_POLL) == 0)\n\t\ttimeout(ncr53c9x_timeout, ecb,\n\t\t    (ecb->timeout * hz) / 1000);\n\n\t/*\n\t * The docs say the target register is never reset, and I\n\t * can't think of a better place to set it\n\t */\n\tNCR_WRITE_REG(sc, NCR_SELID, target);\n\tncr53c9x_setsync(sc, ti);\n\n\tif (ncr53c9x_dmaselect && (tiflags & T_NEGOTIATE) == 0) {\n\t\tsize_t dmasize;\n\n\t\tecb->cmd.id = \n\t\t    MSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1);\n\n\t\t/* setup DMA transfer for command */\n\t\tdmasize = clen = ecb->clen + 1;\n\t\tsc->sc_cmdlen = clen;\n\t\tsc->sc_cmdp = (caddr_t)&ecb->cmd;\n\t\tNCRDMA_SETUP(sc, &sc->sc_cmdp, &sc->sc_cmdlen, 0, &dmasize);\n\n\t\t/* Program the SCSI counter */\n\t\tNCR_WRITE_REG(sc, NCR_TCL, dmasize);\n\t\tNCR_WRITE_REG(sc, NCR_TCM, dmasize >> 8);\n\t\tif (sc->sc_cfg2 & NCRCFG2_FE) {\n\t\t\tNCR_WRITE_REG(sc, NCR_TCH, dmasize >> 16);\n\t\t}\n\n\t\t/* load the count in */\n\t\tNCRCMD(sc, NCRCMD_NOP|NCRCMD_DMA);\n\n\t\t/* And get the targets attention */\n\t\tNCRCMD(sc, NCRCMD_SELATN | NCRCMD_DMA);\n\t\tNCRDMA_GO(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * Who am I. This is where we tell the target that we are\n\t * happy for it to disconnect etc.\n\t */\n\tNCR_WRITE_REG(sc, NCR_FIFO,\n\t\t\tMSG_IDENTIFY(lun, (tiflags & T_RSELECTOFF)?0:1));\n\n\tif (ti->flags & T_NEGOTIATE) {\n\t\t/* Arbitrate, select and stop after IDENTIFY message */\n\t\tNCRCMD(sc, NCRCMD_SELATNS);\n\t\treturn;\n\t}\n\n\t/* Now the command into the FIFO */\n\tcmd = (u_char *)&ecb->cmd.cmd;\n\tclen = ecb->clen;\n\twhile (clen--)\n\t\tNCR_WRITE_REG(sc, NCR_FIFO, *cmd++);\n\n\t/* And get the targets attention */\n\tNCRCMD(sc, NCRCMD_SELATN);\n}"
  },
  {
    "function_name": "ncr53c9x_setsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "415-443",
    "snippet": "static inline void\nncr53c9x_setsync(sc, ti)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_tinfo *ti;\n{\n\tu_char syncoff, synctp, cfg3 = sc->sc_cfg3;\n\n\tif (ti->flags & T_SYNCMODE) {\n\t\tsyncoff = ti->offset;\n\t\tsynctp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\tif (sc->sc_features & NCR_F_FASTSCSI) {\n\t\t\t/*\n\t\t\t * If the period is 200ns or less (ti->period <= 50),\n\t\t\t * put the chip in Fast SCSI mode.\n\t\t\t */\n\t\t\tif (ti->period <= 50)\n\t\t\t\tcfg3 |= NCRCFG3_FSCSI;\n\t\t}\n\t} else {\n\t\tsyncoff = 0;\n\t\tsynctp = 0;\n\t}\n\n\tif (sc->sc_features & NCR_F_HASCFG3)\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, cfg3);\n\n\tNCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);\n\tNCR_WRITE_REG(sc, NCR_SYNCTP, synctp);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline int ncr53c9x_stp2cpb",
      "static inline void ncr53c9x_setsync",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_SYNCTP",
            "synctp"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_SYNCOFF",
            "syncoff"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_CFG3",
            "cfg3"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_stp2cpb",
          "args": [
            "sc",
            "ti->period"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_stp2cpb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "402-413",
          "snippet": "static inline int\nncr53c9x_stp2cpb(sc, period)\n\tstruct ncr53c9x_softc *sc;\n\tint period;\n{\n\tint v;\n\tv = (sc->sc_freq * period) / 250;\n\tif (ncr53c9x_cpb2stp(sc, v) < period)\n\t\t/* Correct round-down error */\n\t\tv++;\n\treturn (v);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline int ncr53c9x_stp2cpb",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline int ncr53c9x_stp2cpb;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nstatic inline int\nncr53c9x_stp2cpb(sc, period)\n\tstruct ncr53c9x_softc *sc;\n\tint period;\n{\n\tint v;\n\tv = (sc->sc_freq * period) / 250;\n\tif (ncr53c9x_cpb2stp(sc, v) < period)\n\t\t/* Correct round-down error */\n\t\tv++;\n\treturn (v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline int ncr53c9x_stp2cpb;\nstatic inline void ncr53c9x_setsync;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nstatic inline void\nncr53c9x_setsync(sc, ti)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_tinfo *ti;\n{\n\tu_char syncoff, synctp, cfg3 = sc->sc_cfg3;\n\n\tif (ti->flags & T_SYNCMODE) {\n\t\tsyncoff = ti->offset;\n\t\tsynctp = ncr53c9x_stp2cpb(sc, ti->period);\n\t\tif (sc->sc_features & NCR_F_FASTSCSI) {\n\t\t\t/*\n\t\t\t * If the period is 200ns or less (ti->period <= 50),\n\t\t\t * put the chip in Fast SCSI mode.\n\t\t\t */\n\t\t\tif (ti->period <= 50)\n\t\t\t\tcfg3 |= NCRCFG3_FSCSI;\n\t\t}\n\t} else {\n\t\tsyncoff = 0;\n\t\tsynctp = 0;\n\t}\n\n\tif (sc->sc_features & NCR_F_HASCFG3)\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, cfg3);\n\n\tNCR_WRITE_REG(sc, NCR_SYNCOFF, syncoff);\n\tNCR_WRITE_REG(sc, NCR_SYNCTP, synctp);\n}"
  },
  {
    "function_name": "ncr53c9x_stp2cpb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "402-413",
    "snippet": "static inline int\nncr53c9x_stp2cpb(sc, period)\n\tstruct ncr53c9x_softc *sc;\n\tint period;\n{\n\tint v;\n\tv = (sc->sc_freq * period) / 250;\n\tif (ncr53c9x_cpb2stp(sc, v) < period)\n\t\t/* Correct round-down error */\n\t\tv++;\n\treturn (v);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline int ncr53c9x_stp2cpb",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr53c9x_cpb2stp",
          "args": [
            "sc",
            "v"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic inline int ncr53c9x_stp2cpb;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nstatic inline int\nncr53c9x_stp2cpb(sc, period)\n\tstruct ncr53c9x_softc *sc;\n\tint period;\n{\n\tint v;\n\tv = (sc->sc_freq * period) / 250;\n\tif (ncr53c9x_cpb2stp(sc, v) < period)\n\t\t/* Correct round-down error */\n\t\tv++;\n\treturn (v);\n}"
  },
  {
    "function_name": "ncr53c9x_readregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "373-397",
    "snippet": "__inline__ void\nncr53c9x_readregs(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\n\tsc->sc_espstat = NCR_READ_REG(sc, NCR_STAT);\n\t/* Only the stepo bits are of interest */\n\tsc->sc_espstep = NCR_READ_REG(sc, NCR_STEP) & NCRSTEP_MASK;\n\tsc->sc_espintr = NCR_READ_REG(sc, NCR_INTR);\n\n\tif (sc->sc_glue->gl_clear_latched_intr != NULL)\n\t\t(*sc->sc_glue->gl_clear_latched_intr)(sc);\n\n\t/*\n\t * Determine the SCSI bus phase, return either a real SCSI bus phase\n\t * or some pseudo phase we use to detect certain exceptions.\n\t */\n\n\tsc->sc_phase = (sc->sc_espintr & NCRINTR_DIS)\n\t\t\t? /* Disconnected */ BUSFREE_PHASE\n\t\t\t: sc->sc_espstat & NCRSTAT_PHASE;\n\n\tNCR_MISC((\"regs[intr=%02x,stat=%02x,step=%02x] \",\n\t\tsc->sc_espintr, sc->sc_espstat, sc->sc_espstep));\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tncr53c9x_readregs",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_MISC",
          "args": [
            "(\"regs[intr=%02x,stat=%02x,step=%02x] \",\n\t\tsc->sc_espintr, sc->sc_espstat, sc->sc_espstep)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_INTR"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_STEP"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_STAT"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_readregs;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\n__inline__ void\nncr53c9x_readregs(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\n\tsc->sc_espstat = NCR_READ_REG(sc, NCR_STAT);\n\t/* Only the stepo bits are of interest */\n\tsc->sc_espstep = NCR_READ_REG(sc, NCR_STEP) & NCRSTEP_MASK;\n\tsc->sc_espintr = NCR_READ_REG(sc, NCR_INTR);\n\n\tif (sc->sc_glue->gl_clear_latched_intr != NULL)\n\t\t(*sc->sc_glue->gl_clear_latched_intr)(sc);\n\n\t/*\n\t * Determine the SCSI bus phase, return either a real SCSI bus phase\n\t * or some pseudo phase we use to detect certain exceptions.\n\t */\n\n\tsc->sc_phase = (sc->sc_espintr & NCRINTR_DIS)\n\t\t\t? /* Disconnected */ BUSFREE_PHASE\n\t\t\t: sc->sc_espstat & NCRSTAT_PHASE;\n\n\tNCR_MISC((\"regs[intr=%02x,stat=%02x,step=%02x] \",\n\t\tsc->sc_espintr, sc->sc_espstat, sc->sc_espstep));\n}"
  },
  {
    "function_name": "ncr53c9x_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "301-362",
    "snippet": "void\nncr53c9x_init(sc, doreset)\n\tstruct ncr53c9x_softc *sc;\n\tint doreset;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tint r;\n\n\tNCR_TRACE((\"[NCR_INIT(%d)] \", doreset));\n\n\tif (sc->sc_state == 0) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tecb = sc->sc_ecb;\n\t\tbzero(ecb, sizeof(sc->sc_ecb));\n\t\tfor (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);\n\t\t\tecb++;\n\t\t}\n\t\tbzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = NCR_CLEANING;\n\t\tif ((ecb = sc->sc_nexus) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t\twhile ((ecb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t}\n\n\t/*\n\t * reset the chip to a known state\n\t */\n\tncr53c9x_reset(sc);\n\n\tsc->sc_phase = sc->sc_prevphase = INVALID_PHASE;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];\n/* XXX - config flags per target: low bits: no reselect; high bits: no synch */\n\n\t\tti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))\n\t\t\t\t? T_NEGOTIATE : 0) |\n\t\t\t\t((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |\n\t\t\t\tT_NEED_TO_RESET;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = 0;\n\t}\n\n\tif (doreset) {\n\t\tsc->sc_state = NCR_SBR;\n\t\tNCRCMD(sc, NCRCMD_RSTSCSI);\n\t} else {\n\t\tsc->sc_state = NCR_IDLE;\n\t\tncr53c9x_sched(sc);\n\t}\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tncr53c9x_init",
      "void\tncr53c9x_sched",
      "void\tncr53c9x_done",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr53c9x_sched",
          "args": [
            "sc"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "687-716",
          "snippet": "void\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_select",
            "void\tncr53c9x_sched",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_select;\nvoid\tncr53c9x_sched;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_sched(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tstruct scsi_link *sc_link;\n\tstruct ncr53c9x_tinfo *ti;\n\n\tNCR_TRACE((\"[ncr53c9x_sched] \"));\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr53c9x_sched: not IDLE (state=%d)\", sc->sc_state);\n\n\t/*\n\t * Find first ecb in ready queue that is for a target/lunit\n\t * combinations that is not busy.\n\t */\n\tfor (ecb = sc->ready_list.tqh_first; ecb; ecb = ecb->chain.tqe_next) {\n\t\tsc_link = ecb->xs->sc_link;\n\t\tti = &sc->sc_tinfo[sc_link->target];\n\t\tif ((ti->lubusy & (1 << sc_link->lun)) == 0) {\n\t\t\tTAILQ_REMOVE(&sc->ready_list, ecb, chain);\n\t\t\tsc->sc_nexus = ecb;\n\t\t\tncr53c9x_select(sc, ecb);\n\t\t\tbreak;\n\t\t} else\n\t\t\tNCR_MISC((\"%d:%d busy\\n\",\n\t\t\t\t  sc_link->target,\n\t\t\t\t  sc_link->lun));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_RSTSCSI"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_reset",
          "args": [
            "sc"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "242-282",
          "snippet": "void\nncr53c9x_reset(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\n\t/* reset DMA first */\n\tNCRDMA_RESET(sc);\n\n\t/* reset SCSI chip */\n\tNCRCMD(sc, NCRCMD_RSTCHIP);\n\tNCRCMD(sc, NCRCMD_NOP);\n\tDELAY(500);\n\n\t/* do these backwards, and fall through */\n\tswitch (sc->sc_rev) {\n\tcase NCR_VARIANT_ESP406:\n\tcase NCR_VARIANT_FAS408:\n\t\tNCR_SCSIREGS(sc);\n\tcase NCR_VARIANT_FAS216:\n\tcase NCR_VARIANT_NCR53C94:\n\tcase NCR_VARIANT_NCR53C96:\n\tcase NCR_VARIANT_ESP200:\n\t\tsc->sc_features |= NCR_F_HASCFG3;\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);\n\tcase NCR_VARIANT_ESP100A:\n\t\tNCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);\n\tcase NCR_VARIANT_ESP100:\n\t\tNCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);\n\t\tNCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);\n\t\tNCR_WRITE_REG(sc, NCR_SYNCOFF, 0);\n\t\tNCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown revision code, assuming ESP100\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);\n\t\tNCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);\n\t\tNCR_WRITE_REG(sc, NCR_SYNCOFF, 0);\n\t\tNCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_reset(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\n\t/* reset DMA first */\n\tNCRDMA_RESET(sc);\n\n\t/* reset SCSI chip */\n\tNCRCMD(sc, NCRCMD_RSTCHIP);\n\tNCRCMD(sc, NCRCMD_NOP);\n\tDELAY(500);\n\n\t/* do these backwards, and fall through */\n\tswitch (sc->sc_rev) {\n\tcase NCR_VARIANT_ESP406:\n\tcase NCR_VARIANT_FAS408:\n\t\tNCR_SCSIREGS(sc);\n\tcase NCR_VARIANT_FAS216:\n\tcase NCR_VARIANT_NCR53C94:\n\tcase NCR_VARIANT_NCR53C96:\n\tcase NCR_VARIANT_ESP200:\n\t\tsc->sc_features |= NCR_F_HASCFG3;\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);\n\tcase NCR_VARIANT_ESP100A:\n\t\tNCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);\n\tcase NCR_VARIANT_ESP100:\n\t\tNCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);\n\t\tNCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);\n\t\tNCR_WRITE_REG(sc, NCR_SYNCOFF, 0);\n\t\tNCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown revision code, assuming ESP100\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);\n\t\tNCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);\n\t\tNCR_WRITE_REG(sc, NCR_SYNCOFF, 0);\n\t\tNCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr53c9x_done",
          "args": [
            "sc",
            "ecb"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "756-823",
          "snippet": "void\nncr53c9x_done(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tNCR_TRACE((\"[ncr53c9x_done(error:%x)] \", xs->error));\n\n\tuntimeout(ncr53c9x_timeout, ecb);\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\txs->status = ecb->stat;\n\t\tif ((ecb->flags & ECB_ABORT) != 0) {\n\t\t\txs->error = XS_TIMEOUT;\n\t\t} else if ((ecb->flags & ECB_SENSE) != 0) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = ecb->dleft;\n\t\t\tncr53c9x_sense(sc, ecb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = ecb->dleft;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#ifdef NCR53C9X_DEBUG\n\tif (ncr53c9x_debug & NCR_SHOWMISC) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ECB from whatever queue it's on.\n\t */\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tif (sc->sc_state != NCR_CLEANING) {\n\t\t\tsc->sc_state = NCR_IDLE;\n\t\t\tncr53c9x_sched(sc);\n\t\t}\n\t} else\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\t\n\tncr53c9x_free_ecb(sc, ecb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr53c9x_debug = 0;",
            "void\tncr53c9x_sched",
            "void\tncr53c9x_done",
            "void\tncr53c9x_timeout",
            "void ncr53c9x_dequeue",
            "void ncr53c9x_sense",
            "void ncr53c9x_free_ecb",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr53c9x_debug = 0;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_done;\nvoid\tncr53c9x_timeout;\nvoid ncr53c9x_dequeue;\nvoid ncr53c9x_sense;\nvoid ncr53c9x_free_ecb;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_done(sc, ecb)\n\tstruct ncr53c9x_softc *sc;\n\tstruct ncr53c9x_ecb *ecb;\n{\n\tstruct scsi_xfer *xs = ecb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[sc_link->target];\n\n\tNCR_TRACE((\"[ncr53c9x_done(error:%x)] \", xs->error));\n\n\tuntimeout(ncr53c9x_timeout, ecb);\n\n\t/*\n\t * Now, if we've come here with no error code, i.e. we've kept the\n\t * initial XS_NOERROR, and the status code signals that we should\n\t * check sense, we'll need to set up a request sense cmd block and\n\t * push the command back into the ready queue *before* any other\n\t * commands for this target/lunit, else we lose the sense info.\n\t * We don't support chk sense conditions for the request sense cmd.\n\t */\n\tif (xs->error == XS_NOERROR) {\n\t\txs->status = ecb->stat;\n\t\tif ((ecb->flags & ECB_ABORT) != 0) {\n\t\t\txs->error = XS_TIMEOUT;\n\t\t} else if ((ecb->flags & ECB_SENSE) != 0) {\n\t\t\txs->error = XS_SENSE;\n\t\t} else if ((ecb->stat & ST_MASK) == SCSI_CHECK) {\n\t\t\t/* First, save the return values */\n\t\t\txs->resid = ecb->dleft;\n\t\t\tncr53c9x_sense(sc, ecb);\n\t\t\treturn;\n\t\t} else {\n\t\t\txs->resid = ecb->dleft;\n\t\t}\n\t}\n\n\txs->flags |= ITSDONE;\n\n#ifdef NCR53C9X_DEBUG\n\tif (ncr53c9x_debug & NCR_SHOWMISC) {\n\t\tif (xs->resid != 0)\n\t\t\tprintf(\"resid=%d \", xs->resid);\n\t\tif (xs->error == XS_SENSE)\n\t\t\tprintf(\"sense=0x%02x\\n\", xs->sense.error_code);\n\t\telse\n\t\t\tprintf(\"error=%d\\n\", xs->error);\n\t}\n#endif\n\n\t/*\n\t * Remove the ECB from whatever queue it's on.\n\t */\n\tif (ecb->flags & ECB_NEXUS)\n\t\tti->lubusy &= ~(1 << sc_link->lun);\n\tif (ecb == sc->sc_nexus) {\n\t\tsc->sc_nexus = NULL;\n\t\tif (sc->sc_state != NCR_CLEANING) {\n\t\t\tsc->sc_state = NCR_IDLE;\n\t\t\tncr53c9x_sched(sc);\n\t\t}\n\t} else\n\t\tncr53c9x_dequeue(sc, ecb);\n\t\t\n\tncr53c9x_free_ecb(sc, ecb, xs->flags);\n\tti->cmds++;\n\tscsi_done(xs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->sc_tinfo",
            "sizeof(sc->sc_tinfo)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INSERT_TAIL",
          "args": [
            "&sc->free_list",
            "ecb",
            "chain"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "ecb",
            "sizeof(sc->sc_ecb)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->free_list"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->nexus_list"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TAILQ_INIT",
          "args": [
            "&sc->ready_list"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "(\"[NCR_INIT(%d)] \", doreset)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_done;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_init(sc, doreset)\n\tstruct ncr53c9x_softc *sc;\n\tint doreset;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tint r;\n\n\tNCR_TRACE((\"[NCR_INIT(%d)] \", doreset));\n\n\tif (sc->sc_state == 0) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tecb = sc->sc_ecb;\n\t\tbzero(ecb, sizeof(sc->sc_ecb));\n\t\tfor (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);\n\t\t\tecb++;\n\t\t}\n\t\tbzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = NCR_CLEANING;\n\t\tif ((ecb = sc->sc_nexus) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t\twhile ((ecb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t}\n\n\t/*\n\t * reset the chip to a known state\n\t */\n\tncr53c9x_reset(sc);\n\n\tsc->sc_phase = sc->sc_prevphase = INVALID_PHASE;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];\n/* XXX - config flags per target: low bits: no reselect; high bits: no synch */\n\n\t\tti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))\n\t\t\t\t? T_NEGOTIATE : 0) |\n\t\t\t\t((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |\n\t\t\t\tT_NEED_TO_RESET;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = 0;\n\t}\n\n\tif (doreset) {\n\t\tsc->sc_state = NCR_SBR;\n\t\tNCRCMD(sc, NCRCMD_RSTSCSI);\n\t} else {\n\t\tsc->sc_state = NCR_IDLE;\n\t\tncr53c9x_sched(sc);\n\t}\n}"
  },
  {
    "function_name": "ncr53c9x_scsi_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "287-296",
    "snippet": "void\nncr53c9x_scsi_reset(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\n\t(*sc->sc_glue->gl_dma_stop)(sc);\n\n\tprintf(\"%s: resetting SCSI bus\\n\", sc->sc_dev.dv_xname);\n\tNCRCMD(sc, NCRCMD_RSTSCSI);\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tncr53c9x_scsi_reset",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_RSTSCSI"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: resetting SCSI bus\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_scsi_reset;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_scsi_reset(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\n\t(*sc->sc_glue->gl_dma_stop)(sc);\n\n\tprintf(\"%s: resetting SCSI bus\\n\", sc->sc_dev.dv_xname);\n\tNCRCMD(sc, NCRCMD_RSTSCSI);\n}"
  },
  {
    "function_name": "ncr53c9x_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "242-282",
    "snippet": "void\nncr53c9x_reset(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\n\t/* reset DMA first */\n\tNCRDMA_RESET(sc);\n\n\t/* reset SCSI chip */\n\tNCRCMD(sc, NCRCMD_RSTCHIP);\n\tNCRCMD(sc, NCRCMD_NOP);\n\tDELAY(500);\n\n\t/* do these backwards, and fall through */\n\tswitch (sc->sc_rev) {\n\tcase NCR_VARIANT_ESP406:\n\tcase NCR_VARIANT_FAS408:\n\t\tNCR_SCSIREGS(sc);\n\tcase NCR_VARIANT_FAS216:\n\tcase NCR_VARIANT_NCR53C94:\n\tcase NCR_VARIANT_NCR53C96:\n\tcase NCR_VARIANT_ESP200:\n\t\tsc->sc_features |= NCR_F_HASCFG3;\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);\n\tcase NCR_VARIANT_ESP100A:\n\t\tNCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);\n\tcase NCR_VARIANT_ESP100:\n\t\tNCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);\n\t\tNCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);\n\t\tNCR_WRITE_REG(sc, NCR_SYNCOFF, 0);\n\t\tNCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown revision code, assuming ESP100\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);\n\t\tNCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);\n\t\tNCR_WRITE_REG(sc, NCR_SYNCOFF, 0);\n\t\tNCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);\n\t}\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TIMEOUT",
            "sc->sc_timeout"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_SYNCOFF",
            "0"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_CCF",
            "sc->sc_ccf"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_CFG1",
            "sc->sc_cfg1"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unknown revision code, assuming ESP100\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_TIMEOUT",
            "sc->sc_timeout"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_SYNCOFF",
            "0"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_CCF",
            "sc->sc_ccf"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_CFG1",
            "sc->sc_cfg1"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_CFG2",
            "sc->sc_cfg2"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_CFG3",
            "sc->sc_cfg3"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_SCSIREGS",
          "args": [
            "sc"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "500"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_NOP"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRCMD",
          "args": [
            "sc",
            "NCRCMD_RSTCHIP"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCRDMA_RESET",
          "args": [
            "sc"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_reset(sc)\n\tstruct ncr53c9x_softc *sc;\n{\n\n\t/* reset DMA first */\n\tNCRDMA_RESET(sc);\n\n\t/* reset SCSI chip */\n\tNCRCMD(sc, NCRCMD_RSTCHIP);\n\tNCRCMD(sc, NCRCMD_NOP);\n\tDELAY(500);\n\n\t/* do these backwards, and fall through */\n\tswitch (sc->sc_rev) {\n\tcase NCR_VARIANT_ESP406:\n\tcase NCR_VARIANT_FAS408:\n\t\tNCR_SCSIREGS(sc);\n\tcase NCR_VARIANT_FAS216:\n\tcase NCR_VARIANT_NCR53C94:\n\tcase NCR_VARIANT_NCR53C96:\n\tcase NCR_VARIANT_ESP200:\n\t\tsc->sc_features |= NCR_F_HASCFG3;\n\t\tNCR_WRITE_REG(sc, NCR_CFG3, sc->sc_cfg3);\n\tcase NCR_VARIANT_ESP100A:\n\t\tNCR_WRITE_REG(sc, NCR_CFG2, sc->sc_cfg2);\n\tcase NCR_VARIANT_ESP100:\n\t\tNCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);\n\t\tNCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);\n\t\tNCR_WRITE_REG(sc, NCR_SYNCOFF, 0);\n\t\tNCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: unknown revision code, assuming ESP100\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_WRITE_REG(sc, NCR_CFG1, sc->sc_cfg1);\n\t\tNCR_WRITE_REG(sc, NCR_CCF, sc->sc_ccf);\n\t\tNCR_WRITE_REG(sc, NCR_SYNCOFF, 0);\n\t\tNCR_WRITE_REG(sc, NCR_TIMEOUT, sc->sc_timeout);\n\t}\n}"
  },
  {
    "function_name": "ncr53c9x_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
    "lines": "144-232",
    "snippet": "void\nncr53c9x_attach(sc, adapter, dev)\n\tstruct ncr53c9x_softc *sc;\n\tstruct scsi_adapter *adapter;\n\tstruct scsi_device *dev;\n{\n\n\t/*\n\t * Allocate SCSI message buffers.\n\t * Front-ends can override allocation to avoid alignment\n\t * handling in the DMA engines. Note that that ncr53c9x_msgout()\n\t * can request a 1 byte DMA transfer.\n\t */\n\tif (sc->sc_omess == NULL)\n\t\tsc->sc_omess = malloc(NCR_MAX_MSG_LEN, M_DEVBUF, M_NOWAIT);\n\n\tif (sc->sc_imess == NULL)\n\t\tsc->sc_imess = malloc(NCR_MAX_MSG_LEN+1, M_DEVBUF, M_NOWAIT);\n\n\tif (sc->sc_omess == NULL || sc->sc_imess == NULL) {\n\t\tprintf(\"out of memory\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Note, the front-end has set us up to print the chip variation.\n\t */\n\tif (sc->sc_rev >= NCR_VARIANT_MAX) {\n\t\tprintf(\"\\n%s: unknown variant %d, devices not attached\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_rev);\n\t\treturn;\n\t}\n\n\tprintf(\": %s, %dMHz, SCSI ID %d\\n\",\n\t    ncr53c9x_variant_names[sc->sc_rev], sc->sc_freq, sc->sc_id);\n\n\tsc->sc_ccf = FREQTOCCF(sc->sc_freq);\n\n\t/* The value *must not* be == 1. Make it 2 */\n\tif (sc->sc_ccf == 1)\n\t\tsc->sc_ccf = 2;\n\n\t/*\n\t * The recommended timeout is 250ms. This register is loaded\n\t * with a value calculated as follows, from the docs:\n\t *\n\t *\t\t(timout period) x (CLK frequency)\n\t *\treg = -------------------------------------\n\t *\t\t 8192 x (Clock Conversion Factor)\n\t *\n\t * Since CCF has a linear relation to CLK, this generally computes\n\t * to the constant of 153.\n\t */\n\tsc->sc_timeout = ((250 * 1000) * sc->sc_freq) / (8192 * sc->sc_ccf);\n\n\t/* CCF register only has 3 bits; 0 is actually 8 */\n\tsc->sc_ccf &= 7;\n\n\t/* Reset state & bus */\n\tsc->sc_cfflags = sc->sc_dev.dv_cfdata->cf_flags;\n\tsc->sc_state = 0;\n\tncr53c9x_init(sc, 1);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_id;\n\tsc->sc_link.adapter = adapter;\n\tsc->sc_link.device = dev;\n\tsc->sc_link.openings = 2;\n\n\t/*\n\t * Now try to attach all the sub-devices\n\t */\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n\n\t/*\n\t * Enable interupts from the SCSI core\n\t */\n\tif ((sc->sc_rev == NCR_VARIANT_ESP406) ||\n\t    (sc->sc_rev == NCR_VARIANT_FAS408)) {\n\t\tNCR_PIOREGS(sc);\n\t\tNCR_WRITE_REG(sc, NCR_CFG5, NCRCFG5_SINT |\n\t\t    NCR_READ_REG(sc, NCR_CFG5));\n\t\tNCR_SCSIREGS(sc);\n\t}\n\n}",
    "includes": [
      "#include <dev/ic/ncr53c9xvar.h>",
      "#include <dev/ic/ncr53c9xreg.h>",
      "#include <machine/cpu.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/queue.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tncr53c9x_init",
      "void\tncr53c9x_msgout",
      "const char *ncr53c9x_variant_names[] = {\n\t\"ESP100\",\n\t\"ESP100A\",\n\t\"ESP200\",\n\t\"NCR53C94\",\n\t\"NCR53C96\",\n\t\"ESP406\",\n\t\"FAS408\",\n\t\"FAS216\",\n};",
      "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_SCSIREGS",
          "args": [
            "sc"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_WRITE_REG",
          "args": [
            "sc",
            "NCR_CFG5",
            "NCRCFG5_SINT |\n\t\t    NCR_READ_REG(sc, NCR_CFG5)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_READ_REG",
          "args": [
            "sc",
            "NCR_CFG5"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_PIOREGS",
          "args": [
            "sc"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_found",
          "args": [
            "&sc->sc_dev",
            "&sc->sc_link",
            "scsiprint"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr53c9x_init",
          "args": [
            "sc",
            "1"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "ncr53c9x_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr53c9x.c",
          "lines": "301-362",
          "snippet": "void\nncr53c9x_init(sc, doreset)\n\tstruct ncr53c9x_softc *sc;\n\tint doreset;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tint r;\n\n\tNCR_TRACE((\"[NCR_INIT(%d)] \", doreset));\n\n\tif (sc->sc_state == 0) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tecb = sc->sc_ecb;\n\t\tbzero(ecb, sizeof(sc->sc_ecb));\n\t\tfor (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);\n\t\t\tecb++;\n\t\t}\n\t\tbzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = NCR_CLEANING;\n\t\tif ((ecb = sc->sc_nexus) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t\twhile ((ecb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t}\n\n\t/*\n\t * reset the chip to a known state\n\t */\n\tncr53c9x_reset(sc);\n\n\tsc->sc_phase = sc->sc_prevphase = INVALID_PHASE;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];\n/* XXX - config flags per target: low bits: no reselect; high bits: no synch */\n\n\t\tti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))\n\t\t\t\t? T_NEGOTIATE : 0) |\n\t\t\t\t((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |\n\t\t\t\tT_NEED_TO_RESET;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = 0;\n\t}\n\n\tif (doreset) {\n\t\tsc->sc_state = NCR_SBR;\n\t\tNCRCMD(sc, NCRCMD_RSTSCSI);\n\t} else {\n\t\tsc->sc_state = NCR_IDLE;\n\t\tncr53c9x_sched(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr53c9xvar.h>",
            "#include <dev/ic/ncr53c9xreg.h>",
            "#include <machine/cpu.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/queue.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tncr53c9x_init",
            "void\tncr53c9x_sched",
            "void\tncr53c9x_done",
            "struct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_sched;\nvoid\tncr53c9x_done;\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\nint flags;\n\nvoid\nncr53c9x_init(sc, doreset)\n\tstruct ncr53c9x_softc *sc;\n\tint doreset;\n{\n\tstruct ncr53c9x_ecb *ecb;\n\tint r;\n\n\tNCR_TRACE((\"[NCR_INIT(%d)] \", doreset));\n\n\tif (sc->sc_state == 0) {\n\t\t/* First time through; initialize. */\n\t\tTAILQ_INIT(&sc->ready_list);\n\t\tTAILQ_INIT(&sc->nexus_list);\n\t\tTAILQ_INIT(&sc->free_list);\n\t\tsc->sc_nexus = NULL;\n\t\tecb = sc->sc_ecb;\n\t\tbzero(ecb, sizeof(sc->sc_ecb));\n\t\tfor (r = 0; r < sizeof(sc->sc_ecb) / sizeof(*ecb); r++) {\n\t\t\tTAILQ_INSERT_TAIL(&sc->free_list, ecb, chain);\n\t\t\tecb++;\n\t\t}\n\t\tbzero(sc->sc_tinfo, sizeof(sc->sc_tinfo));\n\t} else {\n\t\t/* Cancel any active commands. */\n\t\tsc->sc_state = NCR_CLEANING;\n\t\tif ((ecb = sc->sc_nexus) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t\twhile ((ecb = sc->nexus_list.tqh_first) != NULL) {\n\t\t\tecb->xs->error = XS_TIMEOUT;\n\t\t\tncr53c9x_done(sc, ecb);\n\t\t}\n\t}\n\n\t/*\n\t * reset the chip to a known state\n\t */\n\tncr53c9x_reset(sc);\n\n\tsc->sc_phase = sc->sc_prevphase = INVALID_PHASE;\n\tfor (r = 0; r < 8; r++) {\n\t\tstruct ncr53c9x_tinfo *ti = &sc->sc_tinfo[r];\n/* XXX - config flags per target: low bits: no reselect; high bits: no synch */\n\n\t\tti->flags = ((sc->sc_minsync && !(sc->sc_cfflags & (1<<(r+8))))\n\t\t\t\t? T_NEGOTIATE : 0) |\n\t\t\t\t((sc->sc_cfflags & (1<<r)) ? T_RSELECTOFF : 0) |\n\t\t\t\tT_NEED_TO_RESET;\n\t\tti->period = sc->sc_minsync;\n\t\tti->offset = 0;\n\t}\n\n\tif (doreset) {\n\t\tsc->sc_state = NCR_SBR;\n\t\tNCRCMD(sc, NCRCMD_RSTSCSI);\n\t} else {\n\t\tsc->sc_state = NCR_IDLE;\n\t\tncr53c9x_sched(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREQTOCCF",
          "args": [
            "sc->sc_freq"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": %s, %dMHz, SCSI ID %d\\n\"",
            "ncr53c9x_variant_names[sc->sc_rev]",
            "sc->sc_freq",
            "sc->sc_id"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "NCR_MAX_MSG_LEN+1",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr53c9xvar.h>\n#include <dev/ic/ncr53c9xreg.h>\n#include <machine/cpu.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <sys/queue.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\tncr53c9x_init;\nvoid\tncr53c9x_msgout;\nconst char *ncr53c9x_variant_names[] = {\n\t\"ESP100\",\n\t\"ESP100A\",\n\t\"ESP200\",\n\t\"NCR53C94\",\n\t\"NCR53C96\",\n\t\"ESP406\",\n\t\"FAS408\",\n\t\"FAS216\",\n};\nstruct ncr53c9x_ecb *\nncr53c9x_get_ecb(sc, flags)\n\tstruct ncr53c9x_softc *sc;\n\nvoid\nncr53c9x_attach(sc, adapter, dev)\n\tstruct ncr53c9x_softc *sc;\n\tstruct scsi_adapter *adapter;\n\tstruct scsi_device *dev;\n{\n\n\t/*\n\t * Allocate SCSI message buffers.\n\t * Front-ends can override allocation to avoid alignment\n\t * handling in the DMA engines. Note that that ncr53c9x_msgout()\n\t * can request a 1 byte DMA transfer.\n\t */\n\tif (sc->sc_omess == NULL)\n\t\tsc->sc_omess = malloc(NCR_MAX_MSG_LEN, M_DEVBUF, M_NOWAIT);\n\n\tif (sc->sc_imess == NULL)\n\t\tsc->sc_imess = malloc(NCR_MAX_MSG_LEN+1, M_DEVBUF, M_NOWAIT);\n\n\tif (sc->sc_omess == NULL || sc->sc_imess == NULL) {\n\t\tprintf(\"out of memory\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Note, the front-end has set us up to print the chip variation.\n\t */\n\tif (sc->sc_rev >= NCR_VARIANT_MAX) {\n\t\tprintf(\"\\n%s: unknown variant %d, devices not attached\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->sc_rev);\n\t\treturn;\n\t}\n\n\tprintf(\": %s, %dMHz, SCSI ID %d\\n\",\n\t    ncr53c9x_variant_names[sc->sc_rev], sc->sc_freq, sc->sc_id);\n\n\tsc->sc_ccf = FREQTOCCF(sc->sc_freq);\n\n\t/* The value *must not* be == 1. Make it 2 */\n\tif (sc->sc_ccf == 1)\n\t\tsc->sc_ccf = 2;\n\n\t/*\n\t * The recommended timeout is 250ms. This register is loaded\n\t * with a value calculated as follows, from the docs:\n\t *\n\t *\t\t(timout period) x (CLK frequency)\n\t *\treg = -------------------------------------\n\t *\t\t 8192 x (Clock Conversion Factor)\n\t *\n\t * Since CCF has a linear relation to CLK, this generally computes\n\t * to the constant of 153.\n\t */\n\tsc->sc_timeout = ((250 * 1000) * sc->sc_freq) / (8192 * sc->sc_ccf);\n\n\t/* CCF register only has 3 bits; 0 is actually 8 */\n\tsc->sc_ccf &= 7;\n\n\t/* Reset state & bus */\n\tsc->sc_cfflags = sc->sc_dev.dv_cfdata->cf_flags;\n\tsc->sc_state = 0;\n\tncr53c9x_init(sc, 1);\n\n\t/*\n\t * fill in the prototype scsi_link.\n\t */\n\tsc->sc_link.adapter_softc = sc;\n\tsc->sc_link.adapter_target = sc->sc_id;\n\tsc->sc_link.adapter = adapter;\n\tsc->sc_link.device = dev;\n\tsc->sc_link.openings = 2;\n\n\t/*\n\t * Now try to attach all the sub-devices\n\t */\n\tconfig_found(&sc->sc_dev, &sc->sc_link, scsiprint);\n\n\t/*\n\t * Enable interupts from the SCSI core\n\t */\n\tif ((sc->sc_rev == NCR_VARIANT_ESP406) ||\n\t    (sc->sc_rev == NCR_VARIANT_FAS408)) {\n\t\tNCR_PIOREGS(sc);\n\t\tNCR_WRITE_REG(sc, NCR_CFG5, NCRCFG5_SINT |\n\t\t    NCR_READ_REG(sc, NCR_CFG5));\n\t\tNCR_SCSIREGS(sc);\n\t}\n\n}"
  }
]