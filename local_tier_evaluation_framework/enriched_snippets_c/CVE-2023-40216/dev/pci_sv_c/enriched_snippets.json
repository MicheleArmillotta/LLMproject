[
  {
    "function_name": "sv_get_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "1513-1518",
    "snippet": "int\nsv_get_props(addr)\n\tvoid *addr;\n{\n\treturn (AUDIO_PROP_MMAP | AUDIO_PROP_FULLDUPLEX);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_get_props",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_get_props;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_get_props(addr)\n\tvoid *addr;\n{\n\treturn (AUDIO_PROP_MMAP | AUDIO_PROP_FULLDUPLEX);\n}"
  },
  {
    "function_name": "sv_mappage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "1495-1511",
    "snippet": "int\nsv_mappage(addr, mem, off, prot)\n\tvoid *addr;\n        void *mem;\n        int off;\n\tint prot;\n{\n\tstruct sv_softc *sc = addr;\n        struct sv_dma *p;\n\n        for (p = sc->sc_dmas; p && KERNADDR(p) != mem; p = p->next)\n\t\t;\n\tif (!p)\n\t\treturn (-1);\n\treturn (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs, \n\t\t\t\toff, prot, BUS_DMA_WAITOK));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_mappage",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamem_mmap",
          "args": [
            "sc->sc_dmatag",
            "p->segs",
            "p->nsegs",
            "off",
            "prot",
            "BUS_DMA_WAITOK"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "p"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_mappage;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_mappage(addr, mem, off, prot)\n\tvoid *addr;\n        void *mem;\n        int off;\n\tint prot;\n{\n\tstruct sv_softc *sc = addr;\n        struct sv_dma *p;\n\n        for (p = sc->sc_dmas; p && KERNADDR(p) != mem; p = p->next)\n\t\t;\n\tif (!p)\n\t\treturn (-1);\n\treturn (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs, \n\t\t\t\toff, prot, BUS_DMA_WAITOK));\n}"
  },
  {
    "function_name": "sv_round",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "1487-1493",
    "snippet": "u_long\nsv_round(addr, size)\n\tvoid *addr;\n\tu_long size;\n{\n\treturn (size);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_long\tsv_round",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "u_long size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_long\tsv_round;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\nu_long size;\n\nu_long\nsv_round(addr, size)\n\tvoid *addr;\n\tu_long size;\n{\n\treturn (size);\n}"
  },
  {
    "function_name": "sv_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "1468-1485",
    "snippet": "void\nsv_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tstruct sv_softc *sc = addr;\n        struct sv_dma **p;\n\n        for (p = &sc->sc_dmas; *p; p = &(*p)->next) {\n                if (KERNADDR(*p) == ptr) {\n                        sv_freemem(sc, *p);\n                        *p = (*p)->next;\n                        free(*p, pool);\n                        return;\n                }\n        }\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_freemem",
      "void\tsv_free",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "int pool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*p",
            "pool"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "sv_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "1468-1485",
          "snippet": "void\nsv_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tstruct sv_softc *sc = addr;\n        struct sv_dma **p;\n\n        for (p = &sc->sc_dmas; *p; p = &(*p)->next) {\n                if (KERNADDR(*p) == ptr) {\n                        sv_freemem(sc, *p);\n                        *p = (*p)->next;\n                        free(*p, pool);\n                        return;\n                }\n        }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sv_freemem",
          "args": [
            "sc",
            "*p"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "sv_freemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "511-521",
          "snippet": "int\nsv_freemem(sc, p)\n\tstruct sv_softc *sc;\n        struct sv_dma *p;\n{\n\tbus_dmamap_unload(sc->sc_dmatag, p->map);\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (0);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsv_freemem",
            "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;",
            "u_long size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_freemem;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\nu_long size;\n\nint\nsv_freemem(sc, p)\n\tstruct sv_softc *sc;\n        struct sv_dma *p;\n{\n\tbus_dmamap_unload(sc->sc_dmatag, p->map);\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "*p"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_freemem;\nvoid\tsv_free;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint pool;\n\nvoid\nsv_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tstruct sv_softc *sc = addr;\n        struct sv_dma **p;\n\n        for (p = &sc->sc_dmas; *p; p = &(*p)->next) {\n                if (KERNADDR(*p) == ptr) {\n                        sv_freemem(sc, *p);\n                        *p = (*p)->next;\n                        free(*p, pool);\n                        return;\n                }\n        }\n}"
  },
  {
    "function_name": "sv_init_mixer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "1420-1442",
    "snippet": "static void\nsv_init_mixer(sc)\n     struct sv_softc *sc;\n{\n  mixer_ctrl_t cp;\n  int idx;\n\n  cp.type = AUDIO_MIXER_ENUM;\n  cp.dev = SV_SRS_MODE;\n  cp.un.ord = 0;\n\n  sv_mixer_set_port(sc, &cp);\n\n  for (idx = 0; idx < ARRAY_SIZE(ports); idx++) {\n    if (ports[idx].audio == AudioNdac) {\n      cp.type = AUDIO_MIXER_ENUM;\n      cp.dev = SV_FIRST_MIXER + idx * SV_DEVICES_PER_PORT + 1;\n      cp.un.ord = 0;\n      sv_mixer_set_port(sc, &cp);\n      break;\n    }\n  }\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SV_SRS_MODE (SV_LAST_MIXER + 4)",
      "#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)",
      "#define SV_DEVICES_PER_PORT 2"
    ],
    "globals_used": [
      "int\tsv_mixer_set_port",
      "static void sv_init_mixer",
      "static const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_mixer_set_port",
          "args": [
            "sc",
            "&cp"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "sv_mixer_set_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "1153-1316",
          "snippet": "int\nsv_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n  struct sv_softc *sc = addr;\n  u_int8_t reg;\n  int idx;\n\n  if (cp->dev >= SV_FIRST_MIXER &&\n      cp->dev <= SV_LAST_MIXER) {\n    int off = cp->dev - SV_FIRST_MIXER;\n    int mute = (off % SV_DEVICES_PER_PORT);\n    idx = off / SV_DEVICES_PER_PORT;\n\n    if (mute) {\n      if (cp->type != AUDIO_MIXER_ENUM) \n\treturn (EINVAL);\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      if (cp->un.ord) \n\treg |= SV_MUTE_BIT;\n      else\n\treg &= ~SV_MUTE_BIT;\n      sv_write_indirect(sc, ports[idx].l_port, reg);\n\n      if (ports[idx].r_port) {\n\treg = sv_read_indirect(sc, ports[idx].r_port);\n\tif (cp->un.ord) \n\t  reg |= SV_MUTE_BIT;\n\telse\n\t  reg &= ~SV_MUTE_BIT;\n\tsv_write_indirect(sc, ports[idx].r_port, reg);\n      }\n    } else {\n      int  lval, rval;\n\n      if (cp->type != AUDIO_MIXER_VALUE)\n\treturn (EINVAL);\n\n      if (cp->un.value.num_channels != 1 &&\n\t  cp->un.value.num_channels != 2)\n\treturn (EINVAL);\n\n      if (ports[idx].r_port == 0) {\n\tif (cp->un.value.num_channels != 1)\n\t  return (EINVAL);\n\tlval = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n      } else {\n\tif (cp->un.value.num_channels != 2)\n\t  return (EINVAL);\n\n\tlval = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\trval = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n      }\n\n      sc->sc_trd = 1;\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      reg &= ~(ports[idx].mask);\n      lval = ((AUDIO_MAX_GAIN - lval) * ports[idx].mask) / AUDIO_MAX_GAIN;\n      reg |= lval;\n      sv_write_indirect(sc, ports[idx].l_port, reg);\n\n      if (ports[idx].r_port != 0) {\n\treg = sv_read_indirect(sc, ports[idx].r_port);\n\treg &= ~(ports[idx].mask);\n\n\trval = ((AUDIO_MAX_GAIN - rval) * ports[idx].mask) / AUDIO_MAX_GAIN;\n\treg |= rval;\n\n\tsv_write_indirect(sc, ports[idx].r_port, reg);\n      }\n\n      sc->sc_trd = 0;\n      sv_read_indirect(sc, ports[idx].l_port);\n    }\n\n    return (0);\n  }\n\n\n  switch (cp->dev) {\n  case SV_RECORD_SOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    for (idx = 0; idx < ARRAY_SIZE(record_sources); idx++) {\n      if (record_sources[idx].idx == cp->un.ord)\n\tgoto found;\n    }\n    \n    return (EINVAL);\n\n  found:\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    reg &= ~SV_REC_SOURCE_MASK;\n    reg |= (((cp->un.ord) << SV_REC_SOURCE_SHIFT) & SV_REC_SOURCE_MASK);\n    sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n\n    reg = sv_read_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL);\n    reg &= ~SV_REC_SOURCE_MASK;\n    reg |= (((cp->un.ord) << SV_REC_SOURCE_SHIFT) & SV_REC_SOURCE_MASK);\n    sv_write_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL, reg);\n    return (0);\n\n  case SV_RECORD_GAIN:\n    {\n      int val;\n\n      if (cp->type != AUDIO_MIXER_VALUE)\n\treturn (EINVAL);\n\n      if (cp->un.value.num_channels != 1)\n\treturn (EINVAL);\n\n      val = (cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] * SV_REC_GAIN_MASK) \n\t/ AUDIO_MAX_GAIN;\n\n      reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n      reg &= ~SV_REC_GAIN_MASK;\n      reg |= val;\n      sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n      \n      reg = sv_read_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL);\n      reg &= ~SV_REC_GAIN_MASK;\n      reg |= val;\n      sv_write_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL, reg);\n\n    }\n\n    return (0);\n\n  case SV_MIC_BOOST:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    if (cp->un.ord) {\n      reg |= SV_MIC_BOOST_BIT;\n    } else {\n      reg &= ~SV_MIC_BOOST_BIT;\n    }\n    \n    sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n    return (0);\n\n  case SV_SRS_MODE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_SRS_SPACE_CONTROL);\n    if (cp->un.ord) {\n      reg &= ~SV_SRS_SPACE_ONOFF;\n    } else {\n      reg |= SV_SRS_SPACE_ONOFF;\n    }\n    \n    sv_write_indirect(sc, SV_SRS_SPACE_CONTROL, reg);\n    return (0);\n  }\n\n  return (EINVAL);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SV_SRS_MODE (SV_LAST_MIXER + 4)",
            "#define SV_RECORD_GAIN (SV_LAST_MIXER + 3)",
            "#define SV_MIC_BOOST (SV_LAST_MIXER + 2)",
            "#define SV_RECORD_SOURCE (SV_LAST_MIXER + 1)",
            "#define SV_LAST_MIXER (SV_DEVICES_PER_PORT * (ARRAY_SIZE(ports)) + SV_LAST_CLASS)",
            "#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)",
            "#define SV_DEVICES_PER_PORT 2"
          ],
          "globals_used": [
            "int\tsv_mixer_set_port",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write_indirect",
            "static const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};",
            "static const struct {\n  int idx;\n  const char *name;\n} record_sources[] = {\n  { SV_REC_CD, AudioNcd },\n  { SV_REC_DAC, AudioNdac },\n  { SV_REC_AUX2, \"aux2\" },\n  { SV_REC_LINE, AudioNline },\n  { SV_REC_AUX1, \"aux1\" },\n  { SV_REC_MIC, AudioNmicrophone },\n  { SV_REC_MIXER, AudioNmixerout }\n};",
            "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SV_SRS_MODE (SV_LAST_MIXER + 4)\n#define SV_RECORD_GAIN (SV_LAST_MIXER + 3)\n#define SV_MIC_BOOST (SV_LAST_MIXER + 2)\n#define SV_RECORD_SOURCE (SV_LAST_MIXER + 1)\n#define SV_LAST_MIXER (SV_DEVICES_PER_PORT * (ARRAY_SIZE(ports)) + SV_LAST_CLASS)\n#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)\n#define SV_DEVICES_PER_PORT 2\n\nint\tsv_mixer_set_port;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write_indirect;\nstatic const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};\nstatic const struct {\n  int idx;\n  const char *name;\n} record_sources[] = {\n  { SV_REC_CD, AudioNcd },\n  { SV_REC_DAC, AudioNdac },\n  { SV_REC_AUX2, \"aux2\" },\n  { SV_REC_LINE, AudioNline },\n  { SV_REC_AUX1, \"aux1\" },\n  { SV_REC_MIC, AudioNmicrophone },\n  { SV_REC_MIXER, AudioNmixerout }\n};\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n  struct sv_softc *sc = addr;\n  u_int8_t reg;\n  int idx;\n\n  if (cp->dev >= SV_FIRST_MIXER &&\n      cp->dev <= SV_LAST_MIXER) {\n    int off = cp->dev - SV_FIRST_MIXER;\n    int mute = (off % SV_DEVICES_PER_PORT);\n    idx = off / SV_DEVICES_PER_PORT;\n\n    if (mute) {\n      if (cp->type != AUDIO_MIXER_ENUM) \n\treturn (EINVAL);\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      if (cp->un.ord) \n\treg |= SV_MUTE_BIT;\n      else\n\treg &= ~SV_MUTE_BIT;\n      sv_write_indirect(sc, ports[idx].l_port, reg);\n\n      if (ports[idx].r_port) {\n\treg = sv_read_indirect(sc, ports[idx].r_port);\n\tif (cp->un.ord) \n\t  reg |= SV_MUTE_BIT;\n\telse\n\t  reg &= ~SV_MUTE_BIT;\n\tsv_write_indirect(sc, ports[idx].r_port, reg);\n      }\n    } else {\n      int  lval, rval;\n\n      if (cp->type != AUDIO_MIXER_VALUE)\n\treturn (EINVAL);\n\n      if (cp->un.value.num_channels != 1 &&\n\t  cp->un.value.num_channels != 2)\n\treturn (EINVAL);\n\n      if (ports[idx].r_port == 0) {\n\tif (cp->un.value.num_channels != 1)\n\t  return (EINVAL);\n\tlval = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n      } else {\n\tif (cp->un.value.num_channels != 2)\n\t  return (EINVAL);\n\n\tlval = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\trval = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n      }\n\n      sc->sc_trd = 1;\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      reg &= ~(ports[idx].mask);\n      lval = ((AUDIO_MAX_GAIN - lval) * ports[idx].mask) / AUDIO_MAX_GAIN;\n      reg |= lval;\n      sv_write_indirect(sc, ports[idx].l_port, reg);\n\n      if (ports[idx].r_port != 0) {\n\treg = sv_read_indirect(sc, ports[idx].r_port);\n\treg &= ~(ports[idx].mask);\n\n\trval = ((AUDIO_MAX_GAIN - rval) * ports[idx].mask) / AUDIO_MAX_GAIN;\n\treg |= rval;\n\n\tsv_write_indirect(sc, ports[idx].r_port, reg);\n      }\n\n      sc->sc_trd = 0;\n      sv_read_indirect(sc, ports[idx].l_port);\n    }\n\n    return (0);\n  }\n\n\n  switch (cp->dev) {\n  case SV_RECORD_SOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    for (idx = 0; idx < ARRAY_SIZE(record_sources); idx++) {\n      if (record_sources[idx].idx == cp->un.ord)\n\tgoto found;\n    }\n    \n    return (EINVAL);\n\n  found:\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    reg &= ~SV_REC_SOURCE_MASK;\n    reg |= (((cp->un.ord) << SV_REC_SOURCE_SHIFT) & SV_REC_SOURCE_MASK);\n    sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n\n    reg = sv_read_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL);\n    reg &= ~SV_REC_SOURCE_MASK;\n    reg |= (((cp->un.ord) << SV_REC_SOURCE_SHIFT) & SV_REC_SOURCE_MASK);\n    sv_write_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL, reg);\n    return (0);\n\n  case SV_RECORD_GAIN:\n    {\n      int val;\n\n      if (cp->type != AUDIO_MIXER_VALUE)\n\treturn (EINVAL);\n\n      if (cp->un.value.num_channels != 1)\n\treturn (EINVAL);\n\n      val = (cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] * SV_REC_GAIN_MASK) \n\t/ AUDIO_MAX_GAIN;\n\n      reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n      reg &= ~SV_REC_GAIN_MASK;\n      reg |= val;\n      sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n      \n      reg = sv_read_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL);\n      reg &= ~SV_REC_GAIN_MASK;\n      reg |= val;\n      sv_write_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL, reg);\n\n    }\n\n    return (0);\n\n  case SV_MIC_BOOST:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    if (cp->un.ord) {\n      reg |= SV_MIC_BOOST_BIT;\n    } else {\n      reg &= ~SV_MIC_BOOST_BIT;\n    }\n    \n    sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n    return (0);\n\n  case SV_SRS_MODE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_SRS_SPACE_CONTROL);\n    if (cp->un.ord) {\n      reg &= ~SV_SRS_SPACE_ONOFF;\n    } else {\n      reg |= SV_SRS_SPACE_ONOFF;\n    }\n    \n    sv_write_indirect(sc, SV_SRS_SPACE_CONTROL, reg);\n    return (0);\n  }\n\n  return (EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ports"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SV_SRS_MODE (SV_LAST_MIXER + 4)\n#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)\n#define SV_DEVICES_PER_PORT 2\n\nint\tsv_mixer_set_port;\nstatic void sv_init_mixer;\nstatic const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};\n\nstatic void\nsv_init_mixer(sc)\n     struct sv_softc *sc;\n{\n  mixer_ctrl_t cp;\n  int idx;\n\n  cp.type = AUDIO_MIXER_ENUM;\n  cp.dev = SV_SRS_MODE;\n  cp.un.ord = 0;\n\n  sv_mixer_set_port(sc, &cp);\n\n  for (idx = 0; idx < ARRAY_SIZE(ports); idx++) {\n    if (ports[idx].audio == AudioNdac) {\n      cp.type = AUDIO_MIXER_ENUM;\n      cp.dev = SV_FIRST_MIXER + idx * SV_DEVICES_PER_PORT + 1;\n      cp.un.ord = 0;\n      sv_mixer_set_port(sc, &cp);\n      break;\n    }\n  }\n}"
  },
  {
    "function_name": "sv_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "1318-1417",
    "snippet": "int\nsv_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n  struct sv_softc *sc = addr;\n  int val;\n  u_int8_t reg;\n\n  if (cp->dev >= SV_FIRST_MIXER &&\n      cp->dev <= SV_LAST_MIXER) {\n    int off = cp->dev - SV_FIRST_MIXER;\n    int mute = (off % 2);\n    int idx = off / 2;\n\n    if (mute) {\n      if (cp->type != AUDIO_MIXER_ENUM) \n\treturn (EINVAL);\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      cp->un.ord = ((reg & SV_MUTE_BIT) ? 1 : 0);\n    } else {\n      if (cp->type != AUDIO_MIXER_VALUE)\n\treturn (EINVAL);\n\n      if (cp->un.value.num_channels != 1 &&\n\t  cp->un.value.num_channels != 2)\n\treturn (EINVAL);\n\n      if ((ports[idx].r_port == 0 &&\n\t   cp->un.value.num_channels != 1) ||\n\t  (ports[idx].r_port != 0 &&\n\t   cp->un.value.num_channels != 2))\n\treturn (EINVAL);\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      reg &= ports[idx].mask;\n\n      val = AUDIO_MAX_GAIN - ((reg * AUDIO_MAX_GAIN) / ports[idx].mask);\n\n      if (ports[idx].r_port != 0) {\n\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = val;\n\n\treg = sv_read_indirect(sc, ports[idx].r_port);\n\treg &= ports[idx].mask;\n      \n\tval = AUDIO_MAX_GAIN - ((reg * AUDIO_MAX_GAIN) / ports[idx].mask);\n\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = val;\n      } else \n\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = val;\n    }\n\n    return (0);\n  }\n\n  switch (cp->dev) {\n  case SV_RECORD_SOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    cp->un.ord = ((reg & SV_REC_SOURCE_MASK) >> SV_REC_SOURCE_SHIFT);\n\n    return (0);\n\n  case SV_RECORD_GAIN:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      return (EINVAL);\n\n    if (cp->un.value.num_channels != 1)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL) & SV_REC_GAIN_MASK;\n    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = \n      (((unsigned int)reg) * AUDIO_MAX_GAIN) / SV_REC_GAIN_MASK;\n\n    return (0);\n\n  case SV_MIC_BOOST:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    cp->un.ord = ((reg & SV_MIC_BOOST_BIT) ? 1 : 0);\n\n    return (0);\n\n\n  case SV_SRS_MODE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_SRS_SPACE_CONTROL);\n\n    cp->un.ord = ((reg & SV_SRS_SPACE_ONOFF) ? 0 : 1);\n    return (0);\n  }\n\n  return (EINVAL);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SV_SRS_MODE (SV_LAST_MIXER + 4)",
      "#define SV_RECORD_GAIN (SV_LAST_MIXER + 3)",
      "#define SV_MIC_BOOST (SV_LAST_MIXER + 2)",
      "#define SV_RECORD_SOURCE (SV_LAST_MIXER + 1)",
      "#define SV_LAST_MIXER (SV_DEVICES_PER_PORT * (ARRAY_SIZE(ports)) + SV_LAST_CLASS)",
      "#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)"
    ],
    "globals_used": [
      "int\tsv_mixer_get_port",
      "static __inline__ u_int8_t sv_read_indirect",
      "static const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_read_indirect",
          "args": [
            "sc",
            "SV_SRS_SPACE_CONTROL"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SV_SRS_MODE (SV_LAST_MIXER + 4)\n#define SV_RECORD_GAIN (SV_LAST_MIXER + 3)\n#define SV_MIC_BOOST (SV_LAST_MIXER + 2)\n#define SV_RECORD_SOURCE (SV_LAST_MIXER + 1)\n#define SV_LAST_MIXER (SV_DEVICES_PER_PORT * (ARRAY_SIZE(ports)) + SV_LAST_CLASS)\n#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)\n\nint\tsv_mixer_get_port;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n  struct sv_softc *sc = addr;\n  int val;\n  u_int8_t reg;\n\n  if (cp->dev >= SV_FIRST_MIXER &&\n      cp->dev <= SV_LAST_MIXER) {\n    int off = cp->dev - SV_FIRST_MIXER;\n    int mute = (off % 2);\n    int idx = off / 2;\n\n    if (mute) {\n      if (cp->type != AUDIO_MIXER_ENUM) \n\treturn (EINVAL);\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      cp->un.ord = ((reg & SV_MUTE_BIT) ? 1 : 0);\n    } else {\n      if (cp->type != AUDIO_MIXER_VALUE)\n\treturn (EINVAL);\n\n      if (cp->un.value.num_channels != 1 &&\n\t  cp->un.value.num_channels != 2)\n\treturn (EINVAL);\n\n      if ((ports[idx].r_port == 0 &&\n\t   cp->un.value.num_channels != 1) ||\n\t  (ports[idx].r_port != 0 &&\n\t   cp->un.value.num_channels != 2))\n\treturn (EINVAL);\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      reg &= ports[idx].mask;\n\n      val = AUDIO_MAX_GAIN - ((reg * AUDIO_MAX_GAIN) / ports[idx].mask);\n\n      if (ports[idx].r_port != 0) {\n\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = val;\n\n\treg = sv_read_indirect(sc, ports[idx].r_port);\n\treg &= ports[idx].mask;\n      \n\tval = AUDIO_MAX_GAIN - ((reg * AUDIO_MAX_GAIN) / ports[idx].mask);\n\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = val;\n      } else \n\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = val;\n    }\n\n    return (0);\n  }\n\n  switch (cp->dev) {\n  case SV_RECORD_SOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    cp->un.ord = ((reg & SV_REC_SOURCE_MASK) >> SV_REC_SOURCE_SHIFT);\n\n    return (0);\n\n  case SV_RECORD_GAIN:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      return (EINVAL);\n\n    if (cp->un.value.num_channels != 1)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL) & SV_REC_GAIN_MASK;\n    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = \n      (((unsigned int)reg) * AUDIO_MAX_GAIN) / SV_REC_GAIN_MASK;\n\n    return (0);\n\n  case SV_MIC_BOOST:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    cp->un.ord = ((reg & SV_MIC_BOOST_BIT) ? 1 : 0);\n\n    return (0);\n\n\n  case SV_SRS_MODE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_SRS_SPACE_CONTROL);\n\n    cp->un.ord = ((reg & SV_SRS_SPACE_ONOFF) ? 0 : 1);\n    return (0);\n  }\n\n  return (EINVAL);\n}"
  },
  {
    "function_name": "sv_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "1153-1316",
    "snippet": "int\nsv_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n  struct sv_softc *sc = addr;\n  u_int8_t reg;\n  int idx;\n\n  if (cp->dev >= SV_FIRST_MIXER &&\n      cp->dev <= SV_LAST_MIXER) {\n    int off = cp->dev - SV_FIRST_MIXER;\n    int mute = (off % SV_DEVICES_PER_PORT);\n    idx = off / SV_DEVICES_PER_PORT;\n\n    if (mute) {\n      if (cp->type != AUDIO_MIXER_ENUM) \n\treturn (EINVAL);\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      if (cp->un.ord) \n\treg |= SV_MUTE_BIT;\n      else\n\treg &= ~SV_MUTE_BIT;\n      sv_write_indirect(sc, ports[idx].l_port, reg);\n\n      if (ports[idx].r_port) {\n\treg = sv_read_indirect(sc, ports[idx].r_port);\n\tif (cp->un.ord) \n\t  reg |= SV_MUTE_BIT;\n\telse\n\t  reg &= ~SV_MUTE_BIT;\n\tsv_write_indirect(sc, ports[idx].r_port, reg);\n      }\n    } else {\n      int  lval, rval;\n\n      if (cp->type != AUDIO_MIXER_VALUE)\n\treturn (EINVAL);\n\n      if (cp->un.value.num_channels != 1 &&\n\t  cp->un.value.num_channels != 2)\n\treturn (EINVAL);\n\n      if (ports[idx].r_port == 0) {\n\tif (cp->un.value.num_channels != 1)\n\t  return (EINVAL);\n\tlval = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n      } else {\n\tif (cp->un.value.num_channels != 2)\n\t  return (EINVAL);\n\n\tlval = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\trval = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n      }\n\n      sc->sc_trd = 1;\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      reg &= ~(ports[idx].mask);\n      lval = ((AUDIO_MAX_GAIN - lval) * ports[idx].mask) / AUDIO_MAX_GAIN;\n      reg |= lval;\n      sv_write_indirect(sc, ports[idx].l_port, reg);\n\n      if (ports[idx].r_port != 0) {\n\treg = sv_read_indirect(sc, ports[idx].r_port);\n\treg &= ~(ports[idx].mask);\n\n\trval = ((AUDIO_MAX_GAIN - rval) * ports[idx].mask) / AUDIO_MAX_GAIN;\n\treg |= rval;\n\n\tsv_write_indirect(sc, ports[idx].r_port, reg);\n      }\n\n      sc->sc_trd = 0;\n      sv_read_indirect(sc, ports[idx].l_port);\n    }\n\n    return (0);\n  }\n\n\n  switch (cp->dev) {\n  case SV_RECORD_SOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    for (idx = 0; idx < ARRAY_SIZE(record_sources); idx++) {\n      if (record_sources[idx].idx == cp->un.ord)\n\tgoto found;\n    }\n    \n    return (EINVAL);\n\n  found:\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    reg &= ~SV_REC_SOURCE_MASK;\n    reg |= (((cp->un.ord) << SV_REC_SOURCE_SHIFT) & SV_REC_SOURCE_MASK);\n    sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n\n    reg = sv_read_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL);\n    reg &= ~SV_REC_SOURCE_MASK;\n    reg |= (((cp->un.ord) << SV_REC_SOURCE_SHIFT) & SV_REC_SOURCE_MASK);\n    sv_write_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL, reg);\n    return (0);\n\n  case SV_RECORD_GAIN:\n    {\n      int val;\n\n      if (cp->type != AUDIO_MIXER_VALUE)\n\treturn (EINVAL);\n\n      if (cp->un.value.num_channels != 1)\n\treturn (EINVAL);\n\n      val = (cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] * SV_REC_GAIN_MASK) \n\t/ AUDIO_MAX_GAIN;\n\n      reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n      reg &= ~SV_REC_GAIN_MASK;\n      reg |= val;\n      sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n      \n      reg = sv_read_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL);\n      reg &= ~SV_REC_GAIN_MASK;\n      reg |= val;\n      sv_write_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL, reg);\n\n    }\n\n    return (0);\n\n  case SV_MIC_BOOST:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    if (cp->un.ord) {\n      reg |= SV_MIC_BOOST_BIT;\n    } else {\n      reg &= ~SV_MIC_BOOST_BIT;\n    }\n    \n    sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n    return (0);\n\n  case SV_SRS_MODE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_SRS_SPACE_CONTROL);\n    if (cp->un.ord) {\n      reg &= ~SV_SRS_SPACE_ONOFF;\n    } else {\n      reg |= SV_SRS_SPACE_ONOFF;\n    }\n    \n    sv_write_indirect(sc, SV_SRS_SPACE_CONTROL, reg);\n    return (0);\n  }\n\n  return (EINVAL);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SV_SRS_MODE (SV_LAST_MIXER + 4)",
      "#define SV_RECORD_GAIN (SV_LAST_MIXER + 3)",
      "#define SV_MIC_BOOST (SV_LAST_MIXER + 2)",
      "#define SV_RECORD_SOURCE (SV_LAST_MIXER + 1)",
      "#define SV_LAST_MIXER (SV_DEVICES_PER_PORT * (ARRAY_SIZE(ports)) + SV_LAST_CLASS)",
      "#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)",
      "#define SV_DEVICES_PER_PORT 2"
    ],
    "globals_used": [
      "int\tsv_mixer_set_port",
      "static __inline__ u_int8_t sv_read_indirect",
      "static __inline__ void sv_write_indirect",
      "static const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};",
      "static const struct {\n  int idx;\n  const char *name;\n} record_sources[] = {\n  { SV_REC_CD, AudioNcd },\n  { SV_REC_DAC, AudioNdac },\n  { SV_REC_AUX2, \"aux2\" },\n  { SV_REC_LINE, AudioNline },\n  { SV_REC_AUX1, \"aux1\" },\n  { SV_REC_MIC, AudioNmicrophone },\n  { SV_REC_MIXER, AudioNmixerout }\n};",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_write_indirect",
          "args": [
            "sc",
            "SV_SRS_SPACE_CONTROL",
            "reg"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "sv_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "238-260",
          "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void sv_write",
            "static __inline__ void sv_write_indirect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\n\nstatic __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sv_read_indirect",
          "args": [
            "sc",
            "SV_SRS_SPACE_CONTROL"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "record_sources"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SV_SRS_MODE (SV_LAST_MIXER + 4)\n#define SV_RECORD_GAIN (SV_LAST_MIXER + 3)\n#define SV_MIC_BOOST (SV_LAST_MIXER + 2)\n#define SV_RECORD_SOURCE (SV_LAST_MIXER + 1)\n#define SV_LAST_MIXER (SV_DEVICES_PER_PORT * (ARRAY_SIZE(ports)) + SV_LAST_CLASS)\n#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)\n#define SV_DEVICES_PER_PORT 2\n\nint\tsv_mixer_set_port;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write_indirect;\nstatic const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};\nstatic const struct {\n  int idx;\n  const char *name;\n} record_sources[] = {\n  { SV_REC_CD, AudioNcd },\n  { SV_REC_DAC, AudioNdac },\n  { SV_REC_AUX2, \"aux2\" },\n  { SV_REC_LINE, AudioNline },\n  { SV_REC_AUX1, \"aux1\" },\n  { SV_REC_MIC, AudioNmicrophone },\n  { SV_REC_MIXER, AudioNmixerout }\n};\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n  struct sv_softc *sc = addr;\n  u_int8_t reg;\n  int idx;\n\n  if (cp->dev >= SV_FIRST_MIXER &&\n      cp->dev <= SV_LAST_MIXER) {\n    int off = cp->dev - SV_FIRST_MIXER;\n    int mute = (off % SV_DEVICES_PER_PORT);\n    idx = off / SV_DEVICES_PER_PORT;\n\n    if (mute) {\n      if (cp->type != AUDIO_MIXER_ENUM) \n\treturn (EINVAL);\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      if (cp->un.ord) \n\treg |= SV_MUTE_BIT;\n      else\n\treg &= ~SV_MUTE_BIT;\n      sv_write_indirect(sc, ports[idx].l_port, reg);\n\n      if (ports[idx].r_port) {\n\treg = sv_read_indirect(sc, ports[idx].r_port);\n\tif (cp->un.ord) \n\t  reg |= SV_MUTE_BIT;\n\telse\n\t  reg &= ~SV_MUTE_BIT;\n\tsv_write_indirect(sc, ports[idx].r_port, reg);\n      }\n    } else {\n      int  lval, rval;\n\n      if (cp->type != AUDIO_MIXER_VALUE)\n\treturn (EINVAL);\n\n      if (cp->un.value.num_channels != 1 &&\n\t  cp->un.value.num_channels != 2)\n\treturn (EINVAL);\n\n      if (ports[idx].r_port == 0) {\n\tif (cp->un.value.num_channels != 1)\n\t  return (EINVAL);\n\tlval = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n      } else {\n\tif (cp->un.value.num_channels != 2)\n\t  return (EINVAL);\n\n\tlval = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\trval = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n      }\n\n      sc->sc_trd = 1;\n\n      reg = sv_read_indirect(sc, ports[idx].l_port);\n      reg &= ~(ports[idx].mask);\n      lval = ((AUDIO_MAX_GAIN - lval) * ports[idx].mask) / AUDIO_MAX_GAIN;\n      reg |= lval;\n      sv_write_indirect(sc, ports[idx].l_port, reg);\n\n      if (ports[idx].r_port != 0) {\n\treg = sv_read_indirect(sc, ports[idx].r_port);\n\treg &= ~(ports[idx].mask);\n\n\trval = ((AUDIO_MAX_GAIN - rval) * ports[idx].mask) / AUDIO_MAX_GAIN;\n\treg |= rval;\n\n\tsv_write_indirect(sc, ports[idx].r_port, reg);\n      }\n\n      sc->sc_trd = 0;\n      sv_read_indirect(sc, ports[idx].l_port);\n    }\n\n    return (0);\n  }\n\n\n  switch (cp->dev) {\n  case SV_RECORD_SOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    for (idx = 0; idx < ARRAY_SIZE(record_sources); idx++) {\n      if (record_sources[idx].idx == cp->un.ord)\n\tgoto found;\n    }\n    \n    return (EINVAL);\n\n  found:\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    reg &= ~SV_REC_SOURCE_MASK;\n    reg |= (((cp->un.ord) << SV_REC_SOURCE_SHIFT) & SV_REC_SOURCE_MASK);\n    sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n\n    reg = sv_read_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL);\n    reg &= ~SV_REC_SOURCE_MASK;\n    reg |= (((cp->un.ord) << SV_REC_SOURCE_SHIFT) & SV_REC_SOURCE_MASK);\n    sv_write_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL, reg);\n    return (0);\n\n  case SV_RECORD_GAIN:\n    {\n      int val;\n\n      if (cp->type != AUDIO_MIXER_VALUE)\n\treturn (EINVAL);\n\n      if (cp->un.value.num_channels != 1)\n\treturn (EINVAL);\n\n      val = (cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] * SV_REC_GAIN_MASK) \n\t/ AUDIO_MAX_GAIN;\n\n      reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n      reg &= ~SV_REC_GAIN_MASK;\n      reg |= val;\n      sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n      \n      reg = sv_read_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL);\n      reg &= ~SV_REC_GAIN_MASK;\n      reg |= val;\n      sv_write_indirect(sc, SV_RIGHT_ADC_INPUT_CONTROL, reg);\n\n    }\n\n    return (0);\n\n  case SV_MIC_BOOST:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL);\n    if (cp->un.ord) {\n      reg |= SV_MIC_BOOST_BIT;\n    } else {\n      reg &= ~SV_MIC_BOOST_BIT;\n    }\n    \n    sv_write_indirect(sc, SV_LEFT_ADC_INPUT_CONTROL, reg);\n    return (0);\n\n  case SV_SRS_MODE:\n    if (cp->type != AUDIO_MIXER_ENUM)\n      return (EINVAL);\n\n    reg = sv_read_indirect(sc, SV_SRS_SPACE_CONTROL);\n    if (cp->un.ord) {\n      reg &= ~SV_SRS_SPACE_ONOFF;\n    } else {\n      reg |= SV_SRS_SPACE_ONOFF;\n    }\n    \n    sv_write_indirect(sc, SV_SRS_SPACE_CONTROL, reg);\n    return (0);\n  }\n\n  return (EINVAL);\n}"
  },
  {
    "function_name": "sv_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "1045-1151",
    "snippet": "int \nsv_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\n  /* It's a class */\n  if (dip->index <= SV_LAST_CLASS) {\n    dip->type = AUDIO_MIXER_CLASS;\n    dip->mixer_class = dip->index;\n    dip->next = dip->prev = AUDIO_MIXER_LAST;\n    strcpy(dip->label.name, \n\t   mixer_classes[dip->index]);\n    return (0);\n  }\n\n  if (dip->index >= SV_FIRST_MIXER &&\n      dip->index <= SV_LAST_MIXER) {\n    int off = dip->index - SV_FIRST_MIXER;\n    int mute = (off % SV_DEVICES_PER_PORT);\n    int idx = off / SV_DEVICES_PER_PORT;\n\n    dip->mixer_class = ports[idx].class;\n    strcpy(dip->label.name, ports[idx].audio);\n\n    if (!mute) {\n      dip->type = AUDIO_MIXER_VALUE;\n      dip->prev = AUDIO_MIXER_LAST;\n      dip->next = dip->index + 1;\n\n      if (ports[idx].r_port != 0)\n\tdip->un.v.num_channels = 2;\n      else\n\tdip->un.v.num_channels = 1;\n      \n      strcpy(dip->un.v.units.name, AudioNvolume);\n\t\t\n    } else {\n      dip->type = AUDIO_MIXER_ENUM;\n      dip->prev = dip->index - 1;\n      dip->next = AUDIO_MIXER_LAST;\n\n      strcpy(dip->label.name, AudioNmute);\n      dip->un.e.num_mem = 2;\n      strcpy(dip->un.e.member[0].label.name, AudioNoff);\n      dip->un.e.member[0].ord = 0;\n      strcpy(dip->un.e.member[1].label.name, AudioNon);\n      dip->un.e.member[1].ord = 1;\n\n    }\n\n    return (0);\n  }\n\n  switch (dip->index) {\n  case SV_RECORD_SOURCE:\n    dip->mixer_class = SV_RECORD_CLASS;\n    dip->prev = AUDIO_MIXER_LAST;\n    dip->next = SV_RECORD_GAIN;\n    strcpy(dip->label.name, AudioNsource);\n    dip->type = AUDIO_MIXER_ENUM;\n\n    dip->un.e.num_mem = ARRAY_SIZE(record_sources);\n\n    {\n      int idx;\n      for (idx = 0; idx < ARRAY_SIZE(record_sources); idx++) {\n\tstrcpy(dip->un.e.member[idx].label.name, record_sources[idx].name);\n\tdip->un.e.member[idx].ord = record_sources[idx].idx;\n      }\n    }\n    return (0);\n\n  case SV_RECORD_GAIN:\n    dip->mixer_class = SV_RECORD_CLASS;\n    dip->prev = SV_RECORD_SOURCE;\n    dip->next = AUDIO_MIXER_LAST;\n    strcpy(dip->label.name, \"gain\");\n    dip->type = AUDIO_MIXER_VALUE;\n    dip->un.v.num_channels = 1;\n    strcpy(dip->un.v.units.name, AudioNvolume);\n    return (0);\n\n  case SV_MIC_BOOST:\n    dip->mixer_class = SV_RECORD_CLASS;\n    dip->prev = AUDIO_MIXER_LAST;\n    dip->next = AUDIO_MIXER_LAST;\n    strcpy(dip->label.name, \"micboost\");\n    goto on_off;\n\n  case SV_SRS_MODE:\n    dip->mixer_class = SV_OUTPUT_CLASS;\n    dip->prev = dip->next = AUDIO_MIXER_LAST;\n    strcpy(dip->label.name, AudioNspatial);\n\non_off:\n    dip->type = AUDIO_MIXER_ENUM;\n    dip->un.e.num_mem = 2;\n    strcpy(dip->un.e.member[0].label.name, AudioNoff);\n    dip->un.e.member[0].ord = 0;\n    strcpy(dip->un.e.member[1].label.name, AudioNon);\n    dip->un.e.member[1].ord = 1;\n    return (0);\n  }\n\n  return (ENXIO);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define SV_SRS_MODE (SV_LAST_MIXER + 4)",
      "#define SV_RECORD_GAIN (SV_LAST_MIXER + 3)",
      "#define SV_MIC_BOOST (SV_LAST_MIXER + 2)",
      "#define SV_RECORD_SOURCE (SV_LAST_MIXER + 1)",
      "#define SV_LAST_MIXER (SV_DEVICES_PER_PORT * (ARRAY_SIZE(ports)) + SV_LAST_CLASS)",
      "#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)",
      "#define SV_DEVICES_PER_PORT 2",
      "#define SV_LAST_CLASS 2",
      "#define SV_RECORD_CLASS 2",
      "#define SV_OUTPUT_CLASS 1"
    ],
    "globals_used": [
      "int\tsv_query_devinfo",
      "static const char *mixer_classes[] = { AudioCinputs, AudioCoutputs, AudioCrecord };",
      "static const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};",
      "static const struct {\n  int idx;\n  const char *name;\n} record_sources[] = {\n  { SV_REC_CD, AudioNcd },\n  { SV_REC_DAC, AudioNdac },\n  { SV_REC_AUX2, \"aux2\" },\n  { SV_REC_LINE, AudioNline },\n  { SV_REC_AUX1, \"aux1\" },\n  { SV_REC_MIC, AudioNmicrophone },\n  { SV_REC_MIXER, AudioNmixerout }\n};",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNspatial"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "\"micboost\""
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "\"gain\""
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[idx].label.name",
            "record_sources[idx].name"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "record_sources"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "record_sources"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNsource"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmute"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "ports[idx].audio"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "mixer_classes[dip->index]"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SV_SRS_MODE (SV_LAST_MIXER + 4)\n#define SV_RECORD_GAIN (SV_LAST_MIXER + 3)\n#define SV_MIC_BOOST (SV_LAST_MIXER + 2)\n#define SV_RECORD_SOURCE (SV_LAST_MIXER + 1)\n#define SV_LAST_MIXER (SV_DEVICES_PER_PORT * (ARRAY_SIZE(ports)) + SV_LAST_CLASS)\n#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)\n#define SV_DEVICES_PER_PORT 2\n#define SV_LAST_CLASS 2\n#define SV_RECORD_CLASS 2\n#define SV_OUTPUT_CLASS 1\n\nint\tsv_query_devinfo;\nstatic const char *mixer_classes[] = { AudioCinputs, AudioCoutputs, AudioCrecord };\nstatic const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};\nstatic const struct {\n  int idx;\n  const char *name;\n} record_sources[] = {\n  { SV_REC_CD, AudioNcd },\n  { SV_REC_DAC, AudioNdac },\n  { SV_REC_AUX2, \"aux2\" },\n  { SV_REC_LINE, AudioNline },\n  { SV_REC_AUX1, \"aux1\" },\n  { SV_REC_MIC, AudioNmicrophone },\n  { SV_REC_MIXER, AudioNmixerout }\n};\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint \nsv_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\n  /* It's a class */\n  if (dip->index <= SV_LAST_CLASS) {\n    dip->type = AUDIO_MIXER_CLASS;\n    dip->mixer_class = dip->index;\n    dip->next = dip->prev = AUDIO_MIXER_LAST;\n    strcpy(dip->label.name, \n\t   mixer_classes[dip->index]);\n    return (0);\n  }\n\n  if (dip->index >= SV_FIRST_MIXER &&\n      dip->index <= SV_LAST_MIXER) {\n    int off = dip->index - SV_FIRST_MIXER;\n    int mute = (off % SV_DEVICES_PER_PORT);\n    int idx = off / SV_DEVICES_PER_PORT;\n\n    dip->mixer_class = ports[idx].class;\n    strcpy(dip->label.name, ports[idx].audio);\n\n    if (!mute) {\n      dip->type = AUDIO_MIXER_VALUE;\n      dip->prev = AUDIO_MIXER_LAST;\n      dip->next = dip->index + 1;\n\n      if (ports[idx].r_port != 0)\n\tdip->un.v.num_channels = 2;\n      else\n\tdip->un.v.num_channels = 1;\n      \n      strcpy(dip->un.v.units.name, AudioNvolume);\n\t\t\n    } else {\n      dip->type = AUDIO_MIXER_ENUM;\n      dip->prev = dip->index - 1;\n      dip->next = AUDIO_MIXER_LAST;\n\n      strcpy(dip->label.name, AudioNmute);\n      dip->un.e.num_mem = 2;\n      strcpy(dip->un.e.member[0].label.name, AudioNoff);\n      dip->un.e.member[0].ord = 0;\n      strcpy(dip->un.e.member[1].label.name, AudioNon);\n      dip->un.e.member[1].ord = 1;\n\n    }\n\n    return (0);\n  }\n\n  switch (dip->index) {\n  case SV_RECORD_SOURCE:\n    dip->mixer_class = SV_RECORD_CLASS;\n    dip->prev = AUDIO_MIXER_LAST;\n    dip->next = SV_RECORD_GAIN;\n    strcpy(dip->label.name, AudioNsource);\n    dip->type = AUDIO_MIXER_ENUM;\n\n    dip->un.e.num_mem = ARRAY_SIZE(record_sources);\n\n    {\n      int idx;\n      for (idx = 0; idx < ARRAY_SIZE(record_sources); idx++) {\n\tstrcpy(dip->un.e.member[idx].label.name, record_sources[idx].name);\n\tdip->un.e.member[idx].ord = record_sources[idx].idx;\n      }\n    }\n    return (0);\n\n  case SV_RECORD_GAIN:\n    dip->mixer_class = SV_RECORD_CLASS;\n    dip->prev = SV_RECORD_SOURCE;\n    dip->next = AUDIO_MIXER_LAST;\n    strcpy(dip->label.name, \"gain\");\n    dip->type = AUDIO_MIXER_VALUE;\n    dip->un.v.num_channels = 1;\n    strcpy(dip->un.v.units.name, AudioNvolume);\n    return (0);\n\n  case SV_MIC_BOOST:\n    dip->mixer_class = SV_RECORD_CLASS;\n    dip->prev = AUDIO_MIXER_LAST;\n    dip->next = AUDIO_MIXER_LAST;\n    strcpy(dip->label.name, \"micboost\");\n    goto on_off;\n\n  case SV_SRS_MODE:\n    dip->mixer_class = SV_OUTPUT_CLASS;\n    dip->prev = dip->next = AUDIO_MIXER_LAST;\n    strcpy(dip->label.name, AudioNspatial);\n\non_off:\n    dip->type = AUDIO_MIXER_ENUM;\n    dip->un.e.num_mem = 2;\n    strcpy(dip->un.e.member[0].label.name, AudioNoff);\n    dip->un.e.member[0].ord = 0;\n    strcpy(dip->un.e.member[1].label.name, AudioNon);\n    dip->un.e.member[1].ord = 1;\n    return (0);\n  }\n\n  return (ENXIO);\n}"
  },
  {
    "function_name": "sv_getdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "975-982",
    "snippet": "int\nsv_getdev(addr, retp)\n\tvoid *addr;\n        struct audio_device *retp;\n{\n\t*retp = sv_device;\n        return (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct audio_device sv_device = {\n\t\"S3 SonicVibes\",\n\t\"\",\n\t\"sv\"\n};",
      "int\tsv_getdev",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct audio_device sv_device = {\n\t\"S3 SonicVibes\",\n\t\"\",\n\t\"sv\"\n};\nint\tsv_getdev;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_getdev(addr, retp)\n\tvoid *addr;\n        struct audio_device *retp;\n{\n\t*retp = sv_device;\n        return (0);\n}"
  },
  {
    "function_name": "sv_halt_in_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "959-973",
    "snippet": "int\nsv_halt_in_dma(addr)\n\tvoid *addr;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n    \n        DPRINTF((\"eap: sv_halt_in_dma\\n\"));\n\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\tmode &= ~SV_RECORD_ENABLE;\n\tsc->sc_enable &= ~SV_RECORD_ENABLE;\n\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\n        return (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_halt_in_dma",
      "static __inline__ u_int8_t sv_read_indirect",
      "static __inline__ void sv_write_indirect",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_write_indirect",
          "args": [
            "sc",
            "SV_PLAY_RECORD_ENABLE",
            "mode"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "sv_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "238-260",
          "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void sv_write",
            "static __inline__ void sv_write_indirect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\n\nstatic __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sv_read_indirect",
          "args": [
            "sc",
            "SV_PLAY_RECORD_ENABLE"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"eap: sv_halt_in_dma\\n\")"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_halt_in_dma;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write_indirect;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_halt_in_dma(addr)\n\tvoid *addr;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n    \n        DPRINTF((\"eap: sv_halt_in_dma\\n\"));\n\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\tmode &= ~SV_RECORD_ENABLE;\n\tsc->sc_enable &= ~SV_RECORD_ENABLE;\n\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\n        return (0);\n}"
  },
  {
    "function_name": "sv_halt_out_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "943-957",
    "snippet": "int\nsv_halt_out_dma(addr)\n\tvoid *addr;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n\t\n        DPRINTF((\"eap: sv_halt_out_dma\\n\"));\n\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\tmode &= ~SV_PLAY_ENABLE;\n\tsc->sc_enable &= ~SV_PLAY_ENABLE;\n\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\n        return (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_halt_out_dma",
      "static __inline__ u_int8_t sv_read_indirect",
      "static __inline__ void sv_write_indirect",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_write_indirect",
          "args": [
            "sc",
            "SV_PLAY_RECORD_ENABLE",
            "mode"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "sv_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "238-260",
          "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void sv_write",
            "static __inline__ void sv_write_indirect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\n\nstatic __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sv_read_indirect",
          "args": [
            "sc",
            "SV_PLAY_RECORD_ENABLE"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"eap: sv_halt_out_dma\\n\")"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_halt_out_dma;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write_indirect;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_halt_out_dma(addr)\n\tvoid *addr;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n\t\n        DPRINTF((\"eap: sv_halt_out_dma\\n\"));\n\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\tmode &= ~SV_PLAY_ENABLE;\n\tsc->sc_enable &= ~SV_PLAY_ENABLE;\n\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\n        return (0);\n}"
  },
  {
    "function_name": "sv_dma_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "914-941",
    "snippet": "int\nsv_dma_input(addr, p, cc, intr, arg)\n\tvoid *addr;\n\tvoid *p;\n\tint cc;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n\n\tDPRINTFN(1, (\"sv_dma_input: sc=%p buf=%p cc=%d intr=%p(%p)\\n\", \n\t\t     addr, p, cc, intr, arg));\n\tsc->sc_rintr = intr;\n\tsc->sc_rarg = arg;\n\tif (!(sc->sc_enable & SV_RECORD_ENABLE)) {\n\t        int dma_count = (cc >> 1) - 1;\n\n\t\tsv_write_indirect(sc, SV_DMAC_COUNT1, dma_count >> 8);\n\t\tsv_write_indirect(sc, SV_DMAC_COUNT0, (dma_count & 0xFF));\n\n\t\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\t\tmode |= SV_RECORD_ENABLE;\n\t\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\t\tsc->sc_enable |= SV_RECORD_ENABLE;\n\t}\n        return (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_dma_input",
      "static __inline__ u_int8_t sv_read_indirect",
      "static __inline__ void sv_write_indirect",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_write_indirect",
          "args": [
            "sc",
            "SV_PLAY_RECORD_ENABLE",
            "mode"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "sv_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "238-260",
          "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void sv_write",
            "static __inline__ void sv_write_indirect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\n\nstatic __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sv_read_indirect",
          "args": [
            "sc",
            "SV_PLAY_RECORD_ENABLE"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"sv_dma_input: sc=%p buf=%p cc=%d intr=%p(%p)\\n\", \n\t\t     addr, p, cc, intr, arg)"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_dma_input;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write_indirect;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_dma_input(addr, p, cc, intr, arg)\n\tvoid *addr;\n\tvoid *p;\n\tint cc;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n\n\tDPRINTFN(1, (\"sv_dma_input: sc=%p buf=%p cc=%d intr=%p(%p)\\n\", \n\t\t     addr, p, cc, intr, arg));\n\tsc->sc_rintr = intr;\n\tsc->sc_rarg = arg;\n\tif (!(sc->sc_enable & SV_RECORD_ENABLE)) {\n\t        int dma_count = (cc >> 1) - 1;\n\n\t\tsv_write_indirect(sc, SV_DMAC_COUNT1, dma_count >> 8);\n\t\tsv_write_indirect(sc, SV_DMAC_COUNT0, (dma_count & 0xFF));\n\n\t\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\t\tmode |= SV_RECORD_ENABLE;\n\t\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\t\tsc->sc_enable |= SV_RECORD_ENABLE;\n\t}\n        return (0);\n}"
  },
  {
    "function_name": "sv_dma_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "883-912",
    "snippet": "int\nsv_dma_output(addr, p, cc, intr, arg)\n\tvoid *addr;\n\tvoid *p;\n\tint cc;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n\n\tDPRINTFN(1, \n                 (\"sv_dma_output: sc=%p buf=%p cc=%d intr=%p(%p)\\n\", \n                  addr, p, cc, intr, arg));\n\n\tsc->sc_pintr = intr;\n\tsc->sc_parg = arg;\n\tif (!(sc->sc_enable & SV_PLAY_ENABLE)) {\n\t        int dma_count = cc - 1;\n\n\t\tsv_write_indirect(sc, SV_DMAA_COUNT1, dma_count >> 8);\n\t\tsv_write_indirect(sc, SV_DMAA_COUNT0, (dma_count & 0xFF));\n\n\t\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\t\tmode |= SV_PLAY_ENABLE;\n\t\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\t\tsc->sc_enable |= SV_PLAY_ENABLE;\n\t}\n        return (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_dma_output",
      "static __inline__ u_int8_t sv_read_indirect",
      "static __inline__ void sv_write_indirect",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_write_indirect",
          "args": [
            "sc",
            "SV_PLAY_RECORD_ENABLE",
            "mode"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "sv_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "238-260",
          "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void sv_write",
            "static __inline__ void sv_write_indirect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\n\nstatic __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sv_read_indirect",
          "args": [
            "sc",
            "SV_PLAY_RECORD_ENABLE"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"sv_dma_output: sc=%p buf=%p cc=%d intr=%p(%p)\\n\", \n                  addr, p, cc, intr, arg)"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_dma_output;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write_indirect;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_dma_output(addr, p, cc, intr, arg)\n\tvoid *addr;\n\tvoid *p;\n\tint cc;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n\n\tDPRINTFN(1, \n                 (\"sv_dma_output: sc=%p buf=%p cc=%d intr=%p(%p)\\n\", \n                  addr, p, cc, intr, arg));\n\n\tsc->sc_pintr = intr;\n\tsc->sc_parg = arg;\n\tif (!(sc->sc_enable & SV_PLAY_ENABLE)) {\n\t        int dma_count = cc - 1;\n\n\t\tsv_write_indirect(sc, SV_DMAA_COUNT1, dma_count >> 8);\n\t\tsv_write_indirect(sc, SV_DMAA_COUNT0, (dma_count & 0xFF));\n\n\t\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\t\tmode |= SV_PLAY_ENABLE;\n\t\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\t\tsc->sc_enable |= SV_PLAY_ENABLE;\n\t}\n        return (0);\n}"
  },
  {
    "function_name": "sv_dma_init_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "853-881",
    "snippet": "int\nsv_dma_init_output(addr, buf, cc)\n\tvoid *addr;\n\tvoid *buf;\n\tint cc;\n{\n\tstruct sv_softc *sc = addr;\n\tstruct sv_dma *p;\n\tint dma_count;\n\n\tDPRINTF((\"eap: dma start loop output buf=%p cc=%d\\n\", buf, cc));\n        for (p = sc->sc_dmas; p && KERNADDR(p) != buf; p = p->next)\n\t\t;\n\tif (!p) {\n\t\tprintf(\"sv_dma_init_output: bad addr %p\\n\", buf);\n\t\treturn (EINVAL);\n\t}\n\n\tdma_count = cc - 1;\n\n\tbus_space_write_4(sc->sc_iot, sc->sc_dmaa_ioh, SV_DMA_ADDR0,\n\t\t\t  DMAADDR(p));\n\tbus_space_write_4(sc->sc_iot, sc->sc_dmaa_ioh, SV_DMA_COUNT0,\n\t\t\t  dma_count);\n\tbus_space_write_1(sc->sc_iot, sc->sc_dmaa_ioh, SV_DMA_MODE,\n\t\t\t  DMA37MD_READ | DMA37MD_LOOP);\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_dma_init_output",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_dmaa_ioh",
            "SV_DMA_MODE",
            "DMA37MD_READ | DMA37MD_LOOP"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->sc_iot",
            "sc->sc_dmaa_ioh",
            "SV_DMA_COUNT0",
            "dma_count"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->sc_iot",
            "sc->sc_dmaa_ioh",
            "SV_DMA_ADDR0",
            "DMAADDR(p)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "p"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sv_dma_init_output: bad addr %p\\n\"",
            "buf"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "p"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"eap: dma start loop output buf=%p cc=%d\\n\", buf, cc)"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_dma_init_output;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_dma_init_output(addr, buf, cc)\n\tvoid *addr;\n\tvoid *buf;\n\tint cc;\n{\n\tstruct sv_softc *sc = addr;\n\tstruct sv_dma *p;\n\tint dma_count;\n\n\tDPRINTF((\"eap: dma start loop output buf=%p cc=%d\\n\", buf, cc));\n        for (p = sc->sc_dmas; p && KERNADDR(p) != buf; p = p->next)\n\t\t;\n\tif (!p) {\n\t\tprintf(\"sv_dma_init_output: bad addr %p\\n\", buf);\n\t\treturn (EINVAL);\n\t}\n\n\tdma_count = cc - 1;\n\n\tbus_space_write_4(sc->sc_iot, sc->sc_dmaa_ioh, SV_DMA_ADDR0,\n\t\t\t  DMAADDR(p));\n\tbus_space_write_4(sc->sc_iot, sc->sc_dmaa_ioh, SV_DMA_COUNT0,\n\t\t\t  dma_count);\n\tbus_space_write_1(sc->sc_iot, sc->sc_dmaa_ioh, SV_DMA_MODE,\n\t\t\t  DMA37MD_READ | DMA37MD_LOOP);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "sv_dma_init_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "822-851",
    "snippet": "int\nsv_dma_init_input(addr, buf, cc)\n\tvoid *addr;\n\tvoid *buf;\n\tint cc;\n{\n\tstruct sv_softc *sc = addr;\n\tstruct sv_dma *p;\n\tint dma_count;\n\n\tDPRINTF((\"sv_dma_init_input: dma start loop input addr=%p cc=%d\\n\", \n\t\t buf, cc));\n        for (p = sc->sc_dmas; p && KERNADDR(p) != buf; p = p->next)\n\t\t;\n\tif (!p) {\n\t\tprintf(\"sv_dma_init_input: bad addr %p\\n\", buf);\n\t\treturn (EINVAL);\n\t}\n\n\tdma_count = (cc >> 1) - 1;\n\n\tbus_space_write_4(sc->sc_iot, sc->sc_dmac_ioh, SV_DMA_ADDR0,\n\t\t\t  DMAADDR(p));\n\tbus_space_write_4(sc->sc_iot, sc->sc_dmac_ioh, SV_DMA_COUNT0,\n\t\t\t  dma_count);\n\tbus_space_write_1(sc->sc_iot, sc->sc_dmac_ioh, SV_DMA_MODE,\n\t\t\t  DMA37MD_WRITE | DMA37MD_LOOP);\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_dma_init_input",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_dmac_ioh",
            "SV_DMA_MODE",
            "DMA37MD_WRITE | DMA37MD_LOOP"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->sc_iot",
            "sc->sc_dmac_ioh",
            "SV_DMA_COUNT0",
            "dma_count"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->sc_iot",
            "sc->sc_dmac_ioh",
            "SV_DMA_ADDR0",
            "DMAADDR(p)"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "p"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sv_dma_init_input: bad addr %p\\n\"",
            "buf"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "p"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"sv_dma_init_input: dma start loop input addr=%p cc=%d\\n\", \n\t\t buf, cc)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_dma_init_input;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_dma_init_input(addr, buf, cc)\n\tvoid *addr;\n\tvoid *buf;\n\tint cc;\n{\n\tstruct sv_softc *sc = addr;\n\tstruct sv_dma *p;\n\tint dma_count;\n\n\tDPRINTF((\"sv_dma_init_input: dma start loop input addr=%p cc=%d\\n\", \n\t\t buf, cc));\n        for (p = sc->sc_dmas; p && KERNADDR(p) != buf; p = p->next)\n\t\t;\n\tif (!p) {\n\t\tprintf(\"sv_dma_init_input: bad addr %p\\n\", buf);\n\t\treturn (EINVAL);\n\t}\n\n\tdma_count = (cc >> 1) - 1;\n\n\tbus_space_write_4(sc->sc_iot, sc->sc_dmac_ioh, SV_DMA_ADDR0,\n\t\t\t  DMAADDR(p));\n\tbus_space_write_4(sc->sc_iot, sc->sc_dmac_ioh, SV_DMA_COUNT0,\n\t\t\t  dma_count);\n\tbus_space_write_1(sc->sc_iot, sc->sc_dmac_ioh, SV_DMA_MODE,\n\t\t\t  DMA37MD_WRITE | DMA37MD_LOOP);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "sv_round_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "814-820",
    "snippet": "int\nsv_round_blocksize(addr, blk)\n\tvoid *addr;\n\tint blk;\n{\n\treturn (blk & -32);\t/* keep good alignment */\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_round_blocksize",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_round_blocksize;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_round_blocksize(addr, blk)\n\tvoid *addr;\n\tint blk;\n{\n\treturn (blk & -32);\t/* keep good alignment */\n}"
  },
  {
    "function_name": "sv_set_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "680-812",
    "snippet": "int\nsv_set_params(addr, setmode, usemode, p, r)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *p, *r;\n{\n\tstruct sv_softc *sc = addr;\n\tvoid (*pswcode) __P((void *, u_char *buf, int cnt));\n\tvoid (*rswcode) __P((void *, u_char *buf, int cnt));\n        u_int32_t mode, val;\n        u_int8_t reg;\n\t\n        pswcode = rswcode = 0;\n        switch (p->encoding) {\n        case AUDIO_ENCODING_SLINEAR_BE:\n        \tif (p->precision == 16)\n                \trswcode = pswcode = swap_bytes;\n\t\telse\n\t\t\tpswcode = rswcode = change_sign8;\n\t\tbreak;\n        case AUDIO_ENCODING_SLINEAR_LE:\n        \tif (p->precision != 16)\n\t\t\tpswcode = rswcode = change_sign8;\n        \tbreak;\n        case AUDIO_ENCODING_ULINEAR_BE:\n        \tif (p->precision == 16) {\n\t\t\tpswcode = swap_bytes_change_sign16;\n\t\t\trswcode = change_sign16_swap_bytes;\n\t\t}\n\t\tbreak;\n        case AUDIO_ENCODING_ULINEAR_LE:\n        \tif (p->precision == 16)\n\t\t\tpswcode = rswcode = change_sign16;\n        \tbreak;\n        case AUDIO_ENCODING_ULAW:\n        \tpswcode = mulaw_to_ulinear8;\n                rswcode = ulinear8_to_mulaw;\n                break;\n        case AUDIO_ENCODING_ALAW:\n                pswcode = alaw_to_ulinear8;\n                rswcode = ulinear8_to_alaw;\n                break;\n        default:\n        \treturn (EINVAL);\n        }\n\n\tif (p->precision == 16)\n\t\tmode = SV_DMAA_FORMAT16 | SV_DMAC_FORMAT16;\n\telse\n\t\tmode = 0;\n        if (p->channels == 2)\n        \tmode |= SV_DMAA_STEREO | SV_DMAC_STEREO;\n\telse if (p->channels != 1)\n\t\treturn (EINVAL);\n        if (p->sample_rate < 2000 || p->sample_rate > 48000)\n        \treturn (EINVAL);\n\n        p->sw_code = pswcode;\n        r->sw_code = rswcode;\n\n        /* Set the encoding */\n\treg = sv_read_indirect(sc, SV_DMA_DATA_FORMAT);\n\treg &= ~(SV_DMAA_FORMAT16 | SV_DMAC_FORMAT16 | SV_DMAA_STEREO |\n\t\t SV_DMAC_STEREO);\n\treg |= (mode);\n\tsv_write_indirect(sc, SV_DMA_DATA_FORMAT, reg);\n\n\tval = p->sample_rate * 65536 / 48000;\n\n\tsv_write_indirect(sc, SV_PCM_SAMPLE_RATE_0, (val & 0xff));\n\tsv_write_indirect(sc, SV_PCM_SAMPLE_RATE_1, (val >> 8));\n\n#define F_REF 24576000\n\n#define ABS(x) (((x) < 0) ? (-x) : (x))\n\n\tif (setmode & AUMODE_RECORD)\n\t{\n\t  /* The ADC reference frequency (f_out) is 512 * the sample rate */\n\n\t  /* f_out is dervied from the 24.576MHZ crystal by three values:\n\t     M & N & R. The equation is as follows:\n\n\t     f_out = (m + 2) * f_ref / ((n + 2) * (2 ^ a))\n\n\t     with the constraint that:\n\n\t     80 MhZ < (m + 2) / (n + 2) * f_ref <= 150Mhz\n\t     and n, m >= 1\n\t  */\n\n\t  int  goal_f_out = 512 * r->sample_rate;\n\t  int  a, n, m, best_n, best_m, best_error = 10000000;\n\t  int  pll_sample;\n\n\t  for (a = 0; a < 8; a++) {\n\t    if ((goal_f_out * (1 << a)) >= 80000000)\n\t      break;\n\t  }\n\t  \n\t  /* a != 8 because sample_rate >= 2000 */\n\n\t  for (n = 33; n > 2; n--) {\n\t    int error;\n\n\t    m = (goal_f_out * n * (1 << a)) / F_REF;\n\n\t    if ((m > 257) || (m < 3)) continue;\n \n\t    pll_sample = (m * F_REF) / (n * (1 << a));\n\t    pll_sample /= 512;\n\n\t    /* Threshold might be good here */\n\t    error = pll_sample - r->sample_rate;\n\t    error = ABS(error);\n\t    \n\t    if (error < best_error) {\n\t      best_error = error;\n\t      best_n = n;\n\t      best_m = m;\n\t      if (error == 0) break;\n\t    }\n\t  }\n\t\n\n\t  best_n -= 2;\n\t  best_m -= 2;\n\t  \n\t  sv_write_indirect(sc, SV_ADC_PLL_M, best_m);\n\t  sv_write_indirect(sc, SV_ADC_PLL_N, best_n | (a << SV_PLL_R_SHIFT));\n\t}\n        return (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define F_REF 24576000"
    ],
    "globals_used": [
      "int\tsv_set_params",
      "static __inline__ u_int8_t sv_read_indirect",
      "static __inline__ void sv_write_indirect",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_write_indirect",
          "args": [
            "sc",
            "SV_ADC_PLL_N",
            "best_n | (a << SV_PLL_R_SHIFT)"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "sv_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "238-260",
          "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void sv_write",
            "static __inline__ void sv_write_indirect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\n\nstatic __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ABS",
          "args": [
            "error"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sv_read_indirect",
          "args": [
            "sc",
            "SV_DMA_DATA_FORMAT"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *, u_char *buf, int cnt)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *, u_char *buf, int cnt)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define F_REF 24576000\n\nint\tsv_set_params;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write_indirect;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_set_params(addr, setmode, usemode, p, r)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *p, *r;\n{\n\tstruct sv_softc *sc = addr;\n\tvoid (*pswcode) __P((void *, u_char *buf, int cnt));\n\tvoid (*rswcode) __P((void *, u_char *buf, int cnt));\n        u_int32_t mode, val;\n        u_int8_t reg;\n\t\n        pswcode = rswcode = 0;\n        switch (p->encoding) {\n        case AUDIO_ENCODING_SLINEAR_BE:\n        \tif (p->precision == 16)\n                \trswcode = pswcode = swap_bytes;\n\t\telse\n\t\t\tpswcode = rswcode = change_sign8;\n\t\tbreak;\n        case AUDIO_ENCODING_SLINEAR_LE:\n        \tif (p->precision != 16)\n\t\t\tpswcode = rswcode = change_sign8;\n        \tbreak;\n        case AUDIO_ENCODING_ULINEAR_BE:\n        \tif (p->precision == 16) {\n\t\t\tpswcode = swap_bytes_change_sign16;\n\t\t\trswcode = change_sign16_swap_bytes;\n\t\t}\n\t\tbreak;\n        case AUDIO_ENCODING_ULINEAR_LE:\n        \tif (p->precision == 16)\n\t\t\tpswcode = rswcode = change_sign16;\n        \tbreak;\n        case AUDIO_ENCODING_ULAW:\n        \tpswcode = mulaw_to_ulinear8;\n                rswcode = ulinear8_to_mulaw;\n                break;\n        case AUDIO_ENCODING_ALAW:\n                pswcode = alaw_to_ulinear8;\n                rswcode = ulinear8_to_alaw;\n                break;\n        default:\n        \treturn (EINVAL);\n        }\n\n\tif (p->precision == 16)\n\t\tmode = SV_DMAA_FORMAT16 | SV_DMAC_FORMAT16;\n\telse\n\t\tmode = 0;\n        if (p->channels == 2)\n        \tmode |= SV_DMAA_STEREO | SV_DMAC_STEREO;\n\telse if (p->channels != 1)\n\t\treturn (EINVAL);\n        if (p->sample_rate < 2000 || p->sample_rate > 48000)\n        \treturn (EINVAL);\n\n        p->sw_code = pswcode;\n        r->sw_code = rswcode;\n\n        /* Set the encoding */\n\treg = sv_read_indirect(sc, SV_DMA_DATA_FORMAT);\n\treg &= ~(SV_DMAA_FORMAT16 | SV_DMAC_FORMAT16 | SV_DMAA_STEREO |\n\t\t SV_DMAC_STEREO);\n\treg |= (mode);\n\tsv_write_indirect(sc, SV_DMA_DATA_FORMAT, reg);\n\n\tval = p->sample_rate * 65536 / 48000;\n\n\tsv_write_indirect(sc, SV_PCM_SAMPLE_RATE_0, (val & 0xff));\n\tsv_write_indirect(sc, SV_PCM_SAMPLE_RATE_1, (val >> 8));\n\n#define F_REF 24576000\n\n#define ABS(x) (((x) < 0) ? (-x) : (x))\n\n\tif (setmode & AUMODE_RECORD)\n\t{\n\t  /* The ADC reference frequency (f_out) is 512 * the sample rate */\n\n\t  /* f_out is dervied from the 24.576MHZ crystal by three values:\n\t     M & N & R. The equation is as follows:\n\n\t     f_out = (m + 2) * f_ref / ((n + 2) * (2 ^ a))\n\n\t     with the constraint that:\n\n\t     80 MhZ < (m + 2) / (n + 2) * f_ref <= 150Mhz\n\t     and n, m >= 1\n\t  */\n\n\t  int  goal_f_out = 512 * r->sample_rate;\n\t  int  a, n, m, best_n, best_m, best_error = 10000000;\n\t  int  pll_sample;\n\n\t  for (a = 0; a < 8; a++) {\n\t    if ((goal_f_out * (1 << a)) >= 80000000)\n\t      break;\n\t  }\n\t  \n\t  /* a != 8 because sample_rate >= 2000 */\n\n\t  for (n = 33; n > 2; n--) {\n\t    int error;\n\n\t    m = (goal_f_out * n * (1 << a)) / F_REF;\n\n\t    if ((m > 257) || (m < 3)) continue;\n \n\t    pll_sample = (m * F_REF) / (n * (1 << a));\n\t    pll_sample /= 512;\n\n\t    /* Threshold might be good here */\n\t    error = pll_sample - r->sample_rate;\n\t    error = ABS(error);\n\t    \n\t    if (error < best_error) {\n\t      best_error = error;\n\t      best_n = n;\n\t      best_m = m;\n\t      if (error == 0) break;\n\t    }\n\t  }\n\t\n\n\t  best_n -= 2;\n\t  best_m -= 2;\n\t  \n\t  sv_write_indirect(sc, SV_ADC_PLL_M, best_m);\n\t  sv_write_indirect(sc, SV_ADC_PLL_N, best_n | (a << SV_PLL_R_SHIFT));\n\t}\n        return (0);\n}"
  },
  {
    "function_name": "sv_query_encoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "621-678",
    "snippet": "int\nsv_query_encoding(addr, fp)\n\tvoid *addr;\n\tstruct audio_encoding *fp;\n{\n\tswitch (fp->index) {\n\tcase 0:\n\t\tstrcpy(fp->name, AudioEulinear);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 1:\n\t\tstrcpy(fp->name, AudioEmulaw);\n\t\tfp->encoding = AUDIO_ENCODING_ULAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 2:\n\t\tstrcpy(fp->name, AudioEalaw);\n\t\tfp->encoding = AUDIO_ENCODING_ALAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 3:\n\t\tstrcpy(fp->name, AudioEslinear);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n        case 4:\n\t\tstrcpy(fp->name, AudioEslinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 5:\n\t\tstrcpy(fp->name, AudioEulinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 6:\n\t\tstrcpy(fp->name, AudioEslinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 7:\n\t\tstrcpy(fp->name, AudioEulinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_query_encoding",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_be"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_be"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_le"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_le"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEalaw"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEmulaw"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_query_encoding;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint flags;\n\nint\nsv_query_encoding(addr, fp)\n\tvoid *addr;\n\tstruct audio_encoding *fp;\n{\n\tswitch (fp->index) {\n\tcase 0:\n\t\tstrcpy(fp->name, AudioEulinear);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 1:\n\t\tstrcpy(fp->name, AudioEmulaw);\n\t\tfp->encoding = AUDIO_ENCODING_ULAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 2:\n\t\tstrcpy(fp->name, AudioEalaw);\n\t\tfp->encoding = AUDIO_ENCODING_ALAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 3:\n\t\tstrcpy(fp->name, AudioEslinear);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n        case 4:\n\t\tstrcpy(fp->name, AudioEslinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 5:\n\t\tstrcpy(fp->name, AudioEulinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 6:\n\t\tstrcpy(fp->name, AudioEslinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 7:\n\t\tstrcpy(fp->name, AudioEulinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n}"
  },
  {
    "function_name": "sv_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "608-619",
    "snippet": "void\nsv_close(addr)\n\tvoid *addr;\n{\n\tstruct sv_softc *sc = addr;\n    \n        sv_halt_in_dma(sc);\n        sv_halt_out_dma(sc);\n\n        sc->sc_pintr = 0;\n        sc->sc_rintr = 0;\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsv_close",
      "int\tsv_halt_in_dma",
      "int\tsv_halt_out_dma",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_halt_out_dma",
          "args": [
            "sc"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "sv_halt_out_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "943-957",
          "snippet": "int\nsv_halt_out_dma(addr)\n\tvoid *addr;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n\t\n        DPRINTF((\"eap: sv_halt_out_dma\\n\"));\n\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\tmode &= ~SV_PLAY_ENABLE;\n\tsc->sc_enable &= ~SV_PLAY_ENABLE;\n\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\n        return (0);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsv_halt_out_dma",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write_indirect",
            "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_halt_out_dma;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write_indirect;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_halt_out_dma(addr)\n\tvoid *addr;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n\t\n        DPRINTF((\"eap: sv_halt_out_dma\\n\"));\n\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\tmode &= ~SV_PLAY_ENABLE;\n\tsc->sc_enable &= ~SV_PLAY_ENABLE;\n\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\n        return (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sv_halt_in_dma",
          "args": [
            "sc"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "sv_halt_in_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "959-973",
          "snippet": "int\nsv_halt_in_dma(addr)\n\tvoid *addr;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n    \n        DPRINTF((\"eap: sv_halt_in_dma\\n\"));\n\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\tmode &= ~SV_RECORD_ENABLE;\n\tsc->sc_enable &= ~SV_RECORD_ENABLE;\n\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\n        return (0);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tsv_halt_in_dma",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write_indirect",
            "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_halt_in_dma;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write_indirect;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nsv_halt_in_dma(addr)\n\tvoid *addr;\n{\n\tstruct sv_softc *sc = addr;\n\tu_int8_t mode;\n    \n        DPRINTF((\"eap: sv_halt_in_dma\\n\"));\n\tmode = sv_read_indirect(sc, SV_PLAY_RECORD_ENABLE);\n\tmode &= ~SV_RECORD_ENABLE;\n\tsc->sc_enable &= ~SV_RECORD_ENABLE;\n\tsv_write_indirect(sc, SV_PLAY_RECORD_ENABLE, mode);\n\n        return (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tsv_close;\nint\tsv_halt_in_dma;\nint\tsv_halt_out_dma;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\nsv_close(addr)\n\tvoid *addr;\n{\n\tstruct sv_softc *sc = addr;\n    \n        sv_halt_in_dma(sc);\n        sv_halt_out_dma(sc);\n\n        sc->sc_pintr = 0;\n        sc->sc_rintr = 0;\n}"
  },
  {
    "function_name": "sv_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "523-603",
    "snippet": "int\nsv_open(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\n    struct sv_softc *sc = addr;\n    int  intr_mask = 0;\n    u_int8_t reg;\n\n    /* Map the DMA channels, if necessary */\n    if (!(sc->sc_dma_configured & SV_DMAA_CONFIGURED)) {\n\t/* XXX - there seems to be no general way to find an\n\t   I/O range */\n\tint dmaio;\n\tint iosize = 0x10;\n\n\tif (sc->sc_dma_configured & SV_DMAA_TRIED_CONFIGURE)\n\t    return (ENXIO);\n\n\tfor (dmaio = 0xa000; dmaio < 0xb000; dmaio += iosize) {\n\t    if (!bus_space_map(sc->sc_iot, dmaio, iosize, 0, \n\t\t\t      &sc->sc_dmaa_ioh)) {\n\t\tgoto found_dmaa;\n\t    }\n\t}\n\n\tsc->sc_dma_configured |= SV_DMAA_TRIED_CONFIGURE;\n\treturn (ENXIO);\n    found_dmaa:\n\t  \n\tpci_conf_write(sc->sc_pci_chipset_tag, sc->sc_pci_tag,\n\t\t       SV_DMAA_CONFIG_OFF, \n\t\t       dmaio | SV_DMA_CHANNEL_ENABLE \n\t\t       | SV_DMAA_EXTENDED_ADDR);\n\n\tsc->sc_dma_configured |= SV_DMAA_CONFIGURED;\n\tintr_mask = 1;\n    }\n\n    if (!(sc->sc_dma_configured & SV_DMAC_CONFIGURED)) {\n\t/* XXX - there seems to be no general way to find an\n\t   I/O range */\n\tint dmaio;\n\tint iosize = 0x10;\n\n\tif (sc->sc_dma_configured & SV_DMAC_TRIED_CONFIGURE)\n\t    return (ENXIO);\n\n\tfor (dmaio = 0xa000; dmaio < 0xb000; dmaio += iosize) {\n\t    if (!bus_space_map(sc->sc_iot, dmaio, iosize, 0, \n\t\t\t      &sc->sc_dmac_ioh)) {\n\t\tgoto found_dmac;\n\t    }\n\t}\n\n\tsc->sc_dma_configured |= SV_DMAC_TRIED_CONFIGURE;\t    \n\treturn (ENXIO);\n    found_dmac:\n\t  \n\tpci_conf_write(sc->sc_pci_chipset_tag, sc->sc_pci_tag,\n\t\t       SV_DMAC_CONFIG_OFF, \n\t\t       dmaio | SV_DMA_CHANNEL_ENABLE);\n\n\tsc->sc_dma_configured |= SV_DMAC_CONFIGURED;\n\tintr_mask = 1;\n    }\n\n    /* Make sure DMA interrupts are enabled */\n    if (intr_mask) {\n\treg = sv_read(sc, SV_CODEC_INTMASK);\n\treg &= ~(SV_INTMASK_DMAA | SV_INTMASK_DMAC);\n\treg |= SV_INTMASK_UD | SV_INTMASK_SINT | SV_INTMASK_MIDI;\n\tsv_write(sc, SV_CODEC_INTMASK, reg);\n    }\n\n    sc->sc_pintr = 0;\n    sc->sc_rintr = 0;\n\n    return (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_open",
      "static __inline__ u_int8_t sv_read",
      "static __inline__ void sv_write",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "int flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_write",
          "args": [
            "sc",
            "SV_CODEC_INTMASK",
            "reg"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "sv_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "238-260",
          "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void sv_write",
            "static __inline__ void sv_write_indirect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\n\nstatic __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sv_read",
          "args": [
            "sc",
            "SV_CODEC_INTMASK"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pci_chipset_tag",
            "sc->sc_pci_tag",
            "SV_DMAC_CONFIG_OFF",
            "dmaio | SV_DMA_CHANNEL_ENABLE"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "dmaio",
            "iosize",
            "0",
            "&sc->sc_dmac_ioh"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->sc_pci_chipset_tag",
            "sc->sc_pci_tag",
            "SV_DMAA_CONFIG_OFF",
            "dmaio | SV_DMA_CHANNEL_ENABLE \n\t\t       | SV_DMAA_EXTENDED_ADDR"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "dmaio",
            "iosize",
            "0",
            "&sc->sc_dmaa_ioh"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_open;\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ void sv_write;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint flags;\n\nint\nsv_open(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\n    struct sv_softc *sc = addr;\n    int  intr_mask = 0;\n    u_int8_t reg;\n\n    /* Map the DMA channels, if necessary */\n    if (!(sc->sc_dma_configured & SV_DMAA_CONFIGURED)) {\n\t/* XXX - there seems to be no general way to find an\n\t   I/O range */\n\tint dmaio;\n\tint iosize = 0x10;\n\n\tif (sc->sc_dma_configured & SV_DMAA_TRIED_CONFIGURE)\n\t    return (ENXIO);\n\n\tfor (dmaio = 0xa000; dmaio < 0xb000; dmaio += iosize) {\n\t    if (!bus_space_map(sc->sc_iot, dmaio, iosize, 0, \n\t\t\t      &sc->sc_dmaa_ioh)) {\n\t\tgoto found_dmaa;\n\t    }\n\t}\n\n\tsc->sc_dma_configured |= SV_DMAA_TRIED_CONFIGURE;\n\treturn (ENXIO);\n    found_dmaa:\n\t  \n\tpci_conf_write(sc->sc_pci_chipset_tag, sc->sc_pci_tag,\n\t\t       SV_DMAA_CONFIG_OFF, \n\t\t       dmaio | SV_DMA_CHANNEL_ENABLE \n\t\t       | SV_DMAA_EXTENDED_ADDR);\n\n\tsc->sc_dma_configured |= SV_DMAA_CONFIGURED;\n\tintr_mask = 1;\n    }\n\n    if (!(sc->sc_dma_configured & SV_DMAC_CONFIGURED)) {\n\t/* XXX - there seems to be no general way to find an\n\t   I/O range */\n\tint dmaio;\n\tint iosize = 0x10;\n\n\tif (sc->sc_dma_configured & SV_DMAC_TRIED_CONFIGURE)\n\t    return (ENXIO);\n\n\tfor (dmaio = 0xa000; dmaio < 0xb000; dmaio += iosize) {\n\t    if (!bus_space_map(sc->sc_iot, dmaio, iosize, 0, \n\t\t\t      &sc->sc_dmac_ioh)) {\n\t\tgoto found_dmac;\n\t    }\n\t}\n\n\tsc->sc_dma_configured |= SV_DMAC_TRIED_CONFIGURE;\t    \n\treturn (ENXIO);\n    found_dmac:\n\t  \n\tpci_conf_write(sc->sc_pci_chipset_tag, sc->sc_pci_tag,\n\t\t       SV_DMAC_CONFIG_OFF, \n\t\t       dmaio | SV_DMA_CHANNEL_ENABLE);\n\n\tsc->sc_dma_configured |= SV_DMAC_CONFIGURED;\n\tintr_mask = 1;\n    }\n\n    /* Make sure DMA interrupts are enabled */\n    if (intr_mask) {\n\treg = sv_read(sc, SV_CODEC_INTMASK);\n\treg &= ~(SV_INTMASK_DMAA | SV_INTMASK_DMAC);\n\treg |= SV_INTMASK_UD | SV_INTMASK_SINT | SV_INTMASK_MIDI;\n\tsv_write(sc, SV_CODEC_INTMASK, reg);\n    }\n\n    sc->sc_pintr = 0;\n    sc->sc_rintr = 0;\n\n    return (0);\n}"
  },
  {
    "function_name": "sv_freemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "511-521",
    "snippet": "int\nsv_freemem(sc, p)\n\tstruct sv_softc *sc;\n        struct sv_dma *p;\n{\n\tbus_dmamap_unload(sc->sc_dmatag, p->map);\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_freemem",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "u_long size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "p->segs",
            "p->nsegs"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "p->addr",
            "p->size"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "sc->sc_dmatag",
            "p->map"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "sc->sc_dmatag",
            "p->map"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_freemem;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\nu_long size;\n\nint\nsv_freemem(sc, p)\n\tstruct sv_softc *sc;\n        struct sv_dma *p;\n{\n\tbus_dmamap_unload(sc->sc_dmatag, p->map);\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (0);\n}"
  },
  {
    "function_name": "sv_allocmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "470-509",
    "snippet": "int\nsv_allocmem(sc, size, align, p)\n\tstruct sv_softc *sc;\n\tsize_t size;\n\tsize_t align;\n        struct sv_dma *p;\n{\n\tint error;\n\n\tp->size = size;\n\terror = bus_dmamem_alloc(sc->sc_dmatag, p->size, align, 0,\n\t\t\t\t p->segs, ARRAY_SIZE(p->segs),\n\t\t\t\t &p->nsegs, BUS_DMA_NOWAIT);\n\tif (error)\n\t\treturn (error);\n\n\terror = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size, \n\t\t\t       &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);\n\tif (error)\n\t\tgoto free;\n\n\terror = bus_dmamap_create(sc->sc_dmatag, p->size, 1, p->size,\n\t\t\t\t  0, BUS_DMA_NOWAIT, &p->map);\n\tif (error)\n\t\tgoto unmap;\n\n\terror = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL, \n\t\t\t\tBUS_DMA_NOWAIT);\n\tif (error)\n\t\tgoto destroy;\n\treturn (0);\n\ndestroy:\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\nunmap:\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\nfree:\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (error);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_allocmem",
      "void *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "u_long size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "p->segs",
            "p->nsegs"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "p->addr",
            "p->size"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "sc->sc_dmatag",
            "p->map"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmatag",
            "p->map",
            "p->addr",
            "p->size",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmatag",
            "p->size",
            "1",
            "p->size",
            "0",
            "BUS_DMA_NOWAIT",
            "&p->map"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmatag",
            "p->segs",
            "p->nsegs",
            "p->size",
            "&p->addr",
            "BUS_DMA_NOWAIT|BUS_DMA_COHERENT"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmatag",
            "p->size",
            "align",
            "0",
            "p->segs",
            "ARRAY_SIZE(p->segs)",
            "&p->nsegs",
            "BUS_DMA_NOWAIT"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "p->segs"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_allocmem;\nvoid *\nsv_malloc(addr, size, pool, flags)\n\tvoid *addr;\nu_long size;\n\nint\nsv_allocmem(sc, size, align, p)\n\tstruct sv_softc *sc;\n\tsize_t size;\n\tsize_t align;\n        struct sv_dma *p;\n{\n\tint error;\n\n\tp->size = size;\n\terror = bus_dmamem_alloc(sc->sc_dmatag, p->size, align, 0,\n\t\t\t\t p->segs, ARRAY_SIZE(p->segs),\n\t\t\t\t &p->nsegs, BUS_DMA_NOWAIT);\n\tif (error)\n\t\treturn (error);\n\n\terror = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size, \n\t\t\t       &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);\n\tif (error)\n\t\tgoto free;\n\n\terror = bus_dmamap_create(sc->sc_dmatag, p->size, 1, p->size,\n\t\t\t\t  0, BUS_DMA_NOWAIT, &p->map);\n\tif (error)\n\t\tgoto unmap;\n\n\terror = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL, \n\t\t\t\tBUS_DMA_NOWAIT);\n\tif (error)\n\t\tgoto destroy;\n\treturn (0);\n\ndestroy:\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\nunmap:\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\nfree:\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (error);\n}"
  },
  {
    "function_name": "sv_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "445-468",
    "snippet": "int\nsv_intr(p)\n\tvoid *p;\n{\n  struct sv_softc *sc = p;\n  u_int8_t intr;\n\n  intr = sv_read(sc, SV_CODEC_STATUS);\n\n  if (!(intr & (SV_INTSTATUS_DMAA | SV_INTSTATUS_DMAC))) \n    return (0);\n\n  if (intr & SV_INTSTATUS_DMAA) {\n    if (sc->sc_pintr)\n      sc->sc_pintr(sc->sc_parg);\n  }\n\n  if (intr & SV_INTSTATUS_DMAC) {\n    if (sc->sc_rintr)\n      sc->sc_rintr(sc->sc_rarg);\n  }\n\n  return (1);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsv_intr",
      "static __inline__ u_int8_t sv_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->sc_rintr",
          "args": [
            "sc->sc_rarg"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_pintr",
          "args": [
            "sc->sc_parg"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sv_read",
          "args": [
            "sc",
            "SV_CODEC_STATUS"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tsv_intr;\nstatic __inline__ u_int8_t sv_read;\n\nint\nsv_intr(p)\n\tvoid *p;\n{\n  struct sv_softc *sc = p;\n  u_int8_t intr;\n\n  intr = sv_read(sc, SV_CODEC_STATUS);\n\n  if (!(intr & (SV_INTSTATUS_DMAA | SV_INTSTATUS_DMAC))) \n    return (0);\n\n  if (intr & SV_INTSTATUS_DMAA) {\n    if (sc->sc_pintr)\n      sc->sc_pintr(sc->sc_parg);\n  }\n\n  if (intr & SV_INTSTATUS_DMAC) {\n    if (sc->sc_rintr)\n      sc->sc_rintr(sc->sc_rarg);\n  }\n\n  return (1);\n}"
  },
  {
    "function_name": "sv_dumpregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "415-442",
    "snippet": "void\nsv_dumpregs(sc)\n     struct sv_softc *sc;\n{\n  int idx;\n\n  { int idx;\n  for (idx = 0; idx < 0x50; idx += 4) {\n    printf (\"%02x = %x\\n\", idx, pci_conf_read(sc->sc_pci_chipset_tag,\n            sc->sc_pci_tag, idx));\n  }\n  }\n\n  for (idx = 0; idx < 6; idx++) {\n    printf (\"REG %02x = %02x\\n\", idx, sv_read(sc, idx));\n  }\n\n  for (idx = 0; idx < 0x32; idx++) {\n    printf (\"IREG %02x = %02x\\n\", idx, sv_read_indirect(sc, idx));\n  }\n\n  for (idx = 0; idx < 0x10; idx++) {\n    printf (\"DMA %02x = %02x\\n\", idx, \n\t    bus_space_read_1(sc->sc_iot, sc->sc_dmaa_ioh, idx));\n  }\n\n  return;\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void    sv_dumpregs",
      "static __inline__ u_int8_t sv_read",
      "static __inline__ u_int8_t sv_read_indirect"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DMA %02x = %02x\\n\"",
            "idx",
            "bus_space_read_1(sc->sc_iot, sc->sc_dmaa_ioh, idx)"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_dmaa_ioh",
            "idx"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sv_read_indirect",
          "args": [
            "sc",
            "idx"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->sc_pci_chipset_tag",
            "sc->sc_pci_tag",
            "idx"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid    sv_dumpregs;\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\n\nvoid\nsv_dumpregs(sc)\n     struct sv_softc *sc;\n{\n  int idx;\n\n  { int idx;\n  for (idx = 0; idx < 0x50; idx += 4) {\n    printf (\"%02x = %x\\n\", idx, pci_conf_read(sc->sc_pci_chipset_tag,\n            sc->sc_pci_tag, idx));\n  }\n  }\n\n  for (idx = 0; idx < 6; idx++) {\n    printf (\"REG %02x = %02x\\n\", idx, sv_read(sc, idx));\n  }\n\n  for (idx = 0; idx < 0x32; idx++) {\n    printf (\"IREG %02x = %02x\\n\", idx, sv_read_indirect(sc, idx));\n  }\n\n  for (idx = 0; idx < 0x10; idx++) {\n    printf (\"DMA %02x = %02x\\n\", idx, \n\t    bus_space_read_1(sc->sc_iot, sc->sc_dmaa_ioh, idx));\n  }\n\n  return;\n}"
  },
  {
    "function_name": "sv_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "276-412",
    "snippet": "static void\nsv_attach(parent, self, aux)\n     struct device *parent, *self;\n     void *aux;\n\n{\n  struct sv_softc *sc = (struct sv_softc *)self;\n  struct pci_attach_args *pa = aux;\n  pci_chipset_tag_t pc = pa->pa_pc;\n  pci_intr_handle_t ih;\n  bus_addr_t iobase;\n  bus_size_t iosize;\n  pcireg_t csr;\n  char const *intrstr;\n  u_int32_t  dmareg, dmaio; \n  u_int8_t   reg;\n\n  sc->sc_pci_chipset_tag = pc;\n  sc->sc_pci_tag = pa->pa_tag;\n\n  /* Map the enhanced port only */\n  if (pci_io_find(pc, pa->pa_tag, SV_ENHANCED_PORTBASE_SLOT, \n\t\t  &iobase, &iosize)) {\n    printf (\": Couldn't find enhanced synth I/O range\\n\");\n    return;\n  }\n\n  if (bus_space_map(sc->sc_iot, iobase, iosize, 0, &sc->sc_ioh)) {\n      printf(\": can't map i/o space\\n\");\n      return;\n  }\n\n  sc->sc_dmatag = pa->pa_dmat;\n\n  dmareg = pci_conf_read(pa->pa_pc, pa->pa_tag, SV_DMAA_CONFIG_OFF);\n  iosize = 0x10;\n  dmaio =  dmareg & ~(iosize - 1);\n  \n  if (dmaio) {\n    dmareg &= 0xF;\n    \n    if (bus_space_map(sc->sc_iot, dmaio, iosize, 0, &sc->sc_dmaa_ioh)) {\n      /* The BIOS assigned us some bad I/O address! Make sure to clear\n         and disable this DMA before we enable the device */\n      pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAA_CONFIG_OFF, 0);\n\n      printf (\": can't map DMA i/o space\\n\");\n      goto enable;\n    }\n\n    pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAA_CONFIG_OFF,\n\t\t   dmaio | dmareg | \n\t\t   SV_DMA_CHANNEL_ENABLE | SV_DMAA_EXTENDED_ADDR);\n    sc->sc_dma_configured |= SV_DMAA_CONFIGURED;\n  }\n\n  dmareg = pci_conf_read(pa->pa_pc, pa->pa_tag, SV_DMAC_CONFIG_OFF);\n  dmaio = dmareg & ~(iosize - 1);\n  if (dmaio) {\n    dmareg &= 0xF;\n\n    if (bus_space_map(sc->sc_iot, dmaio, iosize, 0, &sc->sc_dmac_ioh)) {\n      /* The BIOS assigned us some bad I/O address! Make sure to clear\n         and disable this DMA before we enable the device */\n      pci_conf_write (pa->pa_pc, pa->pa_tag, SV_DMAC_CONFIG_OFF, \n\t\t      dmareg & ~SV_DMA_CHANNEL_ENABLE); \n      printf (\": can't map DMA i/o space\\n\");\n      goto enable;\n    }\n\n    pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAC_CONFIG_OFF, \n\t\t   dmaio | dmareg | SV_DMA_CHANNEL_ENABLE);\n    sc->sc_dma_configured |= SV_DMAC_CONFIGURED;\n  }\n\n  /* Enable the device. */\n enable:\n  csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n  pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t csr | PCI_COMMAND_MASTER_ENABLE \n\t\t /* | PCI_COMMAND_IO_ENABLE | PCI_COMMAND_PARITY_ENABLE */);\n\n  sv_write_indirect(sc, SV_ANALOG_POWER_DOWN_CONTROL, 0);\n  sv_write_indirect(sc, SV_DIGITAL_POWER_DOWN_CONTROL, 0);\n\n  /* initialize codec registers */\n  reg = sv_read(sc, SV_CODEC_CONTROL);\n  reg |= SV_CTL_RESET;\n  sv_write(sc, SV_CODEC_CONTROL, reg);\n  delay(50);\n\n  reg = sv_read(sc, SV_CODEC_CONTROL);\n  reg &= ~SV_CTL_RESET;\n  reg |= SV_CTL_INTA | SV_CTL_ENHANCED;\n\n  /* This write clears the reset */\n  sv_write(sc, SV_CODEC_CONTROL, reg);\n  delay(50);\n\n  /* This write actually shoves the new values in */\n  sv_write(sc, SV_CODEC_CONTROL, reg);\n\n  DPRINTF ((\"reg: %x\\n\", sv_read(sc, SV_CODEC_CONTROL)));\n\n  /* Enable DMA interrupts */\n  reg = sv_read(sc, SV_CODEC_INTMASK);\n  reg &= ~(SV_INTMASK_DMAA | SV_INTMASK_DMAC);\n  reg |= SV_INTMASK_UD | SV_INTMASK_SINT | SV_INTMASK_MIDI;\n  sv_write(sc, SV_CODEC_INTMASK, reg);\n\n  sv_read(sc, SV_CODEC_STATUS);\n\n  sc->sc_trd = 0;\n  sc->sc_enable = 0;\n\n  /* Map and establish the interrupt. */\n  if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t   pa->pa_intrline, &ih)) {\n    printf(\": couldn't map interrupt\\n\");\n    return;\n  }\n  intrstr = pci_intr_string(pc, ih);\n  sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, sv_intr, sc,\n\t\t\t\t sc->sc_dev.dv_xname);\n  if (sc->sc_ih == NULL) {\n    printf(\": couldn't establish interrupt\");\n    if (intrstr != NULL)\n      printf(\" at %s\", intrstr);\n    printf(\"\\n\");\n    return;\n  }\n  printf(\": %s\\n\", intrstr);\n\n  sv_init_mixer(sc);\n\n  audio_attach_mi(&sv_hw_if, sc, &sc->sc_dev);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tsv_attach",
      "int\tsv_intr",
      "struct audio_hw_if sv_hw_if = {\n\tsv_open,\n\tsv_close,\n\tNULL,\n\tsv_query_encoding,\n\tsv_set_params,\n\tsv_round_blocksize,\n\tNULL,\n\tsv_dma_init_output,\n\tsv_dma_init_input,\n\tsv_dma_output,\n\tsv_dma_input,\n\tsv_halt_out_dma,\n\tsv_halt_in_dma,\n\tNULL,\n\tsv_getdev,\n\tNULL,\n\tsv_mixer_set_port,\n\tsv_mixer_get_port,\n\tsv_query_devinfo,\n\tsv_malloc,\n\tsv_free,\n\tsv_round,\n\tsv_mappage,\n\tsv_get_props,\n\tNULL,\n\tNULL\n};",
      "static __inline__ u_int8_t sv_read",
      "static __inline__ void sv_write",
      "static __inline__ void sv_write_indirect",
      "static void sv_init_mixer"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_attach_mi",
          "args": [
            "&sv_hw_if",
            "sc",
            "&sc->sc_dev"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "audio_attach_mi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "394-408",
          "snippet": "void\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sv_init_mixer",
          "args": [
            "sc"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "sv_init_mixer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "1420-1442",
          "snippet": "static void\nsv_init_mixer(sc)\n     struct sv_softc *sc;\n{\n  mixer_ctrl_t cp;\n  int idx;\n\n  cp.type = AUDIO_MIXER_ENUM;\n  cp.dev = SV_SRS_MODE;\n  cp.un.ord = 0;\n\n  sv_mixer_set_port(sc, &cp);\n\n  for (idx = 0; idx < ARRAY_SIZE(ports); idx++) {\n    if (ports[idx].audio == AudioNdac) {\n      cp.type = AUDIO_MIXER_ENUM;\n      cp.dev = SV_FIRST_MIXER + idx * SV_DEVICES_PER_PORT + 1;\n      cp.un.ord = 0;\n      sv_mixer_set_port(sc, &cp);\n      break;\n    }\n  }\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SV_SRS_MODE (SV_LAST_MIXER + 4)",
            "#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)",
            "#define SV_DEVICES_PER_PORT 2"
          ],
          "globals_used": [
            "int\tsv_mixer_set_port",
            "static void sv_init_mixer",
            "static const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SV_SRS_MODE (SV_LAST_MIXER + 4)\n#define SV_FIRST_MIXER (SV_LAST_CLASS + 1)\n#define SV_DEVICES_PER_PORT 2\n\nint\tsv_mixer_set_port;\nstatic void sv_init_mixer;\nstatic const struct {\n  u_int8_t   l_port;\n  u_int8_t   r_port;\n  u_int8_t   mask;\n  u_int8_t   class;\n  const char *audio;\n} ports[] = {\n  { SV_LEFT_AUX1_INPUT_CONTROL, SV_RIGHT_AUX1_INPUT_CONTROL, SV_AUX1_MASK,\n    SV_INPUT_CLASS, \"aux1\" },\n  { SV_LEFT_CD_INPUT_CONTROL, SV_RIGHT_CD_INPUT_CONTROL, SV_CD_MASK, \n    SV_INPUT_CLASS, AudioNcd },\n  { SV_LEFT_LINE_IN_INPUT_CONTROL, SV_RIGHT_LINE_IN_INPUT_CONTROL, SV_LINE_IN_MASK,\n    SV_INPUT_CLASS, AudioNline },\n  { SV_MIC_INPUT_CONTROL, 0, SV_MIC_MASK, SV_INPUT_CLASS, AudioNmicrophone },\n  { SV_LEFT_SYNTH_INPUT_CONTROL, SV_RIGHT_SYNTH_INPUT_CONTROL, \n    SV_SYNTH_MASK, SV_INPUT_CLASS, AudioNfmsynth },\n  { SV_LEFT_AUX2_INPUT_CONTROL, SV_RIGHT_AUX2_INPUT_CONTROL, SV_AUX2_MASK,\n    SV_INPUT_CLASS, \"aux2\" },\n  { SV_LEFT_PCM_INPUT_CONTROL, SV_RIGHT_PCM_INPUT_CONTROL, SV_PCM_MASK,\n    SV_INPUT_CLASS, AudioNdac },\n  { SV_LEFT_MIXER_OUTPUT_CONTROL, SV_RIGHT_MIXER_OUTPUT_CONTROL, \n    SV_MIXER_OUT_MASK, SV_OUTPUT_CLASS, AudioNmaster }\n};\n\nstatic void\nsv_init_mixer(sc)\n     struct sv_softc *sc;\n{\n  mixer_ctrl_t cp;\n  int idx;\n\n  cp.type = AUDIO_MIXER_ENUM;\n  cp.dev = SV_SRS_MODE;\n  cp.un.ord = 0;\n\n  sv_mixer_set_port(sc, &cp);\n\n  for (idx = 0; idx < ARRAY_SIZE(ports); idx++) {\n    if (ports[idx].audio == AudioNdac) {\n      cp.type = AUDIO_MIXER_ENUM;\n      cp.dev = SV_FIRST_MIXER + idx * SV_DEVICES_PER_PORT + 1;\n      cp.un.ord = 0;\n      sv_mixer_set_port(sc, &cp);\n      break;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": %s\\n\"",
            "intrstr"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_AUDIO",
            "sv_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sv_read",
          "args": [
            "sc",
            "SV_CODEC_STATUS"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ u_int8_t sv_read",
            "static __inline__ u_int8_t sv_read_indirect",
            "static __inline__ void sv_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sv_write",
          "args": [
            "sc",
            "SV_CODEC_INTMASK",
            "reg"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "sv_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "238-260",
          "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void sv_write",
            "static __inline__ void sv_write_indirect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\n\nstatic __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"reg: %x\\n\", sv_read(sc, SV_CODEC_CONTROL))"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "50"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "csr | PCI_COMMAND_MASTER_ENABLE/* | PCI_COMMAND_IO_ENABLE | PCI_COMMAND_PARITY_ENABLE */"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "SV_DMAC_CONFIG_OFF",
            "dmaio | dmareg | SV_DMA_CHANNEL_ENABLE"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "SV_DMAC_CONFIG_OFF",
            "dmareg & ~SV_DMA_CHANNEL_ENABLE"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "dmaio",
            "iosize",
            "0",
            "&sc->sc_dmac_ioh"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "SV_DMAC_CONFIG_OFF"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "SV_DMAA_CONFIG_OFF",
            "dmaio | dmareg | \n\t\t   SV_DMA_CHANNEL_ENABLE | SV_DMAA_EXTENDED_ADDR"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "SV_DMAA_CONFIG_OFF",
            "0"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "dmaio",
            "iosize",
            "0",
            "&sc->sc_dmaa_ioh"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "SV_DMAA_CONFIG_OFF"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "iobase",
            "iosize",
            "0",
            "&sc->sc_ioh"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "SV_ENHANCED_PORTBASE_SLOT",
            "&iobase",
            "&iosize"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tsv_attach;\nint\tsv_intr;\nstruct audio_hw_if sv_hw_if = {\n\tsv_open,\n\tsv_close,\n\tNULL,\n\tsv_query_encoding,\n\tsv_set_params,\n\tsv_round_blocksize,\n\tNULL,\n\tsv_dma_init_output,\n\tsv_dma_init_input,\n\tsv_dma_output,\n\tsv_dma_input,\n\tsv_halt_out_dma,\n\tsv_halt_in_dma,\n\tNULL,\n\tsv_getdev,\n\tNULL,\n\tsv_mixer_set_port,\n\tsv_mixer_get_port,\n\tsv_query_devinfo,\n\tsv_malloc,\n\tsv_free,\n\tsv_round,\n\tsv_mappage,\n\tsv_get_props,\n\tNULL,\n\tNULL\n};\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\nstatic void sv_init_mixer;\n\nstatic void\nsv_attach(parent, self, aux)\n     struct device *parent, *self;\n     void *aux;\n\n{\n  struct sv_softc *sc = (struct sv_softc *)self;\n  struct pci_attach_args *pa = aux;\n  pci_chipset_tag_t pc = pa->pa_pc;\n  pci_intr_handle_t ih;\n  bus_addr_t iobase;\n  bus_size_t iosize;\n  pcireg_t csr;\n  char const *intrstr;\n  u_int32_t  dmareg, dmaio; \n  u_int8_t   reg;\n\n  sc->sc_pci_chipset_tag = pc;\n  sc->sc_pci_tag = pa->pa_tag;\n\n  /* Map the enhanced port only */\n  if (pci_io_find(pc, pa->pa_tag, SV_ENHANCED_PORTBASE_SLOT, \n\t\t  &iobase, &iosize)) {\n    printf (\": Couldn't find enhanced synth I/O range\\n\");\n    return;\n  }\n\n  if (bus_space_map(sc->sc_iot, iobase, iosize, 0, &sc->sc_ioh)) {\n      printf(\": can't map i/o space\\n\");\n      return;\n  }\n\n  sc->sc_dmatag = pa->pa_dmat;\n\n  dmareg = pci_conf_read(pa->pa_pc, pa->pa_tag, SV_DMAA_CONFIG_OFF);\n  iosize = 0x10;\n  dmaio =  dmareg & ~(iosize - 1);\n  \n  if (dmaio) {\n    dmareg &= 0xF;\n    \n    if (bus_space_map(sc->sc_iot, dmaio, iosize, 0, &sc->sc_dmaa_ioh)) {\n      /* The BIOS assigned us some bad I/O address! Make sure to clear\n         and disable this DMA before we enable the device */\n      pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAA_CONFIG_OFF, 0);\n\n      printf (\": can't map DMA i/o space\\n\");\n      goto enable;\n    }\n\n    pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAA_CONFIG_OFF,\n\t\t   dmaio | dmareg | \n\t\t   SV_DMA_CHANNEL_ENABLE | SV_DMAA_EXTENDED_ADDR);\n    sc->sc_dma_configured |= SV_DMAA_CONFIGURED;\n  }\n\n  dmareg = pci_conf_read(pa->pa_pc, pa->pa_tag, SV_DMAC_CONFIG_OFF);\n  dmaio = dmareg & ~(iosize - 1);\n  if (dmaio) {\n    dmareg &= 0xF;\n\n    if (bus_space_map(sc->sc_iot, dmaio, iosize, 0, &sc->sc_dmac_ioh)) {\n      /* The BIOS assigned us some bad I/O address! Make sure to clear\n         and disable this DMA before we enable the device */\n      pci_conf_write (pa->pa_pc, pa->pa_tag, SV_DMAC_CONFIG_OFF, \n\t\t      dmareg & ~SV_DMA_CHANNEL_ENABLE); \n      printf (\": can't map DMA i/o space\\n\");\n      goto enable;\n    }\n\n    pci_conf_write(pa->pa_pc, pa->pa_tag, SV_DMAC_CONFIG_OFF, \n\t\t   dmaio | dmareg | SV_DMA_CHANNEL_ENABLE);\n    sc->sc_dma_configured |= SV_DMAC_CONFIGURED;\n  }\n\n  /* Enable the device. */\n enable:\n  csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n  pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t csr | PCI_COMMAND_MASTER_ENABLE \n\t\t /* | PCI_COMMAND_IO_ENABLE | PCI_COMMAND_PARITY_ENABLE */);\n\n  sv_write_indirect(sc, SV_ANALOG_POWER_DOWN_CONTROL, 0);\n  sv_write_indirect(sc, SV_DIGITAL_POWER_DOWN_CONTROL, 0);\n\n  /* initialize codec registers */\n  reg = sv_read(sc, SV_CODEC_CONTROL);\n  reg |= SV_CTL_RESET;\n  sv_write(sc, SV_CODEC_CONTROL, reg);\n  delay(50);\n\n  reg = sv_read(sc, SV_CODEC_CONTROL);\n  reg &= ~SV_CTL_RESET;\n  reg |= SV_CTL_INTA | SV_CTL_ENHANCED;\n\n  /* This write clears the reset */\n  sv_write(sc, SV_CODEC_CONTROL, reg);\n  delay(50);\n\n  /* This write actually shoves the new values in */\n  sv_write(sc, SV_CODEC_CONTROL, reg);\n\n  DPRINTF ((\"reg: %x\\n\", sv_read(sc, SV_CODEC_CONTROL)));\n\n  /* Enable DMA interrupts */\n  reg = sv_read(sc, SV_CODEC_INTMASK);\n  reg &= ~(SV_INTMASK_DMAA | SV_INTMASK_DMAC);\n  reg |= SV_INTMASK_UD | SV_INTMASK_SINT | SV_INTMASK_MIDI;\n  sv_write(sc, SV_CODEC_INTMASK, reg);\n\n  sv_read(sc, SV_CODEC_STATUS);\n\n  sc->sc_trd = 0;\n  sc->sc_enable = 0;\n\n  /* Map and establish the interrupt. */\n  if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t   pa->pa_intrline, &ih)) {\n    printf(\": couldn't map interrupt\\n\");\n    return;\n  }\n  intrstr = pci_intr_string(pc, ih);\n  sc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, sv_intr, sc,\n\t\t\t\t sc->sc_dev.dv_xname);\n  if (sc->sc_ih == NULL) {\n    printf(\": couldn't establish interrupt\");\n    if (intrstr != NULL)\n      printf(\" at %s\", intrstr);\n    printf(\"\\n\");\n    return;\n  }\n  printf(\": %s\\n\", intrstr);\n\n  sv_init_mixer(sc);\n\n  audio_attach_mi(&sv_hw_if, sc, &sc->sc_dev);\n}"
  },
  {
    "function_name": "sv_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "262-274",
    "snippet": "int\nsv_match(parent, match, aux)\n     struct device *parent;\n     void *match, *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_S3 &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_S3_SONICVIBES)\n\t  return (1);\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nsv_match(parent, match, aux)\n     struct device *parent;\n     void *match, *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_S3 &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_S3_SONICVIBES)\n\t  return (1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "sv_write_indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "238-260",
    "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline__ void sv_write",
      "static __inline__ void sv_write_indirect"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_write",
          "args": [
            "sc",
            "SV_CODEC_IDATA",
            "val"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "sv_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "238-260",
          "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Invalid register\\n\""
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\n\nstatic __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}"
  },
  {
    "function_name": "sv_read_indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "222-236",
    "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline__ u_int8_t sv_read",
      "static __inline__ u_int8_t sv_read_indirect",
      "static __inline__ void sv_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sv_read",
          "args": [
            "sc",
            "SV_CODEC_IDATA"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "sv_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "222-236",
          "snippet": "static __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sv_write",
          "args": [
            "sc",
            "SV_CODEC_IADDR",
            "iaddr"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "sv_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
          "lines": "238-260",
          "snippet": "static __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/s3_617.h>",
            "#include <dev/ic/i8237reg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void sv_write",
            "static __inline__ void sv_write_indirect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\nstatic __inline__ void sv_write_indirect;\n\nstatic __inline__ void\nsv_write_indirect (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n{\n    u_int8_t iaddr = 0;\n#ifdef DIAGNOSTIC\n    if (reg > 0x3f) {\n      printf (\"Invalid register\\n\");\n      return;\n    }\n#endif\n\n    if (reg == SV_DMA_DATA_FORMAT)\n      iaddr |= SV_IADDR_MCE;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n    sv_write (sc, SV_CODEC_IDATA, val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\nstatic __inline__ u_int8_t sv_read_indirect;\nstatic __inline__ void sv_write;\n\nstatic __inline__ u_int8_t\nsv_read_indirect (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n{\n    u_int8_t iaddr = 0;\n\n    if (sc->sc_trd > 0)\n      iaddr |= SV_IADDR_TRD;\n\n    iaddr |= (reg & SV_IADDR_MASK);\n    sv_write (sc, SV_CODEC_IADDR, iaddr);\n\n    return (sv_read(sc, SV_CODEC_IDATA));\n}"
  },
  {
    "function_name": "sv_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "213-220",
    "snippet": "static __inline__ u_int8_t\nsv_read (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n     \n{\n  return (bus_space_read_1(sc->sc_iot, sc->sc_ioh, reg));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline__ u_int8_t sv_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "reg"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ u_int8_t sv_read;\n\nstatic __inline__ u_int8_t\nsv_read (sc, reg)\n     struct sv_softc *sc;\n     u_int8_t reg;\n     \n{\n  return (bus_space_read_1(sc->sc_iot, sc->sc_ioh, reg));\n}"
  },
  {
    "function_name": "sv_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/sv.c",
    "lines": "204-211",
    "snippet": "static __inline__ void\nsv_write (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n     \n{\n  bus_space_write_1(sc->sc_iot, sc->sc_ioh, reg, val);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/s3_617.h>",
      "#include <dev/ic/i8237reg.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline__ void sv_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "reg",
            "val"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/s3_617.h>\n#include <dev/ic/i8237reg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ void sv_write;\n\nstatic __inline__ void\nsv_write (sc, reg, val)\n     struct sv_softc *sc;\n     u_int8_t reg, val;\n     \n{\n  bus_space_write_1(sc->sc_iot, sc->sc_ioh, reg, val);\n}"
  }
]